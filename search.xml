<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux中修改终端登录欢迎界面</title>
    <url>/2024/06/07/Linux%E4%B8%AD%E4%BF%AE%E6%94%B9%E7%BB%88%E7%AB%AF%E7%99%BB%E5%BD%95%E6%AC%A2%E8%BF%8E%E7%95%8C%E9%9D%A2/</url>
    <content><![CDATA[<h3 id="终端登陆前欢迎界面"><a href="#终端登陆前欢迎界面" class="headerlink" title="终端登陆前欢迎界面"></a>终端登陆前欢迎界面</h3><ul>
<li>  修改/etc/issue</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat /etc/issue</span><br><span class="line">Authorized users only. All activities may be monitored and reported.</span><br></pre></td></tr></table></figure>
<span id="more"></span>


<h3 id="远程终端登录后欢迎信息"><a href="#远程终端登录后欢迎信息" class="headerlink" title="远程终端登录后欢迎信息"></a>远程终端登录后欢迎信息</h3><h4 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h4><ul>
<li>  修改/etc/motd</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat /etc/motd</span><br><span class="line"></span><br><span class="line">Authorized users only. All activities may be monitored and reported.</span><br></pre></td></tr></table></figure>

<h4 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h4><ul>
<li>  Ubuntu中没有/etc/motd</li>
<li>  相关欢迎信息存储在/etc/update-mod.d/中的文件中</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ll /etc/update-motd.d/</span><br><span class="line">total 20</span><br><span class="line">-rwxr-xr-x. 1 root root  222 May 24  2023 00-logo</span><br><span class="line">-rwxr-xr-x. 1 root root  309 May 24  2023 10-banner</span><br><span class="line">-rwxr-xr-x. 1 root root  745 May 24  2023 20-sysinfo</span><br><span class="line">-rwxr-xr-x. 1 root root  495 May 24  2023 30-support</span><br><span class="line">-rwxr-xr-x. 1 root root 1454 May 24  2023 99-updates</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  00-logo</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@bclinux-corsica update-motd.d]# cat 00-logo </span><br><span class="line">#!/bin/sh</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line">#    00-logo - BCLinux logo</span><br><span class="line">#    Copyright (c) 2016 China Mobile</span><br><span class="line">#</span><br><span class="line">#    Authors: Haishuang Yan &lt;yanhaishuang@cmss.chinamobile.com&gt;</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">[ -f /etc/bigcloud/welcome/logo ] &amp;&amp;  /bin/cat /etc/bigcloud/welcome/logo</span><br><span class="line"># cat /etc/bigcloud/welcome/logo</span><br><span class="line"> ____  _        ____ _                 _</span><br><span class="line">| __ )(_) __ _ / ___| | ___  _   _  __| |</span><br><span class="line">|  _ \| |/ _` | |   | |/ _ \| | | |/ _` |</span><br><span class="line">| |_) | | (_| | |___| | (_) | |_| | (_| |</span><br><span class="line">|____/|_|\__, |\____|_|\___/ \__,_|\__,_|</span><br><span class="line">         |___/</span><br><span class="line"></span><br><span class="line"> _____       _                       _            _     _</span><br><span class="line">| ____|_ __ | |_ ___ _ __ _ __  _ __(_)___  ___  | |   (_)_ __  _   ___  __</span><br><span class="line">|  _| | &#x27;_ \| __/ _ \ &#x27;__| &#x27;_ \| &#x27;__| / __|/ _ \ | |   | | &#x27;_ \| | | \ \/ /</span><br><span class="line">| |___| | | | ||  __/ |  | |_) | |  | \__ \  __/ | |___| | | | | |_| |&gt;  &lt;</span><br><span class="line">|_____|_| |_|\__\___|_|  | .__/|_|  |_|___/\___| |_____|_|_| |_|\__,_/_/\_\</span><br><span class="line">                         |_|</span><br><span class="line"></span><br><span class="line"> _____             _____       _              ____   ____      _  ___     _   _   _ </span><br><span class="line">|  ___|__  _ __   | ____|_   _| | ___ _ __   |___ \ |___ \    / |/ _ \   | | | | / |</span><br><span class="line">| |_ / _ \| &#x27;__|  |  _| | | | | |/ _ \ &#x27;__|    __) |  __) |   | | | | |  | | | | | |</span><br><span class="line">|  _| (_) | |     | |__ | |_| | |  __/ |      / __/| / __/| _ | | |_| |  | |_| | | |</span><br><span class="line">|_|  \___/|_|     |_____|\__,_|_|\___|_|     |_____||_____|(_)|_|\___/    \__,_| |_|</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  10-banner</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#</span><br><span class="line">#    10-banner - generate the banner information</span><br><span class="line">#    Copyright (c) 2016 China Mobile</span><br><span class="line">#</span><br><span class="line">#    Authors: Haishuang Yan &lt;yanhaishuang@cmss.chinamobile.com&gt;</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">printf &quot;\n&quot;</span><br><span class="line">printf &quot;Welcome to %s (%s %s %s)\n\n&quot;  &quot;BigCloud Enterprise Linux For Euler 22.10U1&quot; &quot;$(uname -o)&quot; &quot;$(uname -r)&quot; &quot;$(uname -m)&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  20-sysinfo</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#</span><br><span class="line">#    20-sysinfo - generate the system information</span><br><span class="line">#    Copyright (c) 2016 China Mobile</span><br><span class="line">#</span><br><span class="line">#    Authors: Haishuang Yan &lt;yanhaishuang@cmss.chinamobile.com&gt;</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">printf &quot;System information as of %s\n&quot; &quot;$(/bin/date)&quot;</span><br><span class="line">printf &quot;\n&quot;</span><br><span class="line">printf &quot;  * System CPU load:\t%-20s&quot;   &quot;$(cat /proc/loadavg | cut -d&#x27; &#x27; -f1-3)&quot;</span><br><span class="line">printf &quot;  * System   uptime:\t%-20s\n&quot; &quot;$(uptime | cut -d&#x27;,&#x27; -f1)&quot;</span><br><span class="line">printf &quot;  * Active sessions:\t%-20s&quot;  &quot;$(w | tail -n +3 | wc -l)&quot;</span><br><span class="line">printf &quot;  * Memory    usage:\t %s / %s MB\n&quot; \</span><br><span class="line">         $(cat /proc/meminfo | grep MemFree | awk &#123;&#x27;print int($2/1000)&#x27;&#125;) \</span><br><span class="line">                $(cat /proc/meminfo | grep MemTotal | awk &#123;&#x27;print int($2/1000)&#x27;&#125;)</span><br><span class="line">printf &quot;  * Processes count:\t%s\n&quot;  &quot;$(cat /proc/loadavg | cut -d&#x27;/&#x27; -f2| cut -d&#x27; &#x27; -f1)&quot;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<ul>
<li>  30-support</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#</span><br><span class="line">#    30-support - generate the support information</span><br><span class="line">#    Copyright (c) 2016 China Mobile</span><br><span class="line">#</span><br><span class="line">#    Authors: Haishuang Yan &lt;yanhaishuang@cmss.chinamobile.com&gt;</span><br><span class="line">#</span><br><span class="line">FORUM=&quot;https://ecloud.10086.cn/api/query/developer/user/home.html&quot;</span><br><span class="line"></span><br><span class="line">printf &quot;\n&quot;</span><br><span class="line">#printf &quot;  * Documentation:\n\t%s\n&quot;   &quot;$DOCS&quot;</span><br><span class="line">#printf &quot;  * Get Support  :\n\t%s\n&quot;   &quot;$SUPPORT&quot;</span><br><span class="line">#printf &quot;  * Ask Questions:\n\t%s\n&quot;   &quot;$FORUM&quot;</span><br><span class="line">printf &quot;  * Contact US   :\n\t%s\n&quot;   &quot;MAIL : 4001100865@cmss.chinamobile.com / TEL : 4001-10086-5&quot;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  99-updates</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#</span><br><span class="line">#    30-updates - generate the updates information</span><br><span class="line">#    Copyright (c) 2016 China Mobile</span><br><span class="line">#</span><br><span class="line">#    Authors: Haishuang Yan &lt;yanhaishuang@cmss.chinamobile.com&gt;</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">#printf &quot;\n&quot;</span><br><span class="line">#UPDATES_COUNT=$(yum check-update --quiet | grep -v &quot;^$&quot; | wc -l)</span><br><span class="line">#UPDATES_SECURITY=$(yum check-update --security --quiet | grep -v &quot;^$&quot; | wc -l)</span><br><span class="line">#if [[ $UPDATES_COUNT -gt 0 ]]; then</span><br><span class="line">#    printf &quot;%s packages can be updated.\n&quot; $&#123;UPDATES_COUNT&#125;</span><br><span class="line">#    printf &quot;%s updates are security updates.\n&quot; $&#123;UPDATES_SECURITY&#125;</span><br><span class="line">#    printf &quot;type &#x27;yum check-update --security&#x27; to see details.\n&quot;</span><br><span class="line">#fi</span><br><span class="line"></span><br><span class="line">[ ! -d /etc/bigcloud/security ] &amp;&amp; mkdir -p /etc/bigcloud/security</span><br><span class="line"></span><br><span class="line">updates=/etc/bigcloud/security/updates</span><br><span class="line">check_security_updates() &#123;</span><br><span class="line">	/usr/bin/check-security-updates &gt; /tmp/security_updates</span><br><span class="line">	if [ $? -eq 0 ]; then</span><br><span class="line">		cp /tmp/security_updates &quot;$updates&quot;</span><br><span class="line">		rm -rf /tmp/security_updates</span><br><span class="line">	fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if [ -f &quot;$updates&quot; ]; then</span><br><span class="line">        # Updates exists, see if it&#x27;s expired</span><br><span class="line">        now=$(date +%s)</span><br><span class="line">        lastrun=$(stat -c %Y &quot;$updates&quot;) 2&gt;/dev/null || lastrun=0</span><br><span class="line">        expiration=$(expr $lastrun + 86400)</span><br><span class="line">        if [ $now -ge $expiration ]; then</span><br><span class="line">                # Older than 1 day old, so update in the background</span><br><span class="line">                check_security_updates &amp;</span><br><span class="line">        elif [ -s &quot;$updates&quot; ]; then</span><br><span class="line">                # Less than 1 day old, and non-empty, so display now</span><br><span class="line">                cat &quot;$updates&quot;</span><br><span class="line">        fi</span><br><span class="line">else</span><br><span class="line">        # No cache at all, so update in the background</span><br><span class="line">	check_security_updates &amp;</span><br><span class="line">fi</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  新建欢迎脚本</li>
<li>  在00-header文件末尾添加cat /etc/update-motd.d/welcom-test</li>
<li>  然后执行：run-parts /etc/update-motd.d/</li>
</ul>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>rm回收站</title>
    <url>/2024/06/03/rm%E5%9B%9E%E6%94%B6%E7%AB%99/</url>
    <content><![CDATA[<blockquote>
<p>一个方案就是重定向 rm 命令以嫁接为 mv 命令，相当于给 Linux 系统定制了一个回收站。</p>
</blockquote>
<span id="more"></span>

<p>实现方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">### 重定义rm命令 ### </span><br><span class="line"> </span><br><span class="line"># 定义回收站目录 </span><br><span class="line">trash_path=&#x27;/local/.trash&#x27;</span><br><span class="line"> </span><br><span class="line"># 判断 $trash_path 定义的文件是否存在，如果不存在，那么就创建 $trash_path.</span><br><span class="line">if [ ! -d $trash_path ]; then</span><br><span class="line">        mkdir -p $trash_path</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># 定义别名：使用 rm 就调用 trash </span><br><span class="line">alias rm=trash </span><br><span class="line"> </span><br><span class="line"># 使用 rl 就调用 &#x27;ls $trash_path&#x27;</span><br><span class="line">alias rl=&#x27;ls $trash_path&#x27;</span><br><span class="line"> </span><br><span class="line"># 使用 unrm 就调用 restorefile，需要在删除目录的父目录下执行 </span><br><span class="line">alias unrm=restorefile</span><br><span class="line"> </span><br><span class="line"># 使用 rmtrash 就调用 claearteash </span><br><span class="line">alias rmtrash=cleartrash</span><br><span class="line"> </span><br><span class="line"># 恢复文件的函数 </span><br><span class="line">restorefile() &#123;</span><br><span class="line">        mv -i $trash_path/$@ ./</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"># 删除文件的函数 </span><br><span class="line">trash() &#123;</span><br><span class="line">        mv $@ $trash_path/</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"># 清空回收站的函数 </span><br><span class="line">cleartrash() &#123;</span><br><span class="line">        read -p &quot;Are you sure about emptying the recycle bin?[y/n]&quot; confirm</span><br><span class="line">        [ $confirm == &#x27;y&#x27; ] || [ $confirm == &#x27;Y&#x27; ] &amp;&amp; /bin/rm -rf $trash_path/*</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后将上述脚本写入 /etc/profile，并立即执行命令 source /etc/profile 即刻生效。</p>
<p>这个脚本定义了几个命令：</p>
<ul>
<li>  rl：查看回收站下的文件。</li>
<li>  unrm 文件名或目录：恢复到当前的路径下。</li>
<li>  rmtrash：清空回收站，不过会友好提示。</li>
</ul>
<p>执行 rm 不会真正删除，而是使用 mv 移动到我们指定的回收站。实在真的想删除可以 /bin/rm 来进行删除。</p>
<p>另外，需要注意的是，之前 rm 指令的一些参数可能不再使用，因为 rm 现在其实是 mv 了。</p>
<p>使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># touch hoxistest </span><br><span class="line"># touch 1 </span><br><span class="line"># mkdir haha </span><br><span class="line"># ls </span><br><span class="line">1 haha hoxistest </span><br><span class="line"># rm 1 </span><br><span class="line"># ls </span><br><span class="line">haha hoxistest </span><br><span class="line"> </span><br><span class="line"># 查看回收站文件 </span><br><span class="line"># rl </span><br><span class="line">1 myftp1 </span><br><span class="line"> </span><br><span class="line"># 恢复已删除文件 </span><br><span class="line"># unrm 1 </span><br><span class="line">[root@CESHI\-CLM-10\-254\-4\-48 test\]# ls </span><br><span class="line">1 haha hoxistest </span><br><span class="line"> </span><br><span class="line"># rm haha/ </span><br><span class="line"># rm hoxistest </span><br><span class="line"># rl </span><br><span class="line">haha hoxistest </span><br><span class="line"> </span><br><span class="line"># 情况回收站 </span><br><span class="line"># rmtrash </span><br><span class="line">确定要清空回收站吗?\[y/n\]y </span><br><span class="line"># rl </span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>trash</tag>
      </tags>
  </entry>
  <entry>
    <title>ovs命令汇总</title>
    <url>/2024/05/24/ovs%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h3 id="设备类"><a href="#设备类" class="headerlink" title="设备类"></a>设备类</h3><p><strong>查看当前ovs接管设备</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ovs-vsctl show</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p><strong>添加pccu端口</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ovs-vsctl add-port br-ext dpdk0 -- <span class="built_in">set</span> Interface dpdk0 <span class="built_in">type</span>=dpdk options:dpdk-devargs=0000:01:00.1 options:n_txq=8 options:n_rxq=8 options:n_rxq_desc=2048 options:n_txq_desc=2048 ofport_request=1</span><br></pre></td></tr></table></figure>

<h3 id="流表类"><a href="#流表类" class="headerlink" title="流表类"></a>流表类</h3><h4 id="流表配置"><a href="#流表配置" class="headerlink" title="流表配置"></a>流表配置</h4><p>通适配置，比如：端口net7 ↔ 端口dpdk0</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ovs-ofctl add-flow br-ext in_port=dpdk0,action=output:net7</span><br><span class="line">ovs-ofctl add-flow br-ext in_port=net7,action=output:dpdk0</span><br></pre></td></tr></table></figure>

<p>精确配置，比如：匹配mac，ip等报文特征</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">##匹配源mac</span></span><br><span class="line">ovs-ofctl add-flow br-ext in_port=net0,dl_src=52:54:00:00:96:85,action=output:dpdk0</span><br><span class="line">ovs-ofctl add-flow br-ext in_port=dpdk0,dl_src=04:02:03:04:05:01,action=output:net0</span><br><span class="line"></span><br><span class="line"><span class="comment">##匹配目的mac</span></span><br><span class="line">ovs-ofctl add-flow br-ext in_port=net0,dl_dst=52:54:00:00:96:85,action=output:dpdk0</span><br><span class="line">ovs-ofctl add-flow br-ext in_port=dpdk0,dl_dst=04:02:03:04:05:01,action=output:net0</span><br><span class="line"></span><br><span class="line"><span class="comment">##匹配源mac+源IP+目的IP</span></span><br><span class="line">ovs-ofctl add-flow br-ext in_port=net7,dl_src=52:54:00:00:96:92,nw_src=7.7.7.3/32,nw_dst=7.7.7.2/32,action=output:dpdk0</span><br></pre></td></tr></table></figure>

<h4 id="常用匹配字段"><a href="#常用匹配字段" class="headerlink" title="常用匹配字段"></a>常用匹配字段</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">##数据包入口</span></span><br><span class="line">in_port =&lt;port&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">##数据包源mac/目的mac</span></span><br><span class="line">dl_src/dl_dst=&lt;mac&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">##数据包源IP/目的IP</span></span><br><span class="line">nw_src/nw_dst=&lt;ip&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">##以太网协议类型</span></span><br><span class="line">dl_type=&lt;0xxxx&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">##nw_proto和dl_type字段协同使用，匹配协议</span></span><br><span class="line">nw_proto=&lt;num&gt;</span><br></pre></td></tr></table></figure>

<p><strong>常用协议方式如下</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip</span><br><span class="line">dl_type=0x0800</span><br><span class="line"></span><br><span class="line">ipv6</span><br><span class="line">dl_type=0x86dd</span><br><span class="line"></span><br><span class="line">icmp</span><br><span class="line">dl_type=0x0800,nw_proto=1</span><br><span class="line"></span><br><span class="line">tcp</span><br><span class="line">dl_type=0x0800,nw_proto=6</span><br><span class="line"></span><br><span class="line">udp</span><br><span class="line">dl_type=0x0800,nw_proto=17</span><br><span class="line"></span><br><span class="line">arp</span><br><span class="line">dl_type=0x0806</span><br><span class="line"></span><br><span class="line">rarp</span><br><span class="line">dl_type=0x8035</span><br></pre></td></tr></table></figure>

<p><strong>匹配数据包vlan</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dl_vlan=&lt;vlan&gt;</span><br></pre></td></tr></table></figure>

<h4 id="动作执行字段"><a href="#动作执行字段" class="headerlink" title="动作执行字段"></a>动作执行字段</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">##数据包从port接口发送</span></span><br><span class="line">output:port</span><br><span class="line"></span><br><span class="line"><span class="comment">##正常上送协议栈处理</span></span><br><span class="line">normal</span><br><span class="line"></span><br><span class="line"><span class="comment">##丢弃数据包</span></span><br><span class="line">drop</span><br><span class="line"></span><br><span class="line"><span class="comment">##转发到其他所有接口</span></span><br><span class="line">all</span><br></pre></td></tr></table></figure>

<h4 id="查看流表"><a href="#查看流表" class="headerlink" title="查看流表"></a>查看流表</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ovs-ofctl dump-flows br-ext</span><br></pre></td></tr></table></figure>

<h4 id="删除流表"><a href="#删除流表" class="headerlink" title="删除流表"></a>删除流表</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">##删除br-ext下所有流表</span></span><br><span class="line">ovs-ofctl del-flows br-ext</span><br><span class="line"></span><br><span class="line"><span class="comment">##删除br-ext下 inport为dpdk0的流表，即删除匹配项对应流表</span></span><br><span class="line">ovs-ofctl del-flows br-ext in_port=dpdk0</span><br></pre></td></tr></table></figure>

<h3 id="统计类"><a href="#统计类" class="headerlink" title="统计类"></a>统计类</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">##查看当前配置流表匹配情况</span></span><br><span class="line">ovs-ofctl dump-flows br-ext</span><br><span class="line"></span><br><span class="line"><span class="comment">##查看流表</span></span><br><span class="line">ovs-appctl bridge/dump-flows  --offload-stats br-ext</span><br><span class="line"></span><br><span class="line"><span class="comment">##查看网桥br-ext各端口收发包统计</span></span><br><span class="line">ovs-ofctl dump-ports br-ext</span><br><span class="line"></span><br><span class="line"><span class="comment">##查看流表报文统计(packets:11为慢速路径统计,dpe_packets:11为快速路径统计)</span></span><br><span class="line">ovs-appctl dpctl/dump-flows --names</span><br><span class="line"></span><br><span class="line"><span class="comment">##查看流表报文详细统计</span></span><br><span class="line">ovs-appctl dpctl/dump-flows -m</span><br><span class="line"></span><br><span class="line"><span class="comment">##查看卸载快表(关注字段offloaded:yes)</span></span><br><span class="line">ovs-appctl dpctl/dump-flows -m |grep <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##清除快表</span></span><br><span class="line">ovs-appctl revalidator/purge</span><br><span class="line"></span><br><span class="line"><span class="comment">##查看dpdk0端口详细信息</span></span><br><span class="line">ovs-vsctl list interface dpdk0</span><br><span class="line"></span><br><span class="line"><span class="comment">##查看dpdk0端口计数</span></span><br><span class="line">ovs-vsctl get interface dpdk0 statistics</span><br></pre></td></tr></table></figure>

<h3 id="日志类"><a href="#日志类" class="headerlink" title="日志类"></a>日志类</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">##放开ovs打印</span></span><br><span class="line">ovs-appctl vlog/disable-rate-limit</span><br><span class="line">ovs-appctl vlog/set netdev_offload_dpdk</span><br><span class="line">ovs-appctl vlog/set dpif_netdev</span><br><span class="line">ovs-appctl vlog/set conntrack</span><br><span class="line"></span><br><span class="line"><span class="comment">##查看ovs包含模块列表</span></span><br><span class="line">ovs-appctl vlog/list</span><br><span class="line"></span><br><span class="line"><span class="comment">##设置所有模块打印级别</span></span><br><span class="line">ovs-appctl vlog/set file:dbg</span><br><span class="line"></span><br><span class="line"><span class="comment">##设置netdev_dpdk模块打印级别</span></span><br><span class="line">ovs-appctl vlog/set netdev_dpdk:file:dbg</span><br><span class="line"></span><br><span class="line"><span class="comment">##查看jmnd log日志</span></span><br><span class="line">ovs-appctl vlog/set dpdk</span><br><span class="line">ovs-appctl dpdk/log-set lib.eal:debug pmd.net.jmnd.*:debug</span><br><span class="line"></span><br><span class="line"><span class="comment">##rxq绑核</span></span><br><span class="line"> ovs-vsctl <span class="built_in">set</span> Interface bm_hostnet0 other_config:pmd-rxq-affinity=0:2,1:3 //rxq:cpu</span><br></pre></td></tr></table></figure>

<p>通路测试，前后端对应接口寻找方法如下：</p>
<ul>
<li>前端virtio-net口，可通过ethtool -i ensX命令查看设备bdf</li>
<li>后端登录诊断(ssh <a href="mailto:&#x72;&#x6f;&#x6f;&#116;&#64;&#x31;&#x32;&#55;&#x2e;&#49;">&#x72;&#x6f;&#x6f;&#116;&#64;&#x31;&#x32;&#55;&#x2e;&#49;</a> -p 60000)，进入msg_cmd模式，敲device list，可查看当前系统所有设备bdf，<br>即bdf可唯一对应前端一个设备</li>
<li>通过ovs-vsctl show查看当前ovs接管设备，可通过比对接口参数(主要通过iface=/tmp/sock0)，唯一可对应到上述第二步的一个设备，<br>即virtio_net口&lt;—&gt;ovs接口唯一确定</li>
</ul>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>ovs</tag>
      </tags>
  </entry>
  <entry>
    <title>iperf使用</title>
    <url>/2024/05/24/iperf%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="iperf3测试命令"><a href="#iperf3测试命令" class="headerlink" title="iperf3测试命令"></a>iperf3测试命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@xx:# iperf3 --help</span><br><span class="line">Usage: iperf3 [-s|-c host] [options]</span><br><span class="line">       iperf3 [-h|--help] [-v|--version]</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Server or Client:</span><br><span class="line">  -p, --port      #         server port to listen on/connect to</span><br><span class="line">  -f, --format   [kmgtKMGT] format to report: Kbits, Mbits, Gbits, Tbits</span><br><span class="line">  -i, --interval  #         seconds between periodic throughput reports</span><br><span class="line">  -F, --file name           xmit/recv the specified file</span><br><span class="line">  -A, --affinity n/n,m      set CPU affinity</span><br><span class="line">  -B, --bind      &lt;host&gt;    bind to the interface associated with the address &lt;host&gt;</span><br><span class="line">  -V, --verbose             more detailed output</span><br><span class="line">  -J, --json                output in JSON format</span><br><span class="line">  --logfile f               send output to a log file</span><br><span class="line">  --forceflush              force flushing output at every interval</span><br><span class="line">  -d, --debug               emit debugging output</span><br><span class="line">  -v, --version             show version information and quit</span><br><span class="line">  -h, --help                show this message and quit</span><br><span class="line">Server specific:</span><br><span class="line">  -s, --server              run in server mode</span><br><span class="line">  -D, --daemon             run the server as a daemon</span><br><span class="line">  -I, --pidfile file        write PID file</span><br><span class="line">  -1, --one-off             handle one client connection then exit</span><br><span class="line">  --rsa-private-key-path    path to the RSA private key used to decrypt</span><br><span class="line">                            authentication credentials</span><br><span class="line">  --authorized-users-path   path to the configuration file containing user</span><br><span class="line">                            credentials</span><br><span class="line">Client specific:</span><br><span class="line">  -c, --client    &lt;host&gt;    run in client mode, connecting to &lt;host&gt;</span><br><span class="line">  --sctp              use SCTP rather than TCP</span><br><span class="line">  -X, --xbind &lt;name&gt;        bind SCTP association to links</span><br><span class="line">  --nstreams      #         number of SCTP streams</span><br><span class="line">  -u, --udp                 use UDP rather than TCP</span><br><span class="line">  --connect-timeout #       timeout for control connection setup (ms)</span><br><span class="line">  -b, --bitrate #[KMG][/#]  target bitrate in bits/sec (0 for unlimited)</span><br><span class="line">                            (default 1 Mbit/sec for UDP, unlimited for TCP)</span><br><span class="line">                            (optional slash and packet count for burst mode)</span><br><span class="line">  --pacing-timer #[KMG]     set the timing for pacing, in microseconds (default 1000)</span><br><span class="line">  --fq-rate #[KMG]          enable fair-queuing based socket pacing in</span><br><span class="line">                            bits/sec (Linux only)</span><br><span class="line">  -t, --time      #         time in seconds to transmit for (default 10 secs)</span><br><span class="line">  -n, --bytes     #[KMG]    number of bytes to transmit (instead of -t)</span><br><span class="line">  -k, --blockcount #[KMG]   number of blocks (packets) to transmit (instead of -t or -n)</span><br><span class="line">  -l, --length    #[KMG]    length of buffer to read or write</span><br><span class="line">                            (default 128 KB for TCP, dynamic or 1460 for UDP)</span><br><span class="line">  --cport         &lt;port&gt;    bind to a specific client port (TCP and UDP, default: ephemeral port)</span><br><span class="line">  -P, --parallel  #         number of parallel client streams to run</span><br><span class="line">  -R, --reverse             run in reverse mode (server sends, client receives)</span><br><span class="line">  --bidir                   run in bidirectional mode.</span><br><span class="line">                            Client and server send and receive data.</span><br><span class="line">  -w, --window    #[KMG]    set window size / socket buffer size</span><br><span class="line">  -C, --congestion &lt;algo&gt;   set TCP congestion control algorithm (Linux and FreeBSD only)</span><br><span class="line">  -M, --set-mss   #         set TCP/SCTP maximum segment size (MTU - 40 bytes)</span><br><span class="line">  -N, --no-delay            set TCP/SCTP no delay, disabling Nagle&#x27;s Algorithm</span><br><span class="line">  -4, --version4            only use IPv4</span><br><span class="line">  -6, --version6            only use IPv6</span><br><span class="line">  -S, --tos N               set the IP type of service, 0-255.</span><br><span class="line">                            The usual prefixes for octal and hex can be used,</span><br><span class="line">                            i.e. 52, 064 and 0x34 all specify the same value.</span><br><span class="line">  --dscp N or --dscp val    set the IP dscp value, either 0-63 or symbolic.</span><br><span class="line">                            Numeric values can be specified in decimal,</span><br><span class="line">                            octal and hex (see --tos above).</span><br><span class="line">  -L, --flowlabel N         set the IPv6 flow label (only supported on Linux)</span><br><span class="line">  -Z, --zerocopy            use a &#x27;zero copy&#x27; method of sending data</span><br><span class="line">  -O, --omit N              omit the first n seconds</span><br><span class="line">  -T, --title str           prefix every output line with this string</span><br><span class="line">  --extra-data str          data string to include in client and server JSON</span><br><span class="line">  --get-server-output       get results from server</span><br><span class="line">  --udp-counters-64bit      use 64-bit counters in UDP test packets</span><br><span class="line">  --repeating-payload       use repeating pattern in payload, instead of</span><br><span class="line">                            randomized payload (like in iperf2)</span><br><span class="line">  --username                username for authentication</span><br><span class="line">  --rsa-public-key-path     path to the RSA public key used to encrypt</span><br><span class="line">                            authentication credentials</span><br><span class="line"> </span><br><span class="line">[KMG] indicates options that support a K/M/G suffix for kilo-, mega-, or giga-</span><br><span class="line"> </span><br><span class="line">iperf3 homepage at: https://software.es.net/iperf/</span><br><span class="line">Report bugs to:     https://github.com/esnet/iperf</span><br></pre></td></tr></table></figure>

<h4 id="iperf3测试命令示例"><a href="#iperf3测试命令示例" class="headerlink" title="iperf3测试命令示例"></a>iperf3测试命令示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##iperf server端(-s 启动server模式；-p 指定server端口号；-A指定绑核；-D后台运行)</span><br><span class="line">iperf3 -s -p 15000 -A 2 -D</span><br><span class="line"> </span><br><span class="line">##iperf clinet端(-c 启动client模式，后面紧跟连接的server端ip；-p 指定server端连接端口号；--cport指定client端源端口号；-P启动线程数；-t测试时间；-M 指定mss长度，udp测试使用-l指定)</span><br><span class="line">iperf3 -c 1.1.1.2 -p 15000 --cport 15000 -A 10 -P 1 -t 36000 -M 100 &gt; /dev/null &amp;</span><br></pre></td></tr></table></figure>

<h4 id="iperf3-结果分析"><a href="#iperf3-结果分析" class="headerlink" title="iperf3 结果分析"></a>iperf3 结果分析</h4><p><strong>udp测试结果分析</strong><br><img src="61e11abd927b51232fd4749d8b8ce5c063339a0a13fd30c04be54590b047f97d.png" alt="picture 1">  </p>
<ul>
<li>第一列 Interval：测试的时长</li>
<li>第二列 Transfer：在 Interval 时长里，传输的数据量</li>
<li>第三列 Bitrate：传输速率</li>
<li>第四列 Jitter：网络抖动，连续发送数据包时延差值的平均值，越小说明网络质量越好</li>
<li>第五列 Lost/Total Datagrams：丢失的数据包与发送的总数据包</li>
</ul>
<p><strong>tcp测试结果分析</strong><br><img src="5f7e502ff8046d757127e1c76a688191d165baf6035cc3099ee0b93e21d6f548.png" alt="picture 2">  </p>
<ul>
<li>第一列 Interval：测试的时长</li>
<li>第二列 Transfer：在 Interval 时长里，传输的数据量</li>
<li>第三列 Bitrate：传输速率</li>
<li>第四列 Retr：报文重传次数</li>
<li>第五列 Cwnd：拥塞窗口</li>
</ul>
<p><strong>性能数据统计</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sar -n ALL 1 1000 | egrep &quot;eno2|IFACE&quot;</span><br></pre></td></tr></table></figure>
<p><img src="8262bbc3838949d6197075f923f71883a20eaf644efe428283a901f340f41fbf.png" alt="picture 3">  </p>
<ul>
<li>IFACE：本地网卡接口的名称</li>
<li>rxpck/s：每秒钟接受的数据包</li>
<li>txpck/s：每秒钟发送的数据包</li>
<li>rxKB/s：每秒钟接受的数据包大小，单位为KB</li>
<li>txKB/s：每秒钟发送的数据包大小，单位为KB</li>
<li>rxcmp/s：每秒钟接受的压缩数据包</li>
<li>txcmp/s：每秒钟发送的压缩数据包</li>
<li>rxmcst/s：每秒钟接收的多播数据包</li>
</ul>
<h3 id="iperf3性能调优"><a href="#iperf3性能调优" class="headerlink" title="iperf3性能调优"></a>iperf3性能调优</h3><h4 id="网卡设置"><a href="#网卡设置" class="headerlink" title="网卡设置"></a>网卡设置</h4><p><strong>RX队列大小设置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ethtool -g ens6 ##查看队列深度</span><br><span class="line"></span><br><span class="line">ethtool -G ens6 rx 4096 ##修改队列深度</span><br></pre></td></tr></table></figure>
<p><img src="91aa41ea41f64434997ff6f6b6171978da16f0861e10968c48b2a18f7fc64102.png" alt="picture 4">  </p>
<p>根据需要修改队列深度等信息，例如：修改为8192队列深度实例 (版本路径/usr/share/jmnd/single/auto/xml/interface_module.xml)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;interface type=&#x27;vhostuser&#x27;&gt;</span><br><span class="line">        &lt;mac address=&#x27;&#123;INTERFACE_MAC&#125;&#x27;/&gt;</span><br><span class="line">      &lt;model type=&#x27;&#123;VIRTIO&#125;&#x27;/&gt;</span><br><span class="line">      &lt;driver queues=&#x27;&#123;INTERFACE_QUEUES&#125;&#x27; mq=&#x27;&#123;MQ_EN&#125;&#x27;  packed=&#x27;on&#x27; rx_queue_size=&#x27;8192&#x27; tx_queue_size=&#x27;8192&#x27;/&gt;</span><br><span class="line">      &lt;source type=&#x27;unix&#x27; path=&#x27;&#123;INTERFACE_NAME&#125;&#x27; mode=&#x27;server&#x27;/&gt;</span><br><span class="line">&lt;/interface&gt;</span><br></pre></td></tr></table></figure>

<p><strong>RX队列数量设置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ethtool -l ens6 ##查看队列数</span><br><span class="line"></span><br><span class="line">ethtool -L eth0 rx 8 ##将RX queue数量都设置为8</span><br><span class="line"></span><br><span class="line">ethtool -L eth0 combined 8 ##将RX queue和TX queue 数量都设置为8</span><br></pre></td></tr></table></figure>
<p><img src="4702bd070e7e31a961b062edd5a102c9aa92c934ac0666487a3186519fe4dea0.png" alt="picture 5">  </p>
<p>根据需要修改队列数目等信息，例如：修改为32 qp_num (版本路径/usr/share/jmnd/single/auto/config/base_config.json)</p>
<p><strong>offload配置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ethtool -K eth1 tso on</span><br><span class="line"></span><br><span class="line">ethtool -K eth1 gro on</span><br></pre></td></tr></table></figure>


<h4 id="pcie链路速率"><a href="#pcie链路速率" class="headerlink" title="pcie链路速率"></a>pcie链路速率</h4><p>lspci -tv<br><img src="9389779ec336b5e5a888f9d9e29a75c02f48c81e2498b931def056b4ba583a59.png" alt="picture 6">  </p>
<p>lspci -s 3c:01.0 -vvv ##确认pcie链路协商Gen5 X16模式<br><img src="9090347a15d0d6d2a1e78684745b644839107d1d4c3f2d888890f027f3d75731.png" alt="picture 7">  </p>
<h4 id="cpu亲核性"><a href="#cpu亲核性" class="headerlink" title="cpu亲核性"></a>cpu亲核性</h4><p>查询numa node<br><img src="fab2771f845bd245f79ec46b7c7e795f7aa75ff4d74451f3988d280a59adca43.png" alt="picture 8">  </p>
<p>lspci -s 47:00.0 -vvv | grep NUMA<br><img src="b0903ba3f571c9a3af287cfa659ab974026b310717208d2b788d6c0382581ee0.png" alt="picture 9">  </p>
<p>lscpu | grep NUMA<br><img src="7fe9154566eb5bef83784bf999bbc9450613120dbbc51982fabcfbcb1f16fb6e.png" alt="picture 10">  </p>
<h4 id="pcie-MPS-amp-MRRS"><a href="#pcie-MPS-amp-MRRS" class="headerlink" title="pcie MPS &amp; MRRS"></a>pcie MPS &amp; MRRS</h4><p><img src="45ed931416bb15b3e982fb3269fab046982f9a0ab3fbe6f5fe880d8c99bbb823.png" alt="picture 11">  </p>
<h4 id="cpu设置为高性能模式"><a href="#cpu设置为高性能模式" class="headerlink" title="cpu设置为高性能模式"></a>cpu设置为高性能模式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cpupower frequency-set -g performance</span><br></pre></td></tr></table></figure>

<h4 id="协议栈优化"><a href="#协议栈优化" class="headerlink" title="协议栈优化"></a>协议栈优化</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##修改内核套接字接受缓存区默认的大小</span><br><span class="line">echo 2147483647 &gt;/proc/sys/net/core/rmem_default</span><br><span class="line">##修改内核套接字接受缓存区最大值</span><br><span class="line">echo 2147483647 &gt;/proc/sys/net/core/rmem_max</span><br><span class="line">##关闭内核看门狗</span><br><span class="line">echo 0 &gt; /proc/sys/kernel/watchdog</span><br><span class="line">##设置 watchdog_thresh参数来定义发现softlockup以后系统panic的时间</span><br><span class="line">echo 0 &gt; /proc/sys/kernel/watchdog_thresh</span><br></pre></td></tr></table></figure>

<h4 id="XPS绑核"><a href="#XPS绑核" class="headerlink" title="XPS绑核"></a>XPS绑核</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#下指令是将指定net的全队列取消绑定在所有cpu上</span><br><span class="line">find /sys/class/net/ens14/queues/tx-* -type f -name &quot;xps_cpus&quot; -exec sh -c &#x27;echo &quot;ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff&quot; &gt;&gt; &#123;&#125;&#x27; \;</span><br><span class="line"></span><br><span class="line">#如需队列绑定指定CPU,如ens14的tx-0队列绑定cpu96：</span><br><span class="line">echo &quot;00000000,00000000,00000001,00000000,00000000,00000000&quot; &gt; /sys/class/net/ens14/queues/tx-0/xps_cpus</span><br></pre></td></tr></table></figure>

<h4 id="RPS绑核"><a href="#RPS绑核" class="headerlink" title="RPS绑核"></a>RPS绑核</h4><p>rps绑核方式和xps类似，文件名 有所差异：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;00000000,00000000,00000001,00000000,00000000,00000000&quot; &gt; /sys/class/net/ens14/queues/rx-0/rps_cpus</span><br></pre></td></tr></table></figure>

<h4 id="中断绑核"><a href="#中断绑核" class="headerlink" title="中断绑核"></a>中断绑核</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /proc/interrupts | grep virtio1 | grep output ##查找中断号，output表示tx队列中断，input表示rx队列中断，config表示配置中断</span><br></pre></td></tr></table></figure>
<p><img src="7787f79c6d5f071e4623aa3cfc95bbaa5e7ac3672a1a7aea70e5ece9a3787583.png" alt="picture 12">  </p>
<p>第一列为中断号，后续18列分别对应cpu 0 - cpu 17中断处理个数(查看cpu方式见上) ，最后一列为中断名称(output表示tx队列中断，input表示rx队列中断，config表示配置中断)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo $cpu_id &gt; /proc/irq/$interrupts/smp_affinity_list ##设置中断绑核</span><br></pre></td></tr></table></figure>

<h4 id="RFS配置"><a href="#RFS配置" class="headerlink" title="RFS配置"></a>RFS配置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo 32768 &gt; /proc/sys/net/core/rps_sock_flow_entries</span><br><span class="line"></span><br><span class="line">echo 1024 &gt; /sys/class/net/ens$i/queues/rx-&lt;n&gt;/rps_flow_cnt ## rps_sock flow_entries = rps_flow_cnt * N；其中，N为队列数量，每个设备是独立的。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>iperf</tag>
      </tags>
  </entry>
  <entry>
    <title>rpm 软件包安装位置</title>
    <url>/2024/05/13/rpm-%E8%BD%AF%E4%BB%B6%E5%8C%85%E5%AE%89%E8%A3%85%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="rpm-软件包安装位置"><a href="#rpm-软件包安装位置" class="headerlink" title="rpm 软件包安装位置"></a>rpm 软件包安装位置</h3><p>想要查看 rpm 软件包安装目录，需要先知道 rpm 软件包全名，然后使用<code>rpm -ql [pakageName]</code>命令，就能输出安装目录。</p>
<span id="more"></span>
<h3 id="rpm-软件包全名"><a href="#rpm-软件包全名" class="headerlink" title="rpm 软件包全名"></a>rpm 软件包全名</h3><p>以安装 nodejs 为例，并使用<code>rpm -qa|grep nodejs</code>查找 rpm 软件包全名。</p>
<ol>
<li>安装 nodejs 软件。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@centos ~]# yum install nodejs</span><br></pre></td></tr></table></figure>
</li>
<li>查找 rpm 软件包全名。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># nodejs 版本</span><br><span class="line">[root@centos ~]# node -v</span><br><span class="line">v6.17.1</span><br><span class="line"># rpm 包全名</span><br><span class="line">[root[@centos] ~]# rpm -qa|grep nodejs</span><br><span class="line">nodejs-6.17.1-1.el7.x86_64</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="rpm-软件包安装目录"><a href="#rpm-软件包安装目录" class="headerlink" title="rpm 软件包安装目录"></a>rpm 软件包安装目录</h3><p>使用<code>rpm -ql [pakageName]</code>查找输出安装目录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@centos ~]# rpm -ql nodejs-6.17.1-1.el7.x86_64</span><br><span class="line">/usr/bin/node</span><br><span class="line">/usr/lib/dtrace</span><br><span class="line">/usr/lib/dtrace/node.d</span><br><span class="line">/usr/lib/node_modules</span><br><span class="line">/usr/lib/rpm/fileattrs/nodejs_native.attr</span><br><span class="line">/usr/lib/rpm/nodejs_native.req</span><br><span class="line">/usr/share/doc/nodejs-6.17.1</span><br><span class="line">/usr/share/doc/nodejs-6.17.1/AUTHORS</span><br><span class="line">/usr/share/doc/nodejs-6.17.1/CHANGELOG.md</span><br><span class="line">/usr/share/doc/nodejs-6.17.1/COLLABORATOR_GUIDE.md</span><br><span class="line">/usr/share/doc/nodejs-6.17.1/GOVERNANCE.md</span><br><span class="line">/usr/share/doc/nodejs-6.17.1/README.md</span><br><span class="line">/usr/share/licenses/nodejs-6.17.1</span><br><span class="line">/usr/share/licenses/nodejs-6.17.1/LICENSE</span><br><span class="line">/usr/share/man/man1/node.1.gz</span><br><span class="line">/usr/share/node</span><br><span class="line">/usr/share/systemtap</span><br><span class="line">/usr/share/systemtap/tapset</span><br><span class="line">/usr/share/systemtap/tapset/node.stp</span><br></pre></td></tr></table></figure>


<p>到此，已获取 nodejs 安装目录。</p>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>rpm</tag>
      </tags>
  </entry>
  <entry>
    <title>Dockerfile 指令详解</title>
    <url>/2024/04/26/Dockerfile-%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h3 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a>FROM 指定基础镜像</h3><p><code>FROM</code> 指令用于指定其后构建新镜像所使用的基础镜像。<code>FROM </code>指令必是 <code>Dockerfile</code> 文件中的首条命令，启动构建流程后，<code>Docker</code> 将会基于该镜像构建新镜像，<code>FROM</code> 后的命令也会基于这个基础镜像。</p>
<span id="more"></span>
<p>FROM语法格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM &lt;image&gt;</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM &lt;image&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure>

<p>或</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM &lt;image&gt;:&lt;digest&gt;</span><br></pre></td></tr></table></figure>

<p>通过 FROM 指定的镜像，可以是任何有效的基础镜像。FROM 有以下限制：</p>
<ul>
<li>  FROM 必须 是 Dockerfile 中第一条非注释命令</li>
<li>  在一个 Dockerfile 文件中创建多个镜像时，FROM 可以多次出现。只需在每个新命令 FROM 之前，记录提交上次的镜像 ID。</li>
<li>  tag 或 digest 是可选的，如果不使用这两个值时，会使用 latest 版本的基础镜像</li>
</ul>
<h3 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h3><p>在镜像的构建过程中执行特定的命令，并生成一个中间镜像。格式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#shell格式</span><br><span class="line">RUN &lt;command&gt;</span><br><span class="line">#exec格式</span><br><span class="line">RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  RUN 命令将在当前 image 中执行任意合法命令并提交执行结果。命令执行提交后，就会自动执行 Dockerfile 中的下一个指令。</li>
<li>  层级 RUN 指令和生成提交是符合 Docker 核心理念的做法。它允许像版本控制那样，在任意一个点，对 image 镜像进行定制化构建。</li>
<li>  RUN 指令创建的中间镜像会被缓存，并会在下次构建中使用。如果不想使用这些缓存镜像，可以在构建时指定 <code>--no-cache</code> 参数，如：<code>docker build --no-cache</code>。</li>
</ul>
<h3 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a>COPY 复制文件</h3><p>格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COPY &lt;源路径&gt;... &lt;目标路径&gt;</span><br><span class="line">COPY [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>和 RUN 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。COPY 指令将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的<code>&lt;目标路径&gt;</code>位置。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COPY package.json /usr/src/app/</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>&lt;源路径&gt;</code>可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 filepath.Match 规则，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">COPY hom* /mydir/</span><br><span class="line">COPY hom?.txt /mydir/</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>&lt;目标路径&gt;</code>可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 WORKDIR 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p>
<p>此外，还需要注意一点，使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p>
<h3 id="ADD-更高级的复制文件"><a href="#ADD-更高级的复制文件" class="headerlink" title="ADD 更高级的复制文件"></a>ADD 更高级的复制文件</h3><p>ADD 指令和 COPY 的格式和性质基本一致。但是在 COPY 基础上增加了一些功能。比如<code>&lt;源路径&gt;</code>可以是一个 URL，这种情况下，Docker 引擎会试图去下载这个链接的文件放到<code>&lt;目标路径&gt;</code>去，并且会将tar包解压。</p>
<p>在构建镜像时，复制上下文中的文件到镜像内，格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ADD &lt;源路径&gt;... &lt;目标路径&gt;</span><br><span class="line">ADD [&quot;&lt;源路径&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong><br>如果 docker 发现文件内容被改变，则接下来的指令都不会再使用缓存。关于复制文件时需要处理的/，基本跟正常的 copy 一致</p>
<h3 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h3><p>格式有两种：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENV &lt;key&gt; &lt;value&gt;</span><br><span class="line">ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 RUN，还是运行时的应用，都可以直接使用这里定义的环境变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENV VERSION=1.0 DEBUG=on \</span><br><span class="line">    NAME=&quot;Happy Feet&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。</p>
<h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p>为构建的镜像设置监听端口，使容器在运行时监听。格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPOSE &lt;port&gt; [&lt;port&gt;...]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>EXPOSE 指令并不会让容器监听 host 的端口，如果需要，需要在 docker run 时使用 <code>-p</code>、<code>-P</code> 参数来发布容器端口到 host 的某个端口上。</p>
<h3 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h3><p>VOLUME用于创建挂载点，即向基于所构建镜像创始的容器添加卷：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">VOLUME [&quot;/data&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一个卷可以存在于一个或多个容器的指定目录，该目录可以绕过联合文件系统，并具有以下功能：</p>
<ul>
<li>  卷可以容器间共享和重用</li>
<li>  容器并不一定要和其它容器共享卷</li>
<li>  修改卷后会立即生效</li>
<li>  对卷的修改不会对镜像产生影响</li>
<li>  卷会一直存在，直到没有任何容器在使用它</li>
</ul>
<p>VOLUME 让我们可以将源代码、数据或其它内容添加到镜像中，而又不并提交到镜像中，并使我们可以多个容器间共享这些内容。</p>
<h3 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR 指定工作目录"></a>WORKDIR 指定工作目录</h3><p>WORKDIR用于在容器内设置一个工作目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WORKDIR /path/to/workdir</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过WORKDIR设置工作目录后，Dockerfile 中其后的命令 RUN、CMD、ENTRYPOINT、ADD、COPY 等命令都会在该目录下执行。<br>如，使用WORKDIR设置工作目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WORKDIR /a</span><br><span class="line">WORKDIR b</span><br><span class="line">WORKDIR c</span><br><span class="line">RUN pwd</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在以上示例中，pwd 最终将会在 <code>/a/b/c</code> 目录中执行。在使用 docker run 运行容器时，可以通过<code>-w</code>参数覆盖构建时所设置的工作目录。</p>
<h3 id="USER-指定当前用户"><a href="#USER-指定当前用户" class="headerlink" title="USER 指定当前用户"></a>USER 指定当前用户</h3><p>USER 用于指定运行镜像所使用的用户：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USER daemon</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用USER指定用户时，可以使用用户名、UID 或 GID，或是两者的组合。以下都是合法的指定试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">USER user</span><br><span class="line">USER user:group</span><br><span class="line">USER uid</span><br><span class="line">USER uid:gid</span><br><span class="line">USER user:gid</span><br><span class="line">USER uid:group</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用USER指定用户后，Dockerfile 中其后的命令 RUN、CMD、ENTRYPOINT 都将使用该用户。镜像构建完成后，通过 docker run 运行容器时，可以通过 <code>-u</code> 参数来覆盖所指定的用户。</p>
<h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>CMD用于指定在容器启动时所要执行的命令。CMD 有以下三种格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</span><br><span class="line">CMD [&quot;param1&quot;,&quot;param2&quot;]</span><br><span class="line">CMD command param1 param2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>省略可执行文件的 exec 格式，这种写法使 CMD 中的参数当做 ENTRYPOINT 的默认参数，此时 ENTRYPOINT 也应该是 exec 格式，具体与 ENTRYPOINT 的组合使用，参考 ENTRYPOINT。</p>
<p><strong>注意</strong><br>与 RUN 指令的区别：RUN 在构建的时候执行，并生成一个新的镜像，CMD 在容器运行的时候执行，在构建时不进行任何操作。</p>
<h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p>ENTRYPOINT 用于给容器配置一个可执行程序。也就是说，每次使用镜像创建容器时，通过 ENTRYPOINT 指定的程序都会被设置为默认程序。ENTRYPOINT 有以下两种形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</span><br><span class="line">ENTRYPOINT command param1 param2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ENTRYPOINT 与 CMD 非常类似，不同的是通过<code>docker run</code>执行的命令不会覆盖 ENTRYPOINT，而<code>docker run</code>命令中指定的任何参数，都会被当做参数再次传递给 ENTRYPOINT。Dockerfile 中只允许有一个 ENTRYPOINT 命令，多指定时会覆盖前面的设置，而只执行最后的 ENTRYPOINT 指令。</p>
<p><code>docker run</code>运行容器时指定的参数都会被传递给 ENTRYPOINT ，且会覆盖 CMD 命令指定的参数。如，执行<code>docker run &lt;image&gt; -d</code>时，-d 参数将被传递给入口点。</p>
<p>也可以通过<code>docker run --entrypoint</code>重写 ENTRYPOINT 入口点。如：可以像下面这样指定一个容器执行程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENTRYPOINT [&quot;/usr/bin/nginx&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>完整构建代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Version: 0.0.3</span><br><span class="line">FROM ubuntu:16.04</span><br><span class="line">MAINTAINER 何民三 &quot;cn.liuht@gmail.com&quot;</span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install -y nginx</span><br><span class="line">RUN echo &#x27;Hello World, 我是个容器&#x27; \ </span><br><span class="line">   &gt; /var/www/html/index.html</span><br><span class="line">ENTRYPOINT [&quot;/usr/sbin/nginx&quot;]</span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用docker build构建镜像，并将镜像指定为 itbilu/test：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t=&quot;itbilu/test&quot; .</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>构建完成后，使用itbilu/test启动一个容器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -i -t  itbilu/test -g &quot;daemon off;&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在运行容器时，我们使用了 <code>-g &quot;daemon off;&quot;</code>，这个参数将会被传递给 ENTRYPOINT，最终在容器中执行的命令为 <code>/usr/sbin/nginx -g &quot;daemon off;&quot;</code>。</p>
<h3 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h3><p>LABEL用于为镜像添加元数据，元数以键值对的形式指定：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用LABEL指定元数据时，一条LABEL指定可以指定一或多条元数据，指定多条元数据时不同元数据之间通过空格分隔。推荐将所有的元数据通过一条LABEL指令指定，以免生成过多的中间镜像。<br>如，通过LABEL指定一些元数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LABEL version=&quot;1.0&quot; description=&quot;这是一个Web服务器&quot; by=&quot;IT笔录&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>指定后可以通过docker inspect查看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker inspect itbilu/test</span><br><span class="line">&quot;Labels&quot;: &#123;</span><br><span class="line">    &quot;version&quot;: &quot;1.0&quot;,</span><br><span class="line">    &quot;description&quot;: &quot;这是一个Web服务器&quot;,</span><br><span class="line">    &quot;by&quot;: &quot;IT笔录&quot;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><p>ARG用于指定传递给构建运行时的变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ARG &lt;name&gt;[=&lt;default value&gt;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如，通过ARG指定两个变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ARG site</span><br><span class="line">ARG build_user=IT笔录</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上我们指定了 site 和 build_user 两个变量，其中 build_user 指定了默认值。在使用 docker build 构建镜像时，可以通过 <code>--build-arg &lt;varname&gt;=&lt;value&gt;</code> 参数来指定或重设置这些变量的值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build --build-arg site=itiblu.com -t itbilu/test .</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样我们构建了 itbilu/test 镜像，其中site会被设置为 itbilu.com，由于没有指定 build_user，其值将是默认值 IT 笔录。</p>
<h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><p>ONBUILD用于设置镜像触发器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ONBUILD [INSTRUCTION]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当所构建的镜像被用做其它镜像的基础镜像，该镜像中的触发器将会被钥触发。<br>如，当镜像被使用时，可能需要做一些处理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[...]</span><br><span class="line">ONBUILD ADD . /app/src</span><br><span class="line">ONBUILD RUN /usr/local/bin/python-build --dir /app/src</span><br><span class="line">[...]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="STOPSIGNAL"><a href="#STOPSIGNAL" class="headerlink" title="STOPSIGNAL"></a>STOPSIGNAL</h3><p>STOPSIGNAL用于设置停止容器所要发送的系统调用信号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">STOPSIGNAL signal</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所使用的信号必须是内核系统调用表中的合法的值，如：SIGKILL。</p>
<h3 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a>SHELL</h3><p>SHELL用于设置执行命令（shell式）所使用的的默认 shell 类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHELL [&quot;executable&quot;, &quot;parameters&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>SHELL在Windows环境下比较有用，Windows 下通常会有 cmd 和 powershell 两种 shell，可能还会有 sh。这时就可以通过 SHELL 来指定所使用的 shell 类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM microsoft/windowsservercore</span><br><span class="line"></span><br><span class="line"># Executed as cmd /S /C echo default</span><br><span class="line">RUN echo default</span><br><span class="line"></span><br><span class="line"># Executed as cmd /S /C powershell -command Write-Host default</span><br><span class="line">RUN powershell -command Write-Host default</span><br><span class="line"></span><br><span class="line"># Executed as powershell -command Write-Host hello</span><br><span class="line">SHELL [&quot;powershell&quot;, &quot;-command&quot;]</span><br><span class="line">RUN Write-Host hello</span><br><span class="line"></span><br><span class="line"># Executed as cmd /S /C echo hello</span><br><span class="line">SHELL [&quot;cmd&quot;, &quot;/S&quot;&quot;, &quot;/C&quot;]</span><br><span class="line">RUN echo hello</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="Dockerfile-示例"><a href="#Dockerfile-示例" class="headerlink" title="Dockerfile 示例"></a>Dockerfile 示例</h3><p><strong>构建Nginx运行环境</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 指定基础镜像</span><br><span class="line">FROM sameersbn/ubuntu:14.04.20161014</span><br><span class="line"></span><br><span class="line"># 维护者信息</span><br><span class="line">MAINTAINER sameer@damagehead.com</span><br><span class="line"></span><br><span class="line"># 设置环境</span><br><span class="line">ENV RTMP_VERSION=1.1.10 \</span><br><span class="line">    NPS_VERSION=1.11.33.4 \</span><br><span class="line">    LIBAV_VERSION=11.8 \</span><br><span class="line">    NGINX_VERSION=1.10.1 \</span><br><span class="line">    NGINX_USER=www-data \</span><br><span class="line">    NGINX_SITECONF_DIR=/etc/nginx/sites-enabled \</span><br><span class="line">    NGINX_LOG_DIR=/var/log/nginx \</span><br><span class="line">    NGINX_TEMP_DIR=/var/lib/nginx \</span><br><span class="line">    NGINX_SETUP_DIR=/var/cache/nginx</span><br><span class="line"></span><br><span class="line"># 设置构建时变量，镜像建立完成后就失效</span><br><span class="line">ARG BUILD_LIBAV=false</span><br><span class="line">ARG WITH_DEBUG=false</span><br><span class="line">ARG WITH_PAGESPEED=true</span><br><span class="line">ARG WITH_RTMP=true</span><br><span class="line"></span><br><span class="line"># 复制本地文件到容器目录中</span><br><span class="line">COPY setup/ $&#123;NGINX_SETUP_DIR&#125;/</span><br><span class="line">RUN bash $&#123;NGINX_SETUP_DIR&#125;/install.sh</span><br><span class="line"></span><br><span class="line"># 复制本地配置文件到容器目录中</span><br><span class="line">COPY nginx.conf /etc/nginx/nginx.conf</span><br><span class="line">COPY entrypoint.sh /sbin/entrypoint.sh</span><br><span class="line"></span><br><span class="line"># 运行指令</span><br><span class="line">RUN chmod 755 /sbin/entrypoint.sh</span><br><span class="line"></span><br><span class="line"># 允许指定的端口</span><br><span class="line">EXPOSE 80/tcp 443/tcp 1935/tcp</span><br><span class="line"></span><br><span class="line"># 指定网站目录挂载点</span><br><span class="line">VOLUME [&quot;$&#123;NGINX_SITECONF_DIR&#125;&quot;]</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;/sbin/entrypoint.sh&quot;]</span><br><span class="line">CMD [&quot;/usr/sbin/nginx&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>构建tomcat 环境</strong></p>
<p>Dockerfile文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 指定基于的基础镜像</span><br><span class="line">FROM ubuntu:13.10  </span><br><span class="line"></span><br><span class="line"># 维护者信息</span><br><span class="line">MAINTAINER zhangjiayang &quot;zhangjiayang@sczq.com.cn&quot;  </span><br><span class="line">  </span><br><span class="line"># 镜像的指令操作</span><br><span class="line"># 获取APT更新的资源列表</span><br><span class="line">RUN echo &quot;deb http://archive.ubuntu.com/ubuntu precise main universe&quot;&gt; /etc/apt/sources.list</span><br><span class="line"># 更新软件</span><br><span class="line">RUN apt-get update  </span><br><span class="line">  </span><br><span class="line"># Install curl  </span><br><span class="line">RUN apt-get -y install curl  </span><br><span class="line">  </span><br><span class="line"># Install JDK 7  </span><br><span class="line">RUN cd /tmp &amp;&amp;  curl -L &#x27;http://download.oracle.com/otn-pub/java/jdk/7u65-b17/jdk-7u65-linux-x64.tar.gz&#x27; -H &#x27;Cookie: oraclelicense=accept-securebackup-cookie; gpw_e24=Dockerfile&#x27; | tar -xz  </span><br><span class="line">RUN mkdir -p /usr/lib/jvm  </span><br><span class="line">RUN mv /tmp/jdk1.7.0_65/ /usr/lib/jvm/java-7-oracle/  </span><br><span class="line">  </span><br><span class="line"># Set Oracle JDK 7 as default Java  </span><br><span class="line">RUN update-alternatives --install /usr/bin/java java /usr/lib/jvm/java-7-oracle/bin/java 300     </span><br><span class="line">RUN update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/java-7-oracle/bin/javac 300     </span><br><span class="line"></span><br><span class="line"># 设置系统环境</span><br><span class="line">ENV JAVA_HOME /usr/lib/jvm/java-7-oracle/  </span><br><span class="line">  </span><br><span class="line"># Install tomcat7  </span><br><span class="line">RUN cd /tmp &amp;&amp; curl -L &#x27;http://archive.apache.org/dist/tomcat/tomcat-7/v7.0.8/bin/apache-tomcat-7.0.8.tar.gz&#x27; | tar -xz  </span><br><span class="line">RUN mv /tmp/apache-tomcat-7.0.8/ /opt/tomcat7/  </span><br><span class="line">  </span><br><span class="line">ENV CATALINA_HOME /opt/tomcat7  </span><br><span class="line">ENV PATH $PATH:$CATALINA_HOME/bin  </span><br><span class="line"></span><br><span class="line"># 复件tomcat7.sh到容器中的目录 </span><br><span class="line">ADD tomcat7.sh /etc/init.d/tomcat7  </span><br><span class="line">RUN chmod 755 /etc/init.d/tomcat7  </span><br><span class="line">  </span><br><span class="line"># Expose ports.  指定暴露的端口</span><br><span class="line">EXPOSE 8080  </span><br><span class="line">  </span><br><span class="line"># Define default command.  </span><br><span class="line">ENTRYPOINT service tomcat7 start &amp;&amp; tail -f /opt/tomcat7/logs/catalina.out</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>tomcat7.sh</code>命令文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/lib/jvm/java-7-oracle/  </span><br><span class="line">export TOMCAT_HOME=/opt/tomcat7  </span><br><span class="line">  </span><br><span class="line">case $1 in  </span><br><span class="line">start)  </span><br><span class="line">  sh $TOMCAT_HOME/bin/startup.sh  </span><br><span class="line">;;  </span><br><span class="line">stop)  </span><br><span class="line">  sh $TOMCAT_HOME/bin/shutdown.sh  </span><br><span class="line">;;  </span><br><span class="line">restart)  </span><br><span class="line">  sh $TOMCAT_HOME/bin/shutdown.sh  </span><br><span class="line">  sh $TOMCAT_HOME/bin/startup.sh  </span><br><span class="line">;;  </span><br><span class="line">esac  </span><br><span class="line">exit 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="原则与建议"><a href="#原则与建议" class="headerlink" title="原则与建议"></a>原则与建议</h3><ul>
<li>  容器轻量化。从镜像中产生的容器应该尽量轻量化，能在足够短的时间内停止、销毁、重新生成并替换原来的容器。</li>
<li>  使用 <code>.gitignore</code>。在大部分情况下，Dockerfile 会和构建所需的文件放在同一个目录中，为了提高构建的性能，应该使用 <code>.gitignore</code> 来过滤掉不需要的文件和目录。</li>
<li>  为了减少镜像的大小，减少依赖，仅安装需要的软件包。</li>
<li>  一个容器只做一件事。解耦复杂的应用，分成多个容器，而不是所有东西都放在一个容器内运行。如一个 Python Web 应用，可能需要 Server、DB、Cache、MQ、Log 等几个容器。一个更加极端的说法：One process per container。</li>
<li>  减少镜像的图层。不要多个 Label、ENV 等标签。</li>
<li>  对续行的参数按照字母表排序，特别是使用<code>apt-get install -y</code>安装包的时候。</li>
<li>  使用构建缓存。如果不想使用缓存，可以在构建的时候使用参数<code>--no-cache=true</code>来强制重新生成中间镜像。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.docker.com/engine/reference/builder/#usage">Dockerfile reference</a><br><a href="https://www.jianshu.com/p/cbce69c7a52f">使用Dockerfile构建Docker镜像</a><br><a href="https://itbilu.com/linux/docker/VyhM5wPuz.html">Docker镜像构建文件Dockerfile及相关命令介绍</a><br><a href="https://github.com/qianlei90/Blog/issues/35">深入Dockerfile（一）: 语法指南</a><br><a href="https://yeasy.gitbooks.io/docker_practice/content/">Docker — 从入门到实践</a></p>
]]></content>
      <categories>
        <category>DOCKER</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker龙蜥镜像制作</title>
    <url>/2024/04/24/docker%E9%BE%99%E8%9C%A5%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="Anolis-OS安装docker"><a href="#Anolis-OS安装docker" class="headerlink" title="Anolis OS安装docker"></a>Anolis OS安装docker</h3><p>系统版本：Anolis OS release 8.6 (Centos8)</p>
<h4 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum remove docker  docker-common docker-selinux docker-engine</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h4 id="设置安装环境"><a href="#设置安装环境" class="headerlink" title="设置安装环境"></a>设置安装环境</h4><p>安装依赖，并设置docker源(中央仓库或阿里源均可)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"></span><br><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo </span><br><span class="line"></span><br><span class="line">#安装containerd的时候提示有冲突的软件包，根据提示，后面加上--allowerasing&#x27; 来替换冲突的软件包</span><br><span class="line">yum -y install containerd --allowerasing</span><br></pre></td></tr></table></figure>

<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>查看可用版本,并选择合适版本安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum list docker-ce --showduplicates | sort -r</span><br><span class="line">yum -y install docker-ce-24.0.1-1.el8</span><br></pre></td></tr></table></figure>

<h4 id="启动和添加自启动"><a href="#启动和添加自启动" class="headerlink" title="启动和添加自启动"></a>启动和添加自启动</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看版本</span><br><span class="line">docker version</span><br><span class="line"></span><br><span class="line"># 启动</span><br><span class="line">systemctl start docker</span><br><span class="line"># 设置开机自启动</span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure>

<h3 id="版本镜像制作"><a href="#版本镜像制作" class="headerlink" title="版本镜像制作"></a>版本镜像制作</h3><h4 id="基础镜像拉取"><a href="#基础镜像拉取" class="headerlink" title="基础镜像拉取"></a>基础镜像拉取</h4><p>dockerhub生成Access Tokens</p>
<p><img src="2d578415edef21bbb04fafd686a06ee8d1230c8ad0c64f587c50549be05cc402.png" alt="picture 0">  </p>
<p>dockerd配置网络，docker login登录，拉取龙蜥官方镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull openanolis/anolisos:8.6-aarch64</span><br></pre></td></tr></table></figure>
<h4 id="Dockerfile制作版本镜像"><a href="#Dockerfile制作版本镜像" class="headerlink" title="Dockerfile制作版本镜像"></a>Dockerfile制作版本镜像</h4><p>拉取版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -u alps-ci:Jaguar@123 -O &quot;https://jfrog1.jaguarmicro.com/artifactory/corsica-sw-generic-local/snapshot/full-version/corsica_dpu_dev/anolis/202404212359/202404212359_jmnd.tar.gz&quot;</span><br></pre></td></tr></table></figure>
<p>基于openanolis/anolisos:8.6-aarch64编译版本镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t anolisos-jmnd:0421 .</span><br></pre></td></tr></table></figure>
<p>参考Dockerfile如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM openanolis/anolisos:8.6-aarch64</span><br><span class="line"></span><br><span class="line">RUN https_proxy=xxxx http_proxy=xxxxx yum install -y python3 jansson jansson-devel libatomic libmlx5 librdmacm yajl-devel libaio-devel libiscsi-devel librados-devel librbd-devel &amp;&amp; \</span><br><span class="line">    yum clean all</span><br><span class="line"></span><br><span class="line">ADD 202404212359_jmnd.tar.gz /usr/share</span><br><span class="line">ADD libmhu.so /usr/lib</span><br><span class="line">ADD libmhu.so /usr/lib64</span><br><span class="line"></span><br><span class="line">WORKDIR /usr/share/jmnd</span><br></pre></td></tr></table></figure>

<h4 id="rpm包方式安装的镜像"><a href="#rpm包方式安装的镜像" class="headerlink" title="rpm包方式安装的镜像"></a>rpm包方式安装的镜像</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat Dockerfile</span><br><span class="line">FROM openanolis/anolisos:8.6-aarch64</span><br><span class="line"></span><br><span class="line">ADD libmhu.so /usr/lib</span><br><span class="line">ADD libmhu.so /usr/lib64</span><br><span class="line">ADD corsica-jmnd-202405082300-debug.aarch64.rpm /</span><br><span class="line">RUN sed -i &#x27;s/mirrors.openanolis.cn/mirrors.jaguarmicro.com/&#x27; /etc/yum.repos.d/AnolisOS-* &amp;&amp; \</span><br><span class="line">    yum update -y &amp;&amp; \</span><br><span class="line">    yum install -y python3 jansson jansson-devel libatomic libmlx5 librdmacm yajl-devel libaio-devel libiscsi-devel librados-devel librbd-devel pciutils openssh-clients &amp;&amp; \</span><br><span class="line">    yum clean all &amp;&amp; \</span><br><span class="line">    rpm -i corsica-jmnd-202405082300-debug.aarch64.rpm --nodeps --force &amp;&amp; rm -f corsica-jmnd-202405082300-debug.aarch64.rpm &amp;&amp; ln -sf /usr/share/jmnd/jm_launcher/jm-ctl /usr/bin/jm-ctl</span><br><span class="line">RUN ssh-keygen -t rsa -N &#x27;&#x27; -f /root/.ssh/id_rsa -q</span><br><span class="line">WORKDIR /usr/share/jmnd</span><br></pre></td></tr></table></figure>
<p>运行容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it --rm --privileged=true --net=host --ipc=shareable -v /data:/data --shm-size 4G anolisos-jmnd:0421 bash</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>DOCKER</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>性能测试Lmbench</title>
    <url>/2024/04/02/Lmbench-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="Lmbench-简介"><a href="#Lmbench-简介" class="headerlink" title="Lmbench 简介"></a>Lmbench 简介</h2><p><code>Lmbench</code>是个用于评价系统综合性能的多平台开源benchmark，能够测试包括文档读写、内存操作、进程创建销毁开销、网络等性能。</p>
<span id="more"></span>
<h2 id="下载和安装"><a href="#下载和安装" class="headerlink" title="下载和安装"></a>下载和安装</h2><p>官网地址：<a href="http://www.bitmover.com/lmbench/">http://www.bitmover.com/lmbench/</a><br>下载连接：<a href="https://download.csdn.net/download/qq_36393978/86261418">lmbench-3.0</a></p>
<p>或者<br>链接：<a href="https://pan.baidu.com/s/1GJ7iOSTYQa4THAjjiD4TXQ">https://pan.baidu.com/s/1GJ7iOSTYQa4THAjjiD4TXQ</a><br>提取码：jayn</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">imaginemiracle:Downloads$ unzip lmbench-3.0-a9.zip</span><br></pre></td></tr></table></figure>

<p>需要注意的是，目前解压出的 <code>lmbench</code> 中所有文件都不可被执行，当直接执行 <code>make</code> 编译后将会看到类似有 <code>Permission denied</code> 等一系列错误。</p>
<p>这里首先需要更改所有文件的权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">imaginemiracle:Downloads$ sudo chmod 777 -R lmbench-3.0-a9/</span><br></pre></td></tr></table></figure>

<p>进入 <code>lmbench</code> 目录，其目录结构如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">imaginemiracle:Downloads$ cd lmbench-3.0-a9/</span><br><span class="line">imaginemiracle:lmbench-3.0-a9$ ls</span><br><span class="line">ACKNOWLEDGEMENTS  CHANGES    COPYING    doc              Makefile  results  src</span><br><span class="line">bin               ChangeSet  COPYING-2  hbench-REBUTTAL  README    scripts</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用-Lmbench-测试"><a href="#使用-Lmbench-测试" class="headerlink" title="使用 Lmbench 测试"></a>使用 Lmbench 测试</h2><p>可能存在测试结果显示不全问题，需要修改getsummary 文件<br>vim scripts/getsummary</p>
<p>添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (/^\[mount:/) &#123;</span><br><span class="line">        next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="e4284b7b8c1922f3d26f6eac03c5988bf4e91b65dabc8082f5730502e9bb6eee.png" alt="picture 0">  </p>
<p>cp config.guess lmbench-3.0-a9/scripts/gnu-os 修正gnu-os参数，解决arm系统适配问题<br>config.guess文件网盘下载自带有</p>
<p>执行 <code>make results</code>，执行后将会有以下选项提示需要设置：</p>
<ul>
<li>  <strong>MULTIPLE COPIES：</strong> 同时运行并行测试，对应生成结果中的 <code>scal load</code> 项；</li>
<li>  <strong>Job placement selection:</strong> 作业调度控制方法，默认选 <code>1</code>，表示允许作业调度；</li>
<li>  <strong>Options to control job placement:</strong> 默认选 <code>1</code>；</li>
<li>  <strong>Memory:</strong> 设置为大于 <code>4</code> 倍的 <code>cache size</code>，该值越大结果越精确，同时运行时间越长；</li>
<li>  <strong>SUBSET:</strong> 要运行的子集，包含 <code>ALL / HARWARE / OS / DEVELOPMENT</code>，默认选 <code>all</code>；</li>
<li>  <strong>FASTMEM、SLOWFS、DISKS、REMOTE…</strong> 等选项，均保持默认即可。</li>
<li>  <strong>Mail results:</strong> 选<code>no</code>。</li>
</ul>
<p>设置完成后测试程序开始运行，需要注意运行时间较久，需耐心等待，或先做其他事情至少 <code>10 min</code> 后再看。</p>
<h2 id="查看结果"><a href="#查看结果" class="headerlink" title="查看结果"></a>查看结果</h2><p>执行 <code>make see</code> 查看运行结果，若只出现两行命令，显示运行结果输出到了 <code>summary.out</code> 文件中，则直接查看该文件即可。<code>cat ./results/summary.out</code>。<br>将会看到如下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make[1]: Entering directory &#x27;/home/tmp/lmbench-3.0-a9/results&#x27;</span><br><span class="line"></span><br><span class="line">                 L M B E N C H  3 . 0   S U M M A R Y</span><br><span class="line">                 ------------------------------------</span><br><span class="line">                 (Alpha software, do not distribute)</span><br><span class="line"></span><br><span class="line">Basic system parameters</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">Host                 OS Description              Mhz  tlb  cache  mem   scal</span><br><span class="line">                                                     pages line   par   load</span><br><span class="line">                                                           bytes  </span><br><span class="line">--------- ------------- ----------------------- ---- ----- ----- ------ ----</span><br><span class="line">k8s-69-22 Linux 5.4.0-1        x86_64-linux-gnu 1499                       1</span><br><span class="line">k8s-69-22 Linux 5.4.0-1        x86_64-linux-gnu 1499                       1</span><br><span class="line">k8s-69-22 Linux 5.4.0-1        x86_64-linux-gnu 2892                       1</span><br><span class="line"></span><br><span class="line">Processor, Processes - times in microseconds - smaller is better</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">Host                 OS  Mhz null null      open slct sig  sig  fork exec sh  </span><br><span class="line">                             call  I/O stat clos TCP  inst hndl proc proc proc</span><br><span class="line">--------- ------------- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----</span><br><span class="line">k8s-69-22 Linux 5.4.0-1 1499 0.08 0.16 0.52 1.13 2.71 0.16 1.09 369. 1016 3659</span><br><span class="line">k8s-69-22 Linux 5.4.0-1 1499 0.08 0.16 0.53 1.18 2.75 0.17 1.13 355. 992. 3567</span><br><span class="line">k8s-69-22 Linux 5.4.0-1 2892 0.08 0.16 0.53 1.14 2.67 0.18 1.09 134. 315. 1057</span><br><span class="line"></span><br><span class="line">Basic integer operations - times in nanoseconds - smaller is better</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">Host                 OS  intgr intgr  intgr  intgr  intgr  </span><br><span class="line">                          bit   add    mul    div    mod   </span><br><span class="line">--------- ------------- ------ ------ ------ ------ ------ </span><br><span class="line">k8s-69-22 Linux 5.4.0-1 0.2400 0.1700        9.4000 9.6100</span><br><span class="line">k8s-69-22 Linux 5.4.0-1 0.2400 0.1700        9.3600 9.5900</span><br><span class="line">k8s-69-22 Linux 5.4.0-1 0.2300 0.1700        9.3600 9.5300</span><br><span class="line"></span><br><span class="line">Basic uint64 operations - times in nanoseconds - smaller is better</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">Host                 OS int64  int64  int64  int64  int64  </span><br><span class="line">                         bit    add    mul    div    mod   </span><br><span class="line">--------- ------------- ------ ------ ------ ------ ------ </span><br><span class="line">k8s-69-22 Linux 5.4.0-1  0.240        0.0100   14.8   14.3</span><br><span class="line">k8s-69-22 Linux 5.4.0-1  0.230        0.0100   14.7   14.3</span><br><span class="line">k8s-69-22 Linux 5.4.0-1  0.230        0.0100   14.7   14.2</span><br><span class="line"></span><br><span class="line">Basic float operations - times in nanoseconds - smaller is better</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">Host                 OS  float  float  float  float</span><br><span class="line">                         add    mul    div    bogo</span><br><span class="line">--------- ------------- ------ ------ ------ ------ </span><br><span class="line">k8s-69-22 Linux 5.4.0-1 1.3800 1.3900 4.9800 1.0400</span><br><span class="line">k8s-69-22 Linux 5.4.0-1 1.3900 1.3900 4.0300 1.0400</span><br><span class="line">k8s-69-22 Linux 5.4.0-1 1.3800 1.3800 4.0400 1.0700</span><br><span class="line"></span><br><span class="line">Basic double operations - times in nanoseconds - smaller is better</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">Host                 OS  double double double double</span><br><span class="line">                         add    mul    div    bogo</span><br><span class="line">--------- ------------- ------  ------ ------ ------ </span><br><span class="line">k8s-69-22 Linux 5.4.0-1 1.3900 1.3800 5.0300 1.3900</span><br><span class="line">k8s-69-22 Linux 5.4.0-1 1.3800 1.3900 5.1900 1.7400</span><br><span class="line">k8s-69-22 Linux 5.4.0-1 1.3800 1.4300 4.9700 1.3800</span><br><span class="line"></span><br><span class="line">Context switching - times in microseconds - smaller is better</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">Host                 OS  2p/0K 2p/16K 2p/64K 8p/16K 8p/64K 16p/16K 16p/64K</span><br><span class="line">                         ctxsw  ctxsw  ctxsw ctxsw  ctxsw   ctxsw   ctxsw</span><br><span class="line">--------- ------------- ------ ------ ------ ------ ------ ------- -------</span><br><span class="line">k8s-69-22 Linux 5.4.0-1 8.7700   10.3   15.2   14.7   18.5    15.1    20.4</span><br><span class="line">k8s-69-22 Linux 5.4.0-1 8.7400 9.0100   17.1   15.0   19.4    14.8    19.7</span><br><span class="line">k8s-69-22 Linux 5.4.0-1 3.7400 3.7600 3.8800 3.7800 3.7500 3.83000 3.85000</span><br><span class="line"></span><br><span class="line">*Local* Communication latencies in microseconds - smaller is better</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">Host                 OS 2p/0K  Pipe AF     UDP  RPC/   TCP  RPC/ TCP</span><br><span class="line">                        ctxsw       UNIX         UDP         TCP conn</span><br><span class="line">--------- ------------- ----- ----- ---- ----- ----- ----- ----- ----</span><br><span class="line">k8s-69-22 Linux 5.4.0-1 8.770 9.096 8.35  14.8  17.7 1.562  21.2  28.</span><br><span class="line">k8s-69-22 Linux 5.4.0-1 8.740 8.745 8.09  20.1  17.7 1.536  25.1  25.</span><br><span class="line">k8s-69-22 Linux 5.4.0-1 3.740 8.483 8.02  14.1  16.0 1.520  19.2  24.</span><br><span class="line"></span><br><span class="line">*Remote* Communication latencies in microseconds - smaller is better</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">Host                 OS   UDP  RPC/  TCP   RPC/ TCP</span><br><span class="line">                               UDP         TCP  conn</span><br><span class="line">--------- ------------- ----- ----- ----- ----- ----</span><br><span class="line">k8s-69-22 Linux 5.4.0-1                             </span><br><span class="line">k8s-69-22 Linux 5.4.0-1                             </span><br><span class="line">k8s-69-22 Linux 5.4.0-1                             </span><br><span class="line"></span><br><span class="line">File &amp; VM system latencies in microseconds - smaller is better</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">Host                 OS   0K File      10K File     Mmap    Prot   Page   100fd</span><br><span class="line">                        Create Delete Create Delete Latency Fault  Fault  selct</span><br><span class="line">--------- ------------- ------ ------ ------ ------ ------- ----- ------- -----</span><br><span class="line">k8s-69-22 Linux 5.4.0-1 7.1240 4.9842   13.4 7.2740  8008.0 0.555 0.30410 1.062</span><br><span class="line">k8s-69-22 Linux 5.4.0-1 6.8406 4.9554   14.0 7.5449  3876.0 0.506 0.22400 1.068</span><br><span class="line">k8s-69-22 Linux 5.4.0-1 6.4733 4.9461   13.8 7.4176  3863.0 0.566 0.26380 1.061</span><br><span class="line"></span><br><span class="line">*Local* Communication bandwidths in MB/s - bigger is better</span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line">Host                OS  Pipe AF    TCP  File   Mmap  Bcopy  Bcopy  Mem   Mem</span><br><span class="line">                             UNIX      reread reread (libc) (hand) read write</span><br><span class="line">--------- ------------- ---- ---- ---- ------ ------ ------ ------ ---- -----</span><br><span class="line">k8s-69-22 Linux 5.4.0-1 2607 4094 5411 5060.1 8378.1 7506.2 4224.4 7763 6201.</span><br><span class="line">k8s-69-22 Linux 5.4.0-1 2775 4045 3911 4961.8 8167.1 7112.0 4479.9 8039 6618.</span><br><span class="line">k8s-69-22 Linux 5.4.0-1 2963 4073 3997 4178.8 7734.7 7262.5 4160.1 8644 7132.</span><br><span class="line"></span><br><span class="line">Memory latencies in nanoseconds - smaller is better</span><br><span class="line">    (WARNING - may not be correct, check graphs)</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">Host                 OS   Mhz   L1 $   L2 $    Main mem    Rand mem    Guesses</span><br><span class="line">--------- -------------   ---   ----   ----    --------    --------    -------</span><br><span class="line">k8s-69-22 Linux 5.4.0-1  1499 1.3840 4.8430        21.3       113.2</span><br><span class="line">k8s-69-22 Linux 5.4.0-1  1499 1.3840 4.8430        20.7       106.4</span><br><span class="line">k8s-69-22 Linux 5.4.0-1  2892 1.3840 4.8440        21.1       109.3</span><br><span class="line">make[1]: Leaving directory &#x27;/home/tmp/lmbench-3.0-a9/results&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="系统基本信息"><a href="#系统基本信息" class="headerlink" title="系统基本信息"></a>系统基本信息</h3><p>输出结果中开始显示系统的基本参数信息。<br><img src="8550509a293cfd68b64a3475aaf98b166b9c3910ca4c1a425206a140f688b97d.png" alt="picture 2">  </p>
<p>其中：</p>
<ul>
<li>  <strong>tlb:</strong> 表示转换后备缓存的页面数；</li>
<li>  <strong>cache line bytes:</strong> 高速缓存行字节数</li>
<li>  <strong>mem par:</strong> 存储器分层并行化；</li>
<li>  <strong>scal load:</strong> 并行执行的 <code>Lmbench</code> 数目。</li>
</ul>
<h3 id="处理器-Processor-性能"><a href="#处理器-Processor-性能" class="headerlink" title="处理器 Processor 性能"></a>处理器 Processor 性能</h3><p>如下输出结果单位均为 <code>us</code>，数值越小表示性能越好。<br><img src="0cfa0da0ec8dd39b3f4437067ef41ba683974f33c31c7665d364cae30b963b6c.png" alt="picture 3">  </p>
<ul>
<li>  <strong>null call:</strong> 执行 <code>getppid</code> 需要的时间；</li>
<li>  <strong>null I/O:</strong> 从 <code>/dev/zero</code> 读取一个字节的时长 <code>t1</code>，写一个字节到 <code>/dev/null</code> 的时长 <code>t2</code>，<code>t1、t2</code> 取平均值即为该项结果；</li>
<li>  <strong>stat:</strong> <code>stat</code> 一个文件（即得到一个文件的信息）所需时长；</li>
<li>  <strong>open clos:</strong> <code>open</code> 一个文件接着再 <code>close</code> 掉该文件一共所用时间（不包含读目录和节点的时间）；</li>
<li>  <strong>slct TCP:</strong> 通过 <code>TCP</code> 网络连接选择 <code>100</code> 个文件描述符所消耗的时间；</li>
<li>  <strong>sig inst:</strong> <code>install signal</code> 所耗时长；</li>
<li>  <strong>sig hndl:</strong> <code>handler signal</code> 所耗时长；</li>
<li>  <strong>fork proc:</strong> <code>fork</code> 一个完全相同的 <code>process</code>，并把原来的 <code>process</code> 关掉一共所消耗的时间；</li>
<li>  <strong>exec proc:</strong> 模拟一个 <code>shell</code> 进程的工作过程：<code>fork</code> 一个新进程执行新命令消耗的时间。</li>
<li>  <strong>sh proc:</strong> <code>fork</code> 一个进程，同时询问系统 <code>shell</code> 来找到并运行一个新程序所用时间。</li>
</ul>
<h3 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h3><p>如下输出结果单位均为 <code>ns</code>，数值越小表示性能越好。</p>
<p><strong>(1) 整型计算</strong></p>
<p><img src="f9fe19b7de0a4c60dae1ff83d7c992d26e09a7a134e1317fe3a0d4ccdf618acc.png" alt="picture 4">  </p>
<p><strong>(2) 无符号整型计算</strong></p>
<p><img src="94a0e44074d17ece6a76729d47c8adb9c48909cb10f2d9e9336b93cf8eaa7075.png" alt="picture 5">  </p>
<p><strong>(3) 浮点型计算</strong></p>
<p><img src="fa112ccd3c58934e89f54504b1389aa06278dc1a34c54d5af92e97827f428cd0.png" alt="picture 6">  </p>
<p><strong>(4) 双精度浮点型计算</strong></p>
<p><img src="eb17eea21a2edede1a93f90d30fb294e9fbc09ccaa4732b879f5bbbf7134b2de.png" alt="picture 7">  </p>
<h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>如下输出结果单位均为 <code>us</code>，数值越小表示性能越好。</p>
<p><img src="9f0e3d3cda656a90c65be7fda2f82d02113e6674ab74958d55e690df4890f39d.png" alt="picture 8">  </p>
<p>多个进程用 <code>unix pipe</code> 环连接起来，每个进程从自己的管道中读取 <code>token</code>，执行任务，然后将 <code>token</code> 写给下一个进程。</p>
<p><code>context swithing</code> 时间包括：切换进程的时间，加上恢复进程所有状态所用的时间（包含恢复 <code>cache</code> 状态）。</p>
<ul>
<li>  <strong>2p/0k:</strong> 每个进程的 <code>size</code> 为 <code>0</code>（不执行任何任务），进程数为 <code>2</code> 时上下文切换所消耗的时间；</li>
<li>  <strong>2p/16k:</strong> 每个进程 <code>size</code> 为 <code>16K</code>（执行任务），进程数为 <code>2</code> 时上下文切换所消耗的时间；</li>
</ul>
<p>之后的测试项以此类推。</p>
<h3 id="本地通讯时延"><a href="#本地通讯时延" class="headerlink" title="本地通讯时延"></a>本地通讯时延</h3><p>如下输出结果单位均为 <code>us</code>，数值越小表示性能越好。</p>
<p><img src="d1a4365d0719ce781e8c89d2440fb41c88f7ecabfb06b117f7e8773580e4efaf.png" alt="picture 9">  </p>
<ul>
<li>  <strong>2p/0k:</strong> 每个进程的 <code>size</code> 为 <code>0</code>（不执行任何任务），进程数为 <code>2</code> 时上下文切换所消耗的时间；</li>
<li>  <strong>Pipe:</strong> 即所谓的 <code>hot potato</code> 测试，两个没有具体任务的进程之间使用 <code>pipe</code> 通信，一个 <code>token</code> 在两个进程间来回传递，传递一个来回所消耗时长的平均值；</li>
<li>  <strong>AF UNIX:</strong> 同 <code>Pipe</code> 测试项，但进程间通信使用的是 <code>socket</code> 通信；</li>
<li>  <strong>UDP:</strong> 同 <code>Pipe</code> 测试项，但进程间通信使用的是 <code>UDP/IP</code> 通信；</li>
<li>  <strong>RPC/UDP:</strong> 同 <code>Pipe</code> 测试项，但进程间通信使用的是 <code>sun RPC</code> 通信，默认情况下，<code>RPC</code> 采用 <code>UDP</code> 协议传输；</li>
<li>  <strong>TCP:</strong> 同 <code>Pipe</code> 测试项，但进程间通信使用的是 <code>TCP/IP</code> 通信；</li>
<li>  <strong>RPC/TCP:</strong> 同 <code>Pipe</code> 测试项，但进程间通信使用的是 <code>sun RPC</code> 通信，指定 <code>RPC</code> 采用 <code>TCP</code> 协议传输；</li>
<li>  <strong>TCP conn:</strong> 创建 <code>socket</code> 描述符和建立连接所用时间。</li>
</ul>
<h3 id="文件、内存延时"><a href="#文件、内存延时" class="headerlink" title="文件、内存延时"></a>文件、内存延时</h3><p>如下输出结果单位均为 <code>us</code>，数值越小表示性能越好。</p>
<p><img src="6cbbd3bb69d25d38de85931ba1f11ec45855134bc883722d30234dd8d7679a7c.png" alt="picture 10">  </p>
<ul>
<li>  <strong>0K File Create:</strong> <code>0K</code> 文件创建所用时间；</li>
<li>  <strong>0K File Delete:</strong> <code>0K</code> 文件删除所用时间；</li>
<li>  <strong>10K File Create:</strong> <code>10K</code> 文件创建所用时间；</li>
<li>  <strong>10K File Delete:</strong> <code>10K</code> 文件删除所用时间；</li>
<li>  <strong>Mmap Latency:</strong> 将指定文件的开头 <code>n</code> 个字节 <code>mmap</code> 到内存，然后 <code>unmap</code>，并记录每次 <code>mmap</code> 和 <code>unmap</code> 共消耗的时间，去每次消耗时间的最大值；</li>
<li>  <strong>Port Fault:</strong> 保护页延时时间；</li>
<li>  <strong>Page Faule:</strong> 缺页延时时间；</li>
<li>  <strong>100fd selct:</strong> 对 <code>100</code> 个文件描述符配置 <code>select</code> 的时间。</li>
</ul>
<h3 id="本地通信带宽"><a href="#本地通信带宽" class="headerlink" title="本地通信带宽"></a>本地通信带宽</h3><p>如下输出结果单位均为 <code>MB/s</code>，数值越大表示性能越好。</p>
<p><img src="b80e04ed533208d79e6c7fb78d5799ab29173ad6f5189172840c4bb8d6b904bc.png" alt="picture 11">  </p>
<ul>
<li>  <strong>Pipe:</strong> 在两个进程建立 <code>pipe</code>，<code>pipe</code> 的每个 <code>chunk</code> 为 <code>64K</code>，通过该管道移动 <code>50MB</code> 数据所消耗的时间；</li>
<li>  <strong>AF UNIX:</strong> 两个进程之间建立 <code>unix stream socket</code> 连接，每个 <code>chunk</code> 为 <code>64K</code>，通过该 <code>socket</code> 传输 <code>10MB</code> 数据所用的时间；</li>
<li>  <strong>TCP:</strong> 同 <code>Pipe</code> 测试项，但进程间使用 <code>TCP/IP socket</code> 通信，传输数据量为 <code>3MB</code>；</li>
<li>  <strong>File reread:</strong> 读文件并将其汇总一起所用的时间；</li>
<li>  <strong>Mmap reread:</strong> 将文件 <code>mmap</code> 到内存中，从内存中读文件并将其汇总一起所用时间；</li>
<li>  <strong>Bcopy(libc):</strong> <code>do bw_mem $i bcopy</code>，从指定内存区域拷贝指定数量的字节内容到另一个指定内存区域的速度；</li>
<li>  <strong>Bcopy(hand):</strong> <code>do bw_mem %i fcp</code>，把数据从磁盘的一个位置拷贝到另一个位置所用的时间；</li>
<li>  <strong>Mem read:</strong> <code>bw_mem $i frd</code>，累加数组中的整数值，测试把数据读入 <code>processor</code> 的带宽；</li>
<li>  <strong>Mem write:</strong> <code>do bw_mem $i fwr</code>，把整数数组的每个成员设置为 <code>1</code>，测试写数据到内存的带宽。</li>
</ul>
<h3 id="内存操作延时"><a href="#内存操作延时" class="headerlink" title="内存操作延时"></a>内存操作延时</h3><p>如下输出结果单位均为 <code>ns</code>，数值越小表示性能越好。</p>
<p><img src="519df4da78a1a5fe20be94155a3bef88f10881afc24cb64b5a182c72247e3dbb.png" alt="picture 12">  </p>
<p>本地测试执行 <code>lat_mem_rd</code>，将整数数组中每第 <code>4</code> 个元素的值累加起来；测试的是读数据到 <code>processor</code> 的带宽。</p>
<ul>
<li>  <strong>L1：</strong> 缓存1</li>
<li>  <strong>L2：</strong> 缓存2</li>
<li>  <strong>Main Mem：</strong> 连续内存</li>
<li>  <strong>Rand Mem：</strong> 内存随机访问延时</li>
<li><strong>Guesses:</strong><br>  假如 <code>L1</code> 和 <code>L2</code> 近似，会显示 <code>“No L1 cache?”</code><br>  假如 <code>L2</code> 和 <code>Main Mem</code> 近似，会显示 <code>“No L2 cache?”</code></li>
</ul>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>LINUX</tag>
      </tags>
  </entry>
  <entry>
    <title>setcap提权</title>
    <url>/2024/02/27/setcap%E6%8F%90%E6%9D%83/</url>
    <content><![CDATA[<h3 id="setcap-命令"><a href="#setcap-命令" class="headerlink" title="setcap 命令"></a>setcap 命令</h3><p><strong>setcap</strong>（英文全拼：set capabilities）是在 Linux 系统中用于设置特殊权限的命令工具。它允许普通用户在执行特定程序时获得一些超过其正常权限的能力。具体来说，<code>setcap</code> 命令允许用户向可执行文件或动态链接库（共享对象）设置特殊的能力。这些能力使得程序能够执行某些通常需要超级用户权限才能完成的操作，例如绑定低于 1024 端口、访问摄像头、修改网络设置等。</p>
<span id="more"></span>

<p>通过使用 <code>setcap</code> 命令，用户不需要将整个程序以 root 身份运行，而只需为其设置所需的能力即可。这提供了更加灵活和安全的权限控制方式，同时避免了用户以超级用户身份运行程序带来的潜在风险。需要注意的是，<code>setcap</code> 命令需要以超级用户（root）身份执行，因为设置特殊能力是一个需要特权的操作。使用时应当慎重，确保仅将特定的能力赋予可信任的程序。</p>
<p><strong>语法</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setcap [-q] [-v] [-n &lt;rootid&gt;] (-r|-|&lt;caps&gt;) &lt;filename&gt;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>选项</strong>：</p>
<ul>
<li>  <code>-q</code>：以简洁方式输出。</li>
<li>  <code>-v</code>：用于验证指定的功能当前是否与该文件关联（v 是 verify 的意思）。如果提供了 <code>-v</code> 和 <code>-n</code>，则还会验证 <code>-n &lt;rootid&gt;</code> 参数。</li>
<li>  <code>-n &lt;rootid&gt;</code>：设置仅在具有此 rootid 所有者的命名空间中使用的文件功能。</li>
<li>  <code>-r</code>：从文件中删除功能集。请注意，设置空功能集与删除它不同，空集可用于保证文件不会以特权执行。</li>
<li>  <code>-</code>：从标准输入读取功能。在这种情况下，功能集以空行终止。</li>
</ul>
<p><strong>参数</strong>：</p>
<ul>
<li>  <code>caps</code>：功能集。详细参考下面说明。</li>
<li>  <code>filename</code>：文件名称。</li>
</ul>
<h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><p>Linux 内核从 2.2 版本开始，就增加了 Capabilities 的概念与机制，并随着版本升高逐步得到改进。在 Linux 中，root 权限被分割为以下 29 种能力：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CAP_CHOWN            # 修改文件属主的权限  </span><br><span class="line">CAP_DAC_OVERRIDE     # 忽略文件的 DAC 访问限制  </span><br><span class="line">CAP_DAC_READ_SEARCH  # 忽略文件读及目录搜索的 DAC 访问限制  </span><br><span class="line">CAP_FOWNER           # 忽略文件属主 ID 必须和进程用户 ID 相匹配的限制  </span><br><span class="line">CAP_FSETID           # 允许设置文件的 setuid 位  </span><br><span class="line">CAP_KILL             # 允许对不属于自己的进程发送信号  </span><br><span class="line">CAP_SETGID           # 允许改变进程的组 ID  </span><br><span class="line">CAP_SETUID           # 允许改变进程的用户 ID  </span><br><span class="line">CAP_SETPCAP          # 允许向其他进程转移能力以及删除其他进程的能力  </span><br><span class="line">CAP_LINUX_IMMUTABLE  # 允许修改文件的 IMMUTABLE 和 APPEND 属性标志  </span><br><span class="line">CAP_NET_BIND_SERVICE # 允许绑定到小于 1024 的端口  </span><br><span class="line">CAP_NET_BROADCAST    # 允许网络广播和多播访问  </span><br><span class="line">CAP_NET_ADMIN        # 允许执行网络管理任务  </span><br><span class="line">CAP_NET_RAW          # 允许使用原始套接字  </span><br><span class="line">CAP_IPC_LOCK         # 允许锁定共享内存片段  </span><br><span class="line">CAP_IPC_OWNER        # 忽略 IPC 所有权检查  </span><br><span class="line">CAP_SYS_MODULE       # 允许插入和删除内核模块  </span><br><span class="line">CAP_SYS_RAWIO        # 允许直接访问 /devport,/dev/mem,/dev/kmem 及原始块设备  </span><br><span class="line">CAP_SYS_CHROOT       # 允许使用 chroot() 系统调用  </span><br><span class="line">CAP_SYS_PTRACE       # 允许跟踪任何进程  </span><br><span class="line">CAP_SYS_PACCT        # 允许执行进程的 BSD 式审计  </span><br><span class="line">CAP_SYS_ADMIN        # 允许执行系统管理任务，如加载或卸载文件系统、设置磁盘配额等  </span><br><span class="line">CAP_SYS_BOOT         # 允许重新启动系统  </span><br><span class="line">CAP_SYS_NICE         # 允许提升优先级及设置其他进程的优先级  </span><br><span class="line">CAP_SYS_RESOURCE     # 忽略资源限制  </span><br><span class="line">CAP_SYS_TIME         # 允许改变系统时钟  </span><br><span class="line">CAP_SYS_TTY_CONFIG   # 允许配置 TTY 设备  </span><br><span class="line">CAP_MKNOD            # 允许使用 mknod() 系统调用  </span><br><span class="line">CAP_LEASE            # 允许修改文件锁的 FL_LEASE 标志  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用 <code>setcap</code> 命令可以分割 root 用户的特权，即将 root 的特权分割成不同的能力，每种能力代表一定的特权操作。例如，能力 <code>CAP_SYS_MODULE</code> 表示用户能够加载（或卸载）内核模块的特权操作，而 <code>CAP_SETUID</code> 表示用户能够修改进程用户身份的特权操作。在 Capbilities 中系统将根据进程拥有的能力来进行特权操作的访问控制。</p>
<p>在 Capilities 中，只有进程和可执行文件才具有能力，每个进程拥有三组能力集，分别称为 cap_effective、cap_inheritable、cap_permitted（分别简记为：<code>pE</code>、<code>pI</code>、<code>pP</code>），其中：</p>
<ul>
<li>  cap_permitted 表示进程所拥有的最大能力集；</li>
<li>  cap_effective 表示进程当前可用的能力集，可以看做是 cap_permitted 的一个子集；</li>
<li>  cap_inheitable 则表示进程可以传递给其子进程的能力集。</li>
</ul>
<p>系统根据进程的 cap_effective 能力集进行访问控制，cap_effective 为 cap_permitted 的子集，进程可以通过取消 cap_effective 中的某些能力来放弃进程的一些特权。</p>
<p>可执行文件也拥有三组能力集，对应于进程的三组能力集，分别称为 cap_effective、cap_allowed 和 cap_forced（分别简记为 <code>fE</code>、<code>fI</code>、<code>fP</code>），其中：</p>
<ul>
<li>  cap_allowed 表示程序运行时可从原进程的 cap_inheritable 中集成的能力集；</li>
<li>  cap_forced 表示运行文件时必须拥有才能完成其服务的能力集；</li>
<li>  cap_effective 则表示文件开始运行时可以使用的能力。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>安装 Wireshark 的时候，有一步是给 dumpcap 读网卡的权限，使得普通用户也可以使用 Wireshark 进行抓包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo setcap &#x27;CAP_NET_RAW+eip CAP_NET_ADMIN+eip&#x27; /usr/sbin/dumpcap  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>给可执行文件 /bin/ping 加上 “cap_net_admin,cap_net_raw+ep” 权限，普通用户即可使用 ping：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo setcap &#x27;cap_net_admin,cap_net_raw+ep&#x27; /bin/ping  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>给 nginx 加上使用 1024 以内端口的权限（无需 root 权限）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo setcap &#x27;cap_net_bind_service=+eip&#x27; /usr/sbin/nginx  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>清除 nginx 可执行文件附加的权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo setcap -r nginx  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>setcap</tag>
      </tags>
  </entry>
  <entry>
    <title>nvme pf直通vm</title>
    <url>/2024/02/04/nvme-pf%E7%9B%B4%E9%80%9Avm/</url>
    <content><![CDATA[<blockquote>
<p>查看设备的是否是pf，当前驱动</p>
</blockquote>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@jaguar-2288H-V7:/data# lspci -s 41:00.0 -v</span><br><span class="line">41:00.0 Non-Volatile memory controller: Device 1f53:1a00 (prog-if 02 [NVM Express])</span><br><span class="line">        Subsystem: Device 1f53:1a00</span><br><span class="line">        Physical Slot: 3-1</span><br><span class="line">        Flags: bus master, fast devsel, latency 0, NUMA node 0</span><br><span class="line">        Memory at d3fffc00000 (64-bit, prefetchable) [size=8K]</span><br><span class="line">        Memory at d3fffc02000 (64-bit, prefetchable) [size=4K]</span><br><span class="line">        Capabilities: [88] Power Management version 3</span><br><span class="line">        Capabilities: [4c] Express Endpoint, MSI 00</span><br><span class="line">        Capabilities: [40] MSI-X: Enable+ Count=3 Masked-</span><br><span class="line">        Kernel driver in use: nvme</span><br><span class="line">        Kernel modules: nvme</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@jaguar-2288H-V7:/data# lspci -s 41:00.0 -vv</span><br><span class="line">41:00.0 Non-Volatile memory controller: Device 1f53:1a00 (prog-if 02 [NVM Express])</span><br><span class="line">        Subsystem: Device 1f53:1a00</span><br><span class="line">        Physical Slot: 3-1</span><br><span class="line">        Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B- DisINTx+</span><br><span class="line">        Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast &gt;TAbort- &lt;TAbort- &lt;MAbort- &gt;SERR- &lt;PERR- INTx-</span><br><span class="line">        Latency: 0, Cache Line Size: 32 bytes</span><br><span class="line">        NUMA node: 0</span><br><span class="line">        Region 0: Memory at d3fffc00000 (64-bit, prefetchable) [size=8K]</span><br><span class="line">        Region 2: Memory at d3fffc02000 (64-bit, prefetchable) [size=4K]</span><br><span class="line">        Capabilities: [88] Power Management version 3</span><br><span class="line">                Flags: PMEClk- DSI- D1- D2- AuxCurrent=0mA PME(D0-,D1-,D2-,D3hot-,D3cold-)</span><br><span class="line">                Status: D0 NoSoftRst+ PME-Enable- DSel=0 DScale=0 PME-</span><br><span class="line">        Capabilities: [4c] Express (v2) Endpoint, MSI 00</span><br><span class="line">                DevCap: MaxPayload 512 bytes, PhantFunc 0, Latency L0s &lt;64ns, L1 &lt;1us</span><br><span class="line">                        ExtTag+ AttnBtn- AttnInd- PwrInd- RBE+ FLReset+ SlotPowerLimit 0.000W</span><br><span class="line">                DevCtl: CorrErr- NonFatalErr- FatalErr- UnsupReq-</span><br><span class="line">                        RlxdOrd+ ExtTag+ PhantFunc- AuxPwr- NoSnoop- FLReset-</span><br><span class="line">                        MaxPayload 256 bytes, MaxReadReq 4096 bytes</span><br><span class="line">                DevSta: CorrErr- NonFatalErr- FatalErr- UnsupReq- AuxPwr- TransPend-</span><br><span class="line">                LnkCap: Port #0, Speed 32GT/s, Width x16, ASPM L0s, Exit Latency L0s &lt;64ns</span><br><span class="line">                        ClockPM- Surprise- LLActRep+ BwNot+ ASPMOptComp-</span><br><span class="line">                LnkCtl: ASPM Disabled; RCB 64 bytes Disabled- CommClk-</span><br><span class="line">                        ExtSynch- ClockPM- AutWidDis- BWInt- AutBWInt-</span><br><span class="line">                LnkSta: Speed 32GT/s (ok), Width x16 (ok)</span><br><span class="line">                        TrErr- Train- SlotClk- DLActive- BWMgmt- ABWMgmt-</span><br><span class="line">                DevCap2: Completion Timeout: Range ABCD, TimeoutDis+, NROPrPrP-, LTR-</span><br><span class="line">                         10BitTagComp+, 10BitTagReq+, OBFF Not Supported, ExtFmt-, EETLPPrefix-</span><br><span class="line">                         EmergencyPowerReduction Not Supported, EmergencyPowerReductionInit-</span><br><span class="line">                         FRS-, TPHComp-, ExtTPHComp-</span><br><span class="line">                         AtomicOpsCap: 32bit- 64bit- 128bitCAS-</span><br><span class="line">                DevCtl2: Completion Timeout: 50us to 50ms, TimeoutDis-, LTR-, OBFF Disabled</span><br><span class="line">                         AtomicOpsCtl: ReqEn-</span><br><span class="line">                LnkCtl2: Target Link Speed: 32GT/s, EnterCompliance- SpeedDis-</span><br><span class="line">                         Transmit Margin: Normal Operating Range, EnterModifiedCompliance- ComplianceSOS-</span><br><span class="line">                         Compliance De-emphasis: -6dB</span><br><span class="line">                LnkSta2: Current De-emphasis Level: -6dB, EqualizationComplete+, EqualizationPhase1+</span><br><span class="line">                         EqualizationPhase2+, EqualizationPhase3+, LinkEqualizationRequest-</span><br><span class="line">        Capabilities: [40] MSI-X: Enable+ Count=3 Masked-</span><br><span class="line">                Vector table: BAR=2 offset=00000000</span><br><span class="line">                PBA: BAR=2 offset=00000c00</span><br><span class="line">        Kernel driver in use: nvme</span><br><span class="line">        Kernel modules: nvme</span><br></pre></td></tr></table></figure>

<p>libvirt xml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#cat nvme.xml </span><br><span class="line">&lt;domain type=&#x27;kvm&#x27; id=&#x27;1&#x27; xmlns:qemu=&#x27;http://libvirt.org/schemas/domain/qemu/1.0&#x27;&gt;</span><br><span class="line">        &lt;name&gt;vm_nvme&lt;/name&gt;</span><br><span class="line">        &lt;uuid&gt;0ba4f4d0-9a80-447e-a64c-e9c0d6c39ed8&lt;/uuid&gt;</span><br><span class="line">        &lt;memory unit=&#x27;KiB&#x27;&gt;4194304&lt;/memory&gt;</span><br><span class="line">        &lt;currentMemory unit=&#x27;KiB&#x27;&gt;4194304&lt;/currentMemory&gt;</span><br><span class="line">        &lt;vcpu placement=&#x27;static&#x27;&gt;10&lt;/vcpu&gt;</span><br><span class="line">        &lt;resource&gt;</span><br><span class="line">                &lt;partition&gt;/machine&lt;/partition&gt;</span><br><span class="line">        &lt;/resource&gt;</span><br><span class="line">        &lt;os&gt;</span><br><span class="line">                &lt;type arch=&#x27;x86_64&#x27; machine=&#x27;pc-i440fx-2.1&#x27;&gt;hvm&lt;/type&gt;</span><br><span class="line">                &lt;boot dev=&#x27;hd&#x27;/&gt;</span><br><span class="line">        &lt;/os&gt;</span><br><span class="line">        &lt;features&gt;</span><br><span class="line">                &lt;acpi/&gt;</span><br><span class="line">        &lt;/features&gt;</span><br><span class="line">        &lt;cpu mode=&#x27;custom&#x27; match=&#x27;exact&#x27; check=&#x27;full&#x27;&gt;</span><br><span class="line">                &lt;model fallback=&#x27;forbid&#x27;&gt;kvm64&lt;/model&gt;</span><br><span class="line">                &lt;feature policy=&#x27;require&#x27; name=&#x27;x2apic&#x27;/&gt;</span><br><span class="line">                &lt;feature policy=&#x27;require&#x27; name=&#x27;hypervisor&#x27;/&gt;</span><br><span class="line">        &lt;/cpu&gt;</span><br><span class="line">        &lt;clock offset=&#x27;utc&#x27;/&gt;</span><br><span class="line">        &lt;on_poweroff&gt;destroy&lt;/on_poweroff&gt;</span><br><span class="line">        &lt;on_reboot&gt;restart&lt;/on_reboot&gt;</span><br><span class="line">        &lt;on_crash&gt;destroy&lt;/on_crash&gt;</span><br><span class="line">        &lt;devices&gt;</span><br><span class="line">                &lt;emulator&gt;/root/pc-bios/qemu-system-x86_64&lt;/emulator&gt;</span><br><span class="line">                &lt;disk type=&#x27;file&#x27; device=&#x27;disk&#x27;&gt;</span><br><span class="line">                        &lt;driver name=&#x27;qemu&#x27; type=&#x27;raw&#x27;/&gt;</span><br><span class="line">                        &lt;source file=&#x27;/data/centos8.3-8g-ext4-host_vm2.img&#x27; index=&#x27;1&#x27;/&gt;</span><br><span class="line">                        &lt;backingStore/&gt;</span><br><span class="line">                        &lt;target dev=&#x27;hda&#x27; bus=&#x27;ide&#x27;/&gt;</span><br><span class="line">                        &lt;alias name=&#x27;ide0-0-0&#x27;/&gt;</span><br><span class="line">                        &lt;address type=&#x27;drive&#x27; controller=&#x27;0&#x27; bus=&#x27;0&#x27; target=&#x27;0&#x27; unit=&#x27;0&#x27;/&gt;</span><br><span class="line">                &lt;/disk&gt;</span><br><span class="line">                &lt;controller type=&#x27;pci&#x27; index=&#x27;0&#x27; model=&#x27;pci-root&#x27;&gt;</span><br><span class="line">                        &lt;alias name=&#x27;pci.0&#x27;/&gt;</span><br><span class="line">                &lt;/controller&gt;</span><br><span class="line">                &lt;controller type=&#x27;usb&#x27; index=&#x27;0&#x27; model=&#x27;piix3-uhci&#x27;&gt;</span><br><span class="line">                        &lt;alias name=&#x27;usb&#x27;/&gt;</span><br><span class="line">                        &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x01&#x27; function=&#x27;0x2&#x27;/&gt;</span><br><span class="line">                &lt;/controller&gt;</span><br><span class="line">                &lt;controller type=&#x27;ide&#x27; index=&#x27;0&#x27;&gt;</span><br><span class="line">                        &lt;alias name=&#x27;ide&#x27;/&gt;</span><br><span class="line">                        &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x01&#x27; function=&#x27;0x1&#x27;/&gt;</span><br><span class="line">                &lt;/controller&gt;</span><br><span class="line">                &lt;input type=&#x27;mouse&#x27; bus=&#x27;ps2&#x27;&gt;</span><br><span class="line">                        &lt;alias name=&#x27;input0&#x27;/&gt;</span><br><span class="line">                &lt;/input&gt;</span><br><span class="line">                &lt;input type=&#x27;keyboard&#x27; bus=&#x27;ps2&#x27;&gt;</span><br><span class="line">                        &lt;alias name=&#x27;input1&#x27;/&gt;</span><br><span class="line">                &lt;/input&gt;</span><br><span class="line">                &lt;graphics type=&#x27;vnc&#x27; port=&#x27;5900&#x27; autoport=&#x27;yes&#x27; listen=&#x27;0.0.0.0&#x27;&gt;</span><br><span class="line">                        &lt;listen type=&#x27;address&#x27; address=&#x27;0.0.0.0&#x27;/&gt;</span><br><span class="line">                &lt;/graphics&gt;</span><br><span class="line">                &lt;video&gt;</span><br><span class="line">                        &lt;model type=&#x27;cirrus&#x27; vram=&#x27;16384&#x27; heads=&#x27;1&#x27; primary=&#x27;yes&#x27;/&gt;</span><br><span class="line">                        &lt;alias name=&#x27;video0&#x27;/&gt;</span><br><span class="line">                        &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x02&#x27; function=&#x27;0x0&#x27;/&gt;</span><br><span class="line">                &lt;/video&gt;</span><br><span class="line">                &lt;hostdev mode=&#x27;subsystem&#x27; type=&#x27;pci&#x27; managed=&#x27;yes&#x27;&gt;</span><br><span class="line">                        &lt;driver name=&#x27;vfio&#x27;/&gt;</span><br><span class="line">                        &lt;source&gt;</span><br><span class="line">                                &lt;address domain=&#x27;0x0000&#x27; bus=&#x27;0x41&#x27; slot=&#x27;0x00&#x27; function=&#x27;0x0&#x27;/&gt;</span><br><span class="line">                        &lt;/source&gt;</span><br><span class="line">                        &lt;alias name=&#x27;hostdev0&#x27;/&gt;</span><br><span class="line">                        &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x0a&#x27; function=&#x27;0x0&#x27;/&gt;</span><br><span class="line">                &lt;/hostdev&gt;</span><br><span class="line">                &lt;memballoon model=&#x27;virtio&#x27;&gt;</span><br><span class="line">                        &lt;alias name=&#x27;balloon0&#x27;/&gt;</span><br><span class="line">                        &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x03&#x27; function=&#x27;0x0&#x27;/&gt;</span><br><span class="line">                &lt;/memballoon&gt;</span><br><span class="line">        &lt;/devices&gt;</span><br><span class="line">        &lt;seclabel type=&#x27;dynamic&#x27; model=&#x27;dac&#x27; relabel=&#x27;yes&#x27;&gt;</span><br><span class="line">                &lt;label&gt;+0:+0&lt;/label&gt;</span><br><span class="line">                &lt;imagelabel&gt;+0:+0&lt;/imagelabel&gt;</span><br><span class="line">        &lt;/seclabel&gt;</span><br><span class="line">        &lt;qemu:commandline&gt;</span><br><span class="line">                &lt;qemu:arg value=&#x27;-L&#x27;/&gt;</span><br><span class="line">                &lt;qemu:arg value=&#x27;/root/pc-bios&#x27;/&gt;</span><br><span class="line">        &lt;/qemu:commandline&gt;</span><br><span class="line">&lt;/domain&gt;</span><br></pre></td></tr></table></figure>
<p>这里<hostdev>设置managed=’yes’会将该设备从nvme驱动卸载绑定到指定驱动vfio</hostdev></p>
<p>执行<br>virsh create /data/nvme.xml<br>Domain ‘vm_nvme’ created from /data/nvme.xml</p>
<p>root@jaguar-2288H-V7:/data# virsh list<br> Id   Name      State</p>
<hr>
<p> 1    vm_nvme   running</p>
<p>root@jaguar-2288H-V7:/data# ps -ef | grep qemu<br>root        4654       1 99 22:03 ?        00:00:22 /root/pc-bios/qemu-system-x86_64 -name guest=vm_nvme,debug-threads=on -S -object {“qom-type”:”secret”,”id”:”masterKey0”,”format”:”raw”,”file”:”/var/local/lib/libvirt/qemu/domain-1-vm_nvme/master-key.aes”} -machine pc-i440fx-2.1,usb=off,dump-guest-core=off,memory-backend=pc.ram -accel kvm -cpu kvm64,x2apic=on,hypervisor=on -m 4096 -object {“qom-type”:”memory-backend-ram”,”id”:”pc.ram”,”size”:4294967296} -overcommit mem-lock=off -smp 10,sockets=10,cores=1,threads=1 -uuid 0ba4f4d0-9a80-447e-a64c-e9c0d6c39ed8 -no-user-config -nodefaults -chardev socket,id=charmonitor,fd=24,server=on,wait=off -mon chardev=charmonitor,id=monitor,mode=control -rtc base=utc -no-shutdown -boot strict=on -device {“driver”:”piix3-usb-uhci”,”id”:”usb”,”bus”:”pci.0”,”addr”:”0x1.0x2”} -blockdev {“driver”:”file”,”filename”:”/data/centos8.3-8g-ext4-host_vm2.img”,”node-name”:”libvirt-1-storage”,”auto-read-only”:true,”discard”:”unmap”} -blockdev {“node-name”:”libvirt-1-format”,”read-only”:false,”driver”:”raw”,”file”:”libvirt-1-storage”} -device {“driver”:”ide-hd”,”bus”:”ide.0”,”unit”:0,”drive”:”libvirt-1-format”,”id”:”ide0-0-0”,”bootindex”:1} -audiodev {“id”:”audio1”,”driver”:”none”} -vnc 0.0.0.0:0,audiodev=audio1 -device {“driver”:”cirrus-vga”,”id”:”video0”,”bus”:”pci.0”,”addr”:”0x2”} -device {“driver”:”vfio-pci”,”host”:”0000:41:00.0”,”id”:”hostdev0”,”bus”:”pci.0”,”addr”:”0xa”} -device {“driver”:”virtio-balloon-pci”,”id”:”balloon0”,”bus”:”pci.0”,”addr”:”0x3”} -L /root/pc-bios -msg timestamp=on<br>root        4685    3954  0 22:03 pts/0    00:00:00 grep –color=auto qemu<br>root@jaguar-2288H-V7:/data# </p>
<p>打开vnc，查看前端驱动类型</p>
<p><img src="../../images/e5a8ffb582c5b2516c61b44f27271b401e93ee600a583472f4cc703f20f001f1.png" alt="picture 0">  </p>
<p>查看nvme的fio配置<br><img src="../../images/42fbb6a61912b1489b5c1b8eb6a2e486c5e412c27698443e1e2e940c70c4a81c.png" alt="picture 1">  </p>
<p><strong>x86_64</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/root/qemu-system-x86_64 -name guest=vm,debug-threads=on \</span><br><span class="line">-drive if=virtio,file=/data/centos8.3-8g-ext4-host_vm2.img -daemonize \</span><br><span class="line">-machine pc-i440fx-2.1,usb=off,dump-guest-core=off -accel kvm -cpu kvm64 -m 2048 \</span><br><span class="line">-overcommit mem-lock=off -smp 2,sockets=2,cores=1,threads=1 \</span><br><span class="line">-uuid 8c6ebff0-eb21-11eb-a2af-0c48c6c88118 -no-user-config -nodefaults \</span><br><span class="line">-rtc base=utc -no-shutdown -boot strict=on \</span><br><span class="line">-device piix3-usb-uhci,id=usb,bus=pci.0,addr=0x1.0x2 \</span><br><span class="line">-device cirrus-vga,id=video0,bus=pci.0,addr=0x2 \</span><br><span class="line">-device vfio-pci,host=0000:8c:00.0,id=hostdev1,bus=pci.0,addr=0xc \</span><br><span class="line">-device virtio-balloon-pci,id=balloon0,bus=pci.0,addr=0x3 \</span><br><span class="line">-L /root/pc-bios \</span><br><span class="line">-vnc :1 \</span><br><span class="line">-msg timestamp=on</span><br></pre></td></tr></table></figure>

<p><strong>aarch64</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/rma/qemu_620/install_dir/bin/qemu-system-aarch64 -name vm0 -machine virt,accel=kvm,usb=off \</span><br><span class="line">-cpu host -m 2048 -smp 2,sockets=1,cores=2,threads=1 \</span><br><span class="line">-boot menu=on \</span><br><span class="line">-hda centos8.6_arm.img \</span><br><span class="line">-device vfio-pci,host=8b:00.1,id=hostdev0,addr=0x9 \</span><br><span class="line">-device vfio-pci,host=8c:00.1,id=hostdev1,addr=0x10 \</span><br><span class="line">-bios /usr/share/qemu-efi-aarch64/QEMU_EFI.fd \</span><br><span class="line">-vnc :50 \</span><br><span class="line">-monitor stdio</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>manifest管理repo</title>
    <url>/2024/01/04/manifest%E7%AE%A1%E7%90%86repo/</url>
    <content><![CDATA[<h3 id="repo是什么？"><a href="#repo是什么？" class="headerlink" title="repo是什么？"></a>repo是什么？</h3><p>repo是Google开发的用于管理Android版本库的一个工具，repo是使用Python对git进行了一定的封装，并不是用于取代git，它简化了对多个Git版本库的管理。用repo管理的版本库都需要使用git命令来进行操作。<strong>因此，使用repo工具之前，请先确保已经安装git。</strong></p>
<span id="more"></span>

<h3 id="为什么要用repo？"><a href="#为什么要用repo？" class="headerlink" title="为什么要用repo？"></a>为什么要用repo？</h3><p>项目模块化/组件化之后各模块也作为独立的 Git 仓库从主项目里剥离了出去，各模块各自管理自己的版本。Android<a href="https://so.csdn.net/so/search?q=%E6%BA%90%E7%A0%81&spm=1001.2101.3001.7020">源码</a>引用了很多开源项目，每一个子项目都是一个Git仓库，每个Git仓库都有很多分支版本，为了方便统一管理各个子项目的Git仓库，需要一个上层工具批量进行处理，因此repo诞生。<br>repo也会建立一个Git仓库，用来记录当前Android版本下各个子项目的Git仓库分别处于哪一个分支，这个仓库通常叫做：manifest仓库(清单库)。</p>
<h3 id="repo下载安装"><a href="#repo下载安装" class="headerlink" title="repo下载安装"></a>repo下载安装</h3><p>下载地址：<a href="https://mirrors.tuna.tsinghua.edu.cn/git/git-repo">https://mirrors.tuna.tsinghua.edu.cn/git/git-repo</a> ，将下载下来的文件命名为repo，放在PATH环境变量所包含的目录下面，例如可以放在<code>/usr/local/bin</code>目录下（后面介绍均以放在<code>/usr/local/bin</code>目录下为例）。</p>
<p>或者，直接使用curl命令下载：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo &gt; /usr/local/bin/repo</span><br></pre></td></tr></table></figure>

<p>最后，修改repo文件的执行权限：<code>chmod 777 /usr/local/bin/repo</code>。</p>
<h3 id="repo命令介绍"><a href="#repo命令介绍" class="headerlink" title="repo命令介绍"></a>repo命令介绍</h3><p><strong>repo init</strong><br><code>u</code>：指定一个URL，其连接到一个manifest仓库<br><code>m</code>：在manifest仓库中选择一个xml文件，如果未选择，默认指向default.xml<br><code>b</code>：选择一个maniest仓库中的一个特殊的分支<br>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repo init -u git@github.com:rma0227/manifest.git -b main -m my_manifest.xml</span><br></pre></td></tr></table></figure>
<p>my_manifest.xml:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;manifest&gt;</span><br><span class="line">  &lt;remote name=&quot;jansson&quot; fetch=&quot;https://github.com/akheron/&quot;/&gt;</span><br><span class="line">  &lt;remote name=&quot;json-c&quot; fetch=&quot;https://github.com/json-c/&quot;/&gt;</span><br><span class="line">  &lt;remote name=&quot;yajl&quot; fetch=&quot;https://github.com/lloyd/&quot;/&gt;</span><br><span class="line">  &lt;remote name=&quot;cjson&quot; fetch=&quot;https://github.com/DaveGamble/&quot;/&gt;</span><br><span class="line">  &lt;remote name=&quot;yyjson&quot; fetch=&quot;https://github.com/ibireme/&quot;/&gt;</span><br><span class="line"></span><br><span class="line">  &lt;default revision=&quot;refs/heads/master&quot; sync-j=&quot;4&quot;/&gt;</span><br><span class="line">  &lt;project remote=&quot;jansson&quot; path=&quot;jansson&quot; name=&quot;jansson.git&quot; /&gt;</span><br><span class="line">  &lt;project remote=&quot;json-c&quot; path=&quot;json-c&quot; name=&quot;json-c.git&quot; /&gt;</span><br><span class="line">  &lt;project remote=&quot;yajl&quot; path=&quot;yajl&quot; name=&quot;yajl.git&quot; /&gt;</span><br><span class="line">  &lt;project remote=&quot;cjson&quot; path=&quot;cjson&quot; name=&quot;cJSON.git&quot; /&gt;</span><br><span class="line">  &lt;project remote=&quot;yyjson&quot; path=&quot;yyjson&quot; name=&quot;yyjson.git&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/manifest&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意，此处命令中 -b main 是指manifest.git 这个repo的branch，可以根据自己的manifest.git的信息，进行设置</p>
<p><strong>repo sync</strong><br>下载manifest中指定xml设置的repo仓库，如上例中的my_manifest.xml所配置的repo信息。执行完sync命令后，每个project的HEAD指向xml配置的该project revision分支的头节点。</p>
<p><strong>repo start</strong><br>将本地代码切换到指定分支，注意：此处branch name仅仅是本地的，不和远端branch name关联，这个和git checkout 命令不同</p>
<p>整体命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repo init -u git@github.com:rma0227/manifest.git -b main -m my_manifest.xml</span><br><span class="line"></span><br><span class="line">repo sync</span><br><span class="line"></span><br><span class="line">repo start master --all</span><br></pre></td></tr></table></figure>

<h3 id="manifest-xml简介"><a href="#manifest-xml简介" class="headerlink" title="manifest xml简介"></a>manifest xml简介</h3><p><strong>remote元素</strong><br>设置远程git服务器的属性，包括下面的属性：</p>
<p><code>name</code>: 远程git服务器的名字，直接用于git fetch, git remote 等操作<br><code>alias</code>: 远程git服务器的别名，如果指定了，则会覆盖name的设定。在一个manifest中， name不能重名，但alias可以重名。<br><code>fetch</code>: 所有projects的git URL 前缀<br>一个manifest文件中可以配置多个remote元素，用于配置不同的project默认下载指向。</p>
<p><strong>default元素</strong><br>设定所有projects的默认属性值，如果在project元素里没有指定一个属性，则使用default元素的属性值。</p>
<p><code>remote</code>: 之前定义的某一个remote元素中name属性值，用于指定使用哪一个远程git服务器。<br><code>revision</code>: git分支的名字，例如master或者refs/heads/master<br><code>sync_j</code>: 在repo sync中默认并行的数目。<br><code>sync_c</code>: 如果设置为true，则只同步指定的分支(revision 属性指定)，而不是所有的ref内容。<br><code>sync_s</code>: 如果设置为true，则会同步git的子项目</p>
<p><strong>project元素</strong><br>指定一个需要clone的git仓库。</p>
<p><code>name</code>: 唯一的名字标识project，同时也用于生成git仓库的URL。格式如下：<br>      ${remote_fetch}/${project_name}<br><code>path</code>: 可选的路径。指定git clone出来的代码存放在本地的子目录。如果没有指定，则以name作为子目录名。<br><code>remote</code>: 指定之前在某个remote元素中的name。<br><code>revision</code>: 指定需要获取的git提交点，可以是master, refs/heads/master, tag或者SHA-1值。如果不设置的话，默认下载当前project，当前分支上的最新代码。</p>
<p>示例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;manifest&gt;</span><br><span class="line">  &lt;remote name=&quot;corsica&quot; fetch=&quot;ssh://git@bit.jaguarmicro.com:7999/jsc/&quot;/&gt;    -----remote元素，定义remote name 对应的git 仓库地址</span><br><span class="line">  &lt;remote name=&quot;cloud&quot; fetch=&quot;ssh://git@bit.jaguarmicro.com:7999/jac/&quot;/&gt;</span><br><span class="line">  &lt;remote name=&quot;jsw&quot; fetch=&quot;ssh://git@bit.jaguarmicro.com:7999/jag/&quot; /&gt;</span><br><span class="line">  &lt;remote name=&quot;infra&quot; fetch=&quot;ssh://git@bit.jaguarmicro.com:7999/jsi/&quot; /&gt;</span><br><span class="line">  &lt;remote name=&quot;kernel&quot; fetch=&quot;ssh://git@bit.jaguarmicro.com:7999/jsk/&quot; /&gt;</span><br><span class="line">  &lt;remote name=&quot;sim&quot; fetch=&quot;ssh://git@bit.jaguarmicro.com:7999/jsim/&quot; /&gt;</span><br><span class="line">   </span><br><span class="line">  &lt;default remote=&quot;corsica&quot; revision=&quot;refs/heads/corsica_dpu_dev&quot; sync-j=&quot;4&quot;/&gt;  -----default元素，定义了默认的remote name 、branch分支、repo sync并行数目</span><br><span class="line">   </span><br><span class="line">  &lt;!-- Platform Zone --&gt;</span><br><span class="line">  &lt;project remote=&quot;corsica&quot; path=&quot;jmnd-dpu-corsica&quot; name=&quot;jmnd-dpu-corsica.git&quot; groups=&quot;drsm&quot;/&gt;  ----project元素</span><br><span class="line">  &lt;project remote=&quot;corsica&quot; path=&quot;jmnd-dpu-corsica/drsm&quot; name=&quot;corsica-drsm.git&quot; groups=&quot;drsm&quot; /&gt;</span><br><span class="line">  &lt;project remote=&quot;corsica&quot; path=&quot;jmnd-dpu-corsica/drsm/dral-soc&quot; name=&quot;dral-soc.git&quot; groups=&quot;drsm&quot; /&gt;</span><br><span class="line">  &lt;project remote=&quot;corsica&quot; path=&quot;jmnd-dpu-corsica/drsm/dral-soc/io_mgr&quot; name=&quot;soc-io-mgr.git&quot; groups=&quot;drsm&quot; /&gt;</span><br><span class="line">  &lt;project remote=&quot;corsica&quot; path=&quot;jmnd-dpu-corsica/drsm/dral-soc/resource_mgr&quot; name=&quot;soc-res-mgr.git&quot; groups=&quot;drsm&quot; /&gt;</span><br><span class="line">  &lt;project remote=&quot;cloud&quot; path=&quot;jmnd-dpu-corsica/drsm/ovs&quot; name=&quot;ovs.git&quot; groups=&quot;drsm&quot; /&gt;</span><br><span class="line">  &lt;project remote=&quot;cloud&quot; path=&quot;jmnd-dpu-corsica/drsm/spdk&quot; name=&quot;spdk.git&quot; groups=&quot;drsm&quot; /&gt;</span><br><span class="line">  &lt;project remote=&quot;infra&quot; path=&quot;jmnd-dpu-corsica/drsm/admin&quot; name=&quot;jmnd-hypervisor.git&quot; groups=&quot;drsm&quot; /&gt;</span><br><span class="line">  &lt;project remote=&quot;infra&quot; path=&quot;jmnd-dpu-corsica/drsm/oprom&quot; name=&quot;oprom.git&quot; groups=&quot;drsm&quot; /&gt;</span><br><span class="line">  &lt;project remote=&quot;infra&quot; path=&quot;jmnd-dpu-corsica/drsm/tools/univer-tools&quot; name=&quot;univer-tools.git&quot; groups=&quot;drsm&quot; /&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;project remote=&quot;jsw&quot; path=&quot;jmnd-dpu-corsica/rdma&quot; name=&quot;rdma-corsica.git&quot; groups=&quot;rmda&quot;/&gt;</span><br><span class="line">  &lt;project remote=&quot;jsw&quot; path=&quot;jmnd-dpu-corsica/rdma/ci&quot; name=&quot;ci.git&quot; revision=&quot;refs/heads/rdma-dev&quot; groups=&quot;rmda&quot;/&gt;</span><br><span class="line">  &lt;project remote=&quot;jsw&quot; path=&quot;jmnd-dpu-corsica/rdma/rdma-core&quot; name=&quot;rdma-core.git&quot; revision=&quot;refs/heads/rdma-dev&quot; groups=&quot;rmda&quot;/&gt;</span><br><span class="line">  &lt;project remote=&quot;corsica&quot; path=&quot;jmnd-dpu-corsica/rdma/rpe_header&quot; name=&quot;chip-headers.git&quot; groups=&quot;rmda&quot;/&gt;</span><br><span class="line">  &lt;project remote=&quot;kernel&quot; path=&quot;jmnd-dpu-corsica/rdma/kernel&quot; name=&quot;kernel-linux-5.10-back.git&quot; revision=&quot;refs/heads/rdma-dev&quot; groups=&quot;rmda&quot;/&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;project remote=&quot;jsw&quot; path=&quot;jmnd-dpu-corsica/p4/p4c&quot; name=&quot;p4c.git&quot; groups=&quot;p4&quot;/&gt;</span><br><span class="line">  &lt;project remote=&quot;jsw&quot; path=&quot;jmnd-dpu-corsica/p4/common&quot; name=&quot;p4-common.git&quot; groups=&quot;p4&quot;/&gt;</span><br><span class="line">  &lt;project remote=&quot;jsw&quot; path=&quot;jmnd-dpu-corsica/p4/riscv-gnu-toolchain&quot; name=&quot;riscv-gnu-toolchain.git&quot; groups=&quot;p4&quot;/&gt;</span><br><span class="line">  &lt;project remote=&quot;jsw&quot; path=&quot;jmnd-dpu-corsica/p4/p4-ci-test&quot; name=&quot;p4-ci-test.git&quot; revision=&quot;refs/heads/master&quot; groups=&quot;p4&quot;/&gt;</span><br><span class="line">   </span><br><span class="line">  &lt;project remote=&quot;sim&quot; path=&quot;jmnd-dpu-corsica/sim/imu&quot; name=&quot;corsica-sim-imu.git&quot; groups=&quot;sim&quot;/&gt;</span><br><span class="line">  &lt;project remote=&quot;sim&quot; path=&quot;jmnd-dpu-corsica/sim/dpe&quot; name=&quot;corsica-sim-dpe.git&quot; groups=&quot;sim&quot;/&gt;</span><br><span class="line">  &lt;project remote=&quot;sim&quot; path=&quot;jmnd-dpu-corsica/sim/qemu&quot; name=&quot;corsica-sim-qemu.git&quot; groups=&quot;sim&quot;/&gt;</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure>

<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><h4 id="建立自己的manifest仓库"><a href="#建立自己的manifest仓库" class="headerlink" title="建立自己的manifest仓库"></a>建立自己的manifest仓库</h4><p>可以参考下面脚本修改（自己没有权限的repo，一定要从xml中删除）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;manifest&gt;</span><br><span class="line">  &lt;remote name=&quot;corsica&quot; fetch=&quot;ssh://git@bit.jaguarmicro.com:7999/jsc/&quot;/&gt;</span><br><span class="line">  &lt;!-- define private remote name by your name --&gt;</span><br><span class="line">  &lt;remote name=&quot;pri&quot; fetch=&quot;ssh://git@bit.jaguarmicro.com:7999/~qiulei.xu&quot;/&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;default remote=&quot;corsica&quot; revision=&quot;refs/heads/corsica_dpu_dev&quot; sync-j=&quot;4&quot;/&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;!-- Platform Zone --&gt;</span><br><span class="line">  &lt;project remote=&quot;corsica&quot; path=&quot;dral-soc&quot; name=&quot;dral-soc.git&quot;/&gt;</span><br><span class="line">  &lt;!-- project remote=&quot;corsica&quot; path=&quot;dral-soc/resource_mgr&quot; name=&quot;soc-res-mgr.git&quot; --/&gt;</span><br><span class="line">  &lt;!-- If you use a private library, replace the previous one with the following configuration  --&gt;</span><br><span class="line">  &lt;project remote=&quot;pri&quot; path=&quot;dral-soc/resource_mgr&quot; name=&quot;soc-res-mgr.git&quot; &gt;     --------此处代码从自己个人库中下</span><br><span class="line">  &lt;project remote=&quot;corsica&quot; path=&quot;dral-soc/ext-lib&quot; name=&quot;ext-lib.git&quot;/&gt;</span><br><span class="line">  &lt;project remote=&quot;corsica&quot; path=&quot;dral-soc/libdpu_soc/msg&quot; name=&quot;dpu-soc-msg.git&quot; /&gt;</span><br><span class="line">  &lt;project remote=&quot;corsica&quot; path=&quot;dral-soc/libdpu_soc/include/platform/corsica/chip-headers&quot; name=&quot;chip-headers.git&quot; revision=&quot;refs/heads/corsica_dpu_dev_B300&quot;/&gt;</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure>

<h4 id="执行repo命令下载代码"><a href="#执行repo命令下载代码" class="headerlink" title="执行repo命令下载代码"></a>执行repo命令下载代码</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repo init -u ssh://git@bit.jaguarmicro.com:7999/xxxx/manifest.git -b corsica_dpu_dev -m dral_soc.xml（确保这个xml里的所有repo你都有权限，没有权限的project需要删掉）</span><br><span class="line">repo sync</span><br><span class="line">repo start corsica_dpu_dev --all</span><br></pre></td></tr></table></figure>

<h4 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h4><p>下载代码修改验证后，如需提交，到path目录下，例如修改了上面的dral-soc.git repo中的代码，则进入dral-soc目录，执行如下操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add</span><br><span class="line">git commit</span><br><span class="line">git push corsica(remote name) HEAD:corsica_dpu_dev(branch name for remote)</span><br></pre></td></tr></table></figure>

<p>注意：push命令，需要指定远端仓库名称（remote name），远端代码分支名称，远端仓库和分支名称可以通过git branch -a查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@jm222:dral-soc# git branch -a</span><br><span class="line">* local_corsica_dev</span><br><span class="line">  remotes/corsica/corsica_dpu_dev</span><br><span class="line">  remotes/corsica/corsica_pt_B300</span><br><span class="line">  remotes/m/corsica_dpu_dev -&gt; corsica/corsica_dpu_dev  -------此信息提供了remote name:corsica, branch:corsica_dpu_dev</span><br></pre></td></tr></table></figure>
<p>如果本地分支名称和xml中配置的远端分支名称相同，可以简化git push命令，直接调用git push就可以提交代码</p>
]]></content>
      <categories>
        <category>GIT</category>
      </categories>
      <tags>
        <tag>manifest</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu下rust安装配置</title>
    <url>/2024/01/03/Ubuntu%E4%B8%8Brust%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="安装rust"><a href="#安装rust" class="headerlink" title="安装rust"></a>安装rust</h3><blockquote>
<p>安装curl</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install curl</span><br></pre></td></tr></table></figure>
<blockquote>
<p>安装rust</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl https://sh.rustup.rs -sSf | sh</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<blockquote>
<p>​选择1默认安装</p>
</blockquote>
<blockquote>
<p>环境变量生效</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source $HOME/.cargo/env</span><br></pre></td></tr></table></figure>

<blockquote>
<p>查看版本</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rustc -V</span><br></pre></td></tr></table></figure>

<h3 id="rust-analyzer加载时间过长"><a href="#rust-analyzer加载时间过长" class="headerlink" title="rust-analyzer加载时间过长"></a>rust-analyzer加载时间过长</h3><p>开发环境:<br>vscode+rust-analyzer</p>
<p>问题：<br>vscode一直卡在<code>fetching metadata</code>阶段。</p>
<p>方法:<br>运行<code>cargo metadata</code>,发现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Blocking waiting for file lock on package cache</span><br></pre></td></tr></table></figure>
<p>运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm -rf ~/.cargo/.package-cache</span><br></pre></td></tr></table></figure>
<p>删除cargo的缓存，而后再运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cargo metadata</span><br></pre></td></tr></table></figure>

<h3 id="Cargo-build失败解决办法"><a href="#Cargo-build失败解决办法" class="headerlink" title="Cargo build失败解决办法"></a>Cargo build失败解决办法</h3><p><strong>现象</strong><br>cargo build 时下载失败, 提示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">error: failed to download from `https://crates-io.proxy.ustclug.org/api/v1/crates/actix-codec/0.3.0/download`</span><br><span class="line"></span><br><span class="line">Caused by:  </span><br><span class="line">[56] Failure when receiving data from the peer (Received HTTP code 500 from proxy after CONNECT)</span><br></pre></td></tr></table></figure>
<p><strong>解决</strong><br>vim ~/.cargo/config</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 放到 `$HOME/.cargo/config` 文件中</span><br><span class="line">[source.crates-io]</span><br><span class="line">registry = &quot;https://github.com/rust-lang/crates.io-index&quot;</span><br><span class="line"></span><br><span class="line"># 替换成你偏好的镜像源</span><br><span class="line">replace-with = &#x27;sjtu&#x27;</span><br><span class="line">#replace-with = &#x27;ustc&#x27;</span><br><span class="line"></span><br><span class="line"># 清华大学</span><br><span class="line">[source.tuna]</span><br><span class="line">registry = &quot;https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git&quot;</span><br><span class="line"></span><br><span class="line"># 中国科学技术大学</span><br><span class="line">[source.ustc]</span><br><span class="line">registry = &quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;</span><br><span class="line"></span><br><span class="line"># 上海交通大学</span><br><span class="line">[source.sjtu]</span><br><span class="line">registry = &quot;https://mirrors.sjtug.sjtu.edu.cn/git/crates.io-index&quot;</span><br><span class="line"></span><br><span class="line"># rustcc社区</span><br><span class="line">[source.rustcc]</span><br><span class="line">registry = &quot;git://crates.rustcc.cn/crates.io-index&quot;</span><br><span class="line"></span><br><span class="line">[net]</span><br><span class="line">git-fetch-with-cli=true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>变为上海交通大学的源，最重要的是 最后net的参数，设置为从git拉取。git不会被墙。</p>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>DOCA 开发容器</title>
    <url>/2023/04/08/DOCA-%E5%BC%80%E5%8F%91%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h2 id="前提准备"><a href="#前提准备" class="headerlink" title="前提准备"></a>前提准备</h2><blockquote>
<p>Note: 运行 <code>DOCA</code> 的<code>Linux Docker</code> 容器所需的最低 <code>Docker</code> 引擎版本为 <code>19.03</code>。  </p>
</blockquote>
<span id="more"></span>

<ul>
<li><p>  在主机系统上，从<a href="https://www.docker.com/">https://www.docker.com/</a>下载您的组织所需的 Docker 软件类型（企业版、桌面版或其他）。</p>
</li>
<li><p>或者，从<a href="https://get.docker.com/">https://get.docker.com/</a> 下载安装脚本，并使用类似于以下内容的命令在主机系统上安装DRIVE OS Docker：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget -qO- https://get.docker.com/ | $&#123;SHELL&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="NVIDIA-GPU-云访问"><a href="#NVIDIA-GPU-云访问" class="headerlink" title="NVIDIA GPU 云访问"></a>NVIDIA GPU 云访问</h2><p>为了访问<a href="http://ngc.nvidia.com/">NVIDIA GPU Cloud (NGC)</a>，需要一个<a href="http://developer.nvidia.com/">NVIDIA 开发者帐户</a>。请先注册一个帐户并申请开发者计划的会员资格，然后再继续。</p>
<h2 id="登录-NVIDIA-GPU-云"><a href="#登录-NVIDIA-GPU-云" class="headerlink" title="登录 NVIDIA GPU 云"></a>登录 NVIDIA GPU 云</h2><blockquote>
<p>注意：请确保您已收到 NGC 激活电子邮件并成功激活您的 NGC 组织和 NGC 团队，然后再继续。   </p>
</blockquote>
<ul>
<li>在主机系统上，使用您的 NVIDIA 开发人员凭据登录 NGC(<a href="https://ngc.nvidia.com/">https://ngc.nvidia.com</a>) 。</li>
<li> 登录后，选择页面右上角“用户”菜单下的“设置”以生成 API 密钥来提取 Docker 映像。</li>
</ul>
<p><img src="b194e5d858b239bf7cc779ee840a29867f4751ad27b8f3def18c5fc572ed63eb.png" alt="picture 0">  </p>
<p>使用参考<br>    <a href="https://docs.nvidia.com/ngc/ngc-overview/index.html#generating-api-key">https://docs.nvidia.com/ngc/ngc-overview/index.html#generating-api-key</a></p>
<ul>
<li><p>登录 NGC 容器注册表.</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker login nvcr.io</span><br></pre></td></tr></table></figure>
</li>
<li><p>当提示您输入用户名时，请输入以下文本:</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$oauthtoken</span><br></pre></td></tr></table></figure>
<p>  用户$oauthtoken名是一个特殊的用户名，表示您将使用 API 密钥进行身份验证，而不是用户名和密码。</p>
</li>
<li><p>当提示输入密码时，输入您的 NGC API 密钥，如下例所示:</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Username: $oauthtoken </span><br><span class="line">Password: _my-api-key_</span><br><span class="line">## 或者</span><br><span class="line">docker login  nvcr.io  -u &#x27;$oauthtoken&#x27; -p _my-api-key_</span><br></pre></td></tr></table></figure>
<p>  有关登录方法的更多信息，请参阅<a href="https://docs.docker.com/engine/reference/commandline/login/">Docker 登录文档</a>。</p>
</li>
<li><p>拉取镜像:</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull nvcr.io/nvidia/doca/doca:1.5.0-devel</span><br></pre></td></tr></table></figure></li>
<li><p>运行:</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --rm --privileged multiarch/qemu-user-static --reset --persistent yes</span><br><span class="line"></span><br><span class="line">docker run --name doca_dev -itd nvcr.io/nvidia/doca/doca:1.5.0-devel bash</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>DOCA</category>
      </categories>
      <tags>
        <tag>DOCA</tag>
      </tags>
  </entry>
  <entry>
    <title>cloud-hypervisor</title>
    <url>/2023/04/08/cloud-hypervisor/</url>
    <content><![CDATA[<h3 id="cloud-hypervisor-单独启动，带一个net设备"><a href="#cloud-hypervisor-单独启动，带一个net设备" class="headerlink" title="cloud-hypervisor 单独启动，带一个net设备"></a>cloud-hypervisor 单独启动，带一个net设备</h3><p>内核版本：4.18.0+（不同版本的cloud-hypervisor对内核的最低版本有要求，不匹配cloud-hypervisor无法运行）</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 下载cloud-hypervisor最新版本（static版本，无需动态库依赖）</span><br><span class="line">wget https://github.com/cloud-hypervisor/cloud-hypervisor/releases/download/v22.0/cloud-hypervisor-static</span><br><span class="line">mv cloud-hypervisor-static  cloud-hypervisor</span><br><span class="line">setcap cap_net_admin+ep ./cloud-hypervisor</span><br><span class="line">chmod +x cloud-hypervisor</span><br><span class="line"> </span><br><span class="line"># 下载 Ubuntu 云镜像，使用 qemu-img 转换其格式</span><br><span class="line">wget https://cloud-images.ubuntu.com/focal/current/focal-server-cloudimg-amd64.img</span><br><span class="line">qemu-img convert -p -f qcow2 -O raw focal-server-cloudimg-amd64.img focal-server-cloudimg-amd64.raw</span><br><span class="line"> </span><br><span class="line"># 下载虚拟化管理程序的固件</span><br><span class="line">wget https://github.com/cloud-hypervisor/rust-hypervisor-firmware/releases/download/0.4.2/hypervisor-fw</span><br><span class="line"> </span><br><span class="line"># 拉取cloud-hypervisor仓库</span><br><span class="line">git clone https://github.com/cloud-hypervisor/cloud-hypervisor</span><br><span class="line">cd cloud-hypervisor</span><br><span class="line"> </span><br><span class="line"># 拷贝cloud init脚本并执行(该脚本会会生成init镜像到/tmp/ubuntu-cloudinit.img，将用户名密码初始化为cloud/cloud123等)</span><br><span class="line">cp scripts/create-cloud-init.sh create-cloud-init.sh</span><br><span class="line">chmod +x create-cloud-init.sh</span><br><span class="line">./create-cloud-init.sh</span><br><span class="line"> </span><br><span class="line"># 启动cloud-hypervisor（后端虚机创建，前端加载好vfio驱动）</span><br><span class="line">./cloud-hypervisor \</span><br><span class="line">    --kernel ./hypervisor-fw \</span><br><span class="line">    --disk path=focal-server-cloudimg-amd64.raw path=/tmp/ubuntu-cloudinit.img \</span><br><span class="line">    --cpus boot=4 \</span><br><span class="line">    --memory size=1024M \</span><br><span class="line">    --device path=/sys/bus/pci/devices/0000:b8:00.1</span><br><span class="line"> </span><br><span class="line"># 虚拟机中一开始看不到网卡，需手动加载驱动</span><br><span class="line">echo virtio-pci &gt; /sys/bus/pci/devices/0000\:00\:04.0/driver_override</span><br><span class="line">echo 0000:00:04.0 &gt; /sys/bus/pci/drivers_probe</span><br><span class="line"> </span><br><span class="line"># 驱动加载完成可看到设备</span><br><span class="line">root@cloud:/home/cloud# ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens4: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/ether 52:54:00:00:23:49 brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure>


<h3 id="安装kata和containerd，测试启动默认安全容器"><a href="#安装kata和containerd，测试启动默认安全容器" class="headerlink" title="安装kata和containerd，测试启动默认安全容器"></a>安装kata和containerd，测试启动默认安全容器</h3><p>参考此文档 <a href="https://github.com/containerd/containerd/blob/main/docs/getting-started.md%EF%BC%8C%E5%85%88%E5%AE%89%E8%A3%85%E5%A5%BDcontainerd">https://github.com/containerd/containerd/blob/main/docs/getting-started.md，先安装好containerd</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 下载kata安装包</span><br><span class="line">wget https://github.com/kata-containers/kata-containers/releases/download/3.2.0/kata-static-3.2.0-amd64.tar.xz</span><br><span class="line"> </span><br><span class="line"># 解压安装</span><br><span class="line">mv kata-static-3.2.0-amd64.tar.xz /</span><br><span class="line">cd /</span><br><span class="line">xz -d &lt; kata-static-3.2.0-amd64.tar.xz | tar -xvf -</span><br><span class="line">export PATH=$PATH:/opt/kata/bin</span><br><span class="line"> </span><br><span class="line"># 创建符号链接，否则后续containerd会找不到containerd-shim-kata-v2</span><br><span class="line">ln -s /opt/kata/bin/containerd-shim-kata-v2 /usr/local/bin/containerd-shim-kata-v2</span><br><span class="line"> </span><br><span class="line"># 生成containerd默认配置</span><br><span class="line">containerd config default &gt; /etc/containerd/config.toml</span><br><span class="line"> </span><br><span class="line"># 修改以下内容（containerd默认采用runc，改为kata）</span><br><span class="line">[plugins]</span><br><span class="line">  [plugins.&quot;io.containerd.grpc.v1.cri&quot;]</span><br><span class="line">    [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd]</span><br><span class="line">      default_runtime_name = &quot;kata&quot;</span><br><span class="line">      [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes]</span><br><span class="line">        [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.kata]</span><br><span class="line">          runtime_type = &quot;io.containerd.kata.v2&quot;</span><br><span class="line"> </span><br><span class="line"># 重启containerd服务</span><br><span class="line">systemctl restart containerd.service</span><br><span class="line"> </span><br><span class="line"># 测试busybox容器</span><br><span class="line">image=&quot;docker.io/library/busybox:latest&quot;</span><br><span class="line">ctr image pull &quot;$image&quot;</span><br><span class="line">ctr run --runtime &quot;io.containerd.kata.v2&quot; --rm -t &quot;$image&quot; test-kata sh</span><br><span class="line"> </span><br><span class="line"># 容器中查看内核版本，跟host不同</span><br><span class="line">/ # uname -a</span><br><span class="line">Linux localhost 6.1.38 #1 SMP Mon Oct 23 18:02:47 UTC 2023 x86_64 GNU/Linux</span><br><span class="line"> </span><br><span class="line"># ps看到，kata默认使用qemu起的虚拟机</span><br><span class="line">ps aux|grep kata</span><br><span class="line">root        5768  0.0  0.0 1857428 36320 pts/0   Sl+  17:17   0:00 ctr run --runtime io.containerd.kata.v2 --rm -t docker.io/library/busybox:latest test-kata sh</span><br><span class="line">root        5788  0.1  0.0 1421180 33536 ?       Sl   17:17   0:00 /opt/kata/bin/containerd-shim-kata-v2 -namespace default -address /run/containerd/containerd.sock -publish-binary /usr/local/bin/containerd -id test-kata</span><br><span class="line">root        5797  0.0  0.0   2612  1916 ?        S    17:17   0:00 /opt/kata/libexec/virtiofsd --syslog --cache=auto --shared-dir=/run/kata-containers/shared/sandboxes/test-kata/shared --fd=3 --thread-pool-size=1 --announce-submounts</span><br><span class="line">root        5798  1.2  0.2 2675292 194512 ?      Sl   17:17   0:00 /opt/kata/bin/qemu-system-x86_64 -name sandbox-test-kata -uuid c39b09f2-135a-49d7-b1ee-721239c9cd42 -machine q35,accel=kvm,nvdimm=on -cpu host,pmu=off -qmp unix:fd=3,server=on,wait=off -m 2048M,slots=10,maxmem=64555M -device pci-bridge,bus=pcie.0,id=pci-bridge-0,chassis_nr=1,shpc=off,addr=2,io-reserve=4k,mem-reserve=1m,pref64-reserve=1m -device virtio-serial-pci,disable-modern=false,id=serial0 -device virtconsole,chardev=charconsole0,id=console0 -chardev socket,id=charconsole0,path=/run/vc/vm/test-kata/console.sock,server=on,wait=off -device nvdimm,id=nv0,memdev=mem0,unarmed=on -object memory-backend-file,id=mem0,mem-path=/opt/kata/share/kata-containers/kata-ubuntu-latest.image,size=268435456,readonly=on -device virtio-scsi-pci,id=scsi0,disable-modern=false -object rng-random,id=rng0,filename=/dev/urandom -device virtio-rng-pci,rng=rng0 -device vhost-vsock-pci,disable-modern=false,vhostfd=4,id=vsock-3367298568,guest-cid=3367298568 -chardev socket,id=char-50717c87b57f1a65,path=/run/vc/vm/test-kata/vhost-fs.sock -device vhost-user-fs-pci,chardev=char-50717c87b57f1a65,tag=kataShared,queue-size=1024 -rtc base=utc,driftfix=slew,clock=host -global kvm-pit.lost_tick_policy=discard -vga none -no-user-config -nodefaults -nographic --no-reboot -object memory-backend-file,id=dimm1,size=2048M,mem-path=/dev/shm,share=on -numa node,memdev=dimm1 -kernel /opt/kata/share/kata-containers/vmlinux-6.1.38-114 -append tsc=reliable no_timer_check rcupdate.rcu_expedited=1 i8042.direct=1 i8042.dumbkbd=1 i8042.nopnp=1 i8042.noaux=1 noreplace-smp reboot=k cryptomgr.notests net.ifnames=0 pci=lastbus=0 root=/dev/pmem0p1 rootflags=dax,data=ordered,errors=remount-ro ro rootfstype=ext4 console=hvc0 console=hvc1 quiet systemd.show_status=false panic=1 nr_cpus=80 selinux=0 systemd.unit=kata-containers.target systemd.mask=systemd-networkd.service systemd.mask=systemd-networkd.socket scsi_mod.scan=none -pidfile /run/vc/vm/test-kata/pid -smp 1,cores=1,threads=1,sockets=80,maxcpus=80</span><br><span class="line">root        5800  0.0  0.0 2106012 5136 ?        Sl   17:17   0:00 /opt/kata/libexec/virtiofsd --syslog --cache=auto --shared-dir=/run/kata-containers/shared/sandboxes/test-kata/shared --fd=3 --thread-pool-size=1 --announce-submounts</span><br><span class="line">root        5857  0.0  0.0 229088  1044 pts/1    S+   17:18   0:00 grep --color=auto kata</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cloud-hypervisor</category>
      </categories>
      <tags>
        <tag>cloud-hypervisor</tag>
        <tag>kata</tag>
      </tags>
  </entry>
  <entry>
    <title>右值引用</title>
    <url>/2023/03/27/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<h3 id="什么是左值、右值"><a href="#什么是左值、右值" class="headerlink" title="什么是左值、右值"></a>什么是左值、右值</h3><p>首先不考虑引用以减少干扰，可以从2个角度判断：左值<strong>可以取地址、位于等号左边</strong>；而右值<strong>没法取地址，位于等号右边</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 5;</span><br></pre></td></tr></table></figure>
<ul>
<li>  a可以通过 &amp; 取地址，位于等号左边，所以a是左值。</li>
<li>  5位于等号右边，5没法通过 &amp; 取地址，所以5是个右值。<span id="more"></span></li>
</ul>
<p>再举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    A(int a = 0) &#123;</span><br><span class="line">        a_ = a;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    int a_;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">A a = A();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  同样的，a可以通过 &amp; 取地址，位于等号左边，所以a是左值。</li>
<li>  A()是个临时值，没法通过 &amp; 取地址，位于等号右边，所以A()是个右值。</li>
</ul>
<p>可见左右值的概念很清晰，有地址的变量就是左值，没有地址的字面值、临时值就是右值。</p>
<h3 id="什么是左值引用、右值引用"><a href="#什么是左值引用、右值引用" class="headerlink" title="什么是左值引用、右值引用"></a>什么是左值引用、右值引用</h3><p>引用本质是别名，可以通过引用修改变量的值，传参时传引用可以避免拷贝，其实现原理和指针类似。 个人认为，引用出现的本意是为了降低C语言指针的使用难度，但现在指针+左右值引用共同存在，反而大大增加了学习和理解成本。</p>
<h3 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h3><p>左值引用大家都很熟悉，<strong>能指向左值，不能指向右值的就是左值引用</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 5;</span><br><span class="line">int &amp;ref_a = a; // 左值引用指向左值，编译通过</span><br><span class="line">int &amp;ref_a = 5; // 左值引用指向了右值，会编译失败</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>引用是变量的别名，由于右值没有地址，没法被修改，所以左值引用无法指向右值。</strong></p>
<p>但是，const左值引用是可以指向右值的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const int &amp;ref_a = 5;  // 编译通过</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>const左值引用不会修改指向值，因此可以指向右值，这也是为什么要使用<code>const &amp;</code>作为函数参数的原因之一，如<code>std::vector</code>的<code>push_back</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void push_back (const value_type&amp; val);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果没有<code>const</code>，<code>vec.push_back(5)</code>这样的代码就无法编译通过了。</p>
<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>再看下右值引用，右值引用的标志是<code>&amp;&amp;</code>，顾名思义，右值引用专门为右值而生，<strong>可以指向右值，不能指向左值</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int &amp;&amp;ref_a_right = 5; // ok</span><br><span class="line"> </span><br><span class="line">int a = 5;</span><br><span class="line">int &amp;&amp;ref_a_left = a; // 编译不过，右值引用不可以指向左值</span><br><span class="line"> </span><br><span class="line">ref_a_right = 6; // 右值引用的用途：可以修改右值</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="对左右值引用本质的讨论"><a href="#对左右值引用本质的讨论" class="headerlink" title="对左右值引用本质的讨论"></a>对左右值引用本质的讨论</h3><p>下边的论述比较复杂，也是本文的核心，对理解这些概念非常重要。</p>
<h4 id="右值引用有办法指向左值吗？"><a href="#右值引用有办法指向左值吗？" class="headerlink" title="右值引用有办法指向左值吗？"></a>右值引用有办法指向左值吗？</h4><p>有办法，<code>std::move</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int a = 5; // a是个左值</span><br><span class="line">int &amp;ref_a_left = a; // 左值引用指向左值</span><br><span class="line">int &amp;&amp;ref_a_right = std::move(a); // 通过std::move将左值转化为右值，可以被右值引用指向</span><br><span class="line"> </span><br><span class="line">cout &lt;&lt; a; // 打印结果：5</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上边的代码里，看上去是左值a通过std::move移动到了右值ref_a_right中，那是不是a里边就没有值了？并不是，打印出a的值仍然是5。</p>
<p><code>std::move</code>是一个非常有迷惑性的函数，不理解左右值概念的人们往往以为它能把一个变量里的内容移动到另一个变量，<strong>但事实上std::move移动不了什么，唯一的功能是把左值强制转化为右值</strong>，让右值引用可以指向左值。其实现等同于一个类型转换：<code>static_cast&lt;T&amp;&amp;&gt;(lvalue)</code>。 所以，<strong>单纯的std::move(xxx)不会有性能提升</strong>，std::move的使用场景在第三章会讲。</p>
<p>同样的，右值引用能指向右值，本质上也是把右值提升为一个左值，并定义一个右值引用通过std::move指向该左值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int &amp;&amp;ref_a = 5;</span><br><span class="line">ref_a = 6; </span><br><span class="line"> </span><br><span class="line">等同于以下代码：</span><br><span class="line"> </span><br><span class="line">int temp = 5;</span><br><span class="line">int &amp;&amp;ref_a = std::move(temp);</span><br><span class="line">ref_a = 6;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="左值引用、右值引用本身是左值还是右值？"><a href="#左值引用、右值引用本身是左值还是右值？" class="headerlink" title="左值引用、右值引用本身是左值还是右值？"></a>左值引用、右值引用本身是左值还是右值？</h4><p><strong>被声明出来的左、右值引用都是左值</strong>。 因为被声明出的左右值引用是有地址的，也位于等号左边。仔细看下边代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 形参是个右值引用</span><br><span class="line">void change(int&amp;&amp; right_value) &#123;</span><br><span class="line">    right_value = 8;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main() &#123;</span><br><span class="line">    int a = 5; // a是个左值</span><br><span class="line">    int &amp;ref_a_left = a; // ref_a_left是个左值引用</span><br><span class="line">    int &amp;&amp;ref_a_right = std::move(a); // ref_a_right是个右值引用</span><br><span class="line"> </span><br><span class="line">    change(a); // 编译不过，a是左值，change参数要求右值</span><br><span class="line">    change(ref_a_left); // 编译不过，左值引用ref_a_left本身也是个左值</span><br><span class="line">    change(ref_a_right); // 编译不过，右值引用ref_a_right本身也是个左值</span><br><span class="line">     </span><br><span class="line">    change(std::move(a)); // 编译通过</span><br><span class="line">    change(std::move(ref_a_right)); // 编译通过</span><br><span class="line">    change(std::move(ref_a_left)); // 编译通过</span><br><span class="line"> </span><br><span class="line">    change(5); // 当然可以直接接右值，编译通过</span><br><span class="line">     </span><br><span class="line">    cout &lt;&lt; &amp;a &lt;&lt; &#x27; &#x27;;</span><br><span class="line">    cout &lt;&lt; &amp;ref_a_left &lt;&lt; &#x27; &#x27;;</span><br><span class="line">    cout &lt;&lt; &amp;ref_a_right;</span><br><span class="line">    // 打印这三个左值的地址，都是一样的</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>看完后你可能有个问题，std::move会返回一个右值引用<code>int &amp;&amp;</code>，它是左值还是右值呢？ 从表达式<code>int &amp;&amp;ref = std::move(a)</code>来看，右值引用<code>ref</code>指向的必须是右值，所以move返回的<code>int &amp;&amp;</code>是个右值。所以右值引用既可能是左值，又可能是右值吗？ 确实如此：<strong>右值引用既可以是左值也可以是右值，如果有名称则为左值，否则是右值</strong>。</p>
<p>或者说：<strong>作为函数返回值的 &amp;&amp; 是右值，直接声明出来的 &amp;&amp; 是左值</strong>。 这同样也符合第一章对左值，右值的判定方式：其实引用和普通变量是一样的，<code>int &amp;&amp;ref = std::move(a)</code>和 <code>int a = 5</code>没有什么区别，等号左边就是左值，右边就是右值。</p>
<p>最后，从上述分析中我们得到如下结论：</p>
<ol>
<li> <strong>从性能上讲，左右值引用没有区别，传参使用左右值引用都可以避免拷贝。</strong></li>
<li> <strong>右值引用可以直接指向右值，也可以通过std::move指向左值；而左值引用只能指向左值(const左值引用也能指向右值)。</strong></li>
<li> <strong>作为函数形参时，右值引用更灵活。虽然const左值引用也可以做到左右值都接受，但它无法修改，有一定局限性。</strong></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void f(const int&amp; n) &#123;</span><br><span class="line">    n += 1; // 编译失败，const左值引用不能修改指向变量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void f2(int &amp;&amp; n) &#123;</span><br><span class="line">    n += 1; // ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    f(5);</span><br><span class="line">    f2(5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="右值引用和std-move的应用场景"><a href="#右值引用和std-move的应用场景" class="headerlink" title="右值引用和std::move的应用场景"></a>右值引用和std::move的应用场景</h3><p>按上文分析，<code>std::move</code>只是类型转换工具，不会对性能有好处；右值引用在作为函数形参时更具灵活性，看上去还是挺鸡肋的。他们有什么实际应用场景吗？</p>
<h4 id="实现移动语义"><a href="#实现移动语义" class="headerlink" title="实现移动语义"></a>实现移动语义</h4><p>在实际场景中，右值引用和std::move被广泛用于在STL和自定义类中<strong>实现移动语义，避免拷贝，从而提升程序性能</strong>。 在没有右值引用之前，一个简单的数组类通常实现如下，有<code>构造函数</code>、<code>拷贝构造函数</code>、<code>赋值运算符重载</code>、<code>析构函数</code>等。深拷贝/浅拷贝在此不做讲解。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Array &#123;</span><br><span class="line">public:</span><br><span class="line">    Array(int size) : size_(size) &#123;</span><br><span class="line">        data = new int[size_];</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    // 深拷贝构造</span><br><span class="line">    Array(const Array&amp; temp_array) &#123;</span><br><span class="line">        size_ = temp_array.size_;</span><br><span class="line">        data_ = new int[size_];</span><br><span class="line">        for (int i = 0; i &lt; size_; i ++) &#123;</span><br><span class="line">            data_[i] = temp_array.data_[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    // 深拷贝赋值</span><br><span class="line">    Array&amp; operator=(const Array&amp; temp_array) &#123;</span><br><span class="line">        delete[] data_;</span><br><span class="line"> </span><br><span class="line">        size_ = temp_array.size_;</span><br><span class="line">        data_ = new int[size_];</span><br><span class="line">        for (int i = 0; i &lt; size_; i ++) &#123;</span><br><span class="line">            data_[i] = temp_array.data_[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~Array() &#123;</span><br><span class="line">        delete[] data_;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">public:</span><br><span class="line">    int *data_;</span><br><span class="line">    int size_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该类的拷贝构造函数、赋值运算符重载函数已经通过使用左值引用传参来避免一次多余拷贝了，但是内部实现要深拷贝，无法避免。 这时，有人提出一个想法：是不是可以提供一个<code>移动构造函数</code>，把被拷贝者的数据移动过来，被拷贝者后边就不要了，这样就可以避免深拷贝了，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Array &#123;</span><br><span class="line">public:</span><br><span class="line">    Array(int size) : size_(size) &#123;</span><br><span class="line">        data = new int[size_];</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    // 深拷贝构造</span><br><span class="line">    Array(const Array&amp; temp_array) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    // 深拷贝赋值</span><br><span class="line">    Array&amp; operator=(const Array&amp; temp_array) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 移动构造函数，可以浅拷贝</span><br><span class="line">    Array(const Array&amp; temp_array, bool move) &#123;</span><br><span class="line">        data_ = temp_array.data_;</span><br><span class="line">        size_ = temp_array.size_;</span><br><span class="line">        // 为防止temp_array析构时delete data，提前置空其data_      </span><br><span class="line">        temp_array.data_ = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    ~Array() &#123;</span><br><span class="line">        delete [] data_;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">public:</span><br><span class="line">    int *data_;</span><br><span class="line">    int size_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这么做有2个问题：</p>
<ul>
<li>  不优雅，表示移动语义还需要一个额外的参数(或者其他方式)。</li>
<li>  无法实现！<code>temp_array</code>是个const左值引用，无法被修改，所以<code>temp_array.data_ = nullptr;</code>这行会编译不过。当然函数参数可以改成非const：<code>Array(Array&amp; temp_array, bool move)&#123;...&#125;</code>，这样也有问题，由于左值引用不能接右值，<code>Array a = Array(Array(), true);</code>这种调用方式就没法用了。</li>
</ul>
<p>可以发现左值引用真是用的很不爽，<strong>右值引用的出现解决了这个问题</strong>，在STL的很多容器中，都实现了以<strong>右值引用为参数</strong>的<code>移动构造函数</code>和<code>移动赋值重载函数</code>，或者其他函数，最常见的如std::vector的<code>push_back</code>和<code>emplace_back</code>。参数为左值引用意味着拷贝，为右值引用意味着移动。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Array &#123;</span><br><span class="line">public:</span><br><span class="line">    ......</span><br><span class="line"> </span><br><span class="line">    // 优雅</span><br><span class="line">    Array(Array&amp;&amp; temp_array) &#123;</span><br><span class="line">        data_ = temp_array.data_;</span><br><span class="line">        size_ = temp_array.size_;</span><br><span class="line">        // 为防止temp_array析构时delete data，提前置空其data_      </span><br><span class="line">        temp_array.data_ = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">public:</span><br><span class="line">    int *data_;</span><br><span class="line">    int size_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如何使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 例1：Array用法</span><br><span class="line">int main()&#123;</span><br><span class="line">    Array a;</span><br><span class="line"> </span><br><span class="line">    // 做一些操作</span><br><span class="line">    .....</span><br><span class="line">     </span><br><span class="line">    // 左值a，用std::move转化为右值</span><br><span class="line">    Array b(std::move(a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="实例：vector-push-back使用std-move提高性能"><a href="#实例：vector-push-back使用std-move提高性能" class="headerlink" title="实例：vector::push_back使用std::move提高性能"></a>实例：vector::push_back使用std::move提高性能</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 例2：std::vector和std::string的实际例子</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::string str1 = &quot;aacasxs&quot;;</span><br><span class="line">    std::vector&lt;std::string&gt; vec;</span><br><span class="line">     </span><br><span class="line">    vec.push_back(str1); // 传统方法，copy</span><br><span class="line">    vec.push_back(std::move(str1)); // 调用移动语义的push_back方法，避免拷贝，str1会失去原有值，变成空字符串</span><br><span class="line">    vec.emplace_back(std::move(str1)); // emplace_back效果相同，str1会失去原有值</span><br><span class="line">    vec.emplace_back(&quot;axcsddcas&quot;); // 当然可以直接接右值</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// std::vector方法定义</span><br><span class="line">void push_back (const value_type&amp; val);</span><br><span class="line">void push_back (value_type&amp;&amp; val);</span><br><span class="line"> </span><br><span class="line">void emplace_back (Args&amp;&amp;... args);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在vector和string这个场景，加个<code>std::move</code>会调用到移动语义函数，避免了深拷贝。</p>
<p>除非设计不允许移动，STL类大都支持移动语义函数，即<code>可移动的</code>。 另外，编译器会<strong>默认</strong>在用户自定义的<code>class</code>和<code>struct</code>中生成移动语义函数，但前提是用户没有主动定义该类的<code>拷贝构造</code>等函数(具体规则自行百度哈)。 <strong>因此，可移动对象在&lt;需要拷贝且被拷贝者之后不再被需要&gt;的场景，建议使用</strong><code>std::move</code><strong>触发移动语义，提升性能。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">moveable_objecta = moveable_objectb; </span><br><span class="line">改为： </span><br><span class="line">moveable_objecta = std::move(moveable_objectb);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>还有些STL类是<code>move-only</code>的，比如<code>unique_ptr</code>，这种类只有移动构造函数，因此只能移动(转移内部对象所有权，或者叫浅拷贝)，不能拷贝(深拷贝):</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::unique_ptr&lt;A&gt; ptr_a = std::make_unique&lt;A&gt;();</span><br><span class="line"></span><br><span class="line">std::unique_ptr&lt;A&gt; ptr_b = std::move(ptr_a); // unique_ptr只有‘移动赋值重载函数‘，参数是&amp;&amp; ，只能接右值，因此必须用std::move转换类型</span><br><span class="line">std::unique_ptr&lt;A&gt; ptr_b = ptr_a; // 编译不通过</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>std::move本身只做类型转换，对性能无影响。</strong> <strong>我们可以在自己的类中实现移动语义，避免深拷贝，充分利用右值引用和std::move的语言特性。</strong></p>
<h3 id="完美转发-std-forward"><a href="#完美转发-std-forward" class="headerlink" title="完美转发 std::forward"></a>完美转发 std::forward</h3><p>和<code>std::move</code>一样，它的兄弟<code>std::forward</code>也充满了迷惑性，虽然名字含义是转发，但他并不会做转发，同样也是做类型转换.</p>
<p>与move相比，forward更强大，move只能转出来右值，forward都可以。</p>
<blockquote>
<p>std::forward<T>(u)有两个参数：T与 u。 a. 当T为左值引用类型时，u将被转换为T类型的左值； b. 否则u将被转换为T类型右值。  </T></p>
</blockquote>
<p>举个例子，有main，A，B三个函数，调用关系为：<code>main-&gt;A-&gt;B</code>，建议先看懂_2.3节对左右值引用本身是左值还是右值的讨论_再看这里：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void B(int&amp;&amp; ref_r) &#123;</span><br><span class="line">    ref_r = 1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// A、B的入参是右值引用</span><br><span class="line">// 有名字的右值引用是左值，因此ref_r是左值</span><br><span class="line">void A(int&amp;&amp; ref_r) &#123;</span><br><span class="line">    B(ref_r);  // 错误，B的入参是右值引用，需要接右值，ref_r是左值，编译失败</span><br><span class="line">     </span><br><span class="line">    B(std::move(ref_r)); // ok，std::move把左值转为右值，编译通过</span><br><span class="line">    B(std::forward&lt;int&gt;(ref_r));  // ok，std::forward的T是int类型，属于条件b，因此会把ref_r转为右值</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main() &#123;</span><br><span class="line">    int a = 5;</span><br><span class="line">    A(std::move(a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>例2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void change2(int&amp;&amp; ref_r) &#123;</span><br><span class="line">    ref_r = 1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void change3(int&amp; ref_l) &#123;</span><br><span class="line">    ref_l = 1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// change的入参是右值引用</span><br><span class="line">// 有名字的右值引用是 左值，因此ref_r是左值</span><br><span class="line">void change(int&amp;&amp; ref_r) &#123;</span><br><span class="line">    change2(ref_r);  // 错误，change2的入参是右值引用，需要接右值，ref_r是左值，编译失败</span><br><span class="line">     </span><br><span class="line">    change2(std::move(ref_r)); // ok，std::move把左值转为右值，编译通过</span><br><span class="line">    change2(std::forward&lt;int &amp;&amp;&gt;(ref_r));  // ok，std::forward的T是右值引用类型(int &amp;&amp;)，符合条件b，因此u(ref_r)会被转换为右值，编译通过</span><br><span class="line">     </span><br><span class="line">    change3(ref_r); // ok，change3的入参是左值引用，需要接左值，ref_r是左值，编译通过</span><br><span class="line">    change3(std::forward&lt;int &amp;&gt;(ref_r)); // ok，std::forward的T是左值引用类型(int &amp;)，符合条件a，因此u(ref_r)会被转换为左值，编译通过</span><br><span class="line">    // 可见，forward可以把值转换为左值或者右值</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main() &#123;</span><br><span class="line">    int a = 5;</span><br><span class="line">    change(std::move(a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上边的示例在日常编程中基本不会用到，<code>std::forward</code>最主要运于模版编程的参数转发中，想深入了解需要学习<code>万能引用(T &amp;&amp;)</code>和<code>引用折叠(eg:&amp; &amp;&amp; → ?)</code>等知识，本文就不详细介绍这些了。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>libvirt with dpdk-vdpa</title>
    <url>/2023/03/14/libvirt-with-dpdk-vdpa/</url>
    <content><![CDATA[<h2 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">OS                               : CentOS Linux release 8.4.2105</span><br><span class="line">Kernel                           : 4.18.0-305.30.1.el8.x86_64</span><br><span class="line">qemu                             : 6.2.0</span><br><span class="line">dpdk                             : 22.11.1 </span><br><span class="line">libvirt                          : 8.0.0</span><br><span class="line">设备类型                         :  net</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="dpdk-vdpa启动"><a href="#dpdk-vdpa启动" class="headerlink" title="dpdk-vdpa启动"></a>dpdk-vdpa启动</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./dpdk-vdpa -c 0x2 -n 4 --socket-mem 1024,1024 \</span><br><span class="line">            -a 0000:cc:00.1,vdpa=1  -a 0000:cc:00.2,vdpa=1  \</span><br><span class="line">                -- --iface /tmp/vdpa-socket</span><br></pre></td></tr></table></figure>

<h2 id="libvirt-xml配置"><a href="#libvirt-xml配置" class="headerlink" title="libvirt xml配置"></a>libvirt xml配置</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">domain</span> <span class="attr">type</span>=<span class="string">&quot;kvm&quot;</span> <span class="attr">xmlns:qemu</span>=<span class="string">&#x27;http://libvirt.org/schemas/domain/qemu/1.0&#x27;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>vm0<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">uuid</span>&gt;</span>d37f5411-b296-11ed-8e6c-0c48c6c879e4<span class="tag">&lt;/<span class="name">uuid</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">memory</span> <span class="attr">unit</span>=<span class="string">&quot;KiB&quot;</span>&gt;</span>2097152<span class="tag">&lt;/<span class="name">memory</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">memoryBacking</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">hugepages</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">page</span> <span class="attr">size</span>=<span class="string">&quot;2&quot;</span> <span class="attr">unit</span>=<span class="string">&quot;M&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">hugepages</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">nosharepages</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">locked</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">source</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">access</span> <span class="attr">mode</span>=<span class="string">&quot;shared&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">discard</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">memoryBacking</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">vcpu</span> <span class="attr">placement</span>=<span class="string">&quot;static&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">vcpu</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">os</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">type</span> <span class="attr">arch</span>=<span class="string">&quot;x86_64&quot;</span> <span class="attr">machine</span>=<span class="string">&quot;pc-i440fx-2.1&quot;</span>&gt;</span>hvm<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">os</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">cpu</span> <span class="attr">mode</span>=<span class="string">&#x27;custom&#x27;</span> <span class="attr">match</span>=<span class="string">&#x27;exact&#x27;</span> <span class="attr">check</span>=<span class="string">&#x27;full&#x27;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">model</span> <span class="attr">fallback</span>=<span class="string">&#x27;forbid&#x27;</span>&gt;</span>kvm64<span class="tag">&lt;/<span class="name">model</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">feature</span> <span class="attr">policy</span>=<span class="string">&#x27;require&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;x2apic&#x27;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">feature</span> <span class="attr">policy</span>=<span class="string">&#x27;require&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;hypervisor&#x27;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">cpu</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">features</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">acpi</span>&gt;</span><span class="tag">&lt;/<span class="name">acpi</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">features</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">clock</span> <span class="attr">offset</span>=<span class="string">&quot;utc&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">clock</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">on_poweroff</span>&gt;</span>destroy<span class="tag">&lt;/<span class="name">on_poweroff</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">on_reboot</span>&gt;</span>restart<span class="tag">&lt;/<span class="name">on_reboot</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">on_crash</span>&gt;</span>destroy<span class="tag">&lt;/<span class="name">on_crash</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">devices</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">emulator</span>&gt;</span>/root/pc-bios/qemu-system-x86_64<span class="tag">&lt;/<span class="name">emulator</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">disk</span> <span class="attr">device</span>=<span class="string">&quot;disk&quot;</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">target</span> <span class="attr">bus</span>=<span class="string">&quot;ide&quot;</span> <span class="attr">dev</span>=<span class="string">&quot;hda&quot;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">source</span> <span class="attr">file</span>=<span class="string">&quot;/mnt/store/vm0-centos8.4-8g-ext4-host-dmar.img&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">disk</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">interface</span> <span class="attr">type</span>=<span class="string">&#x27;vhostuser&#x27;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">mac</span> <span class="attr">address</span>=<span class="string">&#x27;00:aa:bb:cc:dd:ee&#x27;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">source</span> <span class="attr">type</span>=<span class="string">&#x27;unix&#x27;</span> <span class="attr">path</span>=<span class="string">&#x27;/tmp/vdpa-socket0&#x27;</span> <span class="attr">mode</span>=<span class="string">&#x27;client&#x27;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">model</span> <span class="attr">type</span>=<span class="string">&#x27;virtio&#x27;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">driver</span> <span class="attr">queues</span>=<span class="string">&#x27;4&#x27;</span> <span class="attr">rx_queue_size</span>=<span class="string">&#x27;512&#x27;</span> <span class="attr">tx_queue_size</span>=<span class="string">&#x27;512&#x27;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">serial</span> <span class="attr">type</span>=<span class="string">&quot;tcp&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">source</span> <span class="attr">mode</span>=<span class="string">&quot;bind&quot;</span> <span class="attr">host</span>=<span class="string">&quot;127.0.0.1&quot;</span> <span class="attr">service</span>=<span class="string">&quot;4321&quot;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">protocol</span> <span class="attr">type</span>=<span class="string">&quot;telnet&quot;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">target</span> <span class="attr">port</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">serial</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">graphics</span> <span class="attr">type</span>=<span class="string">&#x27;vnc&#x27;</span> <span class="attr">port</span>=<span class="string">&#x27;5901&#x27;</span> <span class="attr">listen</span>=<span class="string">&#x27;0.0.0.0&#x27;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">listen</span> <span class="attr">type</span>=<span class="string">&#x27;address&#x27;</span> <span class="attr">address</span>=<span class="string">&#x27;0.0.0.0&#x27;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">graphics</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;/<span class="name">devices</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">qemu:commandline</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">qemu:arg</span> <span class="attr">value</span>=<span class="string">&#x27;-L&#x27;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">qemu:arg</span> <span class="attr">value</span>=<span class="string">&#x27;/root/pc-bios&#x27;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">qemu:commandline</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="验证结果"><a href="#验证结果" class="headerlink" title="验证结果"></a>验证结果</h2><p>1、查看libvirt是否正常拉起vm</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># virsh -c qemu+tcp:///system create vm.xml</span></span><br><span class="line">Domain <span class="string">&#x27;vm0&#x27;</span> created from vm.xml</span><br><span class="line"></span><br><span class="line"><span class="comment"># virsh list</span></span><br><span class="line"> Id   Name   State</span><br><span class="line">----------------------</span><br><span class="line"> 29   vm0    running</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、ping测试<br><img src="03e2f3d08b21dc6b24565608fdd47abc9cbe6acb6bd8286f651bb44728647ad3.png" alt="图 2">  </p>
<h2 id="调试问题"><a href="#调试问题" class="headerlink" title="调试问题"></a>调试问题</h2><p>使用libvirt拉起vm时，ping failed<br><img src="3d9fe6c5801dcd971f82c9826d8fd9e596c0c1edd45cd42b49d299b31abe463e.png" alt="图 1">  </p>
<h3 id="定位过程"><a href="#定位过程" class="headerlink" title="定位过程"></a>定位过程</h3><p>1、查看/var/log/libvirt/qemu/vm0.log日志，发现存在错误日志打印，可以看到qemu启动参数需要指定<code>memory-backend-file</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2023-06-14T01:53:51.897860Z qemu-system-x86_64: Failed initializing vhost-user memory map, consider using -object memory-backend-file share=on</span><br><span class="line">2023-06-14T01:53:51.897958Z qemu-system-x86_64: vhost_set_mem_table failed: Input/output error (5)</span><br><span class="line">2023-06-14T01:53:51.912732Z qemu-system-x86_64: unable to start vhost net: 5: falling back on userspace virtio</span><br><span class="line">2023-06-14T01:53:51.949246Z qemu-system-x86_64: Failed initializing vhost-user memory map, consider using -object memory-backend-file share=on</span><br><span class="line">2023-06-14T01:53:51.949266Z qemu-system-x86_64: vhost_set_mem_table failed: Resource temporarily unavailable (11)</span><br><span class="line">2023-06-14T01:53:51.963736Z qemu-system-x86_64: unable to start vhost net: 11: falling back on userspace virtio</span><br></pre></td></tr></table></figure>

<p>2、查看qemu启动进程参数，发现qemu参数指定的是<code>memory-backend-ram</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root        6394       1 50 08:23 ?        00:00:47 /root/pc-bios/qemu-system-x86_64 -name guest=vm0,debug-threads=on -S -object &#123;<span class="string">&quot;qom-type&quot;</span>:<span class="string">&quot;secret&quot;</span>,<span class="string">&quot;id&quot;</span>:<span class="string">&quot;masterKey0&quot;</span>,<span class="string">&quot;format&quot;</span>:<span class="string">&quot;raw&quot;</span>,<span class="string">&quot;file&quot;</span>:<span class="string">&quot;/var/lib/libvirt/qemu/domain-10-vm0/master-key.aes&quot;</span>&#125; -machine pc-i440fx-2.1,usb=off,dump-guest-core=off,memory-backend=pc.ram -accel kvm -cpu kvm64,x2apic=on,hypervisor=on -m 2048 -object &#123;<span class="string">&quot;qom-type&quot;</span>:<span class="string">&quot;memory-backend-ram&quot;</span>,<span class="string">&quot;id&quot;</span>:<span class="string">&quot;pc.ram&quot;</span>,<span class="string">&quot;size&quot;</span>:2147483648&#125; -overcommit mem-lock=off -smp 2,sockets=2,cores=1,threads=1 -uuid d37f5411-b296-11ed-8e6c-0c48c6c879e4 -no-user-config -nodefaults -chardev socket,<span class="built_in">id</span>=charmonitor,fd=38,server=on,<span class="built_in">wait</span>=off -mon chardev=charmonitor,<span class="built_in">id</span>=monitor,mode=control -rtc base=utc -no-shutdown -boot strict=on -device piix3-usb-uhci,<span class="built_in">id</span>=usb,bus=pci.0,addr=0x1.0x2 -blockdev &#123;<span class="string">&quot;driver&quot;</span>:<span class="string">&quot;file&quot;</span>,<span class="string">&quot;filename&quot;</span>:<span class="string">&quot;/mnt/store/vm0-centos8.4-8g-ext4-host-dmar.img&quot;</span>,<span class="string">&quot;node-name&quot;</span>:<span class="string">&quot;libvirt-1-storage&quot;</span>,<span class="string">&quot;auto-read-only&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;discard&quot;</span>:<span class="string">&quot;unmap&quot;</span>&#125; -blockdev &#123;<span class="string">&quot;node-name&quot;</span>:<span class="string">&quot;libvirt-1-format&quot;</span>,<span class="string">&quot;read-only&quot;</span>:<span class="literal">false</span>,<span class="string">&quot;driver&quot;</span>:<span class="string">&quot;raw&quot;</span>,<span class="string">&quot;file&quot;</span>:<span class="string">&quot;libvirt-1-storage&quot;</span>&#125; -device ide-hd,bus=ide.0,unit=0,drive=libvirt-1-format,<span class="built_in">id</span>=ide0-0-0,bootindex=1 -chardev socket,<span class="built_in">id</span>=charnet0,path=/tmp/vdpa-socket0 -netdev vhost-user,chardev=charnet0,queues=4,<span class="built_in">id</span>=hostnet0 -device virtio-net-pci,mq=on,vectors=10,rx_queue_size=512,tx_queue_size=512,netdev=hostnet0,<span class="built_in">id</span>=net0,mac=00:aa:bb:cc:<span class="built_in">dd</span>:ee,bus=pci.0,addr=0x3 -chardev socket,<span class="built_in">id</span>=charserial0,host=127.0.0.1,port=4321,telnet=on,server=on,<span class="built_in">wait</span>=off -device isa-serial,chardev=charserial0,<span class="built_in">id</span>=serial0 -audiodev &#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;audio1&quot;</span>,<span class="string">&quot;driver&quot;</span>:<span class="string">&quot;none&quot;</span>&#125; -vnc 0.0.0.0:0,audiodev=audio1 -device cirrus-vga,<span class="built_in">id</span>=video0,bus=pci.0,addr=0x2 -device virtio-balloon-pci,<span class="built_in">id</span>=balloon0,bus=pci.0,addr=0x4 -L /root/pc-bios -msg timestamp=on</span><br></pre></td></tr></table></figure>

<h3 id="根因分析"><a href="#根因分析" class="headerlink" title="根因分析"></a>根因分析</h3><p>qemu进程在ram_block初始化的时候根据memory-backend-xxx，其中xxx可以指定file、memfd、ram，<br>从而指定不同的内存申请方式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">host_memory_backend_memory_complete(UserCreatable *uc, Error **errp)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (bc-&gt;alloc) &#123;</span><br><span class="line">        bc-&gt;alloc(backend, &amp;local_err);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当指定memory-backend-file<br>则bc-&gt;alloc = file_backend_memory_alloc</p>
<p>当指定memory-backend-ram<br>则bc-&gt;alloc = ram_backend_memory_alloc;</p>
<p>这两个主要的区别在于申请ram_block时，file_backend_memory_alloc会额外申请一个fd，用于前后端进程共享内存</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">RAMBlock *<span class="title function_">qemu_ram_alloc_from_file</span><span class="params">(<span class="type">ram_addr_t</span> size, MemoryRegion *mr,</span></span><br><span class="line"><span class="params">                                   <span class="type">uint32_t</span> ram_flags, <span class="type">const</span> <span class="type">char</span> *mem_path,</span></span><br><span class="line"><span class="params">                                   <span class="type">bool</span> readonly, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    fd = file_ram_open(mem_path, memory_region_name(mr), readonly, &amp;created,</span><br><span class="line">                       errp);</span><br><span class="line">...</span><br><span class="line">    block = qemu_ram_alloc_from_fd(size, mr, ram_flags, fd, <span class="number">0</span>, readonly, errp);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MemoryRegion通过vhost-user VHOST_USER_SET_MEM_TABLE消息传递到dpdk-vdpa进程<br>如果不指定memory-backend-file，VHOST_USER_SET_MEM_TABLE消息失败，在vhost_dev_start中返回失败，不会走后续设备启动流程</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vhost_dev_start</span><span class="params">(<span class="keyword">struct</span> vhost_dev *hdev, VirtIODevice *vdev)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    r = hdev-&gt;vhost_ops-&gt;vhost_set_mem_table(hdev, hdev-&gt;mem);</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        VHOST_OPS_DEBUG(<span class="string">&quot;vhost_set_mem_table failed&quot;</span>);</span><br><span class="line">        r = -errno;</span><br><span class="line">        <span class="keyword">goto</span> fail_mem;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">     r = hdev-&gt;vhost_ops-&gt;vhost_dev_start(hdev, <span class="literal">true</span>);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="问题修复"><a href="#问题修复" class="headerlink" title="问题修复"></a>问题修复</h3><p>libvirt xml指定memoryBacking类型为file</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">domain</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">	<span class="tag">&lt;<span class="name">memoryBacking</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">hugepages</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">page</span> <span class="attr">size</span>=<span class="string">&quot;2&quot;</span> <span class="attr">unit</span>=<span class="string">&quot;M&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">hugepages</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">nosharepages</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">locked</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">source</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">access</span> <span class="attr">mode</span>=<span class="string">&quot;shared&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">discard</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">memoryBacking</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此时再次启动vm，可以发现此时qemu进程启动参数为<code>memory-backend-file</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root       17715       1 75 23:02 ?        00:00:47 /root/pc-bios/qemu-system-x86_64 -name guest=vm0,debug-threads=on -S -object &#123;<span class="string">&quot;qom-type&quot;</span>:<span class="string">&quot;secret&quot;</span>,<span class="string">&quot;id&quot;</span>:<span class="string">&quot;masterKey0&quot;</span>,<span class="string">&quot;format&quot;</span>:<span class="string">&quot;raw&quot;</span>,<span class="string">&quot;file&quot;</span>:<span class="string">&quot;/var/lib/libvirt/qemu/domain-3-vm0/master-key.aes&quot;</span>&#125; -machine pc-i440fx-2.1,usb=off,dump-guest-core=off,mem-merge=off,memory-backend=pc.ram -accel kvm -cpu kvm64,x2apic=on,hypervisor=on -m 2048 -object &#123;<span class="string">&quot;qom-type&quot;</span>:<span class="string">&quot;memory-backend-file&quot;</span>,<span class="string">&quot;id&quot;</span>:<span class="string">&quot;pc.ram&quot;</span>,<span class="string">&quot;mem-path&quot;</span>:<span class="string">&quot;/dev/hugepages/libvirt/qemu/3-vm0&quot;</span>,<span class="string">&quot;discard-data&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;share&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;x-use-canonical-path-for-ramblock-id&quot;</span>:<span class="literal">false</span>,<span class="string">&quot;prealloc&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;size&quot;</span>:2147483648&#125; -overcommit mem-lock=on -smp 2,sockets=2,cores=1,threads=1 -uuid d37f5411-b296-11ed-8e6c-0c48c6c879e4 -no-user-config -nodefaults -chardev socket,<span class="built_in">id</span>=charmonitor,fd=39,server=on,<span class="built_in">wait</span>=off -mon chardev=charmonitor,<span class="built_in">id</span>=monitor,mode=control -rtc base=utc -no-shutdown -boot strict=on -device piix3-usb-uhci,<span class="built_in">id</span>=usb,bus=pci.0,addr=0x1.0x2 -blockdev &#123;<span class="string">&quot;driver&quot;</span>:<span class="string">&quot;file&quot;</span>,<span class="string">&quot;filename&quot;</span>:<span class="string">&quot;/mnt/store/vm0-centos8.4-8g-ext4-host-dmar.img&quot;</span>,<span class="string">&quot;node-name&quot;</span>:<span class="string">&quot;libvirt-1-storage&quot;</span>,<span class="string">&quot;auto-read-only&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;discard&quot;</span>:<span class="string">&quot;unmap&quot;</span>&#125; -blockdev &#123;<span class="string">&quot;node-name&quot;</span>:<span class="string">&quot;libvirt-1-format&quot;</span>,<span class="string">&quot;read-only&quot;</span>:<span class="literal">false</span>,<span class="string">&quot;driver&quot;</span>:<span class="string">&quot;raw&quot;</span>,<span class="string">&quot;file&quot;</span>:<span class="string">&quot;libvirt-1-storage&quot;</span>&#125; -device ide-hd,bus=ide.0,unit=0,drive=libvirt-1-format,<span class="built_in">id</span>=ide0-0-0,bootindex=1 -chardev socket,<span class="built_in">id</span>=charnet0,path=/tmp/vdpa-socket0 -netdev vhost-user,chardev=charnet0,queues=4,<span class="built_in">id</span>=hostnet0 -device virtio-net-pci,mq=on,vectors=10,rx_queue_size=512,tx_queue_size=512,netdev=hostnet0,<span class="built_in">id</span>=net0,mac=00:aa:bb:cc:<span class="built_in">dd</span>:ee,bus=pci.0,addr=0x3 -chardev socket,<span class="built_in">id</span>=charserial0,host=127.0.0.1,port=4321,telnet=on,server=on,<span class="built_in">wait</span>=off -device isa-serial,chardev=charserial0,<span class="built_in">id</span>=serial0 -audiodev &#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;audio1&quot;</span>,<span class="string">&quot;driver&quot;</span>:<span class="string">&quot;none&quot;</span>&#125; -vnc 0.0.0.0:0,audiodev=audio1 -device cirrus-vga,<span class="built_in">id</span>=video0,bus=pci.0,addr=0x2 -device virtio-balloon-pci,<span class="built_in">id</span>=balloon0,bus=pci.0,addr=0x4 -L /root/pc-bios -msg timestamp=on</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>Libvirt</tag>
      </tags>
  </entry>
  <entry>
    <title>protobuf使用</title>
    <url>/2023/03/08/protobuf%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Protobuf安装"><a href="#Protobuf安装" class="headerlink" title="Protobuf安装"></a>Protobuf安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install protobuf-compiler protobuf-c-compiler libprotobuf-dev libprotobuf-c-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># check</span></span><br><span class="line">protoc --version</span><br><span class="line"><span class="built_in">which</span> protoc-c</span><br><span class="line">find / -name <span class="string">&quot;libprotobuf-c.so&quot;</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="Protobuf使用说明"><a href="#Protobuf使用说明" class="headerlink" title="Protobuf使用说明"></a>Protobuf使用说明</h2><h3 id="proto定义"><a href="#proto定义" class="headerlink" title="proto定义"></a>proto定义</h3><p>一个简单的amessage.proto文件如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">syntax = &quot;proto2&quot;;</span><br><span class="line"></span><br><span class="line">message  AMessage</span><br><span class="line">&#123;</span><br><span class="line">    required int32 a=1; </span><br><span class="line">    optional int32 b=2; </span><br><span class="line">    </span><br><span class="line">     oneof test_oneof &#123;    </span><br><span class="line">         string c=3;    </span><br><span class="line">         int32  d=4;    </span><br><span class="line">     &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>使用如下命令在当前目录下生成protobuf的.c文件和.h文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protoc-c --c_out=. amessage.proto</span><br></pre></td></tr></table></figure>

<h3 id="序列化代码"><a href="#序列化代码" class="headerlink" title="序列化代码"></a>序列化代码</h3><p>序列化AMessage的代码amessage_serialize.c如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &quot;amessage.pb-c.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	AMessage msg = AMESSAGE__INIT; // AMessage</span><br><span class="line">	void *buf; // Buffer to store serialized data</span><br><span class="line">	unsigned len; // Length of serialized data</span><br><span class="line">	char *word = &quot;hello world!&quot;;</span><br><span class="line"></span><br><span class="line">	if (argc != 2 &amp;&amp; argc != 3 &amp;&amp; argc != 4) &#123; // Allow one or two integers</span><br><span class="line">		fprintf(stderr, &quot;usage: amessage a [b] [c]\n&quot;);</span><br><span class="line">		return 1;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	msg.a = atoi(argv[1]);</span><br><span class="line">	if (argc &gt;= 3) &#123;</span><br><span class="line">		msg.has_b = 1;</span><br><span class="line">		msg.b = atoi(argv[2]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if (argc &gt;= 4) &#123;</span><br><span class="line">		msg.d = atoi(argv[3]);</span><br><span class="line">		msg.test_oneof_case = AMESSAGE__TEST_ONEOF_D;</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		msg.c = word;</span><br><span class="line">		msg.test_oneof_case = AMESSAGE__TEST_ONEOF_C;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	len = amessage__get_packed_size(&amp;msg);</span><br><span class="line"></span><br><span class="line">	buf = malloc(len);</span><br><span class="line">	amessage__pack(&amp;msg, buf);</span><br><span class="line"></span><br><span class="line">	fprintf(stderr, &quot;Writing %d serialized bytes\n&quot;,</span><br><span class="line">		len); // See the length of message</span><br><span class="line">	fwrite(buf, len, 1,</span><br><span class="line">	       stdout); // Write to stdout to allow direct command line piping</span><br><span class="line"></span><br><span class="line">	free(buf); // Free the allocated serialized buffer</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意事项：</p>
<blockquote>
<p>使用A_MESSAGE__INIT宏来初始化消息结构体</p>
</blockquote>
<blockquote>
<p>成员has_b表示可选成员b是否存在</p>
</blockquote>
<blockquote>
<p>成员test_oneof_case指示oneof使用的成员是哪一个</p>
</blockquote>
<blockquote>
<p>AMESSAGE__TEST_ONEOF_C宏表示oneof使用的成员是c</p>
</blockquote>
<blockquote>
<p>amessage__get_packed_size函数返回序列化后消息的长度</p>
</blockquote>
<blockquote>
<p>amessage__pack函数序列化消息</p>
</blockquote>
<h3 id="反序列化代码"><a href="#反序列化代码" class="headerlink" title="反序列化代码"></a>反序列化代码</h3><p>反序列化消息的代码amessage_deserialize.c如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &quot;amessage.pb-c.h&quot;</span><br><span class="line">#define MAX_MSG_SIZE 1024</span><br><span class="line"></span><br><span class="line">static size_t read_buffer(unsigned max_length, uint8_t *out)</span><br><span class="line">&#123;</span><br><span class="line">	size_t cur_len = 0;</span><br><span class="line">	size_t nread;</span><br><span class="line">	while ((nread = fread(out + cur_len, 1, max_length - cur_len, stdin)) !=</span><br><span class="line">	       0) &#123;</span><br><span class="line">		cur_len += nread;</span><br><span class="line">		if (cur_len == max_length) &#123;</span><br><span class="line">			fprintf(stderr, &quot;max message length exceeded\n&quot;);</span><br><span class="line">			exit(1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return cur_len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	AMessage *msg;</span><br><span class="line"></span><br><span class="line">	// Read packed message from standard-input.</span><br><span class="line">	uint8_t buf[MAX_MSG_SIZE];</span><br><span class="line">	size_t msg_len = read_buffer(MAX_MSG_SIZE, buf);</span><br><span class="line"></span><br><span class="line">	// Unpack the message using protobuf-c.</span><br><span class="line">	msg = amessage__unpack(NULL, msg_len, buf);</span><br><span class="line">	if (msg == NULL) &#123;</span><br><span class="line">		fprintf(stderr, &quot;error unpacking incoming message\n&quot;);</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// display the message&#x27;s fields.</span><br><span class="line">	printf(&quot;Received: a=%d&quot;, msg-&gt;a); // required field</span><br><span class="line">	if (msg-&gt;has_b) // handle optional field</span><br><span class="line">		printf(&quot;  b=%d&quot;, msg-&gt;b);</span><br><span class="line">	if (msg-&gt;test_oneof_case == AMESSAGE__TEST_ONEOF_C)</span><br><span class="line">		printf(&quot;  c=%s&quot;, msg-&gt;c);</span><br><span class="line">	else if (msg-&gt;test_oneof_case == AMESSAGE__TEST_ONEOF_D)</span><br><span class="line">		printf(&quot;  d=%d&quot;, msg-&gt;d);</span><br><span class="line"></span><br><span class="line">	printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">	// Free the unpacked message</span><br><span class="line">	amessage__free_unpacked(msg, NULL);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Makefile文件"><a href="#Makefile文件" class="headerlink" title="Makefile文件"></a>Makefile文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">all:</span><br><span class="line">	protoc-c --c_out=. amessage.proto</span><br><span class="line">	gcc amessage_serialize.c amessage.pb-c.c -o amessage_serialize -lprotobuf-c</span><br><span class="line">	gcc amessage_deserialize.c amessage.pb-c.c -o amessage_deserialize -lprotobuf-c</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">	rm -f *.pb-c.c *.pb-c.h amessage_serialize amessage_deserialize</span><br></pre></td></tr></table></figure>


<h3 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./amessage_serialize 10 2 | ./amessage_deserialize</span><br><span class="line"></span><br><span class="line">Writing 18 serialized bytes</span><br><span class="line">Received: a=10  b=2  c=hello world!</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>GRPC</category>
      </categories>
      <tags>
        <tag>protobuf</tag>
      </tags>
  </entry>
  <entry>
    <title>proto2语法指引</title>
    <url>/2023/03/07/proto2%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<blockquote>
<p>本指南介绍如何使用 protocol buffer 语言来构造 protocol buffer 数据，包括 <code>.proto</code> 文件语法以及如何从 <code>.proto</code> 文件生成数据访问类。它涵盖了 protocol buffer 语言的 <strong>proto2</strong> 版本。</p>
</blockquote>
<span id="more"></span>

<h2 id="定义一个-Message-类型"><a href="#定义一个-Message-类型" class="headerlink" title="定义一个 Message 类型"></a>定义一个 Message 类型</h2><p>首先让我们看一个非常简单的例子。假设你要定义一个搜索请求的 message 格式，其中每个搜索请求都有一个查询字符串，你感兴趣的特定结果页数（第几页）以及每页的结果数。下面就是定义这个请求的 .proto 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">message SearchRequest &#123;</span><br><span class="line">  required string query = 1;  // 查询字符串</span><br><span class="line">  optional int32 page_number = 2;  // 第几页</span><br><span class="line">  optional int32 result_per_page = 3;  // 每页的结果数</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>SearchRequest message 定义指定了三个字段（名称/值对），每个字段对应着要包含在 message 中的数据，每个字段都有一个名称和类型。</p>
<h3 id="指定字段类型"><a href="#指定字段类型" class="headerlink" title="指定字段类型"></a>指定字段类型</h3><p>在上面的示例中，所有字段都是 <a href="https://developers.google.com/protocol-buffers/docs/proto#scalar">标量类型</a>：两个整数（<code>page_number</code> 和 <code>result_per_page</code>）和一个字符串（<code>query</code>）。但是，你还可以为字段指定复合类型，包括 <a href="https://developers.google.com/protocol-buffers/docs/proto#enum">枚举</a> 和其它的 message 类型。</p>
<h3 id="分配字段编号"><a href="#分配字段编号" class="headerlink" title="分配字段编号"></a>分配字段编号</h3><p>如你所见，message 定义中的每个字段都有<strong>唯一编号</strong>。这些数字以 <a href="https://www.jianshu.com/p/82ff31c6adc6">message 二进制格式</a> 标识你的字段，并且一旦你的 message 被使用，这些编号就无法再更改。请注意，1 到 15 范围内的字段编号需要一个字节进行编码，编码结果将同时包含编号和类型（你可以在 <a href="https://www.jianshu.com/p/82ff31c6adc6">Protocol Buffer 编码</a> 中找到更多相关信息）。16 到 2047 范围内的字段编号占用两个字节。因此，你应该为非常频繁出现的 message 元素保留字段编号 1 到 15。请记住为将来可能添加的常用元素预留出一些空间。</p>
<p>你可以指定的最小字段数为 1，最大字段数为 229 - 1 或 536,870,911。你也不能使用 19000 到 19999 范围内的数字（<code>FieldDescriptor::kFirstReservedNumber</code> 到 <code>FieldDescriptor::kLastReservedNumber</code>），因为它们是为 Protocol Buffers 的实现保留的 - 如果你使用这些保留数字之一，protocol buffer 编译器会抱怨你的 <code>.proto</code>。同样，你也不能使用任何以前定义的 <a href="https://developers.google.com/protocol-buffers/docs/proto#reserved">保留</a> 字段编号。</p>
<blockquote>
<p>译者注：<br>“不能使用任何以前定义的保留字段编号” 指的是使用 reserved 关键字声明的保留字段。</p>
</blockquote>
<h3 id="指定字段规则"><a href="#指定字段规则" class="headerlink" title="指定字段规则"></a>指定字段规则</h3><p>你指定的 message 字段可以是下面几种情况之一：</p>
<ul>
<li>  <strong>required</strong>: 格式良好的 message 必须包含该字段一次。</li>
<li>  <strong>optional</strong>: 格式良好的 message 可以包含该字段零次或一次（不超过一次）。</li>
<li>  <strong>repeated</strong>: 该字段可以在格式良好的消息中重复任意多次（包括零）。其中重复值的顺序会被保留。</li>
</ul>
<p>由于一些历史原因，标量数字类型的 repeated 字段不能尽可能高效地编码。新代码应使用特殊选项 [packed = true] 来获得更高效的编码。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">repeated int32 samples = 4 [packed=true];</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<blockquote>
<p>对 required 的使用永远都应该非常小心。如果你希望在某个时刻停止写入或发送 required 字段，则将字段更改为可选字段将会有问题 - 旧读者会认为没有此字段的邮件不完整，可能会无意中拒绝或删除它们。你应该考虑为 buffers 编写特定于应用程序的自定义验证的例程。谷歌的一些工程师得出的结论是，使用 required 弊大于利；他们更喜欢只使用 optional 和 repeated。但是，这种观点并未普及。</p>
</blockquote>
<blockquote>
<p>译者注：在 proto3 中已经为兼容性彻底抛弃 required。</p>
</blockquote>
<h3 id="添加更多-message-类型"><a href="#添加更多-message-类型" class="headerlink" title="添加更多 message 类型"></a>添加更多 message 类型</h3><p>可以在单个 .proto 文件中定义多种 message 类型。这在你需要定义多个相关 message 的时候会很有用 - 例如，如果要定义与搜索请求相应的搜索回复 message - SearchResponse message，则可以将其添加到相同的 .proto：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">message SearchRequest &#123;</span><br><span class="line">  required string query = 1;</span><br><span class="line">  optional int32 page_number = 2;</span><br><span class="line">  optional int32 result_per_page = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message SearchResponse &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>组合 messages 会导致膨胀虽然可以在单个 .proto 文件中定义多种 messages 类型（例如 message，enum 和 service），但是当在单个文件中定义了大量具有不同依赖关系的 messages 时，它也会导致依赖性膨胀。建议每个 .proto 文件包含尽可能少的 message 类型。</p>
</blockquote>
<h3 id="添加注释"><a href="#添加注释" class="headerlink" title="添加注释"></a>添加注释</h3><p>为你的 .proto 文件添加注释，可以使用 C/C++ 语法风格的注释 // 和 /* … */ 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* SearchRequest represents a search query, with pagination options to</span><br><span class="line"> * indicate which results to include in the response. */</span><br><span class="line"></span><br><span class="line">message SearchRequest &#123;</span><br><span class="line">  required string query = 1;</span><br><span class="line">  optional int32 page_number = 2;  // Which page number do we want?</span><br><span class="line">  optional int32 result_per_page = 3;  // Number of results to return per page.</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Reserved-保留字段"><a href="#Reserved-保留字段" class="headerlink" title="Reserved 保留字段"></a>Reserved 保留字段</h3><p>如果你通过完全删除字段或将其注释掉来更新 message 类型，则未来一些用户在做他们的修改或更新时就可能会再次使用这些字段编号。如果以后加载相同 <code>.proto</code> 的旧版本，这可能会导致一些严重问题，包括数据损坏，隐私错误等。确保不会发生这种情况的一种方法是指定已删除字段的字段编号（有时也需要指定名称为保留状态，英文名称可能会导致 JSON 序列化问题）为 “保留” 状态。如果将来的任何用户尝试使用这些字段标识符，protocol buffer 编译器将会抱怨。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">message Foo &#123;</span><br><span class="line">  reserved 2, 15, 9 to 11;</span><br><span class="line">  reserved &quot;foo&quot;, &quot;bar&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>请注意，你不能在同一 “reserved” 语句中将字段名称和字段编号混合在一起指定。</p>
<h3 id="你的-proto-文件将生成什么？"><a href="#你的-proto-文件将生成什么？" class="headerlink" title="你的 .proto 文件将生成什么？"></a>你的 .proto 文件将生成什么？</h3><p>当你在 <code>.proto</code> 上运行 protocol buffer 编译器时，编译器将会生成所需语言的代码，这些代码可以操作文件中描述的 message 类型，包括获取和设置字段值、将 message 序列化为输出流、以及从输入流中解析出 message。</p>
<ul>
<li>  对于 C++，编译器从每个 .proto 生成一个 .h 和 .cc 文件，其中包含文件中描述的每种 message 类型对应的类。</li>
<li>  对于 <strong>Java</strong>，编译器为每个 message 类型生成一个 .java 文件（类），以及用于创建 message 类实例的特殊 Builder 类。</li>
<li>  <strong>Python</strong> 有点不同 - Python 编译器生成一个模块，其中包含 .proto 中每种 message 类型的静态描述符，然后与元类一起使用以创建必要的 Python 数据访问类。</li>
<li>对于 <strong>Go</strong>，编译器会生成一个 .pb.go 文件，其中包含对应每种 message 类型的类型。<br>  你可以按照所选语言的教程了解更多有关各种语言使用 API ​​的信息。有关更多 API 详细信息，请参阅相关的 <a href="https://developers.google.com/protocol-buffers/docs/reference/overview">API 参考</a>。</li>
</ul>
<h2 id="标量值类型"><a href="#标量值类型" class="headerlink" title="标量值类型"></a>标量值类型</h2><p>标量 message 字段可以具有以下几种类型之一 - 该表显示 .proto 文件中指定的类型，以及自动生成的类中的相应类型：</p>
<table>
<thead>
<tr>
<th>.proto Type</th>
<th>Notes</th>
<th>C++ Type</th>
<th>Java Type</th>
<th>Python Type</th>
<th>Go Type</th>
</tr>
</thead>
<tbody><tr>
<td>double</td>
<td></td>
<td>double</td>
<td>double</td>
<td>float</td>
<td>*float64</td>
</tr>
<tr>
<td>float</td>
<td></td>
<td>float</td>
<td>float</td>
<td>float</td>
<td>*float32</td>
</tr>
<tr>
<td>int32</td>
<td>使用可变长度编码。编码负数的效率低 - 如果你的字段可能有负值，请改用 sint32</td>
<td>int32</td>
<td>int</td>
<td>int</td>
<td>*int32</td>
</tr>
<tr>
<td>int64</td>
<td>使用可变长度编码。编码负数的效率低 - 如果你的字段可能有负值，请改用 sint64</td>
<td>int64</td>
<td>long</td>
<td>int/long</td>
<td>*int64</td>
</tr>
<tr>
<td>uint32</td>
<td>使用可变长度编码</td>
<td>uint32</td>
<td>int</td>
<td>int/long</td>
<td>*uint32</td>
</tr>
<tr>
<td>uint64</td>
<td>使用可变长度编码</td>
<td>uint64</td>
<td>long</td>
<td>int/long</td>
<td>*uint64</td>
</tr>
<tr>
<td>sint32</td>
<td>使用可变长度编码。有符号的 int 值。这些比常规 int32 对负数能更有效地编码</td>
<td>int32</td>
<td>int</td>
<td>int</td>
<td>*int32</td>
</tr>
<tr>
<td>sint64</td>
<td>使用可变长度编码。有符号的 int 值。这些比常规 int64 对负数能更有效地编码</td>
<td>int64</td>
<td>long</td>
<td>int/long</td>
<td>*int64</td>
</tr>
<tr>
<td>fixed32</td>
<td>总是四个字节。如果值通常大于 228，则比 uint32 更有效。</td>
<td>uint32</td>
<td>int</td>
<td>int/long</td>
<td>*uint32</td>
</tr>
<tr>
<td>fixed64</td>
<td>总是八个字节。如果值通常大于 256，则比 uint64 更有效。</td>
<td>uint64</td>
<td>long</td>
<td>int/long</td>
<td>*uint64</td>
</tr>
<tr>
<td>sfixed32</td>
<td>总是四个字节</td>
<td>int32</td>
<td>int</td>
<td>int</td>
<td>*int32</td>
</tr>
<tr>
<td>sfixed64</td>
<td>总是八个字节</td>
<td>int64</td>
<td>long</td>
<td>int/long</td>
<td>*int64</td>
</tr>
<tr>
<td>bool</td>
<td></td>
<td>bool</td>
<td>boolean</td>
<td>bool</td>
<td>*bool</td>
</tr>
<tr>
<td>string</td>
<td>字符串必须始终包含 UTF-8 编码或 7 位 ASCII 文本</td>
<td>string</td>
<td>String</td>
<td>str/unicode</td>
<td>*string</td>
</tr>
<tr>
<td>bytes</td>
<td>可以包含任意字节序列</td>
<td>string</td>
<td>ByteString</td>
<td>str</td>
<td>byte</td>
</tr>
</tbody></table>
<p>在 Java 中，无符号的 32 位和 64 位整数使用它们对应的带符号表示，第一个 bit 位只是简单的存储在符号位中。<br>在所有情况下，设置字段的值将执行类型检查以确保其有效。<br>64 位或无符号 32 位整数在解码时始终表示为 long，但如果在设置字段时给出 int，则可以为int。在所有情况下，该值必须适合设置时的类型。见。<br>Python 字符串在解码时表示为 unicode，但如果给出了 ASCII 字符串，则可以是 str（这条可能会发生变化）。</p>
<h2 id="Optional-可选字段和默认值"><a href="#Optional-可选字段和默认值" class="headerlink" title="Optional 可选字段和默认值"></a>Optional 可选字段和默认值</h2><p>如上所述，message 描述中的元素可以标记为可选 optional。格式良好的 message 可能包含也可能不包含被声明为可选的元素。解析 message 时，如果 message 不包含 optional 元素，则解析对象中的相应字段将设置为该字段的默认值。可以将默认值指定为 message 描述的一部分。例如，假设你要为 SearchRequest 的 result_per_page 字段提供默认值10。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">optional int32 result_per_page = 3 [default = 10];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果未为 optional 元素指定默认值，则使用特定于类型的默认值：对于字符串，默认值为空字符串。对于 bool，默认值为 false。对于数字类型，默认值为零。对于枚举，默认值是枚举类型定义中列出的第一个值。这意味着在将值添加到枚举值列表的开头时必须小心。有关如何安全的更改定义的指导，请参阅 <code>更新 Message 类型</code> 部分（见下面的 <code>更新 message 类型</code>）。</p>
<h2 id="枚举-Enumerations"><a href="#枚举-Enumerations" class="headerlink" title="枚举 Enumerations"></a>枚举 Enumerations</h2><p>在定义 message 类型时，你可能希望其中一个字段只有一个预定义的值列表。例如，假设你要为每个 SearchRequest 添加语料库字段，其中语料库可以是 UNIVERSAL，WEB，IMAGES，LOCAL，NEWS，PRODUCTS 或 VIDEO。你可以通过向 message 定义添加枚举来简单地执行此操作 - 具有枚举类型的字段只能将一组指定的常量作为其值（如果你尝试提供不同的值，则解析器会将其视为一个未知的领域）。在下面的例子中，我们添加了一个名为 Corpus 的枚举，其中包含所有可能的值，之后定义了一个类型为 Corpus 枚举的字段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">message SearchRequest &#123;</span><br><span class="line">  required string query = 1;</span><br><span class="line">  optional int32 page_number = 2;</span><br><span class="line">  optional int32 result_per_page = 3 [default = 10];</span><br><span class="line">  enum Corpus &#123;</span><br><span class="line">    UNIVERSAL = 0;</span><br><span class="line">    WEB = 1;</span><br><span class="line">    IMAGES = 2;</span><br><span class="line">    LOCAL = 3;</span><br><span class="line">    NEWS = 4;</span><br><span class="line">    PRODUCTS = 5;</span><br><span class="line">    VIDEO = 6;</span><br><span class="line">  &#125;</span><br><span class="line">  optional Corpus corpus = 4 [default = UNIVERSAL];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>你可以通过为不同的枚举常量指定相同的值来定义别名。为此，你需要将 allow_alias 选项设置为true，否则 protocol 编译器将在找到别名时生成错误消息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum EnumAllowingAlias &#123;</span><br><span class="line">  option allow_alias = true;</span><br><span class="line">  UNKNOWN = 0;</span><br><span class="line">  STARTED = 1;</span><br><span class="line">  RUNNING = 1;</span><br><span class="line">&#125;</span><br><span class="line">enum EnumNotAllowingAlias &#123;</span><br><span class="line">  UNKNOWN = 0;</span><br><span class="line">  STARTED = 1;</span><br><span class="line">  // RUNNING = 1;  // 取消此行注释将导致 Google 内部的编译错误和外部的警告消息</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>枚举器常量必须在 32 位整数范围内。由于 <code>enum</code> 值在线上使用 <code>varint encoding</code>，负值效率低，因此不推荐使用。你可以在 message 中定义 enums，如上例所示的那样。或者将其定义在 message 外部 - 这样这些 <code>enum</code> 就可以在 <code>.proto</code> 文件中的任何 message 定义中重用。你还可以使用一个 message 中声明的 <code>enum</code> 类型作为不同 message 中字段的类型，使用语法 <em>MessageType</em>.<em>EnumType</em> 来实现。</p>
<p>当你在使用 <code>enum</code> 的 <code>.proto</code> 上运行 protocol buffer 编译器时，生成的代码将具有相应的用于　Java 或 C++ 的 <code>enum</code>，或者用于创建集合的 Python 的特殊 <code>EnumDescriptor</code> 类。运行时生成的类中具有整数值的符号常量。</p>
<p>有关如何在应用程序中使用 enums 的更多信息，请参阅相关语言的 <a href="https://developers.google.com/protocol-buffers/docs/reference/overview">代码生成指南</a></p>
<h3 id="保留值"><a href="#保留值" class="headerlink" title="保留值"></a>保留值</h3><p>如果你通过完全删除枚举条目或将其注释掉来更新枚举类型，则未来用户可能在对 message 做出自己的修改或更新时重复使用这些数值。如果以后加载相同 <code>.proto</code> 的旧版本，这可能会导致严重问题，包括数据损坏，隐私错误等。确保不会发生这种情况的一种方法是指定已删除字段的字段编号（有时也需要指定名称为保留状态，英文名称可能会导致 JSON 序列化问题）为 “保留” 状态。如果将来的任何用户尝试使用这些字段标识符，protocol buffer 编译器将会抱怨。你可以使用 <code>max</code> 关键字指定保留的数值范围一直到最大值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">enum Foo &#123;</span><br><span class="line">  reserved 2, 15, 9 to 11, 40 to max;</span><br><span class="line">  reserved &quot;FOO&quot;, &quot;BAR&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>请注意，你不能在同一 “reserved” 语句中将字段名称和字段编号混合在一起指定。</p>
<h2 id="使用其他-Message-类型"><a href="#使用其他-Message-类型" class="headerlink" title="使用其他 Message 类型"></a>使用其他 Message 类型</h2><p>你可以使用其他 message 类型作为字段类型。例如，假设你希望在每个 SearchResponse 消息中包含 Result message - 为此，你可以在同一 .proto 中定义 Result message 类型，然后在SearchResponse 中指定 Result 类型的字段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">message SearchResponse &#123;</span><br><span class="line">  repeated Result result = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Result &#123;</span><br><span class="line">  required string url = 1;</span><br><span class="line">  optional string title = 2;</span><br><span class="line">  repeated string snippets = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="导入定义-Importing-Definitions"><a href="#导入定义-Importing-Definitions" class="headerlink" title="导入定义 Importing Definitions"></a>导入定义 Importing Definitions</h3><p>在上面的示例中，Result message 类型在与 SearchResponse 相同的文件中定义 - 如果要用作字段类型的 message 类型已在另一个 .proto 文件中定义，该怎么办？</p>
<p>你可以通过导入来使用其他 .proto 文件中的定义。要导入另一个 .proto 的定义，可以在文件顶部添加一个 import 语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &quot;myproject/other_protos.proto&quot;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>默认情况下，你只能使用直接导入的 .proto 文件中的定义。但是，有时你可能需要将 .proto 文件移动到新位置。现在，你可以在旧位置放置一个虚拟 .proto 文件，以使用 import public 概念将所有导入转发到新位置，而不是直接移动 .proto 文件并在一次更改中更新所有调用点。导入包含 import public 语句的 proto 的任何人都可以传递依赖导入公共依赖项。例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// new.proto</span><br><span class="line">// All definitions are moved here</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// old.proto</span><br><span class="line">// This is the proto that all clients are importing.</span><br><span class="line">import public &quot;new.proto&quot;;</span><br><span class="line">import &quot;other.proto&quot;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// client.proto</span><br><span class="line">import &quot;old.proto&quot;;</span><br><span class="line">// 你可以使用 old.proto 和 new.proto 中的定义，但无法使用 other.proto</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用命令 -I/–proto_path 让 protocol 编译器在指定的一组目录中搜索要导入的文件。如果没有给出这个命令选项，它将查找调用编译器所在的目录。通常，你应将 –proto_path 设置为项目的根目录，并对所有导入使用完全限定名称。</p>
<h3 id="使用-proto3-Message-类型"><a href="#使用-proto3-Message-类型" class="headerlink" title="使用 proto3 Message 类型"></a>使用 proto3 Message 类型</h3><p>可以导入 <a href="https://developers.google.com/protocol-buffers/docs/proto3">proto3</a> message 类型并在 proto2 message 中使用它们，反之亦然。但是，proto2 枚举不能用于 proto3 语法。</p>
<h2 id="嵌套类型-Nested-Types"><a href="#嵌套类型-Nested-Types" class="headerlink" title="嵌套类型 Nested Types"></a>嵌套类型 Nested Types</h2><p>你可以在其他 message 类型中定义和使用 message 类型，如下例所示 - 此处结果消息在SearchResponse 消息中定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">message SearchResponse &#123;</span><br><span class="line">  message Result &#123;</span><br><span class="line">    required string url = 1;</span><br><span class="line">    optional string title = 2;</span><br><span class="line">    repeated string snippets = 3;</span><br><span class="line">  &#125;</span><br><span class="line">  repeated Result result = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果要在其父消息类型之外重用此消息类型，请将其称为 _Parent.Type_：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">message SomeOtherMessage &#123;</span><br><span class="line">  optional SearchResponse.Result result = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>你可以根据需要深入的嵌套消息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">message Outer &#123;                  // Level 0</span><br><span class="line">  message MiddleAA &#123;  // Level 1</span><br><span class="line">    message Inner &#123;   // Level 2</span><br><span class="line">      required int64 ival = 1;</span><br><span class="line">      optional bool  booly = 2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  message MiddleBB &#123;  // Level 1</span><br><span class="line">    message Inner &#123;   // Level 2</span><br><span class="line">      required int32 ival = 1;</span><br><span class="line">      optional bool  booly = 2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Groups"><a href="#Groups" class="headerlink" title="Groups"></a>Groups</h3><p><strong>请注意，此功能已弃用，在创建新消息类型时不应使用 - 请改用嵌套消息类型。</strong><br>Groups 是在 message 定义中嵌套信息的另一种方法。例如，指定包含许多结果的SearchResponse 的另一种方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">message SearchResponse &#123;</span><br><span class="line">  repeated group Result = 1 &#123;</span><br><span class="line">    required string url = 2;</span><br><span class="line">    optional string title = 3;</span><br><span class="line">    repeated string snippets = 4;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>group 只是将嵌套 message 类型和字段组合到单个声明中。在你的代码中，你可以将此消息视为具有名为 <code>result</code> 的 <code>Result</code> 类型字段（前一名称转换为小写，以便它不与前者冲突）。因此，此示例完全等同于上面的 <code>SearchResponse</code>，但 message 具有不同的编码结果。</p>
<blockquote>
<p>译者注：<br>再次强调，此功能<strong>已弃用</strong>，这里只为尽可能保留原文内容。</p>
</blockquote>
<h2 id="更新-message-类型"><a href="#更新-message-类型" class="headerlink" title="更新 message 类型"></a>更新 message 类型</h2><p>如果现有的 message 类型不再满足你的所有需求 - 例如，你希望 message 格式具有额外的字段 - 但你仍然希望使用旧格式创建代码，请不要担心！在不破坏任何现有代码的情况下更新 message 类型非常简单。请记住以下规则：</p>
<ul>
<li>  请勿更改任何现有字段的字段编号。</li>
<li>  你添加的任何新字段都应该是 <code>optional</code> 或 <code>repeated</code>。这意味着使用“旧”消息格式的代码序列化的任何消息都可以由新生成的代码进行解析，因为它们不会缺少任何 <code>required</code> 元素。你应该为这些元素设置合理的 <code>默认值</code>，以便新代码可以正确地与旧代码生成的 message 进行交互。同样，你的新代码创建的 message 可以由旧代码解析：旧的二进制文件在解析时只是忽略新字段。但是未丢弃这个新字段（未知字段），如果稍后序列化消息，则将新字段（未知字段）与其一起序列化 - 因此，如果将消息传递给新代码，则新字段仍然可用。</li>
<li>  只要在更新的 message 类型中不再使用字段编号，就可以删除非必填字段。你可能希望重命名该字段，可能添加前缀 “OBSOLETE_“，或者将字段编号<strong>保留（Reserved）</strong>，以便将来你的 <code>.proto</code> 的用户不会不小心重用这个编号。</li>
<li>  只要类型和编号保持不变，非必填字段就可以转换为扩展 <a href="https://developers.google.com/protocol-buffers/docs/proto#extensions">extensions</a>，反之亦然。</li>
<li>  <code>int32</code>，<code>uint32</code>，<code>int64</code>，<code>uint64</code> 和 <code>bool</code> 都是兼容的 - 这意味着你可以将字段从这些类型更改为另一种类型，而不会破坏向前或向后兼容性。如果从中解析出一个不符合相应类型的数字，你将获得与在 C++ 中将该数字转换为该类型时相同的效果（例如，如果将 64 位数字作为 int32 读取，它将被截断为 32 位）。</li>
<li>  <code>sint32</code> 和 <code>sint64</code> 彼此兼容，但与其他整数类型不兼容。</li>
<li>  只要字节是有效的 UTF-8，<code>string</code> 和 <code>bytes</code> 就是兼容的。</li>
<li>  如果字节包含 message 的编码版本，则嵌入 message 与 <code>bytes</code> 兼容。</li>
<li>  <code>fixed32</code> 与 <code>sfixed32</code> 兼容，<code>fixed64</code> 与 <code>sfixed64</code> 兼容。</li>
<li>  <code>optional</code> 与 <code>repeated</code> 兼容。给定重复字段的序列化数据作为输入，期望该字段为 <code>optional</code> 的客户端将采用最后一个输入值（如果它是基本类型字段）或合并所有输入元素（如果它是 message 类型字段）。</li>
<li>  更改默认值通常是正常的，只要你记住永远不会通过网络发送默认值。因此，如果程序接收到未设置特定字段的消息，则程序将看到该程序的协议版本中定义的默认值。它不会看到发件人代码中定义的默认值。</li>
<li>  <code>enum</code> 与 <code>int32</code>，<code>uint32</code>，<code>int64</code> 和 <code>uint64</code>兼容（注意，如果它们不适合，值将被截断），但要注意 message 反序列化时客户端代码对待它们将有所不同。值得注意的是，当 message 被反序列化时，将丢弃无法识别的 <code>enum</code> 值，这使得字段的 <code>has..</code> 访问器返回 false 并且其 getter 返回 <code>enum</code> 定义中列出的第一个值，或者如果指定了一个默认值则返回默认值。在 repeated 枚举字段的情况下，任何无法识别的值都将从列表中删除。但是，整数字段将始终保留其值。因此，在有可能接收超出范围的枚举值时，对整数升级为 <code>enum</code> 这一操作需要非常小心。</li>
<li>  在当前的 Java 和 C++ 实现中，当删除无法识别的 <code>enum</code> 值时，它们与其他未知字段一起存储。请注意，如果此数据被序列化，然后由识别这些值的客户端重新解析，则会导致奇怪的行为。在 optional 可选字段的情况下，即使在反序列化原始 message 之后写入新值，旧值仍然可以被客户端识别。在 repeated 字段的情况下，旧值将出现在任何已识别和新添加的值之后，这意味着顺序将不被保留。</li>
<li>  将单个 <code>optional</code> 值更改为 <strong>new</strong><code>oneof</code> 的成员是安全且二进制兼容的。如果你确定没有代码一次设置多个，则将多个 <code>optional</code> 字段移动到新的 <code>oneof</code> 中可能是安全的。但是将任何字段移动到现有的 <code>oneof</code> 是不安全的。</li>
</ul>
<h2 id="扩展-Extensions"><a href="#扩展-Extensions" class="headerlink" title="扩展 Extensions"></a>扩展 Extensions</h2><p>通过扩展，你可以声明 message 中的一系列字段编号用于第三方扩展。扩展名是那些未由原始 .proto 文件定义的字段的占位符。这允许通过使用这些字段编号来定义部分或全部字段从而将其它 .proto 文件定义的字段添加到当前 message 定义中。我们来看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">message Foo &#123;</span><br><span class="line">  // ...</span><br><span class="line">  extensions 100 to 199;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这表示 Foo 中的字段数 [100,199] 的范围是为扩展保留的。其他用户现在可以使用指定范围内的字段编号在他们自己的 .proto 文件中为 Foo 添加新字段，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extend Foo &#123;</span><br><span class="line">  optional int32 bar = 126;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这会将名为 bar 且编号为 126 的字段添加到 Foo 的原始定义中。</p>
<blockquote>
<p>译者注：<br>第一段翻译过来的语义实在是太别扭了（因为站在了被扩展字段所在的 .proto 文件的角度来看待扩展），实际站在扩展字段所在的 .proto 文件的角度－就是可以在自己的 .proto 文件中扩展其他人定义的另一个 .proto 中的 message。</p>
</blockquote>
<p>当用户的 Foo 消息被编码时，其格式与用户在 Foo 中常规定义新字段的格式完全相同。但是，在应用程序代码中访问扩展字段的方式与访问常规字段略有不同 - 生成的数据访问代码具有用于处理扩展的特殊访问器。那么，举个例子，下面就是如何在 C++ 中设置 bar 的值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Foo foo;</span><br><span class="line">foo.SetExtension(bar, 15);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>类似地，Foo 类定义模板化访问器 HasExtension()，ClearExtension()，GetExtension()，MutableExtension() 和 AddExtension()。它们都具有与正常字段生成的访问器相匹配的语义。有关使用扩展的更多信息，请参阅所选语言的代码生成参考。</p>
<p>请注意，扩展可以是任何字段类型，包括 message 类型，但不能是 oneofs 或 maps。</p>
<h3 id="嵌套扩展"><a href="#嵌套扩展" class="headerlink" title="嵌套扩展"></a>嵌套扩展</h3><p>你可以在另一种 message 类型内部声明扩展：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">message Baz &#123;</span><br><span class="line">  extend Foo &#123;</span><br><span class="line">    optional int32 bar = 126;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这种情况下，访问此扩展的 C++ 代码为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Foo foo;</span><br><span class="line">foo.SetExtension(Baz::bar, 15);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>换句话说，唯一的影响是 bar 是在 Baz 的范围内定义。</p>
<blockquote>
<p>注意:<br>这是一个常见的混淆源：在一个 message 类型中声明嵌套的扩展块并不意味着外部类型和扩展类型之间存在任何关系。特别是，上面的例子并不意味着 Baz 是 Foo 的任何子类。这意味着符号栏是在 Baz 范围内声明的；它仅仅只是一个静态成员而已。</p>
</blockquote>
<p>一种常见的模式是在扩展的字段类型范围内定义扩展 - 例如，这里是 Baz 类型的 Foo 扩展，其中扩展名被定义为 Baz 的一部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">message Baz &#123;</span><br><span class="line">  extend Foo &#123;</span><br><span class="line">    optional Baz foo_ext = 127;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>译者注：<br>这里比较绕，实际上就是要对某个 message A 扩展一个字段 B（B 类型），那么可以将这条扩展语句写在 message B 的定义里。</p>
</blockquote>
<p>但是，并不是必须要在类型内才能定义该类型的扩展字段。你也可以这样做：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">message Baz &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 该定义甚至可以移到另一个文件中</span><br><span class="line">extend Foo &#123;</span><br><span class="line">  optional Baz foo_baz_ext = 127;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实际上，这种语法可能是首选的，以避免混淆。如上所述，嵌套语法经常被不熟悉扩展的用户误认为是子类。</p>
<h3 id="选择扩展字段编号"><a href="#选择扩展字段编号" class="headerlink" title="选择扩展字段编号"></a>选择扩展字段编号</h3><p>确保两个用户不使用相同的字段编号向同一 message 类型添加扩展名非常重要 - 如果扩展名被意外解释为错误类型，则可能导致数据损坏。你可能需要考虑为项目定义扩展编号的约定以防止这种情况发生。</p>
<p>如果你的编号约定可能涉及那些具有非常大字段编号的扩展，则可以使用 max 关键字指定扩展范围至编号最大值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">message Foo &#123;</span><br><span class="line">  extensions 1000 to max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最大值为 229 - 1，或者 536,870,911。</p>
<p>与一般选择字段编号时一样，你的编号约定还需要避免 19000 到 19999 的字段编号(FieldDescriptor::kFirstReservedNumber 到 FieldDescriptor::kLastReservedNumber)，因为它们是为 Protocol Buffers 实现保留的。你可以定义包含此范围的扩展名范围，但 protocol 编译器不允许你使用这些编号定义实际扩展名。</p>
<h2 id="Oneof"><a href="#Oneof" class="headerlink" title="Oneof"></a>Oneof</h2><p>如果你的 message 包含许多可选字段，并且最多只能同时设置其中一个字段，则可以使用 oneof 功能强制执行此行为并节省内存。</p>
<p>Oneof 字段类似于可选字段，除了 oneof 共享内存中的所有字段，并且最多只能同时设置一个字段。设置 oneof 的任何成员会自动清除所有其他成员。你可以使用特殊的 case() 或 WhichOneof() 方法检查 oneof 字段中当前是哪个值（如果有）被设置，具体方法取决于你选择的语言。</p>
<h3 id="使用-Oneof"><a href="#使用-Oneof" class="headerlink" title="使用 Oneof"></a>使用 Oneof</h3><p>要在 .proto 中定义 oneof，请使用 oneof 关键字，后跟你的 oneof 名称，在本例中为 test_oneof：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">message SampleMessage &#123;</span><br><span class="line">  oneof test_oneof &#123;</span><br><span class="line">     string name = 4;</span><br><span class="line">     SubMessage sub_message = 9;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后，将 oneof 字段添加到 oneof 定义中。你可以添加任何类型的字段，但不能使用 <code>required</code>，<code>optional</code> 或 <code>repeated</code> 关键字。如果需要向 oneof 添加重复字段，可以使用包含重复字段的 message。</p>
<p>在生成的代码中，oneof 字段与常规 <code>optional</code> 方法具有相同的 getter 和 setter。你还可以使用特殊方法检查 oneof 中的值（如果有）。你可以在相关的 API 参考中找到有关所选语言的 oneof API的更多信息。</p>
<h3 id="Oneof-特性"><a href="#Oneof-特性" class="headerlink" title="Oneof 特性"></a>Oneof 特性</h3><ul>
<li>设置 oneof 字段将自动清除 oneof 的所有其他成员。因此，如果你设置了多个字段，则只有你设置的最后一个字段仍然具有值。  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SampleMessage message;</span><br><span class="line">message.set_name(&quot;name&quot;);</span><br><span class="line">CHECK(message.has_name());</span><br><span class="line">message.mutable_sub_message();   // Will clear name field.</span><br><span class="line">CHECK(!message.has_name());</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>如果解析器遇到同一个 oneof 的多个成员，则在解析的消息中仅使用看到的最后一个成员。</li>
<li>oneof 不支持扩展</li>
<li>oneof 不能使用 repeated</li>
<li>反射 API 适用于 oneof 字段</li>
<li>如果你使用的是 C++，请确保你的代码不会导致内存崩溃。以下示例代码将崩溃，因为已通过调用 set_name() 方法删除了 sub_message。  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SampleMessage message;</span><br><span class="line">SubMessage* sub_message = message.mutable_sub_message();</span><br><span class="line">message.set_name(&quot;name&quot;);      // Will delete sub_message</span><br><span class="line">sub_message-&gt;set_...            // Crashes here</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>同样在 C++中，如果你使用 Swap() 交换了两条 oneofs 消息，则每条消息将以另一条消息的 oneof 实例结束：在下面的示例中，msg1 将具有 sub_message 而 msg2 将具有 name。  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SampleMessage msg1;</span><br><span class="line">msg1.set_name(&quot;name&quot;);</span><br><span class="line">SampleMessage msg2;</span><br><span class="line">msg2.mutable_sub_message();</span><br><span class="line">msg1.swap(&amp;msg2);</span><br><span class="line">CHECK(msg1.has_sub_message());</span><br><span class="line">CHECK(msg2.has_name());</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="向后兼容性问题"><a href="#向后兼容性问题" class="headerlink" title="向后兼容性问题"></a>向后兼容性问题</h3><p>添加或删除其中一个字段时要小心。如果检查 oneof 的值返回 None/NOT_SET，则可能意味着 oneof 尚未设置或已设置为 oneof 的另一个字段。这种情况是无法区分的，因为无法知道未知字段是否是 oneof 成员。</p>
<h4 id="标签重用问题"><a href="#标签重用问题" class="headerlink" title="标签重用问题"></a>标签重用问题</h4><ul>
<li>  <strong>将 optional 可选字段移入或移出 oneof</strong>：在序列化和解析 message 后，你可能会丢失一些信息（某些字段将被清除）。但是，你可以安全地将单个字段移动到新的 oneof 中，并且如果已知只有一个字段被设置，则可以移动多个字段。</li>
<li>  <strong>删除 oneof 字段并将其重新添加回去</strong>：在序列化和解析 message 后，这可能会清除当前设置的 oneof 字段。</li>
<li>  <strong>拆分或合并 oneof</strong>：这与移动常规的 optional 字段有类似的问题。</li>
</ul>
<h2 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h2><p>如果要在数据定义中创建关联映射，protocol buffers 提供了一种方便快捷的语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map&lt;key_type, value_type&gt; map_field = N;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>…其中 <code>key_type</code> 可以是任何整数或字符串类型（任何标量类型除浮点类型和 <code>bytes</code>）。请注意，枚举不是有效的 <code>key_type</code>。<code>value_type</code> 可以是除 map 之外的任何类型。</p>
<p>因此，举个例子，如果要创建项目映射，其中每个 “Project” message 都与字符串键相关联，则可以像下面这样定义它：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">map&lt;string, Project&gt; projects = 3;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>生成的 map API 目前可用于所有 proto2 支持的语言。你可以在相关的 <a href="https://developers.google.com/protocol-buffers/docs/reference/overview">API 参考</a> 中找到有关所选语言的 map API 的更多信息。</p>
<h3 id="Maps-特性"><a href="#Maps-特性" class="headerlink" title="Maps 特性"></a>Maps 特性</h3><ul>
<li>  maps 不支持扩展</li>
<li>  maps 不能是 repeated、optional、required</li>
<li>  map 值的格式排序和 map 迭代排序未定义，因此你不能依赖于特定顺序的 map 项</li>
<li>  生成 .proto 的文本格式时，maps 按键排序。数字键按数字排序</li>
<li>  当解析或合并时，如果有重复的 map 键，则使用最后看到的键。从文本格式解析 map 时，如果存在重复键，则解析可能会失败</li>
</ul>
<h3 id="向后兼容性"><a href="#向后兼容性" class="headerlink" title="向后兼容性"></a>向后兼容性</h3><p>map 语法等效于以下内容，因此不支持 map 的 protocol buffers 实现仍可处理你的数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">message MapFieldEntry &#123;</span><br><span class="line">  optional key_type key = 1;</span><br><span class="line">  optional value_type value = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repeated MapFieldEntry map_field = N;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>任何支持 maps 的 protocol buffers 实现都必须生成和接受上述定义所能接受的数据。</p>
<h2 id="Packages"><a href="#Packages" class="headerlink" title="Packages"></a>Packages</h2><p>你可以将 optional 可选的包说明符添加到 .proto 文件，以防止 protocol message 类型之间的名称冲突。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package foo.bar;</span><br><span class="line">message Open &#123; ... &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后，你可以在定义 message 类型的字段时使用包说明符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">message Foo &#123;</span><br><span class="line">  ...</span><br><span class="line">  required foo.bar.Open open = 1;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>package 影响生成的代码的方式取决于你所选择的语言：</p>
<ul>
<li>  在 <strong>C++</strong> 中，生成的类包含在 C++ 命名空间中。例如，Open 将位于命名空间 foo::bar 中。</li>
<li>  在 <strong>Java</strong> 中，除非在 .proto 文件中明确提供选项 java_package，否则该包将用作 Java 包</li>
<li>  在 <strong>Python</strong> 中，package 指令被忽略，因为 Python 模块是根据它们在文件系统中的位置进行组织的</li>
</ul>
<p>请注意，即使 package 指令不直接影响生成的代码，但是例如在 Python 中，仍然强烈建议指定 .proto 文件的包，否则可能导致描述符中的命名冲突并使 proto 对于其他语言不方便。</p>
<h3 id="Packages-和名称解析"><a href="#Packages-和名称解析" class="headerlink" title="Packages 和名称解析"></a>Packages 和名称解析</h3><p>protocol buffer 语言中的类型名称解析与 C++ 类似：首先搜索最里面的范围，然后搜索下一个范围，依此类推，每个包被认为是其父包的 “内部”。一个领先的 ‘.’（例如 .foo.bar.Baz）意味着从最外层的范围开始。</p>
<p>protocol buffer 编译器通过解析导入的 .proto 文件来解析所有类型名称。每种语言的代码生成器都知道如何使用相应的语言类型，即使它具有不同的范围和规则。</p>
<h2 id="定义服务"><a href="#定义服务" class="headerlink" title="定义服务"></a>定义服务</h2><p>如果要将 message 类型与 RPC（远程过程调用）系统一起使用，则可以在 .proto 文件中定义 RPC 服务接口，protocol buffer 编译器将使用你选择的语言生成服务接口代码和存根。因此，例如，如果要定义一个 RPC 服务，其中具有一个获取 SearchRequest 并返回 SearchResponse 的方法，可以在 .proto 文件中定义它，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service SearchService &#123;</span><br><span class="line">  rpc Search (SearchRequest) returns (SearchResponse);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>默认情况下，protocol 编译器将生成一个名为 SearchService 的抽象接口和相应的 “存根” 实现。存根转发所有对 RpcChannel 的调用，而 RpcChannel 又是一个抽象接口，你必须根据自己的 RPC 系统自行定义。例如，你可以实现一个 RpcChannel，它将 message 序列化并通过 HTTP 将其发送到服务器。换句话说，生成的存根提供了一个类型安全的接口，用于进行基于 protocol-buffer 的 RPC 调用，而不会将你锁定到任何特定的 RPC 实现中。所以，在 C++ 中，你可能会得到这样的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using google::protobuf;</span><br><span class="line"></span><br><span class="line">protobuf::RpcChannel* channel;</span><br><span class="line">protobuf::RpcController* controller;</span><br><span class="line">SearchService* service;</span><br><span class="line">SearchRequest request;</span><br><span class="line">SearchResponse response;</span><br><span class="line"></span><br><span class="line">void DoSearch() &#123;</span><br><span class="line">  // You provide classes MyRpcChannel and MyRpcController, which implement</span><br><span class="line">  // the abstract interfaces protobuf::RpcChannel and protobuf::RpcController.</span><br><span class="line">  channel = new MyRpcChannel(&quot;somehost.example.com:1234&quot;);</span><br><span class="line">  controller = new MyRpcController;</span><br><span class="line"></span><br><span class="line">  // The protocol compiler generates the SearchService class based on the</span><br><span class="line">  // definition given above.</span><br><span class="line">  service = new SearchService::Stub(channel);</span><br><span class="line"></span><br><span class="line">  // Set up the request.</span><br><span class="line">  request.set_query(&quot;protocol buffers&quot;);</span><br><span class="line"></span><br><span class="line">  // Execute the RPC.</span><br><span class="line">  service-&gt;Search(controller, request, response, protobuf::NewCallback(&amp;Done));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Done() &#123;</span><br><span class="line">  delete service;</span><br><span class="line">  delete channel;</span><br><span class="line">  delete controller;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>所有服务类还实现了 Service 接口，它提供了一种在编译时不知道方法名称或其输入和输出类型的情况下来调用特定方法的方法。在服务器端，这可用于实现一个可以注册服务的 RPC 服务器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">using google::protobuf;</span><br><span class="line"></span><br><span class="line">class ExampleSearchService : public SearchService &#123;</span><br><span class="line"> public:</span><br><span class="line">  void Search(protobuf::RpcController* controller,</span><br><span class="line">              const SearchRequest* request,</span><br><span class="line">              SearchResponse* response,</span><br><span class="line">              protobuf::Closure* done) &#123;</span><br><span class="line">    if (request-&gt;query() == &quot;google&quot;) &#123;</span><br><span class="line">      response-&gt;add_result()-&gt;set_url(&quot;http://www.google.com&quot;);</span><br><span class="line">    &#125; else if (request-&gt;query() == &quot;protocol buffers&quot;) &#123;</span><br><span class="line">      response-&gt;add_result()-&gt;set_url(&quot;http://protobuf.googlecode.com&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    done-&gt;Run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  // You provide class MyRpcServer.  It does not have to implement any</span><br><span class="line">  // particular interface; this is just an example.</span><br><span class="line">  MyRpcServer server;</span><br><span class="line"></span><br><span class="line">  protobuf::Service* service = new ExampleSearchService;</span><br><span class="line">  server.ExportOnPort(1234, service);</span><br><span class="line">  server.Run();</span><br><span class="line"></span><br><span class="line">  delete service;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果你不想插入自己现有的 RPC 系统，现在可以使用 <a href="https://github.com/grpc/grpc-common">gRPC</a>: 一个由谷歌开发的与语言和平台无关的开源 RPC 系统。gRPC 特别适用于 protocol buffers，并允许你使用特殊的 protocol buffers 编译器插件直接从 <code>.proto</code> 文件生成相关的 RPC 代码。但是，由于使用 proto2 和 proto3 生成的客户端和服务器之间存在潜在的兼容性问题，我们建议你使用 proto3 来定义 gRPC 服务。你可以在 <a href="https://www.jianshu.com/p/fc7485af828d">Proto3 语言指南</a> 中找到有关 proto3 语法的更多信息。如果你确实希望将 proto2 与 gRPC 一起使用，则需要使用 3.0.0 或更高版本的 protocol buffers 编译器和库。</p>
<p>除了 gRPC 之外，还有许多正在进行的第三方项目，用于开发 Protocol Buffers 的 RPC 实现。有关我们了解的项目的链接列表，请参阅 <a href="https://github.com/google/protobuf/blob/master/docs/third_party.md">第三方附加组件维基页面</a>。</p>
<h2 id="选项-Options"><a href="#选项-Options" class="headerlink" title="选项 Options"></a>选项 Options</h2><p>.proto 文件中的各个声明可以使用许多选项进行注释。选项不会更改声明的整体含义，但可能会影响在特定上下文中处理它的方式。可用选项的完整列表在 google/protobuf/descriptor.proto 中定义。</p>
<p>一些选项是文件级选项，这意味着它们应该在顶级范围内编写，而不是在任何消息，枚举或服务定义中。一些选项是 message 消息级选项，这意味着它们应该写在 message 消息定义中。一些选项是字段级选项，这意味着它们应该写在字段定义中。选项也可以写在枚举类型、枚举值、服务类型和服务方法上，但是，目前在这几个项目上并没有任何有用的选项。</p>
<p>以下是一些最常用的选项：</p>
<ul>
<li>java_package（文件选项）：要用于生成的 Java 类的包。如果 .proto 文件中没有给出显式的 java_package 选项，那么默认情况下将使用 proto 包（使用 .proto 文件中的 “package” 关键字指定）。但是，proto 包通常不能生成好的 Java 包，因为 proto 包不会以反向域名开头。如果不生成Java 代码，则此选项无效。```<br>  option java_package = “com.example.foo”;  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line">*   java\_outer\_classname（文件选项）：要生成的最外层 Java 类（以及文件名）的类名。如果 .proto 文件中没有指定显式的 java\_outer\_classname，则通过将 .proto 文件名转换为 camel-case 来构造类名（因此 foo\_bar.proto 变为 FooBar.java）。如果不生成 Java 代码，则此选项无效。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
option java_outer_classname = “Ponycopter”;</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">*   optimize\_for（文件选项）：可以设置为 **SPEED**，**CODE\_SIZE** 或 **LITE\_RUNTIME**。这会以下列方式影响 C++和 Java 的代码生成器（可能还有第三方生成器）：</span><br><span class="line">    </span><br><span class="line">    *   **SPEED（默认值）**：protocol buffer 编译器将生成用于对 message 类型进行序列化，解析和执行其他常见操作的代码。此代码经过高度优化。</span><br><span class="line">    *   **CODE\_SIZE**：protocol buffer 编译器将生成最少的类，并依赖于基于反射的共享代码来实现序列化，解析和各种其他操作。因此，生成的代码将比使用 SPEED 小得多，但操作会更慢。类仍将实现与 SPEED 模式完全相同的公共 API。此模式在包含大量 .proto 文件的应用程序中最有用，并且不需要所有这些文件都非常快。</span><br><span class="line">    *   **LITE\_RUNTIME**：protocol buffer 编译器将生成仅依赖于 “lite” 运行时库（libprotobuf-lite 而不是libprotobuf）的类。精简版运行时比整个库小得多（大约小一个数量级），但省略了描述符和反射等特定功能。这对于在移动电话等受限平台上运行的应用程序尤其有用。编译器仍将生成所有方法的快速实现，就像在 SPEED 模式下一样。生成的类将仅实现每种语言的 MessageLite 接口，该接口仅提供完整 Message 接口的方法的子集。</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<pre><code>option optimize_for = CODE_SIZE;

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line">*   `cc_generic_services`，`java_generic_services`，`py_generic_services`（文件选项）：protocol buffer 编译器应根据服务定义判断是否生成 C++，Java 和 Python 抽象服务代码。由于遗留原因，这些默认为 “true”。但是，从版本 2.3.0（2010年1月）开始，RPC 实现最好提供 [代码生成器插件](https://developers.google.com/protocol-buffers/docs/reference/cpp/google.protobuf.compiler.plugin.pb) 生成更具体到每个系统的代码，而不是依赖于 “抽象” 服务。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</code></pre>
<p>// This file relies on plugins to generate service code.<br>option cc_generic_services = false;<br>option java_generic_services = false;<br>option py_generic_services = false;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">*   `cc_enable_arenas`（文件选项）：为 C++ 生成的代码启用 [arena allocation](https://developers.google.com/protocol-buffers/docs/reference/arenas)</span><br><span class="line">*   message\_set\_wire\_format（消息选项）：如果设置为 true，则消息使用不同的二进制格式，旨在与 Google 内部使用的旧格式兼容，即 MessageSet。Google 以外的用户可能永远不需要使用此选项。必须严格按如下方式声明消息：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>message Foo {<br>  option message_set_wire_format = true;<br>  extensions 4 to max;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">*   `packed`（字段选项）：如果在基本数字类型的重复字段上设置为 &#x27;true\`，则一个更紧凑的编码 被使用。使用此选项没有任何缺点。但请注意，在版本 2.3.0 之前，在不期望的情况下接收打包数据的解析器将忽略它。因此，在不破坏兼容性的情况下，无法将现有字段更改为打包格式。在 2.3.0 及更高版本中，此更改是安全的，因为可打包字段的解析器将始终接受这两种格式，但如果你必须使用旧的 protobuf 版本处理旧程序，请务必小心。```</span><br><span class="line">    repeated int32 samples = 4 [packed=true];</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<ul>
<li><code>deprecated</code>（field option）：如果设置为 <code>true</code>，表示该字段已弃用，新代码不应使用该字段。在大多数语言中，这没有实际效果。在 Java 中，这变成了 <code>@Deprecated</code> 注释。将来，其他特定于语言的代码生成器可能会在字段的访问器上生成弃用注释，这将导致在编译尝试使用该字段的代码时发出警告。如果任何人都未使用该字段，并且你希望阻止新用户使用该字段，请考虑使用 <a href="https://developers.google.com/protocol-buffers/docs/proto#reserved">reserved</a> 替换字段声明。```<br>  optional int32 old_field = 6 [deprecated=true];  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line"></span><br><span class="line">### 自定义选项</span><br><span class="line"></span><br><span class="line">Protocol Buffers 甚至允许你定义和使用自己的选项。请注意，这是 **高级功能**，大多数人不需要。由于选项是由 `google/protobuf/descriptor.proto`（如 `FileOptions` 或 `FieldOptions`）中定义的消息定义的，因此定义你自己的选项只需要扩展这些消息。例如：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
import “google/protobuf/descriptor.proto”;</li>
</ul>
<p>extend google.protobuf.MessageOptions {<br>  optional string my_option = 51234;<br>}</p>
<p>message MyMessage {<br>  option (my_option) = “Hello world!”;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">这里我们通过扩展 MessageOptions 定义了一个新的 message 级选项。然后，当我们使用该选项时，必须将选项名称括在括号中以指示它是扩展名。我们现在可以在 C++ 中读取 my\_option 的值，如下所示：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>string value = MyMessage::descriptor()-&gt;options().GetExtension(my_option);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">这里，`MyMessage::descriptor()-&gt;options()` 返回 `MyMessage` 的 `MessageOptions` protocol message。从中读取自定义选项就像阅读任何其他扩展。</span><br><span class="line"></span><br><span class="line">同样，在 Java 中我们会写：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>String value = MyProtoFile.MyMessage.getDescriptor().getOptions().getExtension(MyProtoFile.myOption);</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">在 Python 中它将是：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>value = my_proto_file_pb2.MyMessage.DESCRIPTOR.GetOptions()<br>  .Extensions[my_proto_file_pb2.my_option]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">可以在 Protocol Buffers 语言中为每种结构自定义选项。这是一个使用各种选项的示例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>import “google/protobuf/descriptor.proto”;</p>
<p>extend google.protobuf.FileOptions {<br>  optional string my_file_option = 50000;<br>}<br>extend google.protobuf.MessageOptions {<br>  optional int32 my_message_option = 50001;<br>}<br>extend google.protobuf.FieldOptions {<br>  optional float my_field_option = 50002;<br>}<br>extend google.protobuf.EnumOptions {<br>  optional bool my_enum_option = 50003;<br>}<br>extend google.protobuf.EnumValueOptions {<br>  optional uint32 my_enum_value_option = 50004;<br>}<br>extend google.protobuf.ServiceOptions {<br>  optional MyEnum my_service_option = 50005;<br>}<br>extend google.protobuf.MethodOptions {<br>  optional MyMessage my_method_option = 50006;<br>}</p>
<p>option (my_file_option) = “Hello world!”;</p>
<p>message MyMessage {<br>  option (my_message_option) = 1234;</p>
<p>  optional int32 foo = 1 [(my_field_option) = 4.5];<br>  optional string bar = 2;<br>}</p>
<p>enum MyEnum {<br>  option (my_enum_option) = true;</p>
<p>  FOO = 1 [(my_enum_value_option) = 321];<br>  BAR = 2;<br>}</p>
<p>message RequestType {}<br>message ResponseType {}</p>
<p>service MyService {<br>  option (my_service_option) = FOO;</p>
<p>  rpc MyMethod(RequestType) returns(ResponseType) {<br>    // Note:  my_method_option has type MyMessage.  We can set each field<br>    //   within it using a separate “option” line.<br>    option (my_method_option).foo = 567;<br>    option (my_method_option).bar = “Some string”;<br>  }<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">请注意，如果要在除定义它之外的包中使用自定义选项，则必须在选项名称前加上包名称，就像对类型名称一样。例如：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>// foo.proto<br>import “google/protobuf/descriptor.proto”;<br>package foo;<br>extend google.protobuf.MessageOptions {<br>  optional string my_option = 51234;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">// bar.proto</span><br><span class="line">import &quot;foo.proto&quot;;</span><br><span class="line">package bar;</span><br><span class="line">message MyMessage &#123;</span><br><span class="line">  option (foo.my_option) = &quot;Hello world!&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后一件事：由于自定义选项是扩展名，因此必须为其分配字段编号，就像任何其他字段或扩展名一样。在上面的示例中，我们使用了 50000-99999 范围内的字段编号。此范围保留供个别组织内部使用，因此你可以自由使用此范围内的数字用于内部应用程序。但是，如果你打算在公共应用程序中使用自定义选项，则务必确保你的字段编号是全局唯一的。要获取全球唯一的字段编号，请发送请求以向 <a href="https://github.com/google/protobuf/blob/master/docs/options.md">protobuf全球扩展注册表</a> 添加条目。通常你只需要一个扩展号。你可以通过将多个选项放在子消息中来实现一个扩展号声明多个选项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">message FooOptions &#123;</span><br><span class="line">  optional int32 opt1 = 1;</span><br><span class="line">  optional string opt2 = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extend google.protobuf.FieldOptions &#123;</span><br><span class="line">  optional FooOptions foo_options = 1234;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// usage:</span><br><span class="line">message Bar &#123;</span><br><span class="line">  optional int32 a = 1 [(foo_options).opt1 = 123, (foo_options).opt2 = &quot;baz&quot;];</span><br><span class="line">  // alternative aggregate syntax (uses TextFormat):</span><br><span class="line">  optional int32 b = 2 [(foo_options) = &#123; opt1: 123 opt2: &quot;baz&quot; &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另请注意，每种选项类型（文件级别，消息级别，字段级别等）都有自己的数字空间，例如，你可以使用相同的数字声明 FieldOptions 和 MessageOptions 的扩展名。</p>
<h2 id="生成你的类"><a href="#生成你的类" class="headerlink" title="生成你的类"></a>生成你的类</h2><p>要生成 Java，Python 或 C++代码，你需要使用 <code>.proto</code> 文件中定义的 message 类型，你需要在 <code>.proto</code> 上运行 protocol buffer 编译器 <code>protoc</code>。如果尚未安装编译器，请 <a href="https://developers.google.com/protocol-buffers/docs/downloads.html">下载软件包</a> 并按照 README 文件中的说明进行操作。</p>
<p>Protocol 编译器的调用如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">protoc --proto_path=IMPORT_PATH --cpp_out=DST_DIR --java_out=DST_DIR --python_out=DST_DIR path/to/file.proto</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  IMPORT_PATH 指定在解析导入指令时查找 .proto 文件的目录。如果省略，则使用当前目录。可以通过多次传递 –proto_path 选项来指定多个导入目录；他们将按顺序搜索。-I = IMPORT_PATH 可以用作 –proto_path 的缩写形式。</li>
<li>你可以提供一个或多个输出指令：<ul>
<li>  <code>--cpp_out</code>在 <code>DST_DIR</code> 中生成 C++ 代码。有关详细信息，请参阅 <a href="https://developers.google.com/protocol-buffers/docs/reference/cpp-generated">C++ 生成的代码参考</a> 。</li>
<li>  <code>--java_out</code>在<code>DST_DIR</code>中生成 Java 代码。有关更多信息，请参阅 <a href="https://developers.google.com/protocol-buffers/docs/reference/java-generated">Java 生成的代码参考</a> 。</li>
<li><code>--python_out</code> 在 <code>DST_DIR</code> 中生成 Python 代码。有关更多信息，请参阅 <a href="https://developers.google.com/protocol-buffers/docs/reference/python-generated">Python 生成的代码</a> 。<br>  为了方便起见，如果 DST_DIR 以 .zip 或 .jar 结尾，编译器会将输出写入到具有给定名称的单个 ZIP 格式的存档文件。.jar 输出还将根据 Java JAR 规范的要求提供清单文件。请注意，如果输出存档已存在，则会被覆盖；编译器不够智能，无法将文件添加到现有存档中。</li>
</ul>
</li>
<li>  你必须提供一个或多个 .proto 文件作为输入。可以一次指定多个 .proto 文件。虽然文件是相对于当前目录命名的，但每个文件必须驻留在其中一个 IMPORT_PATH 中，以便编译器可以确定其规范名称。</li>
</ul>
]]></content>
      <categories>
        <category>GRPC</category>
      </categories>
      <tags>
        <tag>proto2</tag>
      </tags>
  </entry>
  <entry>
    <title>DPDK+OVS+QEMU前后端启动vm</title>
    <url>/2023/03/06/DPDK-OVS-QEMU%E5%89%8D%E5%90%8E%E7%AB%AF%E5%90%AF%E5%8A%A8vm/</url>
    <content><![CDATA[<h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><ul>
<li><p>DPDK 22.11.1</p>
</li>
<li><p>A DPDK supported NIC</p>
</li>
</ul>
<p>Only required when physical ports are in use</p>
<span id="more"></span>
<ul>
<li>A suitable kernel</li>
</ul>
<p>On Linux Distros running kernel version &gt;= 3.0, only IOMMU needs to enabled via the grub cmdline, assuming you are using VFIO. For older kernels, ensure the kernel is built with UIO, HUGETLBFS, PROC_PAGE_MONITOR, HPET, HPET_MMAP support. If these are not present, it will be necessary to upgrade your kernel or build a custom kernel with these flags enabled.</p>
<h2 id="dpdk环境设置"><a href="#dpdk环境设置" class="headerlink" title="dpdk环境设置"></a>dpdk环境设置</h2><p>检查VT-d功能是否打开</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/cmdline | grep iommu=pt</span><br><span class="line"><span class="built_in">cat</span> /proc/cmdline | grep intel_iommu=on</span><br></pre></td></tr></table></figure>
<p>如果没有开启，那么需要修改/etc/default/grub中GRUB_CMDLINE_LINUX_DEFAULT，重新创建引导grub</p>
<p>设置大页，加载vfio，绑定物理网卡到vfio</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">huge_set --setup 4g</span><br><span class="line">modprobe vfio-pci</span><br><span class="line">dpdk_bind -b vfio-pci ens33f1</span><br></pre></td></tr></table></figure>
<p>这里的<code>huge_set</code>、<code>dpdk_bind</code>对应dpdk bin中的<code>dpdk-devbind.py</code>、<code>dpdk-hugepages.py</code></p>
<h2 id="ovs启动"><a href="#ovs启动" class="headerlink" title="ovs启动"></a>ovs启动</h2><ul>
<li>创建ovs相关目录</li>
<li>第一次需要创建ovsdb</li>
<li>启动ovsdb-server</li>
<li>检查db.sock是否正常创建</li>
<li>设置other_config为dpdk模式</li>
<li>启动ovs-vswitchd</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /mnt/store/ovs/images/bin</span><br><span class="line"></span><br><span class="line">dpdk_socket_mem=<span class="string">&quot;1024,0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p /var/run/openvswitch</span><br><span class="line"><span class="built_in">mkdir</span> -p /etc/openvswitch</span><br><span class="line"><span class="built_in">mkdir</span> -p /var/log/openvswitch</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ! <span class="built_in">test</span> -f /etc/openvswitch/conf.db; <span class="keyword">then</span></span><br><span class="line">	./ovsdb-tool create /etc/openvswitch/conf.db /mnt/store/ovs/images/db/vswitch.ovsschema</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">./ovsdb-server /etc/openvswitch/conf.db -vconsole:emer -vsyslog:err -vfile:info --remote=punix:/var/run/openvswitch/db.sock --private-key=db:Open_vSwitch,SSL,private_key --certificate=db:Open_vSwitch,SSL,certificate --bootstrap-ca-cert=db:Open_vSwitch,SSL,ca_cert --no-chdir --log-file=/var/log/openvswitch/ovsdb-server.log --pidfile=/var/run/openvswitch/ovsdb-server.pid --detach --monitor</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [ ! -S /var/run/openvswitch/db.sock ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">	<span class="built_in">sleep</span> 1</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">./ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-init=<span class="literal">true</span></span><br><span class="line">./ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-extra=<span class="string">&quot;--iova-mode=pa&quot;</span></span><br><span class="line">./ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-socket-mem=<span class="variable">$dpdk_socket_mem</span></span><br><span class="line"></span><br><span class="line">./ovs-vswitchd unix:/var/run/openvswitch/db.sock -vconsole:emer -vsyslog:err -vfile:info --mlockall --no-chdir --log-file=/var/log/openvswitch/ovs-vswitchd.log --pidfile=/var/run/openvswitch/ovs-vswitchd.pid --detach --monitor</span><br></pre></td></tr></table></figure>

<h2 id="ovs停止运行"><a href="#ovs停止运行" class="headerlink" title="ovs停止运行"></a>ovs停止运行</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ovs-appctl -t ovs-vswitchd <span class="built_in">exit</span></span><br><span class="line">ovs-appctl -t ovsdb-server <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>

<h2 id="ovs创建port"><a href="#ovs创建port" class="headerlink" title="ovs创建port"></a>ovs创建port</h2><ul>
<li>创建网桥</li>
<li>物理端口绑定网桥</li>
<li>前后端通信端口绑定网桥</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">/mnt/store/ovs/images/bin/ovs-vsctl --may-exist add-br br0 -- <span class="built_in">set</span> bridge br0 datapath_type=netdev</span><br><span class="line"></span><br><span class="line"><span class="comment"># dpdk-devargs后面跟的是dpdk绑定网卡的pci bdf号</span></span><br><span class="line">/mnt/store/ovs/images/bin/ovs-vsctl --may-exist add-port br0 phy0 -- <span class="built_in">set</span> Interface phy0 <span class="built_in">type</span>=dpdk options:dpdk-devargs=0000:24:00.1</span><br><span class="line"></span><br><span class="line">/mnt/store/ovs/images/bin/ovs-vsctl --may-exist add-port br0 vhost-user-1 -- <span class="built_in">set</span> Interface vhost-user-1 <span class="built_in">type</span>=dpdkvhostuserclient options:vhost-server-path=<span class="string">&quot;/tmp/sock0&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>ovs-vsctl show查看运行结果</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># /mnt/store/ovs/images/bin/ovs-vsctl show</span></span><br><span class="line">90ce12f9-3e63-4fff-b615-ae7e864858db</span><br><span class="line">    Bridge br0</span><br><span class="line">        datapath_type: netdev</span><br><span class="line">        Port br0</span><br><span class="line">            Interface br0</span><br><span class="line">                <span class="built_in">type</span>: internal</span><br><span class="line">        Port vhost-user-1</span><br><span class="line">            Interface vhost-user-1</span><br><span class="line">                <span class="built_in">type</span>: dpdkvhostuserclient</span><br><span class="line">                options: &#123;vhost-server-path=<span class="string">&quot;/tmp/sock0&quot;</span>&#125;</span><br><span class="line">        Port phy0</span><br><span class="line">            Interface phy0</span><br><span class="line">                <span class="built_in">type</span>: dpdk</span><br><span class="line">                options: &#123;dpdk-devargs=<span class="string">&quot;0000:24:00.1&quot;</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="qemu启动"><a href="#qemu启动" class="headerlink" title="qemu启动"></a>qemu启动</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">ulimit</span> -l unlimited</span><br><span class="line">/root/pc-bios/qemu-system-x86_64  \</span><br><span class="line">	-enable-kvm -m 2048 -cpu host \</span><br><span class="line">	-hda /mnt/store/vm0-centos8.4-8g-ext4-host-dmar.img \</span><br><span class="line">	-object memory-backend-file,<span class="built_in">id</span>=mem,size=2048M,mem-path=/dev/hugepages,share=on \</span><br><span class="line">	-mem-prealloc \</span><br><span class="line">	-numa node,memdev=mem \</span><br><span class="line">	-chardev socket,<span class="built_in">id</span>=char0,path=/tmp/sock0,server=on \</span><br><span class="line">	-netdev <span class="built_in">type</span>=vhost-user,<span class="built_in">id</span>=vdpa,chardev=char0,queues=4 \</span><br><span class="line">	-device virtio-net-pci,mq=on,rx_queue_size=512,tx_queue_size=512,netdev=vdpa,mac=00:aa:bb:cc:<span class="built_in">dd</span>:ee,page-per-vq=on,disable-modern=on,disable-legacy=off \</span><br><span class="line">	-serial telnet:127.1:4321,server,nowait \</span><br><span class="line">	-monitor stdio \</span><br><span class="line">	-D ./qemu-vm0.<span class="built_in">log</span> \</span><br><span class="line">	-vnc :90 -L /root/pc-bios</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="ping包测试"><a href="#ping包测试" class="headerlink" title="ping包测试"></a>ping包测试</h2><p>host上网桥配置ip，端口up</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig br0 192.188.1.3/24 up</span><br></pre></td></tr></table></figure>

<p>geust上net口配置同网段ip，端口up</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig ens3 192.188.1.2/24 up</span><br></pre></td></tr></table></figure>

<p>vm ping host<br><img src="212553173cc3f955da5935e31ed69460df0ad4632296146b4ae845f52fe8edde.png" alt="图 1">  </p>
]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>DPDK</tag>
        <tag>OVS</tag>
        <tag>QEMU</tag>
      </tags>
  </entry>
  <entry>
    <title>Python + Selenium</title>
    <url>/2023/02/16/Python-Selenium/</url>
    <content><![CDATA[<h1 id="Selenium-简介"><a href="#Selenium-简介" class="headerlink" title="Selenium 简介"></a>Selenium 简介</h1><blockquote>
<p>Selenium 是一个用于 Web 应用程序测试的工具。Selenium 测试直接运行在浏览器中，就像真正的用户在操作一样。支持的浏览器包括Mozilla Firefox，Safari，Chrome，Opera，Edge 等</p>
</blockquote>
<span id="more"></span>

<h1 id="Selenium-优势"><a href="#Selenium-优势" class="headerlink" title="Selenium 优势"></a>Selenium 优势</h1><p>1、免费开源</p>
<p>2、小巧，对于不同的语言而言，只是一个包的大小</p>
<p>3、支持多语言，python，java 等</p>
<p>4、支持多平台，多浏览器</p>
<h1 id="Selenium-原理"><a href="#Selenium-原理" class="headerlink" title="Selenium 原理"></a>Selenium 原理</h1><p><img src="https://tech.uupt.com/wp-content/uploads/2022/10/image-1024x551.png"></p>
<p>上图所示Selenium Client Library就是我们平时使用的编码语言，包括 java、python、C#等。可以看到这些语言并没有直接与 Browser Drivers 进行通信，而是通过了 JSON WireProtocol，这就是 webdriver 协议。</p>
<p>简单的说他定义了一套接口规范，以我们最熟悉的点击操作为例，他对应的接口协议是：</p>
<p>POST /session/{session id}/element/{element id}/click</p>
<p>这样以来，无论我们编码使用 python 代码来执行点击操作：</p>
<p>driver.find_element_by_id(“”).click()</p>
<p>还是以 java 代码执行点击操作：</p>
<p>driver.findElement(By.id(“”)).click();</p>
<p>都会通过 selenium 客户端的程序将 click 操作转化成对应的 webdriver 协议。这样对于 Browser Drivers 来说只需要解析具体协议，而无需关注客户端使用的是哪种代码了，这就是 selenium 支持多种语言的原理。</p>
<p>在 Browser Drivers 中可以看到各个浏览器的 driver，这里我们以 chromedriver 为例进行讲解。在代码中直接 new ChromeDriver() 将会启动一个 ChromeDriver 进程，ChromeDriver 是一个独立的服务，它是 google 为网站开发人员提供的自动化测试接口，它是 selenium 和 chrome 浏览器进行通信的桥梁。chromeDriver 解析 webdriver 协议，然后根据解析结果，调用与之对应的 Remote Debugging 协议来操控 chrome 浏览器，它可以和浏览器内核进行交互进而操控浏览器</p>
<h1 id="浏览器驱动"><a href="#浏览器驱动" class="headerlink" title="浏览器驱动"></a>浏览器驱动</h1><p>当 selenium 升级到 3.0 之后，对不同的浏览器驱动进行了规范。如果想使用 selenium 驱动不同的浏览器，必须单独下载并设置不同的浏览器驱动。</p>
<p>各浏览器驱动下载地址：</p>
<p>Firefox 浏览器驱动：<a href="https://github.com/mozilla/geckodriver/releases">geckodriver</a></p>
<p>Chrome 浏览器驱动：<a href="https://sites.google.com/a/chromium.org/chromedriver/home">chromedriver</a> , <a href="https://npm.taobao.org/mirrors/chromedriver">taobao</a>镜像</p>
<p>Edge 浏览器驱动：<a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver">MicrosoftWebDriver</a></p>
<p>Opera 浏览器驱动：<a href="https://github.com/operasoftware/operachromiumdriver/releases">operadriver</a></p>
<h1 id="python-安装Selenium"><a href="#python-安装Selenium" class="headerlink" title="python 安装Selenium"></a>python 安装Selenium</h1><p>通过命令安装：pip install selenium</p>
<p>注：如果电脑上既有 python2，又有 python3，在执行 pip 命令安装时，要注意区分</p>
<h1 id="设置浏览器驱动"><a href="#设置浏览器驱动" class="headerlink" title="设置浏览器驱动"></a>设置浏览器驱动</h1><p>1、设置浏览器的地址非常简单。 我们可以手动创建一个存放浏览器驱动的目录，如： C:\driver ,将下载的浏览器驱动文件放到该目录下，然后将此目录路径放在环境变量 Path 下</p>
<p>2、python 验证不同的浏览器驱动是否正常使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line"> </span><br><span class="line">driver = webdriver.Firefox()   # Firefox浏览器</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()    # Chrome浏览器</span><br><span class="line"> </span><br><span class="line">driver = webdriver.Edge()      # Edge浏览器</span><br><span class="line"> </span><br><span class="line">driver = webdriver.Opera()     # Opera浏览器</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3、测试是否正常打开浏览器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line"> </span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(&#x27;https://www.baidu.com&#x27;) # 打开百度</span><br><span class="line"> </span><br><span class="line">print(driver.title) # 获取网页title</span><br><span class="line"> </span><br><span class="line">driver.quit() # 关闭浏览器</span><br></pre></td></tr></table></figure>

<h1 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h1><h2 id="元素定位"><a href="#元素定位" class="headerlink" title="元素定位"></a>元素定位</h2><p>常用元素定位为 8 种，分别为：</p>
<p>通过 id 定位：find_element_by_id()</p>
<p>通过 id 定位一组元素：find_elements_by_id()</p>
<p>通过 name 定位：find_element_by_name()</p>
<p>通过 name 定位一组元素：find_elements_by_name()</p>
<p>通过 class name 定位：find_element_by_class_name()</p>
<p>通过 class name 定位一组元素：find_elements_by_class_name()</p>
<p>通过 tag name 定位：find_element_by_tag_name()</p>
<p>通过 tag name 定位一组元素：find_elements_by_tag_name()</p>
<p>通过 link text 定位：find_element_by_link_text()</p>
<p>通过 link text 定位一组元素：find_elements_by_link_text()</p>
<p>通过部分 link text 定位：find_element_by_partial_link_text()</p>
<p>通过部分 link text 定位一组元素：find_elements_by_partial_link_text()</p>
<p>通过 xpath 定位：find_element_by_xpath()</p>
<p>通过 xpath 定位一组元素：find_elements_by_xpath()</p>
<p>通过 css 定位：find_element_by_css_selector()</p>
<p>通过 css 定位一组元素：find_elements_by_css_selector()</p>
<p>注意：如果定位一组元素，则在 element 后面加一个 s</p>
<h2 id="控制浏览器"><a href="#控制浏览器" class="headerlink" title="控制浏览器"></a>控制浏览器</h2><ul>
<li>  控制浏览器大小</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line"></span><br><span class="line">driver = webdriver.Firefox()</span><br><span class="line">driver.get(&quot;http://www.baidu.com&quot;)</span><br><span class="line"> </span><br><span class="line"># 参数数字为像素点_</span><br><span class="line">print(&quot;设置浏览器宽500、高500显示&quot;)</span><br><span class="line">driver.set_window_size(500, 500)</span><br><span class="line">driver.quit()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  控制浏览器前进后退</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line"> </span><br><span class="line">driver = webdriver.Firefox()</span><br><span class="line"> </span><br><span class="line">#访问百度首页</span><br><span class="line">first_url= &#x27;http://www.baidu.com&#x27;</span><br><span class="line">print(&quot;access %s&quot; %(first_url))</span><br><span class="line">driver.get(first_url)</span><br><span class="line"> </span><br><span class="line">#访问新闻页面</span><br><span class="line">second_url=&#x27;http://news.baidu.com&#x27;</span><br><span class="line">print(&quot;access %s&quot; %(second_url))</span><br><span class="line">driver.get(second_url)</span><br><span class="line"> </span><br><span class="line">#返回（后退）到百度首页</span><br><span class="line">print(&quot;back to  %s &quot;%(first_url))</span><br><span class="line">driver.back()</span><br><span class="line"> </span><br><span class="line">#前进到新闻页</span><br><span class="line">print(&quot;forward to  %s&quot;%(second_url))</span><br><span class="line">driver.forward()</span><br><span class="line"> </span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<h2 id="WebDriver-常用方法"><a href="#WebDriver-常用方法" class="headerlink" title="WebDriver 常用方法"></a>WebDriver 常用方法</h2><ul>
<li>  clear()： 清除文本</li>
<li>  send_keys (value)： 模拟按键输入</li>
<li>  click()： 单击元素</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line"> </span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(&quot;https://www.baidu.com&quot;)</span><br><span class="line">driver.find_element_by_id(&quot;kw&quot;).clear()</span><br><span class="line">driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;selenium&quot;)</span><br><span class="line">driver.find_element_by_id(&quot;su&quot;).click()</span><br><span class="line">driver.quit()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  submit()：用于提交表单</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line"> </span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(&quot;https://www.baidu.com&quot;)</span><br><span class="line"> </span><br><span class="line">search_text = driver.find_element_by_id(&#x27;kw&#x27;)</span><br><span class="line">search_text.send_keys(&#x27;selenium&#x27;)</span><br><span class="line">search_text.submit()</span><br><span class="line"> </span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>

<h2 id="设置元素等待"><a href="#设置元素等待" class="headerlink" title="设置元素等待"></a>设置元素等待</h2><p>WebDriver 提供了两种类型的等待：显式等待和隐式等待</p>
<p>显式等待使 WebdDriver 等待某个条件成立时继续执行，否则在达到最大时长时抛出超时异常（TimeoutException）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">from selenium.webdriver.common.by import By</span><br><span class="line">from selenium.webdriver.support.ui import WebDriverWait</span><br><span class="line">from selenium.webdriver.support import expected_conditions as EC</span><br><span class="line"> </span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(&quot;http://www.baidu.com&quot;)</span><br><span class="line"> </span><br><span class="line">element = WebDriverWait(driver, 5, 0.5).until(EC.presence_of_element_located((By.ID, &quot;kw&quot;)))</span><br><span class="line">element.send_keys(&#x27;selenium&#x27;)</span><br><span class="line">driver.quit()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>隐式等待并不影响脚本的执行速度。其次，它并不针对页面上的某一元素进行等待。当脚本执行到某个元素定位时，如果元素可以定位，则继续执行；如果元素定位不到，则它将以轮询的方式不断地判断元素是否被定位到。假设在第 5 秒定位到了元素则继续执行，若直到超出设置时长（10 秒）还没有定位到元素，则抛出异常。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">from selenium.common.exceptions import NoSuchElementException</span><br><span class="line">from time import ctime</span><br><span class="line"> </span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line"> </span><br><span class="line"># 设置隐式等待为10秒</span><br><span class="line">driver.implicitly_wait(10)</span><br><span class="line">driver.get(&quot;http://www.baidu.com&quot;)</span><br><span class="line"> </span><br><span class="line">try:</span><br><span class="line">    print(ctime())</span><br><span class="line">    driver.find_element_by_id(&quot;kww&quot;).send_keys(&#x27;selenium&#x27;)</span><br><span class="line">except NoSuchElementException as e:</span><br><span class="line">    print(e)</span><br><span class="line">finally:</span><br><span class="line">    print(ctime())</span><br><span class="line">    driver.quit()</span><br></pre></td></tr></table></figure>

<h1 id="Python-Selenium-实现识别图片验证码登录"><a href="#Python-Selenium-实现识别图片验证码登录" class="headerlink" title="Python+Selenium 实现识别图片验证码登录"></a>Python+Selenium 实现识别图片验证码登录</h1><p>1、打开网站设置要访问的网站地址，并把窗口最大化，这是能保证在电脑上每次截取的图片都是相同的大小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">url = &quot;https://www.xxxxx.com&quot;</span><br><span class="line"># 1、打开浏览器，最大化浏览器</span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(url)</span><br><span class="line">#driver.implicitly_wait(10)#隐式等待10s</span><br><span class="line">driver.maximize_window()  #最大化窗口</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、截取带图片验证码的网站内容，并保存在本地</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">driver.save_screenshot(&quot;H://test/01.png&quot;)#截取屏幕内容，保存到本地</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>也可以通过 id 或者 Xpath 的方式定位到图片验证码的方式直接获取图片验证码，保存在本地</p>
<p><img src="https://tech.uupt.com/wp-content/uploads/2022/10/image-1-1024x456.png"></p>
<p>3、使用第三方库对图片进行识别（pytesseract 和ddddocr 都可以识别图片验证码）</p>
<p>a、使用pytesseract 识别图片验证码</p>
<p>定位在图片中验证码所在的位置，四个参数分别代表图片验证码的左，上，右，下坐标，可以通过 windows 自带的画图工具获取</p>
<p>当使用通过定位获取到验证码的方式时，可以跳过手动获取图片验证码的流程，直接跳转到图像处理步骤</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ran = Image.open(&quot;H://test/01.png&quot;)   #打开截图，获取验证码位置，截取保存验证码</span><br><span class="line">box = (564, 395, 643, 423)  # 获取验证码位置,代表（左，上，右，下）</span><br><span class="line">ran.crop(box).save(&quot;H://test/02.png&quot;)   #把获取的验证码保存</span><br><span class="line">#获取验证码图片，读取验证码</span><br><span class="line">imageCode = Image.open(&quot;H://test/02.png&quot;)  #打开保存的验证码图片</span><br><span class="line">#imageCode.load()</span><br><span class="line"># 图像增强，二值化</span><br><span class="line">sharp_img = ImageEnhance.Contrast(imageCode).enhance(2.0)</span><br><span class="line">sharp_img.save(&quot;H://test/03.png&quot;) #保存图像增强，二值化之后的验证码图片</span><br><span class="line">sharp_img.load()  # 对比度增强</span><br><span class="line">time.sleep(2)</span><br><span class="line">print(sharp_img) #打印图片的信息</span><br><span class="line">code = pytesseract.image_to_string(sharp_img).strip() #读取验证码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>b、使用 ddddocr 识别图片验证码</p>
<p>先将图片保存在本地，然后可以直接通过二进制读取图片，进行识别</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建对象</span><br><span class="line">ocr = ddddocr.DdddOcr() </span><br><span class="line"># 使用二进制的方式读取图片</span><br><span class="line">with open(&#x27;./images/code1.png&#x27;, &#x27;rb&#x27;) as f:</span><br><span class="line">    img_tytes = f.read()</span><br><span class="line">    # 调用识别方法_</span><br><span class="line">    res = ocr.classification(img_tytes)</span><br><span class="line">    print(f&#x27;验证码为：&#123;res&#125;&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4、定位账号密码等输入框，并输入相关内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name=driver.find_element_by_id(&quot;username&quot;)  #定位账号输入框</span><br><span class="line">password=driver.find_element_by_id(&quot;password_1&quot;)  #定位密码输入框</span><br><span class="line">code1=driver.find_element_by_id(&quot;user_ck&quot;)  #定位验证码输入框</span><br><span class="line">name.send_keys(&#x27;username&#x27;)   #给定位账号的输入框中输入值</span><br><span class="line">password.send_keys(&#x27;password&#x27;)   #给定位密码的输入框中输入值</span><br><span class="line">code1.send_keys(code)   #给定位验证码的输入框中输入读取到的验证码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>5、定位并点击按钮</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">driver.find_element_by_name(&quot;yt0&quot;).click() #点击登录</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>6、最后关闭页面</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#关闭浏览器</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Selenium</tag>
      </tags>
  </entry>
  <entry>
    <title>ChromeDriver安装</title>
    <url>/2023/02/15/ChromeDriver%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="官网下载"><a href="#官网下载" class="headerlink" title="官网下载"></a>官网下载</h1><ul>
<li>  官方网站：<a href="https://sites.google.com/a/chromium.org/chromedriver">https://sites.google.com/a/chromium.org/chromedriver</a></li>
<li>  下载地址：<a href="https://chromedriver.storage.googleapis.com/index.html">https://chromedriver.storage.googleapis.com/index.html</a><span id="more"></span></li>
</ul>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在这之前请确保已经正确安装好了 Chrome 浏览器并可以正常运行，安装过程不再赘述。</p>
<h2 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h2><p>点击 Chrome 的菜单，帮助-&gt;关于 Chrome，即可查看 Chrome 的版本号，在这里我的版本是 114.0.5735.199，如图所示：</p>
<p><img src="4b19c10a0918a34aa2d1b682b01a86d939da61ec9233b23501343177662c0186.png" alt="picture 0">  </p>
<p>请记住 Chrome 版本号，在后面选择 ChromeDriver 版本时需要用到。</p>
<h2 id="禁用Chrome升级"><a href="#禁用Chrome升级" class="headerlink" title="禁用Chrome升级"></a>禁用Chrome升级</h2><p>由于ChromeDriver需要与Chrome 版本号一致，默认情况下Chrome会自动升级，这里需要禁用Chrome升级<br>第一步：禁用任务计划<br>首先是【右键计算机-&gt;管理】，在【计算机管理(本地)-&gt;系统工具-&gt;任务计划程序-&gt;任务计划程序库】中找到两个和Google自动更新相关的任务计划【GoogleUpdateTaskMachineCore】与【GoogleUpdateTaskMachineUA】，并把它俩禁用掉。<br><img src="709f9d6336c4807addf4a9fafe7563c9ed48b1e072e41ec5fa7862d4afeaa98b.png" alt="picture 1">  </p>
<p>第二步：禁用更新服务<br>然后在下方的【服务和应用程序-&gt;服务】中，找到两个和Google更新相关的服务【Google更新服务(gupdate)】、【Google更新服务(gupdatem)】，并右键，选择属性，把启动类型改为禁用。<br><img src="0950e09f69d4062b142820c0df774849c93d9d1d2d0de6d6334d6363bd03dea5.png" alt="picture 2">  </p>
<h2 id="下载-ChromeDriver"><a href="#下载-ChromeDriver" class="headerlink" title="下载 ChromeDriver"></a>下载 ChromeDriver</h2><p>打开 ChromeDriver 的官方网站，链接为：<a href="https://sites.google.com/chromium.org/driver/downloads">https://sites.google.com/chromium.org/driver/downloads</a><br>可以看到到目前为止最新支持的 Chrome 浏览器版本为 114，最新版本以官网为准，如图所示：</p>
<p><img src="6aa27b8893391cda5354530d6ad9eb976207c3fe832d832292c90ed2f360fc6f.png" alt="picture 3">  </p>
<p>每个版本都有相应的支持 Chrome 版本介绍，请找好自己的 Chrome 浏览器版本对应的 ChromeDriver 版本再下载，否则可能导致无法正常工作。</p>
<p>由于我这边的 ChromeDriver 版本是 114.*，找到对应的下载列表，如图所示：</p>
<p><img src="92bfce436feb13eb2aa165fb7e4d116e3a16bae282c84cb54bff8513d47edf1a.png" alt="picture 4">  </p>
<p>Windows 系统就下载 win32.zip，Mac 系统 Intel 芯片下载 mac64.zip，Linux 系统下载 linux64.zip，下载解压之后会得到一个 ChromeDriver 的可执行文件。</p>
<p>另外如果上面的链接打不开的话，也可以从对应的 ChromeDriver 镜像网站下载：<a href="https://chromedriver.storage.googleapis.com/index.html">https://chromedriver.storage.googleapis.com/index.html</a></p>
<h2 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h2><p>下载完成后将 ChromeDriver 的可执行文件配置到环境变量下。</p>
<p>在 Windows 下，建议直接将 chromedriver.exe 文件拖到 Python 的 Scripts 目录下，如图所示：</p>
<p><img src="f3b902f7fe49df4551c4b21747d5a360834e4f3f9d04a7e320c1136740233772.png" alt="picture 5">  </p>
<h2 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h2><p>配置完成之后，就可以在命令行下直接执行 chromedriver 命令了。</p>
<p>命令行下输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chromedriver</span><br></pre></td></tr></table></figure>

<p>输入控制台有类似输出，如图所示：</p>
<p><img src="7c8145799a2f568e5ac7923637ad8d94b5d19e5eca242fe1842e8fb1771417a4.png" alt="picture 6">  </p>
<p>如果有类似输出则证明 ChromeDriver 的环境变量配置好了。</p>
<p>另外如果要配合代码进行测试的话，可以安装 Selenium,<br>安装好了之后，随后再在程序中测试，执行如下 Python 代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">browser = webdriver.Chrome()</span><br></pre></td></tr></table></figure>

<p>运行之后会弹出一个空白的 Chrome 浏览器，证明所有的配置都没有问题，如果没有弹出，请检查之前的每一步的配置。</p>
<p>如果弹出之后闪退，则可能是 ChromeDriver 版本和 Chrome 版本不简容，请更换 ChromeDriver 版本。</p>
<p>如果没有问题，接下来我们就可以利用 Chrome 来做网页抓取了。</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>ChromeDriver</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode使用CodeGPT</title>
    <url>/2023/02/10/VSCode%E4%BD%BF%E7%94%A8CodeGPT/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>CodeGPT</code>允许我们通过官方<code>OpenAI API</code>在<code>VSCode</code>中使用<code>GPT-3</code>，使得我们可以在代码编辑器拥有了<code>ChatGPT</code>。<br>借助 <code>CodeGPT</code>，我们可以生成代码、解释代码、重构代码等等。</p>
<span id="more"></span>


<h2 id="安装和设置"><a href="#安装和设置" class="headerlink" title="安装和设置"></a>安装和设置</h2><p>打开VSCode编辑器，点击扩展，然后在搜索框中输入“Code GPT”，然后点击“安装”。<br><img src="11a74d39367434d81ee6d91b62f82591270e1597d59b0237479cd9ed18ad5c4f.png" alt="图 5">  </p>
<p>Code GPT安装完，进到“Settings”界面，然后找到扩展下的“Code GPT”<br>CodeGPT的设置界面如下：<br><img src="79e7618f461b768065b9fea7f62b8f19727bc3c644aa6a05a332f304007086c6.png" alt="图 4">  </p>
<p><img src="a551258121c4603e9a22a950ebcac95490ec3ed3132b6b65998478d96b0069e0.png" alt="图 6">  </p>
<p>想要让CodeGPT运行起来，需要在上图的输入框处输入<a href="https://platform.openai.com/account/api-keys">OpenAI API key</a>，API key需要到OpenAI的官网生成。<br><img src="1ec8c9b392d9b9c48adef2505b45788e26fae2b55c8e30fbd6db20885f54e342.png" alt="图 7">  </p>
<p><strong>使用注意</strong><br>在WSL中无法使用CodeGPT，需要在Windows端使用</p>
<h2 id="解释代码"><a href="#解释代码" class="headerlink" title="解释代码"></a>解释代码</h2><p>选中代码，右键点击<code>Explain CodeGPT</code><br><img src="a1f348872a247c684d3eb2ee93a9801cc1a7e5094b5b4696a572c5759883d1f5.png" alt="图 1">  </p>
<h2 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h2><p>在对应后缀的代码文件中描述注释，并将光标点击到文末，快捷键ctrl+shift+i<br><img src="7fef95c4a63f509a4d1ce45159b1e1a344f6ce8c991344b63d674e52fd9c108f.png" alt="图 3">  </p>
<h2 id="重构代码"><a href="#重构代码" class="headerlink" title="重构代码"></a>重构代码</h2><p>选中代码，右键点击<code>Refactor CodeGPT</code><br><img src="95d51eff9bcb3c7c2c3d03bc3b67ba6cb3e8f1da454757e2d083fae5c0f4c7b2.png" alt="图 2">  </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重构后的代码</span></span><br><span class="line">wait_for_process() &#123;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">参数说明</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="variable">$1</span>: 进程名</span></span><br><span class="line">  </span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">输入验证</span></span><br><span class="line">  if [ $# -ne 1 ]; then</span><br><span class="line">    echo &quot;Parameters incorrect&quot;</span><br><span class="line">    exit 1</span><br><span class="line">  fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">设置超时时间</span></span><br><span class="line">  WAIT_TIMEOUT=10</span><br><span class="line"></span><br><span class="line">  for i in $(seq 1 $WAIT_TIMEOUT); do</span><br><span class="line">    # 检索进程ID</span><br><span class="line">    proc_pid=$(pidof $1)</span><br><span class="line"></span><br><span class="line">    if [ &quot;$proc_pid&quot; != &quot;&quot; ]</span><br><span class="line">    then</span><br><span class="line">      # 进程已启动，返回</span><br><span class="line">      echo &quot;$1 started&quot;</span><br><span class="line">      return</span><br><span class="line">    fi</span><br><span class="line">    </span><br><span class="line">    echo &quot;Waiting for $1 to start&quot;</span><br><span class="line">    sleep 1</span><br><span class="line">  done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">超时</span></span><br><span class="line">  echo &quot;Timeout waiting for $1 to start&quot;</span><br><span class="line">  exit 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>VSCODE</category>
      </categories>
      <tags>
        <tag>CodeGPT</tag>
      </tags>
  </entry>
  <entry>
    <title>Dockerfile使用介绍</title>
    <url>/2022/12/11/Dockerfile%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="Dockerfile-概念"><a href="#Dockerfile-概念" class="headerlink" title="Dockerfile 概念"></a>Dockerfile 概念</h2><p>Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>
<span id="more"></span>
<p>镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。</p>
<p>Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。有了 Dockerfile，当我们需要定制自己额外的需求时，只需在 Dockerfile 上添加或者修改指令，重新生成 image 即可，省去了敲命令的麻烦。</p>
<h2 id="Dockerfile-文件格式"><a href="#Dockerfile-文件格式" class="headerlink" title="Dockerfile 文件格式"></a>Dockerfile 文件格式</h2><p>Dockerfile文件格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">##  Dockerfile文件格式</span><br><span class="line"></span><br><span class="line"># This dockerfile uses the ubuntu image</span><br><span class="line"># VERSION 2 - EDITION 1</span><br><span class="line"># Author: docker_user</span><br><span class="line"># Command format: Instruction [arguments / command] ..</span><br><span class="line"> </span><br><span class="line"># 1、第一行必须指定 基础镜像信息</span><br><span class="line">FROM ubuntu</span><br><span class="line"> </span><br><span class="line"># 2、维护者信息</span><br><span class="line">MAINTAINER docker_user docker_user@email.com</span><br><span class="line"> </span><br><span class="line"># 3、镜像操作指令</span><br><span class="line">RUN echo &quot;deb http://archive.ubuntu.com/ubuntu/ raring main universe&quot; &gt;&gt; /etc/apt/sources.list</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y nginx</span><br><span class="line">RUN echo &quot;\ndaemon off;&quot; &gt;&gt; /etc/nginx/nginx.conf</span><br><span class="line"> </span><br><span class="line"># 4、容器启动执行指令</span><br><span class="line">CMD /usr/sbin/nginx</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Dockerfile 分为四部分：<strong>基础镜像信息、维护者信息、镜像操作指令、容器启动执行指令</strong>。一开始必须要指明所基于的镜像名称，接下来一般会说明维护者信息；后面则是镜像操作指令，例如 RUN 指令。每执行一条RUN 指令，镜像添加新的一层，并提交；最后是 CMD 指令，来指明运行容器时的操作命令。</p>
<h2 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h2><p>docker build 命令会根据 Dockerfile 文件及上下文构建新 Docker 镜像。构建上下文是指 Dockerfile 所在的本地路径或一个URL（Git仓库地址）。构建上下文环境会被递归处理，所以构建所指定的路径还包括了子目录，而URL还包括了其中指定的子模块。</p>
<p>将当前目录做为构建上下文时，可以像下面这样使用docker build命令构建镜像：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build .</span><br><span class="line">Sending build context to Docker daemon  6.51 MB</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>说明：构建会在 Docker 后台守护进程（daemon）中执行，而不是<code>CLI</code>中。构建前，构建进程会将全部内容（递归）发送到守护进程。大多情况下，应该将一个空目录作为构建上下文环境，并将 Dockerfile 文件放在该目录下。</p>
<p>在构建上下文中使用的 Dockerfile 文件，是一个构建指令文件。为了提高构建性能，可以通过<code>.dockerignore</code>文件排除上下文目录下不需要的文件和目录。</p>
<p>在 Docker 构建镜像的第一步，docker CLI 会先在上下文目录中寻找<code>.dockerignore</code>文件，根据<code>.dockerignore</code> 文件排除上下文目录中的部分文件和目录，然后把剩下的文件和目录传递给 Docker 服务。</p>
<p>Dockerfile 一般位于构建上下文的根目录下，也可以通过<code>-f</code>指定该文件的位置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -f /path/to/a/Dockerfile .</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>构建时，还可以通过<code>-t</code>参数指定构建成镜像的仓库、标签。</p>
<h2 id="镜像标签"><a href="#镜像标签" class="headerlink" title="镜像标签"></a>镜像标签</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t nginx/v3 .</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果存在多个仓库下，或使用多个镜像标签，就可以使用多个<code>-t</code>参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t nginx/v3:1.0.2 -t nginx/v3:latest .</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 Docker 守护进程执行 Dockerfile 中的指令前，首先会对 Dockerfile 进行语法检查，有语法错误时会返回：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t nginx/v3 .</span><br><span class="line">Sending build context to Docker daemon 2.048 kB</span><br><span class="line">Error response from daemon: Unknown instruction: RUNCMD</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>Docker 守护进程会一条一条的执行 Dockerfile 中的指令，而且会在每一步提交并生成一个新镜像，最后会输出最终镜像的ID。生成完成后，Docker 守护进程会自动清理你发送的上下文。 Dockerfile文件中的每条指令会被独立执行，并会创建一个新镜像，RUN cd /tmp等命令不会对下条指令产生影响。 Docker 会重用已生成的中间镜像，以加速docker build的构建速度。以下是一个使用了缓存镜像的执行过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker build -t svendowideit/ambassador .</span><br><span class="line">Sending build context to Docker daemon 15.36 kB</span><br><span class="line">Step 1/4 : FROM alpine:3.2</span><br><span class="line"> ---&gt; 31f630c65071</span><br><span class="line">Step 2/4 : MAINTAINER SvenDowideit@home.org.au</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 2a1c91448f5f</span><br><span class="line">Step 3/4 : RUN apk update &amp;&amp;      apk add socat &amp;&amp;        rm -r /var/cache/</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 21ed6e7fbb73</span><br><span class="line">Step 4/4 : CMD env | grep _TCP= | (sed &#x27;s/.*_PORT_\([0-9]*\)_TCP=tcp:\/\/\(.*\):\(.*\)/socat -t 100000000 TCP4-LISTEN:\1,fork,reuseaddr TCP4:\2:\3 \&amp;/&#x27; &amp;&amp; echo wait) | sh</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 7ea8aef582cc</span><br><span class="line">Successfully built 7ea8aef582cc</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>构建缓存仅会使用本地父生成链上的镜像，如果不想使用本地缓存的镜像，也可以通过<code>--cache-from</code>指定缓存。指定后将不再使用本地生成的镜像链，而是从镜像仓库中下载。</p>
<h2 id="寻找缓存的逻辑"><a href="#寻找缓存的逻辑" class="headerlink" title="寻找缓存的逻辑"></a>寻找缓存的逻辑</h2><p>Docker 寻找缓存的逻辑其实就是树型结构根据 Dockerfile 指令遍历子节点的过程。下图可以说明这个逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     FROM base_image:version           Dockerfile:</span><br><span class="line">           +----------+                FROM base_image:version</span><br><span class="line">           |base image|                RUN cmd1  --&gt; use cache because we found base image</span><br><span class="line">           +-----X----+                RUN cmd11 --&gt; use cache because we found cmd1</span><br><span class="line">                / \</span><br><span class="line">               /   \</span><br><span class="line">       RUN cmd1     RUN cmd2           Dockerfile:</span><br><span class="line">       +------+     +------+           FROM base_image:version</span><br><span class="line">       |image1|     |image2|           RUN cmd2  --&gt; use cache because we found base image</span><br><span class="line">       +---X--+     +------+           RUN cmd21 --&gt; not use cache because there&#x27;s no child node</span><br><span class="line">          / \                                        running cmd21, so we build a new image here</span><br><span class="line">         /   \</span><br><span class="line">RUN cmd11     RUN cmd12</span><br><span class="line">+-------+     +-------+</span><br><span class="line">|image11|     |image12|</span><br><span class="line">+-------+     +-------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>大部分指令可以根据上述逻辑去寻找缓存，除了 ADD 和 COPY 。这两个指令会复制文件内容到镜像内，除了指令相同以外，Docker 还会检查每个文件内容校验(不包括最后修改时间和最后访问时间)，如果校验不一致，则不会使用缓存。</p>
<p>除了这两个命令，Docker 并不会去检查容器内的文件内容，比如 <code>RUN apt-get -y update</code>，每次执行时文件可能都不一样，但是 Docker 认为命令一致，会继续使用缓存。这样一来，以后构建时都不会再重新运行<code>apt-get -y update</code>。</p>
<p>如果 Docker 没有找到当前指令的缓存，则会构建一个新的镜像，并且之后的所有指令都不会再去寻找缓存。</p>
<h2 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h2><p>接下来用一个简单的示例来感受一下 Dockerfile 是如何用来构建镜像启动容器。我们以定制 nginx 镜像为例，在一个空白目录中，建立一个文本文件，并命名为 Dockerfile：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir mynginx</span><br><span class="line">cd mynginx</span><br><span class="line">vi Dockerfile</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>构建一个 Dockerfile 文件内容为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM nginx</span><br><span class="line">RUN echo &#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27; &gt; /usr/share/nginx/html/index.html</span><br></pre></td></tr></table></figure>

<p>这个 Dockerfile 很简单，一共就两行涉及到了两条指令：FROM 和 RUN，FROM 表示获取指定基础镜像，RUN 执行命令，在执行的过程中重写了 nginx 的默认页面信息，将信息替换为：Hello, Docker!。</p>
<p>在 Dockerfile 文件所在目录执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build -t nginx:v1 .</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>命令最后有一个. 表示当前目录</p>
<p>构建完成之后，使用 <code>docker images</code> 命令查看所有镜像，如果存在 REPOSITORY 为 nginx 和 TAG 是 v1 的信息，就表示构建成功。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker images</span><br><span class="line">REPOSITORY                      TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">nginx                           v1                  8c92471de2cc        6 minutes ago       108.6 MB</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接下来使用 docker run 命令来启动容器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run  --name docker_nginx_v1   -d -p 80:80 nginx:v1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这条命令会用 nginx 镜像启动一个容器，命名为<code>docker_nginx_v1</code>，并且映射了 80 端口，这样我们可以用浏览器去访问这个 nginx 服务器：<code>http://192.168.0.54/</code>，页面返回信息：</p>
<p><img src="http://favorites.ren/assets/images/2018/docker/1.png"></p>
<p>这样一个简单使用 Dockerfile 构建镜像，运行容器的示例就完成了！</p>
<h2 id="修改容器内容"><a href="#修改容器内容" class="headerlink" title="修改容器内容"></a>修改容器内容</h2><p>容器启动后，需要对容器内的文件进行进一步的完善，可以使用<code>docker exec -it xx bash</code>命令再次进行修改，以上面的示例为基础，修改 nginx 启动页面内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it docker_nginx_v1   bash</span><br><span class="line">root@3729b97e8226:/# echo &#x27;&lt;h1&gt;Hello, Docker neo!&lt;/h1&gt;&#x27; &gt; /usr/share/nginx/html/index.html</span><br><span class="line">root@3729b97e8226:/# exit</span><br><span class="line">exit</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以交互式终端方式进入 docker_nginx_v1 容器，并执行了 bash 命令，也就是获得一个可操作的 Shell。然后，我们用<code>&lt;h1&gt;Hello, Docker neo!&lt;/h1&gt;</code>覆盖了 <code>/usr/share/nginx/html/index.html</code> 的内容。</p>
<p>再次刷新浏览器，会发现内容被改变。</p>
<p><img src="http://favorites.ren/assets/images/2018/docker/2.png"></p>
<p>修改了容器的文件，也就是改动了容器的存储层，可以通过 docker diff 命令看到具体的改动。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker diff docker_nginx_v1 </span><br><span class="line">... </span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DOCKER</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>基于当前系统制作docker镜像</title>
    <url>/2022/12/10/%E5%9F%BA%E4%BA%8E%E5%BD%93%E5%89%8D%E7%B3%BB%E7%BB%9F%E5%88%B6%E4%BD%9Cdocker%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h3 id="打包centos7系统"><a href="#打包centos7系统" class="headerlink" title="打包centos7系统"></a>打包centos7系统</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># tar --numeric-owner --exclude=/proc --exclude=/sys --exclude=dev  --exclude=boot -cvf /home/centos7.tar /</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="安装docker服务"><a href="#安装docker服务" class="headerlink" title="安装docker服务"></a>安装docker服务</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># yum -y install yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"># yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"># yum makecache fast</span><br><span class="line"># yum -y install docker-ce</span><br><span class="line"># systemctl start docker</span><br></pre></td></tr></table></figure>

<h3 id="导入镜像"><a href="#导入镜像" class="headerlink" title="导入镜像"></a>导入镜像</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># docker import centos7.tar cetos7-ls</span><br></pre></td></tr></table></figure>

<h3 id="确认是否导入成功"><a href="#确认是否导入成功" class="headerlink" title="确认是否导入成功"></a>确认是否导入成功</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">cetos7-ls           latest              0fade5fd53f6        17 minutes ago      1.35GB</span><br></pre></td></tr></table></figure>

<h3 id="运行docker容器"><a href="#运行docker容器" class="headerlink" title="运行docker容器"></a>运行docker容器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># docker run -itd -p 80:80 --restart=always --name Centos7 cetos7-ls bin/bash</span><br></pre></td></tr></table></figure>

<h3 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                NAMES</span><br><span class="line">fe1ec605fb7f        cetos7-ls           &quot;bin/bash&quot;          14 minutes ago      Up 14 minutes       0.0.0.0:80-&gt;80/tcp   Centos7</span><br></pre></td></tr></table></figure>

<h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># docker exec -it fe bash</span><br><span class="line"># ls</span><br><span class="line">bin  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">#打包镜像之前已经安装过nginx服务，现在在容器内启动一下</span><br><span class="line">#容器内的操作系统和本地的操作系统是分离的</span><br><span class="line"># /usr/sbin/nginx </span><br><span class="line"># netstat -lntp</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name    </span><br><span class="line">tcp        0      0 0.0.0.0:80              0.0.0.0:\*               LISTEN      210/nginx: master p </span><br><span class="line">tcp6       0      0 :::80                   :::\*                    LISTEN      210/nginx: master p </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DOCKER</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Python命令行模块Click</title>
    <url>/2022/12/10/Python%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%A8%A1%E5%9D%97Click/</url>
    <content><![CDATA[<blockquote>
<p>click通过click.command()装饰函数，使之成为命令行接口；通过click.option()装饰函数，为其约束并添加命令行选项和参数。简化了传统加参的方式，减少了开发者编写的代码量，使命令行工具编写起来快速而有趣。</p>
</blockquote>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import click</span><br><span class="line"></span><br><span class="line">@click.command()</span><br><span class="line">@click.option(&quot;--name&quot;,required=True)</span><br><span class="line">def add(name):</span><br><span class="line">    click.echo(f&quot;add user &#123;name&#125;&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    add()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先定义了一个add()函数，通过click.command()将add()函数装饰成一个命令接口，这样可以直接在命令行上通过“python 文件名.py ”的形式直接调用add()函数，再通过click.option()为add()函数添加选项“–name”，此选项即可通过命令行输入的形式传给add()函数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># python3 cli1.py --name test</span><br><span class="line">add user test</span><br></pre></td></tr></table></figure>

<h2 id="click-option中参数的修饰字段汇总"><a href="#click-option中参数的修饰字段汇总" class="headerlink" title="click.option中参数的修饰字段汇总"></a>click.option中参数的修饰字段汇总</h2><h3 id="required"><a href="#required" class="headerlink" title="required"></a>required</h3><p>click.option()函数中有个required字段，当required=True时表示这个选项在命令行输入参数时必须带上，否则会报错。当required=False时，表示此参数可带可不带。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># python3 cli1.py </span><br><span class="line">Usage: cli1.py [OPTIONS]</span><br><span class="line"></span><br><span class="line">Error: Missing option &quot;--name&quot;.</span><br></pre></td></tr></table></figure>


<p>如果将required=False，则命令是可以执行成功的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import click</span><br><span class="line"></span><br><span class="line">@click.command()</span><br><span class="line">@click.option(&#x27;-n&#x27;,&quot;--name&quot;,required=False)</span><br><span class="line">def add(name):</span><br><span class="line">    click.echo(f&quot;add user &#123;name&#125;&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    add()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># python3 cli2.py </span><br><span class="line">add user None</span><br></pre></td></tr></table></figure>

<p>click.option()还有许多其他参数字段，用来限制或者扩展选项，以满足开发者的需要。</p>
<h3 id="default"><a href="#default" class="headerlink" title="default"></a>default</h3><p>为当前的选项添加default值。即使此时required=True，命令行也可以不输入参数值，如果命令行不输入参数值表示此时输入的是默认值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import click</span><br><span class="line"></span><br><span class="line">@click.command()</span><br><span class="line">@click.option(&quot;--name&quot;,required=True,default=&quot;def_name&quot;)</span><br><span class="line">def add(name):</span><br><span class="line">    click.echo(f&quot;add user &#123;name&#125;&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    add()</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># python3 cli3.py </span><br><span class="line">add user def_name</span><br></pre></td></tr></table></figure>

<h3 id="nargs"><a href="#nargs" class="headerlink" title="nargs"></a>nargs</h3><p>指定命令行参数接收的值的个数，等于-1表示接受参数不限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import click</span><br><span class="line"></span><br><span class="line">@click.command()</span><br><span class="line">@click.option(&quot;--name&quot;,required=True,nargs=2)</span><br><span class="line">def add(name):</span><br><span class="line">    print(name)</span><br><span class="line">    click.echo(f&quot;add user &#123;name&#125;&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    add()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># python3 cli4.py --name 1</span><br><span class="line">Error: --name option requires 2 arguments</span><br><span class="line"></span><br><span class="line"># python3 cli4.py --name 1 2</span><br><span class="line">(&#x27;1&#x27;, &#x27;2&#x27;)</span><br><span class="line">add user (&#x27;1&#x27;, &#x27;2&#x27;)</span><br></pre></td></tr></table></figure>

<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>指定输入选项对应的参数的数据类型，未指定时默认是str字符串类型。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import click</span><br><span class="line"></span><br><span class="line">@click.command()</span><br><span class="line">@click.option(&quot;--name&quot;,required=True)</span><br><span class="line">#@click.option(&quot;--name&quot;,required=True,type=str)  #等同于上一句</span><br><span class="line">def add(name):</span><br><span class="line">    print(type(name))  #打印输入参数name的数据类型</span><br><span class="line">    click.echo(f&quot;add user &#123;name&#125;&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    add()</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># python3 cli5.py --name 1</span><br><span class="line">&lt;class &#x27;str&#x27;&gt;</span><br><span class="line">add user 1</span><br></pre></td></tr></table></figure>

<h3 id="multiple"><a href="#multiple" class="headerlink" title="multiple"></a>multiple</h3><p>multiple=True，使用多个相同地位选项分别指定值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import click</span><br><span class="line"></span><br><span class="line">@click.command()</span><br><span class="line">@click.option(&quot;-N&quot;,&quot;-n&quot;,&quot;--name&quot;,required=True,type=str,multiple=True)</span><br><span class="line">def add(name):</span><br><span class="line">    print(name)</span><br><span class="line">    click.echo(f&quot;add user &#123;name&#125;&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    add()</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># python3 cli6.py --name 1</span><br><span class="line">(&#x27;1&#x27;,)</span><br><span class="line">add user (&#x27;1&#x27;,)</span><br><span class="line"># python3 cli6.py --name 1 -n 2</span><br><span class="line">(&#x27;1&#x27;, &#x27;2&#x27;)</span><br><span class="line">add user (&#x27;1&#x27;, &#x27;2&#x27;)</span><br><span class="line"># python3 cli6.py --name 1 -n 2 -N 3</span><br><span class="line">(&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;)</span><br><span class="line">add user (&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;)</span><br></pre></td></tr></table></figure>

<p>三个选项地位相同，使用的时候可以三选一，可以解决某些要求选项不区分大小写的情况。输入的参数值是以元组的形式传入函数中。</p>
<h3 id="prompt"><a href="#prompt" class="headerlink" title="prompt"></a>prompt</h3><p>当在命令行中没有输入相应的参数时，会根据 prompt 提示用户输入。一般用于密码验证。prompt=True表示接受用户输入，hide_input=True表示隐藏输入的内容，confirmation_prompt=True表示再次确认输入的内容。当然也可以直接在命令行中输入。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import click</span><br><span class="line"></span><br><span class="line">@click.command()</span><br><span class="line">@click.option(&quot;--name&quot;,required=True,type=str)</span><br><span class="line">@click.option(&quot;--password&quot;, prompt=True, hide_input=True, confirmation_prompt=True)</span><br><span class="line">#@click.password_option()  #作用同上句一样，是click对上句的封装</span><br><span class="line">def add(name,password):</span><br><span class="line">    print(name,password)</span><br><span class="line">    click.echo(f&quot;add user &#123;name&#125;&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    add()</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># python3 cli7.py --name 1 </span><br><span class="line">Password: </span><br><span class="line">Repeat for confirmation: </span><br><span class="line">1 123</span><br><span class="line">add user 1</span><br></pre></td></tr></table></figure>

<h3 id="is-eager、is-eager、callback，is-flag"><a href="#is-eager、is-eager、callback，is-flag" class="headerlink" title="is_eager、is_eager、callback，is_flag"></a>is_eager、is_eager、callback，is_flag</h3><p>Click 提供 eager 标识对参数名进行标识，如果输入该参数，则会拦截既定的命令行执行流程，跳转去执行一个回调函数。<br><code>is_eager=True </code>            表明该命令行选项优先级高于其他选项；<br><code>expose_value=False</code>   表示如果没有输入该命令行选项时，会执行既定的命令行流程；<br><code>callback=函数名 </code>         指定了输入该命令行选项时，要跳转执行的函数；<br><code>is_flag=True </code>               表明参数值可以省略。</p>
<p>这四个修饰字段一般会同时使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import click</span><br><span class="line"></span><br><span class="line">def print_version(ctx, param, value):</span><br><span class="line">    print(f&quot;this program version : &#123;value&#125;&quot;)</span><br><span class="line">    # exit()</span><br><span class="line"></span><br><span class="line">@click.command()</span><br><span class="line">@click.option(&quot;--name&quot;,required=True,type=str)</span><br><span class="line"># @click.option(&quot;--version&quot;,is_eager=True,expose_value=False,callback=print_version,is_flag=True)</span><br><span class="line">@click.option(&quot;--version&quot;,is_eager=True,expose_value=False,callback=print_version,is_flag=False)</span><br><span class="line">def add(name):</span><br><span class="line">    print(name)</span><br><span class="line">    click.echo(f&quot;add user &#123;name&#125;&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    add()</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># python3 cli8.py --name 1 </span><br><span class="line">this program version : None</span><br><span class="line">1</span><br><span class="line">add user 1</span><br><span class="line"># python3 cli8.py --name 1 --version 3</span><br><span class="line">this program version : 3</span><br><span class="line">1</span><br><span class="line">add user 1</span><br></pre></td></tr></table></figure>

<p>expose_value=False表示命令行中没有出现–version选项时，会执行click既定的命令流程</p>
<p>callback=print_version，表示当命令行中出现–version时，不在执行click既定的命令流程，转而执行print_version()函数。</p>
<h2 id="click-argument"><a href="#click-argument" class="headerlink" title="click.argument()"></a>click.argument()</h2><p>click.argument()比click.option()用法简单很多，也是用来修饰函数为其添加参数的。不同的是argument()只是添加参数，不添加选项。上面option()中用到的修饰字段也可以用于argument()。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import click</span><br><span class="line"></span><br><span class="line">@click.command()</span><br><span class="line">#@click.option(&quot;--name&quot;,required=True,type=str)</span><br><span class="line">@click.argument(&quot;name&quot;)</span><br><span class="line">def add(name):</span><br><span class="line">    click.echo(f&quot;add user &#123;name&#125;&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    add()</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># python3 cli9.py 123</span><br><span class="line">add user 123</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Click</tag>
      </tags>
  </entry>
  <entry>
    <title>docker离线安装</title>
    <url>/2022/12/09/docker%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<p>安装环境：centos 7.6</p>
<ol>
<li>在docker官网上下载，合适的安装文件，本次使用的是“docker-20.10.3.tgz” 下载地址：<a href="https://download.docker.com/linux/static/stable/x86_64">https://download.docker.com/linux/static/stable/x86_64</a></li>
</ol>
<span id="more"></span>

<ol>
<li>执行 <code>tar xzvf docker-20.10.3.tgz</code> 命令，解压安装包。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@CentOS opt]# tar xzvf docker-20.10.3.tgz</span><br><span class="line">docker/</span><br><span class="line">docker/docker</span><br><span class="line">docker/runc</span><br><span class="line">docker/ctr</span><br><span class="line">docker/dockerd</span><br><span class="line">docker/docker-init</span><br><span class="line">docker/docker-proxy</span><br><span class="line">docker/containerd-shim-runc-v2</span><br><span class="line">docker/containerd-shim</span><br><span class="line">docker/containerd</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>进入docker目录，将目录下的所有文件拷贝至“/usr/bin/” <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@CentOS opt]# cd docker/</span><br><span class="line">[root@CentOS docker]# cp * /usr/bin/</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>执行“vim /etc/systemd/system/docker.service”命令，然后在文件中添加以下内容，然后按“esc”，退出编辑状态，输入“：qw”退出文件编辑。 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Docker Application Container Engine</span><br><span class="line">Documentation=https://docs.docker.com</span><br><span class="line">After=network-online.target firewalld.service</span><br><span class="line">Wants=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=notify</span><br><span class="line">ExecStart=/usr/bin/dockerd</span><br><span class="line">ExecReload=/bin/kill -s HUP $MAINPID</span><br><span class="line">LimitNOFILE=infinity</span><br><span class="line">LimitNPROC=infinity</span><br><span class="line">TimeoutStartSec=0</span><br><span class="line">Delegate=yes</span><br><span class="line">KillMode=process</span><br><span class="line">Restart=on-failure</span><br><span class="line">StartLimitBurst=3</span><br><span class="line">StartLimitInterval=60s</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>给文件增加可执行权限 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x /etc/systemd/system/docker.service</span><br><span class="line">systemctl daemon-reload </span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>开机启动 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl enable docker.service</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>启动Docker <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li>测试 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@CentOS ~]# docker -v</span><br><span class="line">Docker version 20.10.3, build 48d30b5</span><br><span class="line">[root@HikvisionOS ~]#</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>DOCKER</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>python property的介绍与使用</title>
    <url>/2022/12/09/property%E7%9A%84%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>python的@property是python的一种装饰器，是用来修饰方法的。</p>
<span id="more"></span>

<h2 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h2><p>我们可以使用@property装饰器来创建<strong>只读属性</strong>，@property装饰器会将<strong>方法</strong>转换为相同名称的<strong>只读属性</strong>,可以与所定义的属性配合使用，这样可以防止属性被修改。</p>
<h2 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h2><h3 id="1-修饰方法，是方法可以像属性一样访问。"><a href="#1-修饰方法，是方法可以像属性一样访问。" class="headerlink" title="1.修饰方法，是方法可以像属性一样访问。"></a>1.修饰方法，是方法可以像属性一样访问。</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class DataSet(object):</span><br><span class="line">  @property</span><br><span class="line">  def method_with_property(self): ##含有@property</span><br><span class="line">      return 15</span><br><span class="line">  def method_without_property(self): ##不含@property</span><br><span class="line">      return 15</span><br><span class="line"></span><br><span class="line">l = DataSet()</span><br><span class="line">print(l.method_with_property) # 加了@property后，可以用调用属性的形式来调用方法,后面不需要加（）。</span><br><span class="line">print(l.method_without_property())  #没有加@property , 必须使用正常的调用方法的形式，即在后面加()</span><br></pre></td></tr></table></figure>

<p>两个都输出为15。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class DataSet(object):</span><br><span class="line">  @property</span><br><span class="line">  def method_with_property(self): ##含有@property</span><br><span class="line">      return 15</span><br><span class="line">l = DataSet()</span><br><span class="line">print(l.method_with_property（）) # 加了@property后，可以用调用属性的形式来调用方法,后面不需要加（）。</span><br></pre></td></tr></table></figure>

<p>如果使用property进行修饰后，又在调用的时候，方法后面添加了()， 那么就会显示错误信息：TypeError: ‘int’ object is not callable，也就是说添加@property 后，这个方法就变成了一个属性，如果后面加入了()，那么就是当作函数来调用，而它却不是callable（可调用）的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class DataSet(object):</span><br><span class="line">  def method_without_property(self): ##不含@property</span><br><span class="line">      return 15</span><br><span class="line">l = DataSet()</span><br><span class="line">print(l.method_without_property） #没有加@property , 必须使用正常的调用方法的形式，即在后面加()</span><br></pre></td></tr></table></figure>

<p>没有使用property修饰，它是一种方法，如果把括号去掉，不会报错输出的就会是方法存放的地址。</p>
<h3 id="2-与所定义的属性配合使用，这样可以防止属性被修改。"><a href="#2-与所定义的属性配合使用，这样可以防止属性被修改。" class="headerlink" title="2.与所定义的属性配合使用，这样可以防止属性被修改。"></a>2.与所定义的属性配合使用，这样可以防止属性被修改。</h3><p>​ 由于python进行属性的定义时，没办法设置私有属性，因此要通过@property的方法来进行设置。这样可以隐藏属性名，让用户进行使用的时候无法随意修改。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class DataSet(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self._images = 1</span><br><span class="line">        self._labels = 2 #定义属性的名称</span><br><span class="line">    @property</span><br><span class="line">    def images(self): #方法加入@property后，这个方法相当于一个属性，这个属性可以让用户进行使用，而且用户有没办法随意修改。</span><br><span class="line">        return self._images </span><br><span class="line">    @property</span><br><span class="line">    def labels(self):</span><br><span class="line">        return self._labels</span><br><span class="line">l = DataSet()</span><br><span class="line">#用户进行属性调用的时候，直接调用images即可，而不用知道属性名_images，因此用户无法更改属性，从而保护了类的属性。</span><br><span class="line">print(l.images) # 加了@property后，可以用调用属性的形式来调用方法,后面不需要加（）。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>property</tag>
      </tags>
  </entry>
  <entry>
    <title>expect源码安装</title>
    <url>/2022/12/08/expect%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>Expect是在TCL(Tool Command Language 工具脚本语言，是Linux内的一种语言包)基础上创建起来的，在安装expect时必须先安装tcl。</p>
<span id="more"></span>
<h3 id="下载源码包"><a href="#下载源码包" class="headerlink" title="下载源码包"></a>下载源码包</h3><p>tcl8.4.11-src.tar.gz</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget http://nchc.dl.sourceforge.net/sourceforge/tcl/tcl8.4.11-src.tar.gz</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>expect5.45.3.tar.gz</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://nchc.dl.sourceforge.net/project/expect/Expect/5.45.3/expect5.45.3.tar.gz</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="安装tcl8-4-11"><a href="#安装tcl8-4-11" class="headerlink" title="安装tcl8.4.11"></a>安装tcl8.4.11</h3><h4 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar xfvz tcl8.4.11-src.tar.gz</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="安装配置"><a href="#安装配置" class="headerlink" title="安装配置"></a>安装配置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd tcl8.4.11/unix</span><br><span class="line">./configure --prefix=/usr/tcl --enable-shared</span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="安装-expect5-45-3"><a href="#安装-expect5-45-3" class="headerlink" title="安装 expect5.45.3"></a>安装 expect5.45.3</h3><h4 id="解压-1"><a href="#解压-1" class="headerlink" title="解压"></a>解压</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar xfvz expect5.45.3.tar.gz</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="安装配置-1"><a href="#安装配置-1" class="headerlink" title="安装配置"></a>安装配置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd expect5.45.3</span><br><span class="line">./configure --prefix=/usr/expect --with-tcl=/usr/tcl/lib --with-tclinclude=../tcl8.4.11/generic</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果是在arm服务器上，提示<code>configure: error: cannot guess build type; you must specify one</code><br>需要加上–build=aarch64-unknown-linux-gnu</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd expect5.45.3</span><br><span class="line">./configure --build=aarch64-unknown-linux-gnu --prefix=/usr/expect --with-tcl=/usr/tcl/lib --with-tclinclude=../tcl8.4.11/generic</span><br><span class="line"></span><br><span class="line">make</span><br><span class="line">make install</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/usr/tcl/bin/expect -f</span><br><span class="line"> for &#123;set i 14&#125; &#123;$i &lt; 23&#125; &#123;incr i&#125; &#123;</span><br><span class="line">     spawn ssh root@192.168.4.$i</span><br><span class="line">     expect &#123;</span><br><span class="line">        &quot;*password:*&quot; &#123;</span><br><span class="line">        send &quot;123456\r&quot;</span><br><span class="line">        exp_continue</span><br><span class="line">            &#125;</span><br><span class="line">        &quot;*yes/no)?*&quot; &#123;</span><br><span class="line">        send &quot;yes\r&quot;</span><br><span class="line">        exp_continue</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    expect &quot;]# &quot;</span><br><span class="line">    send &quot;rm -rf /usr//work/*\r&quot;</span><br><span class="line">    send &quot;exit\r&quot;</span><br><span class="line">    expect eof</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>expect</tag>
      </tags>
  </entry>
  <entry>
    <title>gitstats使用介绍</title>
    <url>/2022/12/05/gitstats%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>进一步来讲，Gitstats它是一个git仓库分析软件，它可以检查仓库并生成历史数据的统计信息。可以帮助你查看git仓库的提交状态，根据不同维度分析计算，并自动生成数据图表。<br>官网介绍：<a href="http://gitstats.sourceforge.net/">http://gitstats.sourceforge.net/</a></p>
<span id="more"></span>
<p>当前GitStats所生成统计信息常用分为如下几类：<br><strong>常规的统计</strong>：文件总数，行数，提交量，作者数。<br><strong>活跃性</strong>：每天中每小时的、每周中每天的、每周中每小时的、每年中每月的、每年的提交量。<br><strong>作者数</strong>：列举所有的作者（提交数，第一次提交日期，最近一次的提交日期），并按月和年来划分。<br><strong>文件数</strong>：按日期划分，按扩展名名划分。<br><strong>行数</strong>：按日期划分。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//mac osx</span><br><span class="line">brew install gnuplot</span><br><span class="line">//centos linux</span><br><span class="line">yum install gnuplot</span><br><span class="line">//ubuntu linux</span><br><span class="line">apt install gnuplot</span><br></pre></td></tr></table></figure>

<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://github.com/hoxu/gitstats.git</span><br><span class="line"><span class="built_in">cd</span> gitstats</span><br><span class="line">./gitstats 你的项目的位置 生成统计的文件夹位置</span><br></pre></td></tr></table></figure>

<h2 id="展示"><a href="#展示" class="headerlink" title="展示"></a>展示</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> 生成统计的文件夹位置</span><br><span class="line">python3 -m http.server 8090</span><br></pre></td></tr></table></figure>

<h2 id="qemu示例"><a href="#qemu示例" class="headerlink" title="qemu示例"></a>qemu示例</h2><p>如下图所示。首先，在gitstats上提供了全局的统计数据报告，包括：</p>
<p><strong>报告产生时间及产生所花费的时间</strong>：如花费了710秒<br><strong>报告所覆盖的时间</strong>：如2003-02-19 to 2022-12-05<br><strong>年龄</strong>：该repo的年纪，如“7230天，其中5918天是活跃天.”<br><strong>文件数及代码</strong>：如：9256个文件，3130k行代码。<br><strong>总提交数</strong>：如：99776，平均每天13.8个<br><strong>作者数</strong>：如2160，每个作者平均提交次数46.2次。<br><img src="efbe731981191bf53d5ddccfb0d2ceddc68787753068302bb6b07ae3325161c7.png" alt="图 6">  </p>
<p>除此之外，还包括了：</p>
<ol>
<li>时间维度的效率分析：每天中每小时的、每周中每天的、每周中每小时的、每年中每月的、每年的提交量。<br><img src="e3f27ccfddf1d938e78059ed84dbee1e10029e531785d1c35dbd64ec9fd176e4.png" alt="图 7"><br><img src="c2af9654b130fbe357f60fc7d9b0d9f688909b0fd41cc173ed06bc9609bb03db.png" alt="图 8"><br><img src="fe0f04ea5472dac1bb45ef27504cf61e91c71154babe868b1d90ae164ffa901c.png" alt="图 9"><br><img src="d8a4aee3fe667a3fe39257feb14b177fc098d0952bfb78cf7a3139ac838adb95.png" alt="图 10"><br><img src="b04a8580c65f01373f091389a9c3a7d3138acb8aaf002e9a21a5ae8b8587acf5.png" alt="图 11"><br><img src="226d67aed51a110fa818c54b82b4e74434e727c354565bcf779b19f6ba31dd55.png" alt="图 12">  </li>
</ol>
<ol start="2">
<li>提交者维度的活跃度统计：列举所有的作者（提交数，第一次提交日期，最近一次的提交日期），并按月和年来划分。<br><img src="1245268c1062710ee022fb12149e82705b29e4591c0e3aacb7fd844462b8bdaf.png" alt="图 13">  </li>
</ol>
<ol start="3">
<li><p>按照文件数：按日期划分，按扩展名名划分。<br><img src="1bacc00060ca63e9f239802a91e68849e4337457d9909e0754eee5fc1664a4ee.png" alt="图 14">  </p>
</li>
<li><p>根据提交行数或提交的tag来统计。<br><img src="29853f0496e7b26c4d69af48e2d863367a2c96ee70534f89698a31e3f49b03a4.png" alt="图 15">  </p>
</li>
</ol>
]]></content>
      <categories>
        <category>GIT</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>centos8安装pprof</title>
    <url>/2022/11/22/centos8%E5%AE%89%E8%A3%85pprof/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这是谷歌的一个linux下性能测试的小工具。可以简单快速的发现程序的性能瓶颈。</p>
<span id="more"></span>
<h2 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /etc/*release</span></span><br><span class="line">CentOS Linux release 8.4.2105</span><br><span class="line">NAME=<span class="string">&quot;CentOS Linux&quot;</span></span><br><span class="line">VERSION=<span class="string">&quot;8&quot;</span></span><br><span class="line">ID=<span class="string">&quot;centos&quot;</span></span><br><span class="line">ID_LIKE=<span class="string">&quot;rhel fedora&quot;</span></span><br><span class="line">VERSION_ID=<span class="string">&quot;8&quot;</span></span><br><span class="line">PLATFORM_ID=<span class="string">&quot;platform:el8&quot;</span></span><br><span class="line">PRETTY_NAME=<span class="string">&quot;CentOS Linux 8&quot;</span></span><br><span class="line">ANSI_COLOR=<span class="string">&quot;0;31&quot;</span></span><br><span class="line">CPE_NAME=<span class="string">&quot;cpe:/o:centos:centos:8&quot;</span></span><br><span class="line">HOME_URL=<span class="string">&quot;https://centos.org/&quot;</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">&quot;https://bugs.centos.org/&quot;</span></span><br><span class="line">CENTOS_MANTISBT_PROJECT=<span class="string">&quot;CentOS-8&quot;</span></span><br><span class="line">CENTOS_MANTISBT_PROJECT_VERSION=<span class="string">&quot;8&quot;</span></span><br><span class="line">CentOS Linux release 8.4.2105</span><br><span class="line">CentOS Linux release 8.4.2105</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="安装编译工具"><a href="#安装编译工具" class="headerlink" title="安装编译工具"></a>安装编译工具</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install gcc</span><br><span class="line">yum -y install gcc-c++</span><br><span class="line">yum -y install make</span><br><span class="line">yum install -y autoconf automake libtool</span><br><span class="line">yum install -y wget</span><br></pre></td></tr></table></figure>

<p><strong>提示</strong>：<br>安装过程中出现以下错误</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yum -y install gcc</span></span><br><span class="line">Last metadata expiration check: 0:15:41 ago on Wed 23 Nov 2022 03:56:44 PM CST.</span><br><span class="line">Error: </span><br><span class="line"> Problem: package gcc-8.5.0-4.el8_5.x86_64 requires glibc-devel &gt;= 2.2.90-12, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libpthread.so.0, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libdl.so.2, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libm.so.6, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libresolv.so.2, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires librt.so.1, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libutil.so.1, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libBrokenLocale.so.1, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libanl.so.1, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libthread_db.so.1, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.x86_64 requires glibc = 2.28-164.el8, but none of the providers can be installed</span><br><span class="line">  - glibc-2.28-164.el8.i686 has inferior architecture</span><br><span class="line">  - cannot install both glibc-2.28-164.el8.x86_64 and glibc-2.28-203.el8.x86_64</span><br><span class="line">  - package glibc-gconv-extra-2.28-203.el8.x86_64 requires glibc(x86-64) = 2.28-203.el8, but none of the providers can be installed</span><br><span class="line">  - cannot install the best candidate <span class="keyword">for</span> the job</span><br><span class="line">  - problem with installed package glibc-gconv-extra-2.28-203.el8.x86_64</span><br><span class="line">(try to add <span class="string">&#x27;--allowerasing&#x27;</span> to <span class="built_in">command</span> line to replace conflicting packages or <span class="string">&#x27;--skip-broken&#x27;</span> to skip uninstallable packages or <span class="string">&#x27;--nobest&#x27;</span> to use not only best candidate packages)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>则执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install gcc --allowerasing</span><br></pre></td></tr></table></figure>

<p>可执行文件对应的安装包查找：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum whatprovides autoreconf</span><br></pre></td></tr></table></figure>
<p><img src="c5dd6168b78ccf54aa38d65134cb70a21c2adb250934fcf9c448d9d29d12851c.png" alt="图 26"><br>则安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y autoconf</span><br></pre></td></tr></table></figure>

<h2 id="安装libunwind"><a href="#安装libunwind" class="headerlink" title="安装libunwind"></a>安装libunwind</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/libunwind/libunwind/archive/v0.99.tar.gz</span><br><span class="line">tar -xvf v0.99.tar.gz</span><br><span class="line"><span class="built_in">cd</span> libunwind-0.99</span><br><span class="line">autoreconf --force -v --install</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h2 id="安装perftools"><a href="#安装perftools" class="headerlink" title="安装perftools"></a>安装perftools</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/gperftools/gperftools/releases/download/gperftools-2.6.1/gperftools-2.6.1.tar.gz</span><br><span class="line">tar -xvf gperftools-2.6.1.tar.gz </span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h2 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h2><p><img src="e25c28feccf7bac3e0f524dec94e4a1f7f2d5db678b0fd3366351056d111b03a.png" alt="图 27">  </p>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>pprof</tag>
      </tags>
  </entry>
  <entry>
    <title>base64编解码</title>
    <url>/2022/11/16/base64%E7%BC%96%E8%A7%A3%E7%A0%81/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，是一种基于<strong>64个可打印字符</strong>来表示二进制数据的方法</p>
<span id="more"></span>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ol>
<li>Base64一般用于在 HTTP协议下传输二进制数据，由于 HTTP协议是文本协议，所以在HTTP协议下传输二进制数据需要将二进制数据转换为字符数据。然而直接转换是不行的。因为网络传输只能传输可打印字符，需要用Base64将不可显字符转换为可显字符</li>
<li>可用于将明文通过AES加密后，通过Base64将不可显的加密字符转换为可显字符</li>
</ol>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>base64编码表<br><img src="c617678b70d6a249a3556d4a16a4d49fbd9dc22f4be59bda0d0e52450c20be76.png" alt="图 2"> </p>
<p>由于base64编码是将编码前的3*8位数据，分解成4个6位的数据，所以经过base64编码后的字符串长度是4的倍数。<br>但往往我们进行编码的数据长度并不是3的倍数，这就造成了“编码”后的位数不为4的倍数，</p>
<p>比如Brisk共5×8=40位，以6位为一组可以分为7组，这样“编码”后就有7个字符，<br>但base64编码后的字符长度应该是4的倍数，显然这里就出问题了，那么怎么办呢？<br>前面的不可以抛弃掉，所以就只有“追加”了，所以Brisk经过base64编码后的长度应该是8个字符，而第8个编码后的字符是’=’，</p>
<p>再比如对单个字符a进行base64编码，由于它的长度不是3的倍数，以3个字节为一组它只能分一组，再以6位为一位它只能分两组，所以经过“编码”后它的长度是2，但base64编码后的个数应该是4的倍数，所以它的长度应该是4，所以在后面补上两个‘=’,</p>
<p>由于一个数求余3后有三个不同的结果，0、1、2，所以在对一个数据进行base64进行编码后它的长度为： </p>
<ol>
<li><p>当进行编码的数据长度是3的倍数时，len=strlen(str_in)/3*4;</p>
</li>
<li><p>当进行编码的数据长度不是3的倍数时，len=(strlen(str_in)/3+1)*4;</p>
</li>
</ol>
<p>我们以Brisk这个例子来说明一下base64编码的过程。首先我们以3个字符为一组将Brisk进行分组，Brisk被氛围两组：Bri 和 sk；然后我们取出这两个分组中每个字节的ASCII码，B:66 r:114 i:105 s:115 k:107。它们对应的二进制数为  B:01000010 r:01110010 i:01101001 s:01110011 k:01101011；</p>
<p>第一组，我们以6位为一组对每一个3字节分组进行再分组就变成了010000 100111 001001 101001。所对应的十进制数是16 39 9 41，对应base64表中的结果是 Q n J p；</p>
<p>第二组，011100 110110 101100(不够补0)，所以对应的十进制数是 28 54 44，对应base64表中的结果是 c 2 s，最终结果为QnJpc2s=（因为第二组“编码”后只有三个字节）。</p>
<p>解码的过程是一个逆过程，我们将经过编码后的字符按4个字符为一组，然后对照base64表得到相应的十进制数，再将其通过拆分和组合，组成3个8位数据，这个数据就是解码后的数据，下面给一个c语言实现编码和解码的代码。</p>
<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">encode_string</span><span class="params">(</span></span><br><span class="line"><span class="params">				<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> * src, <span class="type">int</span> len,</span></span><br><span class="line"><span class="params">				<span class="type">unsigned</span> <span class="type">char</span> * dest, <span class="type">unsigned</span> <span class="type">char</span> * base64, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> one;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> two;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> thr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> fou;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ( len &gt;= <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        one = src[<span class="number">0</span>] &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        two = ( ( src[<span class="number">0</span>] &amp; <span class="number">0x03</span> ) &lt;&lt; <span class="number">4</span> ) | ( src[<span class="number">1</span>] &gt;&gt; <span class="number">4</span> );</span><br><span class="line">        thr = ( ( src[<span class="number">1</span>] &amp; <span class="number">0x0F</span> ) &lt;&lt; <span class="number">2</span> ) | ( src[<span class="number">2</span>] &gt;&gt; <span class="number">6</span> );</span><br><span class="line">        fou = src[<span class="number">2</span>] &amp; <span class="number">0x3F</span>;</span><br><span class="line"> </span><br><span class="line">        *( dest + index++ ) = base64[one];</span><br><span class="line">        *( dest + index++ ) = base64[two];</span><br><span class="line">        *( dest + index++ ) = base64[thr];</span><br><span class="line">        *( dest + index   ) = base64[fou];</span><br><span class="line">		<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> ( len == <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        one = src[<span class="number">0</span>] &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        two = ( ( src[<span class="number">0</span>] &amp; <span class="number">0x03</span>) &lt;&lt; <span class="number">4</span> ) | ( src[<span class="number">1</span>] &gt;&gt; <span class="number">4</span> );</span><br><span class="line">        thr = ( src[<span class="number">1</span>] &amp; <span class="number">0x0F</span> ) &lt;&lt; <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">        *( dest + index++ ) = base64[one];</span><br><span class="line">        *( dest + index++ ) = base64[two];</span><br><span class="line">        *( dest + index++ ) = base64[thr];</span><br><span class="line">        *( dest + index   ) = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( len == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        one = src[<span class="number">0</span>] &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        two = ( src[<span class="number">0</span>] &amp; <span class="number">0x03</span> ) &lt;&lt; <span class="number">4</span>;</span><br><span class="line"> </span><br><span class="line">        *( dest + index++ ) = base64[one];</span><br><span class="line">        *( dest + index++ ) = base64[two];</span><br><span class="line">        *( dest + index++ ) = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">        *( dest + index   ) = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;Unknow length\n&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">base64_encode</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> * src, <span class="type">int</span> src_len, <span class="type">char</span> * dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> base64[] = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">while</span>( src_len &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> step = encode_string( src, src_len, (<span class="type">unsigned</span> <span class="type">char</span> *)dest, base64, index );</span><br><span class="line"> </span><br><span class="line">        index += <span class="number">4</span>;</span><br><span class="line">        src += step;</span><br><span class="line">		src_len -= step;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    *( dest + index ) = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">create_array</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> * <span class="built_in">array</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( index  = <span class="number">0</span>; index &lt; <span class="number">123</span>; index += <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( index == <span class="number">0x2B</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            *( <span class="built_in">array</span> + index ) = <span class="number">0x3E</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( index == <span class="number">0x2F</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            *( <span class="built_in">array</span> + index ) = <span class="number">0x3F</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( index &gt;= <span class="number">0x30</span> &amp;&amp; index &lt;= <span class="number">0x39</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            *( <span class="built_in">array</span> + index ) = <span class="number">0x34</span> + index - <span class="number">0x30</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( index == <span class="number">0x3D</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            *( <span class="built_in">array</span> + index ) = <span class="number">0x00</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( index &gt;= <span class="number">0x41</span> &amp;&amp; index &lt;= <span class="number">0x5A</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            *( <span class="built_in">array</span> + index ) = index - <span class="number">0x41</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( index &gt;= <span class="number">0x61</span> &amp;&amp; index &lt;= <span class="number">0x7A</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            *( <span class="built_in">array</span> + index ) = <span class="number">0x1A</span> + index - <span class="number">0x61</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            *( <span class="built_in">array</span> + index ) = <span class="number">0x00</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    *( <span class="built_in">array</span> + <span class="number">123</span> ) = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">decode_string</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * src, <span class="type">unsigned</span> <span class="type">char</span> * dest, <span class="type">unsigned</span> <span class="type">char</span> * <span class="built_in">array</span>, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> step;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> one;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> two;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> thr;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> ( src[<span class="number">3</span>] == <span class="string">&#x27;=&#x27;</span> &amp;&amp; src[<span class="number">2</span>] == <span class="string">&#x27;=&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        one = ( <span class="built_in">array</span>[src[<span class="number">0</span>]] &lt;&lt; <span class="number">2</span> ) | ( <span class="built_in">array</span>[src[<span class="number">1</span>]] &gt;&gt; <span class="number">4</span> );</span><br><span class="line">        *( dest + index ) = one;</span><br><span class="line"> </span><br><span class="line">        step = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( src[<span class="number">3</span>] == <span class="string">&#x27;=&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        one = ( <span class="built_in">array</span>[src[<span class="number">0</span>]] &lt;&lt; <span class="number">2</span> ) | ( <span class="built_in">array</span>[src[<span class="number">1</span>]] &gt;&gt; <span class="number">4</span> );</span><br><span class="line">        two = ( ( <span class="built_in">array</span>[src[<span class="number">1</span>]] &amp; <span class="number">0x0F</span> ) &lt;&lt; <span class="number">4</span> ) | ( <span class="built_in">array</span>[src[<span class="number">2</span>]] &gt;&gt; <span class="number">2</span> );</span><br><span class="line"> </span><br><span class="line">        *( dest + index++ ) = one;</span><br><span class="line">        *( dest + index   ) = two;</span><br><span class="line"> </span><br><span class="line">        step = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        one = ( <span class="built_in">array</span>[src[<span class="number">0</span>]] &lt;&lt; <span class="number">2</span> ) | ( <span class="built_in">array</span>[src[<span class="number">1</span>]] &gt;&gt; <span class="number">4</span> );</span><br><span class="line">        two = ( ( <span class="built_in">array</span>[src[<span class="number">1</span>]] &amp; <span class="number">0x0F</span> ) &lt;&lt; <span class="number">4</span> ) | ( <span class="built_in">array</span>[src[<span class="number">2</span>]] &gt;&gt; <span class="number">2</span> );</span><br><span class="line">        thr = ( <span class="built_in">array</span>[src[<span class="number">2</span>]] &lt;&lt; <span class="number">6</span> ) | <span class="built_in">array</span>[src[<span class="number">3</span>]];</span><br><span class="line"> </span><br><span class="line">        *( dest + index++ ) = one;</span><br><span class="line">        *( dest + index++ ) = two;</span><br><span class="line">        *( dest + index   ) = thr;</span><br><span class="line"> </span><br><span class="line">        step = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">base64_decode</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * src, <span class="type">unsigned</span> <span class="type">char</span> * dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> <span class="built_in">array</span>[<span class="number">124</span>];</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">memset</span>( <span class="built_in">array</span>, <span class="number">0x00</span>, <span class="number">124</span> );</span><br><span class="line">    create_array( <span class="built_in">array</span> );</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> ( *src )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> step = decode_string( src, dest, <span class="built_in">array</span>, index );</span><br><span class="line"> </span><br><span class="line">        index += step;</span><br><span class="line">        src   += <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    *( dest + index ) = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>测试代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *src_str = <span class="string">&quot;abcsjdhs123134&quot;</span>;</span><br><span class="line">	<span class="type">int</span> src_str_len = <span class="built_in">strlen</span>(src_str);</span><br><span class="line">	<span class="type">char</span> *out_buf = (<span class="type">char</span> *)<span class="built_in">malloc</span>(src_str_len * <span class="number">2</span>);</span><br><span class="line">	<span class="type">char</span> *out_decode_buf = (<span class="type">char</span> *)<span class="built_in">malloc</span>(src_str_len * <span class="number">2</span>);</span><br><span class="line">	base64_encode(src_str, src_str_len, out_buf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;src_str:       %s\n&quot;</span>, src_str);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;base64_encode: %s\n&quot;</span>, out_buf);</span><br><span class="line"></span><br><span class="line">	base64_decode(out_buf, out_decode_buf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;base64_decode: %s\n&quot;</span>, out_decode_buf);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果展示<br><img src="8106a76ff5b18e8cda5e478736125efeec53fcaf86e1744cf4fe4accaaf6a38b.png" alt="图 3">  </p>
]]></content>
      <categories>
        <category>BASE64</category>
      </categories>
      <tags>
        <tag>BASE64</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenSSL之AES用法</title>
    <url>/2022/11/16/OpenSSL%E4%B9%8BAES%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>AES是<strong>对称</strong>加密的算法，使用128、192 和 256 位密钥，将被加密数据划分为128位（16字节）一块，然后使用某种加密模式进行加密</p>
<p>关键词：<br><strong>块大小</strong>：16字节<br><strong>密钥长度</strong>：AES算法下，key的长度有三种：128、192和256 bits。</p>
<span id="more"></span>
<p><strong>加密模式</strong>：AES属于块加密（Block Cipher），块加密中有CBC、ECB、CTR、OFB、CFB等几种工作模式。<br><strong>填充模式</strong>：</p>
<ul>
<li>NoPadding，数据长度不对齐时使用”\0”填充，否则不填充</li>
<li>PKCS7Padding，假设数据长度需要填充n(n&gt;0)个字节才对齐，那么填充n个字节，每个字节都是n;如果数据本身就已经对齐了，则填充一块长度为块大小的数据，每个字节都是块大小</li>
<li>PKCS5Padding，PKCS7Padding的子集，块大小固定为8字节。</li>
</ul>
<p>AES加密，如果输入是16<em>n字节，NoPadding填充的情况下，输出和输入相同；有填充的情况下，输出是16</em>（n+1）。<br>如果输入不是16字节整数倍，而是大于16<em>n小于16</em>（n+1），NoPadding填充情况下（只能是CFB和OFB模式），输出和输入长度相同；其他情况下，输出长度是16*（n+1）</p>
<h2 id="设置加解密接口"><a href="#设置加解密接口" class="headerlink" title="设置加解密接口"></a>设置加解密接口</h2><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><ul>
<li><p>函数原型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">AES_set_encrypt_key</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *userKey, <span class="type">const</span> <span class="type">int</span> bits,</span></span><br><span class="line"><span class="params">                        AES_KEY *key)</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>函数作用<br>设定加密用的Key</p>
</li>
<li><p>参数说明<br><code>userKey</code>： 密钥数值；<br><code>bits</code>：密钥长度，以bit为单位，如果密钥数字是16个字节，则此参数值应为128；<br><code>key</code>： AES_KEY对象指针；<br><code>返回值</code>：<br>0: 成功<br>1: userkey，key为空<br>2: 密钥长度不是128，192，256</p>
</li>
</ul>
<h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><ul>
<li><p>函数原型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">AES_set_decrypt_key</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *userKey, <span class="type">const</span> <span class="type">int</span> bits,</span></span><br><span class="line"><span class="params">                        AES_KEY *key)</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>函数作用<br>设定解密用的Key</p>
</li>
<li><p>参数说明<br><code>userKey</code>： 密钥数值；<br><code>bits</code>：密钥长度，以bit为单位，如果密钥数字是16个字节，则此参数值应为128；<br><code>key</code>： AES_KEY对象指针；<br><code>返回值</code>：<br>0: 成功<br>1: userkey，key为空<br>2: 密钥长度不是128，192，256</p>
</li>
</ul>
<h2 id="常用加密模式"><a href="#常用加密模式" class="headerlink" title="常用加密模式"></a>常用加密模式</h2><h3 id="CBC"><a href="#CBC" class="headerlink" title="CBC"></a>CBC</h3><ul>
<li><p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AES_cbc_encrypt</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *in, <span class="type">unsigned</span> <span class="type">char</span> *out,</span></span><br><span class="line"><span class="params">                     <span class="type">size_t</span> length, <span class="type">const</span> AES_KEY *key,</span></span><br><span class="line"><span class="params">                     <span class="type">unsigned</span> <span class="type">char</span> *ivec, <span class="type">const</span> <span class="type">int</span> enc)</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>函数作用：<br>AES加密/解密单个数据块（16个字节），CBC模式</p>
</li>
<li><p>参数说明：<br><code>in</code>： 需要加密/解密的数据；<br><code>out</code>： 计算后输出的数据；<br><code>length</code>： 数据长度（这里不包含初始向量数据长度）<br><code>key</code>：密钥<br><code>ivec</code>： 初始向量（一般为16字节全0）<br><code>enc</code>：<br>AES_ENCRYPT：代表加密<br>AES_DECRYPT：代表解密</p>
</li>
</ul>
<h3 id="ECB"><a href="#ECB" class="headerlink" title="ECB"></a>ECB</h3><ul>
<li><p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AES_ecb_encrypt</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *in, <span class="type">unsigned</span> <span class="type">char</span> *out,</span></span><br><span class="line"><span class="params">                     <span class="type">const</span> AES_KEY *key, <span class="type">const</span> <span class="type">int</span> enc)</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>函数作用：<br>AES加密/解密单个数据块（16个字节），ECB模式</p>
</li>
<li><p>参数说明：<br><code>in</code>: 需要加密/解密的数据；<br><code>out</code>: 计算后输出的数据；<br><code>key</code>: 密钥<br><code>enc</code>:<br>AES_ENCRYPT：代表加密<br>AES_DECRYPT：代表解密</p>
</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>测试代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TEST_ORG_DATA <span class="string">&quot;this is test aes data!&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">remove_padding</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buff, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	ch = buff[size - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; ch; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (buff[size - i] != buff[size - (i + <span class="number">1</span>)])</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	buff[size - i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">str2hex</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *ret = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> str_len = <span class="built_in">strlen</span>(str);</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> sret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	ret = (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="built_in">malloc</span>(str_len / <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; str_len; i += <span class="number">2</span>)</span><br><span class="line">		sret = <span class="built_in">sscanf</span>(str + i, <span class="string">&quot;%2hhX&quot;</span>, &amp;ret[i/<span class="number">2</span>]);</span><br><span class="line">	<span class="keyword">if</span> (sret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">free</span>(ret);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">decode_aes128_ecb</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *encrypt_buff, <span class="type">int</span> buf_len, <span class="type">unsigned</span> <span class="type">char</span> **out)</span></span><br><span class="line">&#123;</span><br><span class="line">	AES_KEY aes;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *decrypt_buff = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *key = str2hex(<span class="string">&quot;B1CFC3D787DC4511&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(&amp;aes, <span class="number">0</span>, <span class="keyword">sizeof</span>(aes));</span><br><span class="line">	decrypt_buff = (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="built_in">malloc</span>((<span class="type">size_t</span>)buf_len);</span><br><span class="line"></span><br><span class="line">	AES_set_decrypt_key(key, <span class="number">128</span>, &amp;aes);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; buf_len; i += AES_BLOCK_SIZE) &#123;</span><br><span class="line">		AES_ecb_encrypt</span><br><span class="line">			(encrypt_buff + i, decrypt_buff + i, &amp;aes, AES_DECRYPT);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	remove_padding(decrypt_buff, buf_len);</span><br><span class="line"></span><br><span class="line">	*out = decrypt_buff;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">encode_aes128_ecb</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> **out, <span class="type">int</span> *out_len)</span></span><br><span class="line">&#123;</span><br><span class="line">	AES_KEY aes;</span><br><span class="line">	<span class="type">int</span> data_len = <span class="built_in">strlen</span>(TEST_ORG_DATA);</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="type">json_error_t</span> error;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *encrypt_buff = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *decrypt_buff = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *key = str2hex(<span class="string">&quot;B1CFC3D787DC4511&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> pad_len = AES_BLOCK_SIZE - (data_len % AES_BLOCK_SIZE);</span><br><span class="line">	encrypt_buff = (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="built_in">malloc</span>(data_len + pad_len);</span><br><span class="line">	decrypt_buff = (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="built_in">malloc</span>(data_len + pad_len);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(decrypt_buff, TEST_ORG_DATA, data_len);</span><br><span class="line">	<span class="built_in">memset</span>(decrypt_buff+data_len, pad_len, pad_len);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(&amp;aes, <span class="number">0</span>, <span class="keyword">sizeof</span>(aes));</span><br><span class="line">	AES_set_encrypt_key(key, <span class="number">128</span>, &amp;aes);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; data_len+pad_len; i += AES_BLOCK_SIZE) &#123;</span><br><span class="line">		AES_ecb_encrypt</span><br><span class="line">			(decrypt_buff + i, encrypt_buff + i, &amp;aes, AES_ENCRYPT);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*out = encrypt_buff;</span><br><span class="line">	*out_len = data_len+pad_len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;data before aes :\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, TEST_ORG_DATA);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *en_code = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> en_code_len;</span><br><span class="line">	encode_aes128_ecb(&amp;en_code, &amp;en_code_len);</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *de_code = <span class="literal">NULL</span>;</span><br><span class="line">	decode_aes128_ecb(en_code, en_code_len, &amp;de_code);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;data after aes encode and decode :\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, de_code);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试结果：<br><img src="4f8473f4df84e1e65d147bd49af24b1cf87b702462969287d002e093c7cfd2e1.png" alt="图 2">  </p>
]]></content>
      <categories>
        <category>OPENSSL</category>
      </categories>
      <tags>
        <tag>AES</tag>
        <tag>OPENSSL</tag>
      </tags>
  </entry>
  <entry>
    <title>/dev/shm容器下调优</title>
    <url>/2022/07/12/dev-shm%E5%AE%B9%E5%99%A8%E4%B8%8B%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>一些应用软件如oracle、postgresql在处理数据时通常会利用/dev/shm目录来缓存的数据文件,以加快IO读写,但是docker 默认只在容器里给这个文件分配64M大小,当应用软件需要缓存较大数据时,就会导致类似<code>could not resize shared memory segment &quot;/PostgreSQL.1131616928&quot; to 16777216 bytes: No space left on device</code>的报错,这样就需要调整/dev/shm大小</p>
<span id="more"></span>

<h3 id="dev-shm目录是什么"><a href="#dev-shm目录是什么" class="headerlink" title="/dev/shm目录是什么"></a>/dev/shm目录是什么</h3><p>/dev/shm在linux中被看作一个设备文件,可以把它看成是内存的入口、一块物理存储或者tmp filesystem，可以通过这个设备向内存中读写文件，以加快某些io高的操作。</p>
<h4 id="dev-shm-理论"><a href="#dev-shm-理论" class="headerlink" title="/dev/shm 理论"></a>/dev/shm 理论</h4><p>默认的Linux发行版中的内核配置都会开启tmpfs，映射到了/dev/下的shm目录。可以通过df 命令查看结果.<br>/dev/shm/是linux下一个非常有用的目录，因为这个目录不在硬盘上，而是在内存里。因此在linux下，就不需要大费周折去建ramdisk，直接使用/dev/shm/就可达到很好的优化效果。默认系统就会加载/dev/shm ，它就是所谓的tmpfs，有人说跟ramdisk（虚拟磁盘），但不一样。象虚拟磁盘一样，tmpfs 可以使用您的 RAM，但它也可以使用您的交换分区来存储。而且传统的虚拟磁盘是个块设备，并需要一个 mkfs 之类的命令才能真正地使用它，tmpfs 是一个文件系统，而不是块设备；您只是安装它，它就可以使用了。<br>tmpfs有以下优势：</p>
<ol>
<li>动态文件系统的大小，/dev /shm需要注意的一个是容量问题，在linux下，它默认最大为内存的一半大小，使用df -h命令可以看到。但它并不会真正的占用这块内存，如果/dev/shm/下没有任何文件，它占用的内存实际上就是0字节；如果它最大为1G，里头放有 100M文件，那剩余的900M仍然可为其它应用程序所使用，但它所占用的100M内存，是绝不会被系统回收重新划分的</li>
<li>tmpfs 的另一个主要的好处是它闪电般的速度。因为典型的 tmpfs 文件系统会完全驻留在 RAM 中，读写几乎可以是瞬间的。</li>
<li>tmpfs 数据在重新启动之后不会保留，因为虚拟内存本质上就是易失的。所以有必要做一些脚本做诸如加载，绑定的操作。</li>
</ol>
<h4 id="修改-dev-shm大小"><a href="#修改-dev-shm大小" class="headerlink" title="修改/dev/shm大小"></a>修改/dev/shm大小</h4><p>默认的最大一半内存大小在某些场合可能不够用，并且默认的inode数量很低一般都要调高些，这时可以用mount命令来管理它。<br><code>#mount -o size=1500M -o nr_inodes=1000000 -o noatime,nodiratime -o remount /dev/shm</code></p>
<p>也可以将mount配置写到fstab让其开机生效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;tmpfs /dev/shm tmpfs,defaults,size=512m 0 0&quot; &gt;&gt; /etc/fstab</span><br><span class="line">mount -o remount /dev/shm</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>下面我们可以创建一个目录绑定/dev/shm文件系统,并测试读写速度</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /dev/shm/tmp</span><br><span class="line">chmod 1777 /dev/shm/tmp</span><br><span class="line">mkdir /fbo-tmp</span><br><span class="line">mount --bind /dev/shm/tmp /fbo-tmp</span><br><span class="line">cd /fbo-tmp</span><br><span class="line">dd if=/dev/zero of=./test.dt bs=1k count=10000</span><br><span class="line"></span><br><span class="line"># free -m 可以发现share内存被占用了10M</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="容器下怎么设置"><a href="#容器下怎么设置" class="headerlink" title="容器下怎么设置"></a>容器下怎么设置</h2><h3 id="docker设置"><a href="#docker设置" class="headerlink" title="docker设置"></a>docker设置</h3><p>docker启动时添加<code>--shm-size</code>参数调整/dev/shm文件系统大小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run --shm-size 124M -it --rm --name test-$RANDOM busybox /bin/sh</span><br><span class="line">Unable to find image &#x27;busybox:latest&#x27; locally</span><br><span class="line">latest: Pulling from library/busybox</span><br><span class="line">b71f96345d44: Pull complete </span><br><span class="line">Digest: sha256:930490f97e5b921535c153e0e7110d251134cc4b72bbb8133c6a5065cc68580d</span><br><span class="line">Status: Downloaded newer image for busybox:latest</span><br><span class="line">/ # df -h  | grep /dev/shm</span><br><span class="line">shm                     124.0M         0    124.0M   0% /dev/shm</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="k8s-中的设置"><a href="#k8s-中的设置" class="headerlink" title="k8s 中的设置"></a>k8s 中的设置</h3><p>可以通过emptyDir挂在内存到容器的/dev/shm目录实现设置容器内的/dev/shm大小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ vim pods-shm.yml </span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: test-pd-shm</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - image: busybox</span><br><span class="line">    name: busybox-test</span><br><span class="line">    command: [ &quot;sleep&quot;, &quot;1000000&quot; ]</span><br><span class="line">    imagePullPolicy: &quot;IfNotPresent&quot;</span><br><span class="line">    volumeMounts:</span><br><span class="line">      - mountPath: /dev/shm</span><br><span class="line">        name: cache-volume</span><br><span class="line">  volumes:</span><br><span class="line">  - emptyDir:</span><br><span class="line">      medium: Memory</span><br><span class="line">      sizeLimit: 128Mi</span><br><span class="line">    name: cache-volume</span><br><span class="line">$ kubectl apply -f pods-shm.yml </span><br><span class="line">pod/test-pd-shm created</span><br><span class="line">$ kubectl exec -it test-pd-shm -- sh</span><br><span class="line">/ # df -h | grep /dev/shm</span><br><span class="line">tmpfs                    15.7G         0     15.7G   0% /dev/shm</span><br><span class="line">### 这里看到大小为15.7G,难道sizelimit没有生效?</span><br><span class="line">### 测试一下</span><br><span class="line">/dev/shm # dd if=/dev/zero of=test.dt bs=1M count=200</span><br><span class="line">200+0 records in</span><br><span class="line">200+0 records out</span><br><span class="line">209715200 bytes (200.0MB) copied, 0.099244 seconds, 2.0GB/s</span><br><span class="line">/dev/shm # df -h | grep /dev/shm</span><br><span class="line">tmpfs                    15.7G    200.0M     15.5G   1% /dev/shm</span><br><span class="line">/dev/shm # command terminated with exit code 137</span><br><span class="line">$ kubectl get pods </span><br><span class="line">NAME          READY   STATUS    RESTARTS   AGE</span><br><span class="line">test-pd-shm   0/1     Evicted   0          6m22s</span><br><span class="line">### 可以看到实际写入200m就会导致pod被驱散</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<hr>
]]></content>
      <categories>
        <category>DOCKER</category>
      </categories>
      <tags>
        <tag>DOCKER</tag>
      </tags>
  </entry>
  <entry>
    <title>rpm-build打包</title>
    <url>/2022/07/11/rpm-build%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>之前介绍yum是基于rpm的包管理工具，yum最终安装的是rpm包，那rpm包是如何来的呢？</p>
<p>按照网上的教程制作了个rpm包，这里记录下。</p>
<span id="more"></span>

<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>1）安装制作工具</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install rpm-build rpm-devel rpmdevtools</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2）生成开发目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpmdev-setuptree </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3）源代码<br>现在，我们来编码源代码，这里我们写个脚本，输出<code>Hello World!</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/rpmbuild/SOURCES/helloworld-1.0.0</span><br><span class="line">cd ~/rpmbuild/SOURCES/helloworld-1.0.0</span><br><span class="line">touch helloworld</span><br><span class="line">chmod 755 helloworld</span><br><span class="line">echo &#x27;#!/bin/sh&#x27; &gt;&gt; helloworld</span><br><span class="line">echo &#x27;echo Hello World!&#x27; &gt;&gt; helloworld</span><br><span class="line">cd ~/rpmbuild/SOURCES</span><br><span class="line">tar zcvf helloworld-1.0.0.tar.gz helloworld-1.0.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样我们就有了我们的源代码<code>helloworld-1.0.0.tar.gz</code></p>
<p>4)编写spec文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd  ~/rpmbuild/SPECS</span><br><span class="line"># 生成spec模版文件</span><br><span class="line">rpmdev-newspec helloworld.spec</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>将内容修改为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Name:           helloworld</span><br><span class="line">Version:        1.0.0</span><br><span class="line">Release:        1%&#123;?dist&#125;</span><br><span class="line">Summary:        helloworld</span><br><span class="line"></span><br><span class="line">Group:          Development/Tools</span><br><span class="line">License:        GPL</span><br><span class="line">#URL:            </span><br><span class="line">Source0:        %&#123;name&#125;-%&#123;version&#125;.tar.gz</span><br><span class="line"></span><br><span class="line">#BuildRequires:  </span><br><span class="line">#Requires:       </span><br><span class="line"></span><br><span class="line">%description</span><br><span class="line"></span><br><span class="line">%prep</span><br><span class="line">%setup -q</span><br><span class="line"></span><br><span class="line">%build</span><br><span class="line"></span><br><span class="line">%install</span><br><span class="line">mkdir -p $RPM_BUILD_ROOT/usr/bin</span><br><span class="line">cp $RPM_BUILD_DIR/%&#123;name&#125;-%&#123;version&#125;/helloworld $RPM_BUILD_ROOT/usr/bin/</span><br><span class="line"></span><br><span class="line">%clean</span><br><span class="line">rm -rf $RPM_BUILD_ROOT</span><br><span class="line"></span><br><span class="line">%files</span><br><span class="line">%defattr(-,root,root,-)</span><br><span class="line">%doc</span><br><span class="line">/usr/bin/helloworld</span><br><span class="line"></span><br><span class="line">%changelog</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>5)打包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpmbuild -ba SPECS/helloworld.spec</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看下最后的目录结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> tree ~/rpmbuild/</span><br><span class="line"> /root/rpmbuild/</span><br><span class="line">├── BUILD</span><br><span class="line">│   └── helloworld-1.0.0</span><br><span class="line">│       ├── debugfiles.list</span><br><span class="line">│       ├── debuglinks.list</span><br><span class="line">│       ├── debugsources.list</span><br><span class="line">│       ├── elfbins.list</span><br><span class="line">│       └── helloworld</span><br><span class="line">├── BUILDROOT</span><br><span class="line">├── RPMS</span><br><span class="line">│   └── x86_64</span><br><span class="line">│       ├── helloworld-1.0.0-1.el7.x86_64.rpm</span><br><span class="line">│       └── helloworld-debuginfo-1.0.0-1.el7.x86_64.rpm</span><br><span class="line">├── SOURCES</span><br><span class="line">│   ├── helloworld-1.0.0</span><br><span class="line">│   │   └── helloworld</span><br><span class="line">│   └── helloworld-1.0.0.tar.gz</span><br><span class="line">├── SPECS</span><br><span class="line">│   └── helloworld.spec</span><br><span class="line">└── SRPMS</span><br><span class="line">    └── helloworld-1.0.0-1.el7.src.rpm</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>BUILD是编译rpm包的临时目录<br>BUILDROOT是最后生成rpm包的临时安装目录<br>RPMS存放最终生成的rpm二进制包<br>SOURCES是源代码(.tar.gz)存放目录<br>SPECS用来存放spec文件<br>SRPMS存放最终生成的rpm源码包<br>rpmbuild/RPMS/x86_64/helloworld-1.0.0-1.el7.x86_64.rpm就是我们打出来的rpm包</p>
</blockquote>
<p>6)安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install ~/rpmbuild/RPMS/x86_64/helloworld-1.0.0-1.el7.x86_64.rpm </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpm -ivh helloworld-1.0.0-1.el7.x86_64.rpm </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>命令行运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">helloworld</span><br><span class="line">Hello World!</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>好啦，成功了!</p>
<h1 id="spec"><a href="#spec" class="headerlink" title="spec"></a>spec</h1><p>好了，回过头再看看打包的步骤，最重要的莫过于<code>helloworld.spec</code>了，我们来详细解释下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Name:           helloworld</span><br><span class="line">Version:        1.0.0</span><br><span class="line">Release:        1%&#123;?dist&#125;</span><br><span class="line">Summary:        helloworld</span><br><span class="line"></span><br><span class="line">Group:          Development/Tools</span><br><span class="line">License:        GPL</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>名称、版本号、打包版本号、简介、Group、License</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Source0:        %&#123;name&#125;-%&#123;version&#125;.tar.gz</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>源代码路径，要确保在SOURCES目录下能找到该包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#BuildRequires:  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编译需要的环境，如gcc&gt;=4.7，这里不需要</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#Requires:      </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该软件运行的依赖，如python rpm&gt;=0:4.1.1，这里不需要</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%description</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>详细描述</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%prep</span><br><span class="line">%setup -q</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编译前的准备操作在这儿,%setup macro 会把 source code tarball 解开并自动进到 %{name}-%{version} 的目录中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%build</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编译，对应源代码打包的./configure和make,例如(%configure –prefix=%{_prefix})</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%install</span><br><span class="line">mkdir -p $RPM_BUILD_ROOT/usr/bin</span><br><span class="line">cp $RPM_BUILD_DIR/%&#123;name&#125;-%&#123;version&#125;/helloworld $RPM_BUILD_ROOT/usr/bin/</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>安装，对应源代码包打包的make install，一般我们是安装在$RPM_BUILD_ROOT下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%files</span><br><span class="line">%defattr(-,root,root,-)</span><br><span class="line">%doc</span><br><span class="line">/usr/bin/helloworld</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>收集文件并创建二进制和源RPM文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%clean</span><br><span class="line">rm -rf $RPM_BUILD_ROOT</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>删除临时构建目录</p>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>rpm-build</tag>
      </tags>
  </entry>
  <entry>
    <title>x86架构下进行ARM镜像的构建与运行</title>
    <url>/2022/07/11/x86%E6%9E%B6%E6%9E%84%E4%B8%8B%E8%BF%9B%E8%A1%8CARM%E9%95%9C%E5%83%8F%E7%9A%84%E6%9E%84%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/</url>
    <content><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><blockquote>
<p>在ARM体系结构的硬件环境中安装Docker，然后构建并运行ARM的镜像自然非常简单，但是如果没有ARM环境，只有x86的机器又想做这件事情，这时QEMU也就有了用武之地。</p>
</blockquote>
<span id="more"></span>

<h2 id="问题再现"><a href="#问题再现" class="headerlink" title="问题再现"></a>问题再现</h2><h3 id="事前准备"><a href="#事前准备" class="headerlink" title="事前准备"></a>事前准备</h3><ul>
<li>  获取ARM格式的Alpine镜像</li>
</ul>
<blockquote>
<p>执行命令：docker pull arm64v8/alpine:3.12.1</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker images |grep arm64v8/alpine</span><br><span class="line">arm64v8/alpine                                                       3.12.1                          2e77e061c27f        6 days ago          5.32MB</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="启动容器并进入"><a href="#启动容器并进入" class="headerlink" title="启动容器并进入"></a>启动容器并进入</h3><ul>
<li>  启动容器并进入</li>
</ul>
<blockquote>
<p>执行命令：docker run –rm -it arm64v8/alpine:3.12.1 sh</p>
</blockquote>
<p>可以看到在x86的机器上执行时出现了如下错误信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ uname -m</span><br><span class="line">x86_64</span><br><span class="line">$ docker run --rm -it arm64v8/alpine:3.12.1 sh</span><br><span class="line">standard_init_linux.go:211: exec user process caused &quot;no such file or directory&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有的时候提示现象不同，其实主要原因就在于体系架构不同所导致的</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>可以根据需要到QEMU上下载对应的可执行文件进行执行，还有一种最为简单的方式就是使用容器的方式执行，使用如下命令，可使得当前机器可以直接直接模拟相应的体系结构</p>
<blockquote>
<p>执行命令：docker run –rm –privileged multiarch/qemu-user-static –reset –persistent yes</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run --rm --privileged multiarch/qemu-user-static --reset --persistent yes</span><br><span class="line">Setting /usr/bin/qemu-alpha-static as binfmt interpreter for alpha</span><br><span class="line">Setting /usr/bin/qemu-arm-static as binfmt interpreter for arm</span><br><span class="line">Setting /usr/bin/qemu-armeb-static as binfmt interpreter for armeb</span><br><span class="line">Setting /usr/bin/qemu-sparc-static as binfmt interpreter for sparc</span><br><span class="line">Setting /usr/bin/qemu-sparc32plus-static as binfmt interpreter for sparc32plus</span><br><span class="line">Setting /usr/bin/qemu-sparc64-static as binfmt interpreter for sparc64</span><br><span class="line">Setting /usr/bin/qemu-ppc-static as binfmt interpreter for ppc</span><br><span class="line">Setting /usr/bin/qemu-ppc64-static as binfmt interpreter for ppc64</span><br><span class="line">Setting /usr/bin/qemu-ppc64le-static as binfmt interpreter for ppc64le</span><br><span class="line">Setting /usr/bin/qemu-m68k-static as binfmt interpreter for m68k</span><br><span class="line">Setting /usr/bin/qemu-mips-static as binfmt interpreter for mips</span><br><span class="line">Setting /usr/bin/qemu-mipsel-static as binfmt interpreter for mipsel</span><br><span class="line">Setting /usr/bin/qemu-mipsn32-static as binfmt interpreter for mipsn32</span><br><span class="line">Setting /usr/bin/qemu-mipsn32el-static as binfmt interpreter for mipsn32el</span><br><span class="line">Setting /usr/bin/qemu-mips64-static as binfmt interpreter for mips64</span><br><span class="line">Setting /usr/bin/qemu-mips64el-static as binfmt interpreter for mips64el</span><br><span class="line">Setting /usr/bin/qemu-sh4-static as binfmt interpreter for sh4</span><br><span class="line">Setting /usr/bin/qemu-sh4eb-static as binfmt interpreter for sh4eb</span><br><span class="line">Setting /usr/bin/qemu-s390x-static as binfmt interpreter for s390x</span><br><span class="line">Setting /usr/bin/qemu-aarch64-static as binfmt interpreter for aarch64</span><br><span class="line">Setting /usr/bin/qemu-aarch64_be-static as binfmt interpreter for aarch64_be</span><br><span class="line">Setting /usr/bin/qemu-hppa-static as binfmt interpreter for hppa</span><br><span class="line">Setting /usr/bin/qemu-riscv32-static as binfmt interpreter for riscv32</span><br><span class="line">Setting /usr/bin/qemu-riscv64-static as binfmt interpreter for riscv64</span><br><span class="line">Setting /usr/bin/qemu-xtensa-static as binfmt interpreter for xtensa</span><br><span class="line">Setting /usr/bin/qemu-xtensaeb-static as binfmt interpreter for xtensaeb</span><br><span class="line">Setting /usr/bin/qemu-microblaze-static as binfmt interpreter for microblaze</span><br><span class="line">Setting /usr/bin/qemu-microblazeel-static as binfmt interpreter for microblazeel</span><br><span class="line">Setting /usr/bin/qemu-or1k-static as binfmt interpreter for or1k</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="结果确认"><a href="#结果确认" class="headerlink" title="结果确认"></a>结果确认</h2><p>然后再次使用同样命令即可发现可进入ARM格式的容器中，使用uname命令也可以确认到其体系结构为ARM格式（aarch64）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker run --rm -it arm64v8/alpine:3.12.1 sh</span><br><span class="line">/ # uname -m</span><br><span class="line">aarch64</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="构建ARM镜像并确认"><a href="#构建ARM镜像并确认" class="headerlink" title="构建ARM镜像并确认"></a>构建ARM镜像并确认</h2><ul>
<li>构建ARM镜像<br>  使用如下Dockerfile构建ARM镜像</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ cat Dockerfile </span><br><span class="line">FROM arm64v8/alpine:3.12.1</span><br><span class="line">RUN set -x \</span><br><span class="line">    &amp;&amp; sed -i &#x27;s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/&#x27; /etc/apk/repositories \</span><br><span class="line">    &amp;&amp; echo &#x27;http://mirrors.aliyun.com/alpine/edge/testing&#x27; &gt;&gt; /etc/apk/repositories \</span><br><span class="line">    &amp;&amp; apk update \</span><br><span class="line">    &amp;&amp; addgroup -g 101 -S nginx \</span><br><span class="line">    &amp;&amp; adduser -S -D -H -u 101 -h /var/cache/nginx -s /sbin/nologin -G nginx -g nginx nginx \</span><br><span class="line">    &amp;&amp; apk add --no-cache --allow-untrusted tzdata \</span><br><span class="line">    &amp;&amp; ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \</span><br><span class="line">    &amp;&amp; echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone \</span><br><span class="line">    &amp;&amp; /bin/rm -rf /tmp/* /var/cache/apk/*</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用docker build在x86机器上构建此ARM镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker build -t myarmimage .</span><br><span class="line">Sending build context to Docker daemon   2.56kB</span><br><span class="line">Step 1/2 : FROM arm64v8/alpine:3.12.1</span><br><span class="line"> ---&gt; 2e77e061c27f</span><br><span class="line">Step 2/2 : RUN set -x     &amp;&amp; sed -i &#x27;s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/&#x27; /etc/apk/repositories     &amp;&amp; echo &#x27;http://mirrors.aliyun.com/alpine/edge/testing&#x27; &gt;&gt; /etc/apk/repositories     &amp;&amp; apk update     &amp;&amp; addgroup -g 101 -S nginx     &amp;&amp; adduser -S -D -H -u 101 -h /var/cache/nginx -s /sbin/nologin -G nginx -g nginx nginx     &amp;&amp; apk add --no-cache --allow-untrusted tzdata     &amp;&amp; ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime     &amp;&amp; echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone     &amp;&amp; /bin/rm -rf /tmp/* /var/cache/apk/*</span><br><span class="line"> ---&gt; Running in ffb20ef332b9</span><br><span class="line">+ sed -i s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/ /etc/apk/repositories</span><br><span class="line">+ echo http://mirrors.aliyun.com/alpine/edge/testing</span><br><span class="line">+ apk update</span><br><span class="line">fetch http://mirrors.aliyun.com/alpine/v3.12/main/aarch64/APKINDEX.tar.gz</span><br><span class="line">fetch http://mirrors.aliyun.com/alpine/v3.12/community/aarch64/APKINDEX.tar.gz</span><br><span class="line">fetch http://mirrors.aliyun.com/alpine/edge/testing/aarch64/APKINDEX.tar.gz</span><br><span class="line">v3.12.1-8-ge053f6efb7 [http://mirrors.aliyun.com/alpine/v3.12/main]</span><br><span class="line">v3.12.1-5-g0954f48dc3 [http://mirrors.aliyun.com/alpine/v3.12/community]</span><br><span class="line">v20200917-2860-gaeb4459434 [http://mirrors.aliyun.com/alpine/edge/testing]</span><br><span class="line">OK: 16530 distinct packages available</span><br><span class="line">+ addgroup -g 101 -S nginx</span><br><span class="line">+ adduser -S -D -H -u 101 -h /var/cache/nginx -s /sbin/nologin -G nginx -g nginx nginx</span><br><span class="line">+ apk add --no-cache --allow-untrusted tzdata</span><br><span class="line">fetch http://mirrors.aliyun.com/alpine/v3.12/main/aarch64/APKINDEX.tar.gz</span><br><span class="line">fetch http://mirrors.aliyun.com/alpine/v3.12/community/aarch64/APKINDEX.tar.gz</span><br><span class="line">fetch http://mirrors.aliyun.com/alpine/edge/testing/aarch64/APKINDEX.tar.gz</span><br><span class="line">(1/1) Installing tzdata (2020c-r0)</span><br><span class="line">Executing busybox-1.31.1-r19.trigger</span><br><span class="line">OK: 9 MiB in 15 packages</span><br><span class="line">+ ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">+ echo Asia/Shanghai</span><br><span class="line">+ /bin/rm -rf &#x27;/tmp/*&#x27; /var/cache/apk/APKINDEX.3a1aa0e6.tar.gz /var/cache/apk/APKINDEX.792faddc.tar.gz /var/cache/apk/APKINDEX.f46ee61c.tar.gz</span><br><span class="line">Removing intermediate container ffb20ef332b9</span><br><span class="line"> ---&gt; 181684f5ebfc</span><br><span class="line">Successfully built 181684f5ebfc</span><br><span class="line">Successfully tagged myarmimage:latest</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  在x86机器上运行ARM格式的镜像并确认结果</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ docker images |grep myarmimage</span><br><span class="line">myarmimage                                                           latest                          181684f5ebfc        9 seconds ago       6.12MB</span><br><span class="line">$ docker run --rm -it myarmimage sh</span><br><span class="line">/ # uname -a</span><br><span class="line">Linux 2bcff8eaae37 4.9.184-linuxkit #1 SMP Tue Jul 2 22:58:16 UTC 2019 aarch64 Linux</span><br><span class="line">/ # uname -m</span><br><span class="line">aarch64</span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>DOCKER</category>
      </categories>
      <tags>
        <tag>DOCKER</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu22.04安装Docker</title>
    <url>/2022/07/10/Ubuntu22-04%E5%AE%89%E8%A3%85Docker/</url>
    <content><![CDATA[<h3 id="Docker-依赖项"><a href="#Docker-依赖项" class="headerlink" title="Docker 依赖项"></a>Docker 依赖项</h3><p>为了安装并配置 Docker ，你的系统必须满足下列最低要求：</p>
<ol>
<li> 64 位 Linux 或 Windows 系统</li>
<li> 如果使用 Linux ，内核版本必须不低于 3.10</li>
<li> 能够使用<code>sudo</code> 权限的用户</li>
<li> 在你系统 BIOS 上启用了 VT（虚拟化技术）支持 on your system BIOS（参考:<a href="https://ostechnix.com/how-to-find-if-a-cpu-supports-virtualization-technology-vt/">如何查看 CPU 支持 虚拟化技术（VT）</a>）</li>
<li> 你的系统应该联网<span id="more"></span></li>
</ol>
<p>在 Linux ，在终端上运行以下命令验证内核以及架构详细信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ uname -a</span><br></pre></td></tr></table></figure>

<p>输出样例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Linux Ubuntu22CT 5.15.35-3-pve #1 SMP PVE 5.15.35-6 (Fri, 17 Jun 2022 13:42:35 +0200) x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure>

<p>正如上面你看到的那样，我的 Ubuntu 系统内核版本是 <strong>5.15.35-3-pve</strong> 并且系统架构是 <strong>64 位</strong>（<strong>x86_64 x86_64 x86_64 GNU/Linux</strong>）。</p>
<blockquote>
<p><strong>注意：</strong> 这里，我在 <a href="https://ostechnix.com/install-proxmox-ve/">Proxmox</a> 中使用 Ubuntu 22.04 容器。这是你看到上方内核版本中有 “pve” 字符的原因。如果你正在使用 Ubuntu 实体（或者虚拟）机，你将看到系统版本为 <strong>5.15.35-3-generic</strong> 。</p>
</blockquote>
<p>内核版本需要不低于最低要求的版本，并且是 64 位机器。这样不会有任何问题，我们能顺利安装并使用 Docker 。</p>
<p>请注意你使用哪一个 Ubuntu 系统不重要。并且你使用 Ubuntu 桌面或服务器版本，亦或者其他 Ubuntu 变种如 Lubuntu 、Kubuntu 、Xubuntu ，都不重要。</p>
<p>只要你的系统内核版本不低于 3.10 ，并且是 64 位系统，Docker 都会正常运行。</p>
<h3 id="在-Ubuntu-22-04-LTS-中安装-Docker"><a href="#在-Ubuntu-22-04-LTS-中安装-Docker" class="headerlink" title="在 Ubuntu 22.04 LTS 中安装 Docker"></a>在 Ubuntu 22.04 LTS 中安装 Docker</h3><p>首先，更新你的 Ubuntu 系统。</p>
<h4 id="1、更新-Ubuntu"><a href="#1、更新-Ubuntu" class="headerlink" title="1、更新 Ubuntu"></a>1、更新 Ubuntu</h4><p>打开终端，依次运行下列命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt update</span><br><span class="line">$ sudo apt upgrade</span><br><span class="line">$ sudo apt full-upgrade</span><br></pre></td></tr></table></figure>

<h4 id="2、添加-Docker-库"><a href="#2、添加-Docker-库" class="headerlink" title="2、添加 Docker 库"></a>2、添加 Docker 库</h4><p>首先，安装必要的证书并允许 apt 包管理器使用以下命令通过 HTTPS 使用存储库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt install apt-transport-https ca-certificates curl software-properties-common gnupg lsb-release</span><br></pre></td></tr></table></figure>

<p>然后，运行下列命令添加 Docker 的官方 GPG 密钥：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br></pre></td></tr></table></figure>

<p>添加 Docker 官方库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo &quot;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></pre></td></tr></table></figure>

<p>使用命令更新 Ubuntu 源列表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt update</span><br></pre></td></tr></table></figure>

<h4 id="3、安装-Docker"><a href="#3、安装-Docker" class="headerlink" title="3、安装 Docker"></a>3、安装 Docker</h4><p>最后，运行下列命令在 Ubuntu 22.04 LTS 服务器中安装最新 Docker CE：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure>

<p>当然你也可以安装其他版本 Docker 。运行下列命令检查可以安装的 Docker 版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ apt-cache madison docker-ce</span><br></pre></td></tr></table></figure>

<p>输出样例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-ce | 5:20.10.17~3-0~ubuntu-jammy | https://download.docker.com/linux/ubuntu jammy/stable amd64 Packages</span><br><span class="line">docker-ce | 5:20.10.16~3-0~ubuntu-jammy | https://download.docker.com/linux/ubuntu jammy/stable amd64 Packages</span><br><span class="line">docker-ce | 5:20.10.15~3-0~ubuntu-jammy | https://download.docker.com/linux/ubuntu jammy/stable amd64 Packages</span><br><span class="line">docker-ce | 5:20.10.14~3-0~ubuntu-jammy | https://download.docker.com/linux/ubuntu jammy/stable amd64 Packages</span><br><span class="line">docker-ce | 5:20.10.13~3-0~ubuntu-jammy | https://download.docker.com/linux/ubuntu jammy/stable amd64 Packages</span><br></pre></td></tr></table></figure>

<p>你可以挑选上面列表中的任何版本进行安装。例如，安装 <strong>5:20.10.16~ 3-0 ~ubuntu-jammy</strong> 这个版本，运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt install docker-ce=5:20.10.16~3-0~ubuntu-jammy docker-ce-cli=5:20.10.16~3-0~ubuntu-jammy containerd.io</span><br></pre></td></tr></table></figure>

<p>安装完成后，运行如下命令验证 Docker 服务是否在运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ systemctl status docker</span><br></pre></td></tr></table></figure>

<p>你会看到类似下面的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* docker.service - Docker Application Container Engine</span><br><span class="line">         Loaded: loaded (/lib/systemd/system/docker.service; enabled; vendor preset: enabled)</span><br><span class="line">         Active: active (running) since Mon 2022-06-27 13:07:43 UTC; 3min 4s ago</span><br><span class="line">    TriggeredBy: * docker.socket</span><br><span class="line">           Docs: https://docs.docker.com</span><br><span class="line">       Main PID: 2208 (dockerd)</span><br><span class="line">          Tasks: 8</span><br><span class="line">         Memory: 29.6M</span><br><span class="line">            CPU: 126ms</span><br><span class="line">         CGroup: /system.slice/docker.service</span><br><span class="line">                 `-2208 /usr/bin/dockerd -H fd:// --cnotallow=/run/containerd/containerd.sock</span><br><span class="line">    Jun 27 13:07:43 Ubuntu22CT dockerd[2208]: time=&quot;2022-06-27T13:07:43.071453522Z&quot; level=info msg=&quot;ccResolverWrapper: sending update to cc: &#123;[&#123;unix:&gt;</span><br><span class="line">    Jun 27 13:07:43 Ubuntu22CT dockerd[2208]: time=&quot;2022-06-27T13:07:43.071459974Z&quot; level=info msg=&quot;ClientConn switching balancer to \&quot;pick_first\&quot;&quot; &gt;</span><br><span class="line">    Jun 27 13:07:43 Ubuntu22CT dockerd[2208]: time=&quot;2022-06-27T13:07:43.130989294Z&quot; level=info msg=&quot;Loading containers: start.&quot;</span><br><span class="line">    Jun 27 13:07:43 Ubuntu22CT dockerd[2208]: time=&quot;2022-06-27T13:07:43.187439756Z&quot; level=info msg=&quot;Default bridge (docker0) is assigned with an IP a&gt;</span><br><span class="line">    Jun 27 13:07:43 Ubuntu22CT dockerd[2208]: time=&quot;2022-06-27T13:07:43.235966874Z&quot; level=info msg=&quot;Loading containers: done.&quot;</span><br><span class="line">    Jun 27 13:07:43 Ubuntu22CT dockerd[2208]: time=&quot;2022-06-27T13:07:43.240149866Z&quot; level=warning msg=&quot;Not using native diff for overlay2, this may c&gt;</span><br><span class="line">    Jun 27 13:07:43 Ubuntu22CT dockerd[2208]: time=&quot;2022-06-27T13:07:43.240281966Z&quot; level=info msg=&quot;Docker daemon&quot; commit=a89b842 graphdriver(s)=over&gt;</span><br><span class="line">    Jun 27 13:07:43 Ubuntu22CT dockerd[2208]: time=&quot;2022-06-27T13:07:43.240386856Z&quot; level=info msg=&quot;Daemon has completed initialization&quot;</span><br><span class="line">    Jun 27 13:07:43 Ubuntu22CT systemd[1]: Started Docker Application Container Engine.</span><br><span class="line">    Jun 27 13:07:43 Ubuntu22CT dockerd[2208]: time=&quot;2022-06-27T13:07:43.276336600Z&quot; level=info msg=&quot;API listen on /run/docker.sock&quot;</span><br></pre></td></tr></table></figure>

<p>好极了！Docker 服务已启动并运行！</p>
<p>如果没有运行，运行以下命令运行 Docker 服务：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure>

<p>使 Docker 服务在每次重启时自动启动：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo systemctl enable docker</span><br></pre></td></tr></table></figure>

<p>可以使用以下命令查看已安装的 Docker 版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo docker version</span><br></pre></td></tr></table></figure>

<p>输出样例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Client: Docker Engine - Community</span><br><span class="line">      Version:           20.10.17</span><br><span class="line">      API version:       1.41</span><br><span class="line">      Go version:        go1.17.11</span><br><span class="line">      Git commit:        100c701</span><br><span class="line">      Built:             Mon Jun  6 23:02:46 2022</span><br><span class="line">      OS/Arch:           linux/amd64</span><br><span class="line">      Context:           default</span><br><span class="line">      Experimental:      true</span><br><span class="line">    Server: Docker Engine - Community</span><br><span class="line">      Engine:</span><br><span class="line">        Version:          20.10.17</span><br><span class="line">        API version:      1.41 (minimum version 1.12)</span><br><span class="line">        Go version:       go1.17.11</span><br><span class="line">        Git commit:       a89b842</span><br><span class="line">      Built:            Mon Jun  6 23:00:51 2022</span><br><span class="line">        OS/Arch:          linux/amd64</span><br><span class="line">        Experimental:     false</span><br><span class="line">      containerd:</span><br><span class="line">        Version:          1.6.6</span><br><span class="line">        GitCommit:        10c12954828e7c7c9b6e0ea9b0c02b01407d3ae1</span><br><span class="line">      runc:</span><br><span class="line">        Version:          1.1.2</span><br><span class="line">        GitCommit:        v1.1.2-0-ga916309</span><br><span class="line">      docker-init:</span><br><span class="line">        Version:          0.19.0</span><br><span class="line">        GitCommit:        de40ad0</span><br></pre></td></tr></table></figure>

<h4 id="4、测试-Docker"><a href="#4、测试-Docker" class="headerlink" title="4、测试 Docker"></a>4、测试 Docker</h4><p>让我们继续，测试 Docker 是否运行正常：</p>
<p>运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure>

<p>上述命令会下载一个 Docker 测试镜像，并在容器内执行一个 “hello_world” 样例程序。</p>
<p>如果你看到类似下方的输出，那么祝贺你！Docker 正常运行在你的 Ubuntu 系统中了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Unable to find image &#x27;hello-world:latest&#x27; locally</span><br><span class="line">    latest: Pulling from library/hello-world</span><br><span class="line">    2db29710123e: Pull complete </span><br><span class="line">    Digest: sha256:13e367d31ae85359f42d637adf6da428f76d75dc9afeb3c21faea0d976f5c651</span><br><span class="line">    Status: Downloaded newer image for hello-world:latest</span><br><span class="line">    Hello from Docker!</span><br><span class="line">    This message shows that your installation appears to be working correctly.</span><br><span class="line">    To generate this message, Docker took the following steps:</span><br><span class="line">     1. The Docker client contacted the Docker daemon.</span><br><span class="line">     2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class="line">        (amd64)</span><br><span class="line">     3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">        executable that produces the output you are currently reading.</span><br><span class="line">     4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">        to your terminal.</span><br><span class="line">    To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line">     $ docker run -it ubuntu bash</span><br><span class="line">    Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line">     https://hub.docker.com/</span><br><span class="line">    For more examples and ideas, visit:</span><br><span class="line">     https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure>

<p>很好！可以使用 Docker 了。</p>
<h4 id="5、作为非-root-用户运行-Docker-（选做）"><a href="#5、作为非-root-用户运行-Docker-（选做）" class="headerlink" title="5、作为非 root 用户运行 Docker （选做）"></a>5、作为非 root 用户运行 Docker （选做）</h4><p>默认情况下，Docker 守护进程绑定到 Unix 套接字而不是 TCP 端口。由于 <strong>Unix 套接字由 root 用户拥有</strong>，Docker 守护程序将仅以 root 用户身份运行。因此，普通用户无法执行大多数 Docker 命令。</p>
<p>如果你想要在 Linux 中作为非 root 用户运行 Docker ，参考下方链接：</p>
<ul>
<li>  <a href="https://ostechnix.com/how-to-run-docker-as-non-root-user-in-linux/">如何在 Linux 中作为非 root 用户运行 Docker</a></li>
</ul>
<p>我个人不这样做也<strong>不推荐</strong>你这么做。如果你不会在互联网上暴露你的系统，那没问题。然而，不要在生产系统中以非 root 用户身份运行 Docker 。</p>
]]></content>
      <categories>
        <category>DOCKER</category>
      </categories>
      <tags>
        <tag>DOCKER</tag>
      </tags>
  </entry>
  <entry>
    <title>pkg-config</title>
    <url>/2022/07/09/pkg-config/</url>
    <content><![CDATA[<h2 id="pkg-config简介"><a href="#pkg-config简介" class="headerlink" title="pkg-config简介"></a>pkg-config简介</h2><p><code>pkg-config</code>在编译应用程序和库的时候作为一个工具来使用。例如你在命令行通过如下命令编译程序时：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># gcc -o test test.c `pkg-config --libs --cflags glib-2.0`</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>pkg-config可以帮助你插入正确的编译选项，而不需要你通过硬编码的方式来找到glib(或其他库）。</p>
<p><code>--cflags</code>一般用于指定头文件，<code>--libs</code>一般用于指定库文件。</p>
<p>大家应该都知道一般用第三方库的时候，就少不了要使用到第三方的头文件和库文件。我们在编译、链接的时候，必须要指定这些头文件和库文件的位置。对于一个比较大的第三方库，其头文件和库文件的数量是比较多的，如果我们一个个手动地写，那将是相当的麻烦的。因此，pkg-config就应运而生了。pkg-config能够把这些头文件和库文件的位置指出来，给编译器使用。pkg-config主要提供了下面几个功能：</p>
<ul>
<li>  检查库的版本号。 如果所需要的库的版本不满足要求，它会打印出错误信息，避免链接错误版本的库文件</li>
<li>  获得编译预处理参数，如宏定义、头文件的位置</li>
<li>  获得链接参数，如库及依赖的其他库的位置，文件名及其他一些链接参数</li>
<li>  自动加入所依赖的其他库的设置</li>
</ul>
<p>pkg-config命令的基本用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># pkg-config &lt;options&gt; &lt;library-name&gt;</span><br></pre></td></tr></table></figure>

<p>例如，我们可以通过如下命令来查看当前安装了哪些库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost pkgconfig]# pkg-config --list-all</span><br><span class="line">zlib                      zlib - zlib compression library</span><br><span class="line">gio-unix-2.0              GIO unix specific APIs - unix specific headers for glib I/O library</span><br><span class="line">inputproto                InputProto - Input extension headers</span><br><span class="line">cairo-xcb                 cairo-xcb - XCB surface backend for cairo graphics library</span><br><span class="line">gio-2.0                   GIO - glib I/O library</span><br><span class="line">//后续省略</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>事实上，pkg-config只是一个工具，所以不是你安装了一个第三方库，pkg-config就能知道第三方库的头文件和库文件的位置的。为了让pkg-config可以得到一个库的信息，就要求库的提供者提供一个.pc文件。默认情况下，比如执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># pkg-config --libs --cflags glib-2.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>pkg-config会到<code>/usr/lib/pkconfig/</code>目录下去寻找glib-2.0.pc文件。也就是说在此目录下的.pc文件，pkg-config是可以自动找到的。然而假如我们安装了一个库，其生成的.pc文件并不在这个默认目录中的话，pkg-config就找不到了。此时我们需要通过<code>PKG_CONFIG_PATH</code>环境变量来指定pkg-config还应该在哪些地方去寻找.pc文件。</p>
<p>我们可以通过如下命令来设置<code>PKG_CONFIG_PATH</code>环境变量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig/</span><br></pre></td></tr></table></figure>

<p>这样pkg-config就会在/usr/local/lib/pkgconfig/目录下寻找.pc文件了。我们在文章开头提到的找不到Leptonica 1.74.4的原因也正是因为其找不到lept.pc，因此我们只需要将对应的目录设置到PKG_CONFIG_PATH环境变量中即可。</p>
<p>另外还需要注意的是,上述环境变量的设置只对当前的终端窗口有效。为了让其永久生效，我们可以将上述命令写入到/etc/bash.bashrc等文件中，以方便后续使用。</p>
<h2 id="pkg-config与LD-LIBRARY-PATH"><a href="#pkg-config与LD-LIBRARY-PATH" class="headerlink" title="pkg-config与LD_LIBRARY_PATH"></a>pkg-config与LD_LIBRARY_PATH</h2><p>pkg-config与LD_LIBRARY_PATH在使用时有些类似，都可以帮助找到对应的库（静态库和共享库）。这里我们重点介绍一下它们两者的区别。我们知道一个程序从源代码，然后编译连接，最后再执行这一基本过程。这里我们列出pkg-config与LD_LIBRARY_PATH的主要工作阶段：</p>
<ul>
<li>  pkg-config: 编译时、 链接时</li>
<li>  LD_LIBRARY_PATH: 链接时、 运行时</li>
</ul>
<p>pkg-config主要是在编译时会用到其来查找对应的头文件、链接库等；而LD_LIBRARY_PATH环境变量则在 链接时 和 运行时 会用到。程序编译出来之后，在程序加载执行时也会通过LD_LIBRARY_PATH环境变量来查询所需要的库文件。</p>
<p>下面我们来讲述一下LD_LIBRARY_PATH及ldconfig命令：</p>
<p>库文件在链接（静态库和共享库）和运行（仅限于使用共享库的程序）时被使用，其搜索路径是在系统中进行设置的。一般Linux系统把/lib和/usr/lib这两个目录作为默认的库搜索路径，所以使用这两个目录中的库时不需要进行设置搜索路径即可直接使用。对于处于默认库搜索路径之外的库，需要将库的位置添加到库的搜索路径之中。设置库文件的搜索路径有下列两种方式，可任选其中一种使用：</p>
<ul>
<li>  在环境变量LD_LIBRARY_PATH中指明库的搜索路径</li>
<li>  在/etc/ld.so.conf文件中添加库的搜索路径</li>
</ul>
<p>将自己可能存放库文件的路径都加入到/etc/ld.so.conf中是明智的选择。添加方法也及其简单，将库文件的绝对路径直接写进去就OK了，一行一个。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/X11R6/lib</span><br><span class="line">/usr/local/lib</span><br><span class="line">/opt/lib</span><br></pre></td></tr></table></figure>

<p>需要注意的是：第二种搜索路径的设置方式对于程序链接时的库（包括共享库和静态库）的定位已经足够了。但是对于使用了共享库的程序的执行还是不够的，这是因为为了加快程序执行时对共享库的定位速度，避免使用搜索路径查找共享库的低效率，所以是直接读取库列表文件/etc/ld.so.cache的方式从中进行搜索。/etc/ld.so.cache是一个非文本的数据文件，不能直接编辑，它是根据/etc/ld.so.conf中设置的搜索路径由/sbin/ldconfig命令将这些搜索路径下的共享库文件集中在一起而生成的（ldconfig命令要以root权限执行）。因此为了保证程序执行时对库的定位，在/etc/ld.so.conf中进行了库搜索路径的设置之后，还必须要运行/sbin/ldconfig命令更新/etc/ld.so.cache文件之后才可以。</p>
<p>ldconfig，简单的说，它的作用就是将/etc/ld.so.conf列出的路径下的库文件缓存到/etc/ld.so.cache以供使用。因此当安装完一些库文件（例如刚安装好glib)，或者修改ld.so.conf增加新的库路径之后，需要运行一下/sbin/ldconfig使所有的库文件都被缓存到ld.so.cache中。如果没有这样做，即使库文件明明就在/usr/lib下的，也是不会被使用的，结果在编译过程中报错。</p>
<p>在程序链接时，对于库文件（静态库和共享库）的搜索路径，除了上面的设置方式之外，还可以通过-L参数显示指定。因为用-L设置的路径将被优先搜索，所以在链接的时候通常都会以这种方式直接指定要链接的库的路径。</p>
<p>前面已经说明过了，库搜索路径的设置有两种方式：在环境变量 LD_LIBRARY_PATH 中设置以及在 /etc/ld.so.conf 文件中设置。其中，第二种设置方式需要 root 权限，以改变 /etc/ld.so.conf 文件并执行 /sbin/ldconfig 命令。而且，当系统重新启动后，所有的基于 GTK2 的程序在运行时都将使用新安装的 GTK+ 库。不幸的是，由于 GTK+ 版本的改变，这有时会给应用程序带来兼容性的问题，造成某些程序运行不正常。为了避免出现上面的这些情况，在 GTK+ 及其依赖库的安装过程中对于库的搜索路径的设置将采用第一种方式进行。这种设置方式不需要 root 权限，设置也简单：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># export LD_LIBRARY_PATH=/opt/gtk/lib:$LD_LIBRARY_PATH</span><br><span class="line"></span><br><span class="line"># echo $LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure>

<h2 id="pc文件书写规范"><a href="#pc文件书写规范" class="headerlink" title="pc文件书写规范"></a>pc文件书写规范</h2><p>这里我们首先来看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost pkgconfig]# cat libevent.pc </span><br><span class="line">#libevent pkg-config source file</span><br><span class="line"></span><br><span class="line">prefix=/usr/local</span><br><span class="line">exec_prefix=$&#123;prefix&#125;</span><br><span class="line">libdir=$&#123;exec_prefix&#125;/lib</span><br><span class="line">includedir=$&#123;prefix&#125;/include</span><br><span class="line"></span><br><span class="line">Name: libevent</span><br><span class="line">Description: libevent is an asynchronous notification event loop library</span><br><span class="line">Version: 2.0.22-stable</span><br><span class="line">Requires:</span><br><span class="line">Conflicts:</span><br><span class="line">Libs: -L$&#123;libdir&#125; -levent</span><br><span class="line">Libs.private: </span><br><span class="line">Cflags: -I$&#123;includedir&#125;</span><br></pre></td></tr></table></figure>

<p>这是libevent库的一个真实的例子。下面我们简单描述一下pc文件中的用到的一些关键词：</p>
<ul>
<li>  Name: 一个针对library或package的便于人阅读的名称。这个名称可以是任意的，它并不会影响到pkg-config的使用，pkg-config是采用pc文件名的方式来工作的。</li>
<li>  Description: 对package的简短描述</li>
<li>  URL: 人们可以通过该URL地址来获取package的更多信息或者package的下载地址</li>
<li>  Version: 指定package版本号的字符串</li>
<li>  Requires: 本库所依赖的其他库文件。所依赖的库文件的版本号可以通过使用如下比较操作符指定：=,&lt;,&gt;,&lt;=,&gt;=</li>
<li>  Requires.private: 本库所依赖的一些私有库文件，但是这些私有库文件并不需要暴露给应用程序。这些私有库文件的版本指定方式与Requires中描述的类似。</li>
<li>  Conflicts: 是一个可选字段，其主要用于描述与本package所冲突的其他package。版本号的描述也与Requires中的描述类似。本字段也可以取值为同一个package的多个不同版本实例。例如: Conflicts: bar &lt; 1.2.3, bar &gt;= 1.3.0</li>
<li>  Cflags: 编译器编译本package时所指定的编译选项，和其他并不支持pkg-config的library的一些编译选项值。假如所需要的library支持pkg-config,则它们应该被添加到Requires或者Requires.private中</li>
<li>  Libs: 链接本库时所需要的一些链接选项，和其他一些并不支持pkg-config的library的链接选项值。与Cflags类似</li>
<li>  Libs.private: 本库所需要的一些私有库的链接选项。</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>如下我们给出一个使用pkg-config的程序例子(test_event.cpp)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;  </span><br><span class="line">#include &lt;event.h&gt;  </span><br><span class="line">#include &lt;sys/socket.h&gt;  </span><br><span class="line">#include &lt;sys/types.h&gt;  </span><br><span class="line">#include &lt;netinet/in.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;fcntl.h&gt;  </span><br><span class="line">  </span><br><span class="line">using namespace std;  </span><br><span class="line">  </span><br><span class="line">struct event_base* main_base;  </span><br><span class="line">  </span><br><span class="line">static const char MESSAGE[] =&quot;Hello, World!\n&quot;;  </span><br><span class="line">  </span><br><span class="line">void accept_handle(const int sfd, const short event, void *arg)  </span><br><span class="line">&#123;  </span><br><span class="line">    cout&lt;&lt;&quot;accept handle&quot;&lt;&lt;endl;  </span><br><span class="line">  </span><br><span class="line">    struct sockaddr_in addr;  </span><br><span class="line">  </span><br><span class="line">    socklen_t addrlen = sizeof(addr);  </span><br><span class="line">  </span><br><span class="line">    int fd = accept(sfd, (struct sockaddr *) &amp;addr, &amp;addrlen); //处理连接  </span><br><span class="line">  </span><br><span class="line">    struct bufferevent* buf_ev;  </span><br><span class="line">    buf_ev = bufferevent_new(fd, NULL, NULL, NULL, NULL);  </span><br><span class="line">  </span><br><span class="line">    buf_ev-&gt;wm_read.high = 4096;  </span><br><span class="line">  </span><br><span class="line">    cout&lt;&lt;&quot;event write&quot;&lt;&lt;endl;  </span><br><span class="line">    bufferevent_write(buf_ev, MESSAGE, strlen(MESSAGE));  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">    cout&lt;&lt;&quot;hello man!&quot;&lt;&lt;endl;  </span><br><span class="line">  </span><br><span class="line">    // 1. 初始化EVENT  </span><br><span class="line">    main_base = event_init();  </span><br><span class="line">    if(main_base)  </span><br><span class="line">        cout&lt;&lt;&quot;init event ok!&quot;&lt;&lt;endl;  </span><br><span class="line">  </span><br><span class="line">    // 2. 初始化SOCKET  </span><br><span class="line">    int sListen;  </span><br><span class="line">  </span><br><span class="line">    // Create listening socket  </span><br><span class="line">    sListen = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);  </span><br><span class="line">  </span><br><span class="line">    // Bind  </span><br><span class="line">    struct sockaddr_in server_addr;  </span><br><span class="line">    bzero(&amp;server_addr,sizeof(struct sockaddr_in));  </span><br><span class="line">    server_addr.sin_family=AF_INET;  </span><br><span class="line">    server_addr.sin_addr.s_addr=htonl(INADDR_ANY);  </span><br><span class="line">    int portnumber = 8080;  </span><br><span class="line">    server_addr.sin_port = htons(portnumber);  </span><br><span class="line">  </span><br><span class="line">    /* 捆绑sockfd描述符  */  </span><br><span class="line">    if(bind(sListen,(struct sockaddr *)(&amp;server_addr),sizeof(struct sockaddr))==-1)  </span><br><span class="line">    &#123;  </span><br><span class="line">        cout&lt;&lt;&quot;error!&quot;&lt;&lt;endl;  </span><br><span class="line">        return -1;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    // Listen  </span><br><span class="line">    ::listen(sListen, 3);  </span><br><span class="line">    cout&lt;&lt;&quot;Server is listening!\n&quot;&lt;&lt;endl;  </span><br><span class="line">  </span><br><span class="line">    /*将描述符设置为非阻塞*/  </span><br><span class="line">    int flags = ::fcntl(sListen, F_GETFL);  </span><br><span class="line">  </span><br><span class="line">    flags |= O_NONBLOCK;  </span><br><span class="line">  </span><br><span class="line">    fcntl(sListen, F_SETFL, flags);  </span><br><span class="line">  </span><br><span class="line">    // 3. 创建EVENT 事件  </span><br><span class="line">    struct event ev;  </span><br><span class="line">    event_set(&amp;ev, sListen, EV_READ | EV_PERSIST, accept_handle, (void *)&amp;ev);  </span><br><span class="line">  </span><br><span class="line">    // 4. 事件添加与删除  </span><br><span class="line">    event_add(&amp;ev, NULL);  </span><br><span class="line">  </span><br><span class="line">    // 5. 进入事件循环  </span><br><span class="line">    event_base_loop(main_base, 0);  </span><br><span class="line">  </span><br><span class="line">    cout&lt;&lt;&quot;over!&quot;&lt;&lt;endl;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行如下命令编译程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># gcc -o test_event test_event.cpp -lstdc++ `pkg-config --cflags --libs libevent`</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost test-src]# ./test_event </span><br><span class="line">hello man!</span><br><span class="line">init event ok!</span><br><span class="line">Server is listening!</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>开启另外一个终端，采用nc命令连接test_event服务端程序：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# nc 127.0.0.1 8080</span><br><span class="line">Hello, World!</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到运行成功。</p>
<h2 id="Linux下链接库的路径顺序"><a href="#Linux下链接库的路径顺序" class="headerlink" title="Linux下链接库的路径顺序"></a>Linux下链接库的路径顺序</h2><h3 id="6-1-运行时链接库的搜索顺序"><a href="#6-1-运行时链接库的搜索顺序" class="headerlink" title="6.1 运行时链接库的搜索顺序"></a>6.1 运行时链接库的搜索顺序</h3><p>Linux程序在运行时对动态链接库的搜索顺序如下：</p>
<p>1） 在编译目标代码时所传递的动态库搜索路径（注意，这里指的是通过<code>-Wl,rpath=&lt;path1&gt;:&lt;path2&gt;</code>或<code>-R</code>选项传递的运行时动态库搜索路径，而不是通过<code>-L</code>选项传递的）</p>
<p>例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># gcc -Wl,-rpath,/home/arc/test,-rpath,/lib/,-rpath,/usr/lib/,-rpath,/usr/local/lib test.c</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"># gcc -Wl,-rpath=/home/arc/test:/lib/:/usr/lib/:/usr/local/lib test.c</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2） 环境变量<code>LD_LIBRARY_PATH</code>指定的动态库搜索路径；</p>
<p>3） 配置文件/etc/ld.so.conf中所指定的动态库搜索路径(更改/etc/ld.so.conf之后，一定要执行命令ldconfig，该命令会将/etc/ld.so.conf文件中所有路径下的库载入内存）;</p>
<p>4） 默认的动态库搜索路径/lib；</p>
<p>5） 默认的动态库搜索路径/usr/lib;</p>
<h3 id="6-2-编译时与运行时动态库查找的比较"><a href="#6-2-编译时与运行时动态库查找的比较" class="headerlink" title="6.2 编译时与运行时动态库查找的比较"></a>6.2 编译时与运行时动态库查找的比较</h3><p>下面是对编译时库的查找与运行时库的查找做一个简单的比较：</p>
<ol>
<li><p>编译时查找的是静态库或动态库， 而运行时，查找的是动态库；</p>
</li>
<li><p>编译时可以用<code>-L</code>指定查找路径，或者用环境变量<code>LIBRARY_PATH</code>， 而运行时可以用<code>-Wl,rpath</code>或者<code>-R</code>选项，或者修改/etc/ld.so.conf，或者设置环境变量<code>LD_LIBRARY_PATH</code>;</p>
</li>
<li><p>编译时用的链接器是<code>ld</code>，而运行时用的链接器是<code>/lib/ld-linux.so.2</code></p>
</li>
<li><p>编译时与运行时都会查找默认路径/lib、/usr/lib</p>
</li>
<li><p>编译时还有一个默认路径/usr/local/lib，而运行时不会默认查找该路径；</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">说明： -Wl,rpath选项虽然是在编译时传递的，但是其实是工作在运行时。其本身其实也不算是gcc的一个选项，而是ld的选项，gcc只不过</span><br><span class="line">      是一个包装器而已。我们可以执行man ld来进一步了解相关信息</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="6-3-补充-gcc使用-Wl-rpath"><a href="#6-3-补充-gcc使用-Wl-rpath" class="headerlink" title="6.3 补充:gcc使用-Wl,-rpath"></a>6.3 补充:gcc使用-Wl,-rpath</h3><ol>
<li><strong>-Wl,-rpath</strong></li>
</ol>
<p>加上<code>-Wl,-rpath</code>选项的作用就是指定<code>程序运行时</code>的库搜索目录，是一个链接选项，生效于设置的环境变量之前(LD_LIBRARY_PATH)。下面我们通过一个例子来说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// add.h</span><br><span class="line">int add(int i, int j);</span><br><span class="line"> </span><br><span class="line">// add.c</span><br><span class="line">#include &quot;add.h&quot;</span><br><span class="line"> </span><br><span class="line">int add(int i, int j)</span><br><span class="line">&#123;</span><br><span class="line">	return i + j;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// main.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &quot;add.h&quot;</span><br><span class="line"> </span><br><span class="line">int main(int argc, char *argv[]) </span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;1 + 2 = %d\n&quot;, add(1, 2));</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>add.h</code>和<code>add.c</code>用于生成一个so库，实现了一个简单的加法，main.c中引用共享库计算1 + 2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 编译共享库</span><br><span class="line">gcc add.c -fPIC -shared -o libadd.so</span><br><span class="line"># 编译主程序</span><br><span class="line">gcc main.o -L. -ladd -o app</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编译好后运行依赖库：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># ldd app</span><br><span class="line">linux-vdso.so.1 (0x00007ffeb23ab000)</span><br><span class="line">libadd.so =&gt; not found</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007febb7dd0000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007febb83d0000</span><br><span class="line"># ./app</span><br><span class="line">./app: error while loading shared libraries: libadd.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>

<p>可以看到， <code>libadd.so</code>这个库没有找到，程序也无法运行，要运行它必须要把当前目录添加到环境变量或者搜索路径中去。但是如果在链接时加上<code>-Wl,rpath</code>选项之后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># gcc -c -o main.o main.c</span><br><span class="line"># gcc -Wl,-rpath=`pwd` main.o -L. -ladd -o app</span><br><span class="line"># ldd app</span><br><span class="line">linux-vdso.so.1 (0x00007fff8f4e3000)</span><br><span class="line">libadd.so =&gt; /data/code/c/1-sys/solib/libadd.so (0x00007faef8428000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007faef8030000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007faef8838000)</span><br><span class="line"># ./app</span><br><span class="line">1 + 2 = 3</span><br></pre></td></tr></table></figure>

<p>依赖库的查找路径就找到了，程序能正常运行。</p>
<p>下面我们再来看一下生成的可执行文件<code>app</code>，执行如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#  readelf app -d</span><br><span class="line"></span><br><span class="line">Dynamic section at offset 0xe08 contains 26 entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> 0x0000000000000001 (NEEDED)             Shared library: [libadd.so]</span><br><span class="line"> 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]</span><br><span class="line"> 0x000000000000000f (RPATH)              Library rpath: [/root/test]</span><br><span class="line"> 0x000000000000000c (INIT)               0x400578</span><br><span class="line"> 0x000000000000000d (FINI)               0x400784</span><br><span class="line"> 0x0000000000000019 (INIT_ARRAY)         0x600df0</span><br><span class="line"> 0x000000000000001b (INIT_ARRAYSZ)       8 (bytes)</span><br><span class="line"> 0x000000000000001a (FINI_ARRAY)         0x600df8</span><br><span class="line"> 0x000000000000001c (FINI_ARRAYSZ)       8 (bytes)</span><br><span class="line"> 0x000000006ffffef5 (GNU_HASH)           0x400298</span><br><span class="line"> 0x0000000000000005 (STRTAB)             0x400408</span><br><span class="line"> 0x0000000000000006 (SYMTAB)             0x4002d0</span><br><span class="line"> 0x000000000000000a (STRSZ)              189 (bytes)</span><br><span class="line"> 0x000000000000000b (SYMENT)             24 (bytes)</span><br><span class="line"> 0x0000000000000015 (DEBUG)              0x0</span><br><span class="line"> 0x0000000000000003 (PLTGOT)             0x601000</span><br><span class="line"> 0x0000000000000002 (PLTRELSZ)           96 (bytes)</span><br><span class="line"> 0x0000000000000014 (PLTREL)             RELA</span><br><span class="line"> 0x0000000000000017 (JMPREL)             0x400518</span><br><span class="line"> 0x0000000000000007 (RELA)               0x400500</span><br><span class="line"> 0x0000000000000008 (RELASZ)             24 (bytes)</span><br><span class="line"> 0x0000000000000009 (RELAENT)            24 (bytes)</span><br><span class="line"> 0x000000006ffffffe (VERNEED)            0x4004e0</span><br><span class="line"> 0x000000006fffffff (VERNEEDNUM)         1</span><br><span class="line"> 0x000000006ffffff0 (VERSYM)             0x4004c6</span><br><span class="line"> 0x0000000000000000 (NULL)               0x0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到是在编译后的程序中包含了库的搜索路径。</p>
<ol start="2">
<li><strong>-Wl,rpath-link</strong></li>
</ol>
<p><code>-Wl,rpath-link</code>是设置编译链接时候的顺序，例如app运行依赖libadd.so，但是libadd.so又依赖libadd_ex.so，<code>rpath-link</code>就是指定libadd_ex.so的路径。和<code>-Wl,rpath</code>相比工作的时间不同，一个在链接期间，一个在运行期间。</p>
<h2 id="gcc编译头文件查找路径"><a href="#gcc编译头文件查找路径" class="headerlink" title="gcc编译头文件查找路径"></a>gcc编译头文件查找路径</h2><p>关于gcc编译时的查找路径，<a href="http://gcc.gnu.org/onlinedocs/cpp/Search-Path.html">GCC The C Preprocessor: Search Path</a>描述的比较清楚，我在这里将其复制出来：</p>
<p>By default, the preprocessor looks for header files included by the quote form of the directive #include “file” first relative to the directory of the current file, and then in a preconfigured list of standard system directories. For example, if /usr/include/sys/stat.h contains #include “types.h”, GCC looks for types.h first in /usr/include/sys, then in its usual search path.</p>
<p>For the angle-bracket form #include , the preprocessor’s default behavior is to look only in the standard system directories. The exact search directory list depends on the target system, how GCC is configured, and where it is installed. You can find the default search directory list for your version of CPP by invoking it with the -v option. For example,</p>
<p>cpp -v /dev/null -o /dev/null There are a number of command-line options you can use to add additional directories to the search path. The most commonly-used option is -Idir, which causes dir to be searched after the current directory (for the quote form of the directive) and ahead of the standard system directories. You can specify multiple -I options on the command line, in which case the directories are searched in left-to-right order.</p>
<p>If you need separate control over the search paths for the quote and angle-bracket forms of the ‘#include’ directive, you can use the -iquote and/or -isystem options instead of -I. See Invocation, for a detailed description of these options, as well as others that are less generally useful.</p>
<p>If you specify other options on the command line, such as -I, that affect where the preprocessor searches for header files, the directory list printed by the -v option reflects the actual search path used by the preprocessor.</p>
<p>Note that you can also prevent the preprocessor from searching any of the default system header directories with the -nostdinc option. This is useful when you are compiling an operating system kernel or some other program that does not use the standard C library facilities, or the standard C library itself.</p>
<p>除此之外，我们还可以通过相应的环境变量来指定头文件的搜索路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export C_INCLUDE_PATH=XXXX:$C_INCLUDE_PATH</span><br><span class="line">export CPLUS_INCLUDE_PATH=XXX:$CPLUS_INCLUDE_PATH</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以将以上代码添加到/etc/profile末尾。</p>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>pkg-config</tag>
      </tags>
  </entry>
  <entry>
    <title>Clash配置allow lan</title>
    <url>/2022/07/07/Trojan%E9%85%8D%E7%BD%AEallow-lan/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Clash for Windows 是基于 <a href="https://github.com/Dreamacro/clash">Clash Core</a> 开发的 Windows 平台代理工具，支持 Shadowsocks(R) / V2Ray / Trojan / Socks5 / HTTP(S) 等代理协议，支持策略组及规则分流。</p>
<span id="more"></span>

<blockquote>
<p>下载地址： <a href="https://github.com/Fndroid/clash_for_windows_pkg/releases">Github Releases</a> </p>
<p>第一次使用？查看 <a href="https://docs.cfw.lbyczf.com/contents/quickstart.html">快速上手</a></p>
</blockquote>
<p>在配置好 Clash for Windows（下文略称为 CFW ）后，我们可以考虑开启 <code>Allow LAN</code> （局域网代理共享），以便处于同一局域网内的其他设备接入到本机代理环境中。这不仅可以节省在多台设备中重复部署代理软件的时间，同时也可以通过 CFW 内置的 Connections 对局域网内设备的网络情况实时地管理与监控。</p>
<p>具体方法如下：</p>
<h2 id="Clash-for-Windows-设置方法"><a href="#Clash-for-Windows-设置方法" class="headerlink" title="Clash for Windows 设置方法"></a>Clash for Windows 设置方法</h2><p>启动 CFW 后，在 General 设置中点击 General YAML 选项，将 Profile 中的 <code>allow-lan</code> 值设置为 <code>true</code> ，随后保存并关闭配置文件窗口。最终效果如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># HTTP 端口</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">7890</span></span><br><span class="line"><span class="comment"># Socks 5 端口</span></span><br><span class="line"><span class="attr">socks-port:</span> <span class="number">7891</span></span><br><span class="line"><span class="comment"># 局域网代理共享</span></span><br><span class="line"><span class="attr">allow-lan:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>此时，我们已经开启 CFW 的局域网代理共享，且可以在 General 设置中看到 Allow LAN 为启动状态。</p>
<p>将鼠标悬浮于 Allow LAN 选项上，可以显示此时 Windows 的内网 IP 地址。</p>
<p><img src="de169eeb984388932b8ac7e0974a26f80fe2795ddf4fa028bc965fd14984079f.png" alt="picture 0">  </p>
<p>这里需要关闭电脑端的防火墙</p>
<h2 id="端口被封，如何解决"><a href="#端口被封，如何解决" class="headerlink" title="端口被封，如何解决"></a>端口被封，如何解决</h2><p>就我目前使用来看，trojan最多被封端口，ip好像没有太大问题。上面哪些方法懒得搞，直接一条iptables解决问题 。<br>在VPS上执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 将40000~50000的端口流量转发到443端口</span><br><span class="line">iptables -t nat -A PREROUTING -p tcp --dport 40000:50000 -j REDIRECT --to-ports 443</span><br></pre></td></tr></table></figure>
<p>使用nat转发流量，在本机上是不会监听端口的，也就是netstat看不到。<br>执行之后就可以客户端使用40000至50000的任意端口和trojan通信了。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p><strong>wsl配置proxy.sh</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">MY_PROXY_URL=&quot;http://172.19.96.1:7890&quot;</span><br><span class="line"> </span><br><span class="line">HTTP_PROXY=$MY_PROXY_URL</span><br><span class="line">HTTPS_PROXY=$MY_PROXY_URL</span><br><span class="line">FTP_PROXY=$MY_PROXY_URL</span><br><span class="line">http_proxy=$MY_PROXY_URL</span><br><span class="line">https_proxy=$MY_PROXY_URL</span><br><span class="line">ftp_proxy=$MY_PROXY_URL</span><br><span class="line"> </span><br><span class="line">export HTTP_PROXY HTTPS_PROXY FTP_PROXY http_proxy https_proxy ftp_proxy</span><br></pre></td></tr></table></figure>
<p>source一下proxy.sh即可开启端口代理</p>
<p><strong>wsl配置unproxy.sh</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line"> </span><br><span class="line">unset HTTP_PROXY HTTPS_PROXY FTP_PROXY http_proxy https_proxy ftp_proxy</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>source一下unproxy.sh即可关闭端口代理</p>
<p><strong>内网服务器配置proxy.sh</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">MY_PROXY_URL=&quot;http://10.20.19.191:7890&quot;</span><br><span class="line"> </span><br><span class="line">HTTP_PROXY=$MY_PROXY_URL</span><br><span class="line">HTTPS_PROXY=$MY_PROXY_URL</span><br><span class="line">FTP_PROXY=$MY_PROXY_URL</span><br><span class="line">http_proxy=$MY_PROXY_URL</span><br><span class="line">https_proxy=$MY_PROXY_URL</span><br><span class="line">ftp_proxy=$MY_PROXY_URL</span><br><span class="line"> </span><br><span class="line">export HTTP_PROXY HTTPS_PROXY FTP_PROXY http_proxy https_proxy ftp_proxy</span><br></pre></td></tr></table></figure>
<p>source一下proxy.sh即可开启端口代理</p>
<p><strong>内网服务器配置unproxy.sh</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line"> </span><br><span class="line">unset HTTP_PROXY HTTPS_PROXY FTP_PROXY http_proxy https_proxy ftp_proxy</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>source一下unproxy.sh即可关闭端口代理</p>
]]></content>
      <categories>
        <category>Trojan</category>
      </categories>
      <tags>
        <tag>Trojan</tag>
      </tags>
  </entry>
  <entry>
    <title>Trojan搭建</title>
    <url>/2022/07/06/Trojan%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h2 id="什么是-Trojan"><a href="#什么是-Trojan" class="headerlink" title="什么是 Trojan"></a>什么是 Trojan</h2><p>Trojan将流量伪装成用户正常访问网页时的HTTPS流量，防止流量被检测和干扰。</p>
<span id="more"></span>


<h2 id="搭建前准备"><a href="#搭建前准备" class="headerlink" title="搭建前准备"></a>搭建前准备</h2><h3 id="一台VPS服务器"><a href="#一台VPS服务器" class="headerlink" title="一台VPS服务器"></a>一台VPS服务器</h3><p>已有服务器的同学可以跳过这部分，没有服务器的同学可以先创建服务器，我使用的是<a href="https://www.itblogcn.com/vultr">Vultr</a>。</p>
<p><a href="https://www.itblogcn.com/vultr/t">Vultr VPS</a> 推出了 <strong>2023 年最新的限时促销活动</strong>，「新用户」注册并充值 10 美元以上，即可获得 100 美元的免费赠送金额！力度相当巨大！！ (去年仅送 $50) 用于建站、学习、自建网盘或各种网络服务等等都很实用，优势是价格低，按时计费，随时更换IP。有购买海外 <a href="https://www.itblogcn.com/vultr">VPS</a> 需求的同学就得抓紧机会了。</p>
<p><strong>Vultr活动地址：</strong><a href="https://www.itblogcn.com/vultr/t">https://www.itblogcn.com/vultr/t</a></p>
<p><strong>Vultr注册教程：</strong><a href="https://www.itblogcn.com/article/registervultr.html">注册Vultr教程和创建VPS服务器教程</a></p>
<p>预算充足的朋友也可以选择搬瓦工的VPS服务器，其CN2 GIA-E线路网速极快。</p>
<p><strong>搬瓦工注册教程(内附优惠券)：</strong><a href="https://www.itblogcn.com/article/bwg-register.html">https://www.itblogcn.com/article/bwg-register.html</a></p>
<p><strong>搬瓦工VPS在售列表一览：</strong><a href="https://www.itblogcn.com/bwg/index.html">https://www.itblogcn.com/bwg/index.html</a></p>
<p>这里也可以使用<a href="https://my.racknerd.com/cart.php?a=confproduct&i=0">racknerd</a>。</p>
<p><strong>racknerd注册教程：</strong><a href="https://www.vpsgo.com/racknerd-purchase-tutorial.html">https://www.vpsgo.com/racknerd-purchase-tutorial.html</a></p>
<p><strong>2023年便宜高性价比VPS推荐：</strong><a href="https://www.vps69.com/posts/cheap-vps">https://www.vps69.com/posts/cheap-vps</a></p>
<h3 id="域名申请"><a href="#域名申请" class="headerlink" title="域名申请"></a>域名申请</h3><p><strong>聚名教程：</strong><a href="https://www.juming.com/help/127.htm">https://www.juming.com/help/127.htm</a></p>
<p><strong>namecheap教程：</strong><a href="https://zhuanlan.zhihu.com/p/33261777">https://zhuanlan.zhihu.com/p/33261777</a></p>
<h3 id="端口开放"><a href="#端口开放" class="headerlink" title="端口开放"></a>端口开放</h3><p>安装前必须开放服务器的<code>80</code>和<code>443</code>端口</p>
<p>防火墙相关命令可阅读 ：<a href="https://www.itblogcn.com/article/vultr-centos-7-firewall.html">https://www.itblogcn.com/article/vultr-centos-7-firewall.html</a></p>
<h2 id="Xshell连接服务器"><a href="#Xshell连接服务器" class="headerlink" title="Xshell连接服务器"></a>Xshell连接服务器</h2><h3 id="电脑端-ssh-登录"><a href="#电脑端-ssh-登录" class="headerlink" title="电脑端 ssh 登录"></a>电脑端 ssh 登录</h3><h2 id="一键Trojan搭建"><a href="#一键Trojan搭建" class="headerlink" title="一键Trojan搭建"></a>一键Trojan搭建</h2><p>系统建议：</p>
<ul>
<li>  CentOS 7</li>
</ul>
<p>首先安装wget（Vultr VPS已安装）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y wget</span><br></pre></td></tr></table></figure>

<h3 id="一键安装Trojan脚本"><a href="#一键安装Trojan脚本" class="headerlink" title="一键安装Trojan脚本"></a>一键安装Trojan脚本</h3><p>输入以下命令，回车执行（<code>shift+insert</code>可粘贴）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget -N --no-check-certificate -q -O trojan_install.sh &quot;https://raw.githubusercontent.com/xyz690/Trojan/master/trojan_install.sh&quot; &amp;&amp; chmod +x trojan_install.sh &amp;&amp; bash trojan_install.sh</span><br></pre></td></tr></table></figure>

<p>输入<code>1</code>回车</p>
<p><img src="https://www.itblogcn.com/wp-content/uploads/2021/03/post-1048-603ca6268a7bb.png" alt="tssh2"></p>
<p>输入你解析的域名，比如我解析的是<code>www.demo.com</code>，然后回车执行</p>
<p><img src="https://www.itblogcn.com/wp-content/uploads/2021/03/post-1048-603ca62778d41.png" alt="tssh4_edit"></p>
<p>如果解析不正常，可能是之前DNS解析还没生效，建议等几分钟重试。</p>
<p>显示一下信息代表安装成功：</p>
<p><img src="https://www.itblogcn.com/wp-content/uploads/2021/03/post-1048-603ca628677ed.png" alt="20210301003431"></p>
<h4 id="查看运行状态（执行）："><a href="#查看运行状态（执行）：" class="headerlink" title="查看运行状态（执行）："></a>查看运行状态（执行）：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl status trojan.service</span><br></pre></td></tr></table></figure>

<p>成功运行显示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">● trojan.service - trojan</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/trojan.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Fri 2022-12-02 16:02:55 UTC; 37s ago</span><br><span class="line"> Main PID: 8263 (trojan)</span><br><span class="line">   CGroup: /system.slice/trojan.service</span><br><span class="line">           └─8263 /usr/src/trojan/trojan -c /usr/src/trojan/server.conf</span><br><span class="line"></span><br><span class="line">Dec 02 16:02:55 vultr.guest systemd[1]: Started trojan.</span><br><span class="line">Dec 02 16:02:55 vultr.guest trojan[8263]: Welcome to trojan 1.16.0</span><br><span class="line">Dec 02 16:02:55 vultr.guest trojan[8263]: [2022-12-02 16:02:55] [WARN] trojan service (server) started at 0.0.0.0:443</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="查看配置文件-该配置在后面链接时使用-："><a href="#查看配置文件-该配置在后面链接时使用-：" class="headerlink" title="查看配置文件(该配置在后面链接时使用)："></a>查看配置文件(该配置在后面链接时使用)：</h4><p>输入以下命令，回车执行（<code>shift+insert</code>可粘贴）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /usr/src/trojan-macos/trojan/config.json</span><br></pre></td></tr></table></figure>

<p>我的配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;run_type&quot;: &quot;client&quot;,</span><br><span class="line">    &quot;local_addr&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;local_port&quot;: 1080,</span><br><span class="line">    &quot;remote_addr&quot;: &quot;www.demo.com&quot;,</span><br><span class="line">    &quot;remote_port&quot;: 443,</span><br><span class="line">    &quot;password&quot;: [</span><br><span class="line">        &quot;ae412345&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;log_level&quot;: 1,</span><br><span class="line">    &quot;ssl&quot;: &#123;</span><br><span class="line">        &quot;verify&quot;: true,</span><br><span class="line">        &quot;verify_hostname&quot;: true,</span><br><span class="line">        &quot;cert&quot;: &quot;&quot;,</span><br><span class="line">        &quot;cipher&quot;: &quot;ECDHE-ECDSA-AES128-GCM-SHA256:...&quot;,</span><br><span class="line">        &quot;cipher_tls13&quot;: &quot;TLS_AES_128_GCM_SHA256:...&quot;,</span><br><span class="line">        &quot;sni&quot;: &quot;&quot;,</span><br><span class="line">        &quot;alpn&quot;: [</span><br><span class="line">            &quot;h2&quot;,</span><br><span class="line">            &quot;http/1.1&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;reuse_session&quot;: true,</span><br><span class="line">        &quot;session_ticket&quot;: false,</span><br><span class="line">        &quot;curves&quot;: &quot;&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;tcp&quot;: &#123;</span><br><span class="line">        &quot;no_delay&quot;: true,</span><br><span class="line">        &quot;keep_alive&quot;: true,</span><br><span class="line">        &quot;reuse_port&quot;: false,</span><br><span class="line">        &quot;fast_open&quot;: false,</span><br><span class="line">        &quot;fast_open_qlen&quot;: 20</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请重点关注配置文件中的如下参数：</p>
<ol>
<li> <code>remote_addr</code>：服务器地址（浏览器输入这个地址能打开网页）</li>
<li> <code>remote_port</code>：端口</li>
<li> <code>password</code>：密码</li>
</ol>
<h2 id="客户端链接Trojan"><a href="#客户端链接Trojan" class="headerlink" title="客户端链接Trojan"></a>客户端链接Trojan</h2><p><strong>clash-for-windows教程：</strong><a href="https://v2xtls.org/clash-for-windows%E9%85%8D%E7%BD%AEtrojan%E6%95%99%E7%A8%8B/">https://v2xtls.org/clash-for-windows%E9%85%8D%E7%BD%AEtrojan%E6%95%99%E7%A8%8B/</a></p>
<p>官网下载地址：<a href="https://github.com/Fndroid/clash_for_windows_pkg/releases">https://github.com/Fndroid/clash_for_windows_pkg/releases</a></p>
<p>下载运行后，点击“Profiles”，点击 <a href="https://v2xtls.org/clash_template2.yaml">https://v2xtls.org/clash_template2.yaml</a> 下载模板配置文件，用记事本、VS Code、Notepad++等编辑器打开，找到trojan配置块，把 server、port、password改成你服务器的信息</p>
<p>把修改好的配置文件拖到clash界面中，</p>
<p>然后双击选中拖进来的配置文件(深色表示选中)</p>
<p>最后回到主界面，点击“System Proxy”，开启系统代理，点击“Start with Windows”设置开机自启</p>
<h2 id="Profiles"><a href="#Profiles" class="headerlink" title="Profiles"></a>Profiles</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mixed-port: 7890</span><br><span class="line">allow-lan: false</span><br><span class="line">log-level: info</span><br><span class="line">external-controller: &#x27;127.0.0.1:29090&#x27;</span><br><span class="line">secret: &#x27;&#x27;</span><br><span class="line">ipv6: false</span><br><span class="line"></span><br><span class="line"># Will be ignored after profile selection</span><br><span class="line">proxies:</span><br><span class="line">  - name: trojan</span><br><span class="line">    type: trojan</span><br><span class="line">    server: www.rma-xxx.xxx</span><br><span class="line">    port: 443</span><br><span class="line">    password: xxxx</span><br><span class="line">    # udp: true</span><br><span class="line">    # sni: example.com # 填写伪装域名</span><br><span class="line">    alpn:</span><br><span class="line">      - h2</span><br><span class="line">      - http/1.1</span><br><span class="line">    # skip-cert-verify: true</span><br><span class="line">  - name: http</span><br><span class="line">    type: http</span><br><span class="line">    server: hkproxy.jaguarmicro.com</span><br><span class="line">    port: 3128</span><br><span class="line">    username: xxxx</span><br><span class="line">    password: xxxxx</span><br><span class="line"></span><br><span class="line">proxy-groups:</span><br><span class="line">  # select is used for selecting proxy or proxy group</span><br><span class="line">  # you can use RESTful API to switch proxy is recommended for use in GUI.</span><br><span class="line">  - name: PROXY</span><br><span class="line">    type: select</span><br><span class="line">    # disable-udp: true</span><br><span class="line">    proxies:</span><br><span class="line">      - trojan</span><br><span class="line">      - http</span><br><span class="line"></span><br><span class="line">rule-providers:</span><br><span class="line">  reject:</span><br><span class="line">    type: http</span><br><span class="line">    behavior: domain</span><br><span class="line">    url: &quot;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/reject.txt&quot;</span><br><span class="line">    path: ./ruleset/reject.yaml</span><br><span class="line">    interval: 86400</span><br><span class="line"></span><br><span class="line">  icloud:</span><br><span class="line">    type: http</span><br><span class="line">    behavior: domain</span><br><span class="line">    url: &quot;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/icloud.txt&quot;</span><br><span class="line">    path: ./ruleset/icloud.yaml</span><br><span class="line">    interval: 86400</span><br><span class="line"></span><br><span class="line">  apple:</span><br><span class="line">    type: http</span><br><span class="line">    behavior: domain</span><br><span class="line">    url: &quot;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/apple.txt&quot;</span><br><span class="line">    path: ./ruleset/apple.yaml</span><br><span class="line">    interval: 86400</span><br><span class="line"></span><br><span class="line">  google:</span><br><span class="line">    type: http</span><br><span class="line">    behavior: domain</span><br><span class="line">    url: &quot;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/google.txt&quot;</span><br><span class="line">    path: ./ruleset/google.yaml</span><br><span class="line">    interval: 86400</span><br><span class="line"></span><br><span class="line">  proxy:</span><br><span class="line">    type: http</span><br><span class="line">    behavior: domain</span><br><span class="line">    url: &quot;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/proxy.txt&quot;</span><br><span class="line">    path: ./ruleset/proxy.yaml</span><br><span class="line">    interval: 86400</span><br><span class="line"></span><br><span class="line">  direct:</span><br><span class="line">    type: http</span><br><span class="line">    behavior: domain</span><br><span class="line">    url: &quot;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/direct.txt&quot;</span><br><span class="line">    path: ./ruleset/direct.yaml</span><br><span class="line">    interval: 86400</span><br><span class="line"></span><br><span class="line">  private:</span><br><span class="line">    type: http</span><br><span class="line">    behavior: domain</span><br><span class="line">    url: &quot;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/private.txt&quot;</span><br><span class="line">    path: ./ruleset/private.yaml</span><br><span class="line">    interval: 86400</span><br><span class="line"></span><br><span class="line">  gfw:</span><br><span class="line">    type: http</span><br><span class="line">    behavior: domain</span><br><span class="line">    url: &quot;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/gfw.txt&quot;</span><br><span class="line">    path: ./ruleset/gfw.yaml</span><br><span class="line">    interval: 86400</span><br><span class="line"></span><br><span class="line">  greatfire:</span><br><span class="line">    type: http</span><br><span class="line">    behavior: domain</span><br><span class="line">    url: &quot;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/greatfire.txt&quot;</span><br><span class="line">    path: ./ruleset/greatfire.yaml</span><br><span class="line">    interval: 86400</span><br><span class="line"></span><br><span class="line">  tld-not-cn:</span><br><span class="line">    type: http</span><br><span class="line">    behavior: domain</span><br><span class="line">    url: &quot;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/tld-not-cn.txt&quot;</span><br><span class="line">    path: ./ruleset/tld-not-cn.yaml</span><br><span class="line">    interval: 86400</span><br><span class="line"></span><br><span class="line">  telegramcidr:</span><br><span class="line">    type: http</span><br><span class="line">    behavior: ipcidr</span><br><span class="line">    url: &quot;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/telegramcidr.txt&quot;</span><br><span class="line">    path: ./ruleset/telegramcidr.yaml</span><br><span class="line">    interval: 86400</span><br><span class="line"></span><br><span class="line">  cncidr:</span><br><span class="line">    type: http</span><br><span class="line">    behavior: ipcidr</span><br><span class="line">    url: &quot;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/cncidr.txt&quot;</span><br><span class="line">    path: ./ruleset/cncidr.yaml</span><br><span class="line">    interval: 86400</span><br><span class="line"></span><br><span class="line">  lancidr:</span><br><span class="line">    type: http</span><br><span class="line">    behavior: ipcidr</span><br><span class="line">    url: &quot;https://cdn.jsdelivr.net/gh/Loyalsoldier/clash-rules@release/lancidr.txt&quot;</span><br><span class="line">    path: ./ruleset/lancidr.yaml</span><br><span class="line">    interval: 86400</span><br><span class="line"></span><br><span class="line">rules:</span><br><span class="line">  - PROCESS-NAME,v2ray,DIRECT</span><br><span class="line">  - PROCESS-NAME,xray,DIRECT</span><br><span class="line">  - PROCESS-NAME,naive,DIRECT</span><br><span class="line">  - PROCESS-NAME,trojan,DIRECT</span><br><span class="line">  - PROCESS-NAME,trojan-go,DIRECT</span><br><span class="line">  - PROCESS-NAME,ss-local,DIRECT</span><br><span class="line">  - PROCESS-NAME,privoxy,DIRECT</span><br><span class="line">  - PROCESS-NAME,leaf,DIRECT</span><br><span class="line">  - PROCESS-NAME,v2ray.exe,DIRECT</span><br><span class="line">  - PROCESS-NAME,xray.exe,DIRECT</span><br><span class="line">  - PROCESS-NAME,naive.exe,DIRECT</span><br><span class="line">  - PROCESS-NAME,trojan.exe,DIRECT</span><br><span class="line">  - PROCESS-NAME,trojan-go.exe,DIRECT</span><br><span class="line">  - PROCESS-NAME,ss-local.exe,DIRECT</span><br><span class="line">  - PROCESS-NAME,privoxy.exe,DIRECT</span><br><span class="line">  - PROCESS-NAME,leaf.exe,DIRECT</span><br><span class="line">  - PROCESS-NAME,Surge,DIRECT</span><br><span class="line">  - PROCESS-NAME,Surge 2,DIRECT</span><br><span class="line">  - PROCESS-NAME,Surge 3,DIRECT</span><br><span class="line">  - PROCESS-NAME,Surge 4,DIRECT</span><br><span class="line">  - PROCESS-NAME,Surge%202,DIRECT</span><br><span class="line">  - PROCESS-NAME,Surge%203,DIRECT</span><br><span class="line">  - PROCESS-NAME,Surge%204,DIRECT</span><br><span class="line">  - PROCESS-NAME,Thunder,DIRECT</span><br><span class="line">  - PROCESS-NAME,DownloadService,DIRECT</span><br><span class="line">  - PROCESS-NAME,qBittorrent,DIRECT</span><br><span class="line">  - PROCESS-NAME,Transmission,DIRECT</span><br><span class="line">  - PROCESS-NAME,fdm,DIRECT</span><br><span class="line">  - PROCESS-NAME,aria2c,DIRECT</span><br><span class="line">  - PROCESS-NAME,Folx,DIRECT</span><br><span class="line">  - PROCESS-NAME,NetTransport,DIRECT</span><br><span class="line">  - PROCESS-NAME,uTorrent,DIRECT</span><br><span class="line">  - PROCESS-NAME,WebTorrent,DIRECT</span><br><span class="line">  - PROCESS-NAME,aria2c.exe,DIRECT</span><br><span class="line">  - PROCESS-NAME,BitComet.exe,DIRECT</span><br><span class="line">  - PROCESS-NAME,fdm.exe,DIRECT</span><br><span class="line">  - PROCESS-NAME,NetTransport.exe,DIRECT</span><br><span class="line">  - PROCESS-NAME,qbittorrent.exe,DIRECT</span><br><span class="line">  - PROCESS-NAME,Thunder.exe,DIRECT</span><br><span class="line">  - PROCESS-NAME,ThunderVIP.exe,DIRECT</span><br><span class="line">  - PROCESS-NAME,transmission-daemon.exe,DIRECT</span><br><span class="line">  - PROCESS-NAME,transmission-qt.exe,DIRECT</span><br><span class="line">  - PROCESS-NAME,uTorrent.exe,DIRECT</span><br><span class="line">  - PROCESS-NAME,WebTorrent.exe,DIRECT</span><br><span class="line">  - DOMAIN,clash.razord.top,DIRECT</span><br><span class="line">  - DOMAIN,yacd.haishan.me,DIRECT</span><br><span class="line">  - RULE-SET,private,DIRECT</span><br><span class="line">  - RULE-SET,reject,REJECT</span><br><span class="line">  - RULE-SET,icloud,DIRECT</span><br><span class="line">  - RULE-SET,apple,DIRECT</span><br><span class="line">  - RULE-SET,google,DIRECT</span><br><span class="line">  - RULE-SET,proxy,PROXY</span><br><span class="line">  - RULE-SET,direct,DIRECT</span><br><span class="line">  - RULE-SET,telegramcidr,PROXY</span><br><span class="line">  - GEOIP,,DIRECT</span><br><span class="line">  - GEOIP,CN,DIRECT</span><br><span class="line">  - MATCH,PROXY</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Trojan</category>
      </categories>
      <tags>
        <tag>Trojan</tag>
      </tags>
  </entry>
  <entry>
    <title>libvirt新增驱动</title>
    <url>/2022/07/05/libvirt%E6%96%B0%E5%A2%9E%E9%A9%B1%E5%8A%A8/</url>
    <content><![CDATA[<h2 id="libvirtd驱动"><a href="#libvirtd驱动" class="headerlink" title="libvirtd驱动"></a>libvirtd驱动</h2><p>libvirtd qemu驱动的实现基于QEMU的API和命令行工具，它可以与QEMU进行交互，以便创建、启动、停止、重启、迁移、备份和恢复虚拟机等操作。</p>
<span id="more"></span>

<h2 id="修改背景"><a href="#修改背景" class="headerlink" title="修改背景"></a>修改背景</h2><p>如果是自研的虚拟化软件，那么在使用libvirtd时，需要开发对应的app驱动。<br>admin 2.0对libvirt 进行了开发，修改了原生7.2的代码，需要删除对原有功能的形象，完成现有功能的迭代</p>
<ol>
<li>支持2.0现有功能</li>
<li>增加新的jmnd_driver支持，可考虑新增代码单独目录放置</li>
</ol>
<h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>原生libvirt增加jmnd_driver:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">编译meson:</span><br><span class="line"></span><br><span class="line">    meson.build：增加jmnd驱动编译</span><br><span class="line"></span><br><span class="line">    meson_options.txt: 增加jmnd驱动选项</span><br><span class="line"></span><br><span class="line">修改代码：</span><br><span class="line"></span><br><span class="line">    include/libvirt/virterror.h: 增加错误域</span><br><span class="line"></span><br><span class="line">    src/util/virerror.c: 增加错误域名</span><br><span class="line"></span><br><span class="line">    src/remote/remote_daemon.c: 增加驱动装载的执行</span><br><span class="line"></span><br><span class="line">    src/meson.build: 增加jmnd驱动编译</span><br><span class="line"></span><br><span class="line">新增驱动代码：</span><br><span class="line"></span><br><span class="line">    src/jmnd : jmnd_driver实现</span><br></pre></td></tr></table></figure>


<h2 id="virsh命令格式"><a href="#virsh命令格式" class="headerlink" title="virsh命令格式"></a>virsh命令格式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    virsh -c jmnd+tcp:///system [CMD]</span><br><span class="line"></span><br><span class="line">    可以将jmnd设置成默认驱动：</span><br><span class="line"></span><br><span class="line">        /usr/share/jmnd/libvirt/etc/libvirt/libvirt.conf 中：uri_default = &quot;jmnd:///system&quot;</span><br><span class="line"></span><br><span class="line">        重启libvirt</span><br><span class="line"></span><br><span class="line">        然后执行virsh [CMD]，等同于执行virsh -c jmnd+tcp:///system [CMD]</span><br><span class="line"></span><br><span class="line">远程操作：</span><br><span class="line"></span><br><span class="line">     virsh -c jmnd+tcp://10.20.25.22/system [CMD]</span><br></pre></td></tr></table></figure>


<h2 id="libvird-l"><a href="#libvird-l" class="headerlink" title="libvird -l"></a>libvird -l</h2><p>用于监听libvirtd.conf中的tcp_port，如果不加-l参数，则virsh只能本地访问libvirtd，添加-l参数后可以远程访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@node-70-20:/usr/share/jmnd/libvirt/etc/libvirt# egrep -v &quot;^#|^$&quot; *</span><br><span class="line">libvirt.conf:uri_default = &quot;jmnd:///system&quot;</span><br><span class="line">libvirtd.conf:listen_tls = 0</span><br><span class="line">libvirtd.conf:listen_tcp = 1</span><br><span class="line">libvirtd.conf:tcp_port = &quot;16509&quot;</span><br><span class="line">libvirtd.conf:log_level = 3</span><br><span class="line">libvirtd.conf:log_outputs=&quot;1:file:/var/log/libvirt/libvirtd.log&quot;</span><br><span class="line">qemu.conf:max_files = 20480</span><br></pre></td></tr></table></figure>

<h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>1.0和2.0可以共用libvirt</p>
<p>1.0用的是libvirt本身支持的qemu驱动、</p>
<p>2.0用的是libvirt支持的jmnd驱动</p>
<p>由于libvirt的jmnd驱动加载后有定时器定时连接jmnd_hypervisor，因此可以直接将jmnd驱动库删除，驱动库：/usr/share/jmnd/libvirt/lib/x86_64-linux-gnu/libvirt/connection-driver/libvirt_driver_jmnd.so</p>
<p>后续jmnd驱动修改代码可以直接替换这个驱动库后重启Libvirt生效</p>
<h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line">#0  jmndConnectHelloWorld (conn=0x7f5ca40051c0, printout=0x7f5cd6f32960) at ../src/jmnd/jmnd_driver.c:404</span><br><span class="line">#1  0x00007f5cde7ee786 in virConnectHelloWorld (conn=&lt;optimized out&gt;, printout=printout@entry=0x7f5cd6f32960) at ../src/libvirt-domain.c:191</span><br><span class="line">#2  0x000055af32336164 in remoteDispatchConnectHelloWorld (server=0x55af33b64080, msg=0x55af33b6e1c0, ret=0x7f5ccc0039d0, rerr=0x7f5cd6f32a30, client=0x7f5ca40050c0)</span><br><span class="line">    at src/remote/remote_daemon_dispatch_stubs.h:1317</span><br><span class="line">#3  remoteDispatchConnectHelloWorldHelper (server=0x55af33b64080, client=0x7f5ca40050c0, msg=0x55af33b6e1c0, rerr=0x7f5cd6f32a30, args=0x0, ret=0x7f5ccc0039d0) at src/remote/remote_daemon_dispatch_stubs.h:1297</span><br><span class="line">#4  0x00007f5cde7877c1 in virNetServerProgramDispatchCall (msg=0x55af33b6e1c0, client=0x7f5ca40050c0, server=0x55af33b64080, prog=0x55af33b65810) at ../src/rpc/virnetserverprogram.c:428</span><br><span class="line">#5  virNetServerProgramDispatch (prog=0x55af33b65810, server=server@entry=0x55af33b64080, client=0x7f5ca40050c0, msg=0x55af33b6e1c0) at ../src/rpc/virnetserverprogram.c:302</span><br><span class="line">#6  0x00007f5cde78c712 in virNetServerProcessMsg (msg=&lt;optimized out&gt;, prog=&lt;optimized out&gt;, client=&lt;optimized out&gt;, srv=0x55af33b64080) at ../src/rpc/virnetserver.c:137</span><br><span class="line">#7  virNetServerHandleJob (jobOpaque=0x55af33b35000, opaque=0x55af33b64080) at ../src/rpc/virnetserver.c:154</span><br><span class="line">#8  0x00007f5cde6d68f0 in virThreadPoolWorker (opaque=&lt;optimized out&gt;) at ../src/util/virthreadpool.c:163</span><br><span class="line">#9  0x00007f5cde6d6027 in virThreadHelper (data=&lt;optimized out&gt;) at ../src/util/virthread.c:233</span><br><span class="line">#10 0x00007f5cdbdae1ca in start_thread () from /lib64/libpthread.so.0</span><br><span class="line">#11 0x00007f5cdd0ecd83 in clone () from /lib64/libc.so.6</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LIBVIRT</category>
      </categories>
      <tags>
        <tag>driver</tag>
      </tags>
  </entry>
  <entry>
    <title>libvirtd初始化流程</title>
    <url>/2022/07/04/libvirtd%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>libvirtd daemon初始化流程比较复杂，本文对代码流程进行初步分析。</p>
<span id="more"></span>
<h2 id="总体代码流程"><a href="#总体代码流程" class="headerlink" title="总体代码流程"></a>总体代码流程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main&#123;remote/remote_deamon.c&#125;</span><br><span class="line">	|</span><br><span class="line">	|--daemonConfigLoadFile&#123;读取libvirtd.conf配置项&#125;</span><br><span class="line">	|</span><br><span class="line">	|--Decided on pid file path &#x27;/usr/local/var/run/libvirtd.pid&#x27;</span><br><span class="line">	|</span><br><span class="line">	|--virDaemonUnixSocketPaths&#123;获取unix对应的socket文件名字，例如：/usr/local/var/run/libvirt/libvirt-sock&#125;</span><br><span class="line">	|</span><br><span class="line">	|--virDaemonForkIntoBackground&#123;如果设置-d参数的话，将启动的libvirtd进程变成后台的daemon进程&#125;</span><br><span class="line">	|</span><br><span class="line">	|--virPidFileAcquirePath&#123;&#x27;/usr/local/var/run/libvirtd.pid&#x27;&#125;</span><br><span class="line">	|</span><br><span class="line">	|--virNetDaemonNew&#123;生成的是daemon变量&#125;</span><br><span class="line">	|</span><br><span class="line">	|--virNetServerNew&#123;初始化的是libvirtd server变量，里面是一堆rpc-worker的线程&#125;</span><br><span class="line">	|</span><br><span class="line">	|--virNetDaemonAddServer&#123;把server变量放进daemon中的hash表中&#125;</span><br><span class="line">	|</span><br><span class="line">	|--daemonSetupSignals&#123;daemon的一些回调函数注册，例如SIGINT，SIGQUIT，SIGTERM，SIGHUP&#125;</span><br><span class="line">	|</span><br><span class="line">	|--daemonSetupNetworking&#123;前面已经启动线程，这里对socket进行监听和消息接收函数注册&#125;</span><br><span class="line">	|</span><br><span class="line">	|--daemonInitialize&#123;动态库添加，例如qemu驱动&#125;</span><br><span class="line">	|</span><br><span class="line">	|--daemonStateInit&#123;驱动初始化，例如qemu驱动的初始化&#125;</span><br><span class="line">	|</span><br><span class="line">	|--virNetServerProgramNew</span><br><span class="line">	|</span><br><span class="line">	|--virNetServerAddProgram(srv, qemuProgram)</span><br><span class="line">	|</span><br><span class="line">	|--virNetDaemonRun&#123;Run event loop&#125;</span><br></pre></td></tr></table></figure>

<h2 id="各个流程代码分析"><a href="#各个流程代码分析" class="headerlink" title="各个流程代码分析"></a>各个流程代码分析</h2><h3 id="子进程创建"><a href="#子进程创建" class="headerlink" title="子进程创建"></a>子进程创建</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">virDaemonForkIntoBackground&#123;如果启动libvirtd进程的时候，以-d启动，则会创建一个子进程来启动，之后在后台运行，否则libvirtd进程就会一直卡在终端界面上&#125;</span><br><span class="line">	|</span><br><span class="line">	|--virPipeQuiet(statuspipe)</span><br><span class="line">	|</span><br><span class="line">	|--fork()</span><br><span class="line">		|</span><br><span class="line">		|--child</span><br><span class="line">		|	|</span><br><span class="line">		|	|--VIR_FORCE_CLOSE(statuspipe[0])&#123;关闭读通道&#125;</span><br><span class="line">		|	|</span><br><span class="line">		|	|--setsid()&#123;为啥在这里设置，child后面就会关掉，为啥不在grand child中设置呢？&#125;</span><br><span class="line">		|	|</span><br><span class="line">		|	|--fork()&#123;继续创建进程&#125;</span><br><span class="line">		|		|</span><br><span class="line">		|		|--grand</span><br><span class="line">		|		|	|</span><br><span class="line">		|		|	|-statuspipe[1]&#123;返回写通道，用grand child作为daemon进程，如果初始化成功，则会向管道中写数据&#125;</span><br><span class="line">		|		|</span><br><span class="line">		|		|--child</span><br><span class="line">		|			|</span><br><span class="line">		|			|--_exit(EXIT_SUCCESS)&#123;child进程退出，但是是不是没有清理资源statuspipe[1]？&#125;</span><br><span class="line">		|</span><br><span class="line">		|--parent</span><br><span class="line">			|</span><br><span class="line">			|--VIR_FORCE_CLOSE(statuspipe[1])&#123;关闭写通道&#125;</span><br><span class="line">			|</span><br><span class="line">			|--waitpid(pid, &amp;exitstatus, 0)&#123;等到child退出&#125;</span><br><span class="line">			|</span><br><span class="line">			|--saferead(statuspipe[0], &amp;status, 1)&#123;grand child后面初始化成功之后会发送消息，但是这个是非阻塞的，难道会等待吗？&#125;</span><br><span class="line">			|</span><br><span class="line">			|--VIR_FORCE_CLOSE(statuspipe[0])&#123;关闭读通道&#125;</span><br><span class="line">			|</span><br><span class="line">			|--_exit(EXIT_SUCCESS)&#123;退出父进程&#125;</span><br><span class="line"></span><br><span class="line">virPidFileAcquirePath的目的是为了防止重复运行libvirtd进程；在该函数中会设置独占锁给pid_file；如果失败，则说明已经有libvirtd运行了，反之则将pid写入到pid_file中(pid_file=/usr/local/var/run/libvirtd.pid)</span><br><span class="line">virPidFileAcquirePath</span><br><span class="line">	|</span><br><span class="line">	|--open(path, O_WRONLY|O_CREAT, 0644)</span><br><span class="line">	|</span><br><span class="line">	|--&#123;Ensuring run dir &#x27;/usr/local/var/run/libvirt&#x27; exists&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="daemon对象创建"><a href="#daemon对象创建" class="headerlink" title="daemon对象创建"></a>daemon对象创建</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">virNetDaemonNew</span><br><span class="line">	|</span><br><span class="line">	|--virNetDaemonInitialize</span><br><span class="line">	|</span><br><span class="line">	|--dmn = virObjectLockableNew&#123;生成一个virNetDaemon对象，后续对该对象中的各个成员变量进行初始化&#125;</span><br><span class="line">	|</span><br><span class="line">	|--dmn-&gt;servers = virHashNew(virObjectFreeHashData)&#123;这里分配HASH表，并对哈希表进行初始化&#125;</span><br><span class="line">	|</span><br><span class="line">	|--virEventRegisterDefaultImpl</span><br><span class="line">		|</span><br><span class="line">		|--virInitialize&#123;所调用的函数只执行一次，pthread_once&#125;</span><br><span class="line">		|	|</span><br><span class="line">		|	|--virGlobalInit&#123;相应的driver注册&#125;</span><br><span class="line">		|		|</span><br><span class="line">		|		|--remoteRegister&#123;这个函数为啥没有日志打印？难道没有执行&#125;</span><br><span class="line">		|			|</span><br><span class="line">		|			|--virRegisterConnectDriver(&amp;connect_driver)</span><br><span class="line">		|			|</span><br><span class="line">		|			|--virRegisterStateDriver(&amp;state_driver)</span><br><span class="line">		|</span><br><span class="line">		|--virResetLastError</span><br><span class="line">		|</span><br><span class="line">		|--virEventGLibRegister</span><br><span class="line">			|</span><br><span class="line">			|--virEventGLibRegisterOnce&#123;函数只执行一次&#125;</span><br><span class="line">				|</span><br><span class="line">				|--virEventRegisterImpl&#123;这个是event事件相关函数句柄注册&#125;</span><br><span class="line">					|</span><br><span class="line">					|--removeHandleImpl=virEventGLibHandleRemove</span><br><span class="line">					|--updateHandleImpl=virEventGLibHandleUpdate</span><br><span class="line">					|--addHandleImpl=virEventGLibHandleAdd</span><br><span class="line">						|</span><br><span class="line">						|--GSource</span><br><span class="line">						|--g_source_new</span><br><span class="line">						|--g_source_add_poll</span><br><span class="line">						|--g_source_set_callback</span><br><span class="line">						|--g_source_attach</span><br></pre></td></tr></table></figure>

<h3 id="virNetServerNew创建"><a href="#virNetServerNew创建" class="headerlink" title="virNetServerNew创建"></a>virNetServerNew创建</h3><p>这个就是初始化一组worker pool,等待信号量，然后再调用消息处理函数处理具体的消息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">virNetServerNew&#123;这个是rpc-worker服务端的初始化函数&#125;</span><br><span class="line">	|</span><br><span class="line">	|--virObjectLockableNew(virNetServerClass)&#123;生成一个virNetServerPtr对象指针&#125;</span><br><span class="line">	|</span><br><span class="line">	|--srv-&gt;workers = virThreadPoolNewFull(virNetServerHandleJob, &quot;rpc-worker&quot;)</span><br><span class="line">	|	|</span><br><span class="line">	|	|--分配virThreadPoolPtr pool</span><br><span class="line">	|	|</span><br><span class="line">	|	|--pool-&gt;jobFunc = func=virNetServerHandleJob&#123;设置pool中的函数句柄&#125;</span><br><span class="line">	|	|</span><br><span class="line">	|	|--pool-&gt;jobName = name&#123;设置pool中的名字&#125;</span><br><span class="line">	|	|</span><br><span class="line">	|	|--pool-&gt;jobOpaque=server&#123;将server变量指针传入到pool的jobopaque指针变量中&#125;</span><br><span class="line">	|	|</span><br><span class="line">	|	|--virThreadPoolExpand(pool, minWorkers)&#123;如函数名称：线程池扩展函数，就是for循环创建多个线程池&#125;</span><br><span class="line">	|	|	|</span><br><span class="line">	|	|	|--data-&gt;pool = pool</span><br><span class="line">	|	|	|</span><br><span class="line">	|	|	|--virThreadCreateFull(&amp;(*workers)[i],virThreadPoolWorker,data)&#123;创建minWorkers个线程&#125;</span><br><span class="line">	|	|		|</span><br><span class="line">	|	|		|--args-&gt;func=virThreadPoolWorker</span><br><span class="line">	|	|		|</span><br><span class="line">	|	|		|--args-&gt;opaque=data</span><br><span class="line">	|	|		|</span><br><span class="line">	|	|		|--pthread_create(&amp;thread-&gt;thread, &amp;attr, virThreadHelper, args)</span><br><span class="line">	|	|			|</span><br><span class="line">	|	|			|--virThreadHelper(args)&#123;这是最终的线程函数&#125;</span><br><span class="line">	|	|				|</span><br><span class="line">	|	|				|--local = *args</span><br><span class="line">	|	|				|</span><br><span class="line">	|	|				|-local.func(local.opaque)&lt;==&gt;virThreadPoolWorker(data)</span><br><span class="line">	|	|					|</span><br><span class="line">	|	|					|--virThreadPoolWorker&#123;这个是线程的最终执行函数，里面有while循环&#125;</span><br><span class="line">	|	|						|</span><br><span class="line">	|	|						|-virMutexLock(&amp;pool-&gt;mutex)&#123;在进入while循环之前先获取锁&#125;</span><br><span class="line">	|	|						|</span><br><span class="line">	|	|						|--virCondWait(cond, &amp;pool-&gt;mutex)&#123;进入while循环之后，先解锁把cond放入等待队列中(原子动作)，获取信号之后，再加锁&#125;</span><br><span class="line">	|	|						|</span><br><span class="line">	|	|						|--pool-&gt;jobQueueDepth--&#123;队列深度减一&#125;</span><br><span class="line">	|	|						|--virMutexUnlock(&amp;pool-&gt;mutex)&#123;解锁&#125;</span><br><span class="line">	|	|						|--(pool-&gt;jobFunc)(job-&gt;data, pool-&gt;jobOpaque)&lt;===&gt;virNetServerHandleJob(server)&#123;这里是处理具体消息的函数&#125;</span><br><span class="line">	|	|						|--virMutexLock(&amp;pool-&gt;mutex)&#123;加锁，进入下一次等待&#125;</span><br><span class="line">	|	|</span><br><span class="line">	|	|--return pool&#123;server变量中的worker就是pool，即线程池&#125;</span><br><span class="line">	|</span><br><span class="line">	|--继续初始化server，这里的pool是server中的变量，同时也是线程中的变量，两边都可以使用</span><br></pre></td></tr></table></figure>

<h3 id="服务端创建"><a href="#服务端创建" class="headerlink" title="服务端创建"></a>服务端创建</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">daemonSetupNetworking(srv, srvAdm,config,sock_file)</span><br><span class="line">	|</span><br><span class="line">	|--virNetServerAddServiceActivation&#123;No activation FDs present，这个函数没啥作用，直接返回了&#125;</span><br><span class="line">	|</span><br><span class="line">	|--virNetServerAddServiceUNIX&#123;针对的unix的*.socket文件&#125;&#123;这里生成的是virNetServerService对象&#125;</span><br><span class="line">	|	|</span><br><span class="line">	|	|--virNetServerAddServiceActivation</span><br><span class="line">	|	|</span><br><span class="line">	|	|--virNetServerServiceNewUNIX</span><br><span class="line">	|	|	|</span><br><span class="line">	|	|	|--virNetSocketNewListenUNIX&#123;Creating new UNIX server path=&#x27;/usr/local/var/run/libvirt/libvirt-sock&#x27;&#125;</span><br><span class="line">	|	|	|	|</span><br><span class="line">	|	|	|	|--virNetSocketNew&#123;生成一个监听的套接字&#125;</span><br><span class="line">	|	|	|</span><br><span class="line">	|	|	|--virNetServerServiceNewSocket(&amp;sock)&#123;得到virNetServerServicePtr变量&#125;</span><br><span class="line">	|	|		|</span><br><span class="line">	|	|		|--virNetSocketListen(svc-&gt;socks[i], max_queued_clients)&#123;对该socket的fd进行监听&#125;</span><br><span class="line">	|	|		|</span><br><span class="line">	|	|		|--virNetSocketAddIOCallback(svc-&gt;socks[i],virNetServerServiceAccept)&#123;循环调用&#125;</span><br><span class="line">	|	|		|	|</span><br><span class="line">	|	|		|	|--sock-&gt;watch = virEventAddHandle(sock-&gt;fd,virNetSocketEventHandle)</span><br><span class="line">	|	|		|	|	|</span><br><span class="line">	|	|		|	|	|--virNetSocketEventHandle&#123;这里进行event—loop监听，并注册监听函数；添加之后，并没直接进入event-loop&#125;</span><br><span class="line">	|	|		|	|		|</span><br><span class="line">	|	|		|	|		|--virNetServerServiceAccept&#123;如果有客户端连接service，则会调用该函数&#125;</span><br><span class="line">	|	|		|	|</span><br><span class="line">	|	|		|	|--sock-&gt;func = virNetServerServiceAccept&#123;server端处理消息的回调函数&#125;</span><br><span class="line">	|	|		|</span><br><span class="line">	|	|		|--将sock中的值赋值给virNetServerServicePtr变量并返回</span><br><span class="line">	|	|</span><br><span class="line">	|	|--virNetServerAddService&#123;将virNetServerServicePtr变量放进virNetServerPtr变量中，virNetServer对象包含多个virNetServerService对象&#125;</span><br><span class="line">	|		|</span><br><span class="line">	|		|--virNetServerServiceSetDispatcher</span><br><span class="line">	|			|</span><br><span class="line">	|			|--svc-&gt;dispatchFunc=virNetServerDispatchNewClient&#123;注册客户端的回调函数，用于处于从Unix得到的消息&#125;</span><br><span class="line">	|</span><br><span class="line">	|--virNetServerAddServiceTCP(针对的是tcp的socket文件)</span><br></pre></td></tr></table></figure>

<p>后续如果socket套接字接收到client端发送的连接之后，经过glib的event-loop调用，会进入到此函数中创建serverclient对象：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">virNetServerServiceAccept&#123;server端如果接收到客户端的连接，则会调用这个回调函数进行处理创建客户端对象&#125;</span><br><span class="line">	|</span><br><span class="line">	|--virNetSocketAccept(sock, &amp;clientsock)</span><br><span class="line">	|	|</span><br><span class="line">	|	|--fd = accept(sock-&gt;fd, &amp;remoteAddr.data.sa, &amp;remoteAddr.len)</span><br><span class="line">	|	|</span><br><span class="line">	|	|--*clientsock = virNetSocketNew(&amp;localAddr,&amp;remoteAddr, true, fd,)&#123;这里根据得到的客户端创建新的套接字&#125;</span><br><span class="line">	|</span><br><span class="line">	|--svc-&gt;dispatchFunc(svc, clientsock, svc-&gt;dispatchOpaque)</span><br><span class="line">		|</span><br><span class="line">		|--virNetServerDispatchNewClient&#123;这个正是上面注册的回调函数&#125;</span><br><span class="line">			|</span><br><span class="line">			|--virNetServerClientNew&#123;分配_virNetServerClient对象，用于接收socket传来的消息&#125;</span><br><span class="line">			|</span><br><span class="line">			|--virNetServerAddClient(srv, client)</span><br><span class="line">				|</span><br><span class="line">				|--virNetServerClientInit</span><br><span class="line">				|	|</span><br><span class="line">				|	|--virNetServerClientRegisterEvent</span><br><span class="line">				|		|</span><br><span class="line">				|		|--virNetServerClientCalculateHandleMode</span><br><span class="line">				|		|</span><br><span class="line">				|		|--virNetSocketAddIOCallback(client-&gt;sock, virNetServerClientDispatchEvent)</span><br><span class="line">				|			|</span><br><span class="line">				|			|--virEventAddHandle(virNetSocketEventHandle)&#123;添加event-loop事件，对客户端的连接进行监听&#125;</span><br><span class="line">				|</span><br><span class="line">				|--srv-&gt;clients[srv-&gt;nclients-1] = virObjectRef(client)&#123;这里是每来一个client，则就在server中的client指针中新增一个client，释放是在后面的while循环中&#125;</span><br><span class="line">				|</span><br><span class="line">				|--virNetServerClientSetDispatcher(client, virNetServerDispatchNewMessage, srv)</span><br><span class="line">				|	|</span><br><span class="line">				|	|--client-&gt;dispatchFunc=virNetServerDispatchNewMessage&#123;server=0x55882b100880 client=0x55882b1112d0 message=0x55882b114690&#125;</span><br><span class="line">				|</span><br><span class="line">				|--virNetServerClientInitKeepAlive(client, srv-&gt;keepaliveInterval, srv-&gt;keepaliveCount)&#123;设置客户端与服务端之间的连接超时时间&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>client如果向该socket发送消息，则会进入到event事件中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">virNetSocketEventHandle</span><br><span class="line">	|</span><br><span class="line">	|--virNetServerClientDispatchEvent</span><br><span class="line">		|</span><br><span class="line">		|--virNetServerClientDispatchWrite&#123;写&#125;</span><br><span class="line">		|</span><br><span class="line">		|--msg = virNetServerClientDispatchRead(client)&#123;读取消息&#125;</span><br><span class="line">		|</span><br><span class="line">		|--virNetServerClientDispatchMessage(client, msg)</span><br><span class="line">			|</span><br><span class="line">			|--client-&gt;dispatchFunc(client, msg, client-&gt;dispatchOpaque)</span><br><span class="line">				|</span><br><span class="line">				|--virNetServerDispatchNewMessage</span><br><span class="line">					|</span><br><span class="line">					|--virThreadPoolSendJob&#123;发送信号量，调用线程池去处理&#125;</span><br><span class="line">					|</span><br><span class="line">					|--进入到另外一个线程virNetServerHandleJob&#123;server=0x55882b100880 client=0x55882b1112d0 message=0x55882b114690 prog=0x55882b109c10&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>总结：<br>一条消息是如何被处理的？<br>1. 在libvirtd初始化的时候，会创建一个worker-pool(线程池)，在线程池中会等待信号量，如果得到信号量则会调用消息处理函数，进行真正的消息处理；<br>2. 但是谁发送的信号量呢？这个是客户端发来的消息处理的。<br>    在初始化的时候，会针对libvirt.sock文件创建一个监听事件，如果客户端连接这个套接字文件之后，则会调用监听事件注册的回调函数。<br>3. 2中注册的回调函数，会重新建立一个客户端和服务端的连接用于接收客户端发来的消息，并对该连接(socket)进行监听，并注册监听事件。<br>4. 如果客户端发送来消息，则会调用3中注册的事件处理函数，读取socket中的消息，并发送信号量调用1中的worker-pool中的线程处理函数。<br>5. 因为线程处理进程是多个的，因此不会阻塞会并发运行。<br>6. 对于每一个客户端的连接都会新生成一个serverclient对象，并对该对象中的socket进行监听。</p>
<h3 id="驱动获取"><a href="#驱动获取" class="headerlink" title="驱动获取"></a>驱动获取</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">daemonInitialize</span><br><span class="line">	|</span><br><span class="line">	|--virDriverLoadModule(&quot;network&quot;, &quot;networkRegister&quot;, false)</span><br><span class="line">	|</span><br><span class="line">	|--***</span><br><span class="line">	|</span><br><span class="line">	|--virDriverLoadModule(&quot;qemu&quot;, &quot;qemuRegister&quot;, false)&#123;加载qemu驱动&#125;</span><br><span class="line">		|</span><br><span class="line">		|--virFileFindResourceFull&#123;path=/usr/local/lib/libvirt/connection-driver/libvirt_driver_qemu.so&#125;</span><br><span class="line">		|</span><br><span class="line">		|--virModuleLoad(path,&quot;qemuRegister&quot;,false)</span><br><span class="line">			|</span><br><span class="line">			|--handle=virModuleLoadFile(path)</span><br><span class="line">			|</span><br><span class="line">			|--virModuleLoadFunc(&quot;qemuRegister&quot;)</span><br><span class="line">			|	|</span><br><span class="line">			|	|--regsym = dlsym(handle, &quot;qemuRegister&quot;)</span><br><span class="line">			|</span><br><span class="line">			|--(*regsym)()-&gt;qemuRegister()</span><br><span class="line">				|</span><br><span class="line">				|--virRegisterConnectDriver</span><br><span class="line">				|	|</span><br><span class="line">				|	|--virConnectDriverTab[virConnectDriverTabCount]=qemuConnectDriver&#123;对应的函数句柄&#125;</span><br><span class="line">				|</span><br><span class="line">				|--virRegisterStateDriver</span><br><span class="line">					|</span><br><span class="line">					|--virStateDriverTab[virStateDriverTabCount]=qemuStateDriver&#123;qemu驱动的初始化和终止函数&#125;</span><br></pre></td></tr></table></figure>

<h3 id="驱动初始化"><a href="#驱动初始化" class="headerlink" title="驱动初始化"></a>驱动初始化</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">daemonStateInit&#123;Initialize drivers &amp; then start accepting new clients from network&#125;</span><br><span class="line">	|</span><br><span class="line">	|--virThreadCreateFull&#123;thread-name=&quot;daemon-init&quot;&#125;</span><br><span class="line">		|</span><br><span class="line">		|--daemonRunStateInit</span><br><span class="line">			|</span><br><span class="line">			|--virIdentitySetCurrent</span><br><span class="line">			|</span><br><span class="line">			|--daemonInhibitCallback</span><br><span class="line">			|</span><br><span class="line">			|-virStateInitialize</span><br><span class="line">				|</span><br><span class="line">				|--virInitialize&#123;只初始化一次&#125;</span><br><span class="line">				|	|</span><br><span class="line">				|	|--virGlobalInit</span><br><span class="line">				|		|</span><br><span class="line">				|		|--testRegister</span><br><span class="line">				|		|</span><br><span class="line">				|		|--openvzRegister</span><br><span class="line">				|		|</span><br><span class="line">				|		|--hypervRegister</span><br><span class="line">				|		|</span><br><span class="line">				|		|--remoteRegister</span><br><span class="line">				|</span><br><span class="line">				|--virStateDriverTab[i]-&gt;stateInitialize&#123;这里是一个for循环，初始化之前注册的driver&#125;</span><br><span class="line">				|	|</span><br><span class="line">				|	|--qemuStateInitialize&#123;qemu_driver.c&#125;&#123;因为前面已经加载了对应的驱动函数&#125;</span><br><span class="line">				|</span><br><span class="line">				|--driversInitialized = true&#123;这里代表驱动的初始化已经完成&#125;</span><br><span class="line">				|</span><br><span class="line">				|--virNetDaemonUpdateServices(dmn, true)&#123;Only now accept clients from network&#125;</span><br><span class="line">					|</span><br><span class="line">					|--virHashForEach(dmn-&gt;servers, daemonServerUpdateServices, &amp;enabled)</span><br><span class="line">						|</span><br><span class="line">						|--daemonServerUpdateServices</span><br><span class="line">							|</span><br><span class="line">							|--virNetServerUpdateServices(srv, *enable)</span><br></pre></td></tr></table></figure>

<h3 id="event事件运行"><a href="#event事件运行" class="headerlink" title="event事件运行"></a>event事件运行</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">virNetDaemonRun</span><br><span class="line">	|</span><br><span class="line">	|--进入while(1)循环</span><br><span class="line">		|</span><br><span class="line">		|--virEventRunDefaultImpl&#123;这里是运行poll去检测eventloop.handles中的每个描述符的事件，如果有事件发生就会调用回调函数去处理事件，但是未看出来&#125;</span><br><span class="line">		|	|</span><br><span class="line">		|	|--virEventGLibRunOnce</span><br><span class="line">		|		|</span><br><span class="line">		|		|--g_main_context_iteration(NULL, TRUE)&#123;该函数可以完成GMainContext的单次迭代&#125;</span><br><span class="line">		|</span><br><span class="line">		|</span><br><span class="line">		|--virHashForEach(dmn-&gt;servers, daemonServerProcessClients, NULL)&#123;这里处理客户端，因为libvirtd也需要连接其他的libvirtd&#125;</span><br><span class="line">		|	|</span><br><span class="line">		|	|--for循环调用</span><br><span class="line">		|		|</span><br><span class="line">		|		|--daemonServerProcessClients(servers[i]-&gt;payload, servers[i]-&gt;name)</span><br><span class="line">		|			|</span><br><span class="line">		|			|--virNetServerProcessClients</span><br><span class="line">		|				|</span><br><span class="line">		|				|--判断client-&gt;wantClose 是否为true，是，则会主动关闭client</span><br><span class="line">		|</span><br><span class="line">		|--dmn-&gt;quit&#123;判断是否是退出&#125;</span><br><span class="line">			|</span><br><span class="line">			|--virThreadCreateFull(&amp;shutdownThread, true, daemonShutdownWait，&quot;daemon-shutdown&quot;)</span><br><span class="line">				|</span><br><span class="line">				|--daemonShutdownWait&#123;创建新的&quot;daemon-shutdown&quot;线程去处理资源&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LIBVIRT</category>
      </categories>
      <tags>
        <tag>libvirt</tag>
      </tags>
  </entry>
  <entry>
    <title>libvirt日志配置</title>
    <url>/2022/07/03/libvirt%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="libvirt配置文件详解"><a href="#libvirt配置文件详解" class="headerlink" title="libvirt配置文件详解"></a>libvirt配置文件详解</h3><h4 id="配置文件：-etc-libvirt-libvirtd-conf"><a href="#配置文件：-etc-libvirt-libvirtd-conf" class="headerlink" title="配置文件：/etc/libvirt/libvirtd.conf"></a>配置文件：/etc/libvirt/libvirtd.conf</h4><span id="more"></span>

<p><strong>日志控制</strong></p>
<p> 日志级别: 4 errors, 3 warnings, 2 information, 1 debug<br> 基本上debug级别可以记录所有日志信息<br> 注意: <br>     journald会锁定libvirt守护进行，限制日志记录级别，如果想监控debug级别日志，必须显式配置到“log_outputs”选项中，<br>     否则，只有information级别的日志会被记录。<br>     如果日志级别设置为2，则通过log_outputs获取不到1 debug级别的日志。<br>     默认情况下，不会将日志输出到journald中，也不会输出到其它地方。</p>
<p><code>log_level = 1</code></p>
<p><strong>日志过滤</strong><br> <br> 日志过滤允许对给定类别的日志选择特定日志级别。<br> 过滤格式可以是如下的一种:<br>    x:name<br>    x:+name<br>    当name字符串匹配到源文件名，比如：“remote”、“qemu”、“util/json”，“+”前缀会告诉libvirt去记录匹配名字的调用栈日志。<br>      x为匹配日志的最低级别:<br>    1: DEBUG<br>    2: INFO<br>    3: WARNING<br>    4: ERROR</p>
<p> 多个过滤器可以同时使用，只需要用空格隔开就行。<br> 示例如下：<br>     只从remote层获取警告和错误信息，并且从event层获取错误信息。</p>
<p><code>log_filters=&quot;3:remote 4:event&quot;</code></p>
<p><strong>日志输出</strong><br> <br> 日志输出可以是如下的几个地方：<br> 日志输出配置格式如下:<br>    x:stderr<br>      输出到标准错误输出中<br>    x:syslog:name<br>      使用自定义的name标识符，输出到系统日志<br>    x:file:file_path<br>      输出到指定路径的文件中<br>    x:journald<br>      输出到journald日志系统中<br> x代表最小的日志输出过滤级别<br>    1: DEBUG<br>    2: INFO<br>    3: WARNING<br>    4: ERROR</p>
<p> 可以同时定义多个输出，只需要用空格分开就行。<br> 注意：<br>     这里要保证日志级别大于等于log_level中的配置，否则无效<br> 例如：使用libvirtd标识记录WARNING以上日志信息到syslog中</p>
<p><code>log_outputs=&quot;3:syslog:libvirtd&quot;</code></p>
<p> 同时将日志记录到libvirtd.log文件和journald（可通过journalctl -u libvirtd来查看）中。</p>
<p><code>log_outputs=&quot;3:file:/var/log/libvirt/libvirtd.log 3:journald&quot;</code></p>
<h4 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h4><p>1、编辑文件 /etc/libvirt/libvirtd.conf，修改如下行，将libvirt调试日志输出到/var/log/libvirt/libvirtd.log文件中：<br>log_level=1</p>
<p>log_outputs=”1:file:/var/log/libvirt/libvirtd.log”</p>
<p>2、重启libvirtd服务使配置生效。</p>
<p>service libvirtd restart</p>
]]></content>
      <categories>
        <category>LIBVIRT</category>
      </categories>
      <tags>
        <tag>log</tag>
      </tags>
  </entry>
  <entry>
    <title>增加一个virsh命令</title>
    <url>/2022/07/02/%E5%A2%9E%E5%8A%A0%E4%B8%80%E4%B8%AAvirsh%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="libvirt-简介"><a href="#libvirt-简介" class="headerlink" title="libvirt 简介"></a>libvirt 简介</h2><p>libvirt 是用于管理虚拟化平台的开源API、后台程序和管理工具。</p>
<span id="more"></span>
<p>它对上层云管平台提供一套 API 接口，libvirt 也自带了一个 virsh 工具可以用来控制虚机的生命周期，包括创建、删除、修改虚机。</p>
<p>本文中使用的 libvirt 版本为 7.3.0。</p>
<h2 id="libvirt-命令增添步骤"><a href="#libvirt-命令增添步骤" class="headerlink" title="libvirt 命令增添步骤"></a>libvirt 命令增添步骤</h2><p>目前 libvirt 已经提供了强大的 API 支持，但由于云上环境比较复杂，有时需要新定义一个 libvirt API 接口。</p>
<p>由于每添加一个 API 接口几乎就要添加一个新的 RPC 调用，所以添加的文件非常多。</p>
<p>以增添一个 <code>cmdHelloWorld</code> 为例，总共包括以下步骤：</p>
<ol>
<li> virsh 命令的添加</li>
<li> API 接口的添加</li>
<li> RPC 的添加</li>
</ol>
<p>由于添加 API 接口的步骤过长，本文先给大家介绍如何添加一个新的 virsh 命令。</p>
<h2 id="增添一个-virsh-命令"><a href="#增添一个-virsh-命令" class="headerlink" title="增添一个 virsh 命令"></a>增添一个 virsh 命令</h2><p>所有 virsh 命令的相应函数及其后传递的命令行参数都是在 <code>virsh-domain.c</code> 中。</p>
<p>virsh 命令是指 virsh 后面跟的第一个命令行参数。本文我们以 <code>virsh helloworld</code> 为例教大家如何添加一个 helloworld 命令。</p>
<h3 id="增添-helloworld-函数-cmdHelloWorld"><a href="#增添-helloworld-函数-cmdHelloWorld" class="headerlink" title="增添 helloworld 函数 cmdHelloWorld"></a>增添 helloworld 函数 cmdHelloWorld</h3><p>命令的响应函数是 <code>cmdHelloWorld</code>。也就是执行 <code>virsh helloworld</code> 后将调用的函数。</p>
<p>这个函数由 virsh 进程调用，最终调用 <code>cmdHelloWorld</code>。</p>
<p><code>cmdHelloWorld</code> 再调用 RPC 与计算结点的守护进程 libvirtd 交互。</p>
<h3 id="为-helloworld-增添新的命令行参数"><a href="#为-helloworld-增添新的命令行参数" class="headerlink" title="为 helloworld 增添新的命令行参数"></a>为 helloworld 增添新的命令行参数</h3><p><code>virsh helloworld</code> 后我们设置了以下几个命令行参数：</p>
<ul>
<li>  <code>--local</code>：表示与本地的 libvirtd 相连。</li>
<li>  <code>--help</code>：显示帮助信息。</li>
</ul>
<p>libvirt 描述命令行参数是用 <code>vshCmdOptDef</code> 数组表示，也就是 <code>--local</code> 要添加到 <code>vshCmdOptDef</code> 数组中。</p>
<p>而 <code>virsh helloworld --help</code> 要显示的信息添加到 <code>vshCmdInfo</code> 数组中。</p>
<h3 id="相应代码实现"><a href="#相应代码实现" class="headerlink" title="相应代码实现"></a>相应代码实现</h3><h4 id="命令行参数实现"><a href="#命令行参数实现" class="headerlink" title="命令行参数实现"></a>命令行参数实现</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static const vshCmdInfo info_helloworld[] = &#123;</span><br><span class="line">    &#123;.name = &quot;help&quot;,</span><br><span class="line">     .data = N_(&quot;Print Hello World&quot;)&#125;,</span><br><span class="line">    &#123;.name = NULL&#125;</span><br><span class="line">&#125;;</span><br><span class="line">static const vshCmdOptDef opts_helloworld[] = &#123;</span><br><span class="line">    &#123;.name = &quot;local&quot;,</span><br><span class="line">     .type = VSH_OT_BOOL,</span><br><span class="line">     .help = N_(&quot;print Hello World in local.&quot;)&#125;,</span><br><span class="line">    &#123;.name = NULL&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>vshCmdOptDef opts_helloworld[]</code>：表示的是 <code>virsh helloworld</code> 后要接的两个命令行参数的描述。 <code>vshCmdInfo info_helloworld[]</code>: 是 <code>virsh helloworld --help</code> 所显示的描述打印。</p>
<h4 id="cmdHelloWorld-实现"><a href="#cmdHelloWorld-实现" class="headerlink" title="cmdHelloWorld 实现"></a>cmdHelloWorld 实现</h4><p>为了让示例程序最简单化，我们把virsh helloworld 的工作就是打印hello world字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static bool</span><br><span class="line">cmdHelloWorld(vshControl *ctl, const vshCmd *cmd)</span><br><span class="line">&#123;</span><br><span class="line">    bool ret = false;</span><br><span class="line">    char *buffer;</span><br><span class="line">    if (!vshCommandOptBool(cmd, &quot;local&quot;))</span><br><span class="line">        goto cleanup;</span><br><span class="line">    vshPrintExtra(ctl, _(&quot;hello, world\n&quot;));</span><br><span class="line">    ret = true;</span><br><span class="line">    cleanup:</span><br><span class="line">        return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="把-helloworld-命令添加进-vshCmdDef-domManagementCmds-中"><a href="#把-helloworld-命令添加进-vshCmdDef-domManagementCmds-中" class="headerlink" title="把 helloworld 命令添加进 vshCmdDef domManagementCmds[] 中"></a>把 helloworld 命令添加进 vshCmdDef domManagementCmds[] 中</h4><p>virsh 命令的命令行和处理函数都要注册到 <code>domManagementCmds[]</code> 中。</p>
<p>我们把刚刚添加的数据结构 <code>vshCmdOptDef</code>、<code>vshCmdInfo</code> 还有处理函数 <code>cmdHelloWorld</code> 添加到 <code>domManagementCmds[]</code> 中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const vshCmdDef domManagementCmds[] = &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#123;.name = &quot;helloworld&quot;,</span><br><span class="line">    .handler = cmdHelloWorld,</span><br><span class="line">    .opts = opts_helloworld,</span><br><span class="line">    .info = info_helloworld,</span><br><span class="line">    .flags = 0</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="编译、调试并运行新增的命令"><a href="#编译、调试并运行新增的命令" class="headerlink" title="编译、调试并运行新增的命令"></a>编译、调试并运行新增的命令</h3><p>centos 佩带的 libvirt 的 src.rpm 包的编译使用的是 spec 文件, 执行 <code>rpmbuild -ba libvirt.spec</code> 的时候会把配置、编译一气合成。</p>
<p>但当我们对自己修改的 libvirt 代码配置的时候，最好不要用 centos 的 spec 里的配置，如果按照 spec 里的配置，在启动我们的 libvirtd 的时候还要先执行 <code>systemctl stop libvirtd</code> 把系统的 libvirtd 的进程停掉。</p>
<p>所以下面分享一下我自己配置和调试 libvirt 的技巧。</p>
<h4 id="配置、编译和安装过程"><a href="#配置、编译和安装过程" class="headerlink" title="配置、编译和安装过程"></a>配置、编译和安装过程</h4><p>配置不加任何参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./configure</span><br></pre></td></tr></table></figure>

<p>编译就不用多说了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make -j 50</span><br></pre></td></tr></table></figure>

<p>后面这步很重要，每次编译后，都要重新卸载再进行安装，否则新编译的代码可能不会出现在 libvirtd 当中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make uninstall</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h4 id="手动启动-libvirtd"><a href="#手动启动-libvirtd" class="headerlink" title="手动启动 libvirtd"></a>手动启动 libvirtd</h4><p>libvirtd 是 libvirt 的守护进程，libvirt 的 API 接口几乎都是通过 RPC 调用链接到 libvirtd。virsh 命令就像一个 client 端，libvirtd 是服务端，virsh 的执行需要依靠 libvirtd。所以我们需要把 libvirtd 手动的拉起来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./daemon/libvirtd &amp;</span><br></pre></td></tr></table></figure>

<h4 id="使用的virsh-文件的路径"><a href="#使用的virsh-文件的路径" class="headerlink" title="使用的virsh 文件的路径"></a>使用的virsh 文件的路径</h4><p>使用 <code>./tools/.libs/virsh</code> 命令行执行。</p>
<p>注意，用 gdb 跟踪时使用 <code>./tools/.libs/virsh</code>，不要使用 <code>./tools/virsh</code>，因为 <code>./tools/virsh</code> 只是个脚本。</p>
<h4 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h4><p>执行结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># virsh helloworld --local</span><br><span class="line">hello, world</span><br></pre></td></tr></table></figure>

<h2 id="添加一个-API-接口"><a href="#添加一个-API-接口" class="headerlink" title="添加一个 API 接口"></a>添加一个 API 接口</h2><p>上面我们讲过了创建 libvirt API 接口的完整步骤，并且讲述了添加一个新的 virsh 命令的步骤。</p>
<p>但是添加的 virsh 命令并没有调用 API 接口。而真正的 virsh 命令一般都是借助 libvirt 的 API 接口来完成的。</p>
<p>下面就为大家介绍如何添加一个 API 接口，并且介绍 API 接口是如何通过 RPC 调用与守护进程 libvirtd 通信的。</p>
<h3 id="完整的-API-函数流程"><a href="#完整的-API-函数流程" class="headerlink" title="完整的 API 函数流程"></a>完整的 API 函数流程</h3><p><img src="8ce7f2070a2b17bade2e4cad7e74f0a6f903685dad6421e6b9a5485e573979b9.png" alt="picture 0">  </p>
<h3 id="添加-virConnectHelloWorld-函数"><a href="#添加-virConnectHelloWorld-函数" class="headerlink" title="添加 virConnectHelloWorld 函数"></a>添加 virConnectHelloWorld 函数</h3><h4 id="libvirt-domain-c"><a href="#libvirt-domain-c" class="headerlink" title="libvirt-domain.c"></a>libvirt-domain.c</h4><p>上一节中实现的 <code>cmdHelloWorld</code> 函数没有调用任何 libvirt API。</p>
<p>但实际上 virsh 命令都是调用 API 函数来实现功能的，同时这个文件里的函数也会给上层业务调用。</p>
<p>例如在云服务上创建虚机都是直接调用 <code>virDomainCreateXML</code> 函数，并不是通过 <code>virsh create aaa.xml</code> 这种方式。</p>
<p>下面给出 <code>cmdHelloWorld</code> 的完整实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extern int virConnectHelloWorld(virConnectPtr dconn, char **printout);</span><br><span class="line"></span><br><span class="line">static bool</span><br><span class="line">cmdHelloWorld(vshControl *ctl, const vshCmd *cmd)</span><br><span class="line">&#123;</span><br><span class="line">    bool ret = false;</span><br><span class="line">    virshControlPtr priv = ctl-&gt;privData;</span><br><span class="line">    char *printout = NULL;</span><br><span class="line">    </span><br><span class="line">    if (!vshCommandOptBool(cmd, &quot;local&quot;))</span><br><span class="line">        goto cleanup;</span><br><span class="line"></span><br><span class="line">    if(virConnectHelloWorld(priv-&gt;conn, &amp;printout) &lt; 0) &#123;</span><br><span class="line">        vshError(ctl, _(&quot;Failed to say HelloWorld&quot;));</span><br><span class="line">        goto cleanup;</span><br><span class="line">    &#125;</span><br><span class="line">    vshPrintExtra(ctl, _(&quot;%s&quot;), printout);</span><br><span class="line">    ret = true;</span><br><span class="line">cleanup:</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="src-libvirt-public-syms"><a href="#src-libvirt-public-syms" class="headerlink" title="src/libvirt_public.syms"></a>src/libvirt_public.syms</h4><p>在 <code>virsh-domain.c</code> 中加入了 <code>virConnectHelloWorld</code> 的函数声明，但在编译过程中还是会报错。原因是要在 <code>libvirt_public.syms</code> 文件中加入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LIBVIRT_7.3.0 &#123;</span><br><span class="line">    global:</span><br><span class="line">        virConnectHelloWorld;</span><br><span class="line">&#125; LIBVIRT_7.2.0;</span><br></pre></td></tr></table></figure>


<h2 id="添加一个-RPC-调用"><a href="#添加一个-RPC-调用" class="headerlink" title="添加一个 RPC 调用"></a>添加一个 RPC 调用</h2><h3 id="添加-RPC-client-调用"><a href="#添加-RPC-client-调用" class="headerlink" title="添加 RPC client 调用"></a>添加 RPC client 调用</h3><p>libvirt API 完整的函数流程中是要通过 RPC 调用和 libvirtd 进行通信。</p>
<p>下面我们把实现完全的代码贴上:</p>
<p><code>virConnectHelloWorld</code> 的入参 <code>virConnectPtr dconn</code> 中的 driver 是一个很关键的字段。描述了 RPC 调用的 client 端和 server 端回调函数的声明。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct _virConnect &#123;</span><br><span class="line">    ...</span><br><span class="line">    virHypervisorDriverPtr driver;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="src-driver-hypervisor-h"><a href="#src-driver-hypervisor-h" class="headerlink" title="src/driver-hypervisor.h"></a>src/driver-hypervisor.h</h4><p>给 <code>_virHypervisorDriver</code> 加入 <code>virDrvConnectHelloWorld</code> 字段，并且添加 <code>virDrvConnectHelloWorld</code> 的定义。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef int</span><br><span class="line">(*virDrvConnectHelloWorld) (virConnectPtr conn, char **printout);</span><br><span class="line"></span><br><span class="line">struct _virHypervisorDriver &#123;</span><br><span class="line">    ...</span><br><span class="line">    virDrvConnectHelloWorld connectHelloWorld;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="src-remote-remote-driver-c"><a href="#src-remote-remote-driver-c" class="headerlink" title="src/remote/remote_driver.c"></a>src/remote/remote_driver.c</h4><p>在 <code>driver-hypervisor.h</code> 中只是给 <code>_virHypervisorDriver</code> 添加了一个字段，还需要给出 RPC 调用的实现函数。</p>
<p><code>virConnectHelloWorld</code> 函数作为 RPC 的 client 端的实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int remoteConnectHelloWorld(virConnectPtr conn, char **printout)</span><br><span class="line">&#123;</span><br><span class="line">    int rv = -1;</span><br><span class="line">    remote_connect_hello_world_ret ret;</span><br><span class="line">    struct private_data *priv = conn-&gt;privateData;</span><br><span class="line">    remoteDriverLock(priv);</span><br><span class="line">    memset(&amp;ret, 0, sizeof(ret));</span><br><span class="line">    if (call(conn, priv, 0, REMOTE_PROC_CONNECT_HELLO_WORLD,</span><br><span class="line">            (xdrproc_t) xdr_void,</span><br><span class="line">            (char *) NULL,</span><br><span class="line">            (xdrproc_t) xdr_remote_connect_hello_world_ret,</span><br><span class="line">            (char *) &amp;ret) == -1)</span><br><span class="line">        goto done;</span><br><span class="line">    if (ret.printout == NULL)</span><br><span class="line">        goto error;</span><br><span class="line">    *printout = ret.printout;</span><br><span class="line">    rv = 0;</span><br><span class="line">done:</span><br><span class="line">    remoteDriverUnlock(priv);</span><br><span class="line">    return rv;</span><br><span class="line">error:</span><br><span class="line">    rv = -1;</span><br><span class="line">    goto done;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static virHypervisorDriver hypervisor_driver = &#123;</span><br><span class="line">    ...</span><br><span class="line">    .connectHelloWorld = remoteConnectHelloWorld, /* 7.3.0 */</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>函数的开头使用了 RPC 请求的返回值结构体 <code>remote_connect_hello_world_ret</code>，这个结构体的定义是自动生成的，模板会在 <code>remote_protocol.x</code> 中给出。</p>
<p>call 函数中的入参 <code>REMOTE_PROC_CONNECT_HELLO_WORLD</code> 是RPC 请求调用号。也是在 <code>remote_protocol.x</code> 中添加。</p>
<p>最后从 <code>ret.printout</code> 取出来自 libvirtd 返回的字符串。</p>
<p>注意: 给 <code>hypervisor_driver-&gt;connectHelloWorld</code> 赋值时, 后面的 <code>/* 7.3.0 */</code> 版本号必须要加上不然 <code>hvsupport.pl</code> 在执行的时候会报错。</p>
<h4 id="src-remote-remote-protocol-x"><a href="#src-remote-remote-protocol-x" class="headerlink" title="./src/remote/remote_protocol.x"></a>./src/remote/remote_protocol.x</h4><p>增添 <code>remote_connect_hello_world_ret</code> 的模板，并且在 <code>enum remote_procedure</code> 的枚举类型中给出 RPC 号的具体数值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct remote_connect_hello_world_ret &#123;</span><br><span class="line">    remote_nonnull_string printout;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">enum remote_procedure &#123;</span><br><span class="line">    /**</span><br><span class="line">    * @generate: none</span><br><span class="line">    * @acl: connect:read</span><br><span class="line">    */</span><br><span class="line">    REMOTE_PROC_CONNECT_HELLO_WORLD = 700</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="src-rpc-gendispatch-pl"><a href="#src-rpc-gendispatch-pl" class="headerlink" title="./src/rpc/gendispatch.pl"></a>./src/rpc/gendispatch.pl</h4><p>以上几个文件会被 <code>gendispatch.pl</code> 文件解析自动生成 <code>remote_protocol.h</code>，<code>remote_protocol.c</code> 和 <code>remote_daemon_dispatch_stubs.h</code> 文件。</p>
<p>这个文件在运行时会检查上面内容添加是否齐全。</p>
<h3 id="添加-RPC-server-端调用"><a href="#添加-RPC-server-端调用" class="headerlink" title="添加 RPC server 端调用"></a>添加 RPC server 端调用</h3><p>libvirtd 充当 RPC 调用的 server 端，<code>remoteDispatchConnectHelloWorld</code> 函数是由 libvirtd 执行的，作为 server 端的响应函数。</p>
<h4 id="src-remote-remote-daemon-dispatch-stubs-h"><a href="#src-remote-remote-daemon-dispatch-stubs-h" class="headerlink" title="src/remote/remote_daemon_dispatch_stubs.h"></a>src/remote/remote_daemon_dispatch_stubs.h</h4><p>增添了 <code>remote_protocol.x</code> 编译后系统会自动生成 <code>remote_dispatch.h</code> 文件，并自其中自动生成 server 端 RPC 处理函数：<code>remoteDispatchConnectHelloWorldHelper</code>。</p>
<p>同时 <code>remote_daemon_dispatch_stubs.h</code> 中会添加 <code>remoteDispatchConnectHelloWorld</code> 函数声明。</p>
<p><code>remoteDispatchConnectHelloWorld</code> 函数作为 RPC server 端的响应函数需要在 <code>remote_daemon_dispatch_stubs.h</code> 中自己手动实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int</span><br><span class="line">remoteDispatchConnectHelloWorld(virNetServerPtr server ATTRIBUTE_UNUSED,</span><br><span class="line">                            virNetServerClientPtr client ATTRIBUTE_UNUSED,</span><br><span class="line">                            virNetMessagePtr msg ATTRIBUTE_UNUSED,</span><br><span class="line">                            virNetMessageErrorPtr rerr,</span><br><span class="line">                            remote_connect_hello_world_ret *ret)</span><br><span class="line">&#123;</span><br><span class="line">    char *printout = NULL;</span><br><span class="line">    int rv = -1;</span><br><span class="line">    struct daemonClientPrivate *priv =</span><br><span class="line">    virNetServerClientGetPrivateData(client);</span><br><span class="line">    if (!priv-&gt;conn) &#123;</span><br><span class="line">        virReportError(VIR_ERR_INTERNAL_ERROR, &quot;%s&quot;, _(&quot;connection not open&quot;));</span><br><span class="line">        goto cleanup;</span><br><span class="line">    &#125;</span><br><span class="line">    rv = virConnectHelloWorld(priv-&gt;conn, &amp;printout);</span><br><span class="line">    if(rv &lt; 0)</span><br><span class="line">        goto cleanup;</span><br><span class="line">    ret-&gt;printout = printout;</span><br><span class="line">cleanup:</span><br><span class="line">    if (rv &lt; 0)</span><br><span class="line">        virNetMessageSaveError(rerr);</span><br><span class="line">    return rv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="src-qemu-qemu-driver-c"><a href="#src-qemu-qemu-driver-c" class="headerlink" title="src/qemu/qemu_driver.c"></a>src/qemu/qemu_driver.c</h4><p>libvirtd 是 RPC 的 server 端，<code>virConnectHelloWorld</code> 采用的 <code>connectHelloWorld</code> 回调函数与 RPC clinet 端不同。</p>
<p>这里要新添加一个 <code>qemuConnectHelloWorld</code> 函数作为 RPC server 端的处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int qemuConnectHelloWorld(virConnectPtr conn, char **printout)</span><br><span class="line">&#123;</span><br><span class="line">    if(VIR_STRDUP(*printout, &quot;hello, world&quot;) &lt; 0)</span><br><span class="line">        return -1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static virHypervisorDriver qemuHypervisorDriver = &#123;</span><br><span class="line">    ...</span><br><span class="line">    .connectHelloWorld = qemuConnectHelloWorld, /* 7.3.0 */</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="执行结果-1"><a href="#执行结果-1" class="headerlink" title="执行结果"></a>执行结果</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># virsh helloworld --local</span><br><span class="line">hello, world</span><br></pre></td></tr></table></figure>

<p>执行结果与第 3 节一样，但不同的是这次的 “hello, world” 是 virsh 命令通过 RPC 调用从 libvirtd 守护进程中拿过来的。</p>
]]></content>
      <categories>
        <category>LIBVIRT</category>
      </categories>
      <tags>
        <tag>virsh</tag>
      </tags>
  </entry>
  <entry>
    <title>docker proxy</title>
    <url>/2022/07/01/docker-proxy/</url>
    <content><![CDATA[<h3 id="配置-HTTP-HTTPS-网络代理"><a href="#配置-HTTP-HTTPS-网络代理" class="headerlink" title="配置 HTTP/HTTPS 网络代理"></a>配置 HTTP/HTTPS 网络代理</h3><p>使用Docker的过程中，因为网络原因，通常需要使用 HTTP/HTTPS 代理来加速镜像拉取。</p>
<span id="more"></span>

<h3 id="Docker-Daemon-配置方式一"><a href="#Docker-Daemon-配置方式一" class="headerlink" title="Docker Daemon 配置方式一"></a>Docker Daemon 配置方式一</h3><p>“docker pull” 命令是由 dockerd 守护进程执行。而 dockerd 守护进程是由 systemd 管理。因此，如果需要在执行 “docker pull” 命令时使用 HTTP/HTTPS 代理，需要通过 systemd 配置。</p>
<ul>
<li>为 dockerd 创建配置文件夹。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/systemd/system/docker.service.d</span><br></pre></td></tr></table></figure>

<ul>
<li>为 dockerd 创建 HTTP/HTTPS 网络代理的配置文件，文件路径是 /etc/systemd/system/docker.service.d/http-proxy.conf 。并在该文件中添加相关环境变量。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Service]</span><br><span class="line">Environment=&quot;HTTP_PROXY=http://10.20.18.78:7890&quot;</span><br><span class="line">Environment=&quot;HTTPS_PROXY=http://10.20.18.78:7890&quot;</span><br><span class="line">Environment=&quot;NO_PROXY=localhost,127.0.0.1,.example.com&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>刷新配置并重启 docker 服务。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<h3 id="Docker-Daemon-配置方式二"><a href="#Docker-Daemon-配置方式二" class="headerlink" title="Docker Daemon 配置方式二"></a>Docker Daemon 配置方式二</h3><p>/etc/docker/daemon.json, 添加如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-EOF</span><br><span class="line">&#123;</span><br><span class="line">        &quot;proxies&quot;: &#123;</span><br><span class="line">                &quot;http-proxy&quot;: &quot;http://10.20.18.78:7890&quot;,</span><br><span class="line">                &quot;https-proxy&quot;: &quot;http://10.20.18.78:7890&quot;,</span><br><span class="line">                &quot;no-proxy&quot;: &quot;*.cn,127.0.0.0/8,192.168.0.0/16,172.16.0.0/12,10.0.0.0/8&quot;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<p>📝Notes:</p>
<p>Docker Daemon 里的 no-proxy, 是支持 CIDR 格式的.</p>
<h3 id="为-docker-容器设置网络代理"><a href="#为-docker-容器设置网络代理" class="headerlink" title="为 docker 容器设置网络代理"></a>为 docker 容器设置网络代理</h3><p>在容器运行阶段，如果需要使用 HTTP/HTTPS 代理，可以通过更改 docker 客户端配置，或者指定环境变量的方式。</p>
<p>更改 docker 客户端配置：创建或更改 ~/.docker/config.json，并在该文件中添加相关配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> &quot;proxies&quot;:</span><br><span class="line"> &#123;</span><br><span class="line">   &quot;default&quot;:</span><br><span class="line">   &#123;</span><br><span class="line">     &quot;httpProxy&quot;: &quot;http://proxy.example.com:8080/&quot;,</span><br><span class="line">     &quot;httpsProxy&quot;: &quot;http://proxy.example.com:8080/&quot;,</span><br><span class="line">     &quot;noProxy&quot;: &quot;localhost,127.0.0.1,.example.com&quot;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者运行 “docker run” 命令时，指定相关环境变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HTTP_PROXY</span><br><span class="line">--env HTTP_PROXY=&quot;http://proxy.example.com:8080/&quot;</span><br><span class="line"></span><br><span class="line">HTTPS_PROXY</span><br><span class="line">--env HTTPS_PROXY=&quot;http://proxy.example.com:8080/&quot;</span><br><span class="line"></span><br><span class="line">NO_PROXY</span><br><span class="line">--env NO_PROXY=&quot;localhost,127.0.0.1,.example.com&quot;</span><br></pre></td></tr></table></figure>

<h3 id="为-docker-build-过程设置网络代理"><a href="#为-docker-build-过程设置网络代理" class="headerlink" title="为 docker build 过程设置网络代理"></a>为 docker build 过程设置网络代理</h3><p>在容器构建阶段，如果需要使用 HTTP/HTTPS 代理，可以通过指定 “docker build” 的环境变量，或者在 Dockerfile 中指定环境变量的方式。</p>
<p>使用 “–build-arg” 指定 “docker build” 的相关环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker build \</span><br><span class="line">    --build-arg &quot;HTTP_PROXY=http://proxy.example.com:8080/&quot; \</span><br><span class="line">    --build-arg &quot;HTTPS_PROXY=http://proxy.example.com:8080/&quot; \</span><br><span class="line">    --build-arg &quot;NO_PROXY=localhost,127.0.0.1,.example.com&quot; -t image_name:tag .</span><br></pre></td></tr></table></figure>

<h3 id="注册各个镜像库账号并登录"><a href="#注册各个镜像库账号并登录" class="headerlink" title="注册各个镜像库账号并登录"></a>注册各个镜像库账号并登录</h3><p>包括不限于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Docker Hub</span><br><span class="line">Quay.io</span><br><span class="line">GHCR.io (GitHub 的 Docker registry)</span><br><span class="line">gcr.io (Google Cloud 的 Registry)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>注册后，视情况不同，有的可以直接通过密码登录，有的需要申请 Token/Service Account 等专用密码。</p>
<p>注册过程略。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker login 登录</span><br><span class="line">Docker Hub 登录：</span><br><span class="line"></span><br><span class="line">echo &quot;&lt;password&gt;&quot; | docker login --username &lt;username&gt; --password-stdin&#x27;</span><br><span class="line">其他 Docker Registry 登录：</span><br><span class="line"></span><br><span class="line">echo &quot;&lt;password&gt;&quot; | docker login quay.io --username &lt;username&gt; --password-stdin</span><br><span class="line">echo &quot;&lt;password&gt;&quot; | docker login ghcr.io --username &lt;username&gt; --password-stdin</span><br><span class="line">echo &quot;&lt;password&gt;&quot; | docker login gcr.io --username &lt;username&gt; --password-stdin</span><br></pre></td></tr></table></figure>
<p>或者，也可以直接写入 ~/.docker/config.json 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;auths&quot;: &#123;</span><br><span class="line">    &quot;ghcr.io&quot;: &#123;</span><br><span class="line">      &quot;auth&quot;: &quot;&lt;auth&gt;&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;https://index.docker.io/v1/&quot;: &#123;</span><br><span class="line">      &quot;auth&quot;: &quot;&lt;auth&gt;&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;quay.io&quot;: &#123;</span><br><span class="line">      &quot;auth&quot;: &quot;&lt;auth&gt;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;auth&gt; 通过如下方式获得：</span><br><span class="line"></span><br><span class="line">echo -n &#x27;&lt;username&gt;:&lt;password&gt;&#x27; | base64</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>DOCKER</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>systemd详解</title>
    <url>/2022/07/01/systemd%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="一、开机启动"><a href="#一、开机启动" class="headerlink" title="一、开机启动"></a>一、开机启动</h2><p>对于那些支持 Systemd 的软件，安装的时候，会自动在<code>/usr/lib/systemd/system</code>目录添加一个配置文件。</p>
<p>如果你想让该软件开机启动，就执行下面的命令（以<code>httpd.service</code>为例）。</p>
<span id="more"></span>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ sudo systemctl enable httpd</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面的命令相当于在<code>/etc/systemd/system</code>目录添加一个符号链接，指向<code>/usr/lib/systemd/system</code>里面的<code>httpd.service</code>文件。</p>
<p>这是因为开机时，<code>Systemd</code>只执行<code>/etc/systemd/system</code>目录里面的配置文件。这也意味着，如果把修改后的配置文件放在该目录，就可以达到覆盖原始配置的效果。</p>
<h2 id="二、启动服务"><a href="#二、启动服务" class="headerlink" title="二、启动服务"></a>二、启动服务</h2><p>设置开机启动以后，软件并不会立即启动，必须等到下一次开机。如果想现在就运行该软件，那么要执行<code>systemctl start</code>命令。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ sudo systemctl start httpd</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>执行上面的命令以后，有可能启动失败，因此要用<code>systemctl status</code>命令查看一下该服务的状态。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ sudo systemctl status httpd</span><br><span class="line"></span><br><span class="line">httpd.service - The Apache HTTP Server</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/httpd.service; enabled)</span><br><span class="line">   Active: active (running) since 金 2014-12-05 12:18:22 JST; 7min ago</span><br><span class="line"> Main PID: 4349 (httpd)</span><br><span class="line">   Status: &quot;Total requests: 1; Current requests/sec: 0; Current traffic:   0 B/sec&quot;</span><br><span class="line">   CGroup: /system.slice/httpd.service</span><br><span class="line">           ├─4349 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           ├─4350 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           ├─4351 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           ├─4352 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           ├─4353 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           └─4354 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line"></span><br><span class="line">12月 05 12:18:22 localhost.localdomain systemd[1]: Starting The Apache HTTP Server...</span><br><span class="line">12月 05 12:18:22 localhost.localdomain systemd[1]: Started The Apache HTTP Server.</span><br><span class="line">12月 05 12:22:40 localhost.localdomain systemd[1]: Started The Apache HTTP Server.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面的输出结果含义如下。</p>
<blockquote>
<ul>
<li>  <code>Loaded</code>行：配置文件的位置，是否设为开机启动</li>
<li>  <code>Active</code>行：表示正在运行</li>
<li>  <code>Main PID</code>行：主进程ID</li>
<li>  <code>Status</code>行：由应用本身（这里是 httpd ）提供的软件当前状态</li>
<li>  <code>CGroup</code>块：应用的所有子进程</li>
<li>  日志块：应用的日志</li>
</ul>
</blockquote>
<h2 id="三、停止服务"><a href="#三、停止服务" class="headerlink" title="三、停止服务"></a>三、停止服务</h2><p>终止正在运行的服务，需要执行<code>systemctl stop</code>命令。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ sudo systemctl stop httpd.service</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>有时候，该命令可能没有响应，服务停不下来。这时候就不得不”杀进程”了，向正在运行的进程发出<code>kill</code>信号。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ sudo systemctl kill httpd.service</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>此外，重启服务要执行<code>systemctl restart</code>命令。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ sudo systemctl restart httpd.service</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="四、读懂配置文件"><a href="#四、读懂配置文件" class="headerlink" title="四、读懂配置文件"></a>四、读懂配置文件</h2><p>一个服务怎么启动，完全由它的配置文件决定。下面就来看，配置文件有些什么内容。</p>
<p>前面说过，配置文件主要放在<code>/usr/lib/systemd/system</code>目录，也可能在<code>/etc/systemd/system</code>目录。找到配置文件以后，使用文本编辑器打开即可。</p>
<p><code>systemctl cat</code>命令可以用来查看配置文件，下面以<code>sshd.service</code>文件为例，它的作用是启动一个 SSH 服务器，供其他用户以 SSH 方式登录。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ systemctl cat sshd.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=OpenSSH server daemon</span><br><span class="line">Documentation=man:sshd(8) man:sshd_config(5)</span><br><span class="line">After=network.target sshd-keygen.service</span><br><span class="line">Wants=sshd-keygen.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">EnvironmentFile=/etc/sysconfig/sshd</span><br><span class="line">ExecStart=/usr/sbin/sshd -D $OPTIONS</span><br><span class="line">ExecReload=/bin/kill -HUP $MAINPID</span><br><span class="line">Type=simple</span><br><span class="line">KillMode=process</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=42s</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>可以看到，配置文件分成几个区块，每个区块包含若干条键值对。</p>
<p>下面依次解释每个区块的内容。</p>
<h2 id="五、-Unit-区块：启动顺序与依赖关系。"><a href="#五、-Unit-区块：启动顺序与依赖关系。" class="headerlink" title="五、 [Unit] 区块：启动顺序与依赖关系。"></a>五、 [Unit] 区块：启动顺序与依赖关系。</h2><p><code>Unit</code>区块的<code>Description</code>字段给出当前服务的简单描述，<code>Documentation</code>字段给出文档位置。</p>
<p>接下来的设置是启动顺序和依赖关系，这个比较重要。</p>
<blockquote>
<p><code>After</code>字段：表示如果<code>network.target</code>或<code>sshd-keygen.service</code>需要启动，那么<code>sshd.service</code>应该在它们之后启动。</p>
</blockquote>
<p>相应地，还有一个<code>Before</code>字段，定义<code>sshd.service</code>应该在哪些服务之前启动。</p>
<p>注意，<code>After</code>和<code>Before</code>字段只涉及启动顺序，不涉及依赖关系。</p>
<p>举例来说，某 Web 应用需要 postgresql 数据库储存数据。在配置文件中，它只定义要在 postgresql 之后启动，而没有定义依赖 postgresql 。上线后，由于某种原因，postgresql 需要重新启动，在停止服务期间，该 Web 应用就会无法建立数据库连接。</p>
<p>设置依赖关系，需要使用<code>Wants</code>字段和<code>Requires</code>字段。</p>
<blockquote>
<p><code>Wants</code>字段：表示<code>sshd.service</code>与<code>sshd-keygen.service</code>之间存在”弱依赖”关系，即如果”sshd-keygen.service”启动失败或停止运行，不影响<code>sshd.service</code>继续执行。</p>
</blockquote>
<p><code>Requires</code>字段则表示”强依赖”关系，即如果该服务启动失败或异常退出，那么<code>sshd.service</code>也必须退出。</p>
<p>注意，<code>Wants</code>字段与<code>Requires</code>字段只涉及依赖关系，与启动顺序无关，默认情况下是同时启动的。</p>
<h2 id="六、-Service-区块：启动行为"><a href="#六、-Service-区块：启动行为" class="headerlink" title="六、[Service] 区块：启动行为"></a>六、[Service] 区块：启动行为</h2><p><code>Service</code>区块定义如何启动当前服务。</p>
<h3 id="6-1-启动命令"><a href="#6-1-启动命令" class="headerlink" title="6.1 启动命令"></a>6.1 启动命令</h3><p>许多软件都有自己的环境参数文件，该文件可以用<code>EnvironmentFile</code>字段读取。</p>
<blockquote>
<p><code>EnvironmentFile</code>字段：指定当前服务的环境参数文件。该文件内部的<code>key=value</code>键值对，可以用<code>$key</code>的形式，在当前配置文件中获取。</p>
</blockquote>
<p>上面的例子中，sshd 的环境参数文件是<code>/etc/sysconfig/sshd</code>。</p>
<p>配置文件里面最重要的字段是<code>ExecStart</code>。</p>
<blockquote>
<p><code>ExecStart</code>字段：定义启动进程时执行的命令。</p>
</blockquote>
<p>上面的例子中，启动<code>sshd</code>，执行的命令是<code>/usr/sbin/sshd -D $OPTIONS</code>，其中的变量<code>$OPTIONS</code>就来自<code>EnvironmentFile</code>字段指定的环境参数文件。</p>
<p>与之作用相似的，还有如下这些字段。</p>
<blockquote>
<ul>
<li>  <code>ExecReload</code>字段：重启服务时执行的命令</li>
<li>  <code>ExecStop</code>字段：停止服务时执行的命令</li>
<li>  <code>ExecStartPre</code>字段：启动服务之前执行的命令</li>
<li>  <code>ExecStartPost</code>字段：启动服务之后执行的命令</li>
<li>  <code>ExecStopPost</code>字段：停止服务之后执行的命令</li>
</ul>
</blockquote>
<p>请看下面的例子。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/bin/echo execstart1</span><br><span class="line">ExecStart=</span><br><span class="line">ExecStart=/bin/echo execstart2</span><br><span class="line">ExecStartPost=/bin/echo post1</span><br><span class="line">ExecStartPost=/bin/echo post2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面这个配置文件，第二行<code>ExecStart</code>设为空值，等于取消了第一行的设置，运行结果如下。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">execstart2</span><br><span class="line">post1</span><br><span class="line">post2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>所有的启动设置之前，都可以加上一个连词号（<code>-</code>），表示”抑制错误”，即发生错误的时候，不影响其他命令的执行。比如，<code>EnvironmentFile=-/etc/sysconfig/sshd</code>（注意等号后面的那个连词号），就表示即使<code>/etc/sysconfig/sshd</code>文件不存在，也不会抛出错误。</p>
<h3 id="6-2-启动类型"><a href="#6-2-启动类型" class="headerlink" title="6.2 启动类型"></a>6.2 启动类型</h3><p><code>Type</code>字段定义启动类型。它可以设置的值如下。</p>
<blockquote>
<ul>
<li>  simple（默认值）：<code>ExecStart</code>字段启动的进程为主进程</li>
<li>  forking：<code>ExecStart</code>字段将以<code>fork()</code>方式启动，此时父进程将会退出，子进程将成为主进程</li>
<li>  oneshot：类似于<code>simple</code>，但只执行一次，Systemd 会等它执行完，才启动其他服务</li>
<li>  dbus：类似于<code>simple</code>，但会等待 D-Bus 信号后启动</li>
<li>  notify：类似于<code>simple</code>，启动结束后会发出通知信号，然后 Systemd 再启动其他服务</li>
<li>  idle：类似于<code>simple</code>，但是要等到其他任务都执行完，才会启动该服务。一种使用场合是为让该服务的输出，不与其他服务的输出相混合</li>
</ul>
</blockquote>
<p>下面是一个<code>oneshot</code>的例子，笔记本电脑启动时，要把触摸板关掉，配置文件可以这样写。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Switch-off Touchpad</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=oneshot</span><br><span class="line">ExecStart=/usr/bin/touchpad-off</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面的配置文件，启动类型设为<code>oneshot</code>，就表明这个服务只要运行一次就够了，不需要长期运行。</p>
<p>如果关闭以后，将来某个时候还想打开，配置文件修改如下。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Switch-off Touchpad</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=oneshot</span><br><span class="line">ExecStart=/usr/bin/touchpad-off start</span><br><span class="line">ExecStop=/usr/bin/touchpad-off stop</span><br><span class="line">RemainAfterExit=yes</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面配置文件中，<code>RemainAfterExit</code>字段设为<code>yes</code>，表示进程退出以后，服务仍然保持执行。这样的话，一旦使用<code>systemctl stop</code>命令停止服务，<code>ExecStop</code>指定的命令就会执行，从而重新开启触摸板。</p>
<h3 id="6-3-重启行为"><a href="#6-3-重启行为" class="headerlink" title="6.3 重启行为"></a>6.3 重启行为</h3><p><code>Service</code>区块有一些字段，定义了重启行为。</p>
<blockquote>
<p><code>KillMode</code>字段：定义 Systemd 如何停止 sshd 服务。</p>
</blockquote>
<p>上面这个例子中，将<code>KillMode</code>设为<code>process</code>，表示只停止主进程，不停止任何sshd 子进程，即子进程打开的 SSH session 仍然保持连接。这个设置不太常见，但对 sshd 很重要，否则你停止服务的时候，会连自己打开的 SSH session 一起杀掉。</p>
<p><code>KillMode</code>字段可以设置的值如下。</p>
<blockquote>
<ul>
<li>  control-group（默认值）：当前控制组里面的所有子进程，都会被杀掉</li>
<li>  process：只杀主进程</li>
<li>  mixed：主进程将收到 SIGTERM 信号，子进程收到 SIGKILL 信号</li>
<li>  none：没有进程会被杀掉，只是执行服务的 stop 命令。</li>
</ul>
</blockquote>
<p>接下来是<code>Restart</code>字段。</p>
<blockquote>
<p><code>Restart</code>字段：定义了 sshd 退出后，Systemd 的重启方式。</p>
</blockquote>
<p>上面的例子中，<code>Restart</code>设为<code>on-failure</code>，表示任何意外的失败，就将重启sshd。如果 sshd 正常停止（比如执行<code>systemctl stop</code>命令），它就不会重启。</p>
<p><code>Restart</code>字段可以设置的值如下。</p>
<blockquote>
<ul>
<li>  no（默认值）：退出后不会重启</li>
<li>  on-success：只有正常退出时（退出状态码为0），才会重启</li>
<li>  on-failure：非正常退出时（退出状态码非0），包括被信号终止和超时，才会重启</li>
<li>  on-abnormal：只有被信号终止和超时，才会重启</li>
<li>  on-abort：只有在收到没有捕捉到的信号终止时，才会重启</li>
<li>  on-watchdog：超时退出，才会重启</li>
<li>  always：不管是什么退出原因，总是重启</li>
</ul>
</blockquote>
<p>对于守护进程，推荐设为<code>on-failure</code>。对于那些允许发生错误退出的服务，可以设为<code>on-abnormal</code>。</p>
<p>最后是<code>RestartSec</code>字段。</p>
<blockquote>
<p><code>RestartSec</code>字段：表示 Systemd 重启服务之前，需要等待的秒数。上面的例子设为等待42秒。</p>
</blockquote>
<h2 id="七、-Install-区块"><a href="#七、-Install-区块" class="headerlink" title="七、[Install] 区块"></a>七、[Install] 区块</h2><p><code>Install</code>区块，定义如何安装这个配置文件，即怎样做到开机启动。</p>
<blockquote>
<p><code>WantedBy</code>字段：表示该服务所在的 Target。</p>
</blockquote>
<p><code>Target</code>的含义是服务组，表示一组服务。<code>WantedBy=multi-user.target</code>指的是，sshd 所在的 Target 是<code>multi-user.target</code>。</p>
<p>这个设置非常重要，因为执行<code>systemctl enable sshd.service</code>命令时，<code>sshd.service</code>的一个符号链接，就会放在<code>/etc/systemd/system</code>目录下面的<code>multi-user.target.wants</code>子目录之中。</p>
<p>Systemd 有默认的启动 Target。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ systemctl get-default</span><br><span class="line">multi-user.target</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面的结果表示，默认的启动 Target 是<code>multi-user.target</code>。在这个组里的所有服务，都将开机启动。这就是为什么<code>systemctl enable</code>命令能设置开机启动的原因。</p>
<p>使用 Target 的时候，<code>systemctl list-dependencies</code>命令和<code>systemctl isolate</code>命令也很有用。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 查看 multi-user.target 包含的所有服务</span><br><span class="line">$ systemctl list-dependencies multi-user.target</span><br><span class="line"></span><br><span class="line"># 切换到另一个 target</span><br><span class="line"># shutdown.target 就是关机状态</span><br><span class="line">$ sudo systemctl isolate shutdown.target</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>一般来说，常用的 Target 有两个：一个是<code>multi-user.target</code>，表示多用户命令行状态；另一个是<code>graphical.target</code>，表示图形用户状态，它依赖于<code>multi-user.target</code>。官方文档有一张非常清晰的 <a href="https://www.freedesktop.org/software/systemd/man/bootup.html#System%20Manager%20Bootup">Target 依赖关系图</a>。</p>
<h2 id="八、Target-的配置文件"><a href="#八、Target-的配置文件" class="headerlink" title="八、Target 的配置文件"></a>八、Target 的配置文件</h2><p>Target 也有自己的配置文件。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ systemctl cat multi-user.target</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Multi-User System</span><br><span class="line">Documentation=man:systemd.special(7)</span><br><span class="line">Requires=basic.target</span><br><span class="line">Conflicts=rescue.service rescue.target</span><br><span class="line">After=basic.target rescue.service rescue.target</span><br><span class="line">AllowIsolate=yes</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>注意，Target 配置文件里面没有启动命令。</p>
<p>上面输出结果中，主要字段含义如下。</p>
<blockquote>
<p><code>Requires</code>字段：要求<code>basic.target</code>一起运行。</p>
<p><code>Conflicts</code>字段：冲突字段。如果<code>rescue.service</code>或<code>rescue.target</code>正在运行，<code>multi-user.target</code>就不能运行，反之亦然。</p>
<p><code>After</code>：表示<code>multi-user.target</code>在<code>basic.target</code> 、 <code>rescue.service</code>、 <code>rescue.target</code>之后启动，如果它们有启动的话。</p>
<p><code>AllowIsolate</code>：允许使用<code>systemctl isolate</code>命令切换到<code>multi-user.target</code>。</p>
</blockquote>
<h2 id="九、修改配置文件后重启"><a href="#九、修改配置文件后重启" class="headerlink" title="九、修改配置文件后重启"></a>九、修改配置文件后重启</h2><p>修改配置文件以后，需要重新加载配置文件，然后重新启动相关服务。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 重新加载配置文件</span><br><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"># 重启相关服务</span><br><span class="line">$ sudo systemctl restart foobar</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>systemd</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenStack断点调试</title>
    <url>/2022/06/30/OpenStack%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95/</url>
    <content><![CDATA[<h1 id="OpenStack断点调试方法总结"><a href="#OpenStack断点调试方法总结" class="headerlink" title="OpenStack断点调试方法总结"></a>OpenStack断点调试方法总结</h1><p>关于断点调试</p>
<p>断点是调试应用程序最主要的方式之一，通过设置断点，可以实现单步执行代码，检查变量的值以及跟踪调用栈，甚至修改进程的内存变量值或者运行代码，从而观察修改后的程序行为。</p>
<span id="more"></span>
<p>大多数的调试器都是通过ptrace系统调用控制和监视进程状态，通过INT 3软件中断实现断点。当我们在代码中插入一个断点时，其实就是调试器找到指令位置（编译成机器码后的位置）嵌入一个INT 3指令，进程运行时遇到INT 3指令时，操作系统就会将该进程暂停，并发送一个SIGTRAP信号，此时调试器接收到进程的停止信号，通过ptrace查看进程状态，并通过标准输入输出与用户交互，更多关于断点和调试信息实现原理可以参考国外的一篇文章How debuggers work【1】，这里只需要注意调试器是通过标准输入输出(stdin、stdout)与用户交互的。</p>
<p>目前主流的调试工具如gdb、jdb以及针对Python语言的pdb等。本文接下来主要介绍的是针对OpenStack的一些调试方法，这些方法不仅适用于OpenStack，其他Python程序同样适用。</p>
<p>02</p>
<p>Python调试工具介绍</p>
<p>Python主要使用pdb工具进行调试，用法也很简单，只要在需要打断点的位置嵌入pdb.set_trace()代码即可。</p>
<p>比如如下Python代码：</p>
<p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20211229_7fea0838-684a-11ec-9ad6-fa163eb4f6be.png"></p>
<p>该代码相当于在say()函数第一行嵌入了一个断点，当代码执行到该函数时，会立即停止，此时可以通过pdb执行各种指令，比如查看代码、查看变量值以及调用栈等，如下：</p>
<p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20211229_801f9cfa-684a-11ec-9ad6-fa163eb4f6be.png"></p>
<p>当然你也可以使用ipdb替换pdb，界面更友好，支持语法高亮以及命令自动补全，使用体验类似于ipython,如图2-1：</p>
<p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20211229_804b45a8-684a-11ec-9ad6-fa163eb4f6be.png"></p>
<p>图2-1 ipdb界面</p>
<p>或者也可以使用功能更强大的ptpdb工具，支持多屏以及更强大的命令补全，如图2-2：</p>
<p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20211229_808be2a2-684a-11ec-9ad6-fa163eb4f6be.png"></p>
<p>图2-2 ptpdb界面</p>
<p>最上面为pdb指令输入框，左下为代码执行位置，右下为当前调用栈。</p>
<p>以上三个工具的pdb指令都是一样的，基本都是pdb工具的包装，详细的使用方法可以查看官方文档【2】或者Google相关资料，这里不对pdb命令进行过多介绍。</p>
<p>03</p>
<p>OpenStack常规调试方法</p>
<p>OpenStack断点调试是学习OpenStack工作流程的最佳方式之一，关于OpenStack源码结构可以参考我之前的一篇文章《如何阅读OpenStack源码》【3】。我们知道OpenStack是基于Python语言开发的，因此自然可以使用如上介绍的pdb工具进行断点调试。</p>
<p>比如，我想了解OpenStack Nova是如何调用Libvirt Driver创建虚拟机的，只需要在nova/virt/libvirt/driver.py模块的spawn()方法打上断点：</p>
<p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20211229_80aa27ee-684a-11ec-9ad6-fa163eb4f6be.png"></p>
<p>然后停止nova-compute服务，使用命令行手动运行nova-compute:  </p>
<p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20211229_80ed36b0-684a-11ec-9ad6-fa163eb4f6be.png"></p>
<p>在另外一个终端使用nova boot命令启动虚拟机，如果有多个计算节点，为了保证能够调度到打了断点的节点，建议把其他计算节点disable掉。</p>
<p>此时nova-compute会在spawn()方法处停止运行，此时可以通过pdb工具查看变量、单步执行等。</p>
<p>对于一些支持多线程多进程的OpenStack服务，为了方便调试，我一般会把verbose选项以及debug设置为False，避免打印太多的干扰信息，并把服务的workers数调成1，防止多个线程断点同时进入导致调试错乱。</p>
<p>比如调试nova-api服务，我会把osapi_compute_workers配置项临时设置为1。</p>
<p>通过如上调试方法，基本可以完成大多数的OpenStack服务调试，但并不能覆盖全部服务，某些OpenStack服务不能直接使用pdb进行调试，比如Keystone、Swift等某些组件，此部分内容将在下一节中进行详细介绍。</p>
<p>04</p>
<p>OpenStack不能直接使用pdb调试的情况</p>
<p>我们前面提到能够调试的前提是终端能够与进程的stdin、stdout直接交互，对于某些不能交互的情况，则必然不能直接通过pdb进行调试。主要包括如下几种情况：</p>
<p><strong>4.1 进程关闭了stdin/stdout</strong></p>
<p>cloud-init就是最经典的案例，在cloudinit/cmd/main.py的入口函数main_init()调用了close_stdin()方法关闭stdin，如下：</p>
<p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20211229_8144de9c-684a-11ec-9ad6-fa163eb4f6be.png"></p>
<p>close_stdin()方法实现如下：</p>
<p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20211229_81707e4e-684a-11ec-9ad6-fa163eb4f6be.png"></p>
<p>相当于把stdin重定向到/dev/null了。因此当我们在cloud-init打上断点时，并不会弹出pdb调试页面，而是直接抛出异常。</p>
<p>比如制作镜像时经常出现cloud-init修改密码失败，于是需要断点调试，我们在cloudinit/config/cc_set_passwords.py模块的handle()方法打上断点，结果pdb直接异常退出，从/var/log/cloud-init.log中可以看到如下错误信息：</p>
<p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20211229_81b00262-684a-11ec-9ad6-fa163eb4f6be.png"></p>
<p>我们从close_stdin()以及redirect_output方法可以发现，我们可以通过设置_CLOUD_INIT_SAVE_STDIN以及_CLOUD_INIT_SAVE_STDOUT环境变量开放stdin/stdout，从而允许我们进入调试:</p>
<p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20211229_81dbfb42-684a-11ec-9ad6-fa163eb4f6be.png"></p>
<p>除了cloud-init，OpenStack Swift也类似，可以查看swift/common/utils.py模块的capture_stdio()方法，</p>
<p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20211229_8212cfa0-684a-11ec-9ad6-fa163eb4f6be.png"></p>
<p>因此account-server、container-server以及object-server均无法直接使用pdb调试。</p>
<p><strong>4.2 Fork多进程</strong></p>
<p>如果一个进程Fork了子进程，则子进程的stdin、stdout不能直接与终端交互。</p>
<p>最经典的场景就是OpenStack组件使用了cotyledon库而不是oslo_service库实现daemon。我们知道oslo_service使用eventlet库通过多线程实现并发，而cotyledon则使用了multiprocess库通过多进程实现并发，更多关于cotyledon的介绍可以参考官方文档【4】。</p>
<p>因此使用cotyledon实现的daemon服务不能通过pdb直接进行调试，比如Ceilometer的polling-agent以及Kuryr的kuryr-daemon服务等。</p>
<p>文章《使用pdb调试ceilometer代码》【5】提出通过实现一个新的类ForkedPdb重定向stdin的方法实现子进程调试，这种方法我本人没有尝试过，不知道是否可行。</p>
<p><strong>4.3 运行在Web服务器</strong></p>
<p>最经典的如Keystone服务以及Horizon服务，我们通常会把该服务运行在Apache服务器上，显然这种情况终端没法直接和Keystone的stdin、stdout进行交互，因此不能通过pdb直接调试。</p>
<p>05</p>
<p>如何解决不能使用pdb直接调试的问题</p>
<p>我们前面总结了几种不能使用pdb直接调试的情况，其根本原因就是终端无法和进程的stdin/stdout交互，因此我们解决的思路就是让终端与进程的stdin/stdout打通。</p>
<p>我们知道stdin以及stdout都是文件流，有没有其他的流呢？显然socket也是一种流。因此我们可以通过把stdin、stdout重定向到一个socket流中，从而实现远程调试。</p>
<p>定义如下方法，把stdin、stdout重定向到本地的一个TCP socket中，监听地址端口为1234:</p>
<p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20211229_8242db96-684a-11ec-9ad6-fa163eb4f6be.png"></p>
<p>当然我们也需要把pdb的stdin、stdout也重定向到该socket中，这样才能与pdb交互，用法如下：</p>
<p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20211229_827adbf4-684a-11ec-9ad6-fa163eb4f6be.png"></p>
<p>运行该程序后，使用另一个终端通过nc或者telnet连接1234端口即可进行调试，如图5-1：</p>
<p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20211229_82b4fece-684a-11ec-9ad6-fa163eb4f6be.png"></p>
<p>可见，通过这种方式可以实现远程调试，不过我们不用每次都写那么长一段代码，社区已经有实现了，只需要使用rpdb替换pdb即可进行远程调试，原理与之类似，默认监听的端口为4444。</p>
<p>比如调试Keystone的list_projects()方法:</p>
<p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20211229_82db57cc-684a-11ec-9ad6-fa163eb4f6be.png"></p>
<p>然后重启httpd服务，重启完毕调用project list API:</p>
<p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20211229_82f6af22-684a-11ec-9ad6-fa163eb4f6be.png"></p>
<p>如上openstack project list命令会hang住，此时通过nc或者telnet连接本地4444端口进行调试：</p>
<p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20211229_832673b0-684a-11ec-9ad6-fa163eb4f6be.png"></p>
<p>可见成功attach了pdb，此时可以像普通pdb一样进行单步调试了。</p>
]]></content>
      <categories>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>pdb</tag>
      </tags>
  </entry>
  <entry>
    <title>nova代码调用栈</title>
    <url>/2022/06/29/nova%E4%BB%A3%E7%A0%81%E8%B0%83%E7%94%A8%E6%A0%88/</url>
    <content><![CDATA[<h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><p>dashboard或者命令行接口 restful接口create</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create                                                  # nova/api/openstack/compute/servers.py</span><br><span class="line">  _create_instance                                        # nova\compute\api.py</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">schedule_and_build_instances                            # nova\conductor\manager.py</span><br><span class="line">  _schedule_instances                                     # nova\conductor\manager.py</span><br><span class="line">    select_destinations                             # nova\scheduler\manager.py</span><br><span class="line">  build_and_run_instance                                  # nova\compute\manager.py</span><br></pre></td></tr></table></figure>

<h2 id="compute"><a href="#compute" class="headerlink" title="compute"></a>compute</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">build_and_run_instance</span><br><span class="line">    _do_build_and_run_instance</span><br><span class="line">        _build_and_run_instance</span><br><span class="line">            _build_resources                            # compute/manage.py</span><br><span class="line">                _build_networks_for_instance            # compute/manage.py</span><br><span class="line">                    _allocate_network                   # computemanage.py</span><br><span class="line">                        _allocate_network_async         # compute/manage.py</span><br><span class="line">                            allocate_for_instance           # network/neutron.py</span><br><span class="line">                                _create_ports_for_instance  # network/neutron.py</span><br><span class="line">                                _update_ports_for_instance  # network/neutron.py</span><br><span class="line">                _prep_block_device                      # compute/manage.py</span><br><span class="line">                    attach_block_devices                    # virt/block_device.py</span><br><span class="line">                        DriverVolumeBlockDevice.attach      # virt/block_device.py</span><br><span class="line">                            _do_attach                      # virt/block_device.py</span><br><span class="line">                                _volume_attach              # virt/block_device.py</span><br><span class="line">                                    attachment_update       # volume/cinder.py</span><br><span class="line">                                        cinderclient        # volume/cinder.py</span><br><span class="line">                                    attach_volume           # virt/driver.py, virt/libvirt/driver.py</span><br><span class="line">                                        _connect_volume     # virt/driver.py, virt/libvirt/driver.py</span><br><span class="line">            driver.spawn                                # compute/manage.py -&gt; virt/libvirt/driver.py</span><br><span class="line">                _get_guest_xml                              # virt/libvirt/driver.py</span><br><span class="line">                    _get_guest_config                       # virt/libvirt/driver.py</span><br><span class="line">                        _get_guest_storage_config           # virt/libvirt/driver.py</span><br><span class="line">                            _connect_volume                 # virt/libvirt/driver.py</span><br><span class="line">                            _get_volume_config              # virt/libvirt/driver.py</span><br><span class="line">                                _get_volume_driver          # virt/libvirt/driver.py</span><br><span class="line">                                    vhostuser               # virt/libvirt/volume/vhostuser.py</span><br><span class="line">                    conf.to_xml                             # virt/libvirt/config.py</span><br><span class="line">                _create_guest_with_network                  # virt/libvirt/driver.py</span><br><span class="line">                    plug_vifs                               # virt/libvirt/driver.py</span><br><span class="line">                        vif_driver.plug                     # virt/libvirt/vif.py</span><br><span class="line">                            _plug_os_vif                    # virt/libvirt/vif.py</span><br><span class="line">                                os_vif.plug</span><br><span class="line">                                    vif_plug_ovs.ovs.plug</span><br><span class="line">                                        _plug_vhostuser</span><br><span class="line">                                            _create_vif_port</span><br><span class="line">                                                create_ovs_vif_port</span><br><span class="line">                                                    update_device_mtu</span><br><span class="line">                                                        _set_mtu_request</span><br><span class="line">                                                            ovsdb.db_set</span><br><span class="line">                    _create_guest</span><br><span class="line">                        libvirt_guest.Guest.create</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>nova</tag>
      </tags>
  </entry>
  <entry>
    <title>docker私有仓库</title>
    <url>/2022/06/28/docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<hr>
<h2 id="一、关于Registry"><a href="#一、关于Registry" class="headerlink" title="一、关于Registry"></a>一、关于Registry</h2><p>官方的Docker hub是一个用于管理公共镜像的好地方，我们可以在上面找到我们想要的镜像，也可以把我们自己的镜像推送上去。</p>
<span id="more"></span>
<p>但是有时候我们的使用场景需要我们拥有一个私有的镜像仓库用于管理我们自己的镜像。这个可以通过开源软件Registry来达成目的。</p>
<p> Registry在github上有两份代码：老代码库和新代码库。老代码是采用python编写的，存在pull和push的性能问题，出到0.9.1版本之后就标志为deprecated，不再继续开发。</p>
<p> 从2.0版本开始就到在新代码库进行开发，新代码库是采用go语言编写，修改了镜像id的生成算法、registry上镜像的保存结构，大大优化了pull和push镜像的效率。</p>
<p> 官方在Docker hub上提供了registry的镜像，我们可以直接使用该registry镜像来构建一个容器，搭建我们自己的私有仓库服务。</p>
<hr>
<h2 id="二、搭建Registry"><a href="#二、搭建Registry" class="headerlink" title="二、搭建Registry"></a>二、搭建Registry</h2><h4 id="首先搜索并拉取镜像"><a href="#首先搜索并拉取镜像" class="headerlink" title="首先搜索并拉取镜像"></a>首先搜索并拉取镜像</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker search registry　　　　# 建议先搜索一下，可以看一下相关的镜像，说不定哪天就有更好的镜像了</span><br><span class="line">docker pull registry　　　　# 标签可以不加，因为当前最新就是v2</span><br></pre></td></tr></table></figure>

<h4 id="运行一个registry容器"><a href="#运行一个registry容器" class="headerlink" title="运行一个registry容器"></a>运行一个registry容器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d \\            # 后台运行</span><br><span class="line">--name registry-srv \\    # 指定容器名</span><br><span class="line">--restart=always \\        # 设置自动启动</span><br><span class="line">-p 5000:5000 \\            # 端口映射宿主机，通过宿主机地址访问</span><br><span class="line">-v /opt/zwx-registry:/var/lib/registry \\     # 把镜像存储目录挂载到本地，方便管理和持久化</span><br><span class="line">-v /opt/zwx-registry/srv-config.yml:/etc/docker/registry/config.yml \\    # 把配置文件挂载到本地，方便修改和保存</span><br><span class="line">registry</span><br></pre></td></tr></table></figure>

<h4 id="srv-config-yml内容如下"><a href="#srv-config-yml内容如下" class="headerlink" title="srv-config.yml内容如下"></a>srv-config.yml内容如下</h4><p>　　标红delete参数设置为true，是为了让仓库支持删除功能。默认没有这个参数，也就是不能删除仓库镜像。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: 0.1</span><br><span class="line">log:</span><br><span class="line">  fields:</span><br><span class="line">    service: registry</span><br><span class="line">storage:</span><br><span class="line">  **delete:</span><br><span class="line">    enabled:** **true**</span><br><span class="line">  cache:</span><br><span class="line">    blobdescriptor: inmemory</span><br><span class="line">  filesystem:</span><br><span class="line">    rootdirectory: /var/lib/registry</span><br><span class="line">http:</span><br><span class="line">  addr: :5000</span><br><span class="line">  headers:</span><br><span class="line">    X-Content-Type-Options: [nosniff]</span><br><span class="line">health:</span><br><span class="line">  storagedriver:</span><br><span class="line">    enabled: true</span><br><span class="line">    interval: 10s</span><br><span class="line">    threshold: 3</span><br></pre></td></tr></table></figure>

<h4 id="注册https协议（否则push安全认证过不去）"><a href="#注册https协议（否则push安全认证过不去）" class="headerlink" title="注册https协议（否则push安全认证过不去）"></a>注册https协议（否则push安全认证过不去）</h4><p>　　需要通过本地仓库下载镜像，均需要配置　　</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/docker/daemon.json　　　　　　　　# 默认无此文件，需自行添加，有则追加以下内容。</span><br><span class="line">&#123; &quot;insecure-registries&quot;:[&quot;xx.xx.xx.xx:5000&quot;] &#125;　　# 指定IP地址或域名</span><br><span class="line">systemctl daemon-reload    # 守护进程重启</span><br><span class="line">systemctl restart docker    # 重启docker服务</span><br></pre></td></tr></table></figure>

<h4 id="镜像上传与下载"><a href="#镜像上传与下载" class="headerlink" title="镜像上传与下载"></a>镜像上传与下载</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker push xx.xx.xx.xx:5000/nginx            # 一定要注明仓库地址，否则会报错</span><br><span class="line">docker pull xx.xx.xx.xx:5000/nginx</span><br></pre></td></tr></table></figure>

<h4 id="查看仓库镜像信息"><a href="#查看仓库镜像信息" class="headerlink" title="查看仓库镜像信息"></a>查看仓库镜像信息</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看仓库镜像列表（也可以通过windows浏览器打开查看）</span><br><span class="line">curl -XGET http://xx.xx.xx.xx:5000/v2/_catalog | python3 -m json.tool</span><br><span class="line"></span><br><span class="line"># 查看指定应用镜像tag</span><br><span class="line">curl -XGET http://xx.xx.xx.xx:5000/v2/image_name/tags/list</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="三、搭建Registry-web"><a href="#三、搭建Registry-web" class="headerlink" title="三、搭建Registry web"></a>三、搭建Registry web</h2><h4 id="首先搜索并拉取镜像-1"><a href="#首先搜索并拉取镜像-1" class="headerlink" title="首先搜索并拉取镜像"></a>首先搜索并拉取镜像</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker search docker-registry-web</span><br><span class="line">docker pull hyper/docker-registry-web　　　　# 这个镜像用的人较多</span><br></pre></td></tr></table></figure>

<h4 id="运行一个registry-web容器"><a href="#运行一个registry-web容器" class="headerlink" title="运行一个registry web容器"></a>运行一个registry web容器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -d \\            # 后台运行</span><br><span class="line">--name registry-web \\    # 指定容器名</span><br><span class="line">--restart=always \\        # 设置自动启动</span><br><span class="line">-p 8000:8080 \\            # 端口映射宿主机，通过宿主机地址访问</span><br><span class="line">-v /opt/zwx-registry/web-config.yml:/conf/config.yml \\    # 把配置文件挂载到本地，方便修改和保存</span><br><span class="line">hyper/docker-registry-web</span><br></pre></td></tr></table></figure>

<h4 id="web-config-yml文件内容如下"><a href="#web-config-yml文件内容如下" class="headerlink" title="web-config.yml文件内容如下"></a>web-config.yml文件内容如下</h4><p>标红readonly参数设置为false，是为了web页面可以显示删除按钮。默认是true，只读状态，没有删除按钮，只能查看。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">registry:</span><br><span class="line">  # Docker registry url</span><br><span class="line">  url: http://10.88.77.32:5000/v2</span><br><span class="line">  # Docker registry fqdn</span><br><span class="line">  name: localhost:5000</span><br><span class="line">  # To allow image delete, should be false</span><br><span class="line">  readonly: false</span><br><span class="line">  auth:</span><br><span class="line">    # Disable authentication</span><br><span class="line">    enabled: false</span><br></pre></td></tr></table></figure>

<h4 id="部署完成后，浏览器打开仓库UI地址即可查看到所有应用镜像"><a href="#部署完成后，浏览器打开仓库UI地址即可查看到所有应用镜像" class="headerlink" title="部署完成后，浏览器打开仓库UI地址即可查看到所有应用镜像"></a>部署完成后，浏览器打开仓库UI地址即可查看到所有应用镜像</h4><p><img src="bfcef290e0529142f4fa675f5cb3cc0d2564e07512912b699ffa9a00bf6c8a6a.png" alt="picture 0">  </p>
<p>选择任意应用镜像库，即可查看到该镜像的所有tag信息，每个tag后面都有个删除按钮（默认没有，配置参考config.yml）</p>
<p><img src="634baf7e844835348b1d5708228a67a8bdda0d92583551bb1dd6dc1d825ff527.png" alt="picture 1">  </p>
<hr>
<h2 id="四、快捷部署"><a href="#四、快捷部署" class="headerlink" title="四、快捷部署"></a>四、快捷部署</h2><p>　　集群模式可以通过docker stack快速部署registry和registry web。</p>
<p>　　新建配置文件srv-config.yml、web-config.yml放到指定路径，再新建docker-compose.yml文件，执行命令即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker stack deploy -c docker-compose.yml RGT</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">version: &#x27;3.7&#x27;　　　　　　\# docker stack 需要是3.0以上版本</span><br><span class="line">services:</span><br><span class="line">  registry-srv:　　　　　　\# 服务名</span><br><span class="line">    image: registry</span><br><span class="line">    </span><br><span class="line">    ports:　　　　　　　　　\# 映射端口</span><br><span class="line">      - 5000:5000</span><br><span class="line">      </span><br><span class="line">    volumes:　　　　　　　　\# 挂载镜像路径和配置文件，注意修改路径与实际一致</span><br><span class="line">      - /opt/zwx-registry:/var/lib/registry</span><br><span class="line">      - /opt/zwx-registry/srv-config.yml:/etc/docker/registry/config.yml</span><br><span class="line">      </span><br><span class="line">    deploy:　　　　　　　　\# 设置单任务，并约束主节点运行</span><br><span class="line">      mode: replicated</span><br><span class="line">      replicas: 1</span><br><span class="line">      placement:</span><br><span class="line">        constraints:</span><br><span class="line">          - node.role == manager</span><br><span class="line">      </span><br><span class="line">  registry-web:　　　　　　\# 服务名　　</span><br><span class="line">    image: hyper/docker-registry-web</span><br><span class="line">    </span><br><span class="line">    ports:　　　　　　　　\# 映射端口</span><br><span class="line">      - 8000:8080</span><br><span class="line">    </span><br><span class="line">    volumes:　　　　　　\# 挂载配置文件，注意修改路径与实际一致</span><br><span class="line">      - /opt/zwx-registry/web-config.yml:/conf/config.yml</span><br><span class="line">      </span><br><span class="line">    environment:</span><br><span class="line">      - REGISTRY_URL=http://registry-srv:5000/v2</span><br><span class="line">      - REGISTRY_NAME=localhost:5000</span><br><span class="line">    </span><br><span class="line">    deploy:　　　　　　　　\# 设置单任务，并约束主节点运行</span><br><span class="line">      mode: replicated</span><br><span class="line">      replicas: 1</span><br><span class="line">      placement:</span><br><span class="line">        constraints:</span><br><span class="line">          - node.role == manager  </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>DOCKER</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker ipc设置</title>
    <url>/2022/06/27/docker-ipc%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<p>官方配置文档：<a href="https://docs.docker.com/engine/reference/run/#ipc-settings---ipc">Docker run reference</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--ipc=&quot;MODE&quot;  : 设置容器的 IPC 模式</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>可接受的值包括：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>“”</td>
<td>使用Docker Daemon的默认值</td>
</tr>
<tr>
<td>none</td>
<td>拥有私有的IPC命名空间，不挂载 /dev/shm</td>
</tr>
<tr>
<td>private</td>
<td>拥有私有的IPC命名空间</td>
</tr>
<tr>
<td>shareable</td>
<td>拥有私有的IPC命名空间, 且可以共享给其他容器</td>
</tr>
<tr>
<td>container: &lt;_name-or-ID_&gt;</td>
<td>加入到其他”shareable”容器的命名空间中</td>
</tr>
<tr>
<td>host</td>
<td>使用主机系统的命名空间</td>
</tr>
</tbody></table>
<p>如果未指定，则使用Docker Daemon的默认值，它可以是”private”或”shareable”，具体取决于daemon的版本和配置。</p>
<p>IPC (POSIX/SysV IPC) 命名空间提供命名共享内存段、信号量和消息队列的隔离。</p>
<p>共享内存段（shared memory segments ）用于以加速进程间通信，性能超过管道或网络。 共享内存常用于科学计算和金融服务行业的数据库和定制高性能应用程序。 如果这些类型的应用程序被分解到多个容器中，可能需要共享容器的 IPC 机制，对主容器使用”shareable”模式，其他容器使用“container:<name-or- id>”模式。</name-or-></p>
]]></content>
      <categories>
        <category>DOCKER</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>nova源码阅读</title>
    <url>/2022/06/26/nova%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<h2 id="1-OpenStack基础"><a href="#1-OpenStack基础" class="headerlink" title="1 OpenStack基础"></a>1 OpenStack基础</h2><h2 id="1-1-OpenStack组件介绍"><a href="#1-1-OpenStack组件介绍" class="headerlink" title="1.1 OpenStack组件介绍"></a>1.1 OpenStack组件介绍</h2><p>OpenStack是一个IaaS云计算平台开源实现，其对标产品为AWS。</p>
<span id="more"></span>
<p>最开始OpenStack只有两个组件，分别为提供计算服务的Nova以及提供对象存储服务的Swift，其中Nova不仅提供计算服务，还包含了网络服务、块存储服务、镜像服务以及裸机管理服务。之后随着项目的不断发展，从Nova中根据功能拆分为多个独立的项目，如nova-volume拆分为Cinder项目提供块存储服务，nova-image拆分为Glance项目，提供镜像存储服务，nova-network则是neutron的前身，裸机管理也从Nova中分离出来为Ironic项目。最开始容器服务也是由Nova提供支持的，作为Nova的driver之一来实现，而后迁移到Heat，到现在已经独立为一个单独的项目Magnum，后来Magnum的愿景调整为主要提供容器编排服务，单纯的容器服务则由Zun项目接管。最开始OpenStack并没有认证功能，从E版开始才加入认证服务Keystone。</p>
<p>目前OpenStack基础服务组件如下:</p>
<ul>
<li>  Keystone：认证服务。</li>
<li>  Glance：镜像服务。</li>
<li>  Nova：计算服务。</li>
<li>  Cinder：块存储服务。</li>
<li>  Neutorn：网络服务。</li>
<li>  Swift：对象存储服务。</li>
</ul>
<p>E版之后，在这些核心服务之上，又不断涌现新的服务，如面板服务Horizon、编排服务Heat、数据库服务Trove、文件共享服务Manila、大数据服务Sahara、工作流服务Mistral以及前面提到的容器编排服务Magnum等，这些服务几乎都依赖于以上的基础服务。比如Sahara大数据服务会先调用Heat模板服务，Heat又会调用Nova创建虚拟机，调用Glance获取镜像，调用Cinder创建数据卷，调用Neutron创建网络等。</p>
<p>OpenStack服务越来越多、越来越复杂，覆盖的技术生态越来越庞大，宛如一个庞然大物，刚接触如此庞大的分布式系统，都或多或少感觉有点如”盲人摸象”的感觉。不过不必先过于绝望，好在OpenStack项目具有非常良好的设计，虽然OpenStack项目众多，组件繁杂，但几乎所有的服务骨架脉络基本是一样的，熟悉了其中一个项目的架构，深入读了其中一个项目源码，再去看其它项目可谓轻车熟路。</p>
<p>本文章会以Nova项目为例，一步一步剖析源码结构，希望读者阅读完之后再去看Cinder项目会是件非常轻松的事。</p>
<p>OpenStack所有项目都是基于Python开发，并且都是标准的Python项目，通过setuptools工具管理项目，负责Python模块的安装和分发。想知道一个项目有哪些服务组成，最直接有效的办法就是找到入口函数（main函数）在哪里，只要是标准的基于setuptools管理的项目的所有入口函数都会在项目根目录的setup.cfg文件中定义，console_scripts就是所有服务组件的入口，比如nova（Mitaka版本）的setup.cfg的console_scripts如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[entry_points]</span><br><span class="line">...</span><br><span class="line">console_scripts =</span><br><span class="line">    nova-all = nova.cmd.all:main    nova-api = nova.cmd.api:main    nova-api-metadata = nova.cmd.api_metadata:main    nova-api-os-compute = nova.cmd.api_os_compute:main    nova-cells = nova.cmd.cells:main    nova-cert = nova.cmd.cert:main    nova-compute = nova.cmd.compute:main    nova-conductor = nova.cmd.conductor:main    nova-console = nova.cmd.console:main    nova-consoleauth = nova.cmd.consoleauth:main    nova-dhcpbridge = nova.cmd.dhcpbridge:main    nova-idmapshift = nova.cmd.idmapshift:main    nova-manage = nova.cmd.manage:main    nova-network = nova.cmd.network:main    nova-novncproxy = nova.cmd.novncproxy:main    nova-rootwrap = oslo_rootwrap.cmd:main    nova-rootwrap-daemon = oslo_rootwrap.cmd:daemon    nova-scheduler = nova.cmd.scheduler:main    nova-serialproxy = nova.cmd.serialproxy:main    nova-spicehtml5proxy = nova.cmd.spicehtml5proxy:main    nova-xvpvncproxy = nova.cmd.xvpvncproxy:main</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由此可知nova项目安装后会包含21个可执行程序，其中nova-compute服务的入口函数为nova/cmd/compute.py模块的main函数:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def main():</span><br><span class="line">    config.parse_args(sys.argv)</span><br><span class="line">    logging.setup(CONF, &#x27;nova&#x27;)</span><br><span class="line">    utils.monkey_patch()</span><br><span class="line">    objects.register_all()</span><br><span class="line"></span><br><span class="line">    gmr.TextGuruMeditation.setup_autorun(version)</span><br><span class="line"></span><br><span class="line">    if not CONF.conductor.use_local:</span><br><span class="line">        block_db_access()</span><br><span class="line">        objects_base.NovaObject.indirection_api = \</span><br><span class="line">            conductor_rpcapi.ConductorAPI()</span><br><span class="line">    else:</span><br><span class="line">        LOG.warning(_LW(&#x27;Conductor local mode is deprecated and will &#x27;</span><br><span class="line">                        &#x27;be removed in a subsequent release&#x27;))</span><br><span class="line"></span><br><span class="line">    server = service.Service.create(binary=&#x27;nova-compute&#x27;,</span><br><span class="line">                                    topic=CONF.compute_topic,</span><br><span class="line">                                    db_allowed=CONF.conductor.use_local)</span><br><span class="line">    service.serve(server)</span><br><span class="line">    service.wait()</span><br></pre></td></tr></table></figure>

<p>其它服务依次类推。</p>
<p>OpenStack使用Python语言开发，而Python是动态类型语言，参数类型不容易从代码中看出，因此部署一个allinone的OpenStack开发测试环境非常有必要，建议使用RDO部署：<a href="https://link.zhihu.com/?target=https://www.rdoproject.org/install/quickstart/">Packstack quickstart</a>，当然乐于折腾使用DevStack也是没有问题的。</p>
<p>要想深入研究源码，最有效的方式就是一步一步跟踪代码执行，因此会使用debug工具是关键技能之一。Python的debug工具有很多，为了简便起见，pdb工具就够了，你也可以尝试ipdb、ptpdb之类的调试工具。使用方法也非常简单，只要在你想设置断点的地方，嵌入以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import pdb; pdb.set_trace()</span><br></pre></td></tr></table></figure>

<p>然后在命令行（不能通过systemd启动）直接运行服务即可。</p>
<p>假如想跟踪nova创建虚拟机的过程，首先nova/api/openstack/compute/servers.py模块的create方法打上断点，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def create(self, req, body):</span><br><span class="line">    &quot;&quot;&quot;Creates a new server for a given user.&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    import pdb; pdb.set_trace() # 设置断点</span><br><span class="line">    context = req.environ[&#x27;nova.context&#x27;]</span><br><span class="line">    server_dict = body[&#x27;server&#x27;]</span><br><span class="line">    password = self._get_server_admin_password(server_dict)</span><br><span class="line">    name = common.normalize_name(server_dict[&#x27;name&#x27;])</span><br><span class="line"></span><br><span class="line">    if api_version_request.is_supported(req, min_version=&#x27;2.19&#x27;):</span><br><span class="line">        if &#x27;description&#x27; in server_dict:</span><br><span class="line">            # This is allowed to be None</span><br><span class="line">            description = server_dict[&#x27;description&#x27;]</span><br><span class="line">        else:</span><br><span class="line">            # No default description</span><br><span class="line">            description = None</span><br><span class="line">    else:</span><br><span class="line">        description = name</span><br><span class="line">    ...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后注意需要通过命令行直接运行，而不能通过systemd启动:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">su -c &#x27;nova-api&#x27; nova</span><br></pre></td></tr></table></figure>

<p>此时调用创建虚拟机API，nova-api进程就会立即弹出pdb shell，此时你可以通过s或者n命令一步一步执行代码。</p>
<h2 id="1-3-OpenStack项目通用骨骼脉络"><a href="#1-3-OpenStack项目通用骨骼脉络" class="headerlink" title="1.3 OpenStack项目通用骨骼脉络"></a>1.3 OpenStack项目通用骨骼脉络</h2><p>阅读源码的首要问题就是就要对代码的结构了然于胸，<strong>需要强调的是，OpenStack项目的目录结构并不是根据组件严格划分，而是根据功能划分</strong>，以Nova为例，compute目录并不是一定在nova-compute节点上运行，而主要是和compute相关(虚拟机操作相关）的功能实现，同样的，scheduler目录代码并不全在scheduler服务节点运行，但主要是和调度相关的代码。不过目录结构并不是完全没有规律，它遵循一定的套路。</p>
<p>通常一个服务的目录都会包含<strong>api.py、rpcapi.py、manager.py</strong>，这三个是最最重要的模块。</p>
<ul>
<li>  <strong>api.py</strong>： 通常是供其它组件调用的封装库。换句话说，该模块通常并不会由本模块调用，而是类似提供其它服务SDK。比如compute目录的api.py，通常会由nova-api服务的controller调用。</li>
<li>  <strong>rpcapi.py</strong>：这个是RPC请求的封装，或者说是RPC封装的client端，该模块封装了所有RPC请求调用。</li>
<li>  <strong>manager.py</strong>： 这个才是真正服务的功能实现，也是RPC的服务端，即处理RPC请求的入口，实现的方法和rpcapi实现的方法一一对应。</li>
</ul>
<p>比如对一个虚拟机执行关机操作的流程为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">API节点</span><br><span class="line">nova-api接收用户请求 -&gt; nova-api调用compute/api.py</span><br><span class="line">-&gt; compute/api调用compute/rpcapi.py -&gt; rpcapi.py向目标计算节点发起stop_instance()RPC请求</span><br><span class="line"></span><br><span class="line">计算节点</span><br><span class="line">收到MQ RPC消息 -&gt; 解析stop_instance()请求 -&gt; 调用compute/manager.py的callback方法stop_instance() -&gt; 调用libvirt关机虚拟机</span><br></pre></td></tr></table></figure>

<p>前面提到OpenStack项目的目录结构是按照功能划分的，而不是服务组件，因此并不是所有的目录都能有对应的组件。仍以Nova为例:</p>
<ul>
<li>  cmd：这是服务的启动脚本，即所有服务的main函数。看服务怎么初始化，就从这里开始。</li>
<li>  db: 封装数据库访问API，目前支持的driver为sqlalchemy，还包括migrate repository。</li>
<li>  conf：Nova的配置项声明都在这里，想看Nova配置的作用和默认值可以从这个目录入手。</li>
<li>  locale: 本地化处理。</li>
<li>  image: 封装image API，其实就是调用python-glanceclient。</li>
<li>  network: 封装网络服务接口，根据配置不同，可能调用nova-network或者neutron。</li>
<li>  volume: 封装数据卷访问接口，通常是Cinder的client封装，调用python-cinderclient。</li>
<li>  virt: 这是所有支持的hypervisor驱动，主流的如libvirt、xen等。</li>
<li>  objects: 对象模型，封装了所有实体对象的CURD操作，相对直接调用db的model更安全，并且支持版本控制。</li>
<li>  policies： policy校验实现。</li>
<li>  tests: 单元测试和功能测试代码。</li>
</ul>
<p>以上同样适用于其它服务，比如Cinder等。</p>
<p>另外需要了解的是，所有的API入口都是从xxx-api开始的，RESTFul API是OpenStack服务的唯一入口，也就是说，阅读源码就从api开始。而api组件也是根据实体划分的，不同的实体对应不同的controller，比如servers、flavors、keypairs等，controller的index方法对应list操作、show方法对应get操作、create创建、delete删除、update更新等。</p>
<p>根据进程阅读源码并不是什么好的实践，因为光理解服务如何初始化、如何通信、如何发送心跳等就不容易，各种高级封装太复杂了。我认为比较好的阅读源码方式是追踪一个任务的执行过程，比如看启动虚拟机的整个流程。因此接下来本文将以创建一台虚拟机为例，一步步分析其过程。</p>
<h2 id="2-创建虚拟机过程分析"><a href="#2-创建虚拟机过程分析" class="headerlink" title="2 创建虚拟机过程分析"></a>2 创建虚拟机过程分析</h2><p>这里以创建虚拟机过程为例，根据前面的总体套路，一步步跟踪其执行过程。需要注意的是，Nova支持同时创建多台虚拟机，因此在调度时需要选择多个宿主机。</p>
<h2 id="S1-nova-api"><a href="#S1-nova-api" class="headerlink" title="S1 nova-api"></a>S1 nova-api</h2><p>入口为<strong>nova/api/openstack/compute/servers.py</strong>的create方法，该方法检查了一堆参数以及policy后，调用compute_api的create方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def create(self, req, body):</span><br><span class="line">    &quot;&quot;&quot;Creates a new server for a given user.&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    context = req.environ[&#x27;nova.context&#x27;]</span><br><span class="line">    server_dict = body[&#x27;server&#x27;]</span><br><span class="line">    password = self._get_server_admin_password(server_dict)</span><br><span class="line">    name = common.normalize_name(server_dict[&#x27;name&#x27;])</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    flavor_id = self._flavor_id_from_req_data(body)</span><br><span class="line">    try:</span><br><span class="line">        inst_type = flavors.get_flavor_by_flavor_id(</span><br><span class="line">                flavor_id, ctxt=context, read_deleted=&quot;no&quot;)</span><br><span class="line"></span><br><span class="line">        (instances, resv_id) = self.compute_api.create(context,</span><br><span class="line">                        inst_type,</span><br><span class="line">                        image_uuid,</span><br><span class="line">                        display_name=name,</span><br><span class="line">                        display_description=description,</span><br><span class="line">                        availability_zone=availability_zone,</span><br><span class="line">                        forced_host=host, forced_node=node,</span><br><span class="line">                        metadata=server_dict.get(&#x27;metadata&#x27;, &#123;&#125;),</span><br><span class="line">                        admin_password=password,</span><br><span class="line">                        requested_networks=requested_networks,</span><br><span class="line">                        check_server_group_quota=True,</span><br><span class="line">                        **create_kwargs)</span><br><span class="line">    except (exception.QuotaError,</span><br><span class="line">            exception.PortLimitExceeded) as error:</span><br><span class="line">        raise exc.HTTPForbidden(</span><br><span class="line">            explanation=error.format_message())</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>这里的compute_api即前面说的<strong>nova/compute/api.py</strong>模块，找到该模块的create方法，该方法会创建数据库记录、检查参数等，然后调用compute_task_api的build_instances方法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">self.compute_task_api.schedule_and_build_instances(</span><br><span class="line">    context,</span><br><span class="line">    build_requests=build_requests,</span><br><span class="line">    request_spec=request_specs,</span><br><span class="line">    image=boot_meta,</span><br><span class="line">    admin_password=admin_password,</span><br><span class="line">    injected_files=injected_files,</span><br><span class="line">    requested_networks=requested_networks,</span><br><span class="line">    block_device_mapping=block_device_mapping)</span><br></pre></td></tr></table></figure>

<p>compute_task_api即conductor的api.py。conductor的api并没有执行什么操作，直接调用了conductor_compute_rpcapi的build_instances方法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def schedule_and_build_instances(self, context, build_requests,</span><br><span class="line">                                 request_spec, image,</span><br><span class="line">                                 admin_password, injected_files,</span><br><span class="line">                                 requested_networks, block_device_mapping):</span><br><span class="line">    self.conductor_compute_rpcapi.schedule_and_build_instances(</span><br><span class="line">        context, build_requests, request_spec, image,</span><br><span class="line">        admin_password, injected_files, requested_networks,</span><br><span class="line">        block_device_mapping)</span><br></pre></td></tr></table></figure>

<p>该方法就是conductor RPC API，即<strong>nova/conductor/rpcapi.py</strong>模块，该方法除了一堆的版本检查，剩下的就是对RPC调用的封装，代码只有两行:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cctxt = self.client.prepare(version=version)</span><br><span class="line">cctxt.cast(context, &#x27;build_instances&#x27;, **kw)</span><br></pre></td></tr></table></figure>

<p>其中cast表示异步调用，build_instances是远程调用的方法，kw是传递的参数。参数是字典类型，没有复杂对象结构，因此不需要特别的序列化操作。</p>
<p>截至到现在，虽然目录由api-&gt;compute-&gt;conductor，但仍在nova-api进程中运行，直到cast方法执行，该方法由于是异步调用，因此nova-api任务完成，此时会响应用户请求，虚拟机状态为building。</p>
<h2 id="S2-nova-conductor"><a href="#S2-nova-conductor" class="headerlink" title="S2 nova-conductor"></a>S2 nova-conductor</h2><p>由于是向nova-conductor发起的RPC调用，而前面说了接收端肯定是manager.py，因此进程跳到nova-conductor服务，入口为nova/conductor/manager.py的build_instances方法，该方法首先调用了_schedule_instances方法，该方法调用了scheduler_client的select_destinations方法:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def _schedule_instances(self, context, request_spec, filter_properties):</span><br><span class="line">    scheduler_utils.setup_instance_group(context, request_spec,</span><br><span class="line">                                         filter_properties)</span><br><span class="line">    # TODO(sbauza): Hydrate here the object until we modify the</span><br><span class="line">    # scheduler.utils methods to directly use the RequestSpec object</span><br><span class="line">    spec_obj = objects.RequestSpec.from_primitives(</span><br><span class="line">        context, request_spec, filter_properties)</span><br><span class="line">    hosts = self.scheduler_client.select_destinations(context, spec_obj)</span><br><span class="line">    return hosts</span><br></pre></td></tr></table></figure>

<p>scheduler_client和compute_api以及compute_task_api都是一样对服务的client SDK调用，不过scheduler没有api.py，而是有个单独的client目录，实现在client目录的__init__.py，这里仅仅是调用query.py下的SchedulerQueryClient的select_destinations实现，然后又很直接地调用了scheduler_rpcapi的select_destinations方法，终于又到了RPC调用环节。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def _schedule_instances(self, context, request_spec, filter_properties):</span><br><span class="line">    scheduler_utils.setup_instance_group(context, request_spec,</span><br><span class="line">                                         filter_properties)</span><br><span class="line">    # TODO(sbauza): Hydrate here the object until we modify the</span><br><span class="line">    # scheduler.utils methods to directly use the RequestSpec object</span><br><span class="line">    spec_obj = objects.RequestSpec.from_primitives(</span><br><span class="line">        context, request_spec, filter_properties)</span><br><span class="line">    hosts = self.scheduler_client.select_destinations(context, spec_obj)</span><br><span class="line">    return hosts</span><br></pre></td></tr></table></figure>

<p>毫无疑问，RPC封装同样是在scheduler的rpcapi中实现。该方法RPC调用代码如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return cctxt.call(ctxt, &#x27;select_destinations&#x27;, **msg_args)</span><br></pre></td></tr></table></figure>

<p>注意这里调用的call方法，即同步RPC调用，此时nova-conductor并不会退出，而是堵塞等待直到nova-scheduler返回。因此当前状态为nova-conductor为blocked状态，等待nova-scheduler返回，nova-scheduler接管任务。</p>
<h2 id="S3-nova-scheduler"><a href="#S3-nova-scheduler" class="headerlink" title="S3 nova-scheduler"></a>S3 nova-scheduler</h2><p>同理找到scheduler的manager.py模块的select_destinations方法，该方法会调用driver方法，这里的driver其实就是调度算法实现，通常用的比较多的就是Filter Scheduler算法，对应filter_scheduler.py模块，该模块首先通过host_manager拿到所有的计算节点信息，然后通过filters过滤掉不满足条件的计算节点，剩下的节点通过weigh方法计算权值，最后选择权值高的作为候选计算节点返回。最后nova-scheduler返回调度结果的hosts集合，任务结束，返回到nova-conductor服务。</p>
<h2 id="S4-nova-condutor"><a href="#S4-nova-condutor" class="headerlink" title="S4 nova-condutor"></a>S4 nova-condutor</h2><p>回到scheduler/manager.py的build_instances方法，nova-conductor等待nova-scheduler返回后，拿到调度的计算节点列表。因为可能同时启动多个虚拟机，因此循环调用了compute_rpcapi的build_and_run_instance方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (instance, host) in six.moves.zip(instances, hosts):</span><br><span class="line">    instance.availability_zone = (</span><br><span class="line">        availability_zones.get_host_availability_zone(context,</span><br><span class="line">                                                      host[&#x27;host&#x27;]))</span><br><span class="line">    try:</span><br><span class="line">        # NOTE(danms): This saves the az change above, refreshes our</span><br><span class="line">        # instance, and tells us if it has been deleted underneath us</span><br><span class="line">        instance.save()</span><br><span class="line">    except (exception.InstanceNotFound,</span><br><span class="line">            exception.InstanceInfoCacheNotFound):</span><br><span class="line">        LOG.debug(&#x27;Instance deleted during build&#x27;, instance=instance)</span><br><span class="line">        continue</span><br><span class="line">    ...</span><br><span class="line">    self.compute_rpcapi.build_and_run_instance(context,</span><br><span class="line">            instance=instance, host=host[&#x27;host&#x27;], image=image,</span><br><span class="line">            request_spec=request_spec,</span><br><span class="line">            filter_properties=local_filter_props,</span><br><span class="line">            admin_password=admin_password,</span><br><span class="line">            injected_files=injected_files,</span><br><span class="line">            requested_networks=requested_networks,</span><br><span class="line">            security_groups=security_groups,</span><br><span class="line">            block_device_mapping=bdms, node=host[&#x27;nodename&#x27;],</span><br><span class="line">            limits=host[&#x27;limits&#x27;])</span><br></pre></td></tr></table></figure>

<p>看到xxxrpc立即想到对应的代码位置，位于compute/rpcapi模块，该方法向nova-compute发起RPC请求:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cctxt.cast(ctxt, &#x27;build_and_run_instance&#x27;, ...)</span><br></pre></td></tr></table></figure>

<p>由于是cast调用，因此发起的是异步RPC，因此nova-conductor任务结束，紧接着终于轮到nova-compute登场了。</p>
<h2 id="S5-nova-compute"><a href="#S5-nova-compute" class="headerlink" title="S5 nova-compute"></a>S5 nova-compute</h2><p>到了nova-compute服务，入口为compute/manager.py，找到build_and_run_instance方法，该方法调用了driver的spawn方法，这里的driver就是各种hypervisor的实现，所有实现的driver都在virt目录下，入口为driver.py，比如libvirt driver实现对应为virt/libvirt/driver.py，找到spawn方法，该方法拉取镜像创建根磁盘、生成xml文件、define domain，启动domain等。最后虚拟机完成创建。nova-compute服务结束。</p>
<h2 id="3-一张图总结"><a href="#3-一张图总结" class="headerlink" title="3 一张图总结"></a>3 一张图总结</h2><p>以上是创建虚拟机的各个服务的交互过程以及调用关系，略去了很多细节。需要注意的是，所有的数据库操作，比如instance.save（）以及update()操作，如果配置use_local为false，则会向nova-conductor发起RPC调用，由nova-conductor代理完成数据库更新，而不是直接由nova-compute更新数据库，这里的RPC调用过程在以上的分析中省略了。</p>
<p>整个流程用一张图表示为:</p>
<p><img src="https://pic3.zhimg.com/v2-7df2beb26c8ef40411501294164da086_r.jpg"></p>
<p>如果你对OpenStack的其它服务以及操作流程感兴趣，可以参考我的<a href="https://link.zhihu.com/?target=https://github.com/int32bit/openstack-workflow">openstack-workflow</a>项目, 这个项目是我本人在学习过程中记录，绘制成序列图，上图就是其中一个实例。项目地址为: <a href="https://link.zhihu.com/?target=https://github.com/int32bit/openstack-workflow">https://github.com/int32bit/openstack-workflow</a>。</p>
<p>本文转自 <a href="https://zhuanlan.zhihu.com/p/28959724">https://zhuanlan.zhihu.com/p/28959724</a>，如有侵权，请联系删除。</p>
]]></content>
      <categories>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>nova</tag>
      </tags>
  </entry>
  <entry>
    <title>nova架构及源码分析</title>
    <url>/2022/06/25/nova%E6%9E%B6%E6%9E%84%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a><a href="about:blank#%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84" title="整体架构"></a>整体架构</h1><ul>
<li>  nova 和其他组件之间的交互使用 HTTP 请求</li>
<li>  内部组件之间使用 <a href="https://github.com/openstack/oslo.messaging">oslo_messaging</a> 库实现 RPC 调用，这里还涉及消息队列 RabbitMQ ，遵循 AMQP 协议</li>
<li>  大部分 nova 组件都可以运行在多个服务器上，然后使用一个管理器监听 RPC 消息</li>
<li>  而 nova-compute 是运行在计算主机上的单进程，用于管理计算资源</li>
<li>nova 内部组件共享本地数据库，通过对象层访问，确保兼容性和安全性<ul>
<li>  nova-compute 访问数据库由 nova-conductor 代理<span id="more"></span>
<img src="https://i.loli.net/2021/06/06/K51XMdUyPrRmupT.png"></li>
</ul>
</li>
</ul>
<p>当用户发起一个新的请求时，该请求会先在 nova-api 中处理。nova-api 会对请求进行一系列检查，包括请求是否合法，配额是否足够等；当检查用过后，nova-api 就会为该请求分配一个唯一的虚拟机 ID ，并在数据库中新建对应的项来记录虚拟机的状态；然后，nova-api 会将请求发送给 nova-conductor 处理。</p>
<p>nova-conductor 主要管理服务之间的通信并进行任务处理。它在接收到请求之后，会为 nova-scheduler 创建一个 RequestSpec 对象用来包装与调度相关的所有请求信息，然后调用 nova-scheduler 服务的 select_destination 接口。</p>
<p>nova-scheduler 通过接收到的 RequestSpec 对象，首先将 RequestSpec 对象转换成 ResourceRequest 对象，并将该对象发送给 Placement 进行一次预筛选，然后会根据数据库中最新的系统状态做出调度决定，并告诉 nova-conductor 把该请求调度到合适的计算节点上。</p>
<p>nova-conductor 在得知调度决定后，会把请求发送给对应的 nova-compute 服务。</p>
<p>每个 nova-compute 服务都有独立的资源监视器（Resource Tracker）用来监视本地主机的资源使用情况。当计算节点接收到请求时，资源监视器能够检查主机是否有足够的资源。</p>
<ul>
<li>  如果对应的资源足够，nova-compute 就会允许在当前主机中启动所要求的虚拟机，并在数据库中更新虚拟机状态，同时将最新的主机资源情况更新到数据库</li>
<li>  如果当前主机不符合请求的资源要求，nova-compute 会拒绝启动虚拟机，并将请求重新发给 nova-conductor 服务，重试整个调度过程</li>
</ul>
<p><img src="https://i.loli.net/2021/06/06/DizGwcpYRQhWKqS.jpg"></p>
<h2 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a><a href="about:blank#%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86" title="组成部分"></a>组成部分</h2><ol>
<li>nova-api 接受和响应用户的计算 API 调用</li>
<li>nova-api-metadata 接受来自实例的元数据请求 <a href="https://docs.openstack.org/nova/latest/admin/metadata-service.html">Metadata service</a></li>
<li>nova-compute 通过 hypervisor API 创建和终止虚拟机实例的守护进程。例如 KVM/QEMU 的 libvirt、VMware 的 VMwareAPI 。 运行在它所管理的 hypervisor 机器上，管理与虚拟机管理程序和虚拟机的通信。</li>
<li>nova-scheduler 从消息队列中获取虚拟机实例请求，并决定在哪个服务器上运行。</li>
<li>nova-conductor 处理需要协调的请求（构建/调整）、充当数据库代理或处理对象转换。用于连接 nova-api、nova-scheduler、nova-compute 服务。</li>
<li>nova-novncproxy 协调 nova-compute 服务和数据库之间的交互。避免 nova-compute 直接访问数据库，为了提供更好的 API 兼容性。建议不要部署在 nova-compute 服务所在的节点上。</li>
<li>nova-spicehtml5proxy 提供通过 SPICE 连接访问运行实例的代理，支持基于浏览器的 HTML5 客户端。</li>
<li>The queue 在守护进程之间传递消息的中央消息队列，通常使用 RabbitMQ 。</li>
<li>SQL database 存储云基础设施的大多数构建时和运行时状态，包括：可用的实例类型、在使用的实例、可用的网络、项目。</li>
</ol>
<h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a><a href="about:blank#RPC" title="RPC"></a>RPC</h1><p>消息代理（RabbitMQ AMQP broker）允许 nova 内部组件以低耦合的方式进行通信，建立在发布/订阅（publish/subscribe）模式上</p>
<ul>
<li>  解耦客户端和服务端</li>
<li>  同步客户端和服务端</li>
<li>  平衡远程调用</li>
</ul>
<p>nova 使用 AMQP 中的直连（direct）、扇型（fanout）、主题（topic）交换；</p>
<p>nova 使用适配器类（adapter）将消息封装和解封从而调用函数，实现了两种 RPC 调用</p>
<ul>
<li>  <code>rpc.call</code>：请求 + 响应，api 作为消费者（consumer）</li>
<li>  <code>rpc.cast</code>：单向，api 作为发布者（publisher）</li>
</ul>
<p>每个 nova 服务在初始化时创建两个队列</p>
<ul>
<li>  接受路由键 <code>NODE-TYPE.NODE-ID</code>（例如，<code>compute.hostname</code>）：nova-api 需要重定向到特定节点</li>
<li>  接受路由键 <code>NODE-TYPE</code>（例如，<code>compute</code>）：</li>
</ul>
<p><img src="https://i.loli.net/2021/06/06/ZvNb61tfPTlF9or.png"></p>
<p>每个 nova 内部组件都连接到消息代理，根据不同的作用，把消息队列作为：</p>
<ul>
<li>  调用者（Invoker）：nova-api、nova-scheduler；通过 <code>rpc.call</code> 和 <code>rpc.cast</code> 向消息队列发送消息</li>
<li>  工作者（Worker）：nova-compute；从消息队列接收消息，根据 <code>rpc.call</code> 进行响应</li>
</ul>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a><a href="about:blank#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5" title="相关概念"></a>相关概念</h2><p><strong>主题发布者（Topic Publisher）</strong></p>
<p>执行 <code>rpc.call</code> 或 <code>rpc.cast</code> 操作将实例化一个主题发布者，用于将消息发送到消息队列。每个发布者总是连接到相同的主题交换机（topic-based exchange）；生命周期仅限于消息传递。</p>
<p><strong>直连消费者（Direct Consumer）</strong></p>
<p>执行 <code>rpc.call</code> 操作将实例化一个直连消费者，用于从消息队列接收响应消息。每个消费者连接到唯一的直连交换机（direct-based exchange）；生命周期仅限于消息传递。</p>
<p><strong>主题消费者（Topic Consumer）</strong></p>
<p>当工作者被实例化后将实例化一个主题消费者，并存在于工作者的整个生命周期；主题消费者用于从消息队列接收消息，并调用工作者定义的操作。主题消费者通过共享/排他队列（shared/exclusive queue）连接到相同的主体交换机。每个工作者都有两个主题消费者，一个处理 <code>rpc.cast</code> ，连接到交换键是 <code>topic</code> 的共享队列；另一个处理 <code>rpc.call</code> ，连接到交换键是 <code>topic.host</code> 的独立队列。</p>
<p><strong>直连发布者（Direct Publisher）</strong></p>
<p>执行 <code>rpc.call</code> 操作将实例化一个直连发布者，用于返回请求/响应操作所需的消息，连接到直连交换机。</p>
<p><strong>主题交换机（Topic Exchange）</strong></p>
<p>存在于虚拟机上下文中的路由表；类型（主题/直连）决定了路由策略；对于 nova 中的每个主题，消息代理节点只有一个主题交换机。</p>
<p><strong>直连交换机（Direct Exchange）</strong></p>
<p>在 <code>rpc.call</code> 操作中创建的路由表，消息代理节点的生命周期中有许多该实例，对应每个 <code>rpc.call</code> 调用。</p>
<p><strong>队列元素（Queue Element）</strong></p>
<p>消息桶，消息一直保存在队列中，直到消费者（主题/直连）连接到队列获取消息。队列可以是共享的也可以是独立的；路由键是 <code>topic</code> 的队列在相同类型的工作者中共享。</p>
<h2 id="rpc-call"><a href="#rpc-call" class="headerlink" title="rpc.call"></a><a href="about:blank#rpc-call" title="rpc.call"></a>rpc.call</h2><ol>
<li>实例化主题发布者，将请求发送到消息队列；在发布操作之前，实例化直连消费者等待响应信息</li>
<li>一旦消息被交换器分派（dispatch），它就会被路由键（例如，<code>topic.host</code>）指定的主题消费者获取，并传递给负责该任务的工作者</li>
<li>任务完成后，将分配一个直连发布者将响应消息发送到消息队列</li>
<li>一旦消息被交换器分派，它就会被路由键（例如，<code>msg_id</code>）指定的直连消费者获取，并传递给调用者</li>
</ol>
<p><img src="https://i.loli.net/2021/06/06/ApK1vCySXhQE3mW.png"></p>
<h2 id="rpc-cast"><a href="#rpc-cast" class="headerlink" title="rpc.cast"></a><a href="about:blank#rpc-cast" title="rpc.cast"></a>rpc.cast</h2><ol>
<li>实例化主题发布者，将请求发送到消息队列</li>
<li>一旦消息被交换器分派（dispatch），它就会被路由键（例如，<code>topic</code>）指定的主题消费者获取，并传递给负责该任务的工作者</li>
</ol>
<p><img src="https://i.loli.net/2021/06/06/3nUaoMlKdHg9BQv.png"></p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a><a href="about:blank#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90" title="源码分析"></a>源码分析</h1><p>从 github 下载 Victoria 版本的 Nova 源码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/openstack/nova.git --branch stable/victoria --single-branch</span><br></pre></td></tr></table></figure>
<p>nova/ 文件夹下的目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">accelerator/    # Cyborg 加速器</span><br><span class="line">api/            # Nova API 服务</span><br><span class="line">cmd/            # 各个 Nova 服务的入口程序</span><br><span class="line">compute/        # Nova Compute 服务</span><br><span class="line">conductor/      # Nova Conductor 服务</span><br><span class="line">conf/           # 所有的配置选项</span><br><span class="line">console/        # nova-console 服务</span><br><span class="line">db/             # 封装数据库操作</span><br><span class="line">hacking/        # 编码规范检查</span><br><span class="line">image/          # 封装镜像操作，Glance 接口抽象</span><br><span class="line">keymgr/         # 密钥管理器实现</span><br><span class="line">locale/         # 国际化相关文件</span><br><span class="line">network/        # nova-network 服务</span><br><span class="line">notifications/  # 通知相关功能</span><br><span class="line">objects/        # 封装实体对象的 CURD 操作</span><br><span class="line">pci/            # PCI/SR-IOV 支持</span><br><span class="line">policies/       # 所有 Policy 的默认规则</span><br><span class="line">privsep/        # oslo_privsep 相关</span><br><span class="line">scheduler/      # Nova Scheduler 服务</span><br><span class="line">servicegroup/   # 成员服务（membership），服务组</span><br><span class="line">storage/        # Ceph 存储支持</span><br><span class="line">tests/          # 单元测试</span><br><span class="line">virt/           # 支持的 hypervisor 驱动</span><br><span class="line">volume/         # 封装卷访问接口，Cinder 接口抽象</span><br></pre></td></tr></table></figure>

<p>nova/ 文件夹下的 python 文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__init__.py</span><br><span class="line">availability_zones.py   # 区域设置的工具函数</span><br><span class="line">baserpc.py              # 基础 RPC 客户端/服务端实现</span><br><span class="line">block_device.py         # 块设备映射</span><br><span class="line">cache_utils.py          # oslo_cache 封装</span><br><span class="line">config.py               # 解析命令行参数</span><br><span class="line">context.py              # 贯穿 Nova 的所有请求的上下文</span><br><span class="line">crypto.py               # 包装标准加密数据元素</span><br><span class="line">debugger.py             # pydev 调试</span><br><span class="line">exception.py            # 基础异常类</span><br><span class="line">exception_wrapper.py    # 封装异常类</span><br><span class="line">filters.py              # 基础过滤器</span><br><span class="line">i18n.py                 # 集成 oslo_i18n</span><br><span class="line">loadables.py            # 可加载类</span><br><span class="line">manager.py              # 基础 Manager 类</span><br><span class="line">middleware.py           # 更新 oslo_middleware 的默认配置选项</span><br><span class="line">monkey_patch.py         # eventlet 猴子补丁</span><br><span class="line">policy.py               # 策略引擎</span><br><span class="line">profiler.py             # 调用 OSProfiler</span><br><span class="line">quota.py                # 每个项目的资源配额</span><br><span class="line">rpc.py                  # RPC 操作相关的工具函数</span><br><span class="line">safe_utils.py           # 不会导致循环导入的工具函数</span><br><span class="line">service.py              # 通用节点基类，用于在主机上运行的所有工作者</span><br><span class="line">service_auth.py         # 身份认证插件</span><br><span class="line">test.py                 # 单元测试基础类</span><br><span class="line">utils.py                # 工具函数</span><br><span class="line">version.py              # 版本号管理</span><br><span class="line">weights.py              # 权重插件</span><br><span class="line">wsgi.py                 # 管理 WSGI 应用的服务器类</span><br></pre></td></tr></table></figure>


<p>setup.cfg 配置文件，<code>[entry_points]</code> 小节指定了 nova 各个组件入口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">console_scripts =</span><br><span class="line">    nova-api = nova.cmd.api:main</span><br><span class="line">    nova-api-metadata = nova.cmd.api_metadata:main</span><br><span class="line">    nova-api-os-compute = nova.cmd.api_os_compute:main</span><br><span class="line">    nova-compute = nova.cmd.compute:main</span><br><span class="line">    nova-conductor = nova.cmd.conductor:main</span><br><span class="line">    nova-manage = nova.cmd.manage:main</span><br><span class="line">    nova-novncproxy = nova.cmd.novncproxy:main</span><br><span class="line">    nova-policy = nova.cmd.policy:main</span><br><span class="line">    nova-rootwrap = oslo_rootwrap.cmd:main</span><br><span class="line">    nova-rootwrap-daemon = oslo_rootwrap.cmd:daemon</span><br><span class="line">    nova-scheduler = nova.cmd.scheduler:main</span><br><span class="line">    nova-serialproxy = nova.cmd.serialproxy:main</span><br><span class="line">    nova-spicehtml5proxy = nova.cmd.spicehtml5proxy:main</span><br><span class="line">    nova-status = nova.cmd.status:main</span><br><span class="line">wsgi_scripts =</span><br><span class="line">    nova-api-wsgi = nova.api.openstack.compute.wsgi:init_application</span><br><span class="line">    nova-metadata-wsgi = nova.api.metadata.wsgi:init_application</span><br></pre></td></tr></table></figure>


<h2 id="nova-api"><a href="#nova-api" class="headerlink" title="nova-api"></a><a href="about:blank#nova-api" title="nova-api"></a>nova-api</h2><p>nova-api 对外提供 RESTful API，没有对内的 RPC 。</p>
<p>nova/api/ 目录结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__init__.py</span><br><span class="line">auth.py             # 身份认证中间件</span><br><span class="line">compute_req_id.py   # x-compute-request-id 中间件（oslo_middleware）</span><br><span class="line">metadata/           # Metadata API</span><br><span class="line">openstack/          # Nova v2.1 API</span><br><span class="line">validation/         # 请求体验证</span><br><span class="line">wsgi.py             # WSGI 原语（请求、应用、中间件、路由、加载器）</span><br></pre></td></tr></table></figure>


<p>openstack 目录中包含 WSGI 基础架构的代码，一些 WSGI 中间件，以及如何解析请求与分发请求的核心代码。</p>
<p>nova/api/openstack/compute/ 包含 Controller 实现，Resource 对象将 API 映射到相应的 Controller 方法上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__init__.py</span><br><span class="line">api_version_request.py  # 版本验证</span><br><span class="line">auth.py                 # noauth 中间件</span><br><span class="line">common.py               # 信息查询的工具函数</span><br><span class="line">compute/                # 每个 API 的入口点</span><br><span class="line">identity.py             # 验证项目是否存在</span><br><span class="line">requestlog.py           # 请求日志中间件</span><br><span class="line">urlmap.py               # url 映射</span><br><span class="line">versioned_method.py     # 版本信息</span><br><span class="line">wsgi.py                 # WSGI 相关抽象类</span><br><span class="line">wsgi_app.py             # WSGI 应用程序初始化方法</span><br></pre></td></tr></table></figure>

<h3 id="API-请求路由"><a href="#API-请求路由" class="headerlink" title="API 请求路由"></a><a href="about:blank#API-%E8%AF%B7%E6%B1%82%E8%B7%AF%E7%94%B1" title="API 请求路由"></a>API 请求路由</h3><p>nova-api 读取 etc/nova/api-paste.ini 并加载 WSGI 程序，最终 API 入口点都位于 nova.api.openstack.compute 中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[composite:osapi_compute]</span><br><span class="line">use = call:nova.api.openstack.urlmap:urlmap_factory</span><br><span class="line">/: oscomputeversions                # version API</span><br><span class="line">/v2: oscomputeversion_legacy_v2     # v2 API</span><br><span class="line">/v2.1: oscomputeversion_v2          # v2.1 API</span><br><span class="line"># v21 is an exactly feature match for v2, except it has more stringent</span><br><span class="line"># input validation on the wsgi surface (prevents fuzzing early on the</span><br><span class="line"># API). It also provides new features via API microversions which are</span><br><span class="line"># opt into for clients. Unaware clients will receive the same frozen</span><br><span class="line"># v2 API feature set, but with some relaxed validation</span><br><span class="line">/v2/+: openstack_compute_api_v21_legacy_v2_compatible</span><br><span class="line">/v2.1/+: openstack_compute_api_v21</span><br><span class="line"></span><br><span class="line">[composite:openstack_compute_api_v21]</span><br><span class="line">use = call:nova.api.auth:pipeline_factory_v21       # 加载中间件</span><br><span class="line">keystone = cors http_proxy_to_wsgi compute_req_id faultwrap request_log sizelimit osprofiler bees_profiler authtoken keystonecontext osapi_compute_app_v21</span><br><span class="line"># DEPRECATED: The [api]auth_strategy conf option is deprecated and will be</span><br><span class="line"># removed in a subsequent release, whereupon this pipeline will be unreachable.</span><br><span class="line">noauth2 = cors http_proxy_to_wsgi compute_req_id faultwrap request_log sizelimit osprofiler bees_profiler noauth2 osapi_compute_app_v21</span><br><span class="line"></span><br><span class="line">[app:osapi_compute_app_v21]</span><br><span class="line">paste.app_factory = nova.api.openstack.compute:APIRouterV21.factory  # 入口</span><br></pre></td></tr></table></figure>

<p>nova/api/openstack/compute/routes.py 中的 APIRouterV21 主要用来完成路由规则的创建，其中 ROUTE_LIST 保存了 URL 与 Controller 之间的映射关系。</p>
<p>APIRouterV21 基于 ROUTE_LIST，使用 Routes 模块作为 URL 映射的工具，将各个模块所实现的 API 对应的 URL 注册到 mapper 中，并把每个资源都封装成 nova.api.openstack.wsgi.Resource 对象，当解析 URL 请求时，可以通过 URL 映射找到 API 对应的 Resource 对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Router 类对 WSGI routes 模块进行了简单的封装</span><br><span class="line">class APIRouterV21(base_wsgi.Router):</span><br><span class="line">    &quot;&quot;&quot;Routes requests on the OpenStack API to the appropriate controller</span><br><span class="line">    and method. The URL mapping based on the plain list `ROUTE_LIST` is built</span><br><span class="line">    at here.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def __init__(self, custom_routes=None):</span><br><span class="line">        &quot;&quot;&quot;:param custom_routes: the additional routes can be added by this</span><br><span class="line">               parameter. This parameter is used to test on some fake routes</span><br><span class="line">               primarily.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        super(APIRouterV21, self).__init__(nova.api.openstack.ProjectMapper())</span><br><span class="line"></span><br><span class="line">        if custom_routes is None:</span><br><span class="line">            custom_routes = tuple()</span><br><span class="line"></span><br><span class="line">        for path, methods in ROUTE_LIST + custom_routes:</span><br><span class="line">            # NOTE(alex_xu): The variable &#x27;methods&#x27; is a dict in normal, since</span><br><span class="line">            # the dict includes all the methods supported in the path. But</span><br><span class="line">            # if the variable &#x27;method&#x27; is a string, it means a redirection.</span><br><span class="line">            # For example, the request to the &#x27;&#x27; will be redirect to the &#x27;/&#x27; in</span><br><span class="line">            # the Nova API. To indicate that, using the target path instead of</span><br><span class="line">            # a dict. The route entry just writes as &quot;(&#x27;&#x27;, &#x27;/)&quot;.</span><br><span class="line">            if isinstance(methods, six.string_types):</span><br><span class="line">                self.map.redirect(path, methods)</span><br><span class="line">                continue</span><br><span class="line"></span><br><span class="line">            for method, controller_info in methods.items():</span><br><span class="line">                # TODO(alex_xu): In the end, I want to create single controller</span><br><span class="line">                # instance instead of create controller instance for each</span><br><span class="line">                # route.</span><br><span class="line">                controller = controller_info[0]()</span><br><span class="line">                action = controller_info[1]</span><br><span class="line">                self.map.create_route(path, method, controller, action)</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def factory(cls, global_config, **local_config):</span><br><span class="line">        &quot;&quot;&quot;Simple paste factory, :class:`nova.wsgi.Router` doesn&#x27;t have one.&quot;&quot;&quot;</span><br><span class="line">        return cls()</span><br></pre></td></tr></table></figure>

<p>nova/api/wsgi.py 解析 URL 映射，通过 _dispatch 回调，调用 Resource 对象的 _<em>call</em>_ 方法，最终通过请求调用 API 对应的模块中的方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 路由</span><br><span class="line">class Router(object):</span><br><span class="line">    &quot;&quot;&quot;WSGI middleware that maps incoming requests to WSGI apps.&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, mapper):</span><br><span class="line">        &quot;&quot;&quot;Create a router for the given routes.Mapper.</span><br><span class="line"></span><br><span class="line">        Each route in `mapper` must specify a &#x27;controller&#x27;, which is a</span><br><span class="line">        WSGI app to call.  You&#x27;ll probably want to specify an &#x27;action&#x27; as</span><br><span class="line">        well and have your controller be an object that can route</span><br><span class="line">        the request to the action-specific method.</span><br><span class="line"></span><br><span class="line">        Examples:</span><br><span class="line">          mapper = routes.Mapper()</span><br><span class="line">          sc = ServerController()</span><br><span class="line"></span><br><span class="line">          # Explicit mapping of one route to a controller+action</span><br><span class="line">          mapper.connect(None, &#x27;/svrlist&#x27;, controller=sc, action=&#x27;list&#x27;)</span><br><span class="line"></span><br><span class="line">          # Actions are all implicitly defined</span><br><span class="line">          mapper.resource(&#x27;server&#x27;, &#x27;servers&#x27;, controller=sc)</span><br><span class="line"></span><br><span class="line">          # Pointing to an arbitrary WSGI app.  You can specify the</span><br><span class="line">          # &#123;path_info:.*&#125; parameter so the target app can be handed just that</span><br><span class="line">          # section of the URL.</span><br><span class="line">          mapper.connect(None, &#x27;/v1.0/&#123;path_info:.*&#125;&#x27;, controller=BlogApp())</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.map = mapper</span><br><span class="line">        # 使用 routes 模块关联 mapper 和 _dispatch</span><br><span class="line">        # routes.middleware.RoutesMiddleware 设置 environ 信息</span><br><span class="line">        self._router = routes.middleware.RoutesMiddleware(self._dispatch,</span><br><span class="line">                                                          self.map)</span><br><span class="line"></span><br><span class="line">    @webob.dec.wsgify(RequestClass=Request)</span><br><span class="line">    def __call__(self, req):</span><br><span class="line">        &quot;&quot;&quot;Route the incoming request to a controller based on self.map.</span><br><span class="line"></span><br><span class="line">        If no match, return a 404.</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 根据 mapper 将请求路由到 WSGI 应用（资源）</span><br><span class="line">        # 每个资源会在 __call__ 方法中根据 HTTP 请求的 URL 路由到对应 Controller 上的方法（Action）</span><br><span class="line">        return self._router</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    @webob.dec.wsgify(RequestClass=Request)</span><br><span class="line">    def _dispatch(req):</span><br><span class="line">        &quot;&quot;&quot;Dispatch the request to the appropriate controller.</span><br><span class="line"></span><br><span class="line">        Called by self._router after matching the incoming request to a route</span><br><span class="line">        and putting the information into req.environ.  Either returns 404</span><br><span class="line">        or the routed WSGI app&#x27;s response.</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 根据 HTTP 请求的 environ 信息找到 URL 对应的 Controller</span><br><span class="line">        match = req.environ[&#x27;wsgiorg.routing_args&#x27;][1]</span><br><span class="line">        if not match:</span><br><span class="line">            return webob.exc.HTTPNotFound()</span><br><span class="line">        app = match[&#x27;controller&#x27;]</span><br><span class="line">        return app</span><br></pre></td></tr></table></figure>

<h3 id="API-实现"><a href="#API-实现" class="headerlink" title="API 实现"></a><a href="about:blank#API-%E5%AE%9E%E7%8E%B0" title="API 实现"></a>API 实现</h3><p>nova/api/openstack/compute/ 目录包含每个 API 对应的 Controller 实现，Resource 对象将请求的 API 映射到相应的 Controller 方法上。</p>
<p>以 keypairs.py （密钥对管理扩展）为例，公共方法包含 create、delete、show、index，多个实现对应不同的 Microversion（使用 <code>@wsgi.Controller.api_version</code> 装饰器）</p>
<ul>
<li>  <code>@wsgi.expected_errors</code>：API 允许的错误返回码</li>
<li>  <code>@validation.query_schema</code>：请求对应的 json schema</li>
<li>  <code>@wsgi.response</code>：API 请求正常返回码</li>
<li>  <code>@wsgi.action</code>：注册 action</li>
</ul>
<p>Microversion 用于实现兼容性。</p>
<p>nova/api/openstack/compute/schemas 包含允许的 json schema，表示接受的键值对及其类型。</p>
<p>通过方法接口可以得到 webob.Request 对象，从 Request 对象中可以获取其他请求参数，用于执行对应的操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class KeypairController(wsgi.Controller):</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;Keypair API controller for the OpenStack API.&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    _view_builder_class = keypairs_view.ViewBuilder</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        super(KeypairController, self).__init__()</span><br><span class="line">        self.api = compute_api.KeypairAPI()</span><br><span class="line"></span><br><span class="line">    @wsgi.Controller.api_version(&quot;2.10&quot;)</span><br><span class="line">    @wsgi.response(201)</span><br><span class="line">    @wsgi.expected_errors((400, 403, 409))</span><br><span class="line">    @validation.schema(keypairs.create_v210)</span><br><span class="line">    def create(self, req, body):</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    @wsgi.Controller.api_version(&quot;2.2&quot;, &quot;2.9&quot;)  # noqa</span><br><span class="line">    @wsgi.response(201)</span><br><span class="line">    @wsgi.expected_errors((400, 403, 409))</span><br><span class="line">    @validation.schema(keypairs.create_v22)</span><br><span class="line">    def create(self, req, body):  # noqa</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>

<h2 id="nova-conductor"><a href="#nova-conductor" class="headerlink" title="nova-conductor"></a><a href="about:blank#nova-conductor" title="nova-conductor"></a>nova-conductor</h2><p>使用 RPC 的子组件通常包含以下文件：</p>
<ul>
<li>  api.py 对 RPC 接口进行封装，类似提供 SDK</li>
<li>  rpcapi.py 暴露给其他内部组件的 RPC 接口，RPC 客户端</li>
<li>  manager.py 处理 RPC API 调用</li>
</ul>
<p>nova-compute 访问数据库的操作都要由 nova-conductor 代理，用 nova/conductor/manager.py 的 ConductorManager 类完成，出于安全性考虑，nova-conductor 和 nova-compute 不能部署在同一服务器上。</p>
<p>nova/objects 定义了 nova object，封装数据库 CURD 操作，每个类对应数据库中的一张表。</p>
<h2 id="nova-scheduler"><a href="#nova-scheduler" class="headerlink" title="nova-scheduler"></a><a href="about:blank#nova-scheduler" title="nova-scheduler"></a>nova-scheduler</h2><p>nova-scheduler 执行调度决策，nova-compute 收集并更新主机数据，实时写入数据库（周期任务）。</p>
<p>nova/scheduler/filters 包含所有的过滤器实现，用于过滤不符合条件的主机；nova/scheduler/weights 包含所有的权重实现，用于计算权重并排序。</p>
<h1 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a><a href="about:blank#%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B" title="启动流程"></a>启动流程</h1><p><strong>nova-api</strong> 启动入口 <code>nova.cmd.api:main</code></p>
<ul>
<li>  <a href="https://docs.openstack.org/nova/queens/reference/gmr.html">Guru Meditation Reports</a></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def main():</span><br><span class="line">    config.parse_args(sys.argv) # 解析参数</span><br><span class="line">    logging.setup(CONF, &quot;nova&quot;) # 设置日志</span><br><span class="line">    objects.register_all()      # 注册 nova object</span><br><span class="line">    gmr_opts.set_defaults(CONF) # 设置 oslo_reports</span><br><span class="line">    if &#x27;osapi_compute&#x27; in CONF.enabled_apis:</span><br><span class="line">        # NOTE(mriedem): This is needed for caching the nova-compute service</span><br><span class="line">        # version.</span><br><span class="line">        objects.Service.enable_min_version_cache()</span><br><span class="line">    log = logging.getLogger(__name__)</span><br><span class="line"></span><br><span class="line">    # 生成报告的机制 Guru Meditation Report (GMR)</span><br><span class="line">    gmr.TextGuruMeditation.setup_autorun(version, conf=CONF)</span><br><span class="line"></span><br><span class="line">    # oslo_service.ProcessLauncher</span><br><span class="line">    launcher = service.process_launcher()</span><br><span class="line">    started = 0</span><br><span class="line">    # 根据 paste-ini 文件创建 WSGI 应用</span><br><span class="line">    for api in CONF.enabled_apis:</span><br><span class="line">        should_use_ssl = api in CONF.enabled_ssl_apis</span><br><span class="line">        try:</span><br><span class="line">            # nova.service.WSGIService 初始化 WSGI 程序</span><br><span class="line">            server = service.WSGIService(api, use_ssl=should_use_ssl)</span><br><span class="line">            # oslo_service.ProcessLauncher 创建子进程启动服务</span><br><span class="line">            launcher.launch_service(server, workers=server.workers or 1)</span><br><span class="line">            started += 1</span><br><span class="line">        except exception.PasteAppNotFound as ex:</span><br><span class="line">            log.warning(&quot;%s. ``enabled_apis`` includes bad values. &quot;</span><br><span class="line">                        &quot;Fix to remove this warning.&quot;, ex)</span><br><span class="line"></span><br><span class="line">    if started == 0:</span><br><span class="line">        log.error(&#x27;No APIs were started. &#x27;</span><br><span class="line">                  &#x27;Check the enabled_apis config option.&#x27;)</span><br><span class="line">        sys.exit(1)</span><br><span class="line"></span><br><span class="line">    # 等待子进程终止</span><br><span class="line">    launcher.wait()</span><br></pre></td></tr></table></figure>

<p>nova.service.WSGIService 的初始化函数实例化 nova.wsgi.Server ，启动函数实际调用了 nova.wsgi.Server 的 start 方法。</p>
<p>其中的 self._socket 使用 <code>eventlet.listen</code> 创建，最后使用 utils 中封装的 spawn 函数启动 WSGI 程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Server(service.ServiceBase):</span><br><span class="line">    &quot;&quot;&quot;Server class to manage a WSGI server, serving a WSGI application.&quot;&quot;&quot;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    def start(self):</span><br><span class="line">        &quot;&quot;&quot;Start serving a WSGI application.</span><br><span class="line"></span><br><span class="line">        :returns: None</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # The server socket object will be closed after server exits,</span><br><span class="line">        # but the underlying file descriptor will remain open, and will</span><br><span class="line">        # give bad file descriptor error. So duplicating the socket object,</span><br><span class="line">        # to keep file descriptor usable.</span><br><span class="line"></span><br><span class="line">        dup_socket = self._socket.dup()</span><br><span class="line">        dup_socket.setsockopt(socket.SOL_SOCKET,</span><br><span class="line">                              socket.SO_REUSEADDR, 1)</span><br><span class="line">        # sockets can hang around forever without keepalive</span><br><span class="line">        dup_socket.setsockopt(socket.SOL_SOCKET,</span><br><span class="line">                              socket.SO_KEEPALIVE, 1)</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        self._server = utils.spawn(**wsgi_kwargs)</span><br></pre></td></tr></table></figure>


<p><strong>nova-conductor</strong> 启动入口 <code>nova.cmd.conductor:main</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def main():</span><br><span class="line">    config.parse_args(sys.argv)</span><br><span class="line">    logging.setup(CONF, &quot;nova&quot;)</span><br><span class="line">    objects.register_all()</span><br><span class="line">    gmr_opts.set_defaults(CONF)</span><br><span class="line">    objects.Service.enable_min_version_cache()</span><br><span class="line"></span><br><span class="line">    gmr.TextGuruMeditation.setup_autorun(version, conf=CONF)</span><br><span class="line"></span><br><span class="line">    # nova.service.Service 实例化 Service 对象</span><br><span class="line">    server = service.Service.create(binary=&#x27;nova-conductor&#x27;,</span><br><span class="line">                                    topic=rpcapi.RPC_TOPIC)</span><br><span class="line">    workers = CONF.conductor.workers or processutils.get_worker_count()</span><br><span class="line">    # oslo_service.launch 创建 launcher</span><br><span class="line">    service.serve(server, workers=workers)</span><br><span class="line">    # 调用 launcher.wait 等待子进程终止</span><br><span class="line">    service.wait()</span><br></pre></td></tr></table></figure>

<p>nova.service.Service 初始化函数接受 manager 对象，通过监听消息队列启用 RPC 服务；设置定期任务报告状态，并写入数据库。</p>
<ul>
<li>  nova-compute</li>
<li>  nova-conductor</li>
<li>  nova-scheduler</li>
</ul>
<p>RPC 服务启动时创建 rpc_client 用于发送消息，创建 rpc_server 用于接收消息，分派执行。</p>
<p><strong>1. rpc_client</strong></p>
<p>nova/cmd/conductor.py 实际创建 Service 实例</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server = service.Service.create(binary=&#x27;nova-conductor&#x27;,</span><br><span class="line">                                topic=rpcapi.RPC_TOPIC)</span><br></pre></td></tr></table></figure>


<p>nova/service.py 初始化函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建 _driver</span><br><span class="line">self.servicegroup_api = servicegroup.API()</span><br><span class="line"></span><br><span class="line"># 动态导入 manager 类</span><br><span class="line">manager_class = importutils.import_class(self.manager_class_name)</span><br><span class="line"></span><br><span class="line">if objects_base.NovaObject.indirection_api:</span><br><span class="line">    # 创建 RPCClient</span><br><span class="line">    conductor_api = conductor.API()</span><br><span class="line">    # 等待 nova-conductor 启动</span><br><span class="line">    conductor_api.wait_until_ready(context.get_admin_context())</span><br></pre></td></tr></table></figure>


<p>nova/servicegroup/api.py 创建 _driver</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">driver_class = _driver_name_class_mapping[CONF.servicegroup_driver]</span><br><span class="line">self._driver = importutils.import_object(driver_class,</span><br><span class="line">                                         *args, **kwargs)</span><br></pre></td></tr></table></figure>



<p>nova/conductor/api.py 实际调用 rpcapi.py</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def __init__(self):</span><br><span class="line">    self.conductor_rpcapi = rpcapi.ConductorAPI()</span><br><span class="line">    self.base_rpcapi = baserpc.BaseAPI(topic=rpcapi.RPC_TOPIC)</span><br></pre></td></tr></table></figure>



<p>nova/conductor/rpcapi.py 设置 rpc_client</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def __init__(self):</span><br><span class="line">    super(ConductorAPI, self).__init__()</span><br><span class="line">    target = messaging.Target(topic=RPC_TOPIC, version=&#x27;3.0&#x27;)</span><br><span class="line">    version_cap = self.VERSION_ALIASES.get(CONF.upgrade_levels.conductor,</span><br><span class="line">                                           CONF.upgrade_levels.conductor)</span><br><span class="line">    serializer = objects_base.NovaObjectSerializer()</span><br><span class="line">    # rpc client</span><br><span class="line">    self.client = rpc.get_client(target,</span><br><span class="line">                                 version_cap=version_cap,</span><br><span class="line">                                 serializer=serializer)</span><br></pre></td></tr></table></figure>


<p>nova/baserpc.py 设置 rpc_client</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def __init__(self, topic):</span><br><span class="line">    super(BaseAPI, self).__init__()</span><br><span class="line">    target = messaging.Target(topic=topic,</span><br><span class="line">                              namespace=_NAMESPACE,</span><br><span class="line">                              version=&#x27;1.0&#x27;)</span><br><span class="line">    version_cap = self.VERSION_ALIASES.get(CONF.upgrade_levels.baseapi,</span><br><span class="line">                                           CONF.upgrade_levels.baseapi)</span><br><span class="line">    self.client = rpc.get_client(target, version_cap=version_cap)</span><br></pre></td></tr></table></figure>



<p><strong>2. rpc_server</strong></p>
<p>nova/cmd/conductor.py 使用 Service 实例启动服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># oslo_service.launch 创建 launcher</span><br><span class="line">service.serve(server, workers=workers)</span><br><span class="line"># 调用 launcher.wait 等待子进程终止</span><br><span class="line">service.wait()</span><br></pre></td></tr></table></figure>


<p>nova/service.py 实际调用 <a href="https://github.com/openstack/oslo.service">oslo_service</a> 的 launch 函数，创建绿色线程（greenthread）或进程，最终调用 Service 实例的 start 方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def serve(server, workers=None):</span><br><span class="line">    global _launcher</span><br><span class="line">    if _launcher:</span><br><span class="line">        raise RuntimeError(_(&#x27;serve() can only be called once&#x27;))</span><br><span class="line"></span><br><span class="line">    _launcher = service.launch(CONF, server, workers=workers,</span><br><span class="line">                               restart_method=&#x27;mutate&#x27;)</span><br></pre></td></tr></table></figure>


<p>nova/service.py Service 实例的 start 方法创建 rpc_server 和 dispatcher；设置周期任务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建 rpc server 以及 dispatcher</span><br><span class="line">self.rpcserver = rpc.get_server(target, endpoints, serializer)</span><br><span class="line">self.rpcserver.start()</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">if self.periodic_enable:</span><br><span class="line">    if self.periodic_fuzzy_delay:</span><br><span class="line">        initial_delay = random.randint(0, self.periodic_fuzzy_delay)</span><br><span class="line">    else:</span><br><span class="line">        initial_delay = None</span><br><span class="line"></span><br><span class="line">    self.tg.add_dynamic_timer(self.periodic_tasks,</span><br><span class="line">                             initial_delay=initial_delay,</span><br><span class="line">                             periodic_interval_max=</span><br><span class="line">                                self.periodic_interval_max)</span><br></pre></td></tr></table></figure>


<p>收到消息后主要由 <a href="https://github.com/openstack/oslo.messaging">oslo_messaging</a> 进行解析和处理，核心是 oslo_messaging/rpc/dispatcher.py</p>
<p>incoming 是 AMQP 消息格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def dispatch(self, incoming):</span><br><span class="line">    &quot;&quot;&quot;Dispatch an RPC message to the appropriate endpoint method.</span><br><span class="line"></span><br><span class="line">    :param incoming: incoming message</span><br><span class="line">    :type incoming: IncomingMessage</span><br><span class="line">    :raises: NoSuchMethod, UnsupportedVersion</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    message = incoming.message</span><br><span class="line">    ctxt = incoming.ctxt</span><br><span class="line"></span><br><span class="line">    method = message.get(&#x27;method&#x27;)</span><br><span class="line">    args = message.get(&#x27;args&#x27;, &#123;&#125;)</span><br><span class="line">    namespace = message.get(&#x27;namespace&#x27;)</span><br><span class="line">    version = message.get(&#x27;version&#x27;, &#x27;1.0&#x27;)</span><br><span class="line"></span><br><span class="line">    # NOTE(danms): This event and watchdog thread are used to send</span><br><span class="line">    # call-monitoring heartbeats for this message while the call</span><br><span class="line">    # is executing if it runs for some time. The thread will wait</span><br><span class="line">    # for the event to be signaled, which we do explicitly below</span><br><span class="line">    # after dispatching the method call.</span><br><span class="line">    completion_event = eventletutils.Event()</span><br><span class="line">    watchdog_thread = threading.Thread(target=self._watchdog,</span><br><span class="line">                                       args=(completion_event, incoming))</span><br><span class="line">    if incoming.client_timeout:</span><br><span class="line">        # NOTE(danms): The client provided a timeout, so we start</span><br><span class="line">        # the watchdog thread. If the client is old or didn&#x27;t send</span><br><span class="line">        # a timeout, we just never start the watchdog thread.</span><br><span class="line">        watchdog_thread.start()</span><br><span class="line"></span><br><span class="line">    found_compatible = False</span><br><span class="line">    for endpoint in self.endpoints:</span><br><span class="line">        target = getattr(endpoint, &#x27;target&#x27;, None)</span><br><span class="line">        if not target:</span><br><span class="line">            target = self._default_target</span><br><span class="line"></span><br><span class="line">        if not (self._is_namespace(target, namespace) and</span><br><span class="line">                self._is_compatible(target, version)):</span><br><span class="line">            continue</span><br><span class="line"></span><br><span class="line">        if hasattr(endpoint, method):</span><br><span class="line">            if self.access_policy.is_allowed(endpoint, method):</span><br><span class="line">                try:</span><br><span class="line">                    # 分派，调用函数</span><br><span class="line">                    return self._do_dispatch(endpoint, method, ctxt, args)</span><br><span class="line">                finally:</span><br><span class="line">                    completion_event.set()</span><br><span class="line">                    if incoming.client_timeout:</span><br><span class="line">                        watchdog_thread.join()</span><br><span class="line"></span><br><span class="line">        found_compatible = True</span><br><span class="line"></span><br><span class="line">    if found_compatible:</span><br><span class="line">        raise NoSuchMethod(method)</span><br><span class="line">    else:</span><br><span class="line">        raise UnsupportedVersion(version, method=method)</span><br></pre></td></tr></table></figure>


<p>oslo_messaging/rpc/dispatcher.py 调用函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def _do_dispatch(self, endpoint, method, ctxt, args):</span><br><span class="line">    ctxt = self.serializer.deserialize_context(ctxt)</span><br><span class="line">    new_args = dict()</span><br><span class="line">    for argname, arg in args.items():</span><br><span class="line">        new_args[argname] = self.serializer.deserialize_entity(ctxt, arg)</span><br><span class="line">    func = getattr(endpoint, method)</span><br><span class="line">    result = func(ctxt, **new_args)</span><br><span class="line">    return self.serializer.serialize_entity(ctxt, result)</span><br></pre></td></tr></table></figure>


<p>发送消息的实现都在 nova/conductor/rpcapi.py 中，cctxt.call 同步调用，cctxt.cast 异步调用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def object_class_action_versions(self, context, objname, objmethod,</span><br><span class="line">                                 object_versions, args, kwargs):</span><br><span class="line">    cctxt = self.client.prepare()</span><br><span class="line">    return cctxt.call(context, &#x27;object_class_action_versions&#x27;,</span><br><span class="line">                      objname=objname, objmethod=objmethod,</span><br><span class="line">                      object_versions=object_versions,</span><br><span class="line">                      args=args, kwargs=kwargs)</span><br><span class="line"></span><br><span class="line">def cache_images(self, ctxt, aggregate, image_ids):</span><br><span class="line">    version = &#x27;1.21&#x27;</span><br><span class="line">    if not self.client.can_send_version(version):</span><br><span class="line">        raise exception.NovaException(&#x27;Conductor RPC version pin does not &#x27;</span><br><span class="line">                                      &#x27;allow cache_images() to be called&#x27;)</span><br><span class="line">    cctxt = self.client.prepare(version=version)</span><br><span class="line">    cctxt.cast(ctxt, &#x27;cache_images&#x27;, aggregate=aggregate,</span><br><span class="line">               image_ids=image_ids)</span><br></pre></td></tr></table></figure>


<p>由 oslo_messaging/rpc/client.py 实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">def cast(self, ctxt, method, **kwargs):</span><br><span class="line">    &quot;&quot;&quot;Invoke a method and return immediately. See RPCClient.cast().&quot;&quot;&quot;</span><br><span class="line">    msg = self._make_message(ctxt, method, kwargs)</span><br><span class="line">    msg_ctxt = self.serializer.serialize_context(ctxt)</span><br><span class="line"></span><br><span class="line">    self._check_version_cap(msg.get(&#x27;version&#x27;))</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        self.transport._send(self.target, msg_ctxt, msg,</span><br><span class="line">                             retry=self.retry,</span><br><span class="line">                             transport_options=self.transport_options)</span><br><span class="line">    except driver_base.TransportDriverError as ex:</span><br><span class="line">        raise ClientSendError(self.target, ex)</span><br><span class="line"></span><br><span class="line">def call(self, ctxt, method, **kwargs):</span><br><span class="line">    &quot;&quot;&quot;Invoke a method and wait for a reply. See RPCClient.call().&quot;&quot;&quot;</span><br><span class="line">    if self.target.fanout:</span><br><span class="line">        raise exceptions.InvalidTarget(&#x27;A call cannot be used with fanout&#x27;,</span><br><span class="line">                                       self.target)</span><br><span class="line"></span><br><span class="line">    msg = self._make_message(ctxt, method, kwargs)</span><br><span class="line">    msg_ctxt = self.serializer.serialize_context(ctxt)</span><br><span class="line"></span><br><span class="line">    timeout = self.timeout</span><br><span class="line">    if self.timeout is None:</span><br><span class="line">        timeout = self.conf.rpc_response_timeout</span><br><span class="line"></span><br><span class="line">    cm_timeout = self.call_monitor_timeout</span><br><span class="line"></span><br><span class="line">    self._check_version_cap(msg.get(&#x27;version&#x27;))</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        result = \</span><br><span class="line">            self.transport._send(self.target, msg_ctxt, msg,</span><br><span class="line">                                 wait_for_reply=True, timeout=timeout,</span><br><span class="line">                                 call_monitor_timeout=cm_timeout,</span><br><span class="line">                                 retry=self.retry,</span><br><span class="line">                                 transport_options=self.transport_options)</span><br><span class="line">    except driver_base.TransportDriverError as ex:</span><br><span class="line">        raise ClientSendError(self.target, ex)</span><br><span class="line"></span><br><span class="line">    return self.serializer.deserialize_entity(ctxt, result)</span><br></pre></td></tr></table></figure>


<p>关于周期任务，nova/scheduler/manager.py 中使用 <code>@periodic_task.periodic_task</code> 装饰的方法将会被周期调用，从 scheduler 的调试日志可以看到周期任务的运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">********************************************************************* log_opt_values /home/jck/.local/lib/python3.6/site-packages/oslo_config/cfg.py:2591</span><br><span class="line">2021-05-18 05:53:17.030 3501 DEBUG oslo_service.periodic_task [req-66b43add-49c7-4f33-8f6b-1e33cb9f0123 - - - - -] Running periodic task SchedulerManager._run_periodic_tasks run_periodic_tasks /home/jck/.local/lib/python3.6/site-packages/oslo_service/periodic_task.py:211</span><br><span class="line">2021-05-18 05:53:39.072 3500 DEBUG oslo_service.periodic_task [req-8436b3e2-96d1-4f15-8ae8-b596cee05536 - - - - -] Running periodic task SchedulerManager._run_periodic_tasks run_periodic_tasks /home/jck/.local/lib/python3.6/site-packages/oslo_service/periodic_task.py:211</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>对应于 nova/scheduler/manager.py</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@periodic_task.periodic_task(spacing=CONF.scheduler.periodic_task_interval,</span><br><span class="line">                             run_immediately=True)</span><br><span class="line">def _run_periodic_tasks(self, context):</span><br><span class="line">    self.driver.run_periodic_tasks(context)</span><br></pre></td></tr></table></figure>

<p>执行周期任务的有 nova-scheduler 和 nova-compute ，主要功能是计算节点 nova-compute 上报资源信息，nova-scheduler 读取数据库，更新资源信息缓存。</p>
<h1 id="参阅"><a href="#参阅" class="headerlink" title="参阅"></a><a href="about:blank#%E5%8F%82%E9%98%85" title="参阅"></a>参阅</h1><ul>
<li>  <a href="https://docs.openstack.org/nova/latest/user/architecture.html">Nova System Architecture</a></li>
<li>  <a href="https://docs.openstack.org/nova/latest/install/get-started-compute.html">Compute service overview</a></li>
<li>  <a href="https://docs.openstack.org/nova/latest/reference/rpc.html">AMQP and Nova</a></li>
<li>  <a href="https://docs.openstack.org/nova/latest/reference/scheduling.html">Scheduling</a></li>
<li>  <a href="https://docs.openstack.org/nova/latest/user/cellsv2-layout.html">Cells Layout (v2)</a></li>
<li>  <a href="https://www.rabbitmq.com/tutorials/amqp-concepts.html">AMQP 0-9-1 Model Explained</a></li>
<li>  <a href="https://rabbitmq.mr-ping.com/AMQP/AMQP_0-9-1_Model_Explained.html">AMQP 0-9-1 简介</a></li>
<li>  <a href="https://docs.openstack.org/nova/latest/admin/metadata-service.html">Metadata service</a></li>
<li>  <a href="https://docs.openstack.org/nova/queens/reference/gmr.html">Guru Meditation Reports</a></li>
</ul>
]]></content>
      <categories>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>nova</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker run 命令参数</title>
    <url>/2022/06/24/Docker-run-%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h2 id="Docker-run-命令参数及使用"><a href="#Docker-run-命令参数及使用" class="headerlink" title="Docker run 命令参数及使用"></a>Docker run 命令参数及使用</h2><h3 id="Docker-run-：创建一个新的容器并运行一个命令"><a href="#Docker-run-：创建一个新的容器并运行一个命令" class="headerlink" title="Docker run ：创建一个新的容器并运行一个命令"></a>Docker run ：创建一个新的容器并运行一个命令</h3><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]  </span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h3 id="OPTIONS说明："><a href="#OPTIONS说明：" class="headerlink" title="OPTIONS说明："></a>OPTIONS说明：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@www ~]# docker run --help  </span><br><span class="line">  </span><br><span class="line">Usage:  docker run [OPTIONS] IMAGE [COMMAND] [ARG...]  </span><br><span class="line">  </span><br><span class="line">Run a command in a new container  </span><br><span class="line">  </span><br><span class="line">  -a, --attach=[]                 Attach to STDIN, STDOUT or STDERR  </span><br><span class="line">  --add-host=[]                   Add a custom host-to-IP mapping (host:ip)  </span><br><span class="line">  --blkio-weight=0                Block IO (relative weight), between 10 and 1000  </span><br><span class="line">  --cpu-shares=0                  CPU shares (relative weight)  </span><br><span class="line">  --cap-add=[]                    Add Linux capabilities  </span><br><span class="line">  --cap-drop=[]                   Drop Linux capabilities  </span><br><span class="line">  --cgroup-parent=                Optional parent cgroup for the container  </span><br><span class="line">  --cidfile=                      Write the container ID to the file  </span><br><span class="line">  --cpu-period=0                  Limit CPU CFS (Completely Fair Scheduler) period  </span><br><span class="line">  --cpu-quota=0                   Limit CPU CFS (Completely Fair Scheduler) quota  </span><br><span class="line">  --cpuset-cpus=                  CPUs in which to allow execution (0-3, 0,1)  </span><br><span class="line">  --cpuset-mems=                  MEMs in which to allow execution (0-3, 0,1)  </span><br><span class="line">  -d, --detach=false            Run container in background and print container ID(后台运行)  </span><br><span class="line">  --device=[]                     Add a host device to the container  </span><br><span class="line">  --disable-content-trust=true    Skip image verification  </span><br><span class="line">  --dns=[]                        Set custom DNS servers  </span><br><span class="line">  --dns-opt=[]                    Set DNS options  </span><br><span class="line">  --dns-search=[]                 Set custom DNS search domains  </span><br><span class="line">  -e, --env=[]                    Set environment variables(设置环境变量)  </span><br><span class="line">  --entrypoint=                   Overwrite the default ENTRYPOINT of the image  </span><br><span class="line">  --env-file=[]                   Read in a file of environment variables  </span><br><span class="line">  --expose=[]                     Expose a port or a range of ports  </span><br><span class="line">  --group-add=[]                  Add additional groups to join  </span><br><span class="line">  -h, --hostname=                 Container host name  </span><br><span class="line">  --help=false                    Print usage  </span><br><span class="line"> -i, --interactive=false         Keep STDIN open even if not attached(保持容器运行)  </span><br><span class="line">  --ipc=                          IPC namespace to use  </span><br><span class="line">  --kernel-memory=                Kernel memory limit  </span><br><span class="line">  -l, --label=[]                  Set meta data on a container  </span><br><span class="line">  --label-file=[]                 Read in a line delimited file of labels  </span><br><span class="line"> --link=[]                       Add link to another container(容器之间的通讯)  </span><br><span class="line">  --log-driver=                   Logging driver for container  </span><br><span class="line">  --log-opt=[]                    Log driver options  </span><br><span class="line">  --lxc-conf=[]                   Add custom lxc options  </span><br><span class="line">  -m, --memory=                   Memory limit  </span><br><span class="line">  --mac-address=                  Container MAC address (e.g. 92:d0:c6:0a:29:33)  </span><br><span class="line">  --memory-reservation=           Memory soft limit  </span><br><span class="line">  --memory-swap=                  Total memory (memory + swap), &#x27;-1&#x27; to disable swap  </span><br><span class="line">  --memory-swappiness=-1          Tuning container memory swappiness (0 to 100)  </span><br><span class="line"> --name=                         Assign a name to the container(指定容器名称)  </span><br><span class="line">  --net=default                   Set the Network for the container  </span><br><span class="line">  --oom-kill-disable=false        Disable OOM Killer  </span><br><span class="line">  -P, --publish-all=false         Publish all exposed ports to random ports  </span><br><span class="line"> -p, --publish=[]                Publish a container&#x27;s port(s) to the host(端口映射 80:8080)  </span><br><span class="line">  --pid=                          PID namespace to use  </span><br><span class="line">  --privileged=false              Give extended privileges to this container  </span><br><span class="line">  --read-only=false               Mount the container&#x27;s root filesystem as read only  </span><br><span class="line">  --restart=no                    Restart policy to apply when a container exits  </span><br><span class="line">  --rm=false                      Automatically remove the container when it exits  </span><br><span class="line">  --security-opt=[]               Security Options  </span><br><span class="line">  --shm-size=                     Size of /dev/shm, default value is 64MB  </span><br><span class="line">  --sig-proxy=true                Proxy received signals to the process  </span><br><span class="line">  --stop-signal=SIGTERM           Signal to stop a container, SIGTERM by default  </span><br><span class="line">  -t, --tty=false                 Allocate a pseudo-TTY  </span><br><span class="line">  -u, --user=                     Username or UID (format: &lt;name|uid&gt;[:&lt;group|gid&gt;])  </span><br><span class="line">  --ulimit=[]                     Ulimit options  </span><br><span class="line">  --uts=                          UTS namespace to use  </span><br><span class="line"> -v, --volume=[]                 Bind mount a volume(挂载目录 /root:/opt/temp)  </span><br><span class="line">  --volume-driver=                Optional volume driver for the container  </span><br><span class="line">  --volumes-from=[]               Mount volumes from the specified container(s)  </span><br><span class="line">  -w, --workdir=                  Working directory inside the container  </span><br></pre></td></tr></table></figure>

<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h5 id="使用docker镜像nginx-latest以后台模式启动一个容器-并将容器命名为mynginx。"><a href="#使用docker镜像nginx-latest以后台模式启动一个容器-并将容器命名为mynginx。" class="headerlink" title="使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx。"></a>使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --name mynginx -d nginx:latest  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="使用镜像nginx-latest以后台模式启动一个容器-并将容器的80端口映射到主机随机端口。"><a href="#使用镜像nginx-latest以后台模式启动一个容器-并将容器的80端口映射到主机随机端口。" class="headerlink" title="使用镜像nginx:latest以后台模式启动一个容器,并将容器的80端口映射到主机随机端口。"></a>使用镜像nginx:latest以后台模式启动一个容器,并将容器的80端口映射到主机随机端口。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -P -d nginx:latest  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="使用镜像nginx-latest以后台模式启动一个容器-将容器的80端口映射到主机的80端口-主机的目录-data映射到容器的-data。"><a href="#使用镜像nginx-latest以后台模式启动一个容器-将容器的80端口映射到主机的80端口-主机的目录-data映射到容器的-data。" class="headerlink" title="使用镜像nginx:latest以后台模式启动一个容器,将容器的80端口映射到主机的80端口,主机的目录/data映射到容器的/data。"></a>使用镜像nginx:latest以后台模式启动一个容器,将容器的80端口映射到主机的80端口,主机的目录/data映射到容器的/data。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -p 80:80 -v /data:/data -d nginx:latest  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="使用镜像nginx-latest以交互模式启动一个容器-在容器内执行-bin-bash命令。"><a href="#使用镜像nginx-latest以交互模式启动一个容器-在容器内执行-bin-bash命令。" class="headerlink" title="使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。"></a>使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">runoob@runoob:~$ docker run -it nginx:latest /bin/bash  </span><br><span class="line">root@b8573233d675:/#   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Usage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...]    </span><br><span class="line">  </span><br><span class="line">  -d, --detach=false         指定容器运行于前台还是后台，默认为false     </span><br><span class="line">  -i, --interactive=false   打开STDIN，用于控制台交互    </span><br><span class="line">  -t, --tty=false            分配tty设备，该可以支持终端登录，默认为false    </span><br><span class="line">  -u, --user=&quot;&quot;              指定容器的用户    </span><br><span class="line">  -a, --attach=[]            登录容器（必须是以docker run -d启动的容器）  </span><br><span class="line">  -w, --workdir=&quot;&quot;           指定容器的工作目录   </span><br><span class="line">  -c, --cpu-shares=0        设置容器CPU权重，在CPU共享场景使用    </span><br><span class="line">  -e, --env=[]               指定环境变量，容器中可以使用该环境变量    </span><br><span class="line">  -m, --memory=&quot;&quot;            指定容器的内存上限    </span><br><span class="line">  -P, --publish-all=false    指定容器暴露的端口    </span><br><span class="line">  -p, --publish=[]           指定容器暴露的端口   </span><br><span class="line">  -h, --hostname=&quot;&quot;          指定容器的主机名    </span><br><span class="line">  -v, --volume=[]            给容器挂载存储卷，挂载到容器的某个目录    </span><br><span class="line">  --volumes-from=[]          给容器挂载其他容器上的卷，挂载到容器的某个目录  </span><br><span class="line">  --cap-add=[]               添加权限，权限清单详见：http://linux.die.net/man/7/capabilities    </span><br><span class="line">  --cap-drop=[]              删除权限，权限清单详见：http://linux.die.net/man/7/capabilities    </span><br><span class="line">  --cidfile=&quot;&quot;               运行容器后，在指定文件中写入容器PID值，一种典型的监控系统用法    </span><br><span class="line">  --cpuset=&quot;&quot;                设置容器可以使用哪些CPU，此参数可以用来容器独占CPU    </span><br><span class="line">  --device=[]                添加主机设备给容器，相当于设备直通    </span><br><span class="line">  --dns=[]                   指定容器的dns服务器    </span><br><span class="line">  --dns-search=[]            指定容器的dns搜索域名，写入到容器的/etc/resolv.conf文件    </span><br><span class="line">  --entrypoint=&quot;&quot;            覆盖image的入口点    </span><br><span class="line">  --env-file=[]              指定环境变量文件，文件格式为每行一个环境变量    </span><br><span class="line">  --expose=[]                指定容器暴露的端口，即修改镜像的暴露端口    </span><br><span class="line">  --link=[]                  指定容器间的关联，使用其他容器的IP、env等信息    </span><br><span class="line">  --lxc-conf=[]              指定容器的配置文件，只有在指定--exec-driver=lxc时使用    </span><br><span class="line">  --name=&quot;&quot;                  指定容器名字，后续可以通过名字进行容器管理，links特性需要使用名字    </span><br><span class="line">  --net=&quot;bridge&quot;             容器网络设置:  </span><br><span class="line">                                bridge 使用docker daemon指定的网桥       </span><br><span class="line">                                host    //容器使用主机的网络    </span><br><span class="line">                                container:NAME_or_ID  &gt;//使用其他容器的网路，共享IP和PORT等网络资源    </span><br><span class="line">                                none 容器使用自己的网络（类似--net=bridge），但是不进行配置   </span><br><span class="line">  --privileged=false         指定容器是否为特权容器，特权容器拥有所有的capabilities    </span><br><span class="line">  --restart=&quot;no&quot;             指定容器停止后的重启策略:  </span><br><span class="line">                                no：容器退出时不重启    </span><br><span class="line">                                on-failure：容器故障退出（返回值非零）时重启   </span><br><span class="line">                                always：容器退出时总是重启    </span><br><span class="line">  --rm=false                 指定容器停止后自动删除容器(不支持以docker run -d启动的容器)    </span><br><span class="line">  --sig-proxy=true           设置由代理接受并处理信号，但是SIGCHLD、SIGSTOP和SIGKILL不能被代理    </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="修改名称和tag"><a href="#修改名称和tag" class="headerlink" title="修改名称和tag"></a>修改名称和tag</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker tag xx.xx.xx.xx:5000/amd64/ubuntu:22.04 arm64_ubuntu:22.04</span><br><span class="line">docker rmi xx.xx.xx.xx:5000/amd64/ubuntu:22.04</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="启动运行容器"><a href="#启动运行容器" class="headerlink" title="启动运行容器"></a>启动运行容器</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -tid --privileged=true --net=host  --add-host=rma:45.141.139.144 --name arm64_ubuntu22.04 --ipc=shareable -v /data:/data -v /sys:/sys -v /dev:/dev  --shm-size 128m arm64_ubuntu:22.04 /sbin/init</span><br><span class="line"></span><br><span class="line">docker run -tid --privileged=true --net=host  --add-host=rma:45.141.139.144 --name arm64_ubuntu22.04 --ipc=shareable -v /data:/data -v /sys:/sys -v /dev:/dev  --shm-size 128m arm64_ubuntu:22.04 bash</span><br><span class="line"></span><br><span class="line">docker run -tid --privileged=true --net=host --name arm64v8-ubuntu20.04 --ipc=shareable -v /data:/data -v /sys:/sys -v /dev:/dev  --shm-size 128m db202edd85e5 bash</span><br><span class="line"></span><br><span class="line">docker exec -it 275d093eb6f9 bash</span><br><span class="line">docker rm 275d093eb6f9</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>DOCKER</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>docker save&amp;&amp;load</title>
    <url>/2022/06/24/docker-save-load/</url>
    <content><![CDATA[<h2 id="docker将镜像导出到本地，上传至内网服务器上"><a href="#docker将镜像导出到本地，上传至内网服务器上" class="headerlink" title="docker将镜像导出到本地，上传至内网服务器上"></a>docker将镜像导出到本地，上传至内网服务器上</h2><p>背景：在企业中往往出现了内网不能和外网相通，不能使用docker pull命令来拉取镜像，这个时候我们就可以考虑在有所需镜像的服务器上导出镜像，再将其上传到内网服务器上。</p>
<span id="more"></span>

<p>有两种方法，一种是通过容器，一种是通过镜像，其实本质是一样的，容器的实质就是镜像</p>
<p>首先，需要提交现有容器<br>查看容器名，关闭容器，commit容器为新的镜像</p>
<p>docker commit 容器id或者容器名称 IMAGE的名称</p>
<p>root@compute:/home/rma# docker ps<br>CONTAINER ID   IMAGE        COMMAND        CREATED       STATUS       PORTS     NAMES<br>6684513da8ac   compute:v1   “/sbin/init”   2 years ago   Up 2 years             jmnd_compute<br>root@compute:/home/rma# docker stop jmnd_compute<br>jmnd_compute</p>
<p>root@compute:/home/rma# docker commit jmnd_compute compute:v2</p>
<h2 id="方法一：通过容器"><a href="#方法一：通过容器" class="headerlink" title="方法一：通过容器"></a>方法一：通过容器</h2><blockquote>
<p>docker save用于导出镜像到文件，包含镜像元数据和历史信息；<br>docker export用于将当前容器状态导出至文件，类似快照，所以不包含元数据及历史信息，体积更小，此外从容器快照导入时也可以重新指定标签和元数据信息；</p>
</blockquote>
<p>1 首先使用docker ps -a 查看本机上的所有容器</p>
<blockquote>
<p>docker ps -a</p>
</blockquote>
<p>2 导出镜像<br>使用docker export命令根据容器id将镜像导成一个文件</p>
<blockquote>
<p>docker export 容器id &gt; image.tar</p>
</blockquote>
<p>3 导入镜像<br>使用docker import命令将这个镜像导进来</p>
<blockquote>
<p>docker import 容器名 &lt; image.tar</p>
</blockquote>
<p>4 通过docker images 命令查看镜像是否导入</p>
<blockquote>
<p>docker images</p>
</blockquote>
<h2 id="方法二：通过镜像"><a href="#方法二：通过镜像" class="headerlink" title="方法二：通过镜像"></a>方法二：通过镜像</h2><p>1 通过docker image查看本机上的所有镜像</p>
<blockquote>
<p>docker images</p>
</blockquote>
<p>2 导出镜像<br>找到要上传的镜像的id,使用docker save命令将镜像保存为一个文件</p>
<blockquote>
<p>docker save 镜像id &gt; image.tar</p>
</blockquote>
<p>上面命令执行之后，我们便可以通过ls命令在当前目录下发现image.tar<br>3 导入镜像<br>docker save 可以将多个image打包成一个文件</p>
<blockquote>
<p>docker save -o image.tar 镜像1 镜像2</p>
</blockquote>
<p>4 通过docker load载入镜像</p>
<blockquote>
<p>docker load &lt; image.tar</p>
</blockquote>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><h3 id="文件大小不同"><a href="#文件大小不同" class="headerlink" title="文件大小不同"></a>文件大小不同</h3><blockquote>
<p>export 导出的镜像文件体积小于 save 保存的镜像</p>
</blockquote>
<h3 id="是否可以对镜像重命名"><a href="#是否可以对镜像重命名" class="headerlink" title="是否可以对镜像重命名"></a>是否可以对镜像重命名</h3><blockquote>
<p>docker import 可以为镜像指定新名称<br>docker load 不能对载入的镜像重命名</p>
</blockquote>
<h3 id="是否可以同时将多个镜像打包到一个文件中"><a href="#是否可以同时将多个镜像打包到一个文件中" class="headerlink" title="是否可以同时将多个镜像打包到一个文件中"></a>是否可以同时将多个镜像打包到一个文件中</h3><blockquote>
<p>docker export 不支持<br>docker save 支持</p>
</blockquote>
<h3 id="是否包含镜像历史"><a href="#是否包含镜像历史" class="headerlink" title="是否包含镜像历史"></a>是否包含镜像历史</h3><blockquote>
<p>export 导出（import 导入）是根据容器拿到的镜像，再导入时会丢失镜像所有的历史记录和元数据信息（即仅保存容器当时的快照状态），所以无法进行回滚操作。</p>
<p>而 save 保存（load 加载）的镜像，没有丢失镜像的历史，可以回滚到之前的层（layer）</p>
</blockquote>
<h3 id="应用场景不同"><a href="#应用场景不同" class="headerlink" title="应用场景不同"></a>应用场景不同</h3><blockquote>
<p>docker export 的应用场景：主要用来制作基础镜像，比如我们从一个 ubuntu 镜像启动一个容器，然后安装一些软件和进行一些设置后，使用 docker export 保存为一个基础镜像。然后，把这个镜像分发给其他人使用，比如作为基础的开发环境。</p>
<p>docker save 的应用场景：如果我们的应用是使用 docker-compose.yml 编排的多个镜像组合，但我们要部署的客户服务器并不能连外网。这时就可以使用 docker save 将用到的镜像打个包，然后拷贝到客户服务器上使用 docker load 载入。</p>
</blockquote>
]]></content>
      <categories>
        <category>DOCKER</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Kdump</title>
    <url>/2022/06/23/Linux-Kdump/</url>
    <content><![CDATA[<p>在ubuntu/debian系统下可以直接通过apt命令进行安装：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt install linux-crashdump               </span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>详细的安装过程如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ sudo apt install linux-crashdump </span><br><span class="line">正在读取软件包列表... </span><br><span class="line">完成 正在分析软件包的依赖关系树        </span><br><span class="line">正在读取状态信息... 完成        </span><br><span class="line">下列软件包是自动安装的并且现在不需要了：  </span><br><span class="line"> linux-hwe-5.4-headers-5.4.0-47 linux-hwe-5.4-headers-5.4.0-52 </span><br><span class="line">使用&#x27;sudo apt autoremove&#x27;来卸载它(它们)。 </span><br><span class="line">将会同时安装下列软件：  </span><br><span class="line"> crash kdump-tools kexec-tools makedumpfile </span><br><span class="line">下列【新】软件包将被安装：   </span><br><span class="line">crash kdump-tools kexec-tools linux-crashdump makedumpfile </span><br><span class="line">升级了 0 个软件包，新安装了 5 个软件包，要卸载 0 个软件包，有 68 个软件包未被升级。 </span><br><span class="line">需要下载 3,050 kB 的归档。 </span><br><span class="line">解压缩后会消耗 9,700 kB 的额外空间。 </span><br><span class="line">您希望继续执行吗？ [Y/n]     =======&gt; Y</span><br></pre></td></tr></table></figure>

<p>弹出的字符界面框都选择是</p>
<p>如果不小心点到否，可以使用以下命令对配置进行重置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ dpkg-reconfigure kexec-tools </span><br><span class="line">$ dpkg-reconfigure kdump-tools               </span><br></pre></td></tr></table></figure>

<p>或者手动编译下面的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改/etc/default/kexec文件：</span><br><span class="line"># Load a kexec kernel (true/false) </span><br><span class="line">LOAD_KEXEC=true               </span><br><span class="line">修改/etc/default/kdump-tools文件：</span><br><span class="line">USE_KDUMP=1               </span><br></pre></td></tr></table></figure>

<p>安装完重启后，通过kdump-config show可以看到以下信息，说明配置有问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ kdump-config show</span><br><span class="line">DUMP_MODE:        kdump</span><br><span class="line">USE_KDUMP:        1</span><br><span class="line">KDUMP_SYSCTL:     kernel.panic_on_oops=1</span><br><span class="line">KDUMP_COREDIR:    /var/crash</span><br><span class="line">crashkernel addr: 0x</span><br><span class="line">   /var/lib/kdump/vmlinuz: broken symbolic link to /boot/vmlinu?-5.4.18debug</span><br><span class="line">kdump initrd: </span><br><span class="line">   /var/lib/kdump/initrd.img: broken symbolic link to /var/lib/kdump/initrd.img-5.4.18debug</span><br><span class="line">current state:    Not ready to kdump</span><br><span class="line"></span><br><span class="line">kexec command:</span><br><span class="line">  /sbin/kexec -p --command-line=&quot;BOOT_IMAGE=/vmlinuz-5.4.18-19-generic root=UUID=6af7820e-7eb9-4d42-a5d6-afb3c7783308 ro quiet splash loglevel=0 resume=UUID=e358413a-5177-4f46-a1fa-dbabc1819a59 audit=0 security=none reset_devices systemd.unit=kdump-tools-dump.service nr_cpus=1 irqpoll nousb ata_piix.prefer_ms_hyperv=0&quot; --initrd=/var/lib/kdump/initrd.img /var/lib/kdump/vmlinuz           </span><br></pre></td></tr></table></figure>

<p>上面出现问题的原因是/boot下的vmlinuz和initrd.img文件名和内核编译时配置的文件名不一致，将vmlinuz-5.4.18-debug和initrd.img-5.4.18-debug分别改为vmlinuz-5.4.18debug、initrd.img-5.4.18debug后，重新通过sudo systemctl restart kdump-tools或者sudo /etc/init.d/kdump-tools restart就可以了。</p>
<p>也可以通过dmesg命令查看到相关的crash字样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~$ dmesg | grep crash</span><br><span class="line">[    0.000000] Command line: BOOT_IMAGE=/vmlinuz-5.4.18debug root=UUID=6af7820e-7eb9-4d42-a5d6-afb3c7783308 ro quiet splash crashkernel=512M-:192M loglevel=0 resume=UUID=e358413a-5177-4f46-a1fa-dbabc1819a59 audit=0 security=none</span><br><span class="line">[    0.009110] Reserving 192MB of memory at 1872MB for crashkernel (System RAM: 8074MB)</span><br><span class="line">[    0.028159] Kernel command line: BOOT_IMAGE=/vmlinuz-5.4.18debug root=UUID=6af7820e-7eb9-4d42-a5d6-afb3c7783308 ro quiet splash crashkernel=512M-:192M loglevel=0 resume=UUID=e358413a-5177-4f46-a1fa-dbabc1819a59 audit=0 security=none            </span><br></pre></td></tr></table></figure>

<p>如果显示信息如下，则说明安装成功了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~$ kdump-config show</span><br><span class="line">DUMP_MODE:        kdump</span><br><span class="line">USE_KDUMP:        1</span><br><span class="line">KDUMP_SYSCTL:     kernel.panic_on_oops=1</span><br><span class="line">KDUMP_COREDIR:    /var/crash</span><br><span class="line">crashkernel addr: 0x</span><br><span class="line">   /var/lib/kdump/vmlinuz: symbolic link to /boot/vmlinuz-5.4.18debug</span><br><span class="line">kdump initrd: </span><br><span class="line">   /var/lib/kdump/initrd.img: symbolic link to /var/lib/kdump/initrd.img-5.4.18debug</span><br><span class="line">current state:    ready to kdump</span><br><span class="line"></span><br><span class="line">kexec command:</span><br><span class="line">  /sbin/kexec -p --command-line=&quot;BOOT_IMAGE=/vmlinuz-5.4.18debug root=UUID=6af7820e-7eb9-4d42-a5d6-afb3c7783308 ro quiet splash loglevel=0 resume=UUID=e358413a-5177-4f46-a1fa-dbabc1819a59 audit=0 security=none reset_devices systemd.unit=kdump-tools-dump.service nr_cpus=1 irqpoll nousb ata_piix.prefer_ms_hyperv=0&quot; --initrd=/var/lib/kdump/initrd.img /var/lib/kdump/vmlinuz              </span><br></pre></td></tr></table></figure>

<p>在grub.cfg中搜索crash可以看到以下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">~$ cat /boot/grub/grub.cfg | grep crash</span><br><span class="line">        linux	/vmlinuz-5.4.18-19-generic root=UUID=6af7820e-7eb9-4d42-a5d6-afb3c7783308 ro  quiet splash crashkernel=512M-:192M loglevel=0 resume=UUID=e358413a-5177-4f46-a1fa-dbabc1819a59 audit=0 security=none</span><br><span class="line">	linux   /vmlinuz-5.4.18-19-generic root=UUID=6af7820e-7eb9-4d42-a5d6-afb3c7783308 rw  quiet splash crashkernel=512M-:192M loglevel=0 resume=UUID=e358413a-5177-4f46-a1fa-dbabc1819a59 audit=0 security=none selinux=0 backup</span><br><span class="line">	linux   /vmlinuz-5.4.18-19-generic root=UUID=6af7820e-7eb9-4d42-a5d6-afb3c7783308 rw  quiet splash crashkernel=512M-:192M loglevel=0 resume=UUID=e358413a-5177-4f46-a1fa-dbabc1819a59 audit=0 security=none selinux=0 restore</span><br><span class="line">        linux	/vmlinuz-5.4.18-19-generic root=UUID=6af7820e-7eb9-4d42-a5d6-afb3c7783308 ro  quiet splash crashkernel=512M-:192M loglevel=0 resume=UUID=e358413a-5177-4f46-a1fa-dbabc1819a59 audit=0 security=none</span><br><span class="line">	linux	/vmlinuz-5.4.18-debug root=UUID=6af7820e-7eb9-4d42-a5d6-afb3c7783308 ro  quiet splash crashkernel=512M-:192M loglevel=0 resume=UUID=e358413a-5177-4f46-a1fa-dbabc1819a59 audit=0 security=none             </span><br></pre></td></tr></table></figure>

<p>内核debuginfo或者dbgsym可以参考网上教程安装。</p>
<p>可以通过如下格式启动crash命令进行相关调试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">crash &lt;debug kernel&gt; &lt;crash dump&gt;                </span><br></pre></td></tr></table></figure>

<p>debug-kernel的路径如果装了debuginfo，可能是在/usr/lib/debug/lib/modules/$(uname -r)/vmlinux或者/usr/lib/debug/boot/vmlinux目录下，注意/boot下的vmlinuz文件是压缩过的bzImage格式文件，然后调试使用的vmlinuz文件是没有经过压缩的文件。如果是自己编译的内核源码，则vmlinuz在编译完后会出现在linux内核源码编译路径根目录下。</p>
<p>kdump-tools服务正常启动后，可以通过以下操作触发panic，测试kdump：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jsy@jsy-PC:~$ sysctl -n kernel.sysrq</span><br><span class="line">176</span><br><span class="line">#等价于以下命令</span><br><span class="line">jsy@jsy-PC:~$ cat /proc/sys/kernel/sysrq</span><br><span class="line">176</span><br><span class="line">$ sudo sysctl -w kernel.sysrq=1</span><br><span class="line">$ sudo sh -c &quot;echo c &gt; /proc/sysrq-trigger&quot;</span><br><span class="line">#或者在root用户下</span><br><span class="line"># echo 1 &gt; /proc/sys/kernel/sysrq        # --&gt; 只要内核没有挂掉，响应任何操作 </span><br><span class="line"># echo c &gt; /proc/sysrq-trigger 		 # --&gt; 认为造成os crash          </span><br></pre></td></tr></table></figure>

<p>然后重启后，通过crash命令可以看到如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@jsy-PC:/home/jsy# ls /usr/src/linux-headers-5.4.18-debug/vmlinux</span><br><span class="line">/usr/src/linux-headers-5.4.18-debug/vmlinux</span><br><span class="line">root@jsy-PC:/home/jsy# ls /var/crash/</span><br><span class="line">202104261059/ kdump_lock    kexec_cmd     </span><br><span class="line">root@jsy-PC:/home/jsy# ls /var/crash/202104261059/</span><br><span class="line">dmesg.202104261059  dump.202104261059</span><br><span class="line">root@jsy-PC:/home/jsy# crash /usr/src/linux-headers-5.4.18-debug/vmlinux /var/crash/202104261059/dump.202104261059 </span><br><span class="line"></span><br><span class="line">crash 7.2.8</span><br><span class="line">Copyright (C) 2002-2020  Red Hat, Inc.</span><br><span class="line">Copyright (C) 2004, 2005, 2006, 2010  IBM Corporation</span><br><span class="line">Copyright (C) 1999-2006  Hewlett-Packard Co</span><br><span class="line">Copyright (C) 2005, 2006, 2011, 2012  Fujitsu Limited</span><br><span class="line">Copyright (C) 2006, 2007  VA Linux Systems Japan K.K.</span><br><span class="line">Copyright (C) 2005, 2011  NEC Corporation</span><br><span class="line">Copyright (C) 1999, 2002, 2007  Silicon Graphics, Inc.</span><br><span class="line">Copyright (C) 1999, 2000, 2001, 2002  Mission Critical Linux, Inc.</span><br><span class="line">This program is free software, covered by the GNU General Public License,</span><br><span class="line">and you are welcome to change it and/or distribute copies of it under</span><br><span class="line">certain conditions.  Enter &quot;help copying&quot; to see the conditions.</span><br><span class="line">This program has absolutely no warranty.  Enter &quot;help warranty&quot; for details.</span><br><span class="line"> </span><br><span class="line">GNU gdb (GDB) 7.6</span><br><span class="line">Copyright (C) 2013 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br><span class="line">and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;x86_64-unknown-linux-gnu&quot;...</span><br><span class="line"></span><br><span class="line">WARNING: kernel relocated [830MB]: patching 113662 gdb minimal_symbol values</span><br><span class="line"></span><br><span class="line">      KERNEL: /usr/src/linux-headers-5.4.18-debug/vmlinux              </span><br><span class="line">    DUMPFILE: /var/crash/202104261059/dump.202104261059  [PARTIAL DUMP]</span><br><span class="line">        CPUS: 12</span><br><span class="line">        DATE: Mon Apr 26 10:59:19 2021</span><br><span class="line">      UPTIME: 00:19:31</span><br><span class="line">LOAD AVERAGE: 0.70, 2.00, 3.72</span><br><span class="line">       TASKS: 1070</span><br><span class="line">    NODENAME: jsy-PC</span><br><span class="line">     RELEASE: 5.4.18debug</span><br><span class="line">     VERSION: #1 SMP Mon Apr 19 09:50:53 CST 2021</span><br><span class="line">     MACHINE: x86_64  (3200 Mhz)</span><br><span class="line">      MEMORY: 7.9 GB</span><br><span class="line">       PANIC: &quot;Kernel panic - not syncing: sysrq triggered crash&quot;</span><br><span class="line">         PID: 3162</span><br><span class="line">     COMMAND: &quot;bash&quot;</span><br><span class="line">        TASK: ffff95428bf58000  [THREAD_INFO: ffff95428bf58000]</span><br><span class="line">         CPU: 8</span><br><span class="line">       STATE: TASK_RUNNING (PANIC)</span><br><span class="line"></span><br><span class="line">KERNEL:系统崩溃时运行的 kernel 文件</span><br><span class="line">DUMPFILE:内核转储文件</span><br><span class="line">CPUS: 所在机器的 CPU 数量</span><br><span class="line">DATE: 系统崩溃的时间</span><br><span class="line">TASKS:系统崩溃时内存中的任务数</span><br><span class="line">NODENAME:崩溃的系统主机名</span><br><span class="line">RELEASE:和 VERSION: 内核版本号</span><br><span class="line">MACHINE:CPU 架构</span><br><span class="line">MEMORY:崩溃主机的物理内存  </span><br><span class="line">bt 查看异常时的堆栈</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>Kdump</tag>
      </tags>
  </entry>
  <entry>
    <title>Virtio协议概述</title>
    <url>/2022/06/22/Virtio%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h2 id="Virtio"><a href="#Virtio" class="headerlink" title="Virtio "></a>Virtio </h2><p>半虚拟化设备(Virtio Device)在当前云计算虚拟化场景下已经得到了非常广泛的应用， 并且现在也有越来越多的物理设备也开始支持Virtio协议，即所谓的<code>Virtio Offload</code>， </p>
<span id="more"></span>
<p>通过将virtio协议卸载到硬件上（例如virtio-net网卡卸载，virtio-scsi卸载）让物理机和虚拟机都能够获得加速体验。 本文中我们来重点了解一下virtio技术中的一些关键点，方便我们加深对半虚拟化的理解。 本文适合对IO虚拟化有一定了解的人群阅读，本文的目的是对想要了解virtio内部机制的读者提供帮助。</p>
<p>在开始了解virtio之前，我们先思考一下几个相关问题：</p>
<ul>
<li>  virtio设备有哪几种呈现方式?</li>
<li>  virtio-pci设备的配置空间都有哪些内容？</li>
<li>  virtio前端和后端基于共享内存机制进行通信，它是凭什么可以做到无锁的？</li>
<li>  virtio机制中有那几个关键的数据结构？virtio配置接口存放在哪里？virtio是如何工作的？</li>
<li>  virtio前后端是如何进行通信的？irqfd和ioeventfd是什么回事儿？在virtio前后端通信中是怎么用到的？</li>
<li>  virtio设备支持MSIx，在qemu/kvm中具体是怎么实现对MSIx的模拟呢？</li>
<li>  virtio modern相对于virtio legay多了哪些新特性？</li>
</ul>
<h2 id="0-简单了解一下Virtio-Spec协议"><a href="#0-简单了解一下Virtio-Spec协议" class="headerlink" title="0. 简单了解一下Virtio Spec协议 "></a>0. 简单了解一下Virtio Spec协议 </h2><p>virtio协议标准最早由IBM提出，virtio作为一套标准协议现在有专门的技术委员会进行管理， 具体的标准可以访问<a href="http://docs.oasis-open.org/virtio/virtio/v1.0/virtio-v1.0.html"><code>virtio</code>官网</a>， 开发者可以向技术委员会提供新的virtio设备提案（<code>RFC</code>），经过委员会通过后可以增加新的virtio设备类型。</p>
<p>组成一个virtio设备的四要素包括： **设备状态域，<code>feature bits</code>，设备配置空间，一个或者多个<code>virtqueue</code>**。 其中设备状态域包含6种状态：</p>
<ul>
<li>  ACKNOWLEDGE（1）：GuestOS发现了这个设备，并且认为这是一个有效的virtio设备；</li>
<li>  DRIVER (2) : GuestOS知道该如何驱动这个设备；</li>
<li>  FAILED (128) : GuestOS无法正常驱动这个设备，Something is wriong；</li>
<li>  FEATURES_OK (8) : GuestOS认识所有的feature，并且feature协商一完成；</li>
<li>  DRIVER_OK (4) : 驱动加载完成，设备可以投入使用了；</li>
<li>  DEVICE_NEEDS_RESET (64) ：设备触发了错误，需要重置才能继续工作。</li>
</ul>
<p><code>feature bits</code>用来标志设备支持那个特性，其中bit0-bit23是特定设备可以使用的<code>feature bits</code>， bit24-bit37预给队列和feature协商机制，bit38以上保留给未来其他用途。 例如：对于virtio-net设备而言，feature bit0表示网卡设备支持checksum校验。 <code>VIRTIO_F_VERSION_1</code>这个feature bit用来表示设备是否支持virtio 1.0 spec标准。</p>
<p>在virtio协议中，所有的设备都使用virtqueue来进行数据的传输。 <strong>每个设备可以有0个或者多个virtqueue，每个virtqueue占用2个或者更多个4K的物理页</strong>。 virtqueue有<code>Split Virtqueues</code>和<code>Packed Virtqueues</code>两种模式， 在<code>Split virtqueues</code>模式下virtqueue被分成若干个部分， 每个部分都是前端驱动或者后端单向可写的（不能两端同时写）。 每个virtqueue都有一个16bit的queue size参数，表示队列的总长度。 每个virtqueue由3个部分组成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-------------------+--------------------------------+-----------------------+</span><br><span class="line">| Descriptor Table  |   Available Ring  (padding)    |       Used Ring       |</span><br><span class="line">+-------------------+--------------------------------+-----------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  Descriptor Table：存放IO传输请求信息；</li>
<li>  Available Ring：记录了Descriptor Table表中的哪些项被更新了，前端Driver可写但后端只读；</li>
<li>  Used Ring：记录Descriptor Table表中哪些请求已经被提交到硬件，前端Driver只读但后端可写。</li>
</ul>
<p>整个virtio协议中设备IO请求的工作机制可以简单地概括为：</p>
<ol>
<li> 前端驱动将IO请求放到<code>Descriptor Table</code>中，然后将索引更新到<code>Available Ring</code>中，然后kick后端去取数据；</li>
<li> 后端取出IO请求进行处理，然后结果刷新到<code>Descriptor Table</code>中再更新<code>Used Ring</code>，然后发送中断notify前端。</li>
</ol>
<p>从virtio协议可以了解到<strong>virtio设备支持3种设备呈现模式</strong>：</p>
<ul>
<li>  Virtio Over PCI BUS，依旧遵循PCI规范，挂在到PCI总线上，作为virtio-pci设备呈现；</li>
<li>  Virtio Over MMIO，部分不支持PCI协议的虚拟化平台可以使用这种工作模式，直接挂载到系统总线上；</li>
<li>  Virtio Over Channel I/O：主要用在s390平台上，virtio-ccw使用这种基于channel I/O的机制。</li>
</ul>
<p>其中，Virtio Over PCI BUS的使用比较广泛，作为PCI设备需按照规范要通过PCI配置空间来向操作系统报告设备支持的特性集合， 这样操作系统才知道这是一个什么类型的virtio设备，并调用对应的前端驱动和这个设备进行握手，进而将设备驱动起来。 QEMU会给virtio设备模拟PCI配置空间，对于virtio设备来说PCI Vendor ID固定为0x1AF4， PCI Device ID 为 0x1000到0x107F之间的是virtio设备。 同时，在不支持PCI协议的虚拟化平台上，virtio设备也可以直接通过MMIO进行呈现， virtio-spec 4.2 <a href="https://docs.oasis-open.org/virtio/virtio/v1.1/csprd01/virtio-v1.1-csprd01.html#x1-1440002">Virtio Over MMIO</a>有针对virtio-mmio设备呈现方式的详细描述，mmio相关信息可以直接通过内核参数报告给Linux操作系统。 本文主要基于virtio-pci展开讨论。</p>
<p>前面提到virtio设备有<code>feature bits</code>，<code>virtqueue</code>等四要素，那么在virtio-pci模式下是如何呈现的呢？ 从virtio spec来看，老的virtio协议和新的virtio协议在这一块有很大改动。 virtio legacy（virtio 0.95）协议规定，对应的配置数据结构（virtio common configuration structure） 应该存放在设备的BAR0里面，我们称之为<code>virtio legay interface</code>，其结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                      virtio legacy ==&gt; Mapped into PCI BAR0 </span><br><span class="line">+------------------------------------------------------------------+ </span><br><span class="line">|                    Host Feature Bits[0:31]                       | </span><br><span class="line">+------------------------------------------------------------------+</span><br><span class="line">|                    Guest Feature Bits[0:31]                      |</span><br><span class="line">+------------------------------------------------------------------+</span><br><span class="line">|                    Virtqueue Address PFN                         |</span><br><span class="line">+---------------------------------+--------------------------------+</span><br><span class="line">|           Queue Select          |           Queue Size           |</span><br><span class="line">+----------------+----------------+--------------------------------+</span><br><span class="line">|   ISR Status   | Device Stat    |           Queue Notify         |</span><br><span class="line">+----------------+----------------+--------------------------------+</span><br><span class="line">|       MSI Config Vector         |         MSI Queue Vector       |</span><br><span class="line">+---------------------------------+--------------------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于新的<code>virtio modern</code>，协议将配置结构划分为5种类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Common configuration */ </span><br><span class="line">#define VIRTIO_PCI_CAP_COMMON_CFG        1 </span><br><span class="line">/* Notifications */ </span><br><span class="line">#define VIRTIO_PCI_CAP_NOTIFY_CFG        2</span><br><span class="line">/* ISR Status */ </span><br><span class="line">#define VIRTIO_PCI_CAP_ISR_CFG           3 </span><br><span class="line">/* Device specific configuration */ </span><br><span class="line">#define VIRTIO_PCI_CAP_DEVICE_CFG        4 </span><br><span class="line">/* PCI configuration access */ </span><br><span class="line">#define VIRTIO_PCI_CAP_PCI_CFG           5 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上的每种配置结构是直接映射到virtio设备的BAR空间内，那么如何指定每种配置结构的位置呢？ 答案是通过<code>PCI Capability list</code>方式去指定，这和物理PCI设备是一样的，体现了virtio-pci的协议兼容性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct virtio_pci_cap &#123; </span><br><span class="line">        u8 cap_vndr;    /* Generic PCI field: PCI_CAP_ID_VNDR */ </span><br><span class="line">        u8 cap_next;    /* Generic PCI field: next ptr. */ </span><br><span class="line">        u8 cap_len;     /* Generic PCI field: capability length */ </span><br><span class="line">        u8 cfg_type;    /* Identifies the structure. */ </span><br><span class="line">        u8 bar;         /* Where to find it. */ </span><br><span class="line">        u8 padding[3];  /* Pad to full dword. */ </span><br><span class="line">        le32 offset;    /* Offset within bar. */ </span><br><span class="line">        le32 length;    /* Length of the structure, in bytes. */ </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>只是略微不同的是，virtio-pci的Capability有一个统一的结构， 其中<code>cfg_type</code>表示Cap的类型，bar表示这个配置结构被映射到的BAR空间号。 这样每个配置结构都可以通过BAR空间直接访问，或者通过PCI配置空间的<code>VIRTIO_PCI_CAP_PCI_CFG</code>域进行访问。 每个Cap的具体结构定义可以参考virtio spec 4.1.4.3小节。</p>
<h1 id="1-前后端数据共享"><a href="#1-前后端数据共享" class="headerlink" title="1. 前后端数据共享"></a>1. 前后端数据共享</h1><p>传统的纯模拟设备在工作的时候，会触发频繁的陷入陷出， 而且IO请求的内容要进行多次拷贝传递，严重影响了设备的IO性能。 virtio为了提升设备的IO性能，采用了共享内存机制， _<strong>前端驱动会提前申请好一段物理地址空间用来存放IO请求，然后将这段地址的GPA告诉QEMU</strong>_。 前端驱动在下发IO请求后，QEMU可以直接从共享内存中取出请求，然后将完成后的结果又直接写到虚拟机对应地址上去。 <strong>整个过程中可以做到直投直取，省去了不必要的数据拷贝开销</strong>。</p>
<p><strong><code>Virtqueue</code>是整个virtio方案的灵魂所在</strong>。每个virtqueue都包含3张表， <code>Descriptor Table</code>存放了IO请求描述符，<code>Available Ring</code>记录了当前哪些描述符是可用的， <code>Used Ring</code>记录了哪些描述符已经被后端使用了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">       +------------------------------------+</span><br><span class="line">       |       virtio  guest driver         |</span><br><span class="line">       +-----------------+------------------+</span><br><span class="line">         /               |              ^</span><br><span class="line">        /                |               \</span><br><span class="line">       put            update             get</span><br><span class="line">      /                  |                 \</span><br><span class="line">     V                   V                  \</span><br><span class="line">+----------+      +------------+        +----------+</span><br><span class="line">|          |      |            |        |          |</span><br><span class="line">+----------+      +------------+        +----------+</span><br><span class="line">| available|      | descriptor |        |   used   |</span><br><span class="line">|   ring   |      |   table    |        |   ring   |</span><br><span class="line">+----------+      +------------+        +----------+</span><br><span class="line">|          |      |            |        |          |</span><br><span class="line">+----------+      +------------+        +----------+</span><br><span class="line">|          |      |            |        |          |</span><br><span class="line">+----------+      +------------+        +----------+</span><br><span class="line">     \                   ^                   ^</span><br><span class="line">      \                  |                  /</span><br><span class="line">      get             update              put</span><br><span class="line">        \                |                /</span><br><span class="line">         V               |               /</span><br><span class="line">        +----------------+-------------------+</span><br><span class="line">        |	   virtio host backend          |</span><br><span class="line">        +------------------------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>Desriptor Table</code>中存放的是一个一个的<code>virtq_desc</code>元素，每个<code>virq_desc</code>元素占用16个字节。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-----------------------------------------------------------+</span><br><span class="line">|                        addr/gpa [0:63]                    |</span><br><span class="line">+-------------------------+-----------------+---------------+</span><br><span class="line">|         len [0:31]      |  flags [0:15]   |  next [0:15]  |</span><br><span class="line">+-------------------------+-----------------+---------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，addr占用64bit存放了单个IO请求的GPA地址信息，例如addr可能表示某个DMA buffer的起始地址。 len占用32bit表示IO请求的长度，flags的取值有3种， <code>VIRTQ_DESC_F_NEXT</code>表示这个IO请求和下一个<code>virtq_desc</code>描述的是连续的， <code>IRTQ_DESC_F_WRITE</code>表示这段buffer是write only的， <code>VIRTQ_DESC_F_INDIRECT</code>表示这段buffer里面放的内容是另外一组buffer的<code>virtq_desc</code>（相当于重定向）， next是指向下一个<code>virtq_desc</code>的索引号（前提是<code>VIRTQ_DESC_F_NEXT</code> &amp; flags）。</p>
<p><code>Available Ring</code>是前端驱动用来告知后端那些IO buffer是的请求需要处理，每个Ring中包含一个<code>virtq_avail</code>占用8个字节。 其中，flags取值为<code>VIRTQ_AVAIL_F_NO_INTERRUPT</code>时表示前端驱动告诉后端： “当你消耗完一个IO buffer的时候，不要立刻给我发中断”（防止中断过多影响效率）。 idx表示下次前端驱动要放置<code>Descriptor Entry</code>的地方。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+--------------+-------------+--------------+---------------------+</span><br><span class="line">| flags [0:15] |  idx [0:15] |  ring[0:15]  |  used_event [0:15]  |</span><br><span class="line">+--------------+-------------+--------------+---------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Used Ring结构稍微不一样，flags的值如果为<code>VIRTIO_F_EVENT_IDX</code>并且前后端协商<code>VIRTIO_F_EVENT_IDX</code> feature成功, 那么Guest会将used ring index放在available ring的末尾，告诉后端说： “Hi 小老弟，当你处理完这个请求的时候，给我发个中断通知我一下”， 同时host也会将avail_event index放到used ring的末尾，告诉guest说： “Hi 老兄，记得把这个idx的请求kick给我哈”。 <code>VIRTIO_F_EVENT_IDX</code>对virtio通知/中断有一定的优化，在某些场景下能够提升IO性能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* The Guest publishes the used index for which it expects an interrupt</span><br><span class="line"> * at the end of the avail ring. Host should ignore the avail-&gt;flags field. */</span><br><span class="line">/* The Host publishes the avail index for which it expects a kick</span><br><span class="line"> * at the end of the used ring. Guest should ignore the used-&gt;flags field. */</span><br><span class="line"> </span><br><span class="line">struct virtq_used &#123; </span><br><span class="line">#define VIRTQ_USED_F_NO_NOTIFY  1 </span><br><span class="line">        le16 flags; </span><br><span class="line">        le16 idx; </span><br><span class="line">        struct virtq_used_elem ring[ /* Queue Size */]; </span><br><span class="line">        le16 avail_event; /* Only if VIRTIO_F_EVENT_IDX */ </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">/* le32 is used here for ids for padding reasons. */ </span><br><span class="line">struct virtq_used_elem &#123; </span><br><span class="line">        /* Index of start of used descriptor chain. */ </span><br><span class="line">        le32 id; </span><br><span class="line">        /* Total length of the descriptor chain which was used (written to) */ </span><br><span class="line">        le32 len; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>原理就到这里，后面会以virtio网卡为例进行详细流程说明。</p>
<h2 id="2-前后端通信机制（irqfd-与-ioeventfd）"><a href="#2-前后端通信机制（irqfd-与-ioeventfd）" class="headerlink" title="2. 前后端通信机制（irqfd 与 ioeventfd）"></a>2. 前后端通信机制（irqfd 与 ioeventfd）</h2><p>共享内存方式解决了传统设备IO过程中内存拷贝带来的性能损耗问题，除此之外前端驱动和后端驱动的通信问题也是有可以改进的地方。 Virtio前后端通信概括起来只有两个方向，即GuestOS通知QEMU和QEMU通知GuestOS。 当前端驱动准备好IO buffer之后，需要通知后端（QEMU），告诉后端： “小老弟，我有一波IO请求已经准备好了，你帮我处理一下”。 前端通知出去后，就可以等待IO结果了（操作系统可以进行一次调度），这时候vCPU可以去干点其他的事情。 后端收到消息后开始处理IO请求，当IO请求处理完成之后，后端就通过中断机制通知GuestOS： “老哥，你的IO给你处理好了，你来取一下”。 前后端通信机制如下图所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+-------------+                +-------------+</span><br><span class="line">|             |                |             |</span><br><span class="line">|             |                |             |</span><br><span class="line">|   GuestOS   |                |     QEMU    |</span><br><span class="line">|             |                |             |</span><br><span class="line">|             |                |             |</span><br><span class="line">+---+---------+                +----+--------+</span><br><span class="line">    |     ^                         |    ^</span><br><span class="line">    |     |                         |    |</span><br><span class="line">+---|-----|-------------------------|----|---+</span><br><span class="line">|   |     |                irqfd    |    |   |</span><br><span class="line">|   |     +-------------------------+    |   |</span><br><span class="line">|   |  ioeventfd                         |   |</span><br><span class="line">|   +------------------------------------+   |</span><br><span class="line">|                   KVM                      |</span><br><span class="line">+--------------------------------------------+</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>前端驱动通知后端比较简单，QEMU设置一段特定的MMIO地址空间，前端驱动访问这段MMIO触发VMExit， 退出到KVM后利用<code>ioeventfd</code>机制通知到用户态的QEMU，QEMU主循环（main_loop poll） 检测到ioeventfd事件后调用callback进行处理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">前端驱动通知后端：</span><br><span class="line">内核流程mark一下，PCI设备驱动流程这个后面可以学习一下，先扫描PCI bus发现是virtio设备再扫描virtio-bus。</span><br><span class="line">worker_thread --&gt; process_one_work --&gt; pciehp_power_thread --&gt; pciehp_enable_slot --&gt; </span><br><span class="line">pciehp_configure_device --&gt; pci_bus_add_devices --&gt; pci_bus_add_device --&gt; device_attach --&gt; </span><br><span class="line">__device_attach --&gt; bus_for_each_drv --&gt; __device_attach_driver --&gt; driver_probe_device --&gt; </span><br><span class="line">pci_device_probe --&gt; local_pci_probe --&gt; virtio_pci_probe --&gt; register_virtio_device --&gt; </span><br><span class="line">device_register --&gt; device_add --&gt; bus_probe_device --&gt; device_initial_probe </span><br><span class="line">--&gt; __device_attach --&gt; bus_for_each_drv --&gt; __device_attach_driver --&gt;</span><br><span class="line">driver_probe_device --&gt; virtio_dev_probe --&gt; virtnet_probe (网卡设备驱动加载的入口)</span><br><span class="line">static int virtnet_probe(struct virtio_device *vdev) </span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    virtio_device_ready(vdev);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * virtio_device_ready - enable vq use in probe function</span><br><span class="line"> * @vdev: the device</span><br><span class="line"> *</span><br><span class="line"> * Driver must call this to use vqs in the probe function.</span><br><span class="line"> *</span><br><span class="line"> * Note: vqs are enabled automatically after probe returns.</span><br><span class="line"> */</span><br><span class="line">static inline</span><br><span class="line">void virtio_device_ready(struct virtio_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">        unsigned status = dev-&gt;config-&gt;get_status(dev);</span><br><span class="line">        BUG_ON(status &amp; VIRTIO_CONFIG_S_DRIVER_OK);</span><br><span class="line">        dev-&gt;config-&gt;set_status(dev, status | VIRTIO_CONFIG_S_DRIVER_OK);</span><br><span class="line">&#125;</span><br><span class="line"># QEMU/KVM后端的处理流程如下：</span><br><span class="line"># 前端驱动写Status位，val &amp; VIRTIO_CONFIG_S_DRIVER_OK，这时候前端驱动已经ready</span><br><span class="line">virtio_pci_config_write  --&gt; virtio_ioport_write --&gt; virtio_pci_start_ioeventfd</span><br><span class="line">--&gt; virtio_bus_set_host_notifier --&gt; virtio_bus_start_ioeventfd --&gt; virtio_device_start_ioeventfd_impl</span><br><span class="line">--&gt; virtio_bus_set_host_notifier</span><br><span class="line">    --&gt; virtio_pci_ioeventfd_assign</span><br><span class="line">        --&gt; memory_region_add_eventfd</span><br><span class="line">            --&gt; memory_region_transaction_commit</span><br><span class="line">              --&gt; address_space_update_ioeventfds</span><br><span class="line">                --&gt; address_space_add_del_ioeventfds</span><br><span class="line">                  --&gt; kvm_io_ioeventfd_add/vhost_eventfd_add</span><br><span class="line">                    --&gt; kvm_set_ioeventfd_pio</span><br><span class="line">                      --&gt; kvm_vm_ioctl(kvm_state, KVM_IOEVENTFD, &amp;kick)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其实，这就是QEMU的<code>Fast MMIO</code>实现机制。 我们可以看到，QEMU会为每个设备MMIO对应的MemoryRegion注册一个ioeventfd。 最后调用了一个KVM_IOEVENTFD ioctl到KVM内核里面，而在KVM内核中会将MMIO对应的（gpa,len,eventfd）信息会注册到KVM_FAST_MMIO_BUS上。 这样当Guest访问MMIO地址范围退出后（触发<code>EPT Misconfig</code>），KVM会查询一下访问的GPA是否落在某段MMIO地址空间range内部， 如果是的话就直接写eventfd告知QEMU，QEMU就会从coalesced mmio ring page中取MMIO请求 （注：pio page和 mmio page是QEMU和KVM内核之间的共享内存页，已经提前mmap好了）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#kvm内核代码virt/kvm/eventfd.c中</span><br><span class="line">kvm_vm_ioctl(KVM_IOEVENTFD)</span><br><span class="line">  --&gt; kvm_ioeventfd</span><br><span class="line">    --&gt; kvm_assign_ioeventfd</span><br><span class="line">      --&gt; kvm_assign_ioeventfd_idx</span><br><span class="line"># MMIO处理流程中（handle_ept_misconfig）最后会调用到ioeventfd_write通知QEMU。</span><br><span class="line">/* MMIO/PIO writes trigger an event if the addr/val match */</span><br><span class="line">static int</span><br><span class="line">ioeventfd_write(struct kvm_vcpu *vcpu, struct kvm_io_device *this, gpa_t addr,</span><br><span class="line">                int len, const void *val)</span><br><span class="line">&#123;</span><br><span class="line">        struct _ioeventfd *p = to_ioeventfd(this);</span><br><span class="line">        if (!ioeventfd_in_range(p, addr, len, val))</span><br><span class="line">                return -EOPNOTSUPP;</span><br><span class="line">        eventfd_signal(p-&gt;eventfd, 1);</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不了解<code>MMIO</code>是如何模拟的童鞋，可以结合本站的文章<a href="https://kernelgo.org/mmio.html"><code>MMIO</code>模拟实现分析</a>去了解一下， 如果还是不懂的可以在文章下面评论。</p>
<p><strong>后端通知前端，是通过中断的方式</strong>，QEMU/KVM中有一套完整的中断模拟实现框架，</p>
<p>如果对QEMU/KVM中断模拟不熟悉的童鞋， 建议阅读一下这篇文章：<a href="https://www.binss.me/blog/qemu-note-of-interrupt/"><code>QEMU学习笔记-中断</code></a>。 对于virtio-pci设备，可以通过Cap呈现MSIx给虚拟机，这样在前端驱动加载的时候就会尝试去使能MSIx中断， 后端在这个时候建立起MSIx通道。</p>
<p>前端驱动加载(probe)的过程中，会去初始化<code>virtqueue</code>，这个时候会去申请MSIx中断并注册中断处理函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">virtnet_probe</span><br><span class="line">  --&gt; init_vqs</span><br><span class="line">    --&gt; virtnet_find_vqs</span><br><span class="line">      --&gt; vi-&gt;vdev-&gt;config-&gt;find_vqs [vp_modern_find_vqs]</span><br><span class="line">        --&gt; vp_find_vqs</span><br><span class="line">          --&gt; vp_find_vqs_msix // 为每virtqueue申请一个MSIx中断，通常收发各一个队列</span><br><span class="line">            --&gt; vp_request_msix_vectors // 主要的MSIx中断申请逻辑都在这个函数里面</span><br><span class="line">              --&gt; pci_alloc_irq_vectors_affinity // 申请MSIx中断描述符(__pci_enable_msix_range)</span><br><span class="line">                --&gt; request_irq  // 注册中断处理函数</span><br><span class="line">               </span><br><span class="line">	       // virtio-net网卡至少申请了3个MSIx中断：</span><br><span class="line">                // 一个是configuration change中断（配置空间发生变化后，QEMU通知前端）</span><br><span class="line">                // 发送队列1个MSIx中断，接收队列1MSIx中断</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在QEMU/KVM这一侧，开始模拟MSIx中断，具体流程大致如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">virtio_pci_config_write</span><br><span class="line">  --&gt; virtio_ioport_write</span><br><span class="line">    --&gt; virtio_set_status</span><br><span class="line">      --&gt; virtio_net_vhost_status</span><br><span class="line">        --&gt; vhost_net_start</span><br><span class="line">          --&gt; virtio_pci_set_guest_notifiers</span><br><span class="line">            --&gt; kvm_virtio_pci_vector_use </span><br><span class="line">              |--&gt; kvm_irqchip_add_msi_route //更新中断路由表</span><br><span class="line">              |--&gt; kvm_virtio_pci_irqfd_use  //使能MSI中断</span><br><span class="line">                 --&gt; kvm_irqchip_add_irqfd_notifier_gsi</span><br><span class="line">                   --&gt; kvm_irqchip_assign_irqfd</span><br><span class="line">                  </span><br><span class="line"># 申请MSIx中断的时候，会为MSIx分配一个gsi，并为这个gsi绑定一个irqfd，然后调用ioctl KVM_IRQFD注册到内核中。               </span><br><span class="line">static int kvm_irqchip_assign_irqfd(KVMState *s, int fd, int rfd, int virq,</span><br><span class="line">                                    bool assign)</span><br><span class="line">&#123;</span><br><span class="line">    struct kvm_irqfd irqfd = &#123;</span><br><span class="line">        .fd = fd,</span><br><span class="line">        .gsi = virq,</span><br><span class="line">        .flags = assign ? 0 : KVM_IRQFD_FLAG_DEASSIGN,</span><br><span class="line">    &#125;;</span><br><span class="line">    if (rfd != -1) &#123;</span><br><span class="line">        irqfd.flags |= KVM_IRQFD_FLAG_RESAMPLE;</span><br><span class="line">        irqfd.resamplefd = rfd;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!kvm_irqfds_enabled()) &#123;</span><br><span class="line">        return -ENOSYS;</span><br><span class="line">    &#125;</span><br><span class="line">    return kvm_vm_ioctl(s, KVM_IRQFD, &amp;irqfd);</span><br><span class="line">&#125;</span><br><span class="line"># KVM内核代码virt/kvm/eventfd.c</span><br><span class="line">kvm_vm_ioctl(s, KVM_IRQFD, &amp;irqfd)</span><br><span class="line">  --&gt; kvm_irqfd_assign</span><br><span class="line">    --&gt; vfs_poll(f.file, &amp;irqfd-&gt;pt) // 在内核中poll这个irqfd</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从上面的流程可以看出，<strong>QEMU/KVM使用<code>irqfd</code>机制来模拟MSIx中断</strong>， 即设备申请MSIx中断的时候会为MSIx分配一个gsi（这个时候会刷新irq routing table）， 并为这个gsi绑定一个<code>irqfd</code>，最后在内核中去<code>poll</code>这个<code>irqfd</code>。 当QEMU处理完IO之后，就写MSIx对应的irqfd，给前端注入一个MSIx中断，告知前端我已经处理好IO了你可以来取结果了。</p>
<p>例如，virtio-scsi从前端取出IO请求后会取做DMA操作（DMA是异步的，QEMU协程中负责处理）。 当DMA完成后QEMU需要告知前端IO请求已完成（Complete），那么怎么去投递这个MSIx中断呢？ 答案是调用<code>virtio_notify_irqfd</code>注入一个MSIx中断。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#0  0x00005604798d569b in virtio_notify_irqfd (vdev=0x56047d12d670, vq=0x7fab10006110) at  hw/virtio/virtio.c:1684</span><br><span class="line">#1  0x00005604798adea4 in virtio_scsi_complete_req (req=0x56047d09fa70) at  hw/scsi/virtio-scsi.c:76</span><br><span class="line">#2  0x00005604798aecfb in virtio_scsi_complete_cmd_req (req=0x56047d09fa70) at  hw/scsi/virtio-scsi.c:468</span><br><span class="line">#3  0x00005604798aee9d in virtio_scsi_command_complete (r=0x56047ccb0be0, status=0, resid=0) at  hw/scsi/virtio-scsi.c:495</span><br><span class="line">#4  0x0000560479b397cf in scsi_req_complete (req=0x56047ccb0be0, status=0) at hw/scsi/scsi-bus.c:1404</span><br><span class="line">#5  0x0000560479b2b503 in scsi_dma_complete_noio (r=0x56047ccb0be0, ret=0) at hw/scsi/scsi-disk.c:279</span><br><span class="line">#6  0x0000560479b2b610 in scsi_dma_complete (opaque=0x56047ccb0be0, ret=0) at hw/scsi/scsi-disk.c:300</span><br><span class="line">#7  0x00005604799b89e3 in dma_complete (dbs=0x56047c6e9ab0, ret=0) at dma-helpers.c:118</span><br><span class="line">#8  0x00005604799b8a90 in dma_blk_cb (opaque=0x56047c6e9ab0, ret=0) at dma-helpers.c:136</span><br><span class="line">#9  0x0000560479cf5220 in blk_aio_complete (acb=0x56047cd77d40) at block/block-backend.c:1327</span><br><span class="line">#10 0x0000560479cf5470 in blk_aio_read_entry (opaque=0x56047cd77d40) at block/block-backend.c:1387</span><br><span class="line">#11 0x0000560479df49c4 in coroutine_trampoline (i0=2095821104, i1=22020) at util/coroutine-ucontext.c:115</span><br><span class="line">#12 0x00007fab214d82c0 in __start_context () at /usr/lib64/libc.so.6</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在<code>virtio_notify_irqfd</code> 函数中，会去写<code>irqfd</code>，给内核发送一个信号。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void virtio_notify_irqfd(VirtIODevice *vdev, VirtQueue *vq)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">     /*</span><br><span class="line">     * virtio spec 1.0 says ISR bit 0 should be ignored with MSI, but</span><br><span class="line">     * windows drivers included in virtio-win 1.8.0 (circa 2015) are</span><br><span class="line">     * incorrectly polling this bit during crashdump and hibernation</span><br><span class="line">     * in MSI mode, causing a hang if this bit is never updated.</span><br><span class="line">     * Recent releases of Windows do not really shut down, but rather</span><br><span class="line">     * log out and hibernate to make the next startup faster.  Hence,</span><br><span class="line">     * this manifested as a more serious hang during shutdown with</span><br><span class="line">     *</span><br><span class="line">     * Next driver release from 2016 fixed this problem, so working around it</span><br><span class="line">     * is not a must, but it&#x27;s easy to do so let&#x27;s do it here.</span><br><span class="line">     *</span><br><span class="line">     * Note: it&#x27;s safe to update ISR from any thread as it was switched</span><br><span class="line">     * to an atomic operation.</span><br><span class="line">     */</span><br><span class="line">    virtio_set_isr(vq-&gt;vdev, 0x1);</span><br><span class="line">    event_notifier_set(&amp;vq-&gt;guest_notifier);   //写vq-&gt;guest_notifier，即irqfd</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>QEMU写了这个<code>irqfd</code>后，KVM内核模块中的irqfd poll就收到一个<code>POLL_IN</code>事件，然后将MSIx中断自动投递给对应的LAPIC。 大致流程是：<code>POLL_IN</code> -&gt; <code>kvm_arch_set_irq_inatomic</code> -&gt; <code>kvm_set_msi_irq</code>, <code>kvm_irq_delivery_to_apic_fast</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int</span><br><span class="line">irqfd_wakeup(wait_queue_entry_t *wait, unsigned mode, int sync, void *key)</span><br><span class="line">&#123;</span><br><span class="line">        if (flags &amp; EPOLLIN) &#123;</span><br><span class="line">                idx = srcu_read_lock(&amp;kvm-&gt;irq_srcu);</span><br><span class="line">                do &#123;</span><br><span class="line">                        seq = read_seqcount_begin(&amp;irqfd-&gt;irq_entry_sc);</span><br><span class="line">                        irq = irqfd-&gt;irq_entry;</span><br><span class="line">                &#125; while (read_seqcount_retry(&amp;irqfd-&gt;irq_entry_sc, seq));</span><br><span class="line">                /* An event has been signaled, inject an interrupt */</span><br><span class="line">                if (kvm_arch_set_irq_inatomic(&amp;irq, kvm,</span><br><span class="line">                                             KVM_USERSPACE_IRQ_SOURCE_ID, 1,</span><br><span class="line">                                             false) == -EWOULDBLOCK)</span><br><span class="line">                        schedule_work(&amp;irqfd-&gt;inject);</span><br><span class="line">                srcu_read_unlock(&amp;kvm-&gt;irq_srcu, idx);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里还有一点没有想明白，结合代码和调试来看，virtio-blk/virtio-scsi的msi中断走irqfd机制， 但是virtio-net（不开启vhost的情况下）不走irqfd，而是直接调用<code>virtio_notify</code>/<code>virtio_pci_notify</code>， 最后通过KVM的ioctl投递中断？ 从代码路径上来看，后者明显路径更长，谁知道原因告诉我一下!!!。 <a href="https://patchwork.kernel.org/patch/9531577/">https://patchwork.kernel.org/patch/9531577/</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Once in virtio_notify_irqfd, once in virtio_queue_guest_notifier_read.</span><br><span class="line">Unfortunately, for virtio-blk + MSI + KVM + old Windows drivers we need the one in virtio_notify_irqfd.</span><br><span class="line">For virtio-net + vhost + INTx we need the one in virtio_queue_guest_notifier_read. </span><br><span class="line">这显然路径更长啊。 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Ok，到这里virtio前后端通信机制已经明了，最后一个小节我们以virtio-net为例，梳理一下virtio中的部分核心代码流程。</p>
<h2 id="3-virtio核心代码分析，以virtio-net为例"><a href="#3-virtio核心代码分析，以virtio-net为例" class="headerlink" title="3. virtio核心代码分析，以virtio-net为例 "></a>3. virtio核心代码分析，以virtio-net为例 </h2><p>这里我们已virtio-net网卡为例，在没有使用vhost的情况下（网卡后端收发包都走QEMU处理）， 后端收发包走vhost的情况下有些不同，后面单独分析。</p>
<h3 id="3-1-前后端握手流程"><a href="#3-1-前后端握手流程" class="headerlink" title="3.1 前后端握手流程"></a>3.1 前后端握手流程</h3><p>QEM模拟PCI设备对GuestOS进行呈现，设备驱动加载的时候尝试去初始化设备。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 先在PCI总线上调用probe设备，调用了virtio_pci_probe，然后再virtio-bus上调用virtio_dev_probe</span><br><span class="line"># virtio_dev_probe最后调用到virtnet_probe</span><br><span class="line">pci_device_probe --&gt; local_pci_probe --&gt; virtio_pci_probe --&gt; register_virtio_device --&gt; </span><br><span class="line">device_register --&gt; device_add --&gt; bus_probe_device --&gt; device_initial_probe </span><br><span class="line">--&gt; __device_attach --&gt; bus_for_each_drv --&gt; __device_attach_driver --&gt; driver_probe_device --&gt; </span><br><span class="line">virtio_dev_probe --&gt; virtnet_probe</span><br><span class="line"># 在virtio_pci_probe里先尝试以virtio modern方式读取设备配置数据结构，如果失败则尝试virio legacy方式。</span><br><span class="line"># 对于virtio legacy，我们前面提到了virtio legacy协议规定设备的配置数据结构放在PCI BAR0里面。</span><br><span class="line">/* the PCI probing function */</span><br><span class="line">int virtio_pci_legacy_probe(struct virtio_pci_device *vp_dev)</span><br><span class="line">&#123;</span><br><span class="line">        rc = pci_request_region(pci_dev, 0, &quot;virtio-pci-legacy&quot;);  //将设备的BAR0映射到物理地址空间</span><br><span class="line">        vp_dev-&gt;ioaddr = pci_iomap(pci_dev, 0, 0);   //获得BAR0的内核地址</span><br><span class="line">&#125;</span><br><span class="line">#对于virtio modern，通过capability方式报告配置数据结构的位置，配置数据结构有5种类型。</span><br><span class="line">int virtio_pci_modern_probe(struct virtio_pci_device *vp_dev)</span><br><span class="line">&#123;</span><br><span class="line">        /* check for a common config: if not, use legacy mode (bar 0). */</span><br><span class="line">        common = virtio_pci_find_capability(pci_dev, VIRTIO_PCI_CAP_COMMON_CFG,</span><br><span class="line">                                            IORESOURCE_IO | IORESOURCE_MEM,</span><br><span class="line">                                            &amp;vp_dev-&gt;modern_bars);</span><br><span class="line">        /* If common is there, these should be too... */</span><br><span class="line">        isr = virtio_pci_find_capability(pci_dev, VIRTIO_PCI_CAP_ISR_CFG,</span><br><span class="line">                                         IORESOURCE_IO | IORESOURCE_MEM,</span><br><span class="line">                                         &amp;vp_dev-&gt;modern_bars);</span><br><span class="line">        notify = virtio_pci_find_capability(pci_dev, VIRTIO_PCI_CAP_NOTIFY_CFG,</span><br><span class="line">                                            IORESOURCE_IO | IORESOURCE_MEM,</span><br><span class="line">                                            &amp;vp_dev-&gt;modern_bars);</span><br><span class="line">                                            </span><br><span class="line">        /* Device capability is only mandatory for devices that have</span><br><span class="line">        * device-specific configuration.</span><br><span class="line">        */</span><br><span class="line">        device = virtio_pci_find_capability(pci_dev, VIRTIO_PCI_CAP_DEVICE_CFG,</span><br><span class="line">                                            IORESOURCE_IO | IORESOURCE_MEM,</span><br><span class="line">                                            &amp;vp_dev-&gt;modern_bars);</span><br><span class="line">        err = pci_request_selected_regions(pci_dev, vp_dev-&gt;modern_bars,</span><br><span class="line">                                            &quot;virtio-pci-modern&quot;);</span><br><span class="line">                                        sizeof(struct virtio_pci_common_cfg), 4,</span><br><span class="line">                                        0, sizeof(struct virtio_pci_common_cfg),</span><br><span class="line">                                        NULL);</span><br><span class="line">        // 将配virtio置结构所在的BAR空间MAP到内核地址空间里                                </span><br><span class="line">        vp_dev-&gt;common = map_capability(pci_dev, common,</span><br><span class="line">                                        sizeof(struct virtio_pci_common_cfg), 4,</span><br><span class="line">                                        0, sizeof(struct virtio_pci_common_cfg),</span><br><span class="line">                                        NULL);</span><br><span class="line">        ......                              </span><br><span class="line">&#125;</span><br><span class="line"># 接着来到virtio_dev_probe里面看下：</span><br><span class="line">static int virtio_dev_probe(struct device *_d)</span><br><span class="line">&#123;</span><br><span class="line">        /* We have a driver! */</span><br><span class="line">        virtio_add_status(dev, VIRTIO_CONFIG_S_DRIVER);     // 更新status bit，这里要写配置数据结构</span><br><span class="line">        /* Figure out what features the device supports. */</span><br><span class="line">        device_features = dev-&gt;config-&gt;get_features(dev);   // 查询后端支持哪些feature bits</span><br><span class="line">        </span><br><span class="line">        // feature set协商，取交集</span><br><span class="line">        err = virtio_finalize_features(dev); </span><br><span class="line">        </span><br><span class="line">        // 调用特定virtio设备的驱动程序probe，例如: virtnet_probe, virtblk_probe</span><br><span class="line">        err = drv-&gt;probe(dev); </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再看下<code>virtnet_probe</code>里面的一些关键的流程，这里包含了virtio-net网卡前端初始化的主要逻辑。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int virtnet_probe(struct virtio_device *vdev)</span><br><span class="line">&#123;</span><br><span class="line">       // check后端是否支持多队列，并按情况创建队列</span><br><span class="line">       /* Allocate ourselves a network device with room for our info */</span><br><span class="line">        dev = alloc_etherdev_mq(sizeof(struct virtnet_info), max_queue_pairs);</span><br><span class="line">        </span><br><span class="line">        // 定义一个网络设备并配置一些属性，例如MAC地址</span><br><span class="line">        dev-&gt;ethtool_ops = &amp;virtnet_ethtool_ops;</span><br><span class="line">	       SET_NETDEV_DEV(dev, &amp;vdev-&gt;dev);</span><br><span class="line"> </span><br><span class="line">        // 初始化virtqueue</span><br><span class="line">        err = init_vqs(vi);</span><br><span class="line">        </span><br><span class="line">        // 注册一个网络设备</span><br><span class="line">        err = register_netdev(dev);</span><br><span class="line">        </span><br><span class="line">        // 写状态位DRIVER_OK，告诉后端，前端已经ready</span><br><span class="line">        virtio_device_ready(vdev);</span><br><span class="line">        </span><br><span class="line">        // 将网卡up起来</span><br><span class="line">        netif_carrier_on(dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中关键的流程是<code>init_vqs</code>，在<code>vp_find_vqs_msix</code>流程中会尝试去申请MSIx中断，这里前面已经有分析过了。 其中，”configuration changed” 中断服务程序<code>vp_config_changed</code>， virtqueue队列的中断服务程序是 <code>vp_vring_interrupt</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">init_vqs --&gt; virtnet_find_vqs --&gt; vi-&gt;vdev-&gt;config-&gt;find_vqs --&gt; vp_modern_find_vqs</span><br><span class="line">--&gt; vp_find_vqs --&gt; vp_find_vqs_msix</span><br><span class="line">static int vp_find_vqs_msix(struct virtio_device *vdev, unsigned nvqs,</span><br><span class="line">		struct virtqueue *vqs[], vq_callback_t *callbacks[],</span><br><span class="line">		const char * const names[], bool per_vq_vectors,</span><br><span class="line">		const bool *ctx,</span><br><span class="line">		struct irq_affinity *desc)</span><br><span class="line">&#123;</span><br><span class="line">        /* 为configuration change申请MSIx中断 */</span><br><span class="line">	err = vp_request_msix_vectors(vdev, nvectors, per_vq_vectors,</span><br><span class="line">			      per_vq_vectors ? desc : NULL);</span><br><span class="line">        for (i = 0; i &lt; nvqs; ++i) &#123;</span><br><span class="line">		 // 创建队列 --&gt; vring_create_virtqueue --&gt; vring_create_virtqueue_split --&gt; vring_alloc_queue</span><br><span class="line">	         vqs[i] = vp_setup_vq(vdev, queue_idx++, callbacks[i], names[i],</span><br><span class="line">                                ctx ? ctx[i] : false,</span><br><span class="line">                                msix_vec);</span><br><span class="line">		// 每个队列申请一个MSIx中断</span><br><span class="line">                err = request_irq(pci_irq_vector(vp_dev-&gt;pci_dev, msix_vec),</span><br><span class="line">                                  vring_interrupt, 0,</span><br><span class="line">                                  vp_dev-&gt;msix_names[msix_vec],</span><br><span class="line">                                  vqs[i]);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>vp_setup_vq</code>流程再往下走就开始分配共享内存页，至此建立起共享内存通信通道。 值得注意的是一路传下来的callbacks参数其实传入了发送队列和接收队列的回调处理函数， 好家伙，从<code>virtnet_find_vqs</code>一路传递到了<code>__vring_new_virtqueue</code>中最终赋值给了<code>vq-&gt;vq.callback</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static struct virtqueue *vring_create_virtqueue_split(</span><br><span class="line">        unsigned int index,</span><br><span class="line">        unsigned int num,</span><br><span class="line">        unsigned int vring_align,</span><br><span class="line">        struct virtio_device *vdev,</span><br><span class="line">        bool weak_barriers,</span><br><span class="line">        bool may_reduce_num,</span><br><span class="line">        bool context,</span><br><span class="line">        bool (*notify)(struct virtqueue *),</span><br><span class="line">        void (*callback)(struct virtqueue *),</span><br><span class="line">        const char *name)</span><br><span class="line">&#123;</span><br><span class="line">       /* TODO: allocate each queue chunk individually */</span><br><span class="line">        for (; num &amp;&amp; vring_size(num, vring_align) &gt; PAGE_SIZE; num /= 2) &#123;</span><br><span class="line">		// 申请物理页，地址赋值给queue</span><br><span class="line">                queue = vring_alloc_queue(vdev, vring_size(num, vring_align),</span><br><span class="line">                                          &amp;dma_addr,</span><br><span class="line">                                          GFP_KERNEL|__GFP_NOWARN|__GFP_ZERO);</span><br><span class="line">        &#125;</span><br><span class="line">        queue_size_in_bytes = vring_size(num, vring_align);</span><br><span class="line">        vring_init(&amp;vring, num, queue, vring_align); // 确定 descriptor table, available ring, used ring的位置。</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们看下如果<code>virtqueue</code>队列如果收到MSIx中断消息后，会调用哪个<code>hook</code>来处理？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">irqreturn_t vring_interrupt(int irq, void *_vq)</span><br><span class="line">&#123;</span><br><span class="line">        struct vring_virtqueue *vq = to_vvq(_vq);</span><br><span class="line">        if (!more_used(vq)) &#123;</span><br><span class="line">                pr_debug(&quot;virtqueue interrupt with no work for %p\n&quot;, vq);</span><br><span class="line">                return IRQ_NONE;</span><br><span class="line">        &#125;</span><br><span class="line">        if (unlikely(vq-&gt;broken))</span><br><span class="line">                return IRQ_HANDLED;</span><br><span class="line">        pr_debug(&quot;virtqueue callback for %p (%p)\n&quot;, vq, vq-&gt;vq.callback);</span><br><span class="line">        if (vq-&gt;vq.callback)</span><br><span class="line">                vq-&gt;vq.callback(&amp;vq-&gt;vq);</span><br><span class="line">        return IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(vring_interrupt);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不难想到中断服务程序里面会调用队列上的callback。 我们再回过头来看下<code>virtnet_find_vqs</code>，原来接受队列的回调函数是<code>skb_recv_done</code>，发送队列的回调函数是<code>skb_xmit_done</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int virtnet_find_vqs(struct virtnet_info *vi)</span><br><span class="line">&#123;</span><br><span class="line">       /* Allocate/initialize parameters for send/receive virtqueues */</span><br><span class="line">        for (i = 0; i &lt; vi-&gt;max_queue_pairs; i++) &#123;</span><br><span class="line">		callbacks[rxq2vq(i)] = skb_recv_done;</span><br><span class="line">		callbacks[txq2vq(i)] = skb_xmit_done;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>OK，这个小节就到这里。Are you clear ?</p>
<h3 id="3-2-virtio-net网卡收发在virtqueue上的实现"><a href="#3-2-virtio-net网卡收发在virtqueue上的实现" class="headerlink" title="3.2 virtio-net网卡收发在virtqueue上的实现"></a>3.2 virtio-net网卡收发在virtqueue上的实现</h3><p>这里以virtio-net为例（非vhost-net模式）来分析一下网卡收发报文在virtio协议上的具体实现。 virtio-net模式下网卡收发包的流程为：</p>
<ul>
<li>  收包：Hardware =&gt; Host Kernel =&gt; Qemu =&gt; Guest</li>
<li>  发包：Guest =&gt; Host Kernel =&gt; Qemu =&gt; Host Kernel =&gt; Hardware</li>
</ul>
<h4 id="3-2-1-virtio-net网卡发包"><a href="#3-2-1-virtio-net网卡发包" class="headerlink" title="3.2.1 virtio-net网卡发包"></a>3.2.1 virtio-net网卡发包</h4><p>前面我们看到virtio-net设备初始化的时候会创建一个<code>net_device</code>设备： <code>virtnet_probe</code> -&gt; <code>alloc_etherdev_mq</code>注册了<code>netdev_ops</code> = <code>&amp;virtnet_netdev</code>， 这里<code>virtnet_netdev</code>是网卡驱动的回调函数集合（收发包和参数设置）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static const struct net_device_ops netdev_ops = &#123;</span><br><span class="line">        .ndo_open               = rio_open,</span><br><span class="line">        .ndo_start_xmit = start_xmit,</span><br><span class="line">        .ndo_stop               = rio_close,</span><br><span class="line">        .ndo_get_stats          = get_stats,</span><br><span class="line">        .ndo_validate_addr      = eth_validate_addr,</span><br><span class="line">        .ndo_set_mac_address    = eth_mac_addr,</span><br><span class="line">        .ndo_set_rx_mode        = set_multicast,</span><br><span class="line">        .ndo_do_ioctl           = rio_ioctl,</span><br><span class="line">        .ndo_tx_timeout         = rio_tx_timeout,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>网卡发包的时候调用<code>ndo_start_xmit</code>，将TCP/IP上层协议栈扔下来的数据发送出去。 对应到virtio网卡的回调函数就是<code>start_xmit</code>，从代码看就是将skb发送到virtqueue中， 然后调用virtqueue_kick通知qemu后端将数据包发送出去。</p>
<p>Guest内核里面的virtio-net驱动发包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">内核驱动 virtio_net.c</span><br><span class="line">start_xmit</span><br><span class="line">	// 将skb放到virtqueue队列中</span><br><span class="line"> 	-&gt; xmit_skb -&gt; sg_init_table,virtqueue_add_outbuf -&gt; virtqueue_add</span><br><span class="line">	// kick通知qemu后端去取</span><br><span class="line">	virtqueue_kick_prepare &amp;&amp; virtqueue_notify </span><br><span class="line">	// kick次数加1</span><br><span class="line">	sq-&gt;stats.kicks++</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Guest Kick后端从KVM中VMExit出来退出到Qemu用户态（走的是ioeventfd）由Qemu去将数据发送出去。 大致调用的流程是： <code>virtio_queue_host_notifier_read</code> -&gt; <code>virtio_net_handle_tx_bh</code> -&gt; <code>virtio_net_flush_tx</code> -&gt; <code>virtqueue_pop</code>拿到发包(skb) -&gt; <code>qemu_sendv_packet_async</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Qemu代码virtio-net相关代码:</span><br><span class="line">virtio_queue_host_notifier_read -&gt; virtio_queue_notify_vq</span><br><span class="line">    -&gt; vq-&gt;handle_output -&gt; virtio_net_handle_tx_bh 队列注册的时候，回注册回调函数</span><br><span class="line">        -&gt; qemu_bh_schedule -&gt; virtio_net_tx_bh</span><br><span class="line">            -&gt; virtio_net_flush_tx</span><br><span class="line">	        -&gt; virtqueue_pop</span><br><span class="line">		-&gt; qemu_sendv_packet_async // 报文放到发送队列上，写tap设备的fd去发包</span><br><span class="line">		    -&gt; tap_receive_iov -&gt; tap_write_packet</span><br><span class="line">		    </span><br><span class="line">// 最后调用 tap_write_packet 把数据包发给tap设备投递出去</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-virtio-net网卡收包"><a href="#3-2-2-virtio-net网卡收包" class="headerlink" title="3.2.2 virtio-net网卡收包"></a>3.2.2 virtio-net网卡收包</h4><p>网卡收包的时候，tap设备先收到报文，对应的virtio-net网卡tap设备fd变为可读， Qemu主循环收到POLL_IN事件调用回调函数收包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tap_send -&gt; qemu_send_packet_async -&gt; qemu_send_packet_async_with_flags</span><br><span class="line">    -&gt; qemu_net_queue_send</span><br><span class="line">        -&gt; qemu_net_queue_deliver</span><br><span class="line">	    -&gt; qemu_deliver_packet_iov</span><br><span class="line">	        -&gt; nc_sendv_compat</span><br><span class="line">		    -&gt; virtio_net_receive</span><br><span class="line">		        -&gt; virtio_net_receive_rcu</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>virtio-net网卡收报最终调用了<code>virtio_net_receive_rcu</code>， 和发包类似都是调用<code>virtqueue_pop</code>从前端获取virtqueue element， 将报文数据填充到vring中然后<code>virtio_notify</code>注入中断通知前端驱动取结果。</p>
<p>这里不得不吐槽一下，为啥收包函数取名要叫<code>tap_send</code>。</p>
<h2 id="4-参考文献"><a href="#4-参考文献" class="headerlink" title="4. 参考文献 "></a>4. 参考文献 </h2><ol>
<li> <a href="https://docs.oasis-open.org/virtio/virtio/v1.1/csprd01/virtio-v1.1-csprd01.html">virtio spec v1.1</a></li>
<li> <a href="https://ozlabs.org/~rusty/virtio-spec/virtio-paper.pdf">Towards a De-Facto Standard For Virtual</a></li>
<li> <a href="https://github.com/qemu/qemu/blob/master/hw/net/virtio-net.c">https://github.com/qemu/qemu/blob/master/hw/net/virtio-net.c</a></li>
<li> <a href="https://github.com/torvalds/linux/blob/master/drivers/net/virtio/_net.c">https://github.com/torvalds/linux/blob/master/drivers/net/virtio\_net.c</a></li>
</ol>
]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>Virtio</tag>
      </tags>
  </entry>
  <entry>
    <title>runlevel设置</title>
    <url>/2022/06/21/runlevel%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="runlevel"><a href="#runlevel" class="headerlink" title="runlevel"></a>runlevel</h1><ul>
<li>  linux操作系统自从开始启动至启动完毕需要经历几个不同的阶段，这几个阶段就叫做runlevel</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;Runlevels&quot; are an obsolete way to start and stop groups of services used in SysV init. </span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>使用runlevel查看当前系统运行的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u20@u20:~$ runlevel --help</span><br><span class="line">runlevel [OPTIONS...]</span><br><span class="line"></span><br><span class="line">Prints the previous and current runlevel of the init system.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">     --help      Show this help</span><br><span class="line"></span><br><span class="line">See the runlevel(8) man page for details.</span><br><span class="line"></span><br><span class="line">Mapping between runlevels and systemd targets</span><br><span class="line">       ┌─────────┬───────────────────┐</span><br><span class="line">       │Runlevel │ Target            │</span><br><span class="line">       ├─────────┼───────────────────┤</span><br><span class="line">       │0        │ poweroff.target   │</span><br><span class="line">       ├─────────┼───────────────────┤</span><br><span class="line">       │1        │ rescue.target     │</span><br><span class="line">       ├─────────┼───────────────────┤</span><br><span class="line">       │2, 3, 4  │ multi-user.target │</span><br><span class="line">       ├─────────┼───────────────────┤</span><br><span class="line">       │5        │ graphical.target  │</span><br><span class="line">       ├─────────┼───────────────────┤</span><br><span class="line">       │6        │ reboot.target     │</span><br><span class="line">       ├─────────┼───────────────────┤</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>0 停机</li>
<li>1 单用户模式</li>
<li>2 多用户，没有 NFS</li>
<li>3 完全多用户模式 （命令行）</li>
<li>4 没有用到</li>
<li>5 图形界面</li>
<li>6 重新启动</li>
<li>S s Single user mode<br>  用到最多的时3和5还有0</li>
<li>系统默认安装后，若有图形界面则，默认进入 level 5</li>
<li>level 3 是最常用的命令行模式</li>
<li>关机时为level 0</li>
<li>更改密码或修复系统用到单用户模式level 0</li>
</ul>
<h1 id="init"><a href="#init" class="headerlink" title="init"></a>init</h1><ul>
<li>  init命令是Linux下的进程初始化工具，init进程是所有Linux进程的父进程，它的进程号为1。init命令是Linux操作系统中不可缺少的程序之一，init进程是Linux内核引导运行的，是系统中的第一个进程。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemd, init - systemd system and service manager</span><br></pre></td></tr></table></figure>

<h2 id="使用init切换用户模式"><a href="#使用init切换用户模式" class="headerlink" title="使用init切换用户模式"></a>使用init切换用户模式</h2><ul>
<li>  init 0 执行关机动作，需root权限</li>
<li>  init 3 切换至命令行界面</li>
<li>  init 5 切换至图形界面</li>
<li>  init -s 切换至单用户模式</li>
</ul>
<h2 id="设置Linux启动时的runlevel"><a href="#设置Linux启动时的runlevel" class="headerlink" title="设置Linux启动时的runlevel"></a>设置Linux启动时的runlevel</h2><ul>
<li>  CentOS</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[22:09:38 root@C8-3-55 ~]#cat /etc/inittab</span><br><span class="line"># inittab is no longer used.</span><br><span class="line">#</span><br><span class="line"># ADDING CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM.</span><br><span class="line">#</span><br><span class="line"># Ctrl-Alt-Delete is handled by /usr/lib/systemd/system/ctrl-alt-del.target</span><br><span class="line">#</span><br><span class="line"># systemd uses &#x27;targets&#x27; instead of runlevels. By default, there are two main targets:</span><br><span class="line">#</span><br><span class="line"># multi-user.target: analogous to runlevel 3</span><br><span class="line"># graphical.target: analogous to runlevel 5</span><br><span class="line">#</span><br><span class="line"># To view current default target, run:</span><br><span class="line"># systemctl get-default</span><br><span class="line">#</span><br><span class="line"># To set a default target, run:</span><br><span class="line"># systemctl set-default TARGET.target</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  Ubuntu</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u20@u20:~$ cat /run/utmp</span><br><span class="line">~~~reboot5.4.0-42-generic&#123;?Y`	35~~~runlevel5.4.0-42-genericGY`®7¤tty1tty1tty1LOGIN¤?Y`=	¶pts/0ts/0u2010.0.0.1W@Y`^® </span><br><span class="line">Epts/1ts/1u2010.0.0.1x@Y`</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面那个就是看看，配置文件在哪我暂时没找到，等找到了再发过来。</p>
<ul>
<li>  设置开机命令行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable multi-user.target</span><br><span class="line">sudo systemctl set-default multi-user.target</span><br><span class="line">或者</span><br><span class="line">sudo systemctl set-default runlevel3.target</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>-设置开机图形</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo systemctl enable graphical.target</span><br><span class="line">sudo systemctl set-default graphical.target</span><br><span class="line">或者</span><br><span class="line">sudo systemctl set-default graphical.target</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="Ubuntu-20-04-设置开机启动由图形界面改为直接进命令行"><a href="#Ubuntu-20-04-设置开机启动由图形界面改为直接进命令行" class="headerlink" title="Ubuntu 20.04 设置开机启动由图形界面改为直接进命令行"></a>Ubuntu 20.04 设置开机启动由图形界面改为直接进命令行</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u20@u20:~$ cat /etc/init/lightdm.conf </span><br><span class="line">cat: /etc/init/lightdm.conf: No such file or directory</span><br><span class="line">u20@u20:~$ sudo systemctl enable multi-user.target</span><br><span class="line">[sudo] password for u20: </span><br><span class="line">The unit files have no installation config (WantedBy=, RequiredBy=, Also=,</span><br><span class="line">Alias= settings in the [Install] section, and DefaultInstance= for template</span><br><span class="line">units). This means they are not meant to be enabled using systemctl.</span><br><span class="line"> </span><br><span class="line">Possible reasons for having this kind of units are:</span><br><span class="line">• A unit may be statically enabled by being symlinked from another unit&#x27;s</span><br><span class="line">  .wants/ or .requires/ directory.</span><br><span class="line">• A unit&#x27;s purpose may be to act as a helper for some other unit which has</span><br><span class="line">  a requirement dependency on it.</span><br><span class="line">• A unit may be started when needed via activation (socket, path, timer,</span><br><span class="line">  D-Bus, udev, scripted systemctl call, ...).</span><br><span class="line">• In case of template units, the unit is meant to be enabled with some</span><br><span class="line">  instance name specified.</span><br><span class="line">u20@u20:~$ sudo systemctl set-default multi-user.target</span><br><span class="line">Created symlink /etc/systemd/system/default.target → /lib/systemd/system/multi-user.target. ##实际上是更改了软链接</span><br><span class="line">u20@u20:~$ runlevel</span><br><span class="line">N 3</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>经过实验发现，Ubuntu 20启动runlevel修改方式并不保存在配置文件中，而是通过更改软连接的方式实现了启动runlevel的修改。</p>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>runlevel</tag>
      </tags>
  </entry>
  <entry>
    <title>ip netns</title>
    <url>/2022/06/20/ip-netns/</url>
    <content><![CDATA[<h2 id="一、命令介绍"><a href="#一、命令介绍" class="headerlink" title="一、命令介绍"></a>一、命令介绍</h2><p>  ip netns 命令是用来管理 <strong>网络命名空间</strong> 的，网络命名空间可以实现 <strong>网络隔离</strong>。每个网络命名空间都提供了一个完全独立的网络协议栈，包括网络设备接口、IPV4 和 IPV6 协议栈、IP路由表、防火墙规则、端口、sockets 等。像 docker 就是利用 Linux 的网络命名空间来实现容器网络的隔离。</p>
<span id="more"></span>

<table>
<thead>
<tr>
<th>用法</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>ip netns list</td>
<td>列出网络命名空间。此命令显示的是 “/var/run/netns” 中的所有网络命名空间。</td>
</tr>
<tr>
<td>ip netns add NAME</td>
<td>添加网络命名空间</td>
</tr>
<tr>
<td>ip [-all] netns delete [NAME]</td>
<td>删除网络命名空间</td>
</tr>
<tr>
<td>ip [-all] netns exec [NAME] cmd …</td>
<td>在指定的网络命名空间中执行命令</td>
</tr>
<tr>
<td>ip netns set NAME NETNSID</td>
<td>给网络命名空间分配id</td>
</tr>
<tr>
<td>ip netns identify [PID]</td>
<td>查看进程的网络命名空间</td>
</tr>
<tr>
<td>ip netns monitor</td>
<td>监控对网络命名空间的操作</td>
</tr>
<tr>
<td>ip netns pids NAME</td>
<td>查找使用此网络命名空间并将其作为主要网络命名空间的进程。此命令会从 /proc 目录中遍历。</td>
</tr>
</tbody></table>
<h2 id="二、示例演示"><a href="#二、示例演示" class="headerlink" title="二、示例演示"></a>二、示例演示</h2><p>添加并列出network namespace，随后删除所有的network namespace。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@cp:~# ip netns add test1</span><br><span class="line">root@cp:~# ip netns add test2</span><br><span class="line">root@cp:~# ip netns ls</span><br><span class="line">test2</span><br><span class="line">test1</span><br><span class="line">root@cp:~# ip -all netns del</span><br><span class="line">root@cp:~# ip netns ls</span><br></pre></td></tr></table></figure>

<p>创建的网络命名空间是可以在 /var/run/netns 路径下看到。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@cp:~# cd /var/run/netns/</span><br><span class="line">root@cp:/var/run/netns# ls</span><br><span class="line">test1  test2</span><br></pre></td></tr></table></figure>

<p>使用 exec 命令在网络命名空间中执行命令，查看 test1 的网卡信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@cp:~# ip netns exec test1 ip a</span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br></pre></td></tr></table></figure>

<p>网络命名空间除了网络是虚拟的以外，文件系统完全和当前系统共享，也就是说所有本地可以使用的命令都可以在网络命名空间中使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@cp:~# ip netns exec test1 ls</span><br><span class="line">app  backup.tar  cp1  perf.data  registry_latest.tar  test  test_0.1.tar  test-bind  ubuntu-test.tar</span><br><span class="line">root@cp:~# ip netns exec test1 pwd</span><br><span class="line">/root</span><br></pre></td></tr></table></figure>

<p>进入网络命名空间可以用 exec 执行 bash 即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@cp:~# ip netns exec test1 bash</span><br><span class="line">root@cp:~# ip a</span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br></pre></td></tr></table></figure>

<p>–all 选项可以在所有网络命名空间中执行命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@cp:~# ip -all netns exec ip a</span><br><span class="line"></span><br><span class="line">netns: test2</span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line"></span><br><span class="line">netns: test1</span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br></pre></td></tr></table></figure>

<p> <br>  使用 ip netns set NAME NETNSID 给网络命名空间分配ID。该ID仅在当前网络命名空间中有效，如果指定了关键字“ auto”，则将会自动选择一个可用的nsid。内核将在某些 netlink 消息中使用此ID，如果在内核需要时未分配ID，则它将由内核自动分配。注意 ID 分配后，将无法更改。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@cp:~# ip netns add cp</span><br><span class="line">root@cp:~# ip netns </span><br><span class="line">cp</span><br><span class="line">root@cp:~# ip netns set cp 6</span><br><span class="line">root@cp:~# ip netns </span><br><span class="line">cp (id: 6)</span><br></pre></td></tr></table></figure>

<p> <br>使用 ip netns monitor 监控网络命名空间的添加和删除事件，只能监控添加和删除。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@cp:~# ip netns del cp</span><br><span class="line">root@cp:~# ip netns add cp</span><br></pre></td></tr></table></figure>

<p>另一个终端同步反馈的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@cp:~# ip netns monitor</span><br><span class="line">delete cp</span><br><span class="line">add cp</span><br></pre></td></tr></table></figure>

<p> <br>  以下两个示例以 docker 容器为例，在没做一些设置前，使用 ip netns 命令是无法管理分配给 docker 容器的网络命名空间，至于如何使用 ip netns 命令管理分配给容器的网络命名空间，下面扩展中有介绍到。在做下面示例时请先做好以下设置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@cp:~# docker run -itd --name test centos</span><br><span class="line">7ec02643b32d1c53b39126f6d603b72a402597d938ddef35e7bdb4076763c68f</span><br><span class="line">root@cp:~# ip netns list    # 查看为空</span><br><span class="line">root@cp:~# </span><br><span class="line">root@cp:~# ln -s /proc/11421/ns/net /var/run/netns/test</span><br><span class="line">root@cp:~# ip netns list</span><br><span class="line">test (id: 0)</span><br></pre></td></tr></table></figure>

<p>  使用 ip netns identify 命令查看容器 test 的网络命名空间。使用 ip netns pids 命令查找使用该网络命名空间的进程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@cp:~# ip netns identify 11421</span><br><span class="line">test</span><br><span class="line">root@cp:~# ip netns pids test</span><br><span class="line">11421</span><br></pre></td></tr></table></figure>

<h2 id="三、扩展"><a href="#三、扩展" class="headerlink" title="三、扩展"></a>三、扩展</h2><h3 id="1、网络命名空间的连接"><a href="#1、网络命名空间的连接" class="headerlink" title="1、网络命名空间的连接"></a>1、网络命名空间的连接</h3><p>  创建一对 veth pair 虚拟网络设备接口，然后将其分别分配给两个网络命名空间，去连接两个网络命名空间。<br>  注：veth-pair 是一对的虚拟网络设备接口，它都是成对出现的，所以它常常充当着一个桥梁，我们可以用它实现 “网络命名空间之间的连接”、“Docker 容器之间的连接” 、“Docker 容器和网桥间的连接” 等等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@cp:~# ip link add name net1 type veth peer name net2</span><br><span class="line">root@cp:~# ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000</span><br><span class="line">    link/ether 00:0c:29:a9:42:0e brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.18.25/24 brd 192.168.18.255 scope global noprefixroute ens33</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::c75c:21df:8db2:598e/64 scope link noprefixroute </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default </span><br><span class="line">    link/ether 02:42:2c:d7:37:17 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::42:2cff:fed7:3717/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">19: net2@net1: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/ether e2:3c:d5:80:93:3c brd ff:ff:ff:ff:ff:ff</span><br><span class="line">20: net1@net2: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/ether f2:f1:b8:34:4a:9a brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure>

<p>将两个虚拟接口迁移到对应的网络命名空间里。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@cp:~# ip link set net1 netns test1</span><br><span class="line">root@cp:~# ip link set net2 netns test2</span><br><span class="line">root@cp:~# ip -all netns exec ip a</span><br><span class="line"></span><br><span class="line">netns: test2</span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">19: net2@if20: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/ether e2:3c:d5:80:93:3c brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line"></span><br><span class="line">netns: test1</span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">20: net1@if19: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/ether f2:f1:b8:34:4a:9a brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br></pre></td></tr></table></figure>

<p>给两块网卡设置ip并启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@cp:~# ip netns exec test1 ip addr add local 192.168.100.1/24 dev net1</span><br><span class="line">root@cp:~# ip netns exec test2 ip addr add local 192.168.100.2/24 dev net2</span><br><span class="line">root@cp:~# ip netns exec test1 ifconfig net2 up</span><br><span class="line">root@cp:~# ip netns exec test2 ifconfig net2 up</span><br><span class="line">root@cp:~# ip -all netns exec ip a</span><br><span class="line"></span><br><span class="line">netns: test2</span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">19: net2@if20: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000</span><br><span class="line">    link/ether e2:3c:d5:80:93:3c brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 192.168.100.2/24 scope global net2</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::e03c:d5ff:fe80:933c/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line">netns: test1</span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">20: net1@if19: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000</span><br><span class="line">    link/ether f2:f1:b8:34:4a:9a brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br><span class="line">    inet 192.168.100.1/24 scope global net1</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::f0f1:b8ff:fe34:4a9a/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>

<p>ping 测试通信</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@cp:~# ip netns exec test1 ping 192.168.100.2</span><br><span class="line">PING 192.168.100.2 (192.168.100.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.100.2: icmp_seq=1 ttl=64 time=0.275 ms</span><br><span class="line">64 bytes from 192.168.100.2: icmp_seq=2 ttl=64 time=0.047 ms</span><br><span class="line">64 bytes from 192.168.100.2: icmp_seq=3 ttl=64 time=0.043 ms</span><br><span class="line">^C</span><br><span class="line">--- 192.168.100.2 ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 2008ms</span><br><span class="line">rtt min/avg/max/mdev = 0.043/0.121/0.275/0.109 ms</span><br></pre></td></tr></table></figure>

<h3 id="2、关于docker网络命名空间的问题"><a href="#2、关于docker网络命名空间的问题" class="headerlink" title="2、关于docker网络命名空间的问题"></a>2、关于docker网络命名空间的问题</h3><p>  当 docker 容器被创建出来后，你会发现使用 ip netns 命令无法看到容器对应的网络命名空间。这是因为 ip netns 命令是从 /var/run/netns 文件夹中读取内容的，而 docker 容器的网络命名空间不是在 /var/run/netns 下，而是位于 /proc/[pid]/ns/net。想要使用 ip netns 命令去管理 docker 容器的网络命名空间，就需要将它的网络命名空间显示在 /var/run/netns 目录下，那就要先找到容器的网络命名空间在哪里，然后做一个软链接即可。</p>
<p>首先查询容器的PID。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@cp:~# docker inspect --format &#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27; web</span><br><span class="line">4775</span><br></pre></td></tr></table></figure>

<p>然后创建软链接，建议指定在 /var/run/netns/ 中的名字，因为每个容器都是net。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root@cp:~# ln -s /proc/4775/ns/net /var/run/netns/web</span><br><span class="line">root@cp:~# ip netns ls</span><br><span class="line">web (id: 0)</span><br><span class="line">test2 (id: 2)</span><br><span class="line">test1 (id: 1)</span><br></pre></td></tr></table></figure>

<p>此时就可以用 ip netns 命令去管理 docker 容器的网络命名空间了。</p>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>netns</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Bridge 详解</title>
    <url>/2022/06/19/Linux-Bridge-%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="Linux-Bridge-详解"><a href="#Linux-Bridge-详解" class="headerlink" title="Linux Bridge 详解"></a><strong>Linux Bridge 详解</strong></h2><p>Linux Bridge（网桥）是用纯软件实现的虚拟交换机，有着和物理交换机相同的功能，例如二层交换，MAC地址学习等。因此我们可以把tun/tap，veth pair等设备绑定到网桥上，就像是把设备连接到物理交换机上一样。此外它和veth pair、tun/tap一样，也是一种虚拟网络设备，具有虚拟设备的所有特性，例如配置IP，MAC地址等。</p>
<span id="more"></span>

<p>Linux Bridge通常是搭配KVM、docker等虚拟化技术一起使用的，用于构建虚拟网络，因为此教程不涉及虚拟化技术，我们就使用前面学习过的netns来模拟虚拟设备。</p>
<h2 id="如何使用Linux-Bridge？"><a href="#如何使用Linux-Bridge？" class="headerlink" title="如何使用Linux Bridge？"></a><strong>如何使用Linux Bridge？</strong></h2><p>操作网桥有多种方式，在这里我们介绍一下通过<strong>bridge-utils</strong>来操作，由于它不是Linux系统自带的工具，因此需要我们手动来安装它。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># centos</span><br><span class="line">yum install -y bridge-utils</span><br><span class="line"># ubuntu</span><br><span class="line">apt-get install -y bridge-utils</span><br></pre></td></tr></table></figure>

<p>使用<code>brctl help</code>查看使用帮助</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">never heard of command [help]</span><br><span class="line">Usage: brctl [commands]</span><br><span class="line">commands:</span><br><span class="line"> addbr      &lt;bridge&gt;  add bridge</span><br><span class="line"> delbr      &lt;bridge&gt;  delete bridge</span><br><span class="line"> addif      &lt;bridge&gt; &lt;device&gt; add interface to bridge</span><br><span class="line"> delif      &lt;bridge&gt; &lt;device&gt; delete interface from bridge</span><br><span class="line"> hairpin    &lt;bridge&gt; &lt;port&gt; &#123;on|off&#125; turn hairpin on/off</span><br><span class="line"> setageing  &lt;bridge&gt; &lt;time&gt;  set ageing time</span><br><span class="line"> setbridgeprio &lt;bridge&gt; &lt;prio&gt;  set bridge priority</span><br><span class="line"> setfd      &lt;bridge&gt; &lt;time&gt;  set bridge forward delay</span><br><span class="line"> sethello   &lt;bridge&gt; &lt;time&gt;  set hello time</span><br><span class="line"> setmaxage  &lt;bridge&gt; &lt;time&gt;  set max message age</span><br><span class="line"> setpathcost &lt;bridge&gt; &lt;port&gt; &lt;cost&gt; set path cost</span><br><span class="line"> setportprio &lt;bridge&gt; &lt;port&gt; &lt;prio&gt; set port priority</span><br><span class="line"> show       [ &lt;bridge&gt; ]  show a list of bridges</span><br><span class="line"> showmacs   &lt;bridge&gt;  show a list of mac addrs</span><br><span class="line"> showstp    &lt;bridge&gt;  show bridge stp info</span><br><span class="line"> stp        &lt;bridge&gt; &#123;on|off&#125; turn stp on/off</span><br></pre></td></tr></table></figure>

<p>常用命令如</p>
<p>新建一个网桥：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brctl addbr &lt;bridge&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>添加一个设备（例如<code>eth0</code>）到网桥：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brctl addif &lt;bridge&gt; eth0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>显示当前存在的网桥及其所连接的网络端口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brctl show</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>启动网桥：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip link set &lt;bridge&gt; up</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>删除网桥，需要先关闭它：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip link set &lt;bridge&gt; down</span><br><span class="line">brctl delbr &lt;bridge&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>或者使用<code>ip link del</code> 命令直接删除网桥</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip link del &lt;bridge&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>增加Linux Bridge时会自动增加一个同名虚拟网卡在宿主机器上，因此我们可以通过<code>ip link</code>命令操作这个虚拟网卡，实际上也就是操作网桥，并且只有当这个虚拟网卡状态处于<strong>up</strong>的时候，网桥才会转发数据。  </p>
</blockquote>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a><strong>实验</strong></h2><p>Linux Bridge最主要的功能就是二层交换，是对现实世界二层交换机的模拟，网络拓扑如下图：</p>
<p><img src="3405a1b5caedb3c915729a35ce3117f963d3d53169d477d00249421f55aa6e70.png" alt="图 1">  </p>
<p>我们建立了一个网桥，三个netns，三对veth pair，分别一端在netns中，另一端连接在网桥上，为了简化拓扑，我去除了netns中的tap设备，将IP直接配置在veth上。</p>
<blockquote>
<p>veth设备不仅仅可以可以充当“网线”，同时它也可以当作虚拟网卡来使用。  </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 添加网桥</span><br><span class="line">brctl addbr br0</span><br><span class="line"># 启动网桥</span><br><span class="line">ip link set br0 up</span><br><span class="line"># 配置网桥ip</span><br><span class="line">ip addr add 10.0.0.1/24 dev br0</span><br><span class="line"></span><br><span class="line"># 新增三个netns</span><br><span class="line">ip netns add ns0</span><br><span class="line">ip netns add ns1</span><br><span class="line">ip netns add ns2</span><br><span class="line"></span><br><span class="line"># 新增两对veth</span><br><span class="line">ip link add veth0-ns type veth peer name veth0-br</span><br><span class="line">ip link add veth1-ns type veth peer name veth1-br</span><br><span class="line">ip link add veth2-ns type veth peer name veth2-br</span><br><span class="line"></span><br><span class="line"># 将veth的一端移动到netns中</span><br><span class="line">ip link set veth0-ns netns ns0</span><br><span class="line">ip link set veth1-ns netns ns1</span><br><span class="line">ip link set veth2-ns netns ns2</span><br><span class="line"></span><br><span class="line"># 将netns中的本地环回和veth启动并配置IP，设置网关为br0地址</span><br><span class="line">ip netns exec ns0 ip link set lo up</span><br><span class="line">ip netns exec ns0 ip link set veth0-ns up</span><br><span class="line">ip netns exec ns0 ip addr add 10.0.0.1/24 dev veth0-ns</span><br><span class="line">ip netns exec ns0 ip route add default via 10.0.0.10</span><br><span class="line"></span><br><span class="line">ip netns exec ns1 ip link set lo up</span><br><span class="line">ip netns exec ns1 ip link set veth1-ns up</span><br><span class="line">ip netns exec ns1 ip addr add 10.0.0.2/24 dev veth1-ns</span><br><span class="line">ip netns exec ns1 ip route add default via 10.0.0.10</span><br><span class="line"></span><br><span class="line">ip netns exec ns2 ip link set lo up</span><br><span class="line">ip netns exec ns2 ip link set veth2-ns up</span><br><span class="line">ip netns exec ns2 ip addr add 10.0.0.3/24 dev veth2-ns</span><br><span class="line">ip netns exec ns2 ip route add default via 10.0.0.10</span><br><span class="line"></span><br><span class="line"># 将veth的另一端启动并挂载到网桥上</span><br><span class="line">ip link set veth0-br up</span><br><span class="line">ip link set veth1-br up</span><br><span class="line">ip link set veth2-br up</span><br><span class="line">brctl addif br0 veth0-br</span><br><span class="line">brctl addif br0 veth1-br</span><br><span class="line">brctl addif br0 veth2-br</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一般linux会把bridge的fowrding禁用，所以还需要进行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iptables -A FORWARD -i br0 -j ACCEPT</span><br></pre></td></tr></table></figure>

<p>测试网络连通性</p>
<p>使用<code>ip netns exec ns0 ping 10.0.0.10</code>在命名空间ns0中测试与网桥br0的10.0.0.10的网络连通性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PING 10.0.0.10 (10.0.0.10) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.0.0.10: icmp_seq=1 ttl=64 time=0.066 ms</span><br><span class="line">64 bytes from 10.0.0.10: icmp_seq=2 ttl=64 time=0.035 ms</span><br><span class="line">64 bytes from 10.0.0.10: icmp_seq=3 ttl=64 time=0.059 ms</span><br><span class="line">64 bytes from 10.0.0.10: icmp_seq=4 ttl=64 time=0.023 ms</span><br><span class="line">64 bytes from 10.0.0.10: icmp_seq=5 ttl=64 time=0.021 ms</span><br><span class="line">^C</span><br><span class="line">--- 10.0.0.10 ping statistics ---</span><br><span class="line">5 packets transmitted, 5 received, 0% packet loss, time 4103ms</span><br><span class="line">rtt min/avg/max/mdev = 0.021/0.040/0.066/0.020 ms</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>使用<code>ip netns exec ns0 ping 10.0.0.2</code>在命名空间ns0中测试与ns1的10.0.0.2的网络连通性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PING 10.0.0.2 (10.0.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.0.0.2: icmp_seq=1 ttl=64 time=0.032 ms</span><br><span class="line">64 bytes from 10.0.0.2: icmp_seq=2 ttl=64 time=0.058 ms</span><br><span class="line">64 bytes from 10.0.0.2: icmp_seq=3 ttl=64 time=0.052 ms</span><br><span class="line">64 bytes from 10.0.0.2: icmp_seq=4 ttl=64 time=0.044 ms</span><br><span class="line">^C</span><br><span class="line">--- 10.0.0.2 ping statistics ---</span><br><span class="line">4 packets transmitted, 4 received, 0% packet loss, time 54ms</span><br><span class="line">rtt min/avg/max/mdev = 0.032/0.046/0.058/0.011 ms</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>Bridge</tag>
      </tags>
  </entry>
  <entry>
    <title>brctl命令简介</title>
    <url>/2022/06/18/brctl%E5%91%BD%E4%BB%A4%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="命令安装"><a href="#命令安装" class="headerlink" title="命令安装"></a>命令安装</h2><p>Centos系统</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install bridge-utils</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>Ubuntu系统</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apt-get  install bridge-utils</span><br></pre></td></tr></table></figure>

<h2 id="命令介绍"><a href="#命令介绍" class="headerlink" title="命令介绍"></a>命令介绍</h2><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>addbr <code>&lt;bridge&gt;</code></td>
<td>创建网桥</td>
<td>brctl addbr br10</td>
</tr>
<tr>
<td>delbr <code>&lt;bridge&gt;</code></td>
<td>删除网桥</td>
<td>brctl delbr br10</td>
</tr>
<tr>
<td>addif <code>&lt;bridge&gt;</code> <code>&lt;device&gt;</code></td>
<td>将网卡接口接入网桥</td>
<td>brctl addif br10 eth0</td>
</tr>
<tr>
<td>delif <code>&lt;bridge&gt;</code> <code>&lt;device&gt;</code></td>
<td>删除网桥接入的网卡接口</td>
<td>brctl delif br10 eth0</td>
</tr>
<tr>
<td>show <code>&lt;bridge&gt;</code></td>
<td>查询网桥信息</td>
<td>brctl show br10</td>
</tr>
<tr>
<td>stp <code>&lt;bridge&gt;</code> <code>&#123;on\off&#125;</code></td>
<td>启用禁用 STP</td>
<td>brctl stp br10 off/on</td>
</tr>
<tr>
<td>showstp <code>&lt;bridge&gt;</code></td>
<td>查看网桥 STP 信息</td>
<td>brctl showstp br10</td>
</tr>
<tr>
<td>setfd <code>&lt;bridge&gt;</code> <code>&lt;time&gt;</code></td>
<td>设置网桥延迟</td>
<td>brctl setfd br10 10</td>
</tr>
<tr>
<td>showmacs <code>&lt;bridge&gt;</code></td>
<td>查看 mac 信息</td>
<td>brctl showmacs br10</td>
</tr>
</tbody></table>
<h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>添加网桥 <code>br0</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brctl addbr br0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>设置<code>br0</code>可用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifconfig br0 192.168.100.1 netmask 255.255.255.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>显示所有的网桥信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brctl show</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>显示网桥<code>br0</code>的信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brctl show br0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="brctl常用命令"><a href="#brctl常用命令" class="headerlink" title="brctl常用命令"></a>brctl常用命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brctl addbr br1             #创建网桥</span><br><span class="line">brctl addif br1 enp4s0      #为网桥添加物理接口</span><br><span class="line">brctl delbr br1             #删除网桥</span><br><span class="line">brctl delif br1 enp4s0      #删除网桥接口</span><br><span class="line">brctl show                  #显示网桥列表信息</span><br><span class="line">brctl show br1              #显示网桥br1的信息</span><br><span class="line">brctl showmacs br1          #显示网桥的MAC地址信息</span><br><span class="line">brctl showstp br1           #显示网桥的stp信息</span><br><span class="line">brctl stp br-test on|off    #开|关stp</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>brctl命令范式，可以通过对应英文参数，执行需要的命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# brctl</span><br><span class="line">Usage: brctl [commands]</span><br><span class="line">commands:</span><br><span class="line">        addbr           &lt;bridge&gt;                add bridge</span><br><span class="line">        delbr           &lt;bridge&gt;                delete bridge</span><br><span class="line">        addif           &lt;bridge&gt; &lt;device&gt;       add interface to bridge</span><br><span class="line">        delif           &lt;bridge&gt; &lt;device&gt;       delete interface from bridge</span><br><span class="line">        hairpin         &lt;bridge&gt; &lt;port&gt; &#123;on|off&#125;        turn hairpin on/off</span><br><span class="line">        setageing       &lt;bridge&gt; &lt;time&gt;         set ageing time</span><br><span class="line">        setbridgeprio   &lt;bridge&gt; &lt;prio&gt;         set bridge priority</span><br><span class="line">        setfd           &lt;bridge&gt; &lt;time&gt;         set bridge forward delay</span><br><span class="line">        sethello        &lt;bridge&gt; &lt;time&gt;         set hello time</span><br><span class="line">        setmaxage       &lt;bridge&gt; &lt;time&gt;         set max message age</span><br><span class="line">        setpathcost     &lt;bridge&gt; &lt;port&gt; &lt;cost&gt;  set path cost</span><br><span class="line">        setportprio     &lt;bridge&gt; &lt;port&gt; &lt;prio&gt;  set port priority</span><br><span class="line">        show            [ &lt;bridge&gt; ]            show a list of bridges</span><br><span class="line">        showmacs        &lt;bridge&gt;                show a list of mac addrs</span><br><span class="line">        showstp         &lt;bridge&gt;                show bridge stp info</span><br><span class="line">        stp             &lt;bridge&gt; &#123;on|off&#125;       turn stp on/off</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>brctl场景使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brctl addbr bridge</span><br><span class="line">brctl addif bridge eth0</span><br><span class="line">brctl addif bridge ath0</span><br><span class="line">ifconfig eth0 0.0.0.0</span><br><span class="line">// 将有线和无线都设置为192.168.1.*网段，即可通过网上邻居进行访问</span><br><span class="line">ifconfig bridge 192.168.1.0 netmask 255.255.255.0 up</span><br><span class="line">// 添加iptables -t nat -A POSTROUTING -o ath0 -j SNAT --to 192.168.2.173</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>brctl</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Namespace</title>
    <url>/2022/06/17/Linux-Namespace/</url>
    <content><![CDATA[<p><code>Linux Namespace</code> 是 Linux 提供的一种内核级别环境隔离的方法。</p>
<span id="more"></span>

<p>Linux Namespace 将全局系统资源封装在一个抽象中，从而使 namespace 内的进程认为自己具有独立的资源实例。这项技术本来没有掀起多大的波澜，是容器技术的崛起让他重新引起了大家的注意。</p>
<p>Linux Namespace 有如下 6 个种类：</p>
<table>
<thead>
<tr>
<th><strong>分类</strong></th>
<th><strong>系统调用参数</strong></th>
<th><strong>相关内核版本</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Mount namespaces</td>
<td>CLONE_NEWNS</td>
<td><a href="http://lwn.net/2001/0301/a/namespaces.php3">Linux 2.4.19</a></td>
</tr>
<tr>
<td>UTS namespaces</td>
<td>CLONE_NEWUTS</td>
<td><a href="http://lwn.net/Articles/179345/">Linux 2.6.19</a></td>
</tr>
<tr>
<td>IPC namespaces</td>
<td>CLONE_NEWIPC</td>
<td><a href="http://lwn.net/Articles/187274/">Linux 2.6.19</a></td>
</tr>
<tr>
<td>PID namespaces</td>
<td>CLONE_NEWPID</td>
<td><a href="http://lwn.net/Articles/259217/">Linux 2.6.24</a></td>
</tr>
<tr>
<td>Network namespaces</td>
<td>CLONE_NEWNET</td>
<td><a href="http://lwn.net/Articles/219794/">始于Linux 2.6.24 完成于 Linux 2.6.29</a></td>
</tr>
<tr>
<td>User namespaces</td>
<td>CLONE_NEWUSER</td>
<td><a href="http://lwn.net/Articles/528078/">始于 Linux 2.6.23 完成于 Linux 3.8</a></td>
</tr>
</tbody></table>
<p>namespace 的 API 由三个系统调用和一系列 <code>/proc</code> 文件组成，本文将会详细介绍这些系统调用和 <code>/proc</code> 文件。为了指定要操作的 namespace 类型，需要在系统调用的 flag 中通过常量 <code>CLONE_NEW*</code> 指定（包括 <code>CLONE_NEWIPC</code>，<code>CLONE_NEWNS</code>， <code>CLONE_NEWNET</code>，<code>CLONE_NEWPID</code>，<code>CLONE_NEWUSER</code> 和 <code>CLONE_NEWUTS</code>），可以指定多个常量，通过 **|**（位或）操作来实现。</p>
<p>简单描述一下三个系统调用的功能：</p>
<ul>
<li>  <strong>clone()</strong> : 实现线程的系统调用，用来创建一个新的进程，并可以通过设计上述系统调用参数达到隔离的目的。</li>
<li>  <strong>unshare()</strong> : 使某进程脱离某个 namespace。</li>
<li>  <strong>setns()</strong> : 把某进程加入到某个 namespace。</li>
</ul>
<p>具体的实现原理请往下看。</p>
<h2 id="1-clone"><a href="#1-clone" class="headerlink" title="1. clone()"></a>1. clone()</h2><hr>
<p><code>clone()</code> 的原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int clone(int (*child_func)(void *), void *child_stack, int flags, void *arg);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  <strong>child_func</strong> : 传入子进程运行的程序主函数。</li>
<li>  <strong>child_stack</strong> : 传入子进程使用的栈空间。</li>
<li>  <strong>flags</strong> : 表示使用哪些 <code>CLONE_*</code> 标志位。</li>
<li>  <strong>args</strong> : 用于传入用户参数。</li>
</ul>
<p><code>clone()</code> 与 <code>fork()</code> 类似，都相当于把当前进程复制了一份，但 <code>clone()</code> 可以更细粒度地控制与子进程共享的资源（其实就是通过 flags 来控制），包括虚拟内存、打开的文件描述符和信号量等等。一旦指定了标志位 <code>CLONE_NEW*</code>，相对应类型的 namespace 就会被创建，新创建的进程也会成为该 namespace 中的一员。</p>
<p>clone() 的原型并不是最底层的系统调用，而是封装过的，真正的系统调用内核实现函数为 <code>do_fork()</code>，形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">long do_fork(unsigned long clone_flags,</span><br><span class="line">	      unsigned long stack_start,</span><br><span class="line">	      unsigned long stack_size,</span><br><span class="line">	      int __user *parent_tidptr,</span><br><span class="line">	      int __user *child_tidptr)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中 <code>clone_flags</code> 可以赋值为上面提到的标志。</p>
<p>下面来看一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* demo_uts_namespaces.c</span><br><span class="line">   Copyright 2013, Michael Kerrisk   Licensed under GNU General Public License v2 or later</span><br><span class="line">   Demonstrate the operation of UTS namespaces.</span><br><span class="line">*/</span><br><span class="line">#define _GNU_SOURCE</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;sys/utsname.h&gt;</span><br><span class="line">#include &lt;sched.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">/* A simple error-handling function: print an error message based</span><br><span class="line">   on the value in &#x27;errno&#x27; and terminate the calling process */</span><br><span class="line">#define errExit(msg)                \</span><br><span class="line">	do                          \</span><br><span class="line">	&#123;                           \</span><br><span class="line">		perror(msg);        \</span><br><span class="line">		exit(EXIT_FAILURE); \</span><br><span class="line">	&#125; while (0)</span><br><span class="line">static int /* Start function for cloned child */</span><br><span class="line">childFunc(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">	struct utsname uts;</span><br><span class="line">	/* 在新的 UTS namespace 中修改主机名 */</span><br><span class="line">	if (sethostname(arg, strlen(arg)) == -1)</span><br><span class="line">		errExit(&quot;sethostname&quot;);</span><br><span class="line">	/* 获取并显示主机名 */</span><br><span class="line">	if (uname(&amp;uts) == -1)</span><br><span class="line">		errExit(&quot;uname&quot;);</span><br><span class="line">	printf(&quot;uts.nodename in child:  %s\n&quot;, uts.nodename);</span><br><span class="line">	/* Keep the namespace open for a while, by sleeping.       This allows some experimentation--for example, another       process might join the namespace. */</span><br><span class="line">	sleep(100);</span><br><span class="line">	return 0; /* Terminates child */</span><br><span class="line">&#125;</span><br><span class="line">/* 定义一个给 clone 用的栈，栈大小1M */</span><br><span class="line">#define STACK_SIZE (1024 * 1024)</span><br><span class="line">static char child_stack[STACK_SIZE];</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	pid_t child_pid;</span><br><span class="line">	struct utsname uts;</span><br><span class="line">	if (argc &lt; 2)</span><br><span class="line">	&#123;</span><br><span class="line">		fprintf(stderr, &quot;Usage: %s &lt;child-hostname&gt;\n&quot;, argv[0]);</span><br><span class="line">		exit(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	/* 调用 clone 函数创建一个新的 UTS namespace，其中传出一个函数，还有一个栈空间（为什么传尾指针，因为栈是反着的）;       新的进程将在用户定义的函数 childFunc() 中执行 */</span><br><span class="line">	child_pid = clone(childFunc, child_stack + STACK_SIZE, CLONE_NEWUTS | SIGCHLD, argv[1]);</span><br><span class="line">	if (child_pid == -1)</span><br><span class="line">		errExit(&quot;clone&quot;);</span><br><span class="line">	printf(&quot;PID of child created by clone() is %ld\n&quot;, (long)child_pid);</span><br><span class="line">	/* Parent falls through to here */</span><br><span class="line">	sleep(1); /* 给子进程预留一定的时间来改变主机名 */</span><br><span class="line">	/* 显示当前 UTS namespace 中的主机名，和       子进程所在的 UTS namespace 中的主机名不同 */</span><br><span class="line">	if (uname(&amp;uts) == -1)</span><br><span class="line">		errExit(&quot;uname&quot;);</span><br><span class="line">	printf(&quot;uts.nodename in parent: %s\n&quot;, uts.nodename);</span><br><span class="line">	if (waitpid(child_pid, NULL, 0) == -1) /* 等待子进程结束 */</span><br><span class="line">		errExit(&quot;waitpid&quot;);</span><br><span class="line">	printf(&quot;child has terminated\n&quot;);</span><br><span class="line">	exit(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该程序通过标志位 <code>CLONE_NEWUTS</code> 调用 <code>clone()</code> 函数创建一个 UTS namespace。UTS namespace 隔离了两个系统标识符 — <strong>主机名</strong>和 <strong>NIS 域名</strong> —它们分别通过 <code>sethostname()</code> 和 <code>setdomainname()</code> 这两个系统调用来设置，并通过系统调用 <code>uname()</code> 来获取。</p>
<p>下面将对程序中的一些关键部分进行解读（为了简单起见，我们将省略其中的错误检查）。</p>
<p>程序运行时后面需要跟上一个命令行参数，它将会创建一个在新的 UTS namespace 中执行的子进程，该子进程会在新的 UTS namespace 中将主机名改为命令行参数中提供的值。</p>
<p>主程序的第一个关键部分是通过系统调用 <code>clone()</code> 来创建子进程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">child_pid = clone(childFunc, </span><br><span class="line">                  child_stack + STACK_SIZE,   /* Points to start of                                                 downwardly growing stack */                  CLONE_NEWUTS | SIGCHLD, argv[1]);</span><br><span class="line">printf(&quot;PID of child created by clone() is %ld\n&quot;, (long) child_pid);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>子进程将会在用户定义的函数 <code>childFunc()</code> 中开始执行，该函数将会接收 <code>clone()</code> 最后的参数（argv[1]）作为自己的参数，并且标志位包含了 <code>CLONE_NEWUTS</code>，所以子进程会在新创建的 UTS namespace 中执行。</p>
<p>接下来主进程睡眠一段时间，让子进程能够有时间更改其 UTS namespace 中的主机名。然后调用 <code>uname()</code> 来检索当前 UTS namespace 中的主机名，并显示该主机名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sleep(1);           /* Give child time to change its hostname */</span><br><span class="line">uname(&amp;uts);</span><br><span class="line">printf(&quot;uts.nodename in parent: %s\n&quot;, uts.nodename);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>与此同时，由 <code>clone()</code> 创建的子进程执行的函数 <code>childFunc()</code> 首先将主机名改为命令行参数中提供的值，然后检索并显示修改后的主机名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sethostname(arg, strlen(arg);</span><br><span class="line">    </span><br><span class="line">uname(&amp;uts);</span><br><span class="line">printf(&quot;uts.nodename in child:  %s\n&quot;, uts.nodename);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>子进程退出之前也睡眠了一段时间，这样可以防止新的 UTS namespace 不会被关闭，让我们能够有机会进行后续的实验。</p>
<p>执行程序，观察父进程和子进程是否处于不同的 UTS namespace 中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ su                   # 需要特权才能创建 UTS namespace</span><br><span class="line">Password: </span><br><span class="line"># uname -n</span><br><span class="line">antero</span><br><span class="line"># ./demo_uts_namespaces bizarro</span><br><span class="line">PID of child created by clone() is 27514</span><br><span class="line">uts.nodename in child:  bizarro</span><br><span class="line">uts.nodename in parent: antero</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除了 User namespace 之外，创建其他的 namespace 都需要特权，更确切地说，是需要相应的 <code>Linux Capabilities</code>，即 <code>CAP_SYS_ADMIN</code>。这样就可以避免设置了 SUID（Set User ID on execution）的程序因为主机名不同而做出一些愚蠢的行为。</p>
<h2 id="2-proc-文件"><a href="#2-proc-文件" class="headerlink" title="2. proc 文件"></a>2. proc 文件</h2><hr>
<p>每个进程都有一个 <code>/proc/PID/ns</code> 目录，其下面的文件依次表示每个 namespace, 例如 user 就表示 user namespace。从 3.8 版本的内核开始，该目录下的每个文件都是一个特殊的符号链接，链接指向 <code>$namespace:[$namespace-inode-number]</code>，前半部份为 namespace 的名称，后半部份的数字表示这个 namespace 的句柄号。句柄号用来对进程所关联的 namespace 执行某些操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ls -l /proc/$$/ns         # $$ 表示当前所在的 shell 的 PID</span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx. 1 mtk mtk 0 Jan  8 04:12 ipc -&gt; ipc:[4026531839]</span><br><span class="line">lrwxrwxrwx. 1 mtk mtk 0 Jan  8 04:12 mnt -&gt; mnt:[4026531840]</span><br><span class="line">lrwxrwxrwx. 1 mtk mtk 0 Jan  8 04:12 net -&gt; net:[4026531956]</span><br><span class="line">lrwxrwxrwx. 1 mtk mtk 0 Jan  8 04:12 pid -&gt; pid:[4026531836]</span><br><span class="line">lrwxrwxrwx. 1 mtk mtk 0 Jan  8 04:12 user -&gt; user:[4026531837]</span><br><span class="line">lrwxrwxrwx. 1 mtk mtk 0 Jan  8 04:12 uts -&gt; uts:[4026531838]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这些符号链接的用途之一是用来<strong>确认两个不同的进程是否处于同一 namespace 中</strong>。如果两个进程指向的 namespace inode number 相同，就说明他们在同一个 namespace 下，否则就在不同的 namespace 下。这些符号链接指向的文件比较特殊，不能直接访问，事实上指向的文件存放在被称为 <code>nsfs</code> 的文件系统中，该文件系统用户不可见，可以使用系统调用 <a href="http://man7.org/linux/man-pages/man2/stat.2.html">stat()</a> 在返回的结构体的 <code>st_ino</code> 字段中获取 inode number。在 shell 终端中可以用命令（实际上就是调用了 stat()）看到指向文件的 inode 信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ stat -L /proc/$$/ns/net</span><br><span class="line">  File: /proc/3232/ns/net  Size: 0         	Blocks: 0          IO Block: 4096   regular empty file</span><br><span class="line">Device: 4h/4d	Inode: 4026531956  Links: 1</span><br><span class="line">Access: (0444/-r--r--r--)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2020-01-17 15:45:23.783304900 +0800</span><br><span class="line">Modify: 2020-01-17 15:45:23.783304900 +0800</span><br><span class="line">Change: 2020-01-17 15:45:23.783304900 +0800</span><br><span class="line"> Birth: -</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除了上述用途之外，这些符号链接还有其他的用途，<strong>如果我们打开了其中一个文件，那么只要与该文件相关联的文件描述符处于打开状态，即使该 namespace 中的所有进程都终止了，该 namespace 依然不会被删除</strong>。通过 bind mount 将符号链接挂载到系统的其他位置，也可以获得相同的效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ touch ~/uts</span><br><span class="line">$ mount --bind /proc/27514/ns/uts ~/uts</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-setns"><a href="#3-setns" class="headerlink" title="3. setns()"></a>3. setns()</h2><hr>
<p>加入一个已经存在的 namespace 可以通过系统调用 <code>setns()</code> 来完成。它的原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int setns(int fd, int nstype);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>更确切的说法是：<code>setns()</code> 将调用的进程与特定类型 namespace 的一个实例分离，并将该进程与该类型 namespace 的另一个实例重新关联。</p>
<ul>
<li>  <code>fd</code> 表示要加入的 namespace 的文件描述符，可以通过打开其中一个符号链接来获取，也可以通过打开 bind mount 到其中一个链接的文件来获取。</li>
<li>  <code>nstype</code> 让调用者可以去检查 fd 指向的 namespace 类型，值可以设置为前文提到的常量 <code>CLONE_NEW*</code>，填 <code>0</code> 表示不检查。如果调用者已经明确知道自己要加入了 namespace 类型，或者不关心 namespace 类型，就可以使用该参数来自动校验。</li>
</ul>
<p>结合 <code>setns()</code> 和 <code>execve()</code> 可以实现一个简单但非常有用的功能：将某个进程加入某个特定的 namespace，然后在该 namespace 中执行命令。直接来看例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* ns_exec.c</span><br><span class="line">   Copyright 2013, Michael Kerrisk   Licensed under GNU General Public License v2 or later</span><br><span class="line">   Join a namespace and execute a command in the namespace</span><br><span class="line">*/</span><br><span class="line">#define _GNU_SOURCE</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sched.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">/* A simple error-handling function: print an error message based</span><br><span class="line">   on the value in &#x27;errno&#x27; and terminate the calling process */</span><br><span class="line">#define errExit(msg)                \</span><br><span class="line">	do                          \</span><br><span class="line">	&#123;                           \</span><br><span class="line">		perror(msg);        \</span><br><span class="line">		exit(EXIT_FAILURE); \</span><br><span class="line">	&#125; while (0)</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	int fd;</span><br><span class="line">	if (argc &lt; 3)</span><br><span class="line">	&#123;</span><br><span class="line">		fprintf(stderr, &quot;%s /proc/PID/ns/FILE cmd [arg...]\n&quot;, argv[0]);</span><br><span class="line">		exit(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	fd = open(argv[1], O_RDONLY); /* 获取想要加入的 namespace 的文件描述符 */</span><br><span class="line">	if (fd == -1)</span><br><span class="line">		errExit(&quot;open&quot;);</span><br><span class="line">	if (setns(fd, 0) == -1) /* 加入该 namespace */</span><br><span class="line">		errExit(&quot;setns&quot;);</span><br><span class="line">	execvp(argv[2], &amp;argv[2]); /* 在加入的 namespace 中执行相应的命令 */</span><br><span class="line">	errExit(&quot;execvp&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该程序运行需要两个或两个以上的命令行参数，第一个参数表示特定的 namespace 符号链接的路径（或者 bind mount 到这些符号链接的文件路径）；第二个参数表示要在该符号链接相对应的 namespace 中执行的程序名称，以及执行这个程序所需的命令行参数。关键步骤如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fd = open(argv[1], O_RDONLY);   /* 获取想要加入的 namespace 的文件描述符 */</span><br><span class="line">setns(fd, 0);                   /* 加入该 namespace */</span><br><span class="line">execvp(argv[2], &amp;argv[2]);      /* 在加入的 namespace 中执行相应的命令 */</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>还记得我们之前已经通过 bind mount 将 <code>demo_uts_namespaces</code> 创建的 UTS namespace 挂载到 <code>~/uts</code> 中了吗？可以将本例中的程序与之结合，让新进程可以在该 UTS namespace 中执行 shell：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./ns_exec ~/uts /bin/bash     # ~/uts 被 bind mount 到了 /proc/27514/ns/uts    My PID is: 28788</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>验证新的 shell 是否与 <code>demo_uts_namespaces</code> 创建的子进程处于同一个 UTS namespace：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hostname</span><br><span class="line">bizarro</span><br><span class="line">$ readlink /proc/27514/ns/uts</span><br><span class="line">uts:[4026532338]</span><br><span class="line">$ readlink /proc/$$/ns/uts      # $$ 表示当前 shell 的 PID</span><br><span class="line">uts:[4026532338]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在早期的内核版本中，不能使用 <code>setns()</code> 来加入 mount namespace、PID namespace 和 user namespace，从 3.8 版本的内核开始，<code>setns()</code> 支持加入所有的 namespace。</p>
<p>util-linux 包里提供了<code>nsenter</code> 命令，其提供了一种方式将新创建的进程运行在指定的 namespace 里面，它的实现很简单，就是通过命令行（-t 参数）指定要进入的 namespace 的符号链接，然后利用 <code>setns()</code> 将当前的进程放到指定的 namespace 里面，再调用 <code>clone()</code> 运行指定的执行文件。我们可以用 <code>strace</code> 来看看它的运行情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># strace nsenter -t 27242 -i -m -n -p -u /bin/bash</span><br><span class="line">execve(&quot;/usr/bin/nsenter&quot;, [&quot;nsenter&quot;, &quot;-t&quot;, &quot;27242&quot;, &quot;-i&quot;, &quot;-m&quot;, &quot;-n&quot;, &quot;-p&quot;, &quot;-u&quot;, &quot;/bin/bash&quot;], [/* 21 vars */]) = 0</span><br><span class="line">…………</span><br><span class="line">…………</span><br><span class="line">open(&quot;/proc/27242/ns/ipc&quot;, O_RDONLY)    = 3</span><br><span class="line">open(&quot;/proc/27242/ns/uts&quot;, O_RDONLY)    = 4</span><br><span class="line">open(&quot;/proc/27242/ns/net&quot;, O_RDONLY)    = 5</span><br><span class="line">open(&quot;/proc/27242/ns/pid&quot;, O_RDONLY)    = 6</span><br><span class="line">open(&quot;/proc/27242/ns/mnt&quot;, O_RDONLY)    = 7</span><br><span class="line">setns(3, CLONE_NEWIPC)                  = 0</span><br><span class="line">close(3)                                = 0</span><br><span class="line">setns(4, CLONE_NEWUTS)                  = 0</span><br><span class="line">close(4)                                = 0</span><br><span class="line">setns(5, CLONE_NEWNET)                  = 0</span><br><span class="line">close(5)                                = 0</span><br><span class="line">setns(6, CLONE_NEWPID)                  = 0</span><br><span class="line">close(6)                                = 0</span><br><span class="line">setns(7, CLONE_NEWNS)                   = 0</span><br><span class="line">close(7)                                = 0</span><br><span class="line">clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f4deb1faad0) = 4968</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-unshare"><a href="#4-unshare" class="headerlink" title="4. unshare()"></a>4. unshare()</h2><hr>
<p>最后一个要介绍的系统调用是 <code>unshare()</code>，它的原型如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int unshare(int flags);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>unshare()</code> 与 <code>clone()</code> 类似，但它运行在原先的进程上，不需要创建一个新进程，即：先通过指定的 flags 参数 <code>CLONE_NEW*</code> 创建一个新的 namespace，然后将调用者加入该 namespace。最后实现的效果其实就是将调用者从当前的 namespace 分离，然后加入一个新的 namespace。</p>
<p>Linux 中自带的 <code>unshare</code> 命令，就是通过 unshare() 系统调用实现的，使用方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ unshare [options] program [arguments]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>options</code> 指定要创建的 namespace 类型。</p>
<p>unshare 命令的主要实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* 通过提供的命令行参数初始化 &#x27;flags&#x27; */</span><br><span class="line">unshare(flags);</span><br><span class="line">/* Now execute &#x27;program&#x27; with &#x27;arguments&#x27;; &#x27;optind&#x27; is the index</span><br><span class="line">   of the next command-line argument after options */</span><br><span class="line">execvp(argv[optind], &amp;argv[optind]);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>unshare 命令的完整实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* unshare.c</span><br><span class="line">   Copyright 2013, Michael Kerrisk   Licensed under GNU General Public License v2 or later</span><br><span class="line">   A simple implementation of the unshare(1) command: unshare   namespaces and execute a command.</span><br><span class="line">*/</span><br><span class="line">#define _GNU_SOURCE</span><br><span class="line">#include &lt;sched.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">/* A simple error-handling function: print an error message based</span><br><span class="line">   on the value in &#x27;errno&#x27; and terminate the calling process */</span><br><span class="line">#define errExit(msg)                \</span><br><span class="line">	do                          \</span><br><span class="line">	&#123;                           \</span><br><span class="line">		perror(msg);        \</span><br><span class="line">		exit(EXIT_FAILURE); \</span><br><span class="line">	&#125; while (0)</span><br><span class="line">static void</span><br><span class="line">usage(char *pname)</span><br><span class="line">&#123;</span><br><span class="line">	fprintf(stderr, &quot;Usage: %s [options] program [arg...]\n&quot;, pname);</span><br><span class="line">	fprintf(stderr, &quot;Options can be:\n&quot;);</span><br><span class="line">	fprintf(stderr, &quot;    -i   unshare IPC namespace\n&quot;);</span><br><span class="line">	fprintf(stderr, &quot;    -m   unshare mount namespace\n&quot;);</span><br><span class="line">	fprintf(stderr, &quot;    -n   unshare network namespace\n&quot;);</span><br><span class="line">	fprintf(stderr, &quot;    -p   unshare PID namespace\n&quot;);</span><br><span class="line">	fprintf(stderr, &quot;    -u   unshare UTS namespace\n&quot;);</span><br><span class="line">	fprintf(stderr, &quot;    -U   unshare user namespace\n&quot;);</span><br><span class="line">	exit(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">	int flags, opt;</span><br><span class="line">	flags = 0;</span><br><span class="line">	while ((opt = getopt(argc, argv, &quot;imnpuU&quot;)) != -1)</span><br><span class="line">	&#123;</span><br><span class="line">		switch (opt)</span><br><span class="line">		&#123;</span><br><span class="line">		case &#x27;i&#x27;:</span><br><span class="line">			flags |= CLONE_NEWIPC;</span><br><span class="line">			break;</span><br><span class="line">		case &#x27;m&#x27;:</span><br><span class="line">			flags |= CLONE_NEWNS;</span><br><span class="line">			break;</span><br><span class="line">		case &#x27;n&#x27;:</span><br><span class="line">			flags |= CLONE_NEWNET;</span><br><span class="line">			break;</span><br><span class="line">		case &#x27;p&#x27;:</span><br><span class="line">			flags |= CLONE_NEWPID;</span><br><span class="line">			break;</span><br><span class="line">		case &#x27;u&#x27;:</span><br><span class="line">			flags |= CLONE_NEWUTS;</span><br><span class="line">			break;</span><br><span class="line">		case &#x27;U&#x27;:</span><br><span class="line">			flags |= CLONE_NEWUSER;</span><br><span class="line">			break;</span><br><span class="line">		default:</span><br><span class="line">			usage(argv[0]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (optind &gt;= argc)</span><br><span class="line">		usage(argv[0]);</span><br><span class="line">	if (unshare(flags) == -1)</span><br><span class="line">		errExit(&quot;unshare&quot;);</span><br><span class="line">	execvp(argv[optind], &amp;argv[optind]);</span><br><span class="line">	errExit(&quot;execvp&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下面我们执行 <code>unshare.c</code> 程序在一个新的 mount namespace 中执行 shell：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ echo $$                             # 显示当前 shell 的 PID</span><br><span class="line">8490</span><br><span class="line">$ cat /proc/8490/mounts | grep mq     # 显示当前 namespace 中的某个挂载点</span><br><span class="line">mqueue /dev/mqueue mqueue rw,seclabel,relatime 0 0</span><br><span class="line">$ readlink /proc/8490/ns/mnt          # 显示当前 namespace 的 ID </span><br><span class="line">mnt:[4026531840]</span><br><span class="line">$ ./unshare -m /bin/bash              # 在新创建的 mount namespace 中执行新的 shell</span><br><span class="line">$ readlink /proc/$$/ns/mnt            # 显示新 namespace 的 ID </span><br><span class="line">mnt:[4026532325]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对比两个 <code>readlink</code> 命令的输出，可以知道两个shell 处于不同的 mount namespace 中。改变新的 namespace 中的某个挂载点，然后观察两个 namespace 的挂载点是否有变化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ umount /dev/mqueue                  # 移除新 namespace 中的挂载点</span><br><span class="line">$ cat /proc/$$/mounts | grep mq       # 检查是否生效</span><br><span class="line">$ cat /proc/8490/mounts | grep mq     # 查看原来的 namespace 中的挂载点是否依然存在?</span><br><span class="line">mqueue /dev/mqueue mqueue rw,seclabel,relatime 0 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看出，新的 namespace 中的挂载点 <code>/dev/mqueue</code> 已经消失了，但在原来的 namespace 中依然存在。</p>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>Namespace</tag>
      </tags>
  </entry>
  <entry>
    <title>docker网络模式</title>
    <url>/2022/06/16/docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="Docker的4种网络模式"><a href="#Docker的4种网络模式" class="headerlink" title="Docker的4种网络模式"></a>Docker的4种网络模式</h1><p><strong>简介：</strong> 我们在使用docker run创建Docker容器时，可以用–net选项指定容器的网络模式，Docker有以下4种网络模式：</p>
<span id="more"></span>

<p><strong>· host模式，使用–net=host指定。</strong></p>
<p><strong>· container模式，使用–net=container:NAME_or_ID指定。</strong></p>
<p><strong>· none模式，使用–net=none指定。</strong></p>
<p><strong>· bridge模式，使用–net=bridge指定，默认设置。</strong></p>
<p>下面分别介绍一下Docker的各个网络模式。</p>
<h4 id="1-host模式"><a href="#1-host模式" class="headerlink" title="1 host模式"></a><strong>1 host模式</strong></h4><p>众所周知，Docker使用了Linux的Namespaces技术来进行资源隔离，如PID Namespace隔离进程，Mount Namespace隔离文件系统，Network Namespace隔离网络等。一个Network Namespace提供了一份独立的网络环境，包括网卡、路由、Iptable规则等都与其他的Network Namespace隔离。一个Docker容器一般会分配一个独立的Network Namespace。但如果启动容器的时候使用host模式，那么这个容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。</p>
<p>例如，我们在10.10.101.105/24的机器上用host模式启动一个含有web应用的Docker容器，监听tcp80端口。当我们在容器中执行任何类似ifconfig命令查看网络环境时，看到的都是宿主机上的信息。而外界访问容器中的应用，则直接使用10.10.101.105:80即可，不用任何NAT转换，就如直接跑在宿主机中一样。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。</p>
<h4 id="2-container模式"><a href="#2-container模式" class="headerlink" title="2 container模式"></a><strong>2 container模式</strong></h4><p>在理解了host模式后，这个模式也就好理解了。这个模式指定新创建的容器和已经存在的一个容器共享一个Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过lo网卡设备通信。</p>
<h4 id="3-none模式"><a href="#3-none模式" class="headerlink" title="3 none模式"></a><strong>3 none模式</strong></h4><p>这个模式和前两个不同。在这种模式下，Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。也就是说，这个Docker容器没有网卡、IP、路由等信息。需要我们自己为Docker容器添加网卡、配置IP等。</p>
<h4 id="4-bridge模式"><a href="#4-bridge模式" class="headerlink" title="4 bridge模式"></a><strong>4 bridge模式</strong></h4><p>bridge模式是Docker默认的网络设置，此模式会为每一个容器分配Network Namespace、设置IP等，并将一个主机上的Docker容器连接到一个虚拟网桥上。下面着重介绍一下此模式。</p>
<p><strong>4.1 bridge模式的拓扑</strong></p>
<p>当Docker server启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。接下来就要为容器分配IP了，Docker会从<a href="http://tools.ietf.org/html/rfc1918">RFC1918</a>所定义的私有IP网段中，选择一个和宿主机不同的IP地址和子网分配给docker0，连接到docker0的容器就从这个子网中选择一个未占用的IP使用。如一般Docker会使用172.17.0.0/16这个网段，并将172.17.42.1/16分配给docker0网桥（在主机上使用ifconfig命令是可以看到docker0的，可以认为它是网桥的管理接口，在宿主机上作为一块虚拟网卡使用）。单机环境下的网络拓扑如下，主机地址为10.10.101.105/24。</p>
<p><img src="https://yqfile.alicdn.com/img_ff6a606bb0be72d2c8bdac3af6c59c9e.png" alt="img_ff6a606bb0be72d2c8bdac3af6c59c9e.png"></p>
<p><img src="https://yqfile.alicdn.com/img_1f765a12343e70cb02c5366ffe1a65e7.jpeg" alt="img_1f765a12343e70cb02c5366ffe1a65e7.jpe"></p>
<p>Docker完成以上网络配置的过程大致是这样的：</p>
<p>1. 在主机上创建一对虚拟网卡veth pair设备。veth设备总是成对出现的，它们组成了一个数据的通道，数据从一个设备进入，就会从另一个设备出来。因此，veth设备常用来连接两个网络设备。</p>
<p>2. Docker将veth pair设备的一端放在新创建的容器中，并命名为eth0。另一端放在主机中，以veth65f9这样类似的名字命名，并将这个网络设备加入到docker0网桥中，可以通过brctl show命令查看。</p>
<p><img src="https://yqfile.alicdn.com/img_6c4a085a0c8704475e0704c541a78dc4.png" alt="img_6c4a085a0c8704475e0704c541a78dc4.png"></p>
<p>3. 从docker0子网中分配一个IP给容器使用，并设置docker0的IP地址为容器的默认网关。</p>
<p>网络拓扑介绍完后，接着介绍一下bridge模式下容器是如何通信的。</p>
<p><strong>4.2 bridge模式下容器的通信</strong></p>
<p>在bridge模式下，连在同一网桥上的容器可以相互通信（若出于安全考虑，也可以禁止它们之间通信，方法是在DOCKER_OPTS变量中设置–icc=false，这样只有使用–link才能使两个容器通信）。</p>
<p>容器也可以与外部通信，我们看一下主机上的Iptable规则，可以看到这么一条</p>
<p>-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE</p>
<p>这条规则会将源地址为172.17.0.0/16的包（也就是从Docker容器产生的包），并且不是从docker0网卡发出的，进行源地址转换，转换成主机网卡的地址。这么说可能不太好理解，举一个例子说明一下。假设主机有一块网卡为eth0，IP地址为10.10.101.105/24，网关为10.10.101.254。从主机上一个IP为172.17.0.1/16的容器中ping百度（180.76.3.151）。IP包首先从容器发往自己的默认网关docker0，包到达docker0后，也就到达了主机上。然后会查询主机的路由表，发现包应该从主机的eth0发往主机的网关10.10.105.254/24。接着包会转发给eth0，并从eth0发出去（主机的ip_forward转发应该已经打开）。这时候，上面的Iptable规则就会起作用，对包做SNAT转换，将源地址换为eth0的地址。这样，在外界看来，这个包就是从10.10.101.105上发出来的，Docker容器对外是不可见的。</p>
<p>那么，外面的机器是如何访问Docker容器的服务呢？我们首先用下面命令创建一个含有web应用的容器，将容器的80端口映射到主机的80端口。</p>
<p>docker run -d –name web -p 80:80 fmzhen/simpleweb</p>
<p>然后查看Iptable规则的变化，发现多了这样一条规则：</p>
<p>-A DOCKER ! -i docker0 -p tcp -m tcp –dport 80 -j DNAT –to-destination 172.17.0.5:80</p>
<p>此条规则就是对主机eth0收到的目的端口为80的tcp流量进行DNAT转换，将流量发往172.17.0.5:80，也就是我们上面创建的Docker容器。所以，外界只需访问10.10.101.105:80就可以访问到容器中得服务。</p>
<p>除此之外，我们还可以自定义Docker使用的IP地址、DNS等信息，甚至使用自己定义的网桥，但是其工作方式还是一样的。</p>
]]></content>
      <categories>
        <category>DOCKER</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>tmux使用</title>
    <url>/2022/06/15/tmux%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="一、Tmux-是什么？"><a href="#一、Tmux-是什么？" class="headerlink" title="一、Tmux 是什么？"></a>一、Tmux 是什么？</h2><h3 id="1-1-会话与进程"><a href="#1-1-会话与进程" class="headerlink" title="1.1 会话与进程"></a>1.1 会话与进程</h3><p>命令行的典型使用方式是，打开一个终端窗口（terminal window，以下简称”窗口”），在里面输入命令。<strong>用户与计算机的这种临时的交互，称为一次”会话”（session）</strong> 。</p>
<span id="more"></span>

<p>会话的一个重要特点是，窗口与其中启动的进程是连在一起的。打开窗口，会话开始；关闭窗口，会话结束，会话内部的进程也会随之终止，不管有没有运行完。</p>
<p>为了解决这个问题，会话与窗口可以”解绑”：窗口关闭时，会话并不终止，而是继续运行，等到以后需要的时候，再让会话”绑定”其他窗口。</p>
<h3 id="1-2-Tmux-的作用"><a href="#1-2-Tmux-的作用" class="headerlink" title="1.2 Tmux 的作用"></a>1.2 Tmux 的作用</h3><p><strong>Tmux 就是会话与窗口的”解绑”工具，将它们彻底分离。</strong></p>
<blockquote>
<p>（1）它允许在单个窗口中，同时访问多个会话。这对于同时运行多个命令行程序很有用。</p>
<p>（2） 它可以让新窗口”接入”已经存在的会话。</p>
<p>（3）它允许每个会话有多个连接窗口，因此可以多人实时共享会话。</p>
<p>（4）它还支持窗口任意的垂直和水平拆分。</p>
</blockquote>
<p>类似的终端复用器还有 GNU Screen。Tmux 与它功能相似，但是更易用，也更强大。</p>
<h2 id="二、基本用法"><a href="#二、基本用法" class="headerlink" title="二、基本用法"></a>二、基本用法</h2><h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h3><p>Tmux 一般需要自己安装。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># Ubuntu 或 Debian</span><br><span class="line">$ sudo apt-get install tmux</span><br><span class="line"></span><br><span class="line"># CentOS 或 Fedora</span><br><span class="line">$ sudo yum install tmux</span><br><span class="line"></span><br><span class="line"># Mac</span><br><span class="line">$ brew install tmux</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-2-启动与退出"><a href="#2-2-启动与退出" class="headerlink" title="2.2 启动与退出"></a>2.2 启动与退出</h3><p>安装完成后，键入<code>tmux</code>命令，就进入了 Tmux 窗口。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ tmux</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令会启动 Tmux 窗口，底部有一个状态栏。状态栏的左侧是窗口信息（编号和名称），右侧是系统信息。</p>
<p><img src="https://www.wangbase.com/blogimg/asset/201910/bg2019102006.png"></p>
<p>按下<code>Ctrl+d</code>或者显式输入<code>exit</code>命令，就可以退出 Tmux 窗口。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ exit</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-3-前缀键"><a href="#2-3-前缀键" class="headerlink" title="2.3 前缀键"></a>2.3 前缀键</h3><p>Tmux 窗口有大量的快捷键。所有快捷键都要通过前缀键唤起。默认的前缀键是<code>Ctrl+b</code>，即先按下<code>Ctrl+b</code>，快捷键才会生效。</p>
<p>举例来说，帮助命令的快捷键是<code>Ctrl+b ?</code>。它的用法是，在 Tmux 窗口中，先按下<code>Ctrl+b</code>，再按下<code>?</code>，就会显示帮助信息。</p>
<p>然后，按下 ESC 键或<code>q</code>键，就可以退出帮助。</p>
<h2 id="三、会话管理"><a href="#三、会话管理" class="headerlink" title="三、会话管理"></a>三、会话管理</h2><h3 id="3-1-新建会话"><a href="#3-1-新建会话" class="headerlink" title="3.1 新建会话"></a>3.1 新建会话</h3><p>第一个启动的 Tmux 窗口，编号是<code>0</code>，第二个窗口的编号是<code>1</code>，以此类推。这些窗口对应的会话，就是 0 号会话、1 号会话。</p>
<p>使用编号区分会话，不太直观，更好的方法是为会话起名。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ tmux new -s &lt;session-name&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令新建一个指定名称的会话。</p>
<h3 id="3-2-分离会话"><a href="#3-2-分离会话" class="headerlink" title="3.2 分离会话"></a>3.2 分离会话</h3><p>在 Tmux 窗口中，按下<code>Ctrl+b d</code>或者输入<code>tmux detach</code>命令，就会将当前会话与窗口分离。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ tmux detach</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令执行后，就会退出当前 Tmux 窗口，但是会话和里面的进程仍然在后台运行。</p>
<p><code>tmux ls</code>命令可以查看当前所有的 Tmux 会话。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ tmux ls</span><br><span class="line"># or</span><br><span class="line">$ tmux list-session</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="3-3-接入会话"><a href="#3-3-接入会话" class="headerlink" title="3.3 接入会话"></a>3.3 接入会话</h3><p><code>tmux attach</code>命令用于重新接入某个已存在的会话。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 使用会话编号</span><br><span class="line">$ tmux attach -t 0</span><br><span class="line"></span><br><span class="line"># 使用会话名称</span><br><span class="line">$ tmux attach -t &lt;session-name&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="3-4-杀死会话"><a href="#3-4-杀死会话" class="headerlink" title="3.4 杀死会话"></a>3.4 杀死会话</h3><p><code>tmux kill-session</code>命令用于杀死某个会话。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 使用会话编号</span><br><span class="line">$ tmux kill-session -t 0</span><br><span class="line"></span><br><span class="line"># 使用会话名称</span><br><span class="line">$ tmux kill-session -t &lt;session-name&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="3-5-切换会话"><a href="#3-5-切换会话" class="headerlink" title="3.5 切换会话"></a>3.5 切换会话</h3><p><code>tmux switch</code>命令用于切换会话。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 使用会话编号</span><br><span class="line">$ tmux switch -t 0</span><br><span class="line"></span><br><span class="line"># 使用会话名称</span><br><span class="line">$ tmux switch -t &lt;session-name&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="3-6-重命名会话"><a href="#3-6-重命名会话" class="headerlink" title="3.6 重命名会话"></a>3.6 重命名会话</h3><p><code>tmux rename-session</code>命令用于重命名会话。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ tmux rename-session -t 0 &lt;new-name&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令将0号会话重命名。</p>
<h3 id="3-7-会话快捷键"><a href="#3-7-会话快捷键" class="headerlink" title="3.7 会话快捷键"></a>3.7 会话快捷键</h3><p>下面是一些会话相关的快捷键。</p>
<blockquote>
<ul>
<li>  <code>Ctrl+b d</code>：分离当前会话。</li>
<li>  <code>Ctrl+b s</code>：列出所有会话。</li>
<li>  <code>Ctrl+b $</code>：重命名当前会话。</li>
</ul>
</blockquote>
<h2 id="四、最简操作流程"><a href="#四、最简操作流程" class="headerlink" title="四、最简操作流程"></a>四、最简操作流程</h2><p>综上所述，以下是 Tmux 的最简操作流程。</p>
<blockquote>
<ol>
<li> 新建会话<code>tmux new -s my_session</code>。</li>
<li> 在 Tmux 窗口运行所需的程序。</li>
<li> 按下快捷键<code>Ctrl+b d</code>将会话分离。</li>
<li> 下次使用时，重新连接到会话<code>tmux attach-session -t my_session</code>。</li>
</ol>
</blockquote>
<h2 id="五、窗格操作"><a href="#五、窗格操作" class="headerlink" title="五、窗格操作"></a>五、窗格操作</h2><p>Tmux 可以将窗口分成多个窗格（pane），每个窗格运行不同的命令。以下命令都是在 Tmux 窗口中执行。</p>
<h3 id="5-1-划分窗格"><a href="#5-1-划分窗格" class="headerlink" title="5.1 划分窗格"></a>5.1 划分窗格</h3><p><code>tmux split-window</code>命令用来划分窗格。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 划分上下两个窗格</span><br><span class="line">$ tmux split-window</span><br><span class="line"></span><br><span class="line"># 划分左右两个窗格</span><br><span class="line">$ tmux split-window -h</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<p><img src="https://www.wangbase.com/blogimg/asset/201910/bg2019102007.jpg"></p>
<h3 id="5-2-移动光标"><a href="#5-2-移动光标" class="headerlink" title="5.2 移动光标"></a>5.2 移动光标</h3><p><code>tmux select-pane</code>命令用来移动光标位置。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 光标切换到上方窗格</span><br><span class="line">$ tmux select-pane -U</span><br><span class="line"></span><br><span class="line"># 光标切换到下方窗格</span><br><span class="line">$ tmux select-pane -D</span><br><span class="line"></span><br><span class="line"># 光标切换到左边窗格</span><br><span class="line">$ tmux select-pane -L</span><br><span class="line"></span><br><span class="line"># 光标切换到右边窗格</span><br><span class="line">$ tmux select-pane -R</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="5-3-交换窗格位置"><a href="#5-3-交换窗格位置" class="headerlink" title="5.3 交换窗格位置"></a>5.3 交换窗格位置</h3><p><code>tmux swap-pane</code>命令用来交换窗格位置。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 当前窗格上移</span><br><span class="line">$ tmux swap-pane -U</span><br><span class="line"></span><br><span class="line"># 当前窗格下移</span><br><span class="line">$ tmux swap-pane -D</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="5-4-窗格快捷键"><a href="#5-4-窗格快捷键" class="headerlink" title="5.4 窗格快捷键"></a>5.4 窗格快捷键</h3><p>下面是一些窗格操作的快捷键。</p>
<blockquote>
<ul>
<li>  <code>Ctrl+b %</code>：划分左右两个窗格。</li>
<li>  <code>Ctrl+b &quot;</code>：划分上下两个窗格。</li>
<li>  <code>Ctrl+b &lt;arrow key&gt;</code>：光标切换到其他窗格。<code>&lt;arrow key&gt;</code>是指向要切换到的窗格的方向键，比如切换到下方窗格，就按方向键<code>↓</code>。</li>
<li>  <code>Ctrl+b ;</code>：光标切换到上一个窗格。</li>
<li>  <code>Ctrl+b o</code>：光标切换到下一个窗格。</li>
<li>  <code>Ctrl+b &#123;</code>：当前窗格与上一个窗格交换位置。</li>
<li>  <code>Ctrl+b &#125;</code>：当前窗格与下一个窗格交换位置。</li>
<li>  <code>Ctrl+b Ctrl+o</code>：所有窗格向前移动一个位置，第一个窗格变成最后一个窗格。</li>
<li>  <code>Ctrl+b Alt+o</code>：所有窗格向后移动一个位置，最后一个窗格变成第一个窗格。</li>
<li>  <code>Ctrl+b x</code>：关闭当前窗格。</li>
<li>  <code>Ctrl+b !</code>：将当前窗格拆分为一个独立窗口。</li>
<li>  <code>Ctrl+b z</code>：当前窗格全屏显示，再使用一次会变回原来大小。</li>
<li>  <code>Ctrl+b Ctrl+&lt;arrow key&gt;</code>：按箭头方向调整窗格大小。</li>
<li>  <code>Ctrl+b q</code>：显示窗格编号。</li>
</ul>
</blockquote>
<h2 id="六、窗口管理"><a href="#六、窗口管理" class="headerlink" title="六、窗口管理"></a>六、窗口管理</h2><p>除了将一个窗口划分成多个窗格，Tmux 也允许新建多个窗口。</p>
<h3 id="6-1-新建窗口"><a href="#6-1-新建窗口" class="headerlink" title="6.1 新建窗口"></a>6.1 新建窗口</h3><p><code>tmux new-window</code>命令用来创建新窗口。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ tmux new-window</span><br><span class="line"></span><br><span class="line"># 新建一个指定名称的窗口</span><br><span class="line">$ tmux new-window -n &lt;window-name&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="6-2-切换窗口"><a href="#6-2-切换窗口" class="headerlink" title="6.2 切换窗口"></a>6.2 切换窗口</h3><p><code>tmux select-window</code>命令用来切换窗口。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 切换到指定编号的窗口</span><br><span class="line">$ tmux select-window -t &lt;window-number&gt;</span><br><span class="line"></span><br><span class="line"># 切换到指定名称的窗口</span><br><span class="line">$ tmux select-window -t &lt;window-name&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="6-3-重命名窗口"><a href="#6-3-重命名窗口" class="headerlink" title="6.3 重命名窗口"></a>6.3 重命名窗口</h3><p><code>tmux rename-window</code>命令用于为当前窗口起名（或重命名）。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ tmux rename-window &lt;new-name&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="6-4-窗口快捷键"><a href="#6-4-窗口快捷键" class="headerlink" title="6.4 窗口快捷键"></a>6.4 窗口快捷键</h3><p>下面是一些窗口操作的快捷键。</p>
<blockquote>
<ul>
<li>  <code>Ctrl+b c</code>：创建一个新窗口，状态栏会显示多个窗口的信息。</li>
<li>  <code>Ctrl+b p</code>：切换到上一个窗口（按照状态栏上的顺序）。</li>
<li>  <code>Ctrl+b n</code>：切换到下一个窗口。</li>
<li>  <code>Ctrl+b &lt;number&gt;</code>：切换到指定编号的窗口，其中的<code>&lt;number&gt;</code>是状态栏上的窗口编号。</li>
<li>  <code>Ctrl+b w</code>：从列表中选择窗口。</li>
<li>  <code>Ctrl+b ,</code>：窗口重命名。</li>
</ul>
</blockquote>
<h2 id="七、其他命令"><a href="#七、其他命令" class="headerlink" title="七、其他命令"></a>七、其他命令</h2><p>下面是一些其他命令。</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># 列出所有快捷键，及其对应的 Tmux 命令</span><br><span class="line">$ tmux list-keys</span><br><span class="line"></span><br><span class="line"># 列出所有 Tmux 命令及其参数</span><br><span class="line">$ tmux list-commands</span><br><span class="line"></span><br><span class="line"># 列出当前所有 Tmux 会话的信息</span><br><span class="line">$ tmux info</span><br><span class="line"></span><br><span class="line"># 重新加载当前的 Tmux 配置</span><br><span class="line">$ tmux source-file ~/.tmux.conf</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>tmux</tag>
      </tags>
  </entry>
  <entry>
    <title>用户态驱动vfio</title>
    <url>/2022/06/14/%E7%94%A8%E6%88%B7%E6%80%81%E9%A9%B1%E5%8A%A8vfio/</url>
    <content><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul>
<li>将硬件设备寄存器映射至用户态</li>
<li>iommu</li>
<li>在用户态处理中断<span id="more"></span></li>
</ul>
<h2 id="用户态使用vfio"><a href="#用户态使用vfio" class="headerlink" title="用户态使用vfio"></a>用户态使用vfio</h2><h3 id="启动Vt-d功能"><a href="#启动Vt-d功能" class="headerlink" title="启动Vt-d功能"></a>启动Vt-d功能</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /proc/cmdline</span></span><br><span class="line">BOOT_IMAGE=(hd0,msdos1)/vmlinuz-4.18.0-305.30.1.jmnd2.el8.x86_64 root=UUID=3e50617c-bb11-4b9f-9313-4d070fd14fbc ro crashkernel=auto console=tty0,edd=off intel_iommu=on iommu=pt pci=realloc</span><br></pre></td></tr></table></figure>
<h3 id="modprobe-vfio-pci"><a href="#modprobe-vfio-pci" class="headerlink" title="modprobe vfio-pci"></a>modprobe vfio-pci</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lsmod | grep vfio</span></span><br><span class="line">vfio_pci               61440  0</span><br><span class="line">vfio_virqfd            16384  1 vfio_pci</span><br><span class="line">vfio_iommu_type1       36864  0</span><br><span class="line">vfio                   36864  2 vfio_iommu_type1,vfio_pci</span><br><span class="line">irqbypass              16384  2 vfio_pci,kvm</span><br></pre></td></tr></table></figure>
<p>上述命令将加载vfio_pci.ko, vfio_virqfd.ko, vfio_iommu_type1.ko, vfio.ko内核模块</p>
<h3 id="绑定设备到vfio-pci"><a href="#绑定设备到vfio-pci" class="headerlink" title="绑定设备到vfio-pci"></a>绑定设备到vfio-pci</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> vfio-pci &gt; /sys/bus/pci/devices/<span class="variable">$1</span>/driver_override</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$1</span> &gt; /sys/bus/pci/devices/<span class="variable">$1</span>/driver/unbind</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$1</span> &gt; /sys/bus/pci/drivers_probe</span><br></pre></td></tr></table></figure>

<h2 id="dpdk中通过vfio映射设备空间"><a href="#dpdk中通过vfio映射设备空间" class="headerlink" title="dpdk中通过vfio映射设备空间"></a>dpdk中通过vfio映射设备空间</h2><ol>
<li>获取设备所在的iommu group</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">....</span><br><span class="line">	rte_pci_device_name(&amp;dev-&gt;addr, devname, RTE_DEV_NAME_MAX_LEN);</span><br><span class="line">	ret = rte_vfio_get_group_num(rte_pci_get_sysfs_path(), devname,</span><br><span class="line">				     &amp;iommu_group_num);</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>rte_vfio_get_group_num内部实现为，获取sys下设备文件的iommu_group</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># readlink /sys/bus/pci/devices/0000\:24\:00.1/iommu_group</span></span><br><span class="line">../../../../kernel/iommu_groups/40</span><br></pre></td></tr></table></figure>

<p>在bash下可以通过lspci查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lspci -s 0000:24:00.1 -vv | grep IOMMU</span><br><span class="line">	IOMMU group: 40</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建container，open /dev/vfio/vfio</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">....</span><br><span class="line">    vfio_container_fd = rte_vfio_container_create();</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>内部实现为，打开设备文件vfio，最大64个container</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> VFIO_CONTAINER_PATH <span class="string">&quot;/dev/vfio/vfio&quot;</span></span></span><br><span class="line">....</span><br><span class="line">    vfio_container_fd = open(VFIO_CONTAINER_PATH, O_RDWR);</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>将iommu_group_num绑定到container</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> VFIO_CONTAINER_PATH <span class="string">&quot;/dev/vfio/vfio&quot;</span></span></span><br><span class="line">....</span><br><span class="line">vfio_group_fd =</span><br><span class="line">		rte_vfio_container_group_bind(vfio_container_fd, iommu_group_num);</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>以vfio_container_fd为key找到全局数组vfio_cfgs元素，</p>
<p>打开/dev/vfio/group_num设备文件，获取vfio_group_fd</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> VFIO_GROUP_FMT <span class="string">&quot;/dev/vfio/%u&quot;</span></span></span><br><span class="line">....</span><br><span class="line">		<span class="built_in">snprintf</span>(filename, <span class="keyword">sizeof</span>(filename),</span><br><span class="line">				 VFIO_GROUP_FMT, iommu_group_num);</span><br><span class="line">		vfio_group_fd = open(filename, O_RDWR);</span><br></pre></td></tr></table></figure>
<p>比如：<br>vfio_group_fd = open(“/dev/vfio/40”, O_RDWR)<br>其中40为iommu_group_num</p>
<p>将iommu_group_num和vfio_group_fd设置到vfio_container_fd对应的vfio_cfgs</p>
<ol start="4">
<li>映射设备空间</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">....</span><br><span class="line">rte_pci_map_device(dev)</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>4.1、rte_vfio_setup_device<br>/* add group to a container */<br>ret = ioctl(vfio_group_fd, VFIO_GROUP_SET_CONTAINER,<br>        &amp;vfio_container_fd)</p>
<p>4.2、vfio_set_iommu_type<br>int ret = ioctl(vfio_container_fd, VFIO_SET_IOMMU,<br>        t-&gt;type_id);</p>
<p>4.3、VFIO_GROUP_GET_DEVICE_FD<br>*vfio_dev_fd = ioctl(vfio_group_fd, VFIO_GROUP_GET_DEVICE_FD, dev_addr);<br>这个dev_addr为pci的bdf号</p>
<p>4.4、通过*vfio_dev_fd访问设备空间<br>ret = ioctl(*vfio_dev_fd, VFIO_DEVICE_GET_INFO, device_info);</p>
<p>把vfio_dev_fd看成一个文件，这个文件的内容包含了设备的所有可访问资源，这包括中断，pci配置空间，扩展配置空间，6个bar空间。这些不同的资源可以看做是文件不同偏移基址处的一段文件内容(region)，可以像读写普通文件一样读写这些资源。6个bar空间对应的region属于可映射区域，可以使用mmap将其映射进用户态空间进行读写，而其他资源则不可映射，只能通过read/write系统调用经内核进行间接的读写。设备的pci配置空间属于不可映射区域，只能read/write系统调用经内核进行间接的读写。</p>
<h2 id="访问PCI配置空间"><a href="#访问PCI配置空间" class="headerlink" title="访问PCI配置空间"></a>访问PCI配置空间</h2><p>遍历每个bar</p>
<ol>
<li>获取region信息</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">....</span><br><span class="line">ret = pci_vfio_get_region_info(vfio_dev_fd, &amp;reg, i);</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>其内部实现为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ret = ioctl(vfio_dev_fd, VFIO_DEVICE_GET_REGION_INFO, ri);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>检查该region是否可map</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">....</span><br><span class="line"><span class="comment">/* skip non-mmappable BARs */</span></span><br><span class="line"><span class="keyword">if</span> ((reg-&gt;flags &amp; VFIO_REGION_INFO_FLAG_MMAP) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">free</span>(reg);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>mmap到用户空间</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">....</span><br><span class="line">	bar_addr = mmap(bar-&gt;addr, bar-&gt;size, <span class="number">0</span>, MAP_PRIVATE |</span><br><span class="line">			MAP_ANONYMOUS | additional_flags, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<h2 id="IOMMU"><a href="#IOMMU" class="headerlink" title="IOMMU"></a>IOMMU</h2><h3 id="DMA-remap"><a href="#DMA-remap" class="headerlink" title="DMA remap"></a>DMA remap</h3><p>guest安全隔离的进行真实设备的DMA，将gpa映射到hpa<br>VFIO_IOMMU_MAP_DMA：将 iova 通过 IOMMU 映射到 vaddr 对应的物理地址上去<br>其中，iova代表gpa，vaddr代表hva</p>
<p>下面描述一下qemu作为前端，dpdk作为后端时，iommu的过程</p>
<ol>
<li>qemu通过VHOST_USER_SET_MEM_TABLE将将gpa，size，mmap的fd带给dpdk</li>
</ol>
<p><code>vhost_user_set_mem_table</code></p>
<ol start="2">
<li>dpdk mmap 得到hva，并且这一块与qemu共享内存</li>
</ol>
<p><code>vhost_user_mmap_region</code></p>
<ol start="3">
<li>将hva和gpa通过ioctl 发送VFIO_IOMMU_MAP_DMA命令带给kernel，完成gpa到hpa的映射</li>
</ol>
<p><code>rte_vfio_container_dma_map</code><br>    <code>vfio_dma_mem_map</code><br>        <code>vfio_type1_dma_mem_map</code><br>            <code>VFIO_IOMMU_MAP_DMA</code></p>
<h3 id="中断remap"><a href="#中断remap" class="headerlink" title="中断remap"></a>中断remap</h3><p>主要作用是通过ioctl命令<code>VFIO_DEVICE_SET_IRQS</code>将eventfd绑定到vfio，用户态即可epoll轮询此eventfd<br>用户态驱动创建一个eventfd，并在vfio中将中断绑定此eventfd，这样一旦vfio内核中的中断处理函数收到中断就会触发eventfd变为可读。用户态驱动epoll此eventfd，即可收到中断通知。<br>用户态中断，以dpdk为例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">....</span><br><span class="line">pci_vfio_setup_interrupts(dev, vfio_dev_fd)</span><br><span class="line">....</span><br></pre></td></tr></table></figure>
<p>内部实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">....</span><br><span class="line">    fd = eventfd(<span class="number">0</span>, EFD_NONBLOCK | EFD_CLOEXEC);</span><br><span class="line">    <span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        RTE_LOG(ERR, EAL, <span class="string">&quot;Cannot set up eventfd, error &quot;</span></span><br><span class="line">                <span class="string">&quot;%i (%s)\n&quot;</span>, errno, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	irq_set = (<span class="keyword">struct</span> vfio_irq_set *)irq_set_buf;</span><br><span class="line">	irq_set-&gt;argsz = <span class="keyword">sizeof</span>(irq_set_buf);</span><br><span class="line">	irq_set-&gt;count = nr_vring + <span class="number">1</span>;</span><br><span class="line">	irq_set-&gt;flags = VFIO_IRQ_SET_DATA_EVENTFD |</span><br><span class="line">			 VFIO_IRQ_SET_ACTION_TRIGGER;</span><br><span class="line">	irq_set-&gt;index = VFIO_PCI_MSIX_IRQ_INDEX;</span><br><span class="line">	irq_set-&gt;start = <span class="number">0</span>;</span><br><span class="line">	fd_ptr = (<span class="type">int</span> *)&amp;irq_set-&gt;data;</span><br><span class="line">	<span class="comment">/* The first interrupt is for the configure space change notification */</span></span><br><span class="line">	fd_ptr[RTE_INTR_VEC_ZERO_OFFSET] =</span><br><span class="line">		rte_intr_fd_get(jmvd-&gt;pdev-&gt;intr_handle);</span><br><span class="line"></span><br><span class="line">	ret = ioctl(jmvd-&gt;vfio_dev_fd, VFIO_DEVICE_SET_IRQS, irq_set);</span><br><span class="line">	<span class="keyword">if</span> (ret) &#123;</span><br><span class="line">		DRV_LOG(ERR, <span class="string">&quot;Error enabling MSI-X interrupts: %s&quot;</span>,</span><br><span class="line">				strerror(errno));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>vfio</tag>
      </tags>
  </entry>
  <entry>
    <title>DPDK vhost处理流程</title>
    <url>/2022/06/13/DPDK-vhost%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rte_eal_init</span><br><span class="line"></span><br><span class="line">    rte_bus_probe</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rte_vdev_bus.probe</span><br><span class="line">    rte_vdev_init</span><br><span class="line">        vdev_probe_all_drivers</span><br><span class="line">                rte_pmd_vhost_probe</span><br><span class="line">                    eth_dev_vhost_create</span><br><span class="line">                        rte_vhost_driver_start</span><br><span class="line">                                1)fdset_event_dispatch thread</span><br><span class="line">                                1) 区分server（vhost_user_start_server）</span><br><span class="line">                                    还是client（vhost_user_start_client)</span><br></pre></td></tr></table></figure>

<h2 id="dpdk-为server"><a href="#dpdk-为server" class="headerlink" title="dpdk 为server"></a>dpdk 为server</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vhost_user_start_server</span><br><span class="line"></span><br><span class="line">       vhost_user_server_new_connection</span><br><span class="line"></span><br><span class="line">              fdset_add (vhost_user_read_cb)</span><br><span class="line"></span><br><span class="line">                     vhost_user_read_cb</span><br><span class="line"></span><br><span class="line">                            vhost_user_msg_handler 消息处理</span><br></pre></td></tr></table></figure>
<h2 id="dpdk-为client"><a href="#dpdk-为client" class="headerlink" title="dpdk 为client"></a>dpdk 为client</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vhost_user_start_client</span><br><span class="line"></span><br><span class="line">       vhost_user_connect_nonblock</span><br><span class="line"></span><br><span class="line">              vhost_user_add_connection</span><br><span class="line"></span><br><span class="line">                     fdset_add (vhost_user_read_cb)</span><br><span class="line"></span><br><span class="line">                            vhost_user_read_cb</span><br><span class="line"></span><br><span class="line">                                   vhost_user_msg_handler 消息处理</span><br></pre></td></tr></table></figure>
<h2 id="消息处理流程"><a href="#消息处理流程" class="headerlink" title="消息处理流程"></a>消息处理流程</h2><p>vhost_user_msg_handler</p>
<p>1）read_vhost_message → read_fd_message →  recvmsg</p>
<p>2） 获取request = msg.request.master</p>
<p>3）根据vhost_message_handlers 结构处理消息</p>
<p>4）处理 post_msg_handle</p>
<p>5）send_vhost_reply 返回处理结果</p>
]]></content>
      <categories>
        <category>DPDK</category>
      </categories>
      <tags>
        <tag>DPDK</tag>
      </tags>
  </entry>
  <entry>
    <title>qemu chardev启动</title>
    <url>/2022/06/12/qemu-chardev%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<h2 id="Qemu-vhost-处理流程"><a href="#Qemu-vhost-处理流程" class="headerlink" title="Qemu vhost 处理流程"></a>Qemu vhost 处理流程</h2><p>初始化流程<br>启动参数 例如 <code>-chardev socket,id=char1,path=/tmp/sock1,server</code></p>
<span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/root/pc-bios/qemu-system-x86_64  \</span><br><span class="line">        -enable-kvm -m 2048 -smp 4 -cpu host \</span><br><span class="line">        -hda /mnt/store/vm0-centos8.4-8g-ext4-host-dmar.img \</span><br><span class="line">        -object memory-backend-file,<span class="built_in">id</span>=mem,size=2048M,mem-path=/dev/hugepages,share=on \</span><br><span class="line">        -mem-prealloc \</span><br><span class="line">        -numa node,memdev=mem \</span><br><span class="line">        -chardev socket,<span class="built_in">id</span>=char0,path=/tmp/vdpa-socket8 \</span><br><span class="line">        -netdev <span class="built_in">type</span>=vhost-user,<span class="built_in">id</span>=vdpa0,chardev=char0,queues=4 \</span><br><span class="line">        -device virtio-net-pci,mq=on,rx_queue_size=512,tx_queue_size=512,netdev=vdpa0,page-per-vq=on \</span><br><span class="line">        -chardev socket,<span class="built_in">id</span>=char1,path=/tmp/vdpa-socket9 \</span><br><span class="line">        -netdev <span class="built_in">type</span>=vhost-user,<span class="built_in">id</span>=vdpa1,chardev=char1,queues=4 \</span><br><span class="line">        -device virtio-net-pci,mq=on,rx_queue_size=512,tx_queue_size=512,netdev=vdpa1,page-per-vq=on \</span><br><span class="line">        -chardev socket,<span class="built_in">id</span>=char2,path=/tmp/vdpa-socket10 \</span><br><span class="line">        -netdev <span class="built_in">type</span>=vhost-user,<span class="built_in">id</span>=vdpa2,chardev=char2,queues=4 \</span><br><span class="line">        -device virtio-net-pci,mq=on,rx_queue_size=512,tx_queue_size=512,netdev=vdpa2,page-per-vq=on \</span><br><span class="line">        -chardev socket,<span class="built_in">id</span>=char3,path=/tmp/vdpa-socket11 \</span><br><span class="line">        -netdev <span class="built_in">type</span>=vhost-user,<span class="built_in">id</span>=vdpa3,chardev=char3,queues=4 \</span><br><span class="line">        -device virtio-net-pci,mq=on,rx_queue_size=512,tx_queue_size=512,netdev=vdpa3,page-per-vq=on \</span><br><span class="line">        -chardev socket,<span class="built_in">id</span>=char_data0,path=/tmp/vdpa-socket0,reconnect=1 \</span><br><span class="line">        -device vhost-user-blk-pci,<span class="built_in">id</span>=blk.0,chardev=char_data0,num-queues=2 \</span><br><span class="line">        -chardev socket,<span class="built_in">id</span>=char_data1,path=/tmp/vdpa-socket1,reconnect=1 \</span><br><span class="line">        -device vhost-user-blk-pci,<span class="built_in">id</span>=blk.1,chardev=char_data1,num-queues=2 \</span><br><span class="line">        -chardev socket,<span class="built_in">id</span>=char_data2,path=/tmp/vdpa-socket2,reconnect=1 \</span><br><span class="line">        -device vhost-user-blk-pci,<span class="built_in">id</span>=blk.2,chardev=char_data2,num-queues=2 \</span><br><span class="line">        -chardev socket,<span class="built_in">id</span>=char_data3,path=/tmp/vdpa-socket3,reconnect=1 \</span><br><span class="line">        -device vhost-user-blk-pci,<span class="built_in">id</span>=blk.3,chardev=char_data3,num-queues=2 \</span><br><span class="line">        -serial telnet:127.1:4321,server,nowait \</span><br><span class="line">        -monitor stdio \</span><br><span class="line">        -D ./qemu-vm0.<span class="built_in">log</span> \</span><br><span class="line">        -vnc :90 -L /root/pc-bios \</span><br><span class="line">        -incoming tcp:0:6666</span><br></pre></td></tr></table></figure>

<h2 id="参数启动过程"><a href="#参数启动过程" class="headerlink" title="参数启动过程"></a>参数启动过程</h2><p>如果qemu作为server，则调用栈</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu_init-&gt;</span><br><span class="line">    qemu_opts_foreach-&gt;</span><br><span class="line">        chardev_init_func -&gt;</span><br><span class="line">            qemu_chr_new_from_opts -&gt;</span><br><span class="line">                qemu_chardev_new -&gt;</span><br><span class="line">                    chardev_new -&gt;</span><br><span class="line">                        qemu_char_open-&gt;</span><br><span class="line">                            qmp_chardev_open_socket-&gt;</span><br><span class="line">                                qmp_chardev_open_socket_server-&gt;</span><br><span class="line">                                        tcp_chr_accept_server_sync -&gt;</span><br><span class="line">                                            qio_net_listener_wait_client -&gt;</span><br><span class="line">                                            等待客户连接（GMainContext）</span><br></pre></td></tr></table></figure>

<p>如果qemu作为client，则调用栈</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu_init</span><br><span class="line">    qemu_create_early_backends</span><br><span class="line">        qemu_opts_foreach</span><br><span class="line">            chardev_init_func</span><br><span class="line">                qemu_chr_new_from_opts</span><br><span class="line">                    qemu_chardev_new</span><br><span class="line">                        chardev_new</span><br><span class="line">                            qemu_char_open</span><br><span class="line">                                qmp_chardev_open_socket</span><br><span class="line">                                    qmp_chardev_open_socket_client</span><br></pre></td></tr></table></figure>


<h3 id="连接事件处理"><a href="#连接事件处理" class="headerlink" title="连接事件处理"></a>连接事件处理</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tcp_chr_new_client -&gt;</span><br><span class="line">    tcp_chr_connect -&gt;</span><br><span class="line">            update_ioc_handlers-&gt; tcp_chr_read,tcp_chr_read_poll</span><br><span class="line">                tcp_chr_read -&gt;</span><br><span class="line">                    tcp_chr_recv-&gt;</span><br><span class="line">                        qio_channel_readv_full -&gt;</span><br><span class="line">                            ioc_klass-&gt;io_readv -&gt;</span><br><span class="line">                                    qio_channel_socket_readv- &gt;</span><br><span class="line">                                        recvmsg</span><br></pre></td></tr></table></figure>


<h2 id="消息处理流程"><a href="#消息处理流程" class="headerlink" title="消息处理流程"></a>消息处理流程</h2><h3 id="net"><a href="#net" class="headerlink" title="net"></a>net</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu_init</span><br><span class="line">    qemu_create_late_backends</span><br><span class="line">        net_init_clients</span><br><span class="line">            qemu_opts_foreach</span><br><span class="line">                net_client_init</span><br><span class="line">                    net_init_vhost_user</span><br><span class="line">                        qemu_chr_fe_set_handlers</span><br><span class="line">                            qemu_chr_be_event</span><br><span class="line">                                net_vhost_user_event</span><br><span class="line">                                    vhost_user_start</span><br><span class="line">                                        vhost_net_init</span><br><span class="line">                                            vhost_dev_init</span><br></pre></td></tr></table></figure>

<h3 id="blk"><a href="#blk" class="headerlink" title="blk"></a>blk</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu_init</span><br><span class="line">    qmp_x_exit_preconfig</span><br><span class="line">        qemu_opts_foreach</span><br><span class="line">            device_init_func</span><br><span class="line">                qdev_device_add</span><br><span class="line">                    qdev_realize</span><br><span class="line">                        virtio_pci_dc_realize</span><br><span class="line">                            virtio_pci_realize</span><br><span class="line">                                vhost_user_blk_pci_realize</span><br><span class="line">                                    virtio_device_realize</span><br><span class="line">                                        vhost_user_blk_device_realize</span><br><span class="line">                                            vhost_user_blk_connect</span><br><span class="line">                                                vhost_dev_init</span><br></pre></td></tr></table></figure>

<h2 id="vhost初始化流程"><a href="#vhost初始化流程" class="headerlink" title="vhost初始化流程"></a>vhost初始化流程</h2><h3 id="vhost-dev-init"><a href="#vhost-dev-init" class="headerlink" title="vhost_dev_init"></a>vhost_dev_init</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vhost_dev_init -&gt;</span><br><span class="line"></span><br><span class="line">      vhost_set_backend_type -&gt;</span><br><span class="line"></span><br><span class="line">          1) vhost_backend_init</span><br><span class="line"></span><br><span class="line">          2) vhost_set_owner</span><br><span class="line"></span><br><span class="line">          3) vhost_get_features</span><br><span class="line"></span><br><span class="line">          4) vhost_virtqueue_init</span><br></pre></td></tr></table></figure>
<h3 id="vhost-dev-start"><a href="#vhost-dev-start" class="headerlink" title="vhost_dev_start"></a>vhost_dev_start</h3><p>guest驱动加载后，vm exit到qemu的vcpu线程处理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu_thread_start</span><br><span class="line">    kvm_vcpu_thread_fn</span><br><span class="line">        kvm_cpu_exec</span><br><span class="line">            kvm_handle_io</span><br><span class="line">                address_space_rw</span><br><span class="line">                    memory_region_dispatch_write</span><br><span class="line">                        access_with_adjusted_size</span><br><span class="line">                            memory_region_write_accessor</span><br><span class="line">                                virtio_pci_config_write</span><br><span class="line">                                    virtio_ioport_write</span><br><span class="line">                                        virtio_set_status</span><br><span class="line">                                            vhost_user_blk_set_status</span><br><span class="line">                                                vhost_user_blk_start</span><br><span class="line">                                                    set_guest_notifiers</span><br><span class="line">                                                    vhost_dev_start</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vhost_dev_start -&gt;</span><br><span class="line"></span><br><span class="line">    1) vhost_dev_set_features</span><br><span class="line"></span><br><span class="line">    2) vhost_set_mem_table</span><br><span class="line"></span><br><span class="line">    3) vhost_virtqueue_start</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    vhost_virtqueue_start -&gt;</span><br><span class="line"></span><br><span class="line">       1) vhost_ops-&gt;vhost_get_vq_index</span><br><span class="line"></span><br><span class="line">       2) vhost_ops-&gt;vhost_set_vring_num</span><br><span class="line"></span><br><span class="line">       3) vhost_ops-&gt;vhost_set_vring_base</span><br><span class="line"></span><br><span class="line">       4) vhost_memory_map</span><br><span class="line"></span><br><span class="line">       5) vhost_ops-&gt;vhost_set_vring_kick</span><br><span class="line"></span><br><span class="line">vhost_virtqueue_start-&gt;</span><br><span class="line"></span><br><span class="line">    dev-&gt;vhost_ops-&gt;vhost_set_vring_num -&gt;</span><br><span class="line"></span><br><span class="line">        vhost_user_set_vring_num -&gt;</span><br><span class="line"></span><br><span class="line">            vhost_set_vring--&gt; 设置msg ,发送 vhost_user_write -&gt;</span><br><span class="line"></span><br><span class="line">                qemu_chr_fe_write_all-&gt;</span><br><span class="line"></span><br><span class="line">                    qemu_chr_write -&gt;</span><br><span class="line"></span><br><span class="line">                    qemu_chr_write_buffer--&gt;</span><br><span class="line"></span><br><span class="line">                        ChardevClass 的 chr_write 方法其他的方法类似。</span><br></pre></td></tr></table></figure>

<p>vhost_user.VhostUserState.CharBackend 如何定义的？</p>
<p>启动参数<br>-chardev socket,id=char1,path=$NETSOCK1,server</p>
<p>-netdev type=vhost-user,id=hostnet1,queues=$QPS,chardev=char1</p>
<p>chardev 通过名字char1 查找到chardev 的到相关的操作。</p>
]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>qemu&amp;kvm io交互</title>
    <url>/2022/06/11/qemu-kvm-io%E4%BA%A4%E4%BA%92/</url>
    <content><![CDATA[<h2 id="qemu初始化"><a href="#qemu初始化" class="headerlink" title="qemu初始化"></a>qemu初始化</h2><p>main函数通过调用kvm_init 和 machine-&gt;init来初始化kvm。 其中, machine-&gt;init会创建vcpu, 用一个线程去模拟vcpu, 该线程执行的函数为kvm_vcpu_thread_fn, 并且该线程调用kvm_cpu_exec,该函数调用kvm_vcpu_ioctl切换到kvm中,下次从kvm中返回时,会接着执行kvm_vcpu_ioctl之后的代码,判断exit_reason,然后进行相应处理。</p>
<span id="more"></span>

<h2 id="qemu的io处理流程"><a href="#qemu的io处理流程" class="headerlink" title="qemu的io处理流程"></a>qemu的io处理流程</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">start_thread</span><br><span class="line">    qemu_thread_start</span><br><span class="line">        kvm_vcpu_thread_fn</span><br><span class="line">            kvm_cpu_exec</span><br><span class="line">                kvm_vcpu_ioctl</span><br><span class="line">                    ioctl</span><br></pre></td></tr></table></figure>

<p>这里ioctl切换到kvm中，并且阻塞直到有io事件<br>Guest执行io指令 -&gt; 发生vmexit-&gt; 返回qemu -&gt; 处理io</p>
<h2 id="kvm的io处理流程"><a href="#kvm的io处理流程" class="headerlink" title="kvm的io处理流程"></a>kvm的io处理流程</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">handle_io</span><span class="params">(<span class="keyword">struct</span> kvm_vcpu *vcpu)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> exit_qualification;</span><br><span class="line">    <span class="type">int</span> size, in, <span class="built_in">string</span>;</span><br><span class="line">    <span class="type">unsigned</span> port;</span><br><span class="line"></span><br><span class="line">    exit_qualification = vmcs_readl(EXIT_QUALIFICATION);  <span class="comment">//获取exit qualification</span></span><br><span class="line">    <span class="built_in">string</span> = (exit_qualification &amp; <span class="number">16</span>) != <span class="number">0</span>; <span class="comment">//判断是否为string io (ins, outs)</span></span><br><span class="line">    in = (exit_qualification &amp; <span class="number">8</span>) != <span class="number">0</span>; <span class="comment">//判断io方向，是in  还是out</span></span><br><span class="line"></span><br><span class="line">    ++vcpu-&gt;stat.io_exits;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">string</span> || in) <span class="comment">//如果是输入类的指令，或者是string io，就进入emulator处理</span></span><br><span class="line">            <span class="keyword">return</span> emulate_instruction(vcpu, <span class="number">0</span>) == EMULATE_DONE;</span><br><span class="line"></span><br><span class="line">    port = exit_qualification &gt;&gt; <span class="number">16</span>; <span class="comment">//得到端口号</span></span><br><span class="line">    size = (exit_qualification &amp; <span class="number">7</span>) + <span class="number">1</span>; <span class="comment">//大小</span></span><br><span class="line">    skip_emulated_instruction(vcpu); <span class="comment">//跳过这个指令</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> kvm_fast_pio_out(vcpu, size, port); <span class="comment">//进行out操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1、out指令虚拟：虚拟单个out指令，在KVM中可以直接把out的数据返回给qemu，qemu完成out操作。</p>
<p>流程：KVM的handle_io-&gt;kvm_fast_pio_out-&gt;emulator_pio_out_emulated后面是vcpu-&gt;arch.pio.count = 0函数中非string类型的 out操作可以一步完成，所以从qemu处理完返回kvm后不需要再进入emulator。在emulator_pio_out_emulated中，将IO数据memcpy到kvm和qemu共享buffer中，然后emulator_pio_in_out，将相应数据保存到kvm_run中就返回到qemu的kvm_cpu_exec的switch看run-&gt;exit_reason，如果是KVM_EXIT_IO则进入kvm_handle_io中和设备交互。</p>
<p>qemu代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">kvm_cpu_exec</span><span class="params">(CPUState *cpu)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    trace_kvm_run_exit(cpu-&gt;cpu_index, run-&gt;exit_reason);</span><br><span class="line">    <span class="keyword">switch</span> (run-&gt;exit_reason) &#123;</span><br><span class="line">    <span class="keyword">case</span> KVM_EXIT_IO:</span><br><span class="line">        DPRINTF(<span class="string">&quot;handle_io\n&quot;</span>);</span><br><span class="line">        <span class="comment">/* Called outside BQL */</span></span><br><span class="line">        kvm_handle_io(run-&gt;io.port, attrs,</span><br><span class="line">                        (<span class="type">uint8_t</span> *)run + run-&gt;io.data_offset,</span><br><span class="line">                        run-&gt;io.direction,</span><br><span class="line">                        run-&gt;io.size,</span><br><span class="line">                        run-&gt;io.count);</span><br><span class="line">        ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、String或in指令虚拟：如果是in指令，qemu只能把得到的数据写到kvm_run中，kvm必须在下一次vmentry的时候，将qemu得到的数据放到相应的位置，所以，在handle_io中，如果是in或者string指令，没有调用skip_emulated_instruction，这样，在qemu完成in或者一次out之后，还会在同样的地方发生vmexit，这样再由emulator完成相应的处理，针对string类型的指令，emulator会进行解码等操作，确认io的次数和源操作数、目的操作数等。</p>
<p>流程：handle_io-&gt;emulate_instruction-&gt;x86_emulate_instruction对指令的decode，在过程中会调用到em_in和em_out（这两个函数最后调用的emulator_pio_in_emulated中先通过和上面PIO一样的函数emulator_pio_in_out，正确返回表明qemu已经将模拟出的数据返回到参数val了，则可直接memcpy完成具体的将从qemu中得到的数据写到正确位置vcpu-&gt;arch.pio_data），设置如果是out，下次到KVM时直接进入emulator，如果是in，注册vcpu-&gt;arch.complete_userspace_io = complete_emulated_pio;需要在下次qemu进入kvm的时候，完成io，实际上就是将qemu得到的数据写到正确的位置。下次进入kvm，如果要完成in指令，会在函数kvm_arch_vcpu_ioctl_run中调用注册的complete_emulated_pio会再次调用emulate_instruction将数据写到正确位置（这次不用解码，而是直接em_in）。</p>
]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>qemu</tag>
        <tag>kvm</tag>
      </tags>
  </entry>
  <entry>
    <title>libvirt操作前端虚机</title>
    <url>/2022/06/10/libvirt%E6%93%8D%E4%BD%9C%E5%89%8D%E7%AB%AF%E8%99%9A%E6%9C%BA/</url>
    <content><![CDATA[<h2 id="virsh-create"><a href="#virsh-create" class="headerlink" title="virsh create"></a>virsh create</h2><p>xml配置</p>
<span id="more"></span>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">domain</span> <span class="attr">type</span>=<span class="string">&quot;kvm&quot;</span> <span class="attr">xmlns:qemu</span>=<span class="string">&#x27;http://libvirt.org/schemas/domain/qemu/1.0&#x27;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>vm0<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">uuid</span>&gt;</span>d37f5411-b296-11ed-8e6c-0c48c6c879e4<span class="tag">&lt;/<span class="name">uuid</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">memory</span> <span class="attr">unit</span>=<span class="string">&quot;KiB&quot;</span>&gt;</span>2097152<span class="tag">&lt;/<span class="name">memory</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">vcpu</span> <span class="attr">placement</span>=<span class="string">&quot;static&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">vcpu</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">os</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">type</span> <span class="attr">arch</span>=<span class="string">&quot;x86_64&quot;</span> <span class="attr">machine</span>=<span class="string">&quot;pc-i440fx-2.1&quot;</span>&gt;</span>hvm<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">os</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">features</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">acpi</span>&gt;</span><span class="tag">&lt;/<span class="name">acpi</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">features</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">clock</span> <span class="attr">offset</span>=<span class="string">&quot;utc&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">clock</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">on_poweroff</span>&gt;</span>destroy<span class="tag">&lt;/<span class="name">on_poweroff</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">on_reboot</span>&gt;</span>restart<span class="tag">&lt;/<span class="name">on_reboot</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">on_crash</span>&gt;</span>destroy<span class="tag">&lt;/<span class="name">on_crash</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">devices</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">emulator</span>&gt;</span>/home/corsica-sim/qemu-system-x86_64-vdpa<span class="tag">&lt;/<span class="name">emulator</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">disk</span> <span class="attr">device</span>=<span class="string">&quot;disk&quot;</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">target</span> <span class="attr">bus</span>=<span class="string">&quot;ide&quot;</span> <span class="attr">dev</span>=<span class="string">&quot;hda&quot;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">source</span> <span class="attr">file</span>=<span class="string">&quot;/home/centos8.4-vm0.qcow2&quot;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">driver</span> <span class="attr">type</span>=<span class="string">&quot;qcow2&quot;</span> <span class="attr">name</span>=<span class="string">&quot;qemu&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">disk</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">interface</span> <span class="attr">type</span>=<span class="string">&#x27;vdpa&#x27;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">source</span> <span class="attr">dev</span>=<span class="string">&#x27;/dev/vhost-vdpa-3&#x27;</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">address</span> <span class="attr">type</span>=<span class="string">&#x27;pci&#x27;</span> <span class="attr">domain</span>=<span class="string">&#x27;0x0000&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;0x00&#x27;</span> <span class="attr">slot</span>=<span class="string">&#x27;0x07&#x27;</span> <span class="attr">function</span>=<span class="string">&#x27;0x0&#x27;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">memballoon</span> <span class="attr">model</span>=<span class="string">&#x27;virtio&#x27;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&#x27;balloon0&#x27;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">address</span> <span class="attr">type</span>=<span class="string">&#x27;pci&#x27;</span> <span class="attr">domain</span>=<span class="string">&#x27;0x0000&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;0x00&#x27;</span> <span class="attr">slot</span>=<span class="string">&#x27;0x08&#x27;</span> <span class="attr">function</span>=<span class="string">&#x27;0x0&#x27;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">memballoon</span>&gt;</span>	</span><br><span class="line">		<span class="tag">&lt;<span class="name">serial</span> <span class="attr">type</span>=<span class="string">&quot;tcp&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">source</span> <span class="attr">mode</span>=<span class="string">&quot;bind&quot;</span> <span class="attr">host</span>=<span class="string">&quot;127.0.0.1&quot;</span> <span class="attr">service</span>=<span class="string">&quot;4319&quot;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">protocol</span> <span class="attr">type</span>=<span class="string">&quot;telnet&quot;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">target</span> <span class="attr">port</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">serial</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">devices</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">qemu:commandline</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">qemu:arg</span> <span class="attr">value</span>=<span class="string">&#x27;-cpu&#x27;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">qemu:arg</span> <span class="attr">value</span>=<span class="string">&#x27;host&#x27;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">qemu:arg</span> <span class="attr">value</span>=<span class="string">&#x27;-net&#x27;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">qemu:arg</span> <span class="attr">value</span>=<span class="string">&#x27;nic&#x27;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">qemu:arg</span> <span class="attr">value</span>=<span class="string">&#x27;-net&#x27;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">qemu:arg</span> <span class="attr">value</span>=<span class="string">&#x27;user,hostfwd=tcp::5022-:22&#x27;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">qemu:commandline</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">domain</span> <span class="attr">type</span>=<span class="string">&quot;kvm&quot;</span> <span class="attr">xmlns:qemu</span>=<span class="string">&#x27;http://libvirt.org/schemas/domain/qemu/1.0&#x27;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">name</span>&gt;</span>vm1<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">uuid</span>&gt;</span>d37f5411-b296-11ed-8e6c-0c48c6c879e5<span class="tag">&lt;/<span class="name">uuid</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">memory</span> <span class="attr">unit</span>=<span class="string">&quot;KiB&quot;</span>&gt;</span>2097152<span class="tag">&lt;/<span class="name">memory</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">vcpu</span> <span class="attr">placement</span>=<span class="string">&quot;static&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">vcpu</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">os</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">type</span> <span class="attr">arch</span>=<span class="string">&quot;x86_64&quot;</span> <span class="attr">machine</span>=<span class="string">&quot;pc-i440fx-2.1&quot;</span>&gt;</span>hvm<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">os</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">features</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">acpi</span>&gt;</span><span class="tag">&lt;/<span class="name">acpi</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">features</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">clock</span> <span class="attr">offset</span>=<span class="string">&quot;utc&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">clock</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">on_poweroff</span>&gt;</span>destroy<span class="tag">&lt;/<span class="name">on_poweroff</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">on_reboot</span>&gt;</span>restart<span class="tag">&lt;/<span class="name">on_reboot</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">on_crash</span>&gt;</span>destroy<span class="tag">&lt;/<span class="name">on_crash</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">devices</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">emulator</span>&gt;</span>/home/corsica-sim/qemu-system-x86_64-vdpa<span class="tag">&lt;/<span class="name">emulator</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">disk</span> <span class="attr">device</span>=<span class="string">&quot;disk&quot;</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">target</span> <span class="attr">bus</span>=<span class="string">&quot;ide&quot;</span> <span class="attr">dev</span>=<span class="string">&quot;hda&quot;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">source</span> <span class="attr">file</span>=<span class="string">&quot;/home/centos8.4-vm1.qcow2&quot;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">driver</span> <span class="attr">type</span>=<span class="string">&quot;qcow2&quot;</span> <span class="attr">name</span>=<span class="string">&quot;qemu&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">disk</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">interface</span> <span class="attr">type</span>=<span class="string">&#x27;vdpa&#x27;</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">source</span> <span class="attr">dev</span>=<span class="string">&#x27;/dev/vhost-vdpa-4&#x27;</span>/&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">address</span> <span class="attr">type</span>=<span class="string">&#x27;pci&#x27;</span> <span class="attr">domain</span>=<span class="string">&#x27;0x0000&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;0x00&#x27;</span> <span class="attr">slot</span>=<span class="string">&#x27;0x07&#x27;</span> <span class="attr">function</span>=<span class="string">&#x27;0x0&#x27;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">memballoon</span> <span class="attr">model</span>=<span class="string">&#x27;virtio&#x27;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">alias</span> <span class="attr">name</span>=<span class="string">&#x27;balloon0&#x27;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">address</span> <span class="attr">type</span>=<span class="string">&#x27;pci&#x27;</span> <span class="attr">domain</span>=<span class="string">&#x27;0x0000&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;0x00&#x27;</span> <span class="attr">slot</span>=<span class="string">&#x27;0x08&#x27;</span> <span class="attr">function</span>=<span class="string">&#x27;0x0&#x27;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">memballoon</span>&gt;</span>	</span><br><span class="line">		<span class="tag">&lt;<span class="name">serial</span> <span class="attr">type</span>=<span class="string">&quot;tcp&quot;</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">source</span> <span class="attr">mode</span>=<span class="string">&quot;bind&quot;</span> <span class="attr">host</span>=<span class="string">&quot;127.0.0.1&quot;</span> <span class="attr">service</span>=<span class="string">&quot;4329&quot;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">protocol</span> <span class="attr">type</span>=<span class="string">&quot;telnet&quot;</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">target</span> <span class="attr">port</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">serial</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">devices</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">qemu:commandline</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">qemu:arg</span> <span class="attr">value</span>=<span class="string">&#x27;-cpu&#x27;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">qemu:arg</span> <span class="attr">value</span>=<span class="string">&#x27;host&#x27;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">qemu:arg</span> <span class="attr">value</span>=<span class="string">&#x27;-net&#x27;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">qemu:arg</span> <span class="attr">value</span>=<span class="string">&#x27;nic&#x27;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">qemu:arg</span> <span class="attr">value</span>=<span class="string">&#x27;-net&#x27;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">qemu:arg</span> <span class="attr">value</span>=<span class="string">&#x27;user,hostfwd=tcp::6022-:22&#x27;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">qemu:commandline</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="vm创建"><a href="#vm创建" class="headerlink" title="vm创建"></a>vm创建</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ./virsh -c qemu+tcp:///system create vm0.xml</span></span><br><span class="line"><span class="comment">#./virsh -c qemu+tcp:///system create vm1.xml</span></span><br></pre></td></tr></table></figure>

<h2 id="telnet登录，配置dhclient"><a href="#telnet登录，配置dhclient" class="headerlink" title="telnet登录，配置dhclient"></a>telnet登录，配置dhclient</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">telnet 127.0.0.1 4319</span><br><span class="line">telnet 127.0.0.1 4329</span><br></pre></td></tr></table></figure>

<p>用户名密码：root/root</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># telnet 127.0.0.1 4319</span></span><br><span class="line">Trying 127.0.0.1...</span><br><span class="line">Connected to 127.0.0.1.</span><br><span class="line">Escape character is <span class="string">&#x27;^]&#x27;</span>.</span><br><span class="line"></span><br><span class="line">CentOS Linux 8</span><br><span class="line">Kernel 4.18.0-305.30.1.jmnd2.el8.x86_64 on an x86_64</span><br><span class="line"></span><br><span class="line">Activate the web console with: systemctl <span class="built_in">enable</span> --now cockpit.socket</span><br><span class="line"></span><br><span class="line">148-VM0 login: root</span><br><span class="line">Password: </span><br><span class="line">Last login: Thu Mar  2 13:56:03 from 10.0.2.2</span><br><span class="line">[root@148-VM0 ~]<span class="comment"># </span></span><br><span class="line">[root@148-VM0 ~]<span class="comment"># dhclient</span></span><br><span class="line">[root@148-VM0 ~]<span class="comment"># </span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># telnet 127.0.0.1 4329</span></span><br><span class="line">Trying 127.0.0.1...</span><br><span class="line">Connected to 127.0.0.1.</span><br><span class="line">Escape character is <span class="string">&#x27;^]&#x27;</span>.</span><br><span class="line"></span><br><span class="line">CentOS Linux 8</span><br><span class="line">Kernel 4.18.0-305.30.1.jmnd2.el8.x86_64 on an x86_64</span><br><span class="line"></span><br><span class="line">Activate the web console with: systemctl <span class="built_in">enable</span> --now cockpit.socket</span><br><span class="line"></span><br><span class="line">VM1 login: root</span><br><span class="line">Password: </span><br><span class="line">Last login: Thu Mar  9 20:16:06 from 10.0.2.2</span><br><span class="line">[root@VM1 ~]<span class="comment"># dhclient</span></span><br><span class="line">[root@VM1 ~]<span class="comment"># </span></span><br></pre></td></tr></table></figure>

<h2 id="ssh登录"><a href="#ssh登录" class="headerlink" title="ssh登录"></a>ssh登录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh root@127.1 -p 5022</span><br><span class="line">ssh root@127.1 -p 6022</span><br></pre></td></tr></table></figure>

<h2 id="virsh-list"><a href="#virsh-list" class="headerlink" title="virsh list"></a>virsh list</h2><h1 id="virsh-c-qemu-tcp-system-list"><a href="#virsh-c-qemu-tcp-system-list" class="headerlink" title="./virsh -c qemu+tcp:///system list"></a>./virsh -c qemu+tcp:///system list</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> Id   Name   State</span><br><span class="line">----------------------</span><br><span class="line"> 2    vm0    running</span><br><span class="line"> 3    vm1    running</span><br></pre></td></tr></table></figure>

<h2 id="virsh-detach-device"><a href="#virsh-detach-device" class="headerlink" title="virsh detach-device"></a>virsh detach-device</h2><p>xml配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">interface</span> <span class="attr">type</span>=<span class="string">&#x27;vdpa&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">dev</span>=<span class="string">&#x27;/dev/vhost-vdpa-3&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">address</span> <span class="attr">type</span>=<span class="string">&#x27;pci&#x27;</span> <span class="attr">domain</span>=<span class="string">&#x27;0x0000&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;0x00&#x27;</span> <span class="attr">slot</span>=<span class="string">&#x27;0x07&#x27;</span> <span class="attr">function</span>=<span class="string">&#x27;0x0&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">interface</span> <span class="attr">type</span>=<span class="string">&#x27;vdpa&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">dev</span>=<span class="string">&#x27;/dev/vhost-vdpa-4&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">address</span> <span class="attr">type</span>=<span class="string">&#x27;pci&#x27;</span> <span class="attr">domain</span>=<span class="string">&#x27;0x0000&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;0x00&#x27;</span> <span class="attr">slot</span>=<span class="string">&#x27;0x07&#x27;</span> <span class="attr">function</span>=<span class="string">&#x27;0x0&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="virsh-detach-device-1"><a href="#virsh-detach-device-1" class="headerlink" title="virsh detach-device"></a>virsh detach-device</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ./virsh -c qemu+tcp:///system detach-device vm0 vdpa-3.xml</span></span><br><span class="line">Device detached successfully</span><br></pre></td></tr></table></figure>
<p>查看vm0上ens7已被detach<br><img src="b213bca99c7fabc492eef79969743956c4964253c7aa94dd17233ba5442dff06.png" alt="图 1">  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ./virsh -c qemu+tcp:///system detach-device vm1 vdpa-4.xml</span></span><br><span class="line">Device detached successfully</span><br></pre></td></tr></table></figure>

<p>查看vm1上ens7已被detach<br><img src="5eeaf596a3267386efc98c323c9c31d4dd479baef6899690bf2195b1ea86c608.png" alt="图 2">  </p>
<h2 id="virsh-attach-device"><a href="#virsh-attach-device" class="headerlink" title="virsh attach-device"></a>virsh attach-device</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ./virsh -c qemu+tcp:///system attach-device vm0 vdpa-3.xml</span></span><br><span class="line">Device attached successfully</span><br><span class="line"></span><br><span class="line"><span class="comment"># ./virsh -c qemu+tcp:///system attach-device vm1 vdpa-4.xml</span></span><br><span class="line">Device attached successfully</span><br></pre></td></tr></table></figure>

<p><img src="655b0b1cd2cc8ebf30538a7cf872e22971fa9b1cf022146d5e547d81771528bc.png" alt="图 3"><br><img src="f062b248bdbac0dfc9dbe9290413a955e5a51078395aa8b1fe8849bfc64483f5.png" alt="图 4">  </p>
<h2 id="virsh-destroy"><a href="#virsh-destroy" class="headerlink" title="virsh destroy"></a>virsh destroy</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ./virsh -c qemu+tcp:///system destroy vm0</span></span><br><span class="line">Domain <span class="string">&#x27;vm0&#x27;</span> destroyed</span><br><span class="line"></span><br><span class="line"><span class="comment"># ./virsh -c qemu+tcp:///system destroy vm1</span></span><br><span class="line">Domain <span class="string">&#x27;vm1&#x27;</span> destroyed</span><br><span class="line"></span><br><span class="line"><span class="comment"># ./virsh -c qemu+tcp:///system list</span></span><br><span class="line"> Id   Name   State</span><br><span class="line">--------------------</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>Libvirt</tag>
      </tags>
  </entry>
  <entry>
    <title>virsh常用命令</title>
    <url>/2022/06/09/virsh%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="virsh常用命令选项"><a href="#virsh常用命令选项" class="headerlink" title="virsh常用命令选项"></a>virsh常用命令选项</h2><span id="more"></span>

<table>
    <tr>
        <th>命令选项</th><th>描述</th>
    </tr>
    <tr>
        <td>virsh create xmlfile.xml</td><td>从 XML 配置文件创建和启动访客</td>
    </tr>
    <tr>
        <td>virsh list --all</td><td>列示主机上的所有访客</td>
    </tr>
    <tr>
        <td>virsh dumpxml guest_name</td><td>以输出文件的形式创建访客的 XML 配置文件</td>
    </tr>
    <tr>
        <td>virsh start guest_name</td><td>启动处于不活动状态的访客</td>
    </tr>
    <tr>
        <td>virsh destroy guest_name</td><td>立即停止该访客</td>
    </tr>
    <tr>
        <td>virsh define xmlfile.xml</td><td>从 XML 配置文件创建访客。该访客未启动</td>
    </tr>
    <tr>
        <td>virsh reboot guest_name</td><td>重新启动该访客</td>
    </tr>
    <tr>
        <td>virsh resume guest_name</td><td>恢复已暂停的访客</td>
    </tr>
    <tr>
        <td>virsh undefine guest_name</td><td>删除该访客</td>
    </tr>
    <tr>
        <td>virsh suspend guest_name</td><td>暂停该访客</td>
    </tr>
    <tr>
        <td>virsh attach-device guest_name device.xml</td><td>设备热插</td>
    </tr>
    <tr>
        <td>virsh detach-device guest_name device.xml</td><td>设备热拔</td>
    </tr>
    <tr>
        <td>virsh qemu-monitor-command vm</td><td>qmp命令</td>
    </tr>
</table>

]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>Libvirt</tag>
      </tags>
  </entry>
  <entry>
    <title>Libvirt源码编译</title>
    <url>/2022/06/08/Libvirt%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h2 id="源码路径"><a href="#源码路径" class="headerlink" title="源码路径"></a>源码路径</h2><p><a href="https://download.libvirt.org/libvirt-8.3.0.tar.xz">https://download.libvirt.org/libvirt-8.3.0.tar.xz</a></p>
<span id="more"></span>

<h2 id="裁剪"><a href="#裁剪" class="headerlink" title="裁剪"></a>裁剪</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">option(<span class="string">&#x27;no_git&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;boolean&#x27;</span>, value: <span class="literal">false</span>, description: <span class="string">&#x27;Disable git submodule update&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;packager&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;string&#x27;</span>, value: <span class="string">&#x27;&#x27;</span>, description: <span class="string">&#x27;Extra packager name&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;packager_version&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;string&#x27;</span>, value: <span class="string">&#x27;&#x27;</span>, description: <span class="string">&#x27;Extra packager version&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;system&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;boolean&#x27;</span>, value: <span class="literal">false</span>, description: <span class="string">&#x27;Set install paths to system ones&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;runstatedir&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;string&#x27;</span>, value: <span class="string">&#x27;&#x27;</span>, description: <span class="string">&#x27;State directory for temporary sockets, pid files, etc&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;expensive_tests&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;set the default for enabling expensive tests (long timeouts)&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;test_coverage&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;boolean&#x27;</span>, value: <span class="literal">false</span>, description: <span class="string">&#x27;turn on code coverage instrumentation&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;git_werror&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;use -Werror if building from GIT&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;rpath&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;auto&#x27;</span>, description: <span class="string">&#x27;whether to include rpath information in installed binaries and libraries&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;docdir&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;string&#x27;</span>, value: <span class="string">&#x27;&#x27;</span>, description: <span class="string">&#x27;documentation installation directory&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;docs&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;whether to generate documentation&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;tests&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;whether to build tests&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># build dependencies options</span></span><br><span class="line">option(<span class="string">&#x27;apparmor&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;apparmor support&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;attr&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;attr support&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;audit&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;audit support&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;bash_completion&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;bash-completion support&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;bash_completion_dir&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;string&#x27;</span>, value: <span class="string">&#x27;&#x27;</span>, description: <span class="string">&#x27;directory containing bash completion scripts&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;blkid&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;blkid support&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;capng&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;cap-ng support&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;curl&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;curl support&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;fuse&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;fuse support&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;glusterfs&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;glusterfs support&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;libiscsi&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;libiscsi support&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;libnl&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;libnl support&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;libpcap&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;libpcap support&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;libssh&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;libssh support&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;libssh2&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;libssh2 support&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;netcf&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;netcf support&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;nls&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;nls support&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;numactl&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;numactl support&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;openwsman&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;openwsman support&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;pciaccess&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;pciaccess support&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;polkit&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;use PolicyKit for UNIX socket access checks&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;readline&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;readline support&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;sanlock&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;sanlock support&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;sasl&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;sasl support&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;selinux&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;selinux support&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;selinux_mount&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;string&#x27;</span>, value: <span class="string">&#x27;&#x27;</span>, description: <span class="string">&#x27;set SELinux mount point&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;udev&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;udev support&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;wireshark_dissector&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;wireshark support&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;wireshark_plugindir&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;string&#x27;</span>, value: <span class="string">&#x27;&#x27;</span>, description: <span class="string">&#x27;wireshark plugins directory for use when installing wireshark plugin&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;yajl&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;enabled&#x27;</span>, description: <span class="string">&#x27;yajl support&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># build driver options</span></span><br><span class="line">option(<span class="string">&#x27;driver_bhyve&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;bhyve driver&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;driver_esx&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;esx driver&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;driver_hyperv&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;Hyper-V driver&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;driver_interface&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;host interface driver&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;driver_libvirtd&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;enabled&#x27;</span>, description: <span class="string">&#x27;libvirtd driver&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;driver_libxl&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;libxenlight driver&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;driver_lxc&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;Linux Container driver&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;driver_ch&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;Cloud-Hypervisor driver&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;ch_user&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;string&#x27;</span>, value: <span class="string">&#x27;&#x27;</span>, description: <span class="string">&#x27;username to run Cloud-Hypervisor system instance as&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;ch_group&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;string&#x27;</span>, value: <span class="string">&#x27;&#x27;</span>, description: <span class="string">&#x27;groupname to run Cloud-Hypervisor system instance as&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;driver_network&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;virtual network driver&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;driver_openvz&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;OpenVZ driver&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;driver_qemu&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;enabled&#x27;</span>, description: <span class="string">&#x27;QEMU/KVM driver&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;qemu_user&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;string&#x27;</span>, value: <span class="string">&#x27;&#x27;</span>, description: <span class="string">&#x27;username to run QEMU system instance as&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;qemu_group&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;string&#x27;</span>, value: <span class="string">&#x27;&#x27;</span>, description: <span class="string">&#x27;groupname to run QEMU system instance as&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;qemu_moddir&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;string&#x27;</span>, value: <span class="string">&#x27;&#x27;</span>, description: <span class="string">&#x27;set the directory where QEMU modules are located&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;qemu_datadir&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;string&#x27;</span>, value: <span class="string">&#x27;&#x27;</span>, description: <span class="string">&#x27;set the directory where QEMU shared data is located&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;driver_remote&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;enabled&#x27;</span>, description: <span class="string">&#x27;remote driver&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;remote_default_mode&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;combo&#x27;</span>, choices: [<span class="string">&#x27;legacy&#x27;</span>, <span class="string">&#x27;direct&#x27;</span>], value: <span class="string">&#x27;direct&#x27;</span>, description: <span class="string">&#x27;remote driver default mode&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;driver_secrets&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;local secrets management driver&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;driver_test&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;test driver&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;driver_vbox&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;VirtualBox XPCOMC driver&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;vbox_xpcomc_dir&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;string&#x27;</span>, value: <span class="string">&#x27;&#x27;</span>, description: <span class="string">&#x27;Location of directory containing VirtualBox XPCOMC library&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;driver_vmware&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;VMware driver&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;driver_vz&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;Virtuozzo driver&#x27;</span>)</span><br><span class="line"></span><br><span class="line">option(<span class="string">&#x27;secdriver_apparmor&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;use AppArmor security driver&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;apparmor_profiles&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;install apparmor profiles&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;secdriver_selinux&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;use SELinux security driver&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># storage driver options</span></span><br><span class="line">option(<span class="string">&#x27;storage_dir&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;directory backend for the storage driver&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;storage_disk&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;GPartd Disk backend for the storage driver&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;storage_fs&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;FileSystem backend for the storage driver&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;storage_gluster&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;Gluster backend for the storage driver&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;storage_iscsi&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;iscsi backend for the storage driver&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;storage_iscsi_direct&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;iscsi-direct backend for the storage driver&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;storage_lvm&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;LVM backend for the storage driver&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;storage_mpath&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;mpath backend for the storage driver&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;storage_rbd&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;RADOS Block Device backend for the storage driver&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;storage_scsi&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;SCSI backend for the storage driver&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;storage_sheepdog&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;Sheepdog backend for the storage driver&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;storage_vstorage&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;Virtuozzo storage backend for the storage driver&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;storage_zfs&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;ZFS backend for the storage driver&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># build feature options</span></span><br><span class="line">option(<span class="string">&#x27;chrdev_lock_files&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;string&#x27;</span>, value: <span class="string">&#x27;&#x27;</span>, description: <span class="string">&#x27;location for UUCP style lock files for character devices (leave empty for default paths on some platforms)&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;dtrace&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;use dtrace for static probing&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;firewalld&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;firewalld support&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;firewalld_zone&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;whether to install firewalld libvirt zone&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;host_validate&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;build virt-host-validate&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;init_script&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;combo&#x27;</span>, choices: [<span class="string">&#x27;systemd&#x27;</span>, <span class="string">&#x27;openrc&#x27;</span>, <span class="string">&#x27;check&#x27;</span>, <span class="string">&#x27;none&#x27;</span>], value: <span class="string">&#x27;check&#x27;</span>, description: <span class="string">&#x27;Style of init script to install&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;loader_nvram&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;string&#x27;</span>, value: <span class="string">&#x27;&#x27;</span>, description: <span class="string">&#x27;Pass list of pairs of &lt;loader&gt;:&lt;nvram&gt; paths. Both pairs and list items are separated by a colon.&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;login_shell&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;build virt-login-shell&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;nss&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;enable Name Service Switch plugin for resolving guest IP addresses&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;numad&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;use numad to manage CPU placement dynamically&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;pm_utils&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;disabled&#x27;</span>, description: <span class="string">&#x27;use pm-utils for power management&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;sysctl_config&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;feature&#x27;</span>, value: <span class="string">&#x27;enabled&#x27;</span>, description: <span class="string">&#x27;Whether to install sysctl configs&#x27;</span>)</span><br><span class="line">option(<span class="string">&#x27;tls_priority&#x27;</span>, <span class="built_in">type</span>: <span class="string">&#x27;string&#x27;</span>, value: <span class="string">&#x27;NORMAL&#x27;</span>, description: <span class="string">&#x27;set the default TLS session priority string&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">CUR_PATH=$(<span class="built_in">dirname</span> $(<span class="built_in">readlink</span> -f <span class="string">&quot;<span class="variable">$0</span>&quot;</span>))</span><br><span class="line"></span><br><span class="line">INSTALL_PATH=<span class="variable">$&#123;CUR_PATH&#125;</span>/libvirt_install_dir</span><br><span class="line">VERSION=8.3.0</span><br><span class="line">SRC_PATH=<span class="variable">$&#123;CUR_PATH&#125;</span>/libvirt-<span class="variable">$&#123;VERSION&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$&#123;INSTALL_PATH&#125;</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;SRC_PATH&#125;</span></span><br><span class="line"><span class="built_in">rm</span> -rf build</span><br><span class="line">meson build --prefix=<span class="variable">$INSTALL_PATH</span> --debug</span><br><span class="line">meson compile -C build -j `grep -c ^processor /proc/cpuinfo`</span><br><span class="line">meson install -C build</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>Libvirt</tag>
      </tags>
  </entry>
  <entry>
    <title>openstack T版本部署</title>
    <url>/2022/06/08/openstack-T%E7%89%88%E6%9C%AC%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<blockquote>
<p>参考：<br><a href="https://www.modb.pro/db/524431">https://www.modb.pro/db/524431</a><br><a href="https://docs.openstack.org/zh_CN/install-guide/environment-memcached-rdo.html">https://docs.openstack.org/zh_CN/install-guide/environment-memcached-rdo.html</a></p>
</blockquote>
<span id="more"></span>

<h2 id="主机名称配置"><a href="#主机名称配置" class="headerlink" title="主机名称配置"></a>主机名称配置</h2><p>controller节点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostnamectl set-hostname controller</span><br></pre></td></tr></table></figure>

<p>compute节点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostnamectl set-hostname compute</span><br></pre></td></tr></table></figure>

<h2 id="主机映射配置"><a href="#主机映射配置" class="headerlink" title="主机映射配置"></a>主机映射配置</h2><p>controller节点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/hosts</span><br><span class="line"></span><br><span class="line">#添加：</span><br><span class="line">10.20.69.56 controller</span><br><span class="line">10.20.70.20 compute</span><br><span class="line">#保存并退出：wq</span><br><span class="line"></span><br><span class="line">ping -c 4 compute</span><br></pre></td></tr></table></figure>

<h2 id="网络时间服务配置"><a href="#网络时间服务配置" class="headerlink" title="网络时间服务配置"></a>网络时间服务配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y chrony</span><br><span class="line">vi /etc/chrony.conf</span><br></pre></td></tr></table></figure>

<p>控制节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> #注释所有server</span><br><span class="line"> #添加：</span><br><span class="line">server controller iburst</span><br><span class="line">allow</span><br><span class="line"> #保存并退出：wq</span><br></pre></td></tr></table></figure>

<p>计算节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> #注释所有server</span><br><span class="line"> #添加：</span><br><span class="line">server controller iburst</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl enable  chronyd.service;systemctl start chronyd.service</span><br><span class="line">systemctl status chronyd</span><br><span class="line">chronyc sources</span><br></pre></td></tr></table></figure>

<h2 id="安装OpenStack包"><a href="#安装OpenStack包" class="headerlink" title="安装OpenStack包"></a>安装OpenStack包</h2><p>所有节点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y centos-release-openstack-train</span><br><span class="line"></span><br><span class="line">cd /etc/yum.repos.d/</span><br><span class="line">sed -i -e &quot;s|mirrorlist=|#mirrorlist=|g&quot; advanced-virtualization.repo CentOS-Messaging-rabbitmq.repo CentOS-OpenStack-train.repo CentOS-Storage-common.repo  ceph-nautilus.repo</span><br><span class="line">sed -i -e &quot;s|#baseurl=http://mirror.centos.org|baseurl=http://vault.centos.org|g&quot; advanced-virtualization.repo CentOS-Messaging-rabbitmq.repo CentOS-OpenStack-train.repo CentOS-Storage-common.repo  ceph-nautilus.repo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">yum clean all &amp;&amp; yum makecache</span><br><span class="line"></span><br><span class="line">yum upgrade --allowerasing    #如果升级过程包含新内核，请重新启动主机以激活它。</span><br><span class="line">yum install python3-openstackclient openstack-selinux -y</span><br></pre></td></tr></table></figure>


<h2 id="安装SQL数据库"><a href="#安装SQL数据库" class="headerlink" title="安装SQL数据库"></a>安装SQL数据库</h2><p>设置进程最大可打开的文件数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/security/limits.conf</span><br><span class="line">添加</span><br><span class="line">* soft nofile 65535</span><br><span class="line">* hard nofile 65535</span><br></pre></td></tr></table></figure>

<p>controller节点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install mariadb mariadb-server python2-PyMySQL -y</span><br><span class="line"></span><br><span class="line">vi /etc/my.cnf.d/openstack.cnf</span><br><span class="line">#创建和编辑</span><br><span class="line">[mysqld]</span><br><span class="line">bind-address = 192.168.200.10</span><br><span class="line">default-storage-engine = innodb</span><br><span class="line">innodb_file_per_table = on</span><br><span class="line">max_connections = 4096</span><br><span class="line">collation-server = utf8_general_ci</span><br><span class="line">character-set-server = utf8</span><br><span class="line">#保存并退出：wq</span><br><span class="line"></span><br><span class="line">systemctl enable mariadb.service;systemctl start mariadb.service</span><br><span class="line"></span><br><span class="line">systemctl status mariadb.service</span><br><span class="line"></span><br><span class="line">mysql_secure_installation</span><br><span class="line"></span><br><span class="line">#输入root密码，默认为空，点击回车</span><br><span class="line">Set root password? [Y/n] y  </span><br><span class="line">#输入root密码&quot;000000&quot;两次</span><br><span class="line">Remove anonymous users? [Y/n] y</span><br><span class="line"></span><br><span class="line">Disallow root login remotely? [Y/n] n</span><br><span class="line"></span><br><span class="line">Remove test database and access to it? [Y/n] y</span><br><span class="line"></span><br><span class="line">Reload privilege tables now? [Y/n] y</span><br></pre></td></tr></table></figure>


<h2 id="安装消息队列-rabbitMQ"><a href="#安装消息队列-rabbitMQ" class="headerlink" title="安装消息队列 rabbitMQ"></a>安装消息队列 rabbitMQ</h2><p>controller节点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install epel-release</span><br><span class="line">yum install -y rabbitmq-server </span><br><span class="line">systemctl enable rabbitmq-server.service</span><br><span class="line">systemctl restart rabbitmq-server.service</span><br><span class="line">systemctl status rabbitmq-server.service</span><br><span class="line"></span><br><span class="line">rabbitmqctl add_user openstack 000000</span><br><span class="line">rabbitmqctl set_permissions openstack &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</span><br><span class="line">#查看是否创建成功</span><br><span class="line">rabbitmqctl list_users</span><br><span class="line">#查看需要启动的服务</span><br><span class="line"> rabbitmq-plugins list</span><br><span class="line">#开启图形化界面(选做，可通过http://10.20.69.56:15672访问，用户名guest，密码guest)</span><br><span class="line">rabbitmq-plugins enable rabbitmq_management rabbitmq_management_agent </span><br></pre></td></tr></table></figure>
<h2 id="安装memcahce服务（内存缓存服务）"><a href="#安装memcahce服务（内存缓存服务）" class="headerlink" title="安装memcahce服务（内存缓存服务）"></a>安装memcahce服务（内存缓存服务）</h2><p>controller节点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y memcached python3-memcached</span><br><span class="line">vim /etc/sysconfig/memcached</span><br><span class="line">#将服务配置为使用控制器节点的管理 IP 地址。这是为了允许其他节点通过管理网络访问：</span><br><span class="line">OPTIONS=&quot;-l 127.0.0.1,::1,controller&quot;</span><br><span class="line">#保存并退出：wq</span><br><span class="line"></span><br><span class="line">systemctl enable memcached.service;systemctl start memcached.service</span><br><span class="line"></span><br><span class="line">#查看运行状态</span><br><span class="line">systemctl status  memcached.service</span><br></pre></td></tr></table></figure>

<h2 id="安装etcd服务"><a href="#安装etcd服务" class="headerlink" title="安装etcd服务"></a>安装etcd服务</h2><p>controller节点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y etcd </span><br><span class="line">vim /etc/etcd/etcd.conf </span><br><span class="line">#删除原内容，添加以下内容</span><br><span class="line">#[Member]</span><br><span class="line">ETCD_DATA_DIR=&quot;/var/lib/etcd/default.etcd&quot;</span><br><span class="line">ETCD_LISTEN_PEER_URLS=&quot;http://10.20.69.56:2380&quot;</span><br><span class="line">ETCD_LISTEN_CLIENT_URLS=&quot;http://10.20.69.56:2379&quot;</span><br><span class="line">ETCD_NAME=&quot;controller&quot;</span><br><span class="line">#[Clustering]</span><br><span class="line">ETCD_INITIAL_ADVERTISE_PEER_URLS=&quot;http://10.20.69.56:2380&quot;</span><br><span class="line">ETCD_ADVERTISE_CLIENT_URLS=&quot;http://10.20.69.56:2379&quot;</span><br><span class="line">ETCD_INITIAL_CLUSTER=&quot;controller=http://10.20.69.56:2380&quot;</span><br><span class="line">ETCD_INITIAL_CLUSTER_TOKEN=&quot;etcd-cluster-01&quot;</span><br><span class="line">ETCD_INITIAL_CLUSTER_STATE=&quot;new&quot;</span><br><span class="line">#保存并退出：wq</span><br><span class="line"></span><br><span class="line">systemctl enable etcd;systemctl start etcd</span><br><span class="line">systemctl status etcd</span><br></pre></td></tr></table></figure>

<h2 id="安装Keystone服务"><a href="#安装Keystone服务" class="headerlink" title="安装Keystone服务"></a>安装Keystone服务</h2><p>controller节点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -u root -p000000</span><br><span class="line">MariaDB [(none)]&gt; CREATE DATABASE keystone;</span><br><span class="line">MariaDB [(none)]&gt; GRANT ALL PRIVILEGES ON keystone.* TO &#x27;keystone&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;000000&#x27;;</span><br><span class="line">MariaDB [(none)]&gt; GRANT ALL PRIVILEGES ON keystone.* TO &#x27;keystone&#x27;@&#x27;%&#x27;  IDENTIFIED BY  &#x27;000000&#x27;; </span><br><span class="line">MariaDB [(none)]&gt; exit;</span><br><span class="line"></span><br><span class="line">yum install openstack-keystone httpd -y</span><br><span class="line"></span><br><span class="line">yum install python3-mod_wsgi.x86_64 -y</span><br><span class="line"></span><br><span class="line">vim /etc/keystone/keystone.conf</span><br><span class="line">#删除原内容，添加以下内容</span><br><span class="line">[database]</span><br><span class="line">connection = mysql+pymysql://keystone:000000@controller/keystone</span><br><span class="line">[token]</span><br><span class="line">provider = fernet</span><br><span class="line">#保存并退出：wq</span><br><span class="line"></span><br><span class="line">su -s /bin/sh -c &quot;keystone-manage db_sync&quot; keystone           #填充身份服务数据库</span><br><span class="line"></span><br><span class="line">keystone-manage fernet_setup --keystone-user keystone --keystone-group keystone</span><br><span class="line">keystone-manage credential_setup --keystone-user keystone --keystone-group keystone</span><br><span class="line"></span><br><span class="line">keystone-manage bootstrap --bootstrap-password 000000 \</span><br><span class="line">  --bootstrap-admin-url http://controller:5000/v3/ \</span><br><span class="line">  --bootstrap-internal-url http://controller:5000/v3/ \</span><br><span class="line">  --bootstrap-public-url http://controller:5000/v3/ \</span><br><span class="line">  --bootstrap-region-id RegionOne</span><br></pre></td></tr></table></figure>

<h3 id="配置Apache-HTTP"><a href="#配置Apache-HTTP" class="headerlink" title="配置Apache HTTP"></a>配置Apache HTTP</h3><p>controller节点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/httpd/conf/httpd.conf</span><br><span class="line"></span><br><span class="line">#仅添加</span><br><span class="line">ServerName controller</span><br><span class="line">#保存并退出：wq</span><br><span class="line"></span><br><span class="line">ln -s /usr/share/keystone/wsgi-keystone.conf /etc/httpd/conf.d/</span><br><span class="line">systemctl enable httpd.service;systemctl start httpd.service</span><br><span class="line">#设置变量配置管理帐户</span><br><span class="line">export OS_USERNAME=admin</span><br><span class="line">export OS_PASSWORD=000000</span><br><span class="line">export OS_PROJECT_NAME=admin</span><br><span class="line">export OS_USER_DOMAIN_NAME=Default</span><br><span class="line">export OS_PROJECT_DOMAIN_NAME=Default</span><br><span class="line">export OS_AUTH_URL=http://controller:5000/v3</span><br><span class="line">export OS_IDENTITY_API_VERSION=3</span><br></pre></td></tr></table></figure>

<h3 id="创建域、项目、用户和角色"><a href="#创建域、项目、用户和角色" class="headerlink" title="创建域、项目、用户和角色"></a>创建域、项目、用户和角色</h3><p>controller节点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">. /home/rma/unproxy.sh  #去除http代理</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">openstack domain create --description &quot;An Example Domain&quot; example</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">openstack project create --domain default --description &quot;Service Project&quot; service</span><br><span class="line">openstack project create --domain default --description &quot;Demo Project&quot; myproject</span><br><span class="line">openstack user create --domain default --password-prompt myuser             #输入两次密码000000 </span><br><span class="line"></span><br><span class="line">openstack role create myrole</span><br><span class="line">openstack role add --project myproject --user myuser myrole</span><br></pre></td></tr></table></figure>

<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unset OS_AUTH_URL OS_PASSWORD</span><br><span class="line"></span><br><span class="line">openstack --os-auth-url http://controller:5000/v3 \</span><br><span class="line">  --os-project-domain-name Default --os-user-domain-name Default \</span><br><span class="line">  --os-project-name admin --os-username admin token issue</span><br><span class="line">   #密码000000 </span><br><span class="line">openstack --os-auth-url http://controller:5000/v3 \</span><br><span class="line">  --os-project-domain-name Default --os-user-domain-name Default \</span><br><span class="line">  --os-project-name myproject --os-username myuser token issue</span><br><span class="line"> #密码000000 </span><br></pre></td></tr></table></figure>

<h3 id="创建admin与demo用户脚本"><a href="#创建admin与demo用户脚本" class="headerlink" title="创建admin与demo用户脚本"></a>创建admin与demo用户脚本</h3><p>controller节点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim admin-openrc</span><br><span class="line">#新建文件，添加以下内容</span><br><span class="line">export OS_PROJECT_DOMAIN_NAME=Default</span><br><span class="line">export OS_USER_DOMAIN_NAME=Default</span><br><span class="line">export OS_PROJECT_NAME=admin</span><br><span class="line">export OS_USERNAME=admin</span><br><span class="line">export OS_PASSWORD=000000</span><br><span class="line">export OS_AUTH_URL=http://controller:5000/v3</span><br><span class="line">export OS_IDENTITY_API_VERSION=3</span><br><span class="line">export OS_IMAGE_API_VERSION=2</span><br><span class="line">#保存并退出：wq</span><br><span class="line"></span><br><span class="line">vim demo-openrc</span><br><span class="line">#新建文件，添加以下内容</span><br><span class="line">export OS_PROJECT_DOMAIN_NAME=Default</span><br><span class="line">export OS_USER_DOMAIN_NAME=Default</span><br><span class="line">export OS_PROJECT_NAME=myproject</span><br><span class="line">export OS_USERNAME=myuser</span><br><span class="line">export OS_PASSWORD=myuser</span><br><span class="line">export OS_AUTH_URL=http://controller:5000/v3</span><br><span class="line">export OS_IDENTITY_API_VERSION=3</span><br><span class="line">export OS_IMAGE_API_VERSION=2</span><br><span class="line">#保存并退出：wq</span><br><span class="line"></span><br><span class="line">. admin-openrc</span><br><span class="line">openstack token issue</span><br></pre></td></tr></table></figure>

<h2 id="安装Glance服务"><a href="#安装Glance服务" class="headerlink" title="安装Glance服务"></a>安装Glance服务</h2><p>controller节点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -u root -p000000</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; CREATE DATABASE glance;</span><br><span class="line">MariaDB [(none)]&gt; GRANT ALL PRIVILEGES ON glance.* TO &#x27;glance&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;000000&#x27;;</span><br><span class="line">MariaDB [(none)]&gt; GRANT ALL PRIVILEGES ON glance.* TO &#x27;glance&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;000000&#x27;;</span><br><span class="line">MariaDB [(none)]&gt; exit;</span><br><span class="line"></span><br><span class="line">. admin-openrc</span><br><span class="line">openstack user create --domain default --password-prompt glance #密码000000</span><br><span class="line">openstack role add --project service --user glance admin</span><br><span class="line"></span><br><span class="line">openstack service create --name glance \</span><br><span class="line">  --description &quot;OpenStack Image&quot; image</span><br><span class="line">openstack endpoint create --region RegionOne \</span><br><span class="line">  image public http://controller:9292 </span><br><span class="line">openstack endpoint create --region RegionOne \</span><br><span class="line">  image internal http://controller:9292</span><br><span class="line">openstack endpoint create --region RegionOne \</span><br><span class="line">  image admin http://controller:9292 </span><br><span class="line"></span><br><span class="line">  #查看端口</span><br><span class="line">openstack endpoint list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#新增华为云，来安装openstack-glance</span><br><span class="line">yum install wget -y</span><br><span class="line">cd /etc/yum.repos.d/</span><br><span class="line">cp CentOS-Linux-BaseOS.repo CentOS-Linux-BaseOS.repo.bak</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Linux-BaseOS.repo https://repo.huaweicloud.com/repository/conf/CentOS-8-reg.repo</span><br><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">yum install openstack-glance -y</span><br><span class="line"></span><br><span class="line">vim /etc/glance/glance-api.conf</span><br><span class="line"></span><br><span class="line">#删除原内容，添加以下内容</span><br><span class="line">[database]</span><br><span class="line">connection = mysql+pymysql://glance:000000@controller/glance</span><br><span class="line">[keystone_authtoken]</span><br><span class="line">www_authenticate_uri  = http://controller:5000</span><br><span class="line">auth_url = http://controller:5000</span><br><span class="line">memcached_servers = controller:11211</span><br><span class="line">auth_type = password</span><br><span class="line">project_domain_name = Default</span><br><span class="line">user_domain_name = Default</span><br><span class="line">project_name = service</span><br><span class="line">username = glance</span><br><span class="line">password = 000000</span><br><span class="line">[paste_deploy]</span><br><span class="line">flavor = keystone  </span><br><span class="line">[glance_store]</span><br><span class="line">stores = file,http</span><br><span class="line">default_store = file</span><br><span class="line">filesystem_store_datadir = /var/lib/glance/images/</span><br><span class="line">#保存并退出：wq</span><br><span class="line"></span><br><span class="line">su -s /bin/sh -c &quot;glance-manage db_sync&quot; glance</span><br><span class="line"></span><br><span class="line">systemctl enable openstack-glance-api.service;systemctl start openstack-glance-api.service</span><br><span class="line"></span><br><span class="line">#验证</span><br><span class="line">#可通过浏览器下载http://download.cirros-cloud.net/0.4.0/cirros-0.4.0-x86_64-disk.img</span><br><span class="line">#上传镜像 cirros-0.4.0-x86_64-disk.img</span><br><span class="line"></span><br><span class="line">glance image-create --name &quot;cirros5&quot; \</span><br><span class="line">  --file cirros-0.4.0-x86_64-disk2.img \</span><br><span class="line">  --disk-format qcow2 --container-format bare \</span><br><span class="line">  --visibility public</span><br><span class="line"></span><br><span class="line"> openstack image list</span><br></pre></td></tr></table></figure>

<h2 id="安装Placement服务"><a href="#安装Placement服务" class="headerlink" title="安装Placement服务"></a>安装Placement服务</h2><p>controller节点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -u root -p000000</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; CREATE DATABASE placement;</span><br><span class="line">MariaDB [(none)]&gt; GRANT ALL PRIVILEGES ON placement.* TO &#x27;placement&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;000000&#x27;;</span><br><span class="line">MariaDB [(none)]&gt; GRANT ALL PRIVILEGES ON placement.* TO &#x27;placement&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;000000&#x27;;</span><br><span class="line">MariaDB [(none)]&gt; exit;</span><br><span class="line"></span><br><span class="line">. admin-openrc</span><br><span class="line">openstack user create --domain default --password-prompt placement #密码000000</span><br><span class="line">openstack role add --project service --user placement admin</span><br><span class="line"></span><br><span class="line">openstack service create --name placement \</span><br><span class="line">  --description &quot;Placement API&quot; placement</span><br><span class="line"> openstack endpoint create --region RegionOne \</span><br><span class="line">  placement public http://controller:8778</span><br><span class="line">openstack endpoint create --region RegionOne \</span><br><span class="line">  placement internal http://controller:8778</span><br><span class="line">openstack endpoint create --region RegionOne \</span><br><span class="line">  placement admin http://controller:8778</span><br><span class="line"></span><br><span class="line">yum install openstack-placement-api -y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vim /etc/placement/placement.conf</span><br><span class="line"></span><br><span class="line">#删除原内容，添加以下内容</span><br><span class="line">[placement_database]</span><br><span class="line">connection = mysql+pymysql://placement:000000@controller/placement</span><br><span class="line">[api]</span><br><span class="line">auth_strategy = keystone</span><br><span class="line">[keystone_authtoken]</span><br><span class="line">auth_url = http://controller:5000/v3</span><br><span class="line">memcached_servers = controller:11211</span><br><span class="line">auth_type = password</span><br><span class="line">project_domain_name = Default</span><br><span class="line">user_domain_name = Default</span><br><span class="line">project_name = service</span><br><span class="line">username = placement</span><br><span class="line">password = 000000</span><br><span class="line">#保存并退出：wq</span><br><span class="line"></span><br><span class="line">su -s /bin/sh -c &quot;placement-manage db sync&quot; placement</span><br><span class="line">#注意如有一下提醒，可忽略此输出中的任何弃用消息</span><br><span class="line">/usr/lib/python2.7/site-packages/pymysql/cursors.py:170: Warning: (1280, u&quot;Name &#x27;alembic_version_pkc&#x27; ignored for PRIMARY key.&quot;)</span><br><span class="line">  result = self._query(query)</span><br><span class="line">httpd -v</span><br><span class="line">#官方文档：由于打包错误，您必须通过添加以下配置来启用对 Placement API 的访问 /etc/httpd/conf.d/00-nova-placement-api.conf：</span><br><span class="line"></span><br><span class="line">vim /etc/httpd/conf.d/00-placement-api.conf </span><br><span class="line">#添加</span><br><span class="line">&lt;Directory /usr/bin&gt;</span><br><span class="line">   &lt;IfVersion &gt;= 2.4&gt;</span><br><span class="line">      Require all granted</span><br><span class="line">   &lt;/IfVersion&gt;</span><br><span class="line">   &lt;IfVersion &lt; 2.4&gt;</span><br><span class="line">      Order allow,deny</span><br><span class="line">      Allow from all</span><br><span class="line">   &lt;/IfVersion&gt;</span><br><span class="line">&lt;/Directory&gt;</span><br><span class="line">#保存并退出：wq</span><br><span class="line"></span><br><span class="line">systemctl restart httpd</span><br><span class="line">#验证</span><br><span class="line">placement-status upgrade check</span><br></pre></td></tr></table></figure>




<h2 id="安装Nova服务"><a href="#安装Nova服务" class="headerlink" title="安装Nova服务"></a>安装Nova服务</h2><h3 id="controller节点"><a href="#controller节点" class="headerlink" title="controller节点"></a>controller节点</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -u root -p000000</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; CREATE DATABASE nova_api;</span><br><span class="line">MariaDB [(none)]&gt; CREATE DATABASE nova;</span><br><span class="line">MariaDB [(none)]&gt; CREATE DATABASE nova_cell0;</span><br><span class="line">MariaDB [(none)]&gt; GRANT ALL PRIVILEGES ON nova_api.* TO &#x27;nova&#x27;@&#x27;localhost&#x27;IDENTIFIED BY &#x27;000000&#x27;;</span><br><span class="line">MariaDB [(none)]&gt; GRANT ALL PRIVILEGES ON nova_api.* TO &#x27;nova&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;000000&#x27;;</span><br><span class="line">MariaDB [(none)]&gt; GRANT ALL PRIVILEGES ON nova.* TO &#x27;nova&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;000000&#x27;;</span><br><span class="line">MariaDB [(none)]&gt; GRANT ALL PRIVILEGES ON nova.* TO &#x27;nova&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;000000&#x27;;</span><br><span class="line">MariaDB [(none)]&gt; GRANT ALL PRIVILEGES ON nova_cell0.* TO &#x27;nova&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;000000&#x27;;</span><br><span class="line">MariaDB [(none)]&gt; GRANT ALL PRIVILEGES ON nova_cell0.* TO &#x27;nova&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;000000&#x27;;</span><br><span class="line">MariaDB [(none)]&gt; exit;</span><br><span class="line"></span><br><span class="line">. admin-openrc</span><br><span class="line"></span><br><span class="line">openstack user create --domain default --password-prompt nova     #密码000000</span><br><span class="line">openstack role add --project service --user nova admin</span><br><span class="line"></span><br><span class="line">openstack service create --name nova \</span><br><span class="line">  --description &quot;OpenStack Compute&quot; compute</span><br><span class="line">openstack endpoint create --region RegionOne \</span><br><span class="line">  compute public http://controller:8774/v2.1</span><br><span class="line">openstack endpoint create --region RegionOne \</span><br><span class="line">  compute internal http://controller:8774/v2.1</span><br><span class="line">openstack endpoint create --region RegionOne \</span><br><span class="line">  compute admin http://controller:8774/v2.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">yum install openstack-nova-api openstack-nova-conductor openstack-nova-novncproxy openstack-nova-scheduler -y</span><br><span class="line"></span><br><span class="line">vim /etc/nova/nova.conf</span><br><span class="line"></span><br><span class="line">#删除原内容，添加以下内容</span><br><span class="line">[DEFAULT]</span><br><span class="line">enabled_apis = osapi_compute,metadata</span><br><span class="line">my_ip = 10.20.69.56</span><br><span class="line">use_neutron = true</span><br><span class="line">firewall_driver = nova.virt.firewall.NoopFirewallDriver</span><br><span class="line">[api_database]</span><br><span class="line">connection = mysql+pymysql://nova:000000@controller/nova_api</span><br><span class="line">[database]</span><br><span class="line">connection = mysql+pymysql://nova:000000@controller/nova</span><br><span class="line">[DEFAULT]</span><br><span class="line">transport_url = rabbit://openstack:000000@controller:5672/</span><br><span class="line">[api]</span><br><span class="line">auth_strategy = keystone</span><br><span class="line">[keystone_authtoken]</span><br><span class="line">www_authenticate_uri = http://controller:5000/</span><br><span class="line">auth_url = http://controller:5000/</span><br><span class="line">memcached_servers = controller:11211</span><br><span class="line">auth_type = password</span><br><span class="line">project_domain_name = Default</span><br><span class="line">user_domain_name = Default</span><br><span class="line">project_name = service</span><br><span class="line">username = nova</span><br><span class="line">password = 000000</span><br><span class="line">[vnc]</span><br><span class="line">enabled = true</span><br><span class="line">server_listen = $my_ip</span><br><span class="line">server_proxyclient_address = $my_ip</span><br><span class="line">[glance]</span><br><span class="line">api_servers = http://controller:9292</span><br><span class="line">[oslo_concurrency]</span><br><span class="line">lock_path = /var/lib/nova/tmp</span><br><span class="line">[placement]</span><br><span class="line">region_name = RegionOne</span><br><span class="line">project_domain_name = Default</span><br><span class="line">project_name = service</span><br><span class="line">auth_type = password</span><br><span class="line">user_domain_name = Default</span><br><span class="line">auth_url = http://controller:5000/v3</span><br><span class="line">username = placement</span><br><span class="line">password = 000000</span><br><span class="line">#保存并退出:wq</span><br><span class="line"></span><br><span class="line">su -s /bin/sh -c &quot;nova-manage api_db sync&quot; nova</span><br><span class="line">su -s /bin/sh -c &quot;nova-manage cell_v2 map_cell0&quot; nova</span><br><span class="line">su -s /bin/sh -c &quot;nova-manage cell_v2 create_cell --name=cell1 --verbose&quot; nova</span><br><span class="line">su -s /bin/sh -c &quot;nova-manage db sync&quot; nova</span><br><span class="line">#验证</span><br><span class="line">su -s /bin/sh -c &quot;nova-manage cell_v2 list_cells&quot; nova</span><br><span class="line"></span><br><span class="line">systemctl enable \</span><br><span class="line">    openstack-nova-api.service \</span><br><span class="line">    openstack-nova-scheduler.service \</span><br><span class="line">    openstack-nova-conductor.service \</span><br><span class="line">    openstack-nova-novncproxy.service</span><br><span class="line">    </span><br><span class="line">systemctl start \</span><br><span class="line">    openstack-nova-api.service \</span><br><span class="line">    openstack-nova-scheduler.service \</span><br><span class="line">    openstack-nova-conductor.service \</span><br><span class="line">    openstack-nova-novncproxy.service</span><br><span class="line"></span><br><span class="line">systemctl status \</span><br><span class="line">    openstack-nova-api.service \</span><br><span class="line">    openstack-nova-scheduler.service \</span><br><span class="line">    openstack-nova-conductor.service \</span><br><span class="line">    openstack-nova-novncproxy.service</span><br></pre></td></tr></table></figure>
<h3 id="compute节点"><a href="#compute节点" class="headerlink" title="compute节点:"></a>compute节点:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://archive.fedoraproject.org/pub/epel/RPM-GPG-KEY-EPEL-8 -O /etc/pki/rpm-gpg/RPM-GPG-KEY-EPEL-8</span><br><span class="line"></span><br><span class="line">yum install openstack-nova-compute -y</span><br><span class="line"></span><br><span class="line">vim /etc/nova/nova.conf</span><br><span class="line"></span><br><span class="line">#删除原内容，添加以下内容</span><br><span class="line">[DEFAULT]</span><br><span class="line">enabled_apis = osapi_compute,metadata</span><br><span class="line">transport_url = rabbit://openstack:000000@controller</span><br><span class="line">my_ip = 10.20.70.20</span><br><span class="line">use_neutron = true</span><br><span class="line">firewall_driver = nova.virt.firewall.NoopFirewallDriver</span><br><span class="line">[api]</span><br><span class="line">auth_strategy = keystone</span><br><span class="line">[keystone_authtoken]</span><br><span class="line">www_authenticate_uri = http://controller:5000/</span><br><span class="line">auth_url = http://controller:5000/</span><br><span class="line">memcached_servers = controller:11211</span><br><span class="line">auth_type = password</span><br><span class="line">project_domain_name = Default</span><br><span class="line">user_domain_name = Default</span><br><span class="line">project_name = service</span><br><span class="line">username = nova</span><br><span class="line">password = 000000</span><br><span class="line">[vnc]</span><br><span class="line">enabled = true</span><br><span class="line">server_listen = 0.0.0.0</span><br><span class="line">server_proxyclient_address = $my_ip</span><br><span class="line">novncproxy_base_url = http://10.20.69.56:6080/vnc_auto.html</span><br><span class="line">[glance]</span><br><span class="line">api_servers = http://controller:9292</span><br><span class="line">[oslo_concurrency]</span><br><span class="line">lock_path = /var/lib/nova/tmp</span><br><span class="line">[placement]</span><br><span class="line">region_name = RegionOne</span><br><span class="line">project_domain_name = Default</span><br><span class="line">project_name = service</span><br><span class="line">auth_type = password</span><br><span class="line">user_domain_name = Default</span><br><span class="line">auth_url = http://controller:5000/v3</span><br><span class="line">username = placement</span><br><span class="line">password = 000000</span><br><span class="line"></span><br><span class="line">#保存并退出:wq</span><br><span class="line"></span><br><span class="line">#确定节点是否支持虚拟机的硬件加速，显示非0数字表示支持</span><br><span class="line">egrep -c &#x27;(vmx|svm)&#x27; /proc/cpuinfo</span><br><span class="line">#如不支持可在nova.conf添加以下内容</span><br><span class="line">[libvirt]</span><br><span class="line">virt_type = qemu</span><br><span class="line"></span><br><span class="line">systemctl enable libvirtd.service openstack-nova-compute.service;systemctl start libvirtd.service openstack-nova-compute.service</span><br><span class="line">systemctl status libvirtd.service openstack-nova-compute.service</span><br></pre></td></tr></table></figure>

<h3 id="controller节点："><a href="#controller节点：" class="headerlink" title="controller节点："></a>controller节点：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">. admin-openrc</span><br><span class="line">#验证操作</span><br><span class="line">openstack compute service list --service nova-compute</span><br><span class="line"></span><br><span class="line">su -s /bin/sh -c &quot;nova-manage cell_v2 discover_hosts --verbose&quot; nova</span><br><span class="line">#注添加新计算节点时，必须在控制器节点上运行以注册这些新计算节点。或者，您可以在以下位置中设置适当的间隔 ：nova-manage cell_v2 discover_hosts/etc/nova/nova.conf</span><br><span class="line"></span><br><span class="line">vim /etc/nova/nova.conf</span><br><span class="line">#添加：</span><br><span class="line">[scheduler]</span><br><span class="line">discover_hosts_in_cells_interval = 300</span><br><span class="line">#保存并退出:wq</span><br><span class="line"></span><br><span class="line">systemctl restart openstack-nova*</span><br><span class="line">openstack compute service list</span><br><span class="line">openstack catalog list</span><br><span class="line">openstack image list</span><br><span class="line">nova-status upgrade check</span><br></pre></td></tr></table></figure>

<h2 id="安装Neutron服务"><a href="#安装Neutron服务" class="headerlink" title="安装Neutron服务"></a>安装Neutron服务</h2><h3 id="controller节点-1"><a href="#controller节点-1" class="headerlink" title="controller节点"></a>controller节点</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -u root -p000000</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; CREATE DATABASE neutron;</span><br><span class="line">MariaDB [(none)]&gt; GRANT ALL PRIVILEGES ON neutron.* TO &#x27;neutron&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;000000&#x27;;</span><br><span class="line">MariaDB [(none)]&gt; GRANT ALL PRIVILEGES ON neutron.* TO &#x27;neutron&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;000000&#x27;;</span><br><span class="line">MariaDB [(none)]&gt; exit;</span><br><span class="line"></span><br><span class="line">. admin-openrc</span><br><span class="line"></span><br><span class="line">openstack user create --domain default --password-prompt neutron  #密码000000</span><br><span class="line">openstack role add --project service --user neutron admin</span><br><span class="line"></span><br><span class="line">openstack service create --name neutron \</span><br><span class="line">  --description &quot;OpenStack Networking&quot; network</span><br><span class="line">openstack endpoint create --region RegionOne \</span><br><span class="line">  network public http://controller:9696</span><br><span class="line">openstack endpoint create --region RegionOne \</span><br><span class="line">  network internal http://controller:9696</span><br><span class="line">openstack endpoint create --region RegionOne \</span><br><span class="line">  network admin http://controller:9696</span><br><span class="line">  </span><br><span class="line">#自助服务网络配置(Self-service networks支持L3, Provider networks（提供商网络）只支持L2)</span><br><span class="line">yum install -y openstack-neutron openstack-neutron-ml2 \</span><br><span class="line">  openstack-neutron-openvswitch ebtables</span><br><span class="line"></span><br><span class="line">vim /etc/neutron/neutron.conf  </span><br><span class="line"></span><br><span class="line">#删除原内容，添加以下内容</span><br><span class="line">[database]</span><br><span class="line">connection = mysql+pymysql://neutron:000000@controller/neutron  </span><br><span class="line">[DEFAULT]</span><br><span class="line">core_plugin = ml2</span><br><span class="line">service_plugins = router</span><br><span class="line">allow_overlapping_ips = true</span><br><span class="line">transport_url = rabbit://openstack:000000@controller</span><br><span class="line">auth_strategy = keystone</span><br><span class="line">notify_nova_on_port_status_changes = true</span><br><span class="line">notify_nova_on_port_data_changes = true</span><br><span class="line">[keystone_authtoken]</span><br><span class="line">www_authenticate_uri = http://controller:5000</span><br><span class="line">auth_url = http://controller:5000</span><br><span class="line">memcached_servers = controller:11211</span><br><span class="line">auth_type = password</span><br><span class="line">project_domain_name = default</span><br><span class="line">user_domain_name = default</span><br><span class="line">project_name = service</span><br><span class="line">username = neutron</span><br><span class="line">password = 000000</span><br><span class="line">[nova]</span><br><span class="line">auth_url = http://controller:5000</span><br><span class="line">auth_type = password</span><br><span class="line">project_domain_name = default</span><br><span class="line">user_domain_name = default</span><br><span class="line">region_name = RegionOne</span><br><span class="line">project_name = service</span><br><span class="line">username = nova</span><br><span class="line">password = 000000</span><br><span class="line">[oslo_concurrency]</span><br><span class="line">lock_path = /var/lib/neutron/tmp</span><br><span class="line">#保存并退出:wq</span><br><span class="line"></span><br><span class="line">#配置 Modular Layer 2 (ML2) 插件</span><br><span class="line">vim /etc/neutron/plugins/ml2/ml2_conf.ini</span><br><span class="line"></span><br><span class="line">#删除原内容，添加以下内容</span><br><span class="line">[ml2]</span><br><span class="line">type_drivers = flat,vlan,vxlan</span><br><span class="line">tenant_network_types = vlan,vxlan</span><br><span class="line">mechanism_drivers = openvswitch,l2population</span><br><span class="line">extension_drivers = port_security</span><br><span class="line">[ml2_type_flat]</span><br><span class="line">flat_networks = provider</span><br><span class="line">[ml2_type_vlan]</span><br><span class="line">network_vlan_ranges = provider,default</span><br><span class="line">[ml2_type_vxlan]</span><br><span class="line">vni_ranges = 1:1000</span><br><span class="line">[securitygroup]</span><br><span class="line">enable_ipset = true</span><br><span class="line">#保存并退出:wq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vim /etc/sysctl.conf</span><br><span class="line">#添加：</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">#保存并退出:wq</span><br><span class="line"></span><br><span class="line">#加载内核参数</span><br><span class="line">modprobe br_netfilter</span><br><span class="line">#查看内核参数</span><br><span class="line">sysctl -p</span><br><span class="line">#要启用网络桥接支持，通常br_netfilter需要加载内核模块</span><br><span class="line"></span><br><span class="line">#配置第三层代理</span><br><span class="line">vim /etc/neutron/l3_agent.ini</span><br><span class="line">#删除原内容，添加以下内容</span><br><span class="line">[DEFAULT]</span><br><span class="line">interface_driver = openvswitch</span><br><span class="line">#保存并退出:wq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#配置 DHCP 代理</span><br><span class="line">vim /etc/neutron/dhcp_agent.ini</span><br><span class="line"></span><br><span class="line">#删除原内容，添加以下内容</span><br><span class="line">[DEFAULT]</span><br><span class="line">interface_driver = openvswitch</span><br><span class="line">enable_isolated_metadata = True</span><br><span class="line">force_metadata = True</span><br><span class="line">#保存并退出:wq</span><br><span class="line"></span><br><span class="line">#配置元数据代理</span><br><span class="line">vim /etc/neutron/metadata_agent.ini</span><br><span class="line"></span><br><span class="line">#删除原内容，添加以下内容</span><br><span class="line">[DEFAULT]</span><br><span class="line">nova_metadata_host = controller</span><br><span class="line">metadata_proxy_shared_secret = 000000</span><br><span class="line">#保存并退出:wq</span><br><span class="line"></span><br><span class="line">#配置计算服务以使用网络服务</span><br><span class="line">vim /etc/nova/nova.conf</span><br><span class="line">#添加：</span><br><span class="line">[neutron]</span><br><span class="line">auth_url = http://controller:5000</span><br><span class="line">auth_type = password</span><br><span class="line">project_domain_name = default</span><br><span class="line">user_domain_name = default</span><br><span class="line">region_name = RegionOne</span><br><span class="line">project_name = service</span><br><span class="line">username = neutron</span><br><span class="line">password = 000000</span><br><span class="line">service_metadata_proxy = true</span><br><span class="line">metadata_proxy_shared_secret = 000000</span><br><span class="line">#保存并退出:wq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ln -s /etc/neutron/plugins/ml2/ml2_conf.ini /etc/neutron/plugin.ini</span><br><span class="line">neutron-openvswitch-agent.service </span><br><span class="line">su -s /bin/sh -c &quot;neutron-db-manage --config-file /etc/neutron/neutron.conf \</span><br><span class="line">  --config-file /etc/neutron/plugins/ml2/ml2_conf.ini upgrade head&quot; neutron</span><br><span class="line"></span><br><span class="line">systemctl restart neutron-server.service  neutron-dhcp-agent.service neutron-metadata-agent.service</span><br><span class="line"></span><br><span class="line">systemctl restart openstack-nova-api.service</span><br><span class="line"></span><br><span class="line">systemctl enable neutron-server.service \</span><br><span class="line">  neutron-openvswitch-agent.service neutron-dhcp-agent.service \</span><br><span class="line">  neutron-metadata-agent.service</span><br><span class="line"></span><br><span class="line">systemctl start neutron-server.service \</span><br><span class="line">  neutron-openvswitch-agent.service neutron-dhcp-agent.service \</span><br><span class="line">  neutron-metadata-agent.service</span><br><span class="line"></span><br><span class="line">systemctl enable neutron-l3-agent.service;systemctl start neutron-l3-agent.service</span><br></pre></td></tr></table></figure>
<h3 id="compute节点-1"><a href="#compute节点-1" class="headerlink" title="compute节点"></a>compute节点</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install openstack-neutron-openvswitch ebtables ipset -y</span><br><span class="line"></span><br><span class="line">vim /etc/neutron/neutron.conf </span><br><span class="line">#删除原内容，添加以下内容</span><br><span class="line">[DEFAULT]</span><br><span class="line">transport_url = rabbit://openstack:000000@controller</span><br><span class="line">auth_strategy = keystone</span><br><span class="line">[keystone_authtoken]</span><br><span class="line">www_authenticate_uri = http://controller:5000</span><br><span class="line">auth_url = http://controller:5000</span><br><span class="line">memcached_servers = controller:11211</span><br><span class="line">auth_type = password</span><br><span class="line">project_domain_name = default</span><br><span class="line">user_domain_name = default</span><br><span class="line">project_name = service</span><br><span class="line">username = neutron</span><br><span class="line">password = 000000</span><br><span class="line">[oslo_concurrency]</span><br><span class="line">lock_path = /var/lib/neutron/tmp</span><br><span class="line">#保存并退出:wq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#自助服务网络</span><br><span class="line">vim /etc/neutron/plugins/ml2/openvswitch_agent.ini </span><br><span class="line"></span><br><span class="line">[ovs]</span><br><span class="line">local_ip = 10.20.70.20</span><br><span class="line">integration_bridge = br-jmnd</span><br><span class="line">datapath_type = netdev</span><br><span class="line">vhostuser_socket_dir = /var/run/openvswitch</span><br><span class="line">ovsdb_connection = unix:/var/run/openvswitch/db.sock</span><br><span class="line"></span><br><span class="line">[agent]</span><br><span class="line">tunnel_types = vxlan</span><br><span class="line">l2_population = True</span><br><span class="line"> </span><br><span class="line">[securitygroup]</span><br><span class="line">firewall_driver = openvswitch</span><br><span class="line"></span><br><span class="line">vim /etc/sysctl.conf</span><br><span class="line">#添加：</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">#保存并退出:wq</span><br><span class="line"></span><br><span class="line">#加载内核参数</span><br><span class="line">modprobe br_netfilter</span><br><span class="line">#查看内核参数</span><br><span class="line">sysctl -p</span><br><span class="line"></span><br><span class="line">#配置计算服务以使用网络服务</span><br><span class="line">vim /etc/nova/nova.conf</span><br><span class="line">#添加：</span><br><span class="line">[neutron]</span><br><span class="line">auth_url = http://controller:5000</span><br><span class="line">auth_type = password</span><br><span class="line">project_domain_name = default</span><br><span class="line">user_domain_name = default</span><br><span class="line">region_name = RegionOne</span><br><span class="line">project_name = service</span><br><span class="line">username = neutron</span><br><span class="line">password = 000000</span><br><span class="line"></span><br><span class="line">#保存并退出:wq</span><br><span class="line"></span><br><span class="line">systemctl restart openstack-nova-compute.service</span><br><span class="line"></span><br><span class="line">systemctl enable neutron-openvswitch-agent.service;systemctl start neutron-openvswitch-agent.service</span><br><span class="line"></span><br><span class="line">systemctl status neutron-openvswitch-agent.service</span><br><span class="line"></span><br><span class="line">### controller节点：</span><br><span class="line"></span><br><span class="line">#验证</span><br><span class="line">. admin-openrc</span><br><span class="line">openstack extension list --network</span><br><span class="line">openstack network agent list</span><br><span class="line"></span><br><span class="line">+--------------------------------------+--------------------+------------+-------------------+-------+-------+---------------------------+</span><br><span class="line">| ID                                   | Agent Type         | Host       | Availability Zone | Alive | State | Binary                    |</span><br><span class="line">+--------------------------------------+--------------------+------------+-------------------+-------+-------+---------------------------+</span><br><span class="line">| 0c916fa1-70d6-46a3-afb1-28a29f7a51cf | L3 agent           | controller | nova              | :-)   | UP    | neutron-l3-agent          |</span><br><span class="line">| 77ba28e4-fd87-4b16-a31f-1bdff0095e9e | Open vSwitch agent | compute    | None              | :-)   | UP    | neutron-openvswitch-agent |</span><br><span class="line">| bf1346e6-6a38-4898-b3cb-2cd0d99ca228 | DHCP agent         | controller | nova              | :-)   | UP    | neutron-dhcp-agent        |</span><br><span class="line">| c73dbb86-baf3-45fe-9561-4dc5396e88d3 | Metadata agent     | controller | None              | :-)   | UP    | neutron-metadata-agent    |</span><br><span class="line">+--------------------------------------+--------------------+------------+-------------------+-------+-------+---------------------------+</span><br></pre></td></tr></table></figure>

<h2 id="安装Dashboard服务"><a href="#安装Dashboard服务" class="headerlink" title="安装Dashboard服务"></a>安装Dashboard服务</h2><h3 id="controller节点-2"><a href="#controller节点-2" class="headerlink" title="controller节点"></a>controller节点</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install openstack-dashboard -y</span><br><span class="line"></span><br><span class="line">vim /etc/openstack-dashboard/local_settings </span><br><span class="line">#更改内容：</span><br><span class="line">OPENSTACK_HOST = &quot;controller&quot;</span><br><span class="line">ALLOWED_HOSTS = [&#x27;*&#x27;]</span><br><span class="line">SESSION_ENGINE = &#x27;django.contrib.sessions.backends.cache&#x27;</span><br><span class="line">CACHES = &#123;</span><br><span class="line">    &#x27;default&#x27;: &#123;</span><br><span class="line">         &#x27;BACKEND&#x27;: &#x27;django.core.cache.backends.memcached.MemcachedCache&#x27;,</span><br><span class="line">         &#x27;LOCATION&#x27;: &#x27;controller:11211&#x27;,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">OPENSTACK_KEYSTONE_URL = &quot;http://%s:5000/v3&quot; % OPENSTACK_HOST</span><br><span class="line">OPENSTACK_KEYSTONE_MULTIDOMAIN_SUPPORT = True</span><br><span class="line">OPENSTACK_API_VERSIONS = &#123;</span><br><span class="line">    &quot;identity&quot;: 3,</span><br><span class="line">    &quot;image&quot;: 2,</span><br><span class="line">    &quot;volume&quot;: 3,</span><br><span class="line">&#125;</span><br><span class="line">OPENSTACK_KEYSTONE_DEFAULT_DOMAIN = &quot;Default&quot;</span><br><span class="line">OPENSTACK_KEYSTONE_DEFAULT_ROLE = &quot;user&quot;</span><br><span class="line">#如配置三层网络不需要改以下注释设置</span><br><span class="line">#OPENSTACK_NEUTRON_NETWORK = &#123;</span><br><span class="line">#    &#x27;enable_auto_allocated_network&#x27;: False,</span><br><span class="line">#    &#x27;enable_distributed_router&#x27;: False,</span><br><span class="line">#    &#x27;enable_fip_topology_check&#x27;: False,</span><br><span class="line">#    &#x27;enable_ha_router&#x27;: False,</span><br><span class="line">#    &#x27;enable_ipv6&#x27;: False,</span><br><span class="line">#    # TODO(amotoki): Drop OPENSTACK_NEUTRON_NETWORK completely from here.</span><br><span class="line">#    # enable_quotas has the different default value here.</span><br><span class="line">#    &#x27;enable_quotas&#x27;: False,</span><br><span class="line">#    &#x27;enable_rbac_policy&#x27;: False,</span><br><span class="line">#    &#x27;enable_router&#x27;: True,</span><br><span class="line">#    &#x27;enable_fip_topology_check&#x27;: False,</span><br><span class="line">#    &#x27;default_dns_nameservers&#x27;: [],</span><br><span class="line">#    &#x27;supported_provider_types&#x27;: [&#x27;*&#x27;],</span><br><span class="line">#    &#x27;segmentation_id_range&#x27;: &#123;&#125;,</span><br><span class="line">#    &#x27;extra_provider_types&#x27;: &#123;&#125;,</span><br><span class="line">#    &#x27;supported_vnic_types&#x27;: [&#x27;*&#x27;],</span><br><span class="line">#    &#x27;physical_networks&#x27;: [],</span><br><span class="line"># &#125;</span><br><span class="line">TIME_ZONE = &quot;Asia/Shanghai&quot;</span><br><span class="line">#保存并退出:wq</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">vim /etc/httpd/conf.d/openstack-dashboard.conf</span><br><span class="line">#添加：</span><br><span class="line">WSGIApplicationGroup %&#123;GLOBAL&#125;</span><br><span class="line">#保存并退出:wq</span><br><span class="line"></span><br><span class="line">#注意，编辑以下文件，找到WEBROOT = &#x27;/&#x27; 修改为WEBROOT = &#x27;/dashboard&#x27; (官方未提及坑点之一)</span><br><span class="line">vi /usr/share/openstack-dashboard/openstack_dashboard/defaults.py</span><br><span class="line">vi /usr/share/openstack-dashboard/openstack_dashboard/test/settings.py</span><br><span class="line">vi /usr/share/openstack-dashboard/static/dashboard/js/e21db2a561ed.js </span><br><span class="line"></span><br><span class="line">systemctl restart httpd.service memcached.service</span><br></pre></td></tr></table></figure>

<h2 id="安装Cinder服务"><a href="#安装Cinder服务" class="headerlink" title="安装Cinder服务"></a>安装Cinder服务</h2><h3 id="controller节点-3"><a href="#controller节点-3" class="headerlink" title="controller节点"></a>controller节点</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -u root -p000000</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt;CREATE DATABASE cinder;</span><br><span class="line">MariaDB [(none)]&gt; GRANT ALL PRIVILEGES ON cinder.* TO &#x27;cinder&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;000000&#x27;;</span><br><span class="line">MariaDB [(none)]&gt;GRANT ALL PRIVILEGES ON cinder.* TO &#x27;cinder&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;000000&#x27;;</span><br><span class="line">MariaDB [(none)]&gt;exit;</span><br><span class="line"></span><br><span class="line">. admin-openrc</span><br><span class="line">openstack user create --domain default --password-prompt cinder    #密码000000</span><br><span class="line">openstack role add --project service --user cinder admin</span><br><span class="line"></span><br><span class="line">openstack service create --name cinderv2 \</span><br><span class="line">  --description &quot;OpenStack Block Storage&quot; volumev2</span><br><span class="line">openstack service create --name cinderv3 \</span><br><span class="line">  --description &quot;OpenStack Block Storage&quot; volumev3</span><br><span class="line">openstack endpoint create --region RegionOne \</span><br><span class="line">  volumev2 public http://controller:8776/v2/%\(project_id\)s</span><br><span class="line">openstack endpoint create --region RegionOne \</span><br><span class="line">  volumev2 internal http://controller:8776/v2/%\(project_id\)s</span><br><span class="line">openstack endpoint create --region RegionOne \</span><br><span class="line">  volumev2 admin http://controller:8776/v2/%\(project_id\)s</span><br><span class="line"></span><br><span class="line">openstack endpoint create --region RegionOne \</span><br><span class="line">  volumev3 public http://controller:8776/v3/%\(project_id\)s</span><br><span class="line">openstack endpoint create --region RegionOne \</span><br><span class="line">  volumev3 internal http://controller:8776/v3/%\(project_id\)s</span><br><span class="line"> openstack endpoint create --region RegionOne \</span><br><span class="line">  volumev3 admin http://controller:8776/v3/%\(project_id\)s</span><br><span class="line"></span><br><span class="line">#安装软件包</span><br><span class="line">yum install openstack-cinder -y</span><br><span class="line"></span><br><span class="line">vi /etc/cinder/cinder.conf</span><br><span class="line">#删除原内容，添加以下内容</span><br><span class="line">[database]</span><br><span class="line">connection = mysql+pymysql://cinder:000000@controller/cinder</span><br><span class="line">[DEFAULT]</span><br><span class="line">transport_url = rabbit://openstack:000000@controller</span><br><span class="line">auth_strategy = keystone</span><br><span class="line">my_ip = 10.20.69.56</span><br><span class="line">[keystone_authtoken]</span><br><span class="line">www_authenticate_uri = http://controller:5000</span><br><span class="line">auth_url = http://controller:5000</span><br><span class="line">memcached_servers = controller:11211</span><br><span class="line">auth_type = password</span><br><span class="line">project_domain_name = default</span><br><span class="line">user_domain_name = default</span><br><span class="line">project_name = service</span><br><span class="line">username = cinder</span><br><span class="line">password = 000000</span><br><span class="line">[oslo_concurrency]</span><br><span class="line">lock_path = /var/lib/cinder/tmp</span><br><span class="line">#保存并退出:wq</span><br><span class="line"></span><br><span class="line">su -s /bin/sh -c &quot;cinder-manage db sync&quot; cinder</span><br><span class="line">#忽略此输出中的任何弃用消息。</span><br><span class="line"></span><br><span class="line">vi /etc/nova/nova.conf</span><br><span class="line">#添加：</span><br><span class="line">[cinder]</span><br><span class="line">os_region_name = RegionOne</span><br><span class="line">#保存并退出:wq</span><br><span class="line"></span><br><span class="line">systemctl restart openstack-nova-api.service</span><br><span class="line"></span><br><span class="line">systemctl enable openstack-cinder-api.service openstack-cinder-scheduler.service;systemctl start openstack-cinder-api.service openstack-cinder-scheduler.service</span><br></pre></td></tr></table></figure>

<h3 id="compute（块存储）节点"><a href="#compute（块存储）节点" class="headerlink" title="compute（块存储）节点:"></a>compute（块存储）节点:</h3><p>host上执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">modprobe target_core_mod</span><br><span class="line"></span><br><span class="line">yum install lvm2 device-mapper-persistent-data -y </span><br><span class="line"></span><br><span class="line">systemctl enable lvm2-lvmetad.service;systemctl start lvm2-lvmetad.service</span><br><span class="line">#请提前添加磁盘sdb</span><br><span class="line">pvcreate /dev/sda4</span><br><span class="line">vgcreate cinder-volumes /dev/sda4</span><br><span class="line"></span><br><span class="line">vi /etc/lvm/lvm.conf</span><br><span class="line">#根据lvm硬盘添加：disp</span><br><span class="line">devices &#123;</span><br><span class="line">filter = [ &quot;a/sda/&quot;, &quot;a/sda4/&quot;, &quot;r/.*/&quot;]</span><br><span class="line">#保存并退出:wq</span><br><span class="line"></span><br><span class="line">yum install openstack-cinder targetcli python3-keystone -y</span><br><span class="line"></span><br><span class="line">vi /etc/cinder/cinder.conf</span><br><span class="line">#删除原内容，添加以下内容</span><br><span class="line">[database]</span><br><span class="line">connection = mysql+pymysql://cinder:000000@controller/cinder</span><br><span class="line">[DEFAULT]</span><br><span class="line">transport_url = rabbit://openstack:000000@controller</span><br><span class="line">auth_strategy = keystone</span><br><span class="line">my_ip = 10.20.70.20</span><br><span class="line">enabled_backends = lvm</span><br><span class="line">glance_api_servers = http://controller:9292</span><br><span class="line">target_ip_address = 10.20.70.20</span><br><span class="line">target_port = 3260</span><br><span class="line">target_helper = lioadm</span><br><span class="line">use_chap_auth = false</span><br><span class="line">instorage_mcs_iscsi_chap_enabled=false</span><br><span class="line">debug = true</span><br><span class="line">osapi_volume_workers=10</span><br><span class="line">[keystone_authtoken]</span><br><span class="line">www_authenticate_uri = http://controller:5000</span><br><span class="line">auth_url = http://controller:5000</span><br><span class="line">memcached_servers = controller:11211</span><br><span class="line">auth_type = password</span><br><span class="line">project_domain_name = default</span><br><span class="line">user_domain_name = default</span><br><span class="line">project_name = service</span><br><span class="line">username = cinder</span><br><span class="line">password = 000000</span><br><span class="line">[lvm]</span><br><span class="line">volume_driver = cinder.volume.drivers.lvm.LVMVolumeDriver</span><br><span class="line">volume_group = cinder-volumes</span><br><span class="line">target_protocol = iscsi</span><br><span class="line">target_helper = lioadm</span><br><span class="line">[oslo_concurrency]</span><br><span class="line">lock_path = /var/lib/cinder/tmp</span><br><span class="line">#保存并退出:wq</span><br><span class="line"></span><br><span class="line">systemctl enable openstack-cinder-volume.service target.service;systemctl start openstack-cinder-volume.service target.service</span><br><span class="line"></span><br><span class="line">systemctl restart openstack-cinder-volume.service </span><br><span class="line">systemctl restart target.servicelv</span><br><span class="line">systemctl status openstack-cinder-volume.service target.service</span><br><span class="line">## 查看安装的版本号</span><br><span class="line"> pip3  list |grep -E &quot;nova|neutron|glance|cinder|placement|keystone|horizon&quot;</span><br></pre></td></tr></table></figure>


<h2 id="启动实例"><a href="#启动实例" class="headerlink" title="启动实例"></a>启动实例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#创建m1.nano主机类型</span><br><span class="line">openstack flavor create --id 0 --vcpus 2 --ram 2048 --disk 1 m1.nano</span><br><span class="line"></span><br><span class="line">openstack server create --flavor m1.nano --image  cirros4 vm5</span><br><span class="line">openstack server create --flavor m2.nano --image  cirros5 vm3</span><br><span class="line"></span><br><span class="line">#删除虚机</span><br><span class="line">openstack server delete vm5</span><br><span class="line"></span><br><span class="line">#生成密钥对选作</span><br><span class="line">ssh-keygen -q -N &quot;&quot;          #需执行回车操作</span><br><span class="line">openstack keypair create --public-key ~/.ssh/id_rsa.pub mykey</span><br><span class="line">openstack keypair list</span><br><span class="line"></span><br><span class="line">#添加安全组规则</span><br><span class="line">#查看默认规则</span><br><span class="line">openstack security group rule list default</span><br><span class="line">#通过ID删除现有规则</span><br><span class="line">openstack security group rule delete &lt;ID&gt;</span><br><span class="line">#添加规则（如有多条同名规则请使用id）</span><br><span class="line">openstack security group rule create --proto icmp default</span><br><span class="line">openstack security group rule create --proto tcp default</span><br><span class="line">openstack security group rule create --proto udp default</span><br><span class="line">openstack security group rule create --proto icmp --egress default</span><br><span class="line">openstack security group rule create --proto tcp --egress default</span><br><span class="line">openstack security group rule create --proto udp --egress default</span><br><span class="line"></span><br><span class="line">#创建内外网络及路由</span><br><span class="line">openstack network create  --share --external \</span><br><span class="line">  --provider-physical-network provider \</span><br><span class="line">  --provider-network-type flat flat-provider</span><br><span class="line"></span><br><span class="line">openstack subnet create --network flat-provider \</span><br><span class="line">  --allocation-pool start=192.168.100.100,end=192.168.100.200 \</span><br><span class="line">  --dns-nameserver 172.16.100.134 --gateway 192.168.100.1 \</span><br><span class="line">  --subnet-range 192.168.100.0/24 flat-subnet</span><br><span class="line">  </span><br><span class="line"> openstack network create int-net</span><br><span class="line"> openstack subnet create --network int-net \</span><br><span class="line">  --dns-nameserver 172.16.100.134 --gateway 10.0.0.1 \</span><br><span class="line">  --subnet-range 10.0.0.0/24 int-subnet</span><br><span class="line"></span><br><span class="line">openstack router create router</span><br><span class="line">openstack router add subnet router int-subnet</span><br><span class="line">openstack router set --external-gateway flat-provider router</span><br><span class="line"></span><br><span class="line">#创建云主机</span><br><span class="line">openstack server create --flavor m1.nano --image  cirros \</span><br><span class="line">  --nic net-id=e41e72a0-e11f-449c-a13b-18cae8347ba4 --security-group default \</span><br><span class="line">  --key-name mykey vm1</span><br><span class="line">#查询云主机</span><br><span class="line">openstack server list</span><br><span class="line">#查询主机控制台链接</span><br><span class="line">openstack console url show vm1</span><br><span class="line"></span><br><span class="line">#在浏览器访问，或在dashboard平台打开</span><br><span class="line"> http://192.168.200.10:6080/vnc_auto.html?path=%3Ftoken%3D2d424de0-0a9b-4961-b7ab-4aa458222a03</span><br></pre></td></tr></table></figure>

<h2 id="调试问题记录"><a href="#调试问题记录" class="headerlink" title="调试问题记录"></a>调试问题记录</h2><h3 id="查看t版本对应的各组件版本"><a href="#查看t版本对应的各组件版本" class="headerlink" title="查看t版本对应的各组件版本"></a>查看t版本对应的各组件版本</h3><p><a href="https://releases.openstack.org/train/index.html">https://releases.openstack.org/train/index.html</a></p>
<h3 id="openstack-server-create-创建虚机失败，virsh-list为空"><a href="#openstack-server-create-创建虚机失败，virsh-list为空" class="headerlink" title="openstack server create 创建虚机失败，virsh list为空"></a>openstack server create 创建虚机失败，virsh list为空</h3><p>查看/var/log/libvirt/qemu的日志，发现kvm没有权限</p>
<p>修改权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#chown root:kvm /dev/kvm</span><br><span class="line">#chmod 666 /dev/kvm</span><br></pre></td></tr></table></figure>

<p>修改/etc/libvirt/qemu.conf</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#user=&quot;root&quot;</span><br><span class="line"></span><br><span class="line">user=&quot;root&quot;</span><br><span class="line"></span><br><span class="line">#group=&quot;root&quot;</span><br><span class="line"></span><br><span class="line">group=&quot;root&quot;</span><br></pre></td></tr></table></figure>
<p>重启libvirtd服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#systemctl restart libvirtd</span><br></pre></td></tr></table></figure>

<h3 id="neutron-openvswitch-agent启动失败"><a href="#neutron-openvswitch-agent启动失败" class="headerlink" title="neutron-openvswitch-agent启动失败"></a>neutron-openvswitch-agent启动失败</h3><p>修改计算节点/usr/lib/systemd/system/neutron-openvswitch-agent.service<br>将User改成User=root<br>删除掉依赖openvswitch.service<br>systemctl daemon-reload<br>在docker外面执行：modprobe bridge</p>
<h3 id="openstack-nova-compute启动失败"><a href="#openstack-nova-compute启动失败" class="headerlink" title="openstack-nova-compute启动失败"></a>openstack-nova-compute启动失败</h3><p>修改计算节点/usr/lib/systemd/system/openstack-nova-compute.service<br>将User改成User=root<br>systemctl daemon-reload</p>
]]></content>
      <categories>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>openstack</tag>
      </tags>
  </entry>
  <entry>
    <title>openstack组件介绍</title>
    <url>/2022/06/07/openstack%E7%BB%84%E4%BB%B6%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="组件类型"><a href="#组件类型" class="headerlink" title="组件类型"></a>组件类型</h2><p>openstack部署分为控制节点和计算节点，一般有1个控制节点多个计算节点。</p>
<span id="more"></span>

<p>控制节点上的主要组件有：keystone  glance nova  neutron  horizon cinder<br>计算节点上的主要组件：nova  neutron  cinder<br><img src="a1a6fc9dc098219581c92a10d164f95b1a1352ec0b386c0b79d348ddf2e66095.png" alt="图 1">  </p>
<h2 id="组件间交互机制"><a href="#组件间交互机制" class="headerlink" title="组件间交互机制"></a>组件间交互机制</h2><p>组件间交互机制有两种：restfulAPI和消息队列</p>
<p>restfulAPI一般是跟各个组件的api服务交互的方式</p>
<p>各组件之间通过rabbitmq实现进程RPC交互，相关rpc接口封装在oslo.messaging库中，实现进程间的消息交互队列。<br><img src="ccb078f3a9107360d1be1335dffe21a5b183a6d5d67a421e79a054ddfc93fbb1.png" alt="图 8">  </p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>管理用户信息，资源信息，各个类型的资源拥有单独的数据库表<br><img src="1aef5778d93e1fbdf789d29568413a49ef2adf15ee3b8b54d7d67e3c654241f2.png" alt="图 3">  </p>
<h3 id="镜像glance"><a href="#镜像glance" class="headerlink" title="镜像glance"></a>镜像glance</h3><p>只运行在controller节点，负责镜像管理，在创建虚机时，nava会像glance-api发送请求下载对应的镜像。</p>
<h3 id="keystone认证"><a href="#keystone认证" class="headerlink" title="keystone认证"></a>keystone认证</h3><p>只运行在controller节点，负责所有openstack的用户/角色/项目等管理。其他组件通过keystone的api进行用户认证。</p>
<h3 id="存储cinder"><a href="#存储cinder" class="headerlink" title="存储cinder"></a>存储cinder</h3><p>在控制节点上启动api和scheduler服务；计算节点上启动volume服务，通过驱动对接各种volume的操作<br><img src="2e7117c3652bbb4b4e983cefa34c99967d6e7f8121b329708eeb5e5af8ffc36b.png" alt="图 4">  </p>
<h3 id="网络neutron"><a href="#网络neutron" class="headerlink" title="网络neutron"></a>网络neutron</h3><p><img src="18ceec8aa5242c281fed3214ab65e36f3cec63afd3d170aee1245ec6b51fa0ae.png" alt="图 5">  </p>
<h3 id="nova组件"><a href="#nova组件" class="headerlink" title="nova组件"></a>nova组件</h3><p>控制节点启动api/conductor/schedule服务；计算节点启动compute服务，通过Libvirt驱动对接计算节点上的libvirt服务，负责创建虚机。<br><img src="e9ce7363f3713949e1ef6ede8f83f6e7b44e1eab6fbea574e8a7434ba083cbed.png" alt="图 6">  </p>
<h2 id="创建虚机的流程"><a href="#创建虚机的流程" class="headerlink" title="创建虚机的流程"></a>创建虚机的流程</h2><p><img src="62317225f89249c15baefb73a86c9198c2764fc32032893ce30f21f884bf240e.png" alt="图 7">  </p>
<p>1.客户端使用自己的用户名密码请求认证。<br>2.keystone通过查询在keystone的数据库user表中保存了user的相关信息，包括password加密后的hash值，并返回一个token_id（令牌），和serviceCatalog(一些服务的endpoint地址，cinder、glance-api后面下载镜像和创建块存储时会用到)。<br>3.客户端带上keystone返回的token_id和创建虚机的相关参数，Post请求nova-api创建虚拟机<br>4.nova-api接收到请求后，首先使用请求携带的token_id来访问该api，以验证请求是否有效。<br>5.keystone验证通过后返回更新后的认证信息。<br>6.nova api检查创建虚拟机参数是否有效与合法。<br>检查虚拟机name是否符合命名规范，flavor_id是否在数据库中存在，image_uuid是否是正确的uuid格式<br>检查instance、vcpu、ram的数量是否超过配额。<br>7.当且仅当所有传参都有效合法时，更新nova数据库，新建一条instance记录，vm_states设为BUILDING，task_state设为SCHEDULING.<br>8.nova api 远程调用传递请求、参数给nova scheduler，把消息“请给我创建一台虚拟机”丢到消息队列，然后定期查询虚机的状态。<br>9.nova scheduler从queue中获取到这条消息<br>10.nova scheduler访问nova 数据库，通过调度算法，过滤出一些合适的计算节点，然后进行排序。<br>11.更新虚机节点信息，返回一个最优节点id给nova scheduler。<br>12.nova scheduler选定host之后，通过rpc调用nova-compute服务，把“创建虚机请求”消息丢个mq。<br>13.nova compute收到创建虚拟机请求的消息<br>#nova-compute有个定时任务，定期从数据库中查找到运行在该节点上的所有虚拟机信息，统计得到空闲内存大小和空闲磁盘大小。然后更新数据库compute_node信息，以保证调度的准确性。<br>14.nova compute通过rpc查询nova数据库中虚机的信息例如主机模板和id<br>15.nova conductor从消息队列中拿到请求查询数据库<br>16.nova conductor查询nova数据库<br>17.数据库返回虚机信息<br>18.nova compute从消息队列中获取信息。<br>19.nova compute 请求glance 的rest api，下载所需要的镜像，一般是qcow2的。<br>20.glance api 也会去验证请求的token的有效性。<br>21.glance api 返回镜像信息给nova-compute。<br>22.同理，nova compute请求neutron api配置网络，例如获取虚机ip地址<br>23.验证token的有效性<br>24.neutron返回网络信息<br>25-27 同glance、neutron验证token返回块设备信息<br>28.据上面配置的虚拟机信息，生成xml，写入libvirt,xml文件，然后调用libvirt driver去使用libvirt.xml文件启动虚拟机。</p>
]]></content>
      <categories>
        <category>openstack</category>
      </categories>
      <tags>
        <tag>openstack</tag>
      </tags>
  </entry>
  <entry>
    <title>vimrc设置</title>
    <url>/2022/06/06/vimrc%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="vimrc"><a href="#vimrc" class="headerlink" title="vimrc"></a>vimrc</h2><p>Vim 的全局配置一般在/etc/vim/vimrc或者/etc/vimrc，对所有用户生效。用户个人的配置在~/.vimrc。</p>
<span id="more"></span>

<h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><p><code>set nocompatible</code><br>不与 Vi 兼容（采用 Vim 自己的操作命令）。</p>
<p><code>syntax on</code><br>打开语法高亮。自动识别代码，使用多种颜色显示。</p>
<p><code>set showmode</code><br>在底部显示，当前处于命令模式还是插入模式。</p>
<p><code>set showcmd</code><br>命令模式下，在底部显示，当前键入的指令。比如，键入的指令是2y3d，那么底部就会显示2y3，当键入d的时候，操作完成，显示消失。</p>
<p><code>set mouse=a</code><br>支持使用鼠标。</p>
<p><code>set encoding=utf-8  </code><br>使用 utf-8 编码。</p>
<h2 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h2><p><code>set autoindent</code><br>按下回车键后，下一行的缩进会自动跟上一行的缩进保持一致。</p>
<p><code>set tabstop=2</code><br>按下 Tab 键时，Vim 显示的空格数。</p>
<p><code>set shiftwidth=4</code><br>在文本上按下&gt;&gt;（增加一级缩进）、&lt;&lt;（取消一级缩进）或者==（取消全部缩进）时，每一级的字符数。</p>
<p><code>set expandtab</code><br>由于 Tab 键在不同的编辑器缩进不一致，该设置自动将 Tab 转为空格。</p>
<p><code>set softtabstop=2</code><br>Tab 转为多少个空格。</p>
<h2 id="外观"><a href="#外观" class="headerlink" title="外观"></a>外观</h2><p><code>set number</code><br>显示行号</p>
<p><code>set relativenumber</code><br>显示光标所在的当前行的行号，其他行都为相对于该行的相对行号。</p>
<p><code>set cursorline</code><br>光标所在的当前行高亮。</p>
<p><code>set textwidth=80</code><br>设置行宽，即一行显示多少个字符。</p>
<p><code>set wrap</code><br>自动折行，即太长的行分成几行显示。</p>
<p><code>set nowrap</code><br>关闭自动折行</p>
<p><code>set linebreak</code><br>只有遇到指定的符号（比如空格、连词号和其他标点符号），才发生折行。也就是说，不会在单词内部折行。</p>
<p><code>set wrapmargin=2</code><br>指定折行处与编辑窗口的右边缘之间空出的字符数。</p>
<p><code>set scrolloff=5</code><br>垂直滚动时，光标距离顶部/底部的位置（单位：行）。</p>
<p><code>set sidescrolloff=15</code><br>水平滚动时，光标距离行首或行尾的位置（单位：字符）。该配置在不折行时比较有用。</p>
<p><code>set laststatus=2</code><br>是否显示状态栏。0 表示不显示，1 表示只在多窗口时显示，2 表示显示。</p>
<p><code>set  ruler</code><br>在状态栏显示光标的当前位置（位于哪一行哪一列）。</p>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p><code>set showmatch</code><br>光标遇到圆括号、方括号、大括号时，自动高亮对应的另一个圆括号、方括号和大括号。</p>
<p><code>set hlsearch</code><br>搜索时，高亮显示匹配结果。</p>
<p><code>set incsearch</code><br>输入搜索模式时，每输入一个字符，就自动跳到第一个匹配的结果。</p>
<p><code>set ignorecase</code><br>搜索时忽略大小写。</p>
<p><code>set smartcase</code><br>如果同时打开了ignorecase，那么对于只有一个大写字母的搜索词，将大小写敏感；其他情况都是大小写不敏感。比如，搜索Test时，将不匹配test；搜索test时，将匹配Test。</p>
<h2 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h2><p><code>set spell spelllang=en_us</code><br>打开英语单词的拼写检查。</p>
<p><code>set nobackup</code><br>不创建备份文件。默认情况下，文件保存时，会额外创建一个备份文件，它的文件名是在原文件名的末尾，再添加一个波浪号（〜）。</p>
<p><code>set noswapfile</code><br>不创建交换文件。交换文件主要用于系统崩溃时恢复文件，文件名的开头是.、结尾是.swp。</p>
<p><code>set undofile</code><br>保留撤销历史。</p>
<p>Vim 会在编辑时保存操作历史，用来供用户撤消更改。默认情况下，操作记录只在本次编辑时有效，一旦编辑结束、文件关闭，操作历史就消失了。</p>
<p>打开这个设置，可以在文件关闭后，操作记录保留在一个文件里面，继续存在。这意味着，重新打开一个文件，可以撤销上一次编辑时的操作。撤消文件是跟原文件保存在一起的隐藏文件，文件名以.un~开头。</p>
<h2 id="参考设置"><a href="#参考设置" class="headerlink" title="参考设置"></a>参考设置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> nu</span><br><span class="line"><span class="built_in">set</span> autoindent</span><br><span class="line"><span class="built_in">set</span> tabstop=4</span><br><span class="line"><span class="built_in">set</span> softtabstop=4</span><br><span class="line"><span class="built_in">set</span> expandtab</span><br><span class="line"><span class="built_in">set</span> shiftwidth=4</span><br><span class="line"><span class="built_in">set</span> ic</span><br><span class="line">syntax on</span><br><span class="line">map &lt;F12&gt; gg=G</span><br><span class="line"><span class="built_in">set</span> <span class="built_in">paste</span></span><br><span class="line"><span class="built_in">set</span> hlsearch</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> has(<span class="string">&quot;autocmd&quot;</span>)</span><br><span class="line">    au BufReadPost * <span class="keyword">if</span> line(<span class="string">&quot;&#x27;\&quot;&quot;</span>) &gt; 1 &amp;&amp; line(<span class="string">&quot;&#x27;\&quot;&quot;</span>) &lt;= line(<span class="string">&quot;$&quot;</span>) | exe <span class="string">&quot;normal! g&#x27;\&quot;&quot;</span> | endif</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">autocmd BufNewFile *.cpp,*.[ch],*.sh,*.java <span class="built_in">exec</span> <span class="string">&quot;:call SetTitle()&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;</span><span class="string">&quot;定义函数SetTitle，自动插入文件头</span></span><br><span class="line"><span class="string">func SetTitle()</span></span><br><span class="line"><span class="string">&quot;</span>如果文件类型为.sh文件</span><br><span class="line"><span class="keyword">if</span> &amp;filetype == <span class="string">&#x27;sh&#x27;</span></span><br><span class="line">call setline(1,<span class="string">&quot;\#########################################################################&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>), <span class="string">&quot;\# File Name: &quot;</span>.<span class="built_in">expand</span>(<span class="string">&quot;%&quot;</span>))</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+1, <span class="string">&quot;\#Created Time:&quot;</span>.strftime(<span class="string">&quot;%c&quot;</span>))</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+2, <span class="string">&quot;\#########################################################################&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+3,<span class="string">&quot;\#!/bin/bash&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+4,<span class="string">&quot;&quot;</span>)</span><br><span class="line">endif</span><br><span class="line"><span class="keyword">if</span> &amp;filetype == <span class="string">&#x27;cpp&#x27;</span></span><br><span class="line">call setline(1, <span class="string">&quot;//*************************************************************************&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>), <span class="string">&quot;#include&lt;stdio.h&gt;&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+1, <span class="string">&quot;#include&lt;stdlib.h&gt;&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+2, <span class="string">&quot;#include&lt;string.h&gt;&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+3, <span class="string">&quot;#include&lt;unistd.h&gt;&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+4, <span class="string">&quot;#include&lt;pthread.h&gt;&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+5, <span class="string">&quot;#include&lt;time.h&gt;&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+6, <span class="string">&quot;&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+7, <span class="string">&quot;int main(int argc, char* argv[])&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+8, <span class="string">&quot;&#123;&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+9, <span class="string">&quot;&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+10, <span class="string">&quot;    return 0;&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+11, <span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+12, <span class="string">&quot;&quot;</span>)</span><br><span class="line">endif</span><br><span class="line"><span class="keyword">if</span> &amp;filetype == <span class="string">&#x27;c&#x27;</span></span><br><span class="line">call setline(1, <span class="string">&quot;//*************************************************************************&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>), <span class="string">&quot;#include&lt;stdio.h&gt;&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+1, <span class="string">&quot;#include&lt;stdlib.h&gt;&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+2, <span class="string">&quot;#include&lt;string.h&gt;&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+3, <span class="string">&quot;#include&lt;unistd.h&gt;&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+4, <span class="string">&quot;#include&lt;pthread.h&gt;&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+5, <span class="string">&quot;&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+6, <span class="string">&quot;int main(int argc, char* argv[])&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+7, <span class="string">&quot;&#123;&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+8, <span class="string">&quot;&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+9, <span class="string">&quot;    return 0;&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+10, <span class="string">&quot;&#125;&quot;</span>)</span><br><span class="line">call append(line(<span class="string">&quot;.&quot;</span>)+11, <span class="string">&quot;&quot;</span>)</span><br><span class="line">endif</span><br><span class="line"><span class="string">&quot;新建文件后，自动定位到文件末尾</span></span><br><span class="line"><span class="string">autocmd BufNewFile * normal G</span></span><br><span class="line"><span class="string">endfunc</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>VIM</category>
      </categories>
      <tags>
        <tag>vimrc</tag>
      </tags>
  </entry>
  <entry>
    <title>DPDK/SPDK/OVS/QEMU源码编译</title>
    <url>/2022/06/05/DPDK-SPDK-OVS-QEMU%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h2 id="DPDK"><a href="#DPDK" class="headerlink" title="DPDK"></a>DPDK</h2><p><strong>源码路径</strong><br><a href="http://fast.dpdk.org/rel/dpdk-21.11.2.tar.xz">http://fast.dpdk.org/rel/dpdk-21.11.2.tar.xz</a></p>
<span id="more"></span>

<p><strong>基础包安装</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install build-essential libnuma-dev python3-pyelftools</span><br><span class="line">pip3 install meson ninja pwntools -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<p><strong>编译</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">CUR_PATH=`<span class="built_in">pwd</span>`</span><br><span class="line">DPDK_VERSION=21.11.2</span><br><span class="line">DPDKLIB_PATH=<span class="variable">$&#123;CUR_PATH&#125;</span>/dpdk_lib</span><br><span class="line">DPDKSRC_PATH=<span class="variable">$&#123;CUR_PATH&#125;</span>/dpdk-stable-<span class="variable">$&#123;DPDK_VERSION&#125;</span></span><br><span class="line">DPDKBUILD_PATH=<span class="variable">$&#123;DPDKSRC_PATH&#125;</span>/build</span><br><span class="line">MESON_BUILD=<span class="string">&quot;--prefix=<span class="variable">$&#123;DPDKLIB_PATH&#125;</span>&quot;</span></span><br><span class="line">MESON_BUILD+=<span class="string">&quot; -Dbuildtype=debug&quot;</span></span><br><span class="line"><span class="comment">#MESON_BUILD+=&quot; -Dmax_numa_nodes=16&quot;</span></span><br><span class="line">MESON_BUILD+=<span class="string">&quot; -Dexamples=all&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="variable">$&#123;DPDKLIB_PATH&#125;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">mkdir</span> -p <span class="variable">$&#123;DPDKLIB_PATH&#125;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="variable">$&#123;DPDKSRC_PATH&#125;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    tar xvf dpdk-<span class="variable">$&#123;DPDK_VERSION&#125;</span>.tar.xz</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;DPDKSRC_PATH&#125;</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="variable">$&#123;DPDKBUILD_PATH&#125;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">    <span class="built_in">rm</span> -rf <span class="variable">$&#123;DPDKBUILD_PATH&#125;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">meson <span class="variable">$&#123;MESON_BUILD&#125;</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">ninja</span><br><span class="line">ninja install</span><br><span class="line">sudo ldconfig</span><br><span class="line"><span class="built_in">cp</span> -f <span class="variable">$&#123;DPDKBUILD_PATH&#125;</span>/examples/dpdk-vdpa <span class="variable">$&#123;DPDKLIB_PATH&#125;</span>/bin/dpdk-vdpa</span><br></pre></td></tr></table></figure>

<h2 id="SPDK"><a href="#SPDK" class="headerlink" title="SPDK"></a>SPDK</h2><p>下载SPDK版本V20.10</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> -b V20.10 https:/http://github.com/spdk/spdk</span><br></pre></td></tr></table></figure>
<p>更新SPDK依赖模块 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git submodule update --init</span><br></pre></td></tr></table></figure>

<p>进入子目录scripts执行脚本，该脚本会检测环境是否满足编译SDPK </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh pkgdep.sh</span><br></pre></td></tr></table></figure>

<p>编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#########################################################################</span></span><br><span class="line"><span class="comment"># File Name: build.sh</span></span><br><span class="line"><span class="comment">#Created Time:Fri Jun  9 17:58:28 2023</span></span><br><span class="line"><span class="comment">#########################################################################</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">CUR_PATH=`<span class="built_in">pwd</span>`</span><br><span class="line">INSTALL_PATH=<span class="variable">$&#123;CUR_PATH&#125;</span>/spdk_install_dir</span><br><span class="line">SPDK_VERSION=20.10</span><br><span class="line">SPDKSRC_PATH=<span class="variable">$&#123;CUR_PATH&#125;</span>/spdk-<span class="variable">$&#123;SPDK_VERSION&#125;</span></span><br><span class="line">DPDK_LIB=<span class="variable">$&#123;CUR_PATH&#125;</span>/dpdk_lib/lib/x86_64-linux-gnu</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$&#123;INSTALL_PATH&#125;</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;SPDKSRC_PATH&#125;</span></span><br><span class="line"></span><br><span class="line">./configure --prefix=<span class="variable">$&#123;INSTALL_PATH&#125;</span> --enable-debug --without-rbd --with-dpdk=<span class="variable">$&#123;DPDK_LIB&#125;</span> --with-virtio</span><br><span class="line"></span><br><span class="line">make -j`grep -c ^processor /proc/cpuinfo` </span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h2 id="OVS"><a href="#OVS" class="headerlink" title="OVS"></a>OVS</h2><p><strong>源码路径</strong><br><a href="https://www.openvswitch.org/releases/openvswitch-2.17.6.tar.gz">https://www.openvswitch.org/releases/openvswitch-2.17.6.tar.gz</a></p>
<p><strong>基础包安装</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install build-essential fakeroot dh-make devscripts linux-headers-generic python3-distutils-extra dh-python pkg-config</span><br></pre></td></tr></table></figure>

<p><strong>编译</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">CUR_PATH=`<span class="built_in">pwd</span>`</span><br><span class="line">INSTALL_PATH=<span class="variable">$&#123;CUR_PATH&#125;</span>/install_dir</span><br><span class="line">OVS_VERSION=2.17.6</span><br><span class="line">OVSSRC_PATH=<span class="variable">$&#123;CUR_PATH&#125;</span>/openvswitch-<span class="variable">$&#123;OVS_VERSION&#125;</span></span><br><span class="line">DPDK_PKG=<span class="variable">$&#123;CUR_PATH&#125;</span>/dpdk_lib/lib/x86_64-linux-gnu/pkgconfig</span><br><span class="line"><span class="built_in">export</span> PKG_CONFIG_PATH=<span class="variable">$&#123;DPDK_PKG&#125;</span>:<span class="variable">$PKG_CONFIG_PATH</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$&#123;INSTALL_PATH&#125;</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$&#123;OVSSRC_PATH&#125;</span></span><br><span class="line"></span><br><span class="line">./configure --disable-ssl --disable-libcapng CFLAGS=<span class="string">&quot;-g&quot;</span> --with-dpdk=<span class="built_in">yes</span>  \</span><br><span class="line">   --prefix=<span class="variable">$&#123;INSTALL_PATH&#125;</span>/usr --localstatedir=<span class="variable">$&#123;INSTALL_PATH&#125;</span>/var --sysconfdir=<span class="variable">$&#123;INSTALL_PATH&#125;</span>/etc</span><br><span class="line">make -j`grep -c ^processor /proc/cpuinfo` </span><br><span class="line">make install</span><br><span class="line">make modules_install</span><br></pre></td></tr></table></figure>

<h2 id="QEMU"><a href="#QEMU" class="headerlink" title="QEMU"></a>QEMU</h2><p><strong>源码路径</strong><br><a href="https://download.qemu.org/qemu-6.2.0.tar.xz">https://download.qemu.org/qemu-6.2.0.tar.xz</a></p>
<p><strong>编译</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">CUR_PATH=`<span class="built_in">pwd</span>`</span><br><span class="line">INSTALL_PATH=<span class="variable">$&#123;CUR_PATH&#125;</span>/install_dir</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p <span class="variable">$&#123;CUR_PATH&#125;</span>/install_dir</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> qemu-6.2.0</span><br><span class="line"><span class="built_in">rm</span> -rf build</span><br><span class="line"><span class="built_in">mkdir</span> -p build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line"></span><br><span class="line">../configure --prefix=<span class="variable">$&#123;INSTALL_PATH&#125;</span> --enable-trace-backends=<span class="built_in">log</span> --enable-kvm --enable-debug \</span><br><span class="line">--enable-debug-info --enable-vnc --target-list=x86_64-softmmu</span><br><span class="line"><span class="comment">#编译arm版本 --target-list=aarch64-softmmu</span></span><br><span class="line"></span><br><span class="line">make -j`grep -c ^processor /proc/cpuinfo` </span><br><span class="line"></span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>qemu启动参数</title>
    <url>/2022/06/05/qemu%E5%90%AF%E5%8A%A8%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<h3 id="设备类型（-machine-M）"><a href="#设备类型（-machine-M）" class="headerlink" title="设备类型（-machine/-M）"></a>设备类型（-machine/-M）</h3><p>在qemu中，不同的指令集的模拟器会编译成不同的可执行文件，诸如：<code>qemu-system-x86_64/qemu-system-aarch64/qemu-system-arm/qemu-system-mips/qemu-system-riscv64</code></p>
<span id="more"></span>

<p>但相同指令集肯定存在不同的设备，尤其是在嵌入式设备上。使用参数-machine help运行模拟器可以查看当前模拟器支持的设备信息，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qqm@ubuntu: qemu-system-riscv64 -machine help      </span><br><span class="line">Supported machines are:</span><br><span class="line">microchip-icicle-kit Microchip PolarFire SoC Icicle Kit</span><br><span class="line">none                 empty machine</span><br><span class="line">quard-star           RISC-V Quard Star board</span><br><span class="line">sifive_e             RISC-V Board compatible with SiFive E SDK</span><br><span class="line">sifive_u             RISC-V Board compatible with SiFive U SDK</span><br><span class="line">spike                RISC-V Spike board (default)</span><br><span class="line">virt                 RISC-V VirtIO board</span><br><span class="line"></span><br><span class="line">qqm@ubuntu: qemu-system-aarch64 -machine help </span><br><span class="line">Supported machines are:</span><br><span class="line">akita                Sharp SL-C1000 (Akita) PDA (PXA270)</span><br><span class="line">ast2500-evb          Aspeed AST2500 EVB (ARM1176)</span><br><span class="line">ast2600-evb          Aspeed AST2600 EVB (Cortex A7)</span><br><span class="line">borzoi               Sharp SL-C3100 (Borzoi) PDA (PXA270)</span><br><span class="line">canon-a1100          Canon PowerShot A1100 IS (ARM946)</span><br><span class="line">cheetah              Palm Tungsten|E aka. Cheetah PDA (OMAP310)</span><br><span class="line">collie               Sharp SL-5500 (Collie) PDA (SA-1110)</span><br><span class="line">connex               Gumstix Connex (PXA255)</span><br><span class="line">cubieboard           cubietech cubieboard (Cortex-A8)</span><br><span class="line">emcraft-sf2          SmartFusion2 SOM kit from Emcraft (M2S010)</span><br><span class="line">g220a-bmc            Bytedance G220A BMC (ARM1176)</span><br><span class="line">highbank             Calxeda Highbank (ECX-1000)</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>模拟器运行时必须选择一个具体的设备，比如运行树梅派3B则执行qemu-system-aarch64 -machine raspi3b或qemu-system-aarch64 -M raspi3b，运行Quard Star board则是执行qemu-system-riscv64 -machine quard-star或qemu-system-aarch64 -M quard-star。qemu定义使用virt来进行通用模拟而非实际的某SOC。</p>
<p>具体到设备本身可能还有额外的参数作为可选项供使用者配置，要查看设备的可选参数可以使用-machine ‘id’,help，如下示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qqm@ubuntu: qemu-system-riscv64 -machine quard-star,help</span><br><span class="line">quard-star.hmat=bool (Set on/off to enable/disable ACPI Heterogeneous Memory Attribute Table (HMAT))</span><br><span class="line">quard-star.mask-rom-path=string (Quard Star Mask ROM image file)</span><br><span class="line">quard-star.suppress-vmdesc=bool (Set on to disable self-describing migration)</span><br><span class="line">quard-star.append=string (Linux kernel command line)</span><br><span class="line">quard-star.mem-merge=bool (Enable/disable memory merge support)</span><br><span class="line">quard-star.dtb=string (Linux kernel device tree file)</span><br><span class="line">quard-star.memory-backend=string (Set RAM backendValid value is ID of hostmem based backend)</span><br><span class="line">quard-star.dumpdtb=string (Dump current dtb to a file and quit)</span><br><span class="line">quard-star.phandle-start=int (The first phandle ID we may generate dynamically)</span><br><span class="line">quard-star.dump-guest-core=bool (Include guest memory in a core dump)</span><br><span class="line">quard-star.memory-encryption=string (Set memory encryption object to use)</span><br><span class="line">quard-star.firmware=string (Firmware image)</span><br><span class="line">quard-star.usb=bool (Set on/off to enable/disable usb)</span><br><span class="line">quard-star.graphics=bool (Set on/off to enable/disable graphics emulation)</span><br><span class="line">quard-star.confidential-guest-support=link&lt;confidential-guest-support&gt; (Set confidential guest scheme to support)</span><br><span class="line">quard-star.initrd=string (Linux initial ramdisk file)</span><br><span class="line">quard-star.dt-compatible=string (Overrides the &quot;compatible&quot; property of the dt root node)</span><br><span class="line">quard-star.kernel=string (Linux kernel image file)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>因此你可以看到我们的run.sh使用了mask-rom-path参数为quard-star指定maskrom固件路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-M quard-star,mask-rom-path=&quot;$SHELL_FOLDER/output/mask_rom/mask_rom.bin&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="内存大小（-m）"><a href="#内存大小（-m）" class="headerlink" title="内存大小（-m）"></a>内存大小（-m）</h3><p>参数-m 1G就是指定虚拟机内部的内存大小为1GB，帮助说明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qqm@ubuntu: qemu-system-riscv64 -m help</span><br><span class="line">qemu-system-riscv64: -m help: Parameter &#x27;size&#x27; expects a non-negative number below 2^64</span><br><span class="line">Optional suffix k, M, G, T, P or E means kilo-, mega-, giga-, tera-, peta-</span><br><span class="line">and exabytes, respectively.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="核心数（-smp）"><a href="#核心数（-smp）" class="headerlink" title="核心数（-smp）"></a>核心数（-smp）</h3><p>现代cpu往往是对称多核心的，因此通过指定-smp 8可以指定虚拟机核心数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qqm@ubuntu: qemu-system-riscv64 -smp help</span><br><span class="line">qemu-system-riscv64: -smp help: Parameter &#x27;cpus&#x27; expects a number</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="驱动器映像文件（-drive）"><a href="#驱动器映像文件（-drive）" class="headerlink" title="驱动器映像文件（-drive）"></a>驱动器映像文件（-drive）</h3><p>-drive用来添加映像文件，一般用于块设备，常见配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-drive if=none,format=raw,file=./usb.img,id=usb0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一般来讲必须要配置file参数，qemu会根据文件内容自动匹配format，但是最好还是显式声明format=raw更好，qemu支持的format非常多，甚至包括ftp、http等网络地址，详细可以查阅<a href="https://www.qemu.org/docs/master/system/images.html">qemu文档-磁盘映像</a>，我们最简单透明的就是直接使用raw格式。if参数用来指定匹配设备内部的块设备，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-drive if=pflash,bus=0,unit=0,format=raw,file=$SHELL_FOLDER/output/fw/fw.bin,id=mtd0 \</span><br><span class="line">-drive if=mtd,format=raw,file=$SHELL_FOLDER/output/fw/norflash.img,id=mtd1 \</span><br><span class="line">-drive if=none,format=raw,file=$SHELL_FOLDER/output/fw/usb.img,id=usb0 \</span><br><span class="line">-drive if=sd,format=raw,file=$SHELL_FOLDER/output/fw/sd.img,id=sd0 \</span><br><span class="line">-drive if=none,format=raw,file=$SHELL_FOLDER/output/rootfs/rootfs.img,id=disk0 \</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样设备映像就匹配到设备源码drive_get_next中的具体ip，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drive_get_next(IF_SD);</span><br><span class="line">drive_get_next(IF_MTD);</span><br><span class="line">drive_get_next(IF_PFLASH);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="网络设备（-netdev）"><a href="#网络设备（-netdev）" class="headerlink" title="网络设备（-netdev）"></a>网络设备（-netdev）</h3><p>网络设备配置常见两种，一种是user模式，一种是tap模式，这里分别介绍：</p>
<h4 id="user模式"><a href="#user模式" class="headerlink" title="user模式"></a>user模式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-netdev user,net=192.168.31.0/24,host=192.168.31.2,hostname=qemu,dns=192.168.31.56,tftp=$SHELL_FOLDER/output,bootfile=/linux_kernel/Image,dhcpstart=192.168.31.100,hostfwd=tcp::3522-:22,hostfwd=tcp::3580-:80,id=net0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如上为user模式配置的一个实例，user模式下，客户机和宿主机之间可以建立tcp/udp连接，且可以配置端口转发将客户机中的端口转发到宿主机上。</p>
<ul>
<li>  net=192.168.31.0/24 ：配置网关地址/子网掩码</li>
<li>  host=192.168.31.2 ：配置主机地址</li>
<li>  hostname=qemu ：配置主机名称</li>
<li>  dns=192.168.31.56 ：创建一个dns服务器</li>
<li>  tftp=$SHELL_FOLDER/output,bootfile=/linux_kernel/Image：创建一个tftp服务器</li>
<li>  dhcpstart=192.168.31.100：dhcp地址分配起始地址</li>
<li>  hostfwd=tcp::3522-:22：端口转发将客户机的22端口转发到宿主机的3522端口</li>
</ul>
<p>user模式的缺点是客户机无法支持全部的ip协议，但其使用简单，无需对宿主机进行额外的配置。</p>
<h4 id="tap模式"><a href="#tap模式" class="headerlink" title="tap模式"></a>tap模式</h4><p>tap即在宿主机上创建一个虚拟网卡设备tap0，客户机使用这个网卡设备进行网络通信，优点是对于客户机网卡设备与真实网卡相似，但是缺点是宿主机需要额外工具进行大量配置，网络拓扑结构复杂。</p>
<p>网桥一般需要手动配置，不过qemu提供了一个qemu-bridge-helper工具可以自动配置网桥，需要配置echo “allow br0” &gt; /etc/qemu/bridge.conf文件，启动qemu参数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-netdev tap,helper=/libexec/qemu-bridge-helper,id=net0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不过如此使用需要qemu使用root权限才能创建网桥，如此对整个qemu提高权限非常不合适，这里我还是建议自己配置网桥后使用如下命令启动qemu。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-netdev tap,ifname=tap0,script=no,downscript=no,id=net0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>网桥的配置方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">set -e</span><br><span class="line"></span><br><span class="line">MODE=\</span><br><span class="line">&quot;config_tap | \</span><br><span class="line">release_tap&quot;</span><br><span class="line"></span><br><span class="line">USER_NAME=$(whoami)</span><br><span class="line">USAGE=&quot;usage $0 [$MODE] [&lt;ETH_NAME&gt;] &quot;</span><br><span class="line"></span><br><span class="line">if [ $# == 2 ] ; then</span><br><span class="line">	ETH_NAME=$1</span><br><span class="line">else</span><br><span class="line">    ETH_NAME=enp2s0f0 #eth0</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">config_tap()</span><br><span class="line">&#123;</span><br><span class="line">    brctl addbr br0</span><br><span class="line">    ip addr flush dev $ETH_NAME</span><br><span class="line">    brctl addif br0 $ETH_NAME</span><br><span class="line">    tunctl -t tap0 -u $USER_NAME</span><br><span class="line">    brctl addif br0 tap0</span><br><span class="line">    ifconfig $ETH_NAME up</span><br><span class="line">    ifconfig tap0 up</span><br><span class="line">    ifconfig br0 up</span><br><span class="line">    ip addr flush dev br0</span><br><span class="line">    ip addr flush dev tap0</span><br><span class="line">    ip addr flush dev $ETH_NAME</span><br><span class="line"></span><br><span class="line">    # static</span><br><span class="line">    ip addr add 169.254.105.176/16 brd + dev br0</span><br><span class="line">    # dynamic</span><br><span class="line">    #dhclient -v br0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">release_tap()</span><br><span class="line">&#123;</span><br><span class="line">    brctl delif br0 tap0</span><br><span class="line">    tunctl -d tap0</span><br><span class="line">    brctl delif br0 $ETH_NAME</span><br><span class="line">    ifconfig br0 down</span><br><span class="line">    brctl delbr br0</span><br><span class="line">    ifconfig $ETH_NAME up</span><br><span class="line"></span><br><span class="line">    # static</span><br><span class="line">    ip addr add 169.254.105.176/16 brd + dev $ETH_NAME</span><br><span class="line">    # dynamic</span><br><span class="line">    #dhclient -v $ETH_NAME</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">case &quot;$1&quot; in</span><br><span class="line">config_tap)</span><br><span class="line">    config_tap</span><br><span class="line">	;;</span><br><span class="line">release_tap)</span><br><span class="line">    release_tap</span><br><span class="line">	;;</span><br><span class="line">--help)</span><br><span class="line">	echo $USAGE</span><br><span class="line">	exit 0</span><br><span class="line">	;;</span><br><span class="line">*)</span><br><span class="line">	echo $USAGE</span><br><span class="line">	exit 1	</span><br><span class="line">	;;</span><br><span class="line">esac</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>完成配置后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">br0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 169.254.105.176  netmask 255.255.0.0  broadcast 169.254.255.255</span><br><span class="line">        ether 0a:0e:24:90:6a:e9  txqueuelen 1000  (以太网)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 7  bytes 811 (811.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">enp2s0f0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        ether 02:42:41:29:3f:f3  txqueuelen 1000  (以太网)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">tap0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        ether 0a:0e:24:90:6a:e9  txqueuelen 1000  (以太网)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后一般情况下的无线网卡sta是不支持网桥的，因此tap方式只能和有线网卡桥接。<a href="https://blog.stdio.io/954">更多参考</a>。</p>
<h3 id="字符设备（-chardev）"><a href="#字符设备（-chardev）" class="headerlink" title="字符设备（-chardev）"></a>字符设备（-chardev）</h3><p>qemu中创建字符设备的典型应用就是模拟ttyUSB的设备，如下参数配置可以在宿主机打开一个telnet服务器，我们可以从外部连接到qemu内部，配合device选项可以关联到内部的usb-serial。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-chardev socket,telnet=on,host=127.0.0.1,port=3450,server=on,wait=off,id=usb1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-device usb-serial,always-plugged=true,chardev=usb1 \</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>字符设备支持如下类型：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qqm@ubuntu: qemu-system-riscv64 -chardev help      </span><br><span class="line">Available chardev backend types: </span><br><span class="line">  ringbuf</span><br><span class="line">  mux</span><br><span class="line">  pipe</span><br><span class="line">  null</span><br><span class="line">  msmouse</span><br><span class="line">  socket</span><br><span class="line">  vc</span><br><span class="line">  parallel</span><br><span class="line">  memory</span><br><span class="line">  udp</span><br><span class="line">  file</span><br><span class="line">  pty</span><br><span class="line">  serial</span><br><span class="line">  wctablet</span><br><span class="line">  stdio</span><br><span class="line">  testdev</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>具体字符设备类型还可以指定更多参数，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qemu-system-riscv64 -chardev sockeet,help</span><br><span class="line">chardev options:</span><br><span class="line">  abstract=&lt;bool (on/off)&gt;</span><br><span class="line">  append=&lt;bool (on/off)&gt;</span><br><span class="line">  backend=&lt;str&gt;</span><br><span class="line">  chardev=&lt;str&gt;</span><br><span class="line">  cols=&lt;num&gt;</span><br><span class="line">  debug=&lt;num&gt;</span><br><span class="line">  delay=&lt;bool (on/off)&gt;</span><br><span class="line">  fd=&lt;str&gt;</span><br><span class="line">  height=&lt;num&gt;</span><br><span class="line">  host=&lt;str&gt;</span><br><span class="line">  ipv4=&lt;bool (on/off)&gt;</span><br><span class="line">  ipv6=&lt;bool (on/off)&gt;</span><br><span class="line">  localaddr=&lt;str&gt;</span><br><span class="line">  localport=&lt;str&gt;</span><br><span class="line">  logappend=&lt;bool (on/off)&gt;</span><br><span class="line">  logfile=&lt;str&gt;</span><br><span class="line">  mux=&lt;bool (on/off)&gt;</span><br><span class="line">  name=&lt;str&gt;</span><br><span class="line">  nodelay=&lt;bool (on/off)&gt;</span><br><span class="line">  path=&lt;str&gt;</span><br><span class="line">  port=&lt;str&gt;</span><br><span class="line">  reconnect=&lt;num&gt;</span><br><span class="line">  rows=&lt;num&gt;</span><br><span class="line">  server=&lt;bool (on/off)&gt;</span><br><span class="line">  signal=&lt;bool (on/off)&gt;</span><br><span class="line">  size=&lt;size&gt;</span><br><span class="line">  telnet=&lt;bool (on/off)&gt;</span><br><span class="line">  tight=&lt;bool (on/off)&gt;</span><br><span class="line">  tls-authz=&lt;str&gt;</span><br><span class="line">  tls-creds=&lt;str&gt;</span><br><span class="line">  tn3270=&lt;bool (on/off)&gt;</span><br><span class="line">  to=&lt;num&gt;</span><br><span class="line">  wait=&lt;bool (on/off)&gt;</span><br><span class="line">  websocket=&lt;bool (on/off)&gt;</span><br><span class="line">  width=&lt;num&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="文件系统设备（-fsdev）"><a href="#文件系统设备（-fsdev）" class="headerlink" title="文件系统设备（-fsdev）"></a>文件系统设备（-fsdev）</h3><p>-fsdev并不常用，但在使用virtio-9p-device设备时会很有用，使用虚拟机软件时，一般都提供一个共享目录功能，让虚拟机和主机可以同时访问同一目录，方便交互文件，virtio-9p-device设备就能实现类似功能，示例参数配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-fsdev local,security_model=mapped-xattr,path=$SHELL_FOLDER,id=fsdev0</span><br><span class="line">-device virtio-9p-device,fsdev=fsdev0,mount_tag=hostshare,id=fs0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由-fsdev选项配置宿主机要共享的路径（path参数），共享模型（security_model参数）指的是关于共享目录的权限处理，这里建议时使用mapped-xattr映射权限，这样在host下权限为运行qemu用户的权限，guest有权进行读和写。</p>
<p>另外qemu支持virtio-9p-device需要的libattr1-dev，否则无法支持这一功能。</p>
<h3 id="音频设备（-audiodev）"><a href="#音频设备（-audiodev）" class="headerlink" title="音频设备（-audiodev）"></a>音频设备（-audiodev）</h3><p>-audiodev用于指定创建host上的音频设备，配置id，以便连接到guest上的音频仿真硬件,该选项参数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-audiodev [driver=]driver,id=id[,prop[=value][,...]]</span><br><span class="line">                specifies the audio backend to use</span><br><span class="line">                id= identifier of the backend</span><br><span class="line">                timer-period= timer period in microseconds</span><br><span class="line">                in|out.mixing-engine= use mixing engine to mix streams inside QEMU</span><br><span class="line">                in|out.fixed-settings= use fixed settings for host audio</span><br><span class="line">                in|out.frequency= frequency to use with fixed settings</span><br><span class="line">                in|out.channels= number of channels to use with fixed settings</span><br><span class="line">                in|out.format= sample format to use with fixed settings</span><br><span class="line">                valid values: s8, s16, s32, u8, u16, u32, f32</span><br><span class="line">                in|out.voices= number of voices to use</span><br><span class="line">                in|out.buffer-length= length of buffer in microseconds</span><br><span class="line">-audiodev none,id=id,[,prop[=value][,...]]</span><br><span class="line">                dummy driver that discards all output</span><br><span class="line">-audiodev alsa,id=id[,prop[=value][,...]]</span><br><span class="line">                in|out.dev= name of the audio device to use</span><br><span class="line">                in|out.period-length= length of period in microseconds</span><br><span class="line">                in|out.try-poll= attempt to use poll mode</span><br><span class="line">                threshold= threshold (in microseconds) when playback starts</span><br><span class="line">-audiodev oss,id=id[,prop[=value][,...]]</span><br><span class="line">                in|out.dev= path of the audio device to use</span><br><span class="line">                in|out.buffer-count= number of buffers</span><br><span class="line">                in|out.try-poll= attempt to use poll mode</span><br><span class="line">                try-mmap= try using memory mapped access</span><br><span class="line">                exclusive= open device in exclusive mode</span><br><span class="line">                dsp-policy= set timing policy (0..10), -1 to use fragment mode</span><br><span class="line">-audiodev pa,id=id[,prop[=value][,...]]</span><br><span class="line">                server= PulseAudio server address</span><br><span class="line">                in|out.name= source/sink device name</span><br><span class="line">                in|out.latency= desired latency in microseconds</span><br><span class="line">-audiodev sdl,id=id[,prop[=value][,...]]</span><br><span class="line">                in|out.buffer-count= number of buffers</span><br><span class="line">-audiodev wav,id=id[,prop[=value][,...]]</span><br><span class="line">                path= path of wav file to record</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里要注意你的qemu不一定支持这么多音频框架，需要在编译qemu时指定config选项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--audio-drv-list=pa,alsa,sdl,oss</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果在windows上的qemu，则不支持以上框架，一般用dsound框架。</p>
<h3 id="全局参数（-global）"><a href="#全局参数（-global）" class="headerlink" title="全局参数（-global）"></a>全局参数（-global）</h3><p>-global一般用于配置qemu的全局参数选项，可配置的内容非常多，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">global options:</span><br><span class="line">  driver=&lt;str&gt;</span><br><span class="line">  property=&lt;str&gt;</span><br><span class="line">  value=&lt;str&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-global virtio-mmio.force-legacy=false</span><br><span class="line">-global quard-star-syscon.boot-cfg=&quot;$DBOOTCFG&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如何查看可用的选项呢？我这里没找到更好的办法，原则上如果你有qemu的源码，在源码中搜索DEFINE_PROP即可看到类似如下的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DEFINE_PROP_STRING(&quot;boot-cfg&quot;, QuardStarSysconState, boot_cfg),</span><br><span class="line">DEFINE_PROP_BOOL(&quot;update-cfg&quot;, QuardStarSysconState, update_cfg, true),</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里的选项均作为global的可配置参数使用，这部分参数配置最好能阅读qemu的源码理解使用，否则不建议配置这些参数。</p>
<h3 id="设备（-device）"><a href="#设备（-device）" class="headerlink" title="设备（-device）"></a>设备（-device）</h3><p>-device常用于指定guest上总线挂载的外部设备，例如virtio-mmio、usb、pci等总线，示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-device virtio-blk-device,drive=disk0,id=hd0 \</span><br><span class="line">-device virtio-gpu-device,xres=$WIDTH,yres=$HEIGHT,id=video0 \</span><br><span class="line">-device virtio-mouse-device,id=input0 \</span><br><span class="line">-device virtio-keyboard-device,id=input1 \</span><br><span class="line">-device virtio-9p-device,fsdev=fsdev0,mount_tag=hostshare,id=fs0 \</span><br><span class="line">-device virtio-net-device,netdev=net0 \</span><br><span class="line">-device usb-storage,drive=usb0 \</span><br><span class="line">-device usb-serial,always-plugged=true,chardev=usb1 \</span><br><span class="line">-device wm8750,audiodev=audio0 \</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意有些设备需要匹配host上的真实设备驱动模拟，一般要匹配类似chardev\audiodev\fsdev\netdev。</p>
<h3 id="显示选项（-display）"><a href="#显示选项（-display）" class="headerlink" title="显示选项（-display）"></a>显示选项（-display）</h3><p>-display与-audiodev情况类似，主要是看qemu在编译时配置那些gui框架，目前建议在ubuntu上使用gtk效果良好。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-display sdl[,alt_grab=on|off][,ctrl_grab=on|off]</span><br><span class="line">            [,window_close=on|off][,gl=on|core|es|off]</span><br><span class="line">-display gtk[,grab_on_hover=on|off][,gl=on|off]|</span><br><span class="line">-display vnc=&lt;display&gt;[,&lt;optargs&gt;]</span><br><span class="line">-display curses[,charset=&lt;encoding&gt;]</span><br><span class="line">-display egl-headless[,rendernode=&lt;file&gt;]</span><br><span class="line">-display none</span><br><span class="line">                select display backend type</span><br><span class="line">                The default display is equivalent to</span><br><span class="line">                &quot;-display gtk&quot;</span><br><span class="line">-nographic      disable graphical output and redirect serial I/Os to console</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>配置示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--display gtk,zoom-to-fit=false</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果你不想仿真GUI时可以使用-nographic选项。</p>
<h3 id="终端选项（–serial-–parallel-–monitor）"><a href="#终端选项（–serial-–parallel-–monitor）" class="headerlink" title="终端选项（–serial　–parallel　–monitor）"></a>终端选项（–serial　–parallel　–monitor）</h3><p>终端包括三类串行终端，并行终端，qemu命令监控终端。</p>
<p>终端对应的host设备可以是以下选项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--serial stdio</span><br><span class="line">--serial vc:1280x720</span><br><span class="line">--serial telnet:127.0.0.1:3441,server,nowait</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>绑定stdio即host的标准输入输出，vc:1280x720即GUI显示窗口（注意配置合适的分辨率），telnet为打开一个服务器用于终端交互。</p>
<h3 id="调试选项（-s-d）"><a href="#调试选项（-s-d）" class="headerlink" title="调试选项（-s -d）"></a>调试选项（-s -d）</h3><p>很多人使用qemu有一个最大的原因就是对目标代码进行验证仿真调试，以便解决在真机上不便于调试的情况。这里介绍两个调试分析相关的选项。</p>
<h4 id="s"><a href="#s" class="headerlink" title="-s"></a>-s</h4><p>-s -S或-gdb tcp::1234 -S选项用于启动gdb服务，启动后qemu不立即运行guest，而是等待主机gdb发起连接，此时使用gdb输入target remote:1234可以进行相关调试，与真机调试无异。</p>
<h4 id="d"><a href="#d" class="headerlink" title="-d"></a>-d</h4><p>如果qemu参数添加-d help，可以得到如下输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Log items (comma separated):</span><br><span class="line">out_asm         show generated host assembly code for each compiled TB</span><br><span class="line">in_asm          show target assembly code for each compiled TB</span><br><span class="line">op              show micro ops for each compiled TB</span><br><span class="line">op_opt          show micro ops after optimization</span><br><span class="line">op_ind          show micro ops before indirect lowering</span><br><span class="line">int             show interrupts/exceptions in short format</span><br><span class="line">exec            show trace before each executed TB (lots of logs)</span><br><span class="line">cpu             show CPU registers before entering a TB (lots of logs)</span><br><span class="line">fpu             include FPU registers in the &#x27;cpu&#x27; logging</span><br><span class="line">mmu             log MMU-related activities</span><br><span class="line">pcall           x86 only: show protected mode far calls/returns/exceptions</span><br><span class="line">cpu_reset       show CPU state before CPU resets</span><br><span class="line">unimp           log unimplemented functionality</span><br><span class="line">guest_errors    log when the guest OS does something invalid (eg accessing a</span><br><span class="line">non-existent register)</span><br><span class="line">page            dump pages at beginning of user mode emulation</span><br><span class="line">nochain         do not chain compiled TBs so that &quot;exec&quot; and &quot;cpu&quot; show</span><br><span class="line">complete traces</span><br><span class="line">plugin          output from TCG plugins</span><br><span class="line"></span><br><span class="line">strace          log every user-mode syscall, its input, and its result</span><br><span class="line">trace:PATTERN   enable trace events</span><br><span class="line"></span><br><span class="line">Use &quot;-d trace:help&quot; to get a list of trace events.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中非常有用的选项，如：-d in_asm/int/page/mmu/strace -D qemu.log都可以给我们输出很多guest运行时的信息到qemu.log文件中，因此可以进行一些非侵入式观察调试行为，便于软件分析。</p>
<h3 id="vfio-设备"><a href="#vfio-设备" class="headerlink" title="vfio 设备"></a>vfio 设备</h3><h4 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;domain type=&#x27;kvm&#x27; id=&#x27;1&#x27;&gt;</span><br><span class="line">  &lt;name&gt;vm&lt;/name&gt;</span><br><span class="line">  &lt;uuid&gt;8c6ebff0-eb21-11eb-a2af-0c48c6c88118&lt;/uuid&gt;</span><br><span class="line">  &lt;memory unit=&#x27;KiB&#x27;&gt;2097152&lt;/memory&gt;</span><br><span class="line">  &lt;currentMemory unit=&#x27;KiB&#x27;&gt;2097152&lt;/currentMemory&gt;</span><br><span class="line">  &lt;vcpu placement=&#x27;static&#x27;&gt;2&lt;/vcpu&gt;</span><br><span class="line">  &lt;resource&gt;</span><br><span class="line">    &lt;partition&gt;/machine&lt;/partition&gt;</span><br><span class="line">  &lt;/resource&gt;</span><br><span class="line">  &lt;os&gt;</span><br><span class="line">    &lt;type arch=&#x27;x86_64&#x27; machine=&#x27;pc-i440fx-2.1&#x27;&gt;hvm&lt;/type&gt;</span><br><span class="line">  &lt;/os&gt;</span><br><span class="line">  &lt;features&gt;</span><br><span class="line">    &lt;acpi/&gt;</span><br><span class="line">  &lt;/features&gt;</span><br><span class="line">  &lt;cpu mode=&#x27;custom&#x27; match=&#x27;exact&#x27; check=&#x27;full&#x27;&gt;</span><br><span class="line">    &lt;model fallback=&#x27;forbid&#x27;&gt;kvm64&lt;/model&gt;</span><br><span class="line">    &lt;feature policy=&#x27;require&#x27; name=&#x27;x2apic&#x27;/&gt;</span><br><span class="line">    &lt;feature policy=&#x27;require&#x27; name=&#x27;hypervisor&#x27;/&gt;</span><br><span class="line">  &lt;/cpu&gt;</span><br><span class="line">  &lt;clock offset=&#x27;utc&#x27;/&gt;</span><br><span class="line">  &lt;on_poweroff&gt;destroy&lt;/on_poweroff&gt;</span><br><span class="line">  &lt;on_reboot&gt;restart&lt;/on_reboot&gt;</span><br><span class="line">  &lt;on_crash&gt;destroy&lt;/on_crash&gt;</span><br><span class="line">  &lt;devices&gt;</span><br><span class="line">    &lt;emulator&gt;/root/pc-bios/qemu-system-x86_64&lt;/emulator&gt;</span><br><span class="line">    &lt;controller type=&#x27;pci&#x27; index=&#x27;0&#x27; model=&#x27;pci-root&#x27;&gt;</span><br><span class="line">      &lt;alias name=&#x27;pci.0&#x27;/&gt;</span><br><span class="line">    &lt;/controller&gt;</span><br><span class="line">    &lt;controller type=&#x27;usb&#x27; index=&#x27;0&#x27; model=&#x27;piix3-uhci&#x27;&gt;</span><br><span class="line">      &lt;alias name=&#x27;usb&#x27;/&gt;</span><br><span class="line">      &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x01&#x27; function=&#x27;0x2&#x27;/&gt;</span><br><span class="line">    &lt;/controller&gt;</span><br><span class="line">    &lt;input type=&#x27;mouse&#x27; bus=&#x27;ps2&#x27;&gt;</span><br><span class="line">      &lt;alias name=&#x27;input0&#x27;/&gt;</span><br><span class="line">    &lt;/input&gt;</span><br><span class="line">    &lt;input type=&#x27;keyboard&#x27; bus=&#x27;ps2&#x27;&gt;</span><br><span class="line">      &lt;alias name=&#x27;input1&#x27;/&gt;</span><br><span class="line">    &lt;/input&gt;</span><br><span class="line">    &lt;graphics type=&#x27;vnc&#x27; port=&#x27;5900&#x27; autoport=&#x27;yes&#x27; listen=&#x27;0.0.0.0&#x27;&gt;</span><br><span class="line">      &lt;listen type=&#x27;address&#x27; address=&#x27;0.0.0.0&#x27;/&gt;</span><br><span class="line">    &lt;/graphics&gt;</span><br><span class="line">    &lt;audio id=&#x27;1&#x27; type=&#x27;none&#x27;/&gt;</span><br><span class="line">    &lt;video&gt;</span><br><span class="line">      &lt;model type=&#x27;cirrus&#x27; vram=&#x27;16384&#x27; heads=&#x27;1&#x27; primary=&#x27;yes&#x27;/&gt;</span><br><span class="line">      &lt;alias name=&#x27;video0&#x27;/&gt;</span><br><span class="line">      &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x02&#x27; function=&#x27;0x0&#x27;/&gt;</span><br><span class="line">    &lt;/video&gt;</span><br><span class="line">    &lt;hostdev mode=&#x27;subsystem&#x27; type=&#x27;pci&#x27; managed=&#x27;yes&#x27;&gt;</span><br><span class="line">      &lt;driver name=&#x27;vfio&#x27;/&gt;</span><br><span class="line">      &lt;source&gt;</span><br><span class="line">        &lt;address domain=&#x27;0x0000&#x27; bus=&#x27;0x65&#x27; slot=&#x27;0x00&#x27; function=&#x27;0x1&#x27;/&gt;</span><br><span class="line">      &lt;/source&gt;</span><br><span class="line">      &lt;boot order=&#x27;1&#x27;/&gt;</span><br><span class="line">      &lt;alias name=&#x27;hostdev0&#x27;/&gt;</span><br><span class="line">      &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x09&#x27; function=&#x27;0x0&#x27;/&gt;</span><br><span class="line">    &lt;/hostdev&gt;</span><br><span class="line">    &lt;hostdev mode=&#x27;subsystem&#x27; type=&#x27;pci&#x27; managed=&#x27;yes&#x27;&gt;</span><br><span class="line">      &lt;driver name=&#x27;vfio&#x27;/&gt;</span><br><span class="line">      &lt;source&gt;</span><br><span class="line">        &lt;address domain=&#x27;0x0000&#x27; bus=&#x27;0x65&#x27; slot=&#x27;0x00&#x27; function=&#x27;0x2&#x27;/&gt;</span><br><span class="line">      &lt;/source&gt;</span><br><span class="line">      &lt;alias name=&#x27;hostdev1&#x27;/&gt;</span><br><span class="line">      &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x0a&#x27; function=&#x27;0x0&#x27;/&gt;</span><br><span class="line">    &lt;/hostdev&gt;</span><br><span class="line">    &lt;hostdev mode=&#x27;subsystem&#x27; type=&#x27;pci&#x27; managed=&#x27;yes&#x27;&gt;</span><br><span class="line">      &lt;driver name=&#x27;vfio&#x27;/&gt;</span><br><span class="line">      &lt;source&gt;</span><br><span class="line">        &lt;address domain=&#x27;0x0000&#x27; bus=&#x27;0x65&#x27; slot=&#x27;0x00&#x27; function=&#x27;0x3&#x27;/&gt;</span><br><span class="line">      &lt;/source&gt;</span><br><span class="line">      &lt;alias name=&#x27;hostdev2&#x27;/&gt;</span><br><span class="line">      &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x0b&#x27; function=&#x27;0x0&#x27;/&gt;</span><br><span class="line">    &lt;/hostdev&gt;</span><br><span class="line">    &lt;hostdev mode=&#x27;subsystem&#x27; type=&#x27;pci&#x27; managed=&#x27;yes&#x27;&gt;</span><br><span class="line">      &lt;driver name=&#x27;vfio&#x27;/&gt;</span><br><span class="line">      &lt;source&gt;</span><br><span class="line">        &lt;address domain=&#x27;0x0000&#x27; bus=&#x27;0x65&#x27; slot=&#x27;0x00&#x27; function=&#x27;0x4&#x27;/&gt;</span><br><span class="line">      &lt;/source&gt;</span><br><span class="line">      &lt;alias name=&#x27;hostdev3&#x27;/&gt;</span><br><span class="line">      &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x0c&#x27; function=&#x27;0x0&#x27;/&gt;</span><br><span class="line">    &lt;/hostdev&gt;</span><br><span class="line">    &lt;hostdev mode=&#x27;subsystem&#x27; type=&#x27;pci&#x27; managed=&#x27;yes&#x27;&gt;</span><br><span class="line">      &lt;driver name=&#x27;vfio&#x27;/&gt;</span><br><span class="line">      &lt;source&gt;</span><br><span class="line">        &lt;address domain=&#x27;0x0000&#x27; bus=&#x27;0x67&#x27; slot=&#x27;0x00&#x27; function=&#x27;0x1&#x27;/&gt;</span><br><span class="line">      &lt;/source&gt;</span><br><span class="line">      &lt;alias name=&#x27;hostdev4&#x27;/&gt;</span><br><span class="line">      &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x0d&#x27; function=&#x27;0x0&#x27;/&gt;</span><br><span class="line">    &lt;/hostdev&gt;</span><br><span class="line">    &lt;hostdev mode=&#x27;subsystem&#x27; type=&#x27;pci&#x27; managed=&#x27;yes&#x27;&gt;</span><br><span class="line">      &lt;driver name=&#x27;vfio&#x27;/&gt;</span><br><span class="line">      &lt;source&gt;</span><br><span class="line">        &lt;address domain=&#x27;0x0000&#x27; bus=&#x27;0x67&#x27; slot=&#x27;0x00&#x27; function=&#x27;0x2&#x27;/&gt;</span><br><span class="line">      &lt;/source&gt;</span><br><span class="line">      &lt;alias name=&#x27;hostdev5&#x27;/&gt;</span><br><span class="line">      &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x0e&#x27; function=&#x27;0x0&#x27;/&gt;</span><br><span class="line">    &lt;/hostdev&gt;</span><br><span class="line">    &lt;hostdev mode=&#x27;subsystem&#x27; type=&#x27;pci&#x27; managed=&#x27;yes&#x27;&gt;</span><br><span class="line">      &lt;driver name=&#x27;vfio&#x27;/&gt;</span><br><span class="line">      &lt;source&gt;</span><br><span class="line">        &lt;address domain=&#x27;0x0000&#x27; bus=&#x27;0x67&#x27; slot=&#x27;0x00&#x27; function=&#x27;0x3&#x27;/&gt;</span><br><span class="line">      &lt;/source&gt;</span><br><span class="line">      &lt;alias name=&#x27;hostdev6&#x27;/&gt;</span><br><span class="line">      &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x0f&#x27; function=&#x27;0x0&#x27;/&gt;</span><br><span class="line">    &lt;/hostdev&gt;</span><br><span class="line">    &lt;hostdev mode=&#x27;subsystem&#x27; type=&#x27;pci&#x27; managed=&#x27;yes&#x27;&gt;</span><br><span class="line">      &lt;driver name=&#x27;vfio&#x27;/&gt;</span><br><span class="line">      &lt;source&gt;</span><br><span class="line">        &lt;address domain=&#x27;0x0000&#x27; bus=&#x27;0x67&#x27; slot=&#x27;0x00&#x27; function=&#x27;0x4&#x27;/&gt;</span><br><span class="line">      &lt;/source&gt;</span><br><span class="line">      &lt;alias name=&#x27;hostdev7&#x27;/&gt;</span><br><span class="line">      &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x10&#x27; function=&#x27;0x0&#x27;/&gt;</span><br><span class="line">    &lt;/hostdev&gt;</span><br><span class="line">    &lt;memballoon model=&#x27;virtio&#x27;&gt;</span><br><span class="line">      &lt;alias name=&#x27;balloon0&#x27;/&gt;</span><br><span class="line">      &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x03&#x27; function=&#x27;0x0&#x27;/&gt;</span><br><span class="line">    &lt;/memballoon&gt;</span><br><span class="line">  &lt;/devices&gt;</span><br><span class="line">  &lt;seclabel type=&#x27;dynamic&#x27; model=&#x27;selinux&#x27; relabel=&#x27;yes&#x27;&gt;</span><br><span class="line">    &lt;label&gt;system_u:system_r:svirt_t:s0:c21,c767&lt;/label&gt;</span><br><span class="line">    &lt;imagelabel&gt;system_u:object_r:svirt_image_t:s0:c21,c767&lt;/imagelabel&gt;</span><br><span class="line">  &lt;/seclabel&gt;</span><br><span class="line">  &lt;seclabel type=&#x27;dynamic&#x27; model=&#x27;dac&#x27; relabel=&#x27;yes&#x27;&gt;</span><br><span class="line">    &lt;label&gt;+0:+0&lt;/label&gt;</span><br><span class="line">    &lt;imagelabel&gt;+0:+0&lt;/imagelabel&gt;</span><br><span class="line">  &lt;/seclabel&gt;</span><br><span class="line">&lt;/domain&gt;</span><br><span class="line"> </span><br><span class="line">[root@node-69-26 ~]# virsh dumpxml vm &gt; xml</span><br><span class="line">[root@node-69-26 ~]#</span><br><span class="line">[root@node-69-26 ~]# cat xml</span><br><span class="line">&lt;domain type=&#x27;kvm&#x27; id=&#x27;1&#x27;&gt;</span><br><span class="line">  &lt;name&gt;vm&lt;/name&gt;</span><br><span class="line">  &lt;uuid&gt;8c6ebff0-eb21-11eb-a2af-0c48c6c88118&lt;/uuid&gt;</span><br><span class="line">  &lt;memory unit=&#x27;KiB&#x27;&gt;2097152&lt;/memory&gt;</span><br><span class="line">  &lt;currentMemory unit=&#x27;KiB&#x27;&gt;2097152&lt;/currentMemory&gt;</span><br><span class="line">  &lt;vcpu placement=&#x27;static&#x27;&gt;2&lt;/vcpu&gt;</span><br><span class="line">  &lt;resource&gt;</span><br><span class="line">    &lt;partition&gt;/machine&lt;/partition&gt;</span><br><span class="line">  &lt;/resource&gt;</span><br><span class="line">  &lt;os&gt;</span><br><span class="line">    &lt;type arch=&#x27;x86_64&#x27; machine=&#x27;pc-i440fx-2.1&#x27;&gt;hvm&lt;/type&gt;</span><br><span class="line">  &lt;/os&gt;</span><br><span class="line">  &lt;features&gt;</span><br><span class="line">    &lt;acpi/&gt;</span><br><span class="line">  &lt;/features&gt;</span><br><span class="line">  &lt;cpu mode=&#x27;custom&#x27; match=&#x27;exact&#x27; check=&#x27;full&#x27;&gt;</span><br><span class="line">    &lt;model fallback=&#x27;forbid&#x27;&gt;kvm64&lt;/model&gt;</span><br><span class="line">    &lt;feature policy=&#x27;require&#x27; name=&#x27;x2apic&#x27;/&gt;</span><br><span class="line">    &lt;feature policy=&#x27;require&#x27; name=&#x27;hypervisor&#x27;/&gt;</span><br><span class="line">  &lt;/cpu&gt;</span><br><span class="line">  &lt;clock offset=&#x27;utc&#x27;/&gt;</span><br><span class="line">  &lt;on_poweroff&gt;destroy&lt;/on_poweroff&gt;</span><br><span class="line">  &lt;on_reboot&gt;restart&lt;/on_reboot&gt;</span><br><span class="line">  &lt;on_crash&gt;destroy&lt;/on_crash&gt;</span><br><span class="line">  &lt;devices&gt;</span><br><span class="line">    &lt;emulator&gt;/root/pc-bios/qemu-system-x86_64&lt;/emulator&gt;</span><br><span class="line">    &lt;controller type=&#x27;pci&#x27; index=&#x27;0&#x27; model=&#x27;pci-root&#x27;&gt;</span><br><span class="line">      &lt;alias name=&#x27;pci.0&#x27;/&gt;</span><br><span class="line">    &lt;/controller&gt;</span><br><span class="line">    &lt;controller type=&#x27;usb&#x27; index=&#x27;0&#x27; model=&#x27;piix3-uhci&#x27;&gt;</span><br><span class="line">      &lt;alias name=&#x27;usb&#x27;/&gt;</span><br><span class="line">      &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x01&#x27; function=&#x27;0x2&#x27;/&gt;</span><br><span class="line">    &lt;/controller&gt;</span><br><span class="line">    &lt;input type=&#x27;mouse&#x27; bus=&#x27;ps2&#x27;&gt;</span><br><span class="line">      &lt;alias name=&#x27;input0&#x27;/&gt;</span><br><span class="line">    &lt;/input&gt;</span><br><span class="line">    &lt;input type=&#x27;keyboard&#x27; bus=&#x27;ps2&#x27;&gt;</span><br><span class="line">      &lt;alias name=&#x27;input1&#x27;/&gt;</span><br><span class="line">    &lt;/input&gt;</span><br><span class="line">    &lt;graphics type=&#x27;vnc&#x27; port=&#x27;5900&#x27; autoport=&#x27;yes&#x27; listen=&#x27;0.0.0.0&#x27;&gt;</span><br><span class="line">      &lt;listen type=&#x27;address&#x27; address=&#x27;0.0.0.0&#x27;/&gt;</span><br><span class="line">    &lt;/graphics&gt;</span><br><span class="line">    &lt;audio id=&#x27;1&#x27; type=&#x27;none&#x27;/&gt;</span><br><span class="line">    &lt;video&gt;</span><br><span class="line">      &lt;model type=&#x27;cirrus&#x27; vram=&#x27;16384&#x27; heads=&#x27;1&#x27; primary=&#x27;yes&#x27;/&gt;</span><br><span class="line">      &lt;alias name=&#x27;video0&#x27;/&gt;</span><br><span class="line">      &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x02&#x27; function=&#x27;0x0&#x27;/&gt;</span><br><span class="line">    &lt;/video&gt;</span><br><span class="line">    &lt;hostdev mode=&#x27;subsystem&#x27; type=&#x27;pci&#x27; managed=&#x27;yes&#x27;&gt;</span><br><span class="line">      &lt;driver name=&#x27;vfio&#x27;/&gt;</span><br><span class="line">      &lt;source&gt;</span><br><span class="line">        &lt;address domain=&#x27;0x0000&#x27; bus=&#x27;0x65&#x27; slot=&#x27;0x00&#x27; function=&#x27;0x1&#x27;/&gt;</span><br><span class="line">      &lt;/source&gt;</span><br><span class="line">      &lt;boot order=&#x27;1&#x27;/&gt;</span><br><span class="line">      &lt;alias name=&#x27;hostdev0&#x27;/&gt;</span><br><span class="line">      &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x09&#x27; function=&#x27;0x0&#x27;/&gt;</span><br><span class="line">    &lt;/hostdev&gt;</span><br><span class="line">    &lt;hostdev mode=&#x27;subsystem&#x27; type=&#x27;pci&#x27; managed=&#x27;yes&#x27;&gt;</span><br><span class="line">      &lt;driver name=&#x27;vfio&#x27;/&gt;</span><br><span class="line">      &lt;source&gt;</span><br><span class="line">        &lt;address domain=&#x27;0x0000&#x27; bus=&#x27;0x65&#x27; slot=&#x27;0x00&#x27; function=&#x27;0x2&#x27;/&gt;</span><br><span class="line">      &lt;/source&gt;</span><br><span class="line">      &lt;alias name=&#x27;hostdev1&#x27;/&gt;</span><br><span class="line">      &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x0a&#x27; function=&#x27;0x0&#x27;/&gt;</span><br><span class="line">    &lt;/hostdev&gt;</span><br><span class="line">    &lt;hostdev mode=&#x27;subsystem&#x27; type=&#x27;pci&#x27; managed=&#x27;yes&#x27;&gt;</span><br><span class="line">      &lt;driver name=&#x27;vfio&#x27;/&gt;</span><br><span class="line">      &lt;source&gt;</span><br><span class="line">        &lt;address domain=&#x27;0x0000&#x27; bus=&#x27;0x65&#x27; slot=&#x27;0x00&#x27; function=&#x27;0x3&#x27;/&gt;</span><br><span class="line">      &lt;/source&gt;</span><br><span class="line">      &lt;alias name=&#x27;hostdev2&#x27;/&gt;</span><br><span class="line">      &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x0b&#x27; function=&#x27;0x0&#x27;/&gt;</span><br><span class="line">    &lt;/hostdev&gt;</span><br><span class="line">    &lt;hostdev mode=&#x27;subsystem&#x27; type=&#x27;pci&#x27; managed=&#x27;yes&#x27;&gt;</span><br><span class="line">      &lt;driver name=&#x27;vfio&#x27;/&gt;</span><br><span class="line">      &lt;source&gt;</span><br><span class="line">        &lt;address domain=&#x27;0x0000&#x27; bus=&#x27;0x65&#x27; slot=&#x27;0x00&#x27; function=&#x27;0x4&#x27;/&gt;</span><br><span class="line">      &lt;/source&gt;</span><br><span class="line">      &lt;alias name=&#x27;hostdev3&#x27;/&gt;</span><br><span class="line">      &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x0c&#x27; function=&#x27;0x0&#x27;/&gt;</span><br><span class="line">    &lt;/hostdev&gt;</span><br><span class="line">    &lt;hostdev mode=&#x27;subsystem&#x27; type=&#x27;pci&#x27; managed=&#x27;yes&#x27;&gt;</span><br><span class="line">      &lt;driver name=&#x27;vfio&#x27;/&gt;</span><br><span class="line">      &lt;source&gt;</span><br><span class="line">        &lt;address domain=&#x27;0x0000&#x27; bus=&#x27;0x67&#x27; slot=&#x27;0x00&#x27; function=&#x27;0x1&#x27;/&gt;</span><br><span class="line">      &lt;/source&gt;</span><br><span class="line">      &lt;alias name=&#x27;hostdev4&#x27;/&gt;</span><br><span class="line">      &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x0d&#x27; function=&#x27;0x0&#x27;/&gt;</span><br><span class="line">    &lt;/hostdev&gt;</span><br><span class="line">    &lt;hostdev mode=&#x27;subsystem&#x27; type=&#x27;pci&#x27; managed=&#x27;yes&#x27;&gt;</span><br><span class="line">      &lt;driver name=&#x27;vfio&#x27;/&gt;</span><br><span class="line">      &lt;source&gt;</span><br><span class="line">        &lt;address domain=&#x27;0x0000&#x27; bus=&#x27;0x67&#x27; slot=&#x27;0x00&#x27; function=&#x27;0x2&#x27;/&gt;</span><br><span class="line">      &lt;/source&gt;</span><br><span class="line">      &lt;alias name=&#x27;hostdev5&#x27;/&gt;</span><br><span class="line">      &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x0e&#x27; function=&#x27;0x0&#x27;/&gt;</span><br><span class="line">    &lt;/hostdev&gt;</span><br><span class="line">    &lt;hostdev mode=&#x27;subsystem&#x27; type=&#x27;pci&#x27; managed=&#x27;yes&#x27;&gt;</span><br><span class="line">      &lt;driver name=&#x27;vfio&#x27;/&gt;</span><br><span class="line">      &lt;source&gt;</span><br><span class="line">        &lt;address domain=&#x27;0x0000&#x27; bus=&#x27;0x67&#x27; slot=&#x27;0x00&#x27; function=&#x27;0x3&#x27;/&gt;</span><br><span class="line">      &lt;/source&gt;</span><br><span class="line">      &lt;alias name=&#x27;hostdev6&#x27;/&gt;</span><br><span class="line">      &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x0f&#x27; function=&#x27;0x0&#x27;/&gt;</span><br><span class="line">    &lt;/hostdev&gt;</span><br><span class="line">    &lt;hostdev mode=&#x27;subsystem&#x27; type=&#x27;pci&#x27; managed=&#x27;yes&#x27;&gt;</span><br><span class="line">      &lt;driver name=&#x27;vfio&#x27;/&gt;</span><br><span class="line">      &lt;source&gt;</span><br><span class="line">        &lt;address domain=&#x27;0x0000&#x27; bus=&#x27;0x67&#x27; slot=&#x27;0x00&#x27; function=&#x27;0x4&#x27;/&gt;</span><br><span class="line">      &lt;/source&gt;</span><br><span class="line">      &lt;alias name=&#x27;hostdev7&#x27;/&gt;</span><br><span class="line">      &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x10&#x27; function=&#x27;0x0&#x27;/&gt;</span><br><span class="line">    &lt;/hostdev&gt;</span><br><span class="line">    &lt;memballoon model=&#x27;virtio&#x27;&gt;</span><br><span class="line">      &lt;alias name=&#x27;balloon0&#x27;/&gt;</span><br><span class="line">      &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x03&#x27; function=&#x27;0x0&#x27;/&gt;</span><br><span class="line">    &lt;/memballoon&gt;</span><br><span class="line">  &lt;/devices&gt;</span><br><span class="line">  &lt;seclabel type=&#x27;dynamic&#x27; model=&#x27;selinux&#x27; relabel=&#x27;yes&#x27;&gt;</span><br><span class="line">    &lt;label&gt;system_u:system_r:svirt_t:s0:c21,c767&lt;/label&gt;</span><br><span class="line">    &lt;imagelabel&gt;system_u:object_r:svirt_image_t:s0:c21,c767&lt;/imagelabel&gt;</span><br><span class="line">  &lt;/seclabel&gt;</span><br><span class="line">  &lt;seclabel type=&#x27;dynamic&#x27; model=&#x27;dac&#x27; relabel=&#x27;yes&#x27;&gt;</span><br><span class="line">    &lt;label&gt;+0:+0&lt;/label&gt;</span><br><span class="line">    &lt;imagelabel&gt;+0:+0&lt;/imagelabel&gt;</span><br><span class="line">  &lt;/seclabel&gt;</span><br><span class="line">&lt;/domain&gt;</span><br></pre></td></tr></table></figure>

<h4 id="qemu参数"><a href="#qemu参数" class="headerlink" title="qemu参数"></a>qemu参数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ulimit -l unlimited</span><br><span class="line">/root/pc-bios/qemu-system-x86_64 -name guest=vm,debug-threads=on -S -object secret,id=masterKey0,format=raw,file=/var/lib/libvirt/qemu/domain-1-vm/master-key.aes -machine pc-i440fx-2.1,usb=off,dump-guest-core=off -accel kvm -cpu kvm64 -m 2048 -overcommit mem-lock=off -smp 2,sockets=2,cores=1,threads=1 -uuid 8c6ebff0-eb21-11eb-a2af-0c48c6c88118 -no-user-config -nodefaults -chardev socket,id=charmonitor,fd=38,server=on,wait=off -mon chardev=charmonitor,id=monitor,mode=control -rtc base=utc -no-shutdown -boot strict=on -device piix3-usb-uhci,id=usb,bus=pci.0,addr=0x1.0x2 -audiodev &#123;&quot;id&quot;:&quot;audio1&quot;,&quot;driver&quot;:&quot;none&quot;&#125; -vnc 0.0.0.0:0,audiodev=audio1 -device cirrus-vga,id=video0,bus=pci.0,addr=0x2 -device vfio-pci,host=0000:65:00.1,id=hostdev0,bootindex=1,bus=pci.0,addr=0x9 -device vfio-pci,host=0000:65:00.2,id=hostdev1,bus=pci.0,addr=0xa -device vfio-pci,host=0000:65:00.3,id=hostdev2,bus=pci.0,addr=0xb -device vfio-pci,host=0000:65:00.4,id=hostdev3,bus=pci.0,addr=0xc -device vfio-pci,host=0000:67:00.1,id=hostdev4,bus=pci.0,addr=0xd -device vfio-pci,host=0000:67:00.2,id=hostdev5,bus=pci.0,addr=0xe -device vfio-pci,host=0000:67:00.3,id=hostdev6,bus=pci.0,addr=0xf -device vfio-pci,host=0000:67:00.4,id=hostdev7,bus=pci.0,addr=0x10 -device virtio-balloon-pci,id=balloon0,bus=pci.0,addr=0x3 -msg timestamp=on</span><br></pre></td></tr></table></figure>

<h3 id="vdpa-设备"><a href="#vdpa-设备" class="headerlink" title="vdpa 设备"></a>vdpa 设备</h3><h4 id="xml-1"><a href="#xml-1" class="headerlink" title="xml"></a>xml</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;domain type=&quot;kvm&quot; xmlns:qemu=&#x27;http://libvirt.org/schemas/domain/qemu/1.0&#x27;&gt;</span><br><span class="line">    &lt;name&gt;vm0&lt;/name&gt;</span><br><span class="line">    &lt;uuid&gt;d37f5411-b296-11ed-8e6c-0c48c6c879e4&lt;/uuid&gt;</span><br><span class="line">    &lt;memory unit=&quot;KiB&quot;&gt;2097152&lt;/memory&gt;</span><br><span class="line">    &lt;vcpu placement=&quot;static&quot;&gt;2&lt;/vcpu&gt;</span><br><span class="line">    &lt;os&gt;</span><br><span class="line">        &lt;type arch=&quot;x86_64&quot; machine=&quot;pc-i440fx-2.1&quot;&gt;hvm&lt;/type&gt;</span><br><span class="line">    &lt;/os&gt;</span><br><span class="line">    &lt;features&gt;</span><br><span class="line">        &lt;acpi&gt;&lt;/acpi&gt;</span><br><span class="line">    &lt;/features&gt;</span><br><span class="line">    &lt;clock offset=&quot;utc&quot;&gt;&lt;/clock&gt;</span><br><span class="line">    &lt;on_poweroff&gt;destroy&lt;/on_poweroff&gt;</span><br><span class="line">    &lt;on_reboot&gt;restart&lt;/on_reboot&gt;</span><br><span class="line">    &lt;on_crash&gt;destroy&lt;/on_crash&gt;</span><br><span class="line">    &lt;devices&gt;</span><br><span class="line">        &lt;emulator&gt;/home/corsica-sim/qemu-system-x86_64-vdpa&lt;/emulator&gt;</span><br><span class="line">        &lt;disk device=&quot;disk&quot; type=&quot;file&quot;&gt;</span><br><span class="line">            &lt;target bus=&quot;ide&quot; dev=&quot;hda&quot;/&gt;</span><br><span class="line">            &lt;source file=&quot;/home/centos8.4-vm0.qcow2&quot;/&gt;</span><br><span class="line">            &lt;driver type=&quot;qcow2&quot; name=&quot;qemu&quot;/&gt;</span><br><span class="line">        &lt;/disk&gt;</span><br><span class="line">        &lt;interface type=&#x27;vdpa&#x27;&gt;</span><br><span class="line">                        &lt;source dev=&#x27;/dev/vhost-vdpa-3&#x27;/&gt;</span><br><span class="line">                        &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x07&#x27; function=&#x27;0x0&#x27;/&gt;</span><br><span class="line">                &lt;/interface&gt;</span><br><span class="line">        &lt;memballoon model=&#x27;virtio&#x27;&gt;</span><br><span class="line">            &lt;alias name=&#x27;balloon0&#x27;/&gt;</span><br><span class="line">            &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x08&#x27; function=&#x27;0x0&#x27;/&gt;</span><br><span class="line">        &lt;/memballoon&gt;</span><br><span class="line">        &lt;serial type=&quot;tcp&quot;&gt;</span><br><span class="line">            &lt;source mode=&quot;bind&quot; host=&quot;127.0.0.1&quot; service=&quot;4319&quot;/&gt;</span><br><span class="line">            &lt;protocol type=&quot;telnet&quot;/&gt;</span><br><span class="line">            &lt;target port=&quot;1&quot;/&gt;</span><br><span class="line">        &lt;/serial&gt;</span><br><span class="line">    &lt;/devices&gt;</span><br><span class="line">    &lt;qemu:commandline&gt;</span><br><span class="line">        &lt;qemu:arg value=&#x27;-cpu&#x27;/&gt;</span><br><span class="line">        &lt;qemu:arg value=&#x27;host&#x27;/&gt;</span><br><span class="line">        &lt;qemu:arg value=&#x27;-net&#x27;/&gt;</span><br><span class="line">        &lt;qemu:arg value=&#x27;nic&#x27;/&gt;</span><br><span class="line">        &lt;qemu:arg value=&#x27;-net&#x27;/&gt;</span><br><span class="line">        &lt;qemu:arg value=&#x27;user,hostfwd=tcp::5022-:22&#x27;/&gt;</span><br><span class="line">    &lt;/qemu:commandline&gt;</span><br><span class="line">&lt;/domain&gt;</span><br></pre></td></tr></table></figure>

<h4 id="qemu参数-1"><a href="#qemu参数-1" class="headerlink" title="qemu参数"></a>qemu参数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#legacy设备</span><br><span class="line">ulimit -l unlimited</span><br><span class="line">/root/qemu/qemu-system-x86_64 \</span><br><span class="line">-drive file=/nfs/centos8.4-8g-ext4-nodebug.img,if=none,id=sys -device virtio-blk-pci,drive=sys,bootindex=1 \</span><br><span class="line">-netdev type=vhost-vdpa,vhostdev=/dev/vhost-vdpa-2,id=vhost-vdpa0,queues=4 \</span><br><span class="line">-device virtio-net-pci,netdev=vhost-vdpa0,mq=on,vectors=9,tx_queue_size=512,rx_queue_size=512,page-per-vq=on,addr=0x9 \</span><br><span class="line">-netdev type=vhost-vdpa,vhostdev=/dev/vhost-vdpa-3,id=vhost-vdpa1,queues=4 \</span><br><span class="line">-device virtio-net-pci,netdev=vhost-vdpa1,mq=on,vectors=9,tx_queue_size=512,rx_queue_size=512,page-per-vq=on,addr=0xa \</span><br><span class="line">-enable-kvm -smp 4 -m 1G -cpu host -vnc :50 -monitor stdio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#modern设备</span><br><span class="line">ulimit -l unlimited</span><br><span class="line">/root/qemu/qemu-system-x86_64 \</span><br><span class="line">-drive file=/mnt/centos8.4-8g-ext4-nodebug.img,if=none,id=sys -device virtio-blk-pci,drive=sys,bootindex=1 \</span><br><span class="line">-netdev type=vhost-vdpa,vhostdev=/dev/vhost-vdpa-0,id=vhost-vdpa0,queues=4 \</span><br><span class="line">-device virtio-net-pci,netdev=vhost-vdpa0,mq=on,vectors=9,disable-modern=off,disable-legacy=on,tx_queue_size=512,rx_queue_size=512,page-per-vq=on,addr=0x9 \</span><br><span class="line">-netdev type=vhost-vdpa,vhostdev=/dev/vhost-vdpa-1,id=vhost-vdpa1,queues=4 \</span><br><span class="line">-device virtio-net-pci,netdev=vhost-vdpa1,mq=on,vectors=9,disable-modern=off,disable-legacy=on,tx_queue_size=512,rx_queue_size=512,page-per-vq=on,addr=0xa \</span><br><span class="line">-device vhost-vdpa-blk-pci,vdpa-dev=/dev/vhost-vdpa-3,vectors=2,disable-modern=off,disable-legacy=on,num-queues=2,queue-size=128,page-per-vq=on,addr=0xb \</span><br><span class="line">-enable-kvm -smp 4 -m 1G -cpu host -vnc :50 -monitor stdio -trace events=event -D dst-vdpa.log</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="vhost-user-设备"><a href="#vhost-user-设备" class="headerlink" title="vhost-user 设备"></a>vhost-user 设备</h3><h4 id="xml-2"><a href="#xml-2" class="headerlink" title="xml"></a>xml</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;domain type=&quot;kvm&quot; xmlns:qemu=&#x27;http://libvirt.org/schemas/domain/qemu/1.0&#x27;&gt;</span><br><span class="line">    &lt;name&gt;vm0&lt;/name&gt;</span><br><span class="line">    &lt;uuid&gt;d37f5411-b296-11ed-8e6c-0c48c6c879e4&lt;/uuid&gt;</span><br><span class="line">    &lt;memory unit=&quot;KiB&quot;&gt;2097152&lt;/memory&gt;</span><br><span class="line">    &lt;memoryBacking&gt;</span><br><span class="line">        &lt;hugepages&gt;</span><br><span class="line">            &lt;page size=&quot;2&quot; unit=&quot;M&quot;/&gt;</span><br><span class="line">        &lt;/hugepages&gt;</span><br><span class="line">        &lt;nosharepages/&gt;</span><br><span class="line">        &lt;locked/&gt;</span><br><span class="line">        &lt;source type=&quot;file&quot;/&gt;</span><br><span class="line">        &lt;access mode=&quot;shared&quot;/&gt;</span><br><span class="line">        &lt;discard/&gt;</span><br><span class="line">    &lt;/memoryBacking&gt;</span><br><span class="line">    &lt;vcpu placement=&quot;static&quot;&gt;2&lt;/vcpu&gt;</span><br><span class="line">    &lt;os&gt;</span><br><span class="line">        &lt;type arch=&quot;x86_64&quot; machine=&quot;pc-i440fx-2.1&quot;&gt;hvm&lt;/type&gt;</span><br><span class="line">    &lt;/os&gt;</span><br><span class="line">    &lt;cpu mode=&#x27;custom&#x27; match=&#x27;exact&#x27; check=&#x27;full&#x27;&gt;</span><br><span class="line">        &lt;model fallback=&#x27;forbid&#x27;&gt;kvm64&lt;/model&gt;</span><br><span class="line">        &lt;feature policy=&#x27;require&#x27; name=&#x27;x2apic&#x27;/&gt;</span><br><span class="line">        &lt;feature policy=&#x27;require&#x27; name=&#x27;hypervisor&#x27;/&gt;</span><br><span class="line">    &lt;/cpu&gt;</span><br><span class="line">    &lt;features&gt;</span><br><span class="line">        &lt;acpi&gt;&lt;/acpi&gt;</span><br><span class="line">    &lt;/features&gt;</span><br><span class="line">    &lt;clock offset=&quot;utc&quot;&gt;&lt;/clock&gt;</span><br><span class="line">    &lt;on_poweroff&gt;destroy&lt;/on_poweroff&gt;</span><br><span class="line">    &lt;on_reboot&gt;restart&lt;/on_reboot&gt;</span><br><span class="line">    &lt;on_crash&gt;destroy&lt;/on_crash&gt;</span><br><span class="line">    &lt;devices&gt;</span><br><span class="line">        &lt;emulator&gt;/root/pc-bios/qemu-system-x86_64&lt;/emulator&gt;</span><br><span class="line">        &lt;disk device=&quot;disk&quot; type=&quot;file&quot;&gt;</span><br><span class="line">            &lt;target bus=&quot;ide&quot; dev=&quot;hda&quot;/&gt;</span><br><span class="line">            &lt;source file=&quot;/mnt/store/vm0-centos8.4-8g-ext4-host-dmar.img&quot;/&gt;</span><br><span class="line">        &lt;/disk&gt;</span><br><span class="line">        &lt;interface type=&#x27;vhostuser&#x27;&gt;</span><br><span class="line">            &lt;mac address=&#x27;00:aa:bb:cc:dd:ee&#x27;/&gt;</span><br><span class="line">            &lt;source type=&#x27;unix&#x27; path=&#x27;/tmp/vdpa-socket0&#x27; mode=&#x27;client&#x27;/&gt;</span><br><span class="line">            &lt;model type=&#x27;virtio&#x27;/&gt;</span><br><span class="line">            &lt;driver queues=&#x27;4&#x27; rx_queue_size=&#x27;512&#x27; tx_queue_size=&#x27;512&#x27;/&gt;</span><br><span class="line">        &lt;/interface&gt;</span><br><span class="line">        &lt;serial type=&quot;tcp&quot;&gt;</span><br><span class="line">            &lt;source mode=&quot;bind&quot; host=&quot;127.0.0.1&quot; service=&quot;4321&quot;/&gt;</span><br><span class="line">            &lt;protocol type=&quot;telnet&quot;/&gt;</span><br><span class="line">            &lt;target port=&quot;1&quot;/&gt;</span><br><span class="line">        &lt;/serial&gt;</span><br><span class="line">        &lt;graphics type=&#x27;vnc&#x27; port=&#x27;5901&#x27; listen=&#x27;0.0.0.0&#x27;&gt;</span><br><span class="line">            &lt;listen type=&#x27;address&#x27; address=&#x27;0.0.0.0&#x27;/&gt;</span><br><span class="line">        &lt;/graphics&gt;</span><br><span class="line">  </span><br><span class="line">    &lt;/devices&gt;</span><br><span class="line">    &lt;qemu:commandline&gt;</span><br><span class="line">        &lt;qemu:arg value=&#x27;-L&#x27;/&gt;</span><br><span class="line">        &lt;qemu:arg value=&#x27;/root/pc-bios&#x27;/&gt;</span><br><span class="line">    &lt;/qemu:commandline&gt;</span><br><span class="line">&lt;/domain&gt;</span><br></pre></td></tr></table></figure>

<h4 id="qemu参数-2"><a href="#qemu参数-2" class="headerlink" title="qemu参数"></a>qemu参数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ulimit -l unlimited</span><br><span class="line">/root/qemu-system-x86_64 \</span><br><span class="line">-m 2048 -enable-kvm \</span><br><span class="line">-drive if=virtio,file=/data/vm0-centos8.4-8g-ext4-host-dmar.img,cache=none  \</span><br><span class="line">-object memory-backend-file,id=mem,size=2048M,mem-path=/dev/hugepages,share=on \</span><br><span class="line">-mem-prealloc \</span><br><span class="line">-numa node,memdev=mem \</span><br><span class="line">-chardev socket,id=char0,path=/tmp/vdpa-socket0,server=on \</span><br><span class="line">-netdev type=vhost-user,id=vdpa,chardev=char0,queues=1 \</span><br><span class="line">-device virtio-net-pci,rx_queue_size=512,tx_queue_size=512,netdev=vdpa,page-per-vq=on,addr=0xa \</span><br><span class="line">-monitor stdio \</span><br><span class="line">-vnc :0 -L /root/pc-bios</span><br></pre></td></tr></table></figure>

<h3 id="nvme设备"><a href="#nvme设备" class="headerlink" title="nvme设备"></a>nvme设备</h3><h4 id="qemu参数-3"><a href="#qemu参数-3" class="headerlink" title="qemu参数"></a>qemu参数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/root/qemu-system-x86_64 -enable-kvm -machine q35 -cpu host -smp 4 -m 4096 \</span><br><span class="line">                -hda $&#123;BASE_PATH&#125;/centos8.4-ext4-host-large.qcow2 -daemonize \</span><br><span class="line">    -device ioh3420,id=root_port1,chassis=0,slot=0 \</span><br><span class="line">    -device x3130-upstream,id=pci.0,bus=root_port1 \</span><br><span class="line">    -device xio3130-downstream,id=pci.2,bus=pci.0,chassis=1,slot=0 \</span><br><span class="line">    -device xio3130-downstream,id=pci.3,bus=pci.0,chassis=1,slot=1 \</span><br><span class="line">    -device xio3130-downstream,id=pci.4,bus=pci.0,chassis=1,slot=2 \</span><br><span class="line">    -device xio3130-downstream,id=pci.5,bus=pci.0,chassis=1,slot=3 \</span><br><span class="line">    -device xio3130-downstream,id=pci.6,bus=pci.0,chassis=1,slot=4 \</span><br><span class="line">    -device xio3130-downstream,id=pci.7,bus=pci.0,chassis=1,slot=5 \</span><br><span class="line">    -device xio3130-downstream,id=pci.8,bus=pci.0,chassis=1,slot=6 \</span><br><span class="line">    -device xio3130-downstream,id=pci.9,bus=pci.0,chassis=1,slot=7 \</span><br><span class="line">    -device xio3130-downstream,id=pci.10,bus=pci.0,chassis=1,slot=8 \</span><br><span class="line">    -device xio3130-downstream,id=pci.11,bus=pci.0,chassis=1,slot=9 \</span><br><span class="line">    -device xio3130-downstream,id=pci.12,bus=pci.0,chassis=1,slot=10 \</span><br><span class="line">    -device xio3130-downstream,id=pci.13,bus=pci.0,chassis=1,slot=11 \</span><br><span class="line">    -device xio3130-downstream,id=pci.14,bus=pci.0,chassis=1,slot=12 \</span><br><span class="line">    -device xio3130-downstream,id=pci.15,bus=pci.0,chassis=1,slot=13 \</span><br><span class="line">    -device xio3130-downstream,id=pci.16,bus=pci.0,chassis=1,slot=14 \</span><br><span class="line">    -device xio3130-downstream,id=pci.17,bus=pci.0,chassis=1,slot=15 \</span><br><span class="line">    -device xio3130-downstream,id=pci.18,bus=pci.0,chassis=1,slot=16 \</span><br><span class="line">    -device xio3130-downstream,id=pci.19,bus=pci.0,chassis=1,slot=17 \</span><br><span class="line">    -device xio3130-downstream,id=pci.20,bus=pci.0,chassis=1,slot=18 \</span><br><span class="line">    -device xio3130-downstream,id=pci.21,bus=pci.0,chassis=1,slot=19 \</span><br><span class="line">    -device xio3130-downstream,id=pci.22,bus=pci.0,chassis=1,slot=20 \</span><br><span class="line">    -device xio3130-downstream,id=pci.23,bus=pci.0,chassis=1,slot=21 \</span><br><span class="line">    -device xio3130-downstream,id=pci.24,bus=pci.0,chassis=1,slot=22 \</span><br><span class="line">    -device xio3130-downstream,id=pci.25,bus=pci.0,chassis=1,slot=23 \</span><br><span class="line">    -device xio3130-downstream,id=pci.26,bus=pci.0,chassis=1,slot=24 \</span><br><span class="line">    -device x3130-upstream,id=pci.27,bus=pci.18 \</span><br><span class="line">    -device xio3130-downstream,id=pci.28,bus=pci.27,chassis=2,slot=0 \</span><br><span class="line">    -device xio3130-downstream,id=pci.29,bus=pci.27,chassis=2,slot=1 \</span><br><span class="line">    -device xio3130-downstream,id=pci.30,bus=pci.27,chassis=2,slot=2 \</span><br><span class="line">    -device xio3130-downstream,id=pci.31,bus=pci.27,chassis=2,slot=3 \</span><br><span class="line">    -device xio3130-downstream,id=pci.32,bus=pci.27,chassis=2,slot=4 \</span><br><span class="line">    -device xio3130-downstream,id=pci.33,bus=pci.27,chassis=2,slot=5 \</span><br><span class="line">    -device xio3130-downstream,id=pci.34,bus=pci.27,chassis=2,slot=6 \</span><br><span class="line">    -device xio3130-downstream,id=pci.35,bus=pci.27,chassis=2,slot=7 \</span><br><span class="line">    -device xio3130-downstream,id=pci.36,bus=pci.27,chassis=2,slot=8 \</span><br><span class="line">    -device xio3130-downstream,id=pci.37,bus=pci.27,chassis=2,slot=9 \</span><br><span class="line">    -device xio3130-downstream,id=pci.38,bus=pci.27,chassis=2,slot=10 \</span><br><span class="line">    -device xio3130-downstream,id=pci.39,bus=pci.27,chassis=2,slot=11 \</span><br><span class="line">    -device xio3130-downstream,id=pci.40,bus=pci.27,chassis=2,slot=12 \</span><br><span class="line">    -device xio3130-downstream,id=pci.41,bus=pci.27,chassis=2,slot=13 \</span><br><span class="line">    -device xio3130-downstream,id=pci.42,bus=pci.27,chassis=2,slot=14 \</span><br><span class="line">    -device xio3130-downstream,id=pci.43,bus=pci.27,chassis=2,slot=15 \</span><br><span class="line">    -device xio3130-downstream,id=pci.44,bus=pci.27,chassis=2,slot=16 \</span><br><span class="line">    -device xio3130-downstream,id=pci.45,bus=pci.27,chassis=2,slot=17 \</span><br><span class="line">    -device xio3130-downstream,id=pci.46,bus=pci.27,chassis=2,slot=18 \</span><br><span class="line">    -device xio3130-downstream,id=pci.47,bus=pci.27,chassis=2,slot=19 \</span><br><span class="line">    -device xio3130-downstream,id=pci.48,bus=pci.27,chassis=2,slot=20 \</span><br><span class="line">    -device xio3130-downstream,id=pci.49,bus=pci.27,chassis=2,slot=21 \</span><br><span class="line">    -device xio3130-downstream,id=pci.50,bus=pci.27,chassis=2,slot=22 \</span><br><span class="line">    -device xio3130-downstream,id=pci.51,bus=pci.27,chassis=2,slot=23 \</span><br><span class="line">    -device xio3130-downstream,id=pci.n0,bus=pci.27,chassis=2,slot=24 \</span><br><span class="line">    -device xio3130-downstream,id=pci.n1,bus=pci.27,chassis=2,slot=25 \</span><br><span class="line">    -device xio3130-downstream,id=pci.n2,bus=pci.27,chassis=2,slot=26 \</span><br><span class="line">    -device xio3130-downstream,id=pci.n3,bus=pci.27,chassis=2,slot=27 \</span><br><span class="line">    -device xio3130-downstream,id=pci.rmda,bus=pci.27,chassis=2,slot=28 \</span><br><span class="line">        -drive file=$&#123;BASE_PATH&#125;/nvme0.raw,format=raw,if=none,id=nvme0 \</span><br><span class="line">    -device nvme,bus=pci.n0,id=nvme.106,drive=nvme0,serial=deadbeaf0,max_ioqpairs=2 \</span><br><span class="line">        -drive file=$&#123;BASE_PATH&#125;/nvme1.raw,format=raw,if=none,id=nvme1 \</span><br><span class="line">    -device nvme,bus=pci.n1,id=nvme.107,drive=nvme1,serial=deadbeaf0,max_ioqpairs=2 \</span><br><span class="line">        -L $&#123;BASE_PATH&#125;/pc-bios \</span><br><span class="line">    -net nic -net user,hostfwd=tcp::5023-:22 \</span><br><span class="line">        -D $&#123;BASE_PATH&#125;/qemu-sim.log \</span><br><span class="line">    -d jmnd_once,jmnd_err,jmnd_sdma,jmnd_nvme,jmnd_warn \</span><br><span class="line">    -msg timestamp=on \</span><br><span class="line">        -trace events=$&#123;BASE_PATH&#125;/events \</span><br><span class="line">    -vnc :0 \</span><br><span class="line">        -monitor telnet:localhost:4321,server,nowait</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>virtqueue与spdq rings</title>
    <url>/2022/06/05/virtqueue/</url>
    <content><![CDATA[<h2 id="virtqueue设置原则"><a href="#virtqueue设置原则" class="headerlink" title="virtqueue设置原则"></a>virtqueue设置原则</h2><p>根据数据驱动的方向设置virtqueue数量，不同的数据驱动方向需要单独的virtqueue。比如：</p>
<span id="more"></span>

<p>vnet设备的rx方向，由后端设备收包驱动数据流向，数据由<strong>后端触发</strong>，发往前端（需要前端预先准备好空闲buffers提供给后端），需要独立的virtqueue；</p>
<p>vnet设备的tx方向，由前端发包请求驱动数据流向，数据由<strong>前端触发</strong>，发往后端（后端处理完后把空闲buffers还给前端），需要独立的virtqueue，不能和rx方向复用（否则如果和rx方向复用的话，available ring中会装满rx需要使用的host侧空闲buffers，待发送数据buffers就无法有效传递到设备侧）；</p>
<p>vblk设备的in和out操作，都是由前端发起请求驱动数据流向，数据由<strong>前端触发</strong>，发往后端（请求headers，和in请求的空闲buffers，以及out请求的待发送数据buffers），后端处理完之后还给前端（响应headers，和in请求的已读取数据buffers，以及out请求的空闲buffers），完成一个数据循环，所以只需要一个virtqueue，in和out可以复用。</p>
<h2 id="virtqueue概念"><a href="#virtqueue概念" class="headerlink" title="virtqueue概念"></a>virtqueue概念</h2><p>virtqueue是数据流向&amp;流程的逻辑抽象，主要包括数据传递的发起方向、空闲host buffers的分配或回收、数据host buffers的传递、任务通知等方面。</p>
<p>virtqueue的概念经过抽象，主要包含如下几个方面：</p>
<p>host buffers的传递通道（available ring &amp; used ring）</p>
<p><code>available ring</code>：net rx场景，host用来向设备发放空闲host buffers，<strong>必须提前发放</strong>，设备按需去取；net tx场景，host用来向设备发放数据host buffers，设备应该立刻取走发送。</p>
<p><code>used ring</code>：net rx场景，设备用来向host发送数据host buffers，即收到的数据包；net tx场景，设备用来向host归还空闲host buffers。</p>
<p>通知机制（kick &amp; irq）</p>
<p><code>kick</code>：net rx场景，host用来通知设备准备好了空闲buffers；net tx场景，host用来通知设备有待发送数据包。</p>
<p><code>irq</code>：net rx场景，设备用来通知host有新收到的数据包；net tx场景，设备用来通知host发送任务完成，归还空闲host buffers。</p>
<p>数据传递的发起方向（host发起 or device发起），用来决定需不需要设置单独的virtqueue</p>
<p>virtqueue不关心host buffers传递到设备后，设备具体如何处理。不同的设备拿到host buffers之后，有自己私有的实现方式。</p>
<h2 id="spd-rings概念"><a href="#spd-rings概念" class="headerlink" title="spd rings概念"></a>spd rings概念</h2><p>spd rings是fpga实现具体IO任务的方式。host通过virtqueue把空闲和数据buffers传递到fpga，但真正的数据接收或发送任务是在soc完成，涉及host buffers和soc buffers之间的数据传递及通知，fpga使用spd rings实现这些具体功能。</p>
<h3 id="对应关系"><a href="#对应关系" class="headerlink" title="对应关系"></a>对应关系</h3><p>每条virtqueue（包含available ring &amp; used ring）对应一套spd rings（包含rx ring、tx ring和free ring），对应关系如下图所示：<br><img src="98fa220eb878bf19efad8628b63c1ec125daddb56b2b19d3daf94cdbeff291da.png" alt="图 1">  </p>
<p>下面按具体场景分析virtqueue和spd rings如何配合工作</p>
<h3 id="net-rx"><a href="#net-rx" class="headerlink" title="net rx"></a>net rx</h3><p><img src="57c05468b7ebd2a827e448136ef1ec7153a45b8a99d67c96e63235bf14a23024.png" alt="图 2">  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">virtio_dev &gt;&gt; show queue info 577 0     </span><br><span class="line">Register Configuration:</span><br><span class="line">    hw_qid:517, q_type:net-rx, vre_active:enabled</span><br><span class="line">    msix:enabled, base_addr:0xfee00638, data:0x00000000</span><br><span class="line">    hash_node_fpga_qid:0, qid:0, sfi:577</span><br><span class="line">    qid2bdf:0xcc01, host_tx_queue_en:enabled</span><br><span class="line"></span><br><span class="line">Host Side VQ Info:</span><br><span class="line">    desc_base :0x36050000, indir_flag:1, size:512, <span class="built_in">type</span>:net-rx, default enabled</span><br><span class="line">    avail_base:0x36052000, indir_flag:1, size:512, <span class="built_in">type</span>:net-rx, default enabled</span><br><span class="line">    used_base :0x36053000, indir_flag:1, size:512, <span class="built_in">type</span>:net-rx, default enabled</span><br><span class="line">    avail_ring_tail:512, avail_ring_head:512</span><br><span class="line">    used_ring_tail:14, used_ring_idx_tail:14</span><br><span class="line"></span><br><span class="line">SoC Side Ring Info:</span><br><span class="line">    rx ring base:0x487b42000, size:16384, <span class="built_in">type</span>:net, enabled</span><br><span class="line">    rx ring_head:14, <span class="built_in">tail</span>:14, inflight_tail:0</span><br><span class="line"></span><br><span class="line">    tx ring base:0x487b02000, size:16384, <span class="built_in">type</span>:net-rx, default enabled</span><br><span class="line">    tx ring <span class="built_in">tail</span> (PA):0x487b82000, <span class="built_in">tail</span>:512, inflight_tail:512,eop_cnt:512</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>要点说明：</p>
<p>net rx场景，spd rings中的free ring不会使用，只用到tx ring和rx ring</p>
<p>host提前把host free buffers的idxes放入virtqueue的available ring，发送给fpga，供收到数据包时使用</p>
<p>fpga取出，获取每个host free buffers的paddr，构造tx messages（同时会记录idxes），放入tx ring发送给soc，供soc收到数据包时使用</p>
<p>soc的dpdk app从外部网络端口收到数据包后，从tx ring获取host free buffers，结合soc收包mbufs的paddr构造rx messages，放入rx ring</p>
<p>fpga从rx ring获取rx messages，执行数据搬移任务，将数据包从soc mbufs搬移到host free buffers，将当前数据包的host buffers的idxes（一直记录在spd ring tx&amp;rx messages中传递）放入virtqueue的used ring，通知host取包</p>
<p>数据搬移完成后，soc可以从rx ring的tail指针变化感知，此时可以释放soc的mbufs</p>
<p>host择机再次把host free buffers的idxes放入virtqueue的available ring，发送给fpga，供下次收到数据包时使用</p>
<h3 id="net-tx"><a href="#net-tx" class="headerlink" title="net tx"></a>net tx</h3><p><img src="92e687118d6ae932e0850f4abe8f19c73d6b79d2d2eab98abb4a28ddb97b56e9.png" alt="图 3">  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">virtio_dev &gt;&gt; show queue info 577 1     </span><br><span class="line">Register Configuration:</span><br><span class="line">    hw_qid:5, q_type:net-tx, vre_active:enabled</span><br><span class="line">    msix:enabled, base_addr:0xfee00658, data:0x00000000</span><br><span class="line">    hash_node_fpga_qid:0, qid:1, sfi:577</span><br><span class="line">    qid2bdf:0xcc01, host_tx_queue_en:enabled</span><br><span class="line"></span><br><span class="line">Host Side VQ Info:</span><br><span class="line">    desc_base :0x36098000, indir_flag:1, size:512, <span class="built_in">type</span>:net-tx, default enabled</span><br><span class="line">    avail_base:0x3609a000, indir_flag:1, size:512, <span class="built_in">type</span>:net-tx, default enabled</span><br><span class="line">    used_base :0x3609b000, indir_flag:1, size:512, <span class="built_in">type</span>:net-tx, default enabled</span><br><span class="line">    avail_ring_tail:0, avail_ring_head:0</span><br><span class="line">    used_ring_tail:0, used_ring_idx_tail:0</span><br><span class="line"></span><br><span class="line">SoC Side Ring Info:</span><br><span class="line">    free ring base:0x47a800000, size:16384, <span class="built_in">type</span>:net, enabled</span><br><span class="line">    free ring <span class="built_in">head</span>:0, <span class="built_in">tail</span>:256, inflight_head:0</span><br><span class="line"></span><br><span class="line">    tx ring base:0x47a820000, size:16384, <span class="built_in">type</span>:net-tx, default enabled</span><br><span class="line">    tx ring <span class="built_in">tail</span> (PA):0x47a860000, <span class="built_in">tail</span>:0, inflight_tail:0,eop_cnt:0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>要点说明：</p>
<p>net tx场景，spd rings中的rx ring不会使用，只用到tx ring和free ring</p>
<p>soc提前将空闲的soc mbufs放入free ring，供fpga收到发包任务时使用</p>
<p>host发起发包任务，填写待发送数据包的buffers，并把这些buffers的idxes放入virtqueue的available ring，发往fpga</p>
<p>fpga取出，并获取这些待发送数据包host buffers的paddr，再从free ring中取出soc free mbufs，直接执行数据搬移操作，将数据从host buffers搬移到soc mbufs中，搬移完成后将soc mbufs放入tx ring发往soc，并将host buffers的idxes放入virtqueue的uesd ring归还给host</p>
<p>soc从tx ring获取到待发送数据包的soc mbufs，执行发包操作，发送完成后将soc mbufs释放</p>
<p>soc择机将空闲的soc mbufs再次注入free ring，供fpga下次收到发包任务时继续使用</p>
<h3 id="blk-in-amp-out"><a href="#blk-in-amp-out" class="headerlink" title="blk in&amp;out"></a>blk in&amp;out</h3><p><img src="54fb5a0c9073a46445ce2b030f23555ef1b203fc3d02a007875f2f0cd63242c5.png" alt="图 4">  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">virtio_dev &gt;&gt; show queue info 66 0     </span><br><span class="line">Register Configuration:</span><br><span class="line">    hw_qid:1028, q_type:blk, vre_active:enabled</span><br><span class="line">    msix:enabled, base_addr:0xfee006b8, data:0x00000000</span><br><span class="line">    hash_node_fpga_qid:0, qid:0, sfi:66</span><br><span class="line">    qid2bdf:0xb302, host_tx_queue_en:enabled</span><br><span class="line"></span><br><span class="line">Host Side VQ Info:</span><br><span class="line">    desc_base :0x320f6000, indir_flag:1, size:128, <span class="built_in">type</span>:blk, default enabled</span><br><span class="line">    avail_base:0x320f6800, indir_flag:1, size:128, <span class="built_in">type</span>:blk, default enabled</span><br><span class="line">    used_base :0x320f7000, indir_flag:1, size:128, <span class="built_in">type</span>:blk, default enabled</span><br><span class="line">    avail_ring_tail:6, avail_ring_head:6</span><br><span class="line">    used_ring_tail:6, used_ring_idx_tail:6</span><br><span class="line"></span><br><span class="line">SoC Side Ring Info:</span><br><span class="line">    free ring base:0x49cca1000, size:16384, <span class="built_in">type</span>:blk, enabled</span><br><span class="line">    free ring <span class="built_in">head</span>:6, <span class="built_in">tail</span>:261, inflight_head:6</span><br><span class="line"></span><br><span class="line">    rx ring base:0x49cd01000, size:16384, <span class="built_in">type</span>:blk, enabled</span><br><span class="line">    rx ring_head:40, <span class="built_in">tail</span>:40, inflight_tail:0</span><br><span class="line"></span><br><span class="line">    tx ring base:0x49ccc1000, size:16384, <span class="built_in">type</span>:blk, default enabled</span><br><span class="line">    tx ring <span class="built_in">tail</span> (PA):0x49cd41000, <span class="built_in">tail</span>:42, inflight_tail:42,eop_cnt:6</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>要点说明：</p>
<p>blk in&amp;out场景，所有spd rings都会被用到（blk只给出数据的流向示意，不涉及soc vblk具体处理）</p>
<p>blk in&amp;out操作均有host发起，in请求将请求headers和空闲buffers发往设备，接收响应headers和数据buffers；out请求将请求headers和数据buffers发往设备，接收响应headers和空闲buffers；in&amp;out请求可以同时在同一个virtqueue发送</p>
<p>in操作（图中绿色箭头路线），参考net rx流程，主要差别是增加了对request headers和response headers的处理（未画出），tx ring复用了tx soc data buffers和rx host free buffers的发送，以及数据流向由host驱动</p>
<p>out操作（图中蓝色箭头路线），参考net tx流程，主要差别是增加了对request headers和response headers的处理（未画出），以及tx ring复用了tx soc data buffers和rx host free buffers的发送</p>
]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>virtio</tag>
      </tags>
  </entry>
  <entry>
    <title>qemu中的协程</title>
    <url>/2022/06/04/qemu%E4%B8%AD%E7%9A%84%E5%8D%8F%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>协程是一种用户态的轻量级线程，相对于系统独立，有自己的上下文，协程的切换也由自己控制，所以相对于进程和线程来说其运行的开销要小得多。</p>
<span id="more"></span>

<h2 id="qemu-coroutine-API"><a href="#qemu-coroutine-API" class="headerlink" title="qemu-coroutine API"></a>qemu-coroutine API</h2><p>源码：<br>qemu-coroutine.c<br>coroutine-ucontext.c<br>coroutine-ucontext.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建新的协程</span></span><br><span class="line"><span class="comment"> * 使用qemu_coroutine_enter() 进入协程执行环境.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Coroutine *<span class="title function_">qemu_coroutine_create</span><span class="params">(CoroutineEntry *entry)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 进入协程执行环境</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * opaque为传递给协程执行入口参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">qemu_coroutine_enter</span><span class="params">(Coroutine *coroutine, <span class="type">void</span> *opaque)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 转移执行控制权到协程的调用者处</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这个函数不会返回除非使用qemu_coroutine_enter()重新进入协程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> coroutine_fn <span class="title function_">qemu_coroutine_yield</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>qemu协程使用非常简单，创建并启动协程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Coroutine *co = qemu_coroutine_create(process_incoming_migration_co, <span class="literal">NULL</span>);</span><br><span class="line">qemu_coroutine_enter(co);</span><br></pre></td></tr></table></figure>
<p>coroutine协程则会执行直到退出或者yields</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">process_incoming_migration_co</span><span class="params">(<span class="type">void</span> *opaque)</span> &#123; </span><br><span class="line">      MyData *my_data = opaque; </span><br><span class="line"></span><br><span class="line">      <span class="comment">/* do some work */</span> </span><br><span class="line"></span><br><span class="line">      qemu_coroutine_yield(); </span><br><span class="line"></span><br><span class="line">      <span class="comment">/* do some more work */</span> </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>yielding 会切换回qemu_coroutine_enter的调用者，qemu中则在发起一个异步的I/O请求后切回主线程的event loop。</p>
<h2 id="qemu协程基础"><a href="#qemu协程基础" class="headerlink" title="qemu协程基础"></a>qemu协程基础</h2><p>qemu-coroutine的实现有gthread,ucontext,sigalstack等几种模式，这里主要看ucontext模式,而coroutine的基础是sigsetjmp/siglongjmp.</p>
<h3 id="sigsetjmp-siglongjmp"><a href="#sigsetjmp-siglongjmp" class="headerlink" title="sigsetjmp/siglongjmp"></a>sigsetjmp/siglongjmp</h3><p>sigsetjmp/siglongjmp是C语言的一组库函数，主要作用是“非本地跳转”，区别于goto，它们能够完成函数外部的跳转。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigsetjmp</span><span class="params">( jmp_buf env )</span>;   <span class="comment">//用于保存程序的运行时的堆栈环境</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">siglongjmp</span><span class="params">( jmp_buf env, <span class="type">int</span> value )</span>; <span class="comment">//用于恢复先前程序中调用的setjmp函数时所保存的堆栈环境,参数value为setjmp返回值</span></span><br></pre></td></tr></table></figure>
<p>其主要作用就是save、restore当前程序的运行上下文，包括寄存器、堆栈信息等到jmp_buf中。</p>
<h3 id="ucontext"><a href="#ucontext" class="headerlink" title="ucontext"></a>ucontext</h3><p>ucontext函数组为sigsetjmp/siglongjmp的升级版：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>  <span class="title function_">getcontext</span><span class="params">(<span class="type">ucontext_t</span> *)</span>; <span class="comment">//初始化ucontext_t结构体，将当前的上下文保存到ucontext_t中</span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">setcontext</span><span class="params">(<span class="type">const</span> <span class="type">ucontext_t</span> *)</span>;  <span class="comment">//设置当前的上下文为ucontext_t,并跳转至其中</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">makecontext</span><span class="params">(<span class="type">ucontext_t</span> *, (<span class="type">void</span> *)(), <span class="type">int</span>, ...)</span>; <span class="comment">//制造一个上下文，并设置入口函数</span></span><br><span class="line"><span class="type">int</span>  <span class="title function_">swapcontext</span><span class="params">(<span class="type">ucontext_t</span> *, <span class="type">const</span> <span class="type">ucontext_t</span> *)</span>; <span class="comment">//保存当前上下文到第一个参数中，然后切换到第二个参数代表的上下文。</span></span><br></pre></td></tr></table></figure>

<h2 id="qemu-coroutine的实现"><a href="#qemu-coroutine的实现" class="headerlink" title="qemu-coroutine的实现"></a>qemu-coroutine的实现</h2><p>qemu-coroutine主要基于sigsetjmp/siglongjmp实现，更为轻量级。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Coroutine *<span class="title function_">qemu_coroutine_create</span><span class="params">(CoroutineEntry *entry)</span></span><br><span class="line">&#123;</span><br><span class="line">    Coroutine *co = qemu_coroutine_new();  <span class="comment">// 创建一个新的coroutine</span></span><br><span class="line">    co-&gt;entry = entry;   <span class="comment">//设置coroutine的入口函数为entry</span></span><br><span class="line">    <span class="keyword">return</span> co;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Coroutine *<span class="title function_">qemu_coroutine_new</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    CoroutineUContext *co;</span><br><span class="line">    <span class="type">ucontext_t</span> old_uc, uc;</span><br><span class="line">    sigjmp_buf old_env;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">cc_arg</span> <span class="title">arg</span> =</span> &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">void</span> *fake_stack_save = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得当前上下文</span></span><br><span class="line">    <span class="keyword">if</span> (getcontext(&amp;uc) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    co = g_malloc0(<span class="keyword">sizeof</span>(*co));</span><br><span class="line">    co-&gt;stack_size = COROUTINE_STACK_SIZE;</span><br><span class="line">    co-&gt;<span class="built_in">stack</span> = qemu_alloc_stack(&amp;co-&gt;stack_size);</span><br><span class="line"></span><br><span class="line">    co-&gt;base.entry_arg = &amp;old_env; <span class="comment">/* stash away our jmp_buf */</span></span><br><span class="line"></span><br><span class="line">    uc.uc_link = &amp;old_uc;</span><br><span class="line">    uc.uc_stack.ss_sp = co-&gt;<span class="built_in">stack</span>;</span><br><span class="line">    uc.uc_stack.ss_size = co-&gt;stack_size;</span><br><span class="line">    uc.uc_stack.ss_flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    arg.p = co;</span><br><span class="line"></span><br><span class="line">    on_new_fiber(co);</span><br><span class="line">    <span class="comment">//制造一个上下文，设置该上下文的栈空间及相关信息</span></span><br><span class="line">    makecontext(&amp;uc, (<span class="type">void</span> (*)(<span class="type">void</span>))coroutine_trampoline,</span><br><span class="line">                <span class="number">2</span>, arg.i[<span class="number">0</span>], arg.i[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* swapcontext() in, siglongjmp() back out */</span></span><br><span class="line">     <span class="comment">//保存当前上下文到old_env中，此时old_env的地址作为co-&gt;base.entry_arg</span></span><br><span class="line">    <span class="keyword">if</span> (!sigsetjmp(old_env, <span class="number">0</span>)) &#123;</span><br><span class="line">        start_switch_fiber_asan(COROUTINE_YIELD, &amp;fake_stack_save, co-&gt;<span class="built_in">stack</span>,</span><br><span class="line">                                co-&gt;stack_size);</span><br><span class="line">        start_switch_fiber_tsan(&amp;fake_stack_save,</span><br><span class="line">                                co, <span class="literal">false</span>); <span class="comment">/* false=not caller */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//切换至uc代表的上下文中，入口函数为coroutine_trampoline，返回点为old_uc中</span></span><br><span class="line">        swapcontext(&amp;old_uc, &amp;uc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    finish_switch_fiber(fake_stack_save);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;co-&gt;base;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">coroutine_trampoline</span><span class="params">(<span class="type">int</span> i0, <span class="type">int</span> i1)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">cc_arg</span> <span class="title">arg</span>;</span></span><br><span class="line">    CoroutineUContext *self;</span><br><span class="line">    Coroutine *co;</span><br><span class="line">    <span class="type">void</span> *fake_stack_save = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    finish_switch_fiber(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    arg.i[<span class="number">0</span>] = i0;</span><br><span class="line">    arg.i[<span class="number">1</span>] = i1;</span><br><span class="line">    self = arg.p;</span><br><span class="line">    <span class="comment">//获取了通过coroutine_new创建的coroutine结构</span></span><br><span class="line">    co = &amp;self-&gt;base;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initialize longjmp environment and switch back the caller */</span></span><br><span class="line">    <span class="comment">//保存当前上下文到co（新协程）的env buffer中，由于第一次setjmp返回的是0，则调用下面的longjmp</span></span><br><span class="line">    <span class="keyword">if</span> (!sigsetjmp(self-&gt;env, <span class="number">0</span>)) &#123;</span><br><span class="line">        start_switch_fiber_asan(COROUTINE_YIELD, &amp;fake_stack_save, leader.<span class="built_in">stack</span>,</span><br><span class="line">                                leader.stack_size);</span><br><span class="line">        start_switch_fiber_tsan(&amp;fake_stack_save, self, <span class="literal">true</span>); <span class="comment">/* true=caller */</span></span><br><span class="line">         <span class="comment">//此时co-&gt;entry_arg为coroutine_new中的old_env保存点，而value给的是1，则swapcontext不会执行，直接return，qemu_coroutine_create就直接返回了</span></span><br><span class="line">        siglongjmp(*(sigjmp_buf *)co-&gt;entry_arg, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    finish_switch_fiber(fake_stack_save);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        co-&gt;entry(co-&gt;entry_arg);</span><br><span class="line">        qemu_coroutine_switch(co, co-&gt;caller, COROUTINE_TERMINATE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过create的过程，新创建的co的env保存了coroutine_trampoline中setjmp(self-&gt;env)的上下文。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">qemu_coroutine_enter</span><span class="params">(Coroutine *co, <span class="type">void</span> *opaque)</span></span><br><span class="line">&#123;</span><br><span class="line">    Coroutine *from = qemu_coroutine_self();   <span class="comment">//获取当前协程的co结构，第一次可认为是主协程的控制信息</span></span><br><span class="line"></span><br><span class="line">    to-&gt;caller = from;   <span class="comment">//新协程的caller为主线程co</span></span><br><span class="line">    to-&gt;ctx = ctx;</span><br><span class="line">    qemu_coroutine_switch(from, to, COROUTINE_ENTER);   <span class="comment">//通过swap操作从主协程切换至新创建的co</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//qemu_coroutine_switch 为协程切换的关键函数</span></span><br><span class="line">CoroutineAction __attribute__((noinline))</span><br><span class="line">qemu_coroutine_switch(Coroutine *from_, Coroutine *to_,</span><br><span class="line">                      CoroutineAction action)</span><br><span class="line">&#123;</span><br><span class="line">    CoroutineUContext *from = DO_UPCAST(CoroutineUContext, base, from_);</span><br><span class="line">    CoroutineUContext *to = DO_UPCAST(CoroutineUContext, base, to_);</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">void</span> *fake_stack_save = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    current = to_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存当前的上下文到主协程的env中，相当于主协程的上下文在qemu_coroutine_enter中</span></span><br><span class="line">    ret = sigsetjmp(from-&gt;env, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">        start_switch_fiber_asan(action, &amp;fake_stack_save, to-&gt;<span class="built_in">stack</span>,</span><br><span class="line">                                to-&gt;stack_size);</span><br><span class="line">        start_switch_fiber_tsan(&amp;fake_stack_save,</span><br><span class="line">                                to, <span class="literal">false</span>); <span class="comment">/* false=not caller */</span></span><br><span class="line"><span class="comment">//跳转至新协程的上下文，新协程的上下文保存点为coroutine_trampoline中的setjmp处，此处action给的是非0，则直接进入co-&gt;entry(co-&gt;entry_arg);执行create时给的entry.</span></span><br><span class="line">        siglongjmp(to-&gt;env, action);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    finish_switch_fiber(fake_stack_save);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若co-&gt;entry(co-&gt;entry_arg)中使用<code>qemu_coroutine_yield</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> coroutine_fn <span class="title function_">qemu_coroutine_yield</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Coroutine *self = qemu_coroutine_self();</span><br><span class="line">    Coroutine *to = self-&gt;caller;</span><br><span class="line"></span><br><span class="line">    trace_qemu_coroutine_yield(self, to);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!to) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Co-routine is yielding to no one\n&quot;</span>);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    self-&gt;caller = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//此处self为新协程，to为主协程</span></span><br><span class="line">    qemu_coroutine_switch(self, to, COROUTINE_YIELD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次通过coroutine_swap操作来进行切换：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CoroutineAction <span class="title function_">qemu_coroutine_switch</span><span class="params">(Coroutine *from_, Coroutine *to_,</span></span><br><span class="line"><span class="params">                                      CoroutineAction action)</span></span><br><span class="line">&#123;</span><br><span class="line">    CoroutineUContext *from = DO_UPCAST(CoroutineUContext, base, from_);</span><br><span class="line">    CoroutineUContext *to = DO_UPCAST(CoroutineUContext, base, to_);</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">void</span> *fake_stack_save = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    current = to_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存当前上下文到from的env即新协程的env，此处的调用栈为qemu_coroutine_yield的内部</span></span><br><span class="line">    ret = sigsetjmp(from-&gt;env, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">        start_switch_fiber_asan(action, &amp;fake_stack_save, to-&gt;<span class="built_in">stack</span>,</span><br><span class="line">                                to-&gt;stack_size);</span><br><span class="line">        start_switch_fiber_tsan(&amp;fake_stack_save,</span><br><span class="line">                                to, <span class="literal">false</span>); <span class="comment">/* false=not caller */</span></span><br><span class="line">        <span class="comment">//切换至主协程的上下文，在上面enter的分析中可以得到，此时主协程的上下文在qemu_coroutine_enter中。</span></span><br><span class="line">        siglongjmp(to-&gt;env, action);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    finish_switch_fiber(fake_stack_save);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样yield处的上下文被保存在新协程的env中，而程序逻辑调回了qemu_coroutine_enter中继续执行，即从qemu_coroutine_enter退出。</p>
<p>在适当的时机，再次调用qemu_coroutine_enter则会恢复yield处的上下文继续执行。</p>
]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>msg_control</title>
    <url>/2022/06/03/msg-control/</url>
    <content><![CDATA[<h2 id="msghdr结构"><a href="#msghdr结构" class="headerlink" title="msghdr结构"></a>msghdr结构</h2><p>msghdr结构一般会用于如下两个函数中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">sendmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="keyword">struct</span> msghdr *msg, <span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">recvmsg</span><span class="params">(<span class="type">int</span> sockfd, <span class="keyword">struct</span> msghdr *msg, <span class="type">int</span> flags)</span>;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>它主要用于向一个socket发送消息，或从一个socket中接收消息。此处很重要的一个作用就是用在unix域中传递一个文件描述符。struct msghdr结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span>                    <span class="comment">/* Scatter/gather array items */</span></span><br><span class="line">   <span class="type">void</span>  *iov_base;              <span class="comment">/* Starting address */</span></span><br><span class="line">   <span class="type">size_t</span> iov_len;               <span class="comment">/* Number of bytes to transfer */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> &#123;</span></span><br><span class="line">   <span class="type">void</span>         *msg_name;       <span class="comment">/* optional address */</span></span><br><span class="line">   <span class="type">socklen_t</span>     msg_namelen;    <span class="comment">/* size of address */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> *<span class="title">msg_iov</span>;</span>        <span class="comment">/* scatter/gather array */</span></span><br><span class="line">   <span class="type">size_t</span>        msg_iovlen;     <span class="comment">/* # elements in msg_iov */</span></span><br><span class="line">   <span class="type">void</span>         *msg_control;    <span class="comment">/* ancillary data, see below */</span></span><br><span class="line">   <span class="type">size_t</span>        msg_controllen; <span class="comment">/* ancillary data buffer len */</span></span><br><span class="line">   <span class="type">int</span>           msg_flags;      <span class="comment">/* flags on received message */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>msg_control</code>指针: 指向与协议控制相关的消息或者辅助数据.<br><code>msg_controllen</code>: msg_control所指向的这块缓冲的长度。</p>
<p><code>msg_control</code>是一个<code>struct cmsghdr</code>结构，下面我们会介绍。</p>
<h2 id="cmsghdr结构"><a href="#cmsghdr结构" class="headerlink" title="cmsghdr结构"></a>cmsghdr结构</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmsghdr</span> &#123;</span></span><br><span class="line">   <span class="type">size_t</span> cmsg_len;    <span class="comment">/* Data byte count, including header</span></span><br><span class="line"><span class="comment">                          (type is socklen_t in POSIX) */</span></span><br><span class="line">   <span class="type">int</span>    cmsg_level;  <span class="comment">/* Originating protocol */</span></span><br><span class="line">   <span class="type">int</span>    cmsg_type;   <span class="comment">/* Protocol-specific type */</span></span><br><span class="line"><span class="comment">/* followed by</span></span><br><span class="line"><span class="comment">   unsigned char cmsg_data[]; */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>cmsg_level</code>一般为原始的协议级别，<code>cmsg_type</code>为前面原始协议下的某一个子类型。<br>要访问此辅助数据结构，一般会用到如下几个函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> cmsghdr *<span class="title function_">CMSG_FIRSTHDR</span><span class="params">(<span class="keyword">struct</span> msghdr *msgh)</span>;</span><br><span class="line"><span class="keyword">struct</span> cmsghdr *<span class="title function_">CMSG_NXTHDR</span><span class="params">(<span class="keyword">struct</span> msghdr *msgh, <span class="keyword">struct</span> cmsghdr</span></span><br><span class="line"><span class="params">*cmsg)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">CMSG_ALIGN</span><span class="params">(<span class="type">size_t</span> length)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">CMSG_SPACE</span><span class="params">(<span class="type">size_t</span> length)</span>;</span><br><span class="line"><span class="type">size_t</span> <span class="title function_">CMSG_LEN</span><span class="params">(<span class="type">size_t</span> length)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">CMSG_DATA</span><span class="params">(<span class="keyword">struct</span> cmsghdr *cmsg)</span>;</span><br></pre></td></tr></table></figure>
<p>这些宏用于创建和访问控制消息(msg_control)，也称为辅助数据，其并不作为socket净荷数据的一部分，净荷数据保存在<code>msg_iov</code>中（参见上述struct msghdr)。 这些辅助数据可能包括：</p>
<ul>
<li><p>所收到的packet的网卡接口</p>
</li>
<li><p>一些不太常用的头部字段</p>
</li>
<li><p>一个扩展的错误描述</p>
</li>
<li><p>一个文件描述符集合</p>
</li>
<li><p>UNIX credentials</p>
</li>
</ul>
<p>例如用辅助数据可以发送一些额外的头部字段(eg. IP options)。</p>
<p>要访问一系列的cmsghdr结构，我们必须使用如下这些宏，而不要直接访问：</p>
<p><code>CMSG_FIRSTHDR()</code>: 返回msghdr辅助数据部分指向第一个cmsghdr的指针</p>
<p><code>CMSG_NXTHDR()</code>: 返回参数中cmsghdr的下一个有效cmsghdr。当msg_control buffer中没有足够剩余的空间的时候，返回NULL</p>
<p><code>CMSG_ALIGN()</code>: 给定一个长度，其会返回对齐后相应的长度。它是一个常量表达式，其一般实现如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CMSG_ALIGN(len)  ( ((len)+sizeof(long)-1) &amp; ~(sizeof(long)-1) ) </span></span><br></pre></td></tr></table></figure>
<p><code>CMSG_SPACE()</code>: 返回辅助数据及其所传递的净荷数据的总长度。即sizeof(cmsg_len) + sizeof(cmsg_level) + sizeof(cmsg_type) + len(cmsg_data)长度进行CMSG_ALIGN后的值.</p>
<p><code>CMSG_DATA()</code>: 返回cmsghdr的净荷数据部分</p>
<p><code>CMSG_LEN()</code>: 返回净荷数据长度进行CMSG_ALIGN后的值，一般赋值给cmsghdr.cmsg_len。</p>
<p>为了创建辅助数据，首先初始化msghdr.msg_controllen字段。 在msghdr上使用CMSG_FIRSTHDR()来获取第一个控制消息，然后使用CMSG_NXTHDR()来获取后续的控制消息。在每一个控制消息中，使用CMSG_LEN()来初始化cmsghdr.cmsg_len，使用CMSG_DATA()来初始化cmsghdr.cmsg_data部分。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>msg_control</tag>
      </tags>
  </entry>
  <entry>
    <title>qemu热迁移代码目的端</title>
    <url>/2022/06/03/qemu%E7%83%AD%E8%BF%81%E7%A7%BB%E4%BB%A3%E7%A0%81%E7%9B%AE%E7%9A%84%E7%AB%AF/</url>
    <content><![CDATA[<h2 id="qemu启动参数"><a href="#qemu启动参数" class="headerlink" title="qemu启动参数"></a>qemu启动参数</h2><p>qemu启动参数设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-incoming tcp:ip:port</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>则表示，该qemu启动为迁移目的端</p>
<h2 id="启动初始化"><a href="#启动初始化" class="headerlink" title="启动初始化"></a>启动初始化</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">qemu_init</span><br><span class="line">    qmp_x_exit_preconfig</span><br><span class="line">        qmp_migrate_incoming</span><br><span class="line">            qemu_start_incoming_migration</span><br><span class="line">                socket_start_incoming_migration</span><br><span class="line">                    socket_start_incoming_migration_internal</span><br></pre></td></tr></table></figure>
<p>这里启动一个socket server，设置socket_accept_incoming_migration为accept事件</p>
<h2 id="热迁移后的处理"><a href="#热迁移后的处理" class="headerlink" title="热迁移后的处理"></a>热迁移后的处理</h2><p>当源端发起<code>migrate tcp:ip:port</code>命令后，则触发目的端接收</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">socket_accept_incoming_migration</span><br><span class="line">    migration_channel_process_incoming</span><br><span class="line">        migration_ioc_process_incoming</span><br><span class="line">            migration_incoming_process</span><br><span class="line"><span class="type">void</span> <span class="title function_">migration_incoming_process</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Coroutine *co = qemu_coroutine_create(process_incoming_migration_co, <span class="literal">NULL</span>);</span><br><span class="line">    qemu_coroutine_enter(co);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里起一个协程，核心流程在qemu_loadvm_state实现</p>
<h3 id="迁移发起"><a href="#迁移发起" class="headerlink" title="迁移发起"></a>迁移发起</h3><p>迁移发起阶段，解析magic，version和configuration字段，同时调用setup回调函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">qemu_loadvm_state_header</span><br><span class="line">qemu_loadvm_state_setup</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">qemu_loadvm_state_header</span><span class="params">(QEMUFile *f)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> v;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 解析magic字段 */</span></span><br><span class="line">    v = qemu_get_be32(f);</span><br><span class="line">    <span class="keyword">if</span> (v != QEMU_VM_FILE_MAGIC) &#123;</span><br><span class="line">        error_report(<span class="string">&quot;Not a migration stream&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 解析version字段*/</span></span><br><span class="line">    v = qemu_get_be32(f);</span><br><span class="line">    <span class="keyword">if</span> (v == QEMU_VM_FILE_VERSION_COMPAT) &#123;</span><br><span class="line">        error_report(<span class="string">&quot;SaveVM v2 format is obsolete and don&#x27;t work anymore&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOTSUP;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (v != QEMU_VM_FILE_VERSION) &#123;</span><br><span class="line">        error_report(<span class="string">&quot;Unsupported migration stream version&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> -ENOTSUP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 解析configuration section */</span></span><br><span class="line">    <span class="keyword">if</span> (migrate_get_current()-&gt;send_configuration) &#123;</span><br><span class="line">        <span class="keyword">if</span> (qemu_get_byte(f) != QEMU_VM_CONFIGURATION) &#123;</span><br><span class="line">            error_report(<span class="string">&quot;Configuration section missing&quot;</span>);</span><br><span class="line">            qemu_loadvm_state_cleanup();</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = vmstate_load_state(f, &amp;vmstate_configuration, &amp;savevm_state, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            qemu_loadvm_state_cleanup();</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">qemu_loadvm_state_setup</span><span class="params">(QEMUFile *f)</span></span><br><span class="line">&#123;</span><br><span class="line">    SaveStateEntry *se;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    trace_loadvm_state_setup();</span><br><span class="line">    QTAILQ_FOREACH(se, &amp;savevm_state.handlers, entry) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!se-&gt;ops || !se-&gt;ops-&gt;load_setup) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (se-&gt;ops-&gt;is_active) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!se-&gt;ops-&gt;is_active(se-&gt;opaque)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//setup回调函数，这里以ram_load_setup为例，与ram_save_setup对应</span></span><br><span class="line">        <span class="comment">//初始化RAMBlock-&gt;receivedmap</span></span><br><span class="line">        ret = se-&gt;ops-&gt;load_setup(f, se-&gt;opaque);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            qemu_file_set_error(f, ret);</span><br><span class="line">            error_report(<span class="string">&quot;Load state of device %s failed&quot;</span>, se-&gt;idstr);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迁移拷贝"><a href="#迁移拷贝" class="headerlink" title="迁移拷贝"></a>迁移拷贝</h3><p>迁移拷贝主要逻辑在qemu_loadvm_state_main函数中，它从流中解析出section类型，<br>这里对应源端递归迁移阶段，while循环接收，直到section类型QEMU_VM_EOF表示数据已接收完毕</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">qemu_loadvm_state_main</span><span class="params">(QEMUFile *f, MigrationIncomingState *mis)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> section_type;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">retry:</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">/* 从输入流中解析section类型 */</span></span><br><span class="line">        section_type = qemu_get_byte(f);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (qemu_file_get_error(f)) &#123;</span><br><span class="line">            ret = qemu_file_get_error(f);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        trace_qemu_loadvm_state_section(section_type);</span><br><span class="line">        <span class="keyword">switch</span> (section_type) &#123;</span><br><span class="line">        <span class="keyword">case</span> QEMU_VM_SECTION_START:</span><br><span class="line">        <span class="keyword">case</span> QEMU_VM_SECTION_FULL:</span><br><span class="line">            <span class="comment">/* start 和full section一起处理 */</span></span><br><span class="line">            ret = qemu_loadvm_section_start_full(f, mis);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> QEMU_VM_SECTION_PART:</span><br><span class="line">        <span class="keyword">case</span> QEMU_VM_SECTION_END:</span><br><span class="line">            <span class="comment">/* part和end section一起处理 */</span></span><br><span class="line">            ret = qemu_loadvm_section_part_end(f, mis);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> QEMU_VM_EOF:</span><br><span class="line">            <span class="comment">/* This is the end of migration */</span></span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迁移完成下半部（bottom-half）"><a href="#迁移完成下半部（bottom-half）" class="headerlink" title="迁移完成下半部（bottom half）"></a>迁移完成下半部（bottom half）</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">g_main_context_dispatch</span><br><span class="line">    aio_ctx_dispatch</span><br><span class="line">        process_incoming_migration_bh</span><br><span class="line">            vm_start</span><br><span class="line">                vm_state_notify</span><br><span class="line">                    virtio_vmstate_change</span><br><span class="line">                        virtio_net_set_status</span><br><span class="line">                            vhost_net_start</span><br></pre></td></tr></table></figure>
<p>发送vhost消息到后端，进行特性协商、vq映射等</p>
]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>qemu热迁移代码源端</title>
    <url>/2022/06/02/qemu%E7%83%AD%E8%BF%81%E7%A7%BB%E4%BB%A3%E7%A0%81%E6%BA%90%E7%AB%AF/</url>
    <content><![CDATA[<h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">qmp_migrate</span><br><span class="line">    migrate_fd_connect</span><br><span class="line">        migration_thread</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>开启热迁移线程：准备阶段（记录卡侧脏页），循环执行迁移，最后处理</p>
<h3 id="savevm-ram-handlers"><a href="#savevm-ram-handlers" class="headerlink" title="savevm_ram_handlers"></a>savevm_ram_handlers</h3><p>ram设备在vm初始化时注册的各种handle</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> SaveVMHandlers savevm_ram_handlers = &#123;</span><br><span class="line">    .save_setup = ram_save_setup,</span><br><span class="line">    .save_live_iterate = ram_save_iterate,</span><br><span class="line">    .save_live_complete_postcopy = ram_save_complete,</span><br><span class="line">    .save_live_complete_precopy = ram_save_complete,</span><br><span class="line">    .has_postcopy = ram_has_postcopy,</span><br><span class="line">    .save_live_pending = ram_save_pending,</span><br><span class="line">    .load_state = ram_load,</span><br><span class="line">    .save_cleanup = ram_save_cleanup,</span><br><span class="line">    .load_setup = ram_load_setup,</span><br><span class="line">    .load_cleanup = ram_load_cleanup,</span><br><span class="line">    .resume_prepare = ram_resume_prepare,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>源端迁移处理函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ram_save_setup          <span class="comment">//第一阶段：虚机内存标脏，卡侧脏页记录</span></span><br><span class="line">ram_save_pending        <span class="comment">//第二阶段：kvm脏页记录，同步到qemu</span></span><br><span class="line"><span class="keyword">while</span> (pending_size &gt; threshold_size)</span><br><span class="line">    ram_save_iterate        <span class="comment">//第二阶段：kvm脏页数据同步到目的端</span></span><br><span class="line">ram_save_complete       <span class="comment">//第三阶段：vm stop，卡侧脏页同步qemu，传输剩余脏页</span></span><br></pre></td></tr></table></figure>
<p>主要做的事：</p>
<ul>
<li>用bitmap跟踪脏页</li>
<li>将脏页传送到对端</li>
</ul>
<p>传输的内存有3部分组成：虚机整体内存、卡侧内存、kvm内存<br>这里为何有卡侧内存，这是因为，虚机dma需要将虚机的内存映射给卡侧，这部分内存是旁路内核的</p>
<p>这里<code>pending_size</code>是kvm获取的脏页大小，<code>threshold_size</code>为临界值：带宽*downtime_limit<br><code>downtime_limit</code>标识最大停机时间，默认为300ms，也可指定</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">migrate_set_parameter downtime_limit 1</span><br></pre></td></tr></table></figure>
<p>带宽 = 已迁移数据大小/迁移时间<br>在迁移脏页数据时计算临界值，调用栈如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ram_save_iterate</span><br><span class="line">    ram_find_and_save_block</span><br><span class="line">     ram_save_host_page</span><br><span class="line">        migration_rate_limit</span><br><span class="line">            migration_update_counters</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">migration_update_counters</span><span class="params">(MigrationState *s,</span></span><br><span class="line"><span class="params">                                      <span class="type">int64_t</span> current_time)</span></span><br><span class="line">&#123;</span><br><span class="line">....</span><br><span class="line">    current_bytes = migration_total_bytes(s);</span><br><span class="line">    transferred = current_bytes - s-&gt;iteration_initial_bytes;</span><br><span class="line">    time_spent = current_time - s-&gt;iteration_start_time;</span><br><span class="line">    bandwidth = (<span class="type">double</span>)transferred / time_spent;</span><br><span class="line">    s-&gt;threshold_size = bandwidth * s-&gt;parameters.downtime_limit;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="准备阶段（记录卡侧脏页）"><a href="#准备阶段（记录卡侧脏页）" class="headerlink" title="准备阶段（记录卡侧脏页）"></a>准备阶段（记录卡侧脏页）</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">migration_thread</span><span class="params">(<span class="type">void</span> *opaque)</span></span><br><span class="line">&#123;</span><br><span class="line">.......</span><br><span class="line">    <span class="comment">//第一阶段 分别调用了savevm_handlers中注册的迁移设备准备接口，以ram_save_setup为例</span></span><br><span class="line">    qemu_savevm_state_setup(s-&gt;to_dst_file);</span><br><span class="line">.......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1、将虚拟机内存全部标脏</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">migration_thread</span><br><span class="line">    qemu_savevm_state_setup</span><br><span class="line">        ram_save_setup</span><br><span class="line">            ram_init_all</span><br><span class="line">                ram_init_bitmaps</span><br><span class="line">                    ram_list_init_bitmaps</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">ram_list_init_bitmaps</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">....</span><br><span class="line">    RAMBLOCK_FOREACH_NOT_IGNORED(block) &#123;</span><br><span class="line">        <span class="comment">//一个RAMBlock最大可以表示8G，</span></span><br><span class="line">        <span class="comment">//max_length取决于qemu启动参数-m 2048的大小，这里为2g</span></span><br><span class="line">        pages = block-&gt;max_length &gt;&gt; TARGET_PAGE_BITS;</span><br><span class="line">        block-&gt;bmap = bitmap_new(pages);</span><br><span class="line">        <span class="comment">//将虚拟机内存全部标脏</span></span><br><span class="line">        bitmap_set(block-&gt;bmap, <span class="number">0</span>, pages);</span><br><span class="line">        block-&gt;clear_bmap_shift = shift;</span><br><span class="line">        block-&gt;clear_bmap = bitmap_new(clear_bmap_size(pages, shift));</span><br><span class="line">    &#125;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、记录卡侧脏页</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">migration_thread</span><br><span class="line">    qemu_savevm_state_setup</span><br><span class="line">        ram_save_setup</span><br><span class="line">            ram_init_all</span><br><span class="line">                ram_init_bitmaps</span><br><span class="line">                    memory_global_dirty_log_start</span><br><span class="line">                        vhost_log_global_start</span><br></pre></td></tr></table></figure>
<p>这里是记录卸载到卡侧的vring内存，desc、avail、used</p>
<h3 id="vhost-log-global-start"><a href="#vhost-log-global-start" class="headerlink" title="vhost_log_global_start"></a>vhost_log_global_start</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vhost_migration_log</span><br><span class="line">    vhost_dev_log_resize</span><br><span class="line">        vhost_set_log_base</span><br><span class="line">    vhost_dev_set_log</span><br><span class="line">        vhost_set_features</span><br></pre></td></tr></table></figure>
<p>1、首先设置log_base和log_size，标识后端需要记录的内存基地址和大小<br>如果后端是kernel，则通过ioctl发送VHOST_USER_SET_LOG_BASE消息<br>如果后端是vhost_user，则通过unix socket发送VHOST_USER_SET_LOG_BASE消息</p>
<p>2、然后通过vhost_set_features，设置VHOST_F_LOG_ALL（26）特性位，通知后端使能log_enabled</p>
<h2 id="循环执行迁移"><a href="#循环执行迁移" class="headerlink" title="循环执行迁移"></a>循环执行迁移</h2><p>migration_iteration_run</p>
<h3 id="脏页记录"><a href="#脏页记录" class="headerlink" title="脏页记录"></a>脏页记录</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ram_save_pending</span><br><span class="line">    migration_bitmap_sync</span><br><span class="line">        memory_global_dirty_log_sync</span><br><span class="line">            kvm_log_sync</span><br><span class="line">                kvm_slot_get_dirty_log       <span class="comment">//获取kvm脏页</span></span><br><span class="line">                kvm_slot_sync_dirty_pages    <span class="comment">//同步到qemu</span></span><br></pre></td></tr></table></figure>
<p>这里记录kvm中的内存，通过ioctl发送KVM_GET_DIRTY_LOG向kvm获取脏页记录</p>
<h4 id="kvm-slot-sync-dirty-pages"><a href="#kvm-slot-sync-dirty-pages" class="headerlink" title="kvm_slot_sync_dirty_pages"></a>kvm_slot_sync_dirty_pages</h4><p>将kvm获取的脏页设置到qemu，每一个log_chunk是一个unsigned long数据，拥有64bit，<br>每一个bit标识一个4k页<br>这里需要区分start是否是unsigned long对齐，具体算法如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">cpu_physical_memory_set_dirty_lebitmap</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> *bitmap,</span></span><br><span class="line"><span class="params">                                                          <span class="type">ram_addr_t</span> start,</span></span><br><span class="line"><span class="params">                                                          <span class="type">ram_addr_t</span> pages)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> i, j;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> page_number, c;</span><br><span class="line">    hwaddr addr;</span><br><span class="line">    <span class="type">ram_addr_t</span> ram_addr;</span><br><span class="line">    <span class="comment">//以64位为单位计算的bitmap的长度</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> len = (pages + HOST_LONG_BITS - <span class="number">1</span>) / HOST_LONG_BITS;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> hpratio = qemu_real_host_page_size / TARGET_PAGE_SIZE;</span><br><span class="line">    <span class="comment">//利用在ramlist中的起始页框号/64 计算出 map位图的索引</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> page = BIT_WORD(start &gt;&gt; TARGET_PAGE_BITS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* start address is aligned at the start of a word? */</span></span><br><span class="line">    <span class="comment">/* 如果section的起始页框号是64对齐的 */</span></span><br><span class="line">    <span class="keyword">if</span> ((((page * BITS_PER_LONG) &lt;&lt; TARGET_PAGE_BITS) == start) &amp;&amp;</span><br><span class="line">        (hpratio == <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> **blocks[DIRTY_MEMORY_NUM];</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> idx;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> offset;</span><br><span class="line">        <span class="type">long</span> k;</span><br><span class="line">        <span class="type">long</span> nr = BITS_TO_LONGS(pages);<span class="comment">//以64位为单位计算bitmap的长度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里的idx和offset就是前面第一个图上的i和j</span></span><br><span class="line">        idx = (start &gt;&gt; TARGET_PAGE_BITS) / DIRTY_MEMORY_BLOCK_SIZE;</span><br><span class="line">        offset = BIT_WORD((start &gt;&gt; TARGET_PAGE_BITS) %</span><br><span class="line">                          DIRTY_MEMORY_BLOCK_SIZE);</span><br><span class="line"></span><br><span class="line">        WITH_RCU_READ_LOCK_GUARD() &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; DIRTY_MEMORY_NUM; i++) &#123;</span><br><span class="line">                blocks[i] =</span><br><span class="line">                    qatomic_rcu_read(&amp;ram_list.dirty_memory[i])-&gt;blocks;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; nr; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (bitmap[k]) &#123;<span class="comment">//存在脏页</span></span><br><span class="line">                    <span class="type">unsigned</span> <span class="type">long</span> temp = leul_to_cpu(bitmap[k]);</span><br><span class="line">                    <span class="comment">//直接设置到map的offset对应项中</span></span><br><span class="line">                    qatomic_or(&amp;blocks[DIRTY_MEMORY_VGA][idx][offset], temp);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (global_dirty_tracking) &#123;</span><br><span class="line">                        qatomic_or(</span><br><span class="line">                                &amp;blocks[DIRTY_MEMORY_MIGRATION][idx][offset],</span><br><span class="line">                                temp);</span><br><span class="line">                        <span class="keyword">if</span> (unlikely(</span><br><span class="line">                            global_dirty_tracking &amp; GLOBAL_DIRTY_DIRTY_RATE)) &#123;</span><br><span class="line">                            total_dirty_pages += ctpopl(temp);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (tcg_enabled()) &#123;</span><br><span class="line">                        qatomic_or(&amp;blocks[DIRTY_MEMORY_CODE][idx][offset],</span><br><span class="line">                                   temp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//offset对应64bit的第一位对应页框在ramlist上的地址已经超过8G</span></span><br><span class="line">                <span class="keyword">if</span> (++offset &gt;= BITS_TO_LONGS(DIRTY_MEMORY_BLOCK_SIZE)) &#123;</span><br><span class="line">                    offset = <span class="number">0</span>;</span><br><span class="line">                    idx++;<span class="comment">//则换到blocks的下一个map位图</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        xen_hvm_modified_memory(start, pages &lt;&lt; TARGET_PAGE_BITS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">uint8_t</span> clients = tcg_enabled() ? DIRTY_CLIENTS_ALL : DIRTY_CLIENTS_NOCODE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!global_dirty_tracking) &#123;</span><br><span class="line">            clients &amp;= ~(<span class="number">1</span> &lt;&lt; DIRTY_MEMORY_MIGRATION);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * bitmap-traveling is faster than memory-traveling (for addr...)</span></span><br><span class="line"><span class="comment">         * especially when most of the memory is not dirty.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bitmap[i] != <span class="number">0</span>) &#123;<span class="comment">//这个64位区间存在脏页</span></span><br><span class="line">                c = leul_to_cpu(bitmap[i]);</span><br><span class="line">                <span class="keyword">if</span> (unlikely(global_dirty_tracking &amp; GLOBAL_DIRTY_DIRTY_RATE)) &#123;</span><br><span class="line">                    total_dirty_pages += ctpopl(c);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    j = ctzl(c);<span class="comment">//返回第一个1的位置，方便后面计算page_number</span></span><br><span class="line">                    c &amp;= ~(<span class="number">1ul</span> &lt;&lt; j);<span class="comment">//把c中的第一个1清空</span></span><br><span class="line">                    page_number = (i * HOST_LONG_BITS + j) * hpratio;</span><br><span class="line">                    addr = page_number * TARGET_PAGE_SIZE;</span><br><span class="line">                    ram_addr = start + addr;<span class="comment">//计算出bitmap第一个脏页框在ramlist中的地址</span></span><br><span class="line">                    <span class="comment">//只设置一个脏页的脏页位</span></span><br><span class="line">                    cpu_physical_memory_set_dirty_range(ram_addr,</span><br><span class="line">                                       TARGET_PAGE_SIZE * hpratio, clients);</span><br><span class="line">                &#125; <span class="keyword">while</span> (c != <span class="number">0</span>);<span class="comment">//整个循环能够设置完64位的脏页位</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//将bitmap整个完整的设置到qemu的blocks位图中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">cpu_physical_memory_set_dirty_range</span><span class="params">(<span class="type">ram_addr_t</span> start,</span></span><br><span class="line"><span class="params">                                                       <span class="type">ram_addr_t</span> length,</span></span><br><span class="line"><span class="params">                                                       <span class="type">uint8_t</span> mask)</span></span><br><span class="line">&#123;</span><br><span class="line">    DirtyMemoryBlocks *blocks[DIRTY_MEMORY_NUM];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> end, page;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> idx, offset, base;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mask &amp;&amp; !xen_enabled()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结束页框号</span></span><br><span class="line">    end = TARGET_PAGE_ALIGN(start + length) &gt;&gt; TARGET_PAGE_BITS;</span><br><span class="line">    <span class="comment">//起始脏页页框号</span></span><br><span class="line">    page = start &gt;&gt; TARGET_PAGE_BITS;</span><br><span class="line"></span><br><span class="line">    WITH_RCU_READ_LOCK_GUARD() &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; DIRTY_MEMORY_NUM; i++) &#123;</span><br><span class="line">            blocks[i] = qatomic_rcu_read(&amp;ram_list.dirty_memory[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//page页框号对应 页框地址 小于8G的情况下，idx = 0,offset = page</span></span><br><span class="line">        <span class="comment">//（这里的offset是不能拿去直接索引map位图的，因为这里的offset是页框号）</span></span><br><span class="line">        idx = page / DIRTY_MEMORY_BLOCK_SIZE;</span><br><span class="line">        offset = page % DIRTY_MEMORY_BLOCK_SIZE;</span><br><span class="line">        base = page - offset;<span class="comment">//base为0</span></span><br><span class="line">        <span class="keyword">while</span> (page &lt; end) &#123;<span class="comment">//这个循环只执行一次</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> next = MIN(end, base + DIRTY_MEMORY_BLOCK_SIZE);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (likely(mask &amp; (<span class="number">1</span> &lt;&lt; DIRTY_MEMORY_MIGRATION))) &#123;</span><br><span class="line">                bitmap_set_atomic(blocks[DIRTY_MEMORY_MIGRATION]-&gt;blocks[idx],</span><br><span class="line">                                  offset, next - page);<span class="comment">//设置脏页位</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (unlikely(mask &amp; (<span class="number">1</span> &lt;&lt; DIRTY_MEMORY_VGA))) &#123;</span><br><span class="line">                bitmap_set_atomic(blocks[DIRTY_MEMORY_VGA]-&gt;blocks[idx],</span><br><span class="line">                                  offset, next - page);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (unlikely(mask &amp; (<span class="number">1</span> &lt;&lt; DIRTY_MEMORY_CODE))) &#123;</span><br><span class="line">                bitmap_set_atomic(blocks[DIRTY_MEMORY_CODE]-&gt;blocks[idx],</span><br><span class="line">                                  offset, next - page);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            page = next;</span><br><span class="line">            idx++;</span><br><span class="line">            offset = <span class="number">0</span>;</span><br><span class="line">            base += DIRTY_MEMORY_BLOCK_SIZE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    xen_hvm_modified_memory(start, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="脏页数据迁移"><a href="#脏页数据迁移" class="headerlink" title="脏页数据迁移"></a>脏页数据迁移</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ram_save_iterate</span><br><span class="line">    ram_find_and_save_block</span><br><span class="line">        ram_save_host_page</span><br><span class="line">            ram_save_target_page</span><br><span class="line">                ram_save_page</span><br><span class="line">                    save_normal_page</span><br></pre></td></tr></table></figure>
<p>这里通过写socket fd将数据（RAMBlock中，guest映射的host内存，写4k大小的数据），将数据发送到目的端</p>
<p><strong>注意</strong><br>如果guest写入内存的速度很快，正常的迁移将永远持续下去，可能无法完成，此时需要在热迁移执行命令前，开启auto-converge，对cpu降频</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">migrate_set_capability auto-converge on</span><br></pre></td></tr></table></figure>
<p>具体参考：<a href="https://wiki.qemu.org/Features/AutoconvergeLiveMigration">https://wiki.qemu.org/Features/AutoconvergeLiveMigration</a><br>代码中<code>migration_bitmap_sync</code>会判断</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">migration_bitmap_sync</span><span class="params">(RAMState *rs)</span></span><br><span class="line">&#123;</span><br><span class="line">.....</span><br><span class="line"><span class="comment">//大于1秒需要看是否支持auto_converge以及xbzrle的数据统计</span></span><br><span class="line"><span class="keyword">if</span> (end_time &gt; rs-&gt;time_last_bitmap_sync + <span class="number">1000</span>) &#123;</span><br><span class="line">....</span><br><span class="line">&#125;</span><br><span class="line">.....</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="最后处理"><a href="#最后处理" class="headerlink" title="最后处理"></a>最后处理</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">migration_completion</span><br><span class="line">    vm_stop_force_state <span class="comment">//关闭vm，设置虚拟机为迁移完成态</span></span><br><span class="line">    qemu_savevm_state_complete_precopy  <span class="comment">//进行调用最后处理</span></span><br></pre></td></tr></table></figure>

<h3 id="vm-stop-force-state"><a href="#vm-stop-force-state" class="headerlink" title="vm_stop_force_state"></a>vm_stop_force_state</h3><p>1、以队列为粒度，通过vhost_get_vring_base向后端发起stop dev处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vm_stop_force_state</span><br><span class="line">vm_stop</span><br><span class="line">vm_state_notify</span><br><span class="line">virtio_vmstate_change</span><br><span class="line">virtio_net_set_status</span><br><span class="line">virtio_net_vhost_status</span><br><span class="line">vhost_net_stop_one</span><br><span class="line">vhost_dev_stop</span><br><span class="line">vhost_virtqueue_stop</span><br><span class="line">vhost_get_vring_base</span><br></pre></td></tr></table></figure>

<p>2、后端关闭设备后，通过vhost_dev_sync_region将卡侧的脏页同步到qemu，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vm_stop_force_state</span><br><span class="line">vm_stop</span><br><span class="line">vm_state_notify</span><br><span class="line">virtio_vmstate_change</span><br><span class="line">virtio_net_set_status</span><br><span class="line">virtio_net_vhost_status</span><br><span class="line">vhost_net_stop_one</span><br><span class="line">vhost_dev_stop</span><br><span class="line">vhost_log_put</span><br><span class="line">vhost_log_sync_range</span><br><span class="line">vhost_sync_dirty_bitmap</span><br><span class="line">vhost_dev_sync_region</span><br><span class="line">cpu_physical_memory_set_dirty_range</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">vhost_dev_sync_region</span><span class="params">(<span class="keyword">struct</span> vhost_dev *dev,</span></span><br><span class="line"><span class="params">                                  MemoryRegionSection *section,</span></span><br><span class="line"><span class="params">                                  <span class="type">uint64_t</span> mfirst, <span class="type">uint64_t</span> mlast,</span></span><br><span class="line"><span class="params">                                  <span class="type">uint64_t</span> rfirst, <span class="type">uint64_t</span> rlast)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (;from &lt; to; ++from) &#123;</span><br><span class="line">        <span class="type">vhost_log_chunk_t</span> <span class="built_in">log</span>;</span><br><span class="line">        <span class="comment">/* We first check with non-atomic: much cheaper,</span></span><br><span class="line"><span class="comment">         * and we expect non-dirty to be the common case. */</span></span><br><span class="line">        <span class="keyword">if</span> (!*from) &#123;</span><br><span class="line">            addr += VHOST_LOG_CHUNK;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Data must be read atomically. We don&#x27;t really need barrier semantics</span></span><br><span class="line"><span class="comment">         * but it&#x27;s easier to use atomic_* than roll our own. */</span></span><br><span class="line">        <span class="built_in">log</span> = qatomic_xchg(from, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">log</span>) &#123;</span><br><span class="line">            <span class="type">int</span> bit = ctzl(<span class="built_in">log</span>);</span><br><span class="line">            hwaddr page_addr;</span><br><span class="line">            hwaddr section_offset;</span><br><span class="line">            hwaddr mr_offset;</span><br><span class="line">            page_addr = addr + bit * VHOST_LOG_PAGE;</span><br><span class="line">            <span class="comment">//增加卡侧内存迁移地址打印</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;vhost log_sync:%lx&quot;</span>, page_addr);</span><br><span class="line">            section_offset = page_addr - section-&gt;offset_within_address_space;</span><br><span class="line">            mr_offset = section_offset + section-&gt;offset_within_region;</span><br><span class="line">            memory_region_set_dirty(section-&gt;mr, mr_offset, VHOST_LOG_PAGE);</span><br><span class="line">            <span class="built_in">log</span> &amp;= ~(<span class="number">0x1</span>ull &lt;&lt; bit);</span><br><span class="line">        &#125;</span><br><span class="line">        addr += VHOST_LOG_CHUNK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vhost log_sync:35c63000</span><br><span class="line">vhost log_sync:35c64000</span><br><span class="line">vhost log_sync:35c6b000</span><br><span class="line">vhost log_sync:35c6c000</span><br><span class="line">vhost log_sync:35c73000</span><br><span class="line">vhost log_sync:35c74000</span><br><span class="line">vhost log_sync:35c7b000</span><br><span class="line">vhost log_sync:35c7c000</span><br><span class="line">vhost log_sync:35c83000</span><br><span class="line">vhost log_sync:35c84000</span><br><span class="line">vhost log_sync:35c8b000</span><br><span class="line">vhost log_sync:35c8c000</span><br><span class="line">vhost log_sync:35c93000</span><br><span class="line">vhost log_sync:35c94000</span><br><span class="line">vhost log_sync:43dfb000</span><br><span class="line">vhost log_sync:43dfc000</span><br></pre></td></tr></table></figure>

<h3 id="qemu-savevm-state-complete-precopy"><a href="#qemu-savevm-state-complete-precopy" class="headerlink" title="qemu_savevm_state_complete_precopy"></a>qemu_savevm_state_complete_precopy</h3><p>save_live_complete_precopy，这里以ram_save_complete为例<br>1、将前面同步给qemu的脏页，发送到目的端</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">qemu_savevm_state_complete_precopy_iterable</span><br><span class="line">    <span class="title function_">save_section_header</span><span class="params">(f, se, QEMU_VM_SECTION_END)</span>; <span class="comment">//设置section_type为QEMU_VM_SECTION_END</span></span><br><span class="line">    ram_save_complete</span><br><span class="line">        ram_find_and_save_block <span class="comment">//传输剩下的脏页</span></span><br><span class="line">            ram_save_host_page</span><br><span class="line">                ram_save_target_page</span><br><span class="line">                    ram_save_page</span><br><span class="line">                        save_normal_page</span><br></pre></td></tr></table></figure>

<p>2、将SaveStateEntry发送到目的端</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">qemu_savevm_state_complete_precopy</span><br><span class="line">    qemu_savevm_state_complete_precopy_non_iterable</span><br><span class="line">        <span class="title function_">save_section_header</span><span class="params">(f, se, QEMU_VM_SECTION_FULL)</span>; <span class="comment">//设置section_type为QEMU_VM_SECTION_FULL</span></span><br><span class="line">        vmstate_save                    ../migration/savevm.c:<span class="number">1000</span></span><br><span class="line">            vmstate_save_state          ../migration/vmstate.c:<span class="number">318</span></span><br><span class="line">                vmstate_save_state_v    ../migration/vmstate.c:<span class="number">382</span></span><br><span class="line">                    virtio_device_put   ../hw/virtio/virtio.c:<span class="number">2824</span></span><br><span class="line">                        virtio_save</span><br><span class="line">                            virtio_pci_save_config</span><br><span class="line">                            <span class="title function_">qemu_put_be16s</span><span class="params">(f, &amp;vdev-&gt;vq[i].last_avail_idx)</span>;</span><br><span class="line">                            virtio_pci_save_queue</span><br><span class="line">                            </span><br></pre></td></tr></table></figure>

<h2 id="downtime时间调优"><a href="#downtime时间调优" class="headerlink" title="downtime时间调优"></a>downtime时间调优</h2><p>qmp命令执行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">qmp_migrate</span><br><span class="line">    migrate_prepare</span><br><span class="line">        migrate_init</span><br></pre></td></tr></table></figure>
<p>初始化downtime、setup_time、total_time为0，获取start_time为当前时间</p>
<p><code>setup_time</code>：第一阶段脏页记录的耗时<br><code>total_time</code>：整个热迁移的耗时<br><code>transfer_time</code>：二三阶段耗时<br><code>downtime</code>：三阶段,vm停机耗时<br>migration_completion（downtime_start）到migration_calculate_complete（end_time）的耗时</p>
<p>通过VHOST_USER_GET_VRING_BASE与后端vdpa程序交互，优化VHOST_USER_GET_VRING_BASE的处理逻辑</p>
<p>、</p>
]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>qemu</tag>
      </tags>
  </entry>
  <entry>
    <title>dpdk-vdpa热迁移</title>
    <url>/2022/06/01/dpdk-vdpa%E7%83%AD%E8%BF%81%E7%A7%BB/</url>
    <content><![CDATA[<h2 id="设备状态保存"><a href="#设备状态保存" class="headerlink" title="设备状态保存"></a>设备状态保存</h2><p>这里需要了解哪些状态信息需要保存， 主要涉及两部分：</p>
<span id="more"></span>

<p>a)       设备启动过程中以及启动之后前端驱动对 BAR 空间的配置和修改。 Vdpa 框架中， virtio 设备配置空间的仿真由 qemu 实现，因此设备状态的保存和恢复由 qemu 实现，并在目的端 vmstats_load 之后， vm_start 流程中调用 vdpa 接口下发 load 后的配置信息，启动设备。</p>
<p>b)      队列当前的头尾指针信息 , virtio 设备涉及 avail head 和 used tail 。 Vdpa 中，队列的状态信息在停止设备过程中调用 vdpa 接口从设备侧读取。</p>
<h2 id="设备队列tx-rx-方向处理"><a href="#设备队列tx-rx-方向处理" class="headerlink" title="设备队列tx/rx 方向处理"></a>设备队列tx/rx 方向处理</h2><p>队列当前的头尾指针信息， virtio 设备侧涉及 avail head 和 used tail 的保存和恢复。</p>
<p>a)       发送方向状态保存 :</p>
<p>保存 used tail, 恢复的时候将 avail head 和 used tail 设置成保存的 used tail 。如果迁移前 used tail &lt; avail head ，迁移后目的端会重复发送部分数据（ used tail -&gt; avail head ）， TCP seq/ack保障可靠性， UDP 侧收到重复数据可能会有影响。</p>
<p>b)      接收方向状态保存：</p>
<p>保存 used tail, 恢复的时候将 avail head 和 used tail 设置成保存的 used tail ，迁移后目的端设备会从 avail 队列中下拉 used tail -&gt; avail tail 的数据。</p>
<p><img src="0734ac154de106c235477400aa1840b92837e72d71524dcaed70ec77f61f4f61.png" alt="图 1">  </p>
<h2 id="vdpa内核态"><a href="#vdpa内核态" class="headerlink" title="vdpa内核态"></a>vdpa内核态</h2><p><img src="53a448e19dd93a2e06b6b44fd832eda4266946e6ac59a0724c61dcc2121a47ac.png" alt="图 2">  </p>
<h2 id="legacy"><a href="#legacy" class="headerlink" title="legacy"></a>legacy</h2><p>1、源端设备 status协商至 0xb；<br>2、驱动给源端设备所有队列的 last_avail_idx寄存器写入值（按照流程，驱动不应写源端设备的last_avail_idx寄存器）；<br>3、驱动遍历此源设备的所有队列，置上 queue_msix_vector后 status协商至 0xf；<br>4、目的设备开始协商，协商 status至 0x3,表明驱动知晓如何驱动目的设备；<br>5、驱动写入源设备的脏页地址与大小寄存器：log_base_l、log_base_h、log_size_l以及 log_size_h；<br>6、驱动将 1写入源设备的 lm_ctrl寄存器，表明源设备使能热迁功能开始进行热迁，即 log start；<br>7、驱动读取源设备的 lm_ctrl，读到的值为 1，再将 2写入源设备的 lm_ctrl寄存器，表明源设备关停设备,即 dev stop；<br>8、驱动读取源设备每个队列的 last_avail_idx；<br>9、驱动写 0xb至目的设备的 status寄存器；<br>10、驱动从源端设备中读取每个队列的 last_avail_idx寄存器写至目的设备的对应的队列的last_avail_idx寄存器；<br>11、驱动遍历目的设备的所有队列，置上 queue_msix_vector后 status协商至 0xf；<br>12、驱动将 0写入源设备的 lm_ctrl寄存器，表明源设备 log stop；<br><strong>注</strong>：前三步为在 VDPA的框架下先协商成功源设备；第四步为驱动发现并知晓如何驱动目的设备；第五步为了后面同步脏页，先将脏页的地址以及大小通知后端 vdev；第六步为 log start，vdev通知 admin开启脏页（根据第四步驱动写入的脏页地址与大小信息）；第七步为关停源设备（主要为 disable队列，同步脏页，spdk、dpdk停止设备）；第八步为驱动获取源设备的last_avail_idx；第九步为驱动协商目的设备的特性完毕；第十步为驱动将源设备的 last_avail_idx设置到目的设备中；第十一步为目的设备协商成功（vdev在协商成功后初始化硬件队列）；第十二步为源设备关闭脏页。</p>
]]></content>
      <categories>
        <category>DPDK</category>
      </categories>
      <tags>
        <tag>DPDK</tag>
      </tags>
  </entry>
  <entry>
    <title>dpdk-vdpa收发包</title>
    <url>/2022/05/31/dpdk-vdpa%E6%94%B6%E5%8F%91%E5%8C%85/</url>
    <content><![CDATA[<h2 id="Tx"><a href="#Tx" class="headerlink" title="Tx"></a>Tx</h2><p>dpdk以设备为单位开启一个线程，监控guest kick事件</p>
<span id="more"></span>
<p><img src="73f28e420a8714d930aabc1f7f2a4ed29f1dd1808e69c999866e56bee39b842f.png" alt="图 1">  </p>
<h3 id="guest-发包调用"><a href="#guest-发包调用" class="headerlink" title="guest 发包调用"></a>guest 发包调用</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xmit_skb→</span><br><span class="line"></span><br><span class="line">virtqueue_add→</span><br><span class="line"></span><br><span class="line">virtqueue_kick-&gt;</span><br><span class="line"></span><br><span class="line">virtqueue_notify→</span><br><span class="line"></span><br><span class="line">vp_notify→</span><br><span class="line"></span><br><span class="line">iowrite16(vq-&gt;index, (void __iomem *)vq→priv);</span><br><span class="line"></span><br><span class="line">kvm <span class="built_in">exit</span>→</span><br><span class="line"></span><br><span class="line">kvm_cpu_exec→</span><br><span class="line"></span><br><span class="line">kvm_handle_io→</span><br></pre></td></tr></table></figure>

<h3 id="qemu-写deivice-notify-mr"><a href="#qemu-写deivice-notify-mr" class="headerlink" title="qemu 写deivice  notify mr"></a>qemu 写deivice  notify mr</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">virtio_ioport_write→</span><br><span class="line"></span><br><span class="line">virtio_queue_notify-&gt;</span><br><span class="line"></span><br><span class="line">event_notifier_set(&amp;vq-&gt;host_notifier);→</span><br></pre></td></tr></table></figure>

<h3 id="dpdk-notify-relay线程收到事件"><a href="#dpdk-notify-relay线程收到事件" class="headerlink" title="dpdk notify_relay线程收到事件"></a>dpdk notify_relay线程收到事件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">notify_relay→</span><br><span class="line"></span><br><span class="line">jmvd_notify_queue(hw, qid)-&gt;</span><br><span class="line"></span><br><span class="line">JMVD_IFCVF_WRITE_REG16(qid, hw-&gt;notify_addr[qid])-&gt;</span><br></pre></td></tr></table></figure>


<h2 id="Rx"><a href="#Rx" class="headerlink" title="Rx"></a>Rx</h2><p><img src="5547b98b9bddfb53de3c0f149e335d9c86e72aae456badf303c4bae0e5a9fd68.png" alt="图 2">  </p>
<p>当未使能msi-x使能</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.device写msix配置空间，触发中断</span><br><span class="line"></span><br><span class="line">2.vfio中预先绑定中断和callfd，触发callfd事件：</span><br><span class="line"></span><br><span class="line">3.qemu收到callfd事件</span><br><span class="line"></span><br><span class="line">virtio_queue_guest_notifier_read→</span><br><span class="line"></span><br><span class="line">virtio_irq→</span><br><span class="line"></span><br><span class="line">virtio_notify_vector(vq-&gt;vdev, vq→vector)→</span><br><span class="line"></span><br><span class="line">virtio_pci_notify→</span><br><span class="line"></span><br><span class="line">msix_notify(&amp;proxy-&gt;pci_dev, vector)→</span><br><span class="line"></span><br><span class="line">kvm entry-&gt;</span><br></pre></td></tr></table></figure>

<p>当使能msi-x使能，通过irqfd机制直接将中断通过KVM注入给虚拟机的vcpu。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">virtio_pci_set_guest_notifiers</span><br><span class="line">    --&gt; kvm_virtio_pci_vector_use</span><br><span class="line">    	-- &gt; kvm_virtio_pci_irqfd_use</span><br><span class="line">    		-- &gt; kvm_irqchip_add_irqfd_notifier_gsi</span><br><span class="line">    			-- &gt; kvm_irqchip_assign_irqfd</span><br></pre></td></tr></table></figure>

<h2 id="qemu设置中断"><a href="#qemu设置中断" class="headerlink" title="qemu设置中断"></a>qemu设置中断</h2><h3 id="blk"><a href="#blk" class="headerlink" title="blk"></a>blk</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kvm_vcpu_thread_fn</span><br><span class="line">    --&gt; memory_region_dispatch_write</span><br><span class="line">    	-- &gt; virtio_pci_common_write</span><br><span class="line">    		-- &gt; vhost_user_blk_set_status</span><br><span class="line">    			-- &gt; vhost_blk_common_start</span><br><span class="line">                            	-- &gt; virtio_pci_set_guest_notifiers</span><br></pre></td></tr></table></figure>

<h3 id="net"><a href="#net" class="headerlink" title="net"></a>net</h3><p>```bash<br>kvm_vcpu_thread_fn<br>    –&gt; memory_region_dispatch_write<br>        – &gt; virtio_pci_common_write<br>            – &gt; virtio_net_set_status<br>                – &gt; vhost_net_start<br>                                – &gt; virtio_pci_set_guest_notifiers</p>
]]></content>
      <categories>
        <category>DPDK</category>
      </categories>
      <tags>
        <tag>DPDK</tag>
      </tags>
  </entry>
  <entry>
    <title>dpdk-vdpa设备加载</title>
    <url>/2022/05/30/dpdk-vdpa%E8%AE%BE%E5%A4%87%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<h2 id="main"><a href="#main" class="headerlink" title="main"></a>main</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rte_eal_init-&gt;</span><br><span class="line">start_vdpa-&gt;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="rte-eal-init"><a href="#rte-eal-init" class="headerlink" title="rte_eal_init"></a>rte_eal_init</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rte_eal_init-&gt;</span><br><span class="line"></span><br><span class="line">    rte_bus_probe-&gt;</span><br><span class="line"></span><br><span class="line">        rte_vdev_bus.probe-&gt;</span><br><span class="line"></span><br><span class="line">            rte_vdev_init-&gt;</span><br><span class="line"></span><br><span class="line">                vdev_probe_all_drivers-&gt;</span><br><span class="line"></span><br><span class="line">                        ifcvf_pci_probe-&gt;</span><br><span class="line"></span><br><span class="line">                           1) ifcvf_vfio_setup-&gt;</span><br><span class="line">                                rte_vfio_container_create</span><br><span class="line">                                rte_vfio_container_group_bind</span><br><span class="line">                                rte_pci_map_device</span><br><span class="line"></span><br><span class="line">                          2)  ifcvf_init_hw -&gt; <span class="comment">#初始化hw信息</span></span><br></pre></td></tr></table></figure>

<h2 id="start-vdpa"><a href="#start-vdpa" class="headerlink" title="start_vdpa"></a>start_vdpa</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">start_vdpa-&gt;</span><br><span class="line"></span><br><span class="line">    rte_vhost_driver_register-&gt;</span><br><span class="line"></span><br><span class="line">    rte_vhost_driver_attach_vdpa_device -&gt;</span><br><span class="line">    </span><br><span class="line">    rte_vhost_driver_start-&gt;</span><br><span class="line">    </span><br><span class="line">        1) rte_vhost_driver_start <span class="comment">#第一次调用会创建线程处理链接请求最多1024，fdset_event_dispatch</span></span><br><span class="line">        vhost_user_start_server-&gt;</span><br><span class="line">            or</span><br><span class="line">        vhost_user_start_client-&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">1）dpdk 为server</span><br><span class="line"></span><br><span class="line">vhost_user_start_server -&gt;</span><br><span class="line"></span><br><span class="line">       vhost_user_server_new_connection -&gt;</span><br><span class="line"></span><br><span class="line">              fdset_add (vhost_user_read_cb)-&gt;</span><br><span class="line"></span><br><span class="line">                     vhost_user_read_cb --&gt;</span><br><span class="line"></span><br><span class="line">                            vhost_user_msg_handler <span class="comment">#消息处理</span></span><br><span class="line"></span><br><span class="line">2）dpdk 为client</span><br><span class="line"></span><br><span class="line">vhost_user_start_client -&gt;</span><br><span class="line"></span><br><span class="line">       vhost_user_connect_nonblock-&gt;</span><br><span class="line"></span><br><span class="line">              vhost_user_add_connection -&gt;</span><br><span class="line"></span><br><span class="line">                     fdset_add (vhost_user_read_cb)-&gt;</span><br><span class="line"></span><br><span class="line">                            vhost_user_read_cb -&gt;</span><br><span class="line"></span><br><span class="line">                                   vhost_user_msg_handler <span class="comment">#消息处理</span></span><br></pre></td></tr></table></figure>
<p>处理函数如下（VHOST_MESSAGE_HANDLERS）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> VHOST_MESSAGE_HANDLERS \</span></span><br><span class="line"><span class="meta">VHOST_MESSAGE_HANDLER(VHOST_USER_NONE, NULL, false) \</span></span><br><span class="line"><span class="meta">VHOST_MESSAGE_HANDLER(VHOST_USER_GET_FEATURES, vhost_user_get_features, false) \</span></span><br><span class="line"><span class="meta">VHOST_MESSAGE_HANDLER(VHOST_USER_SET_FEATURES, vhost_user_set_features, false) \</span></span><br><span class="line"><span class="meta">VHOST_MESSAGE_HANDLER(VHOST_USER_SET_OWNER, vhost_user_set_owner, false) \</span></span><br><span class="line"><span class="meta">VHOST_MESSAGE_HANDLER(VHOST_USER_RESET_OWNER, vhost_user_reset_owner, false) \</span></span><br><span class="line"><span class="meta">VHOST_MESSAGE_HANDLER(VHOST_USER_SET_MEM_TABLE, vhost_user_set_mem_table, true) \</span></span><br><span class="line"><span class="meta">VHOST_MESSAGE_HANDLER(VHOST_USER_SET_LOG_BASE, vhost_user_set_log_base, true) \</span></span><br><span class="line"><span class="meta">VHOST_MESSAGE_HANDLER(VHOST_USER_SET_LOG_FD, vhost_user_set_log_fd, true) \</span></span><br><span class="line"><span class="meta">VHOST_MESSAGE_HANDLER(VHOST_USER_SET_VRING_NUM, vhost_user_set_vring_num, false) \</span></span><br><span class="line"><span class="meta">VHOST_MESSAGE_HANDLER(VHOST_USER_SET_VRING_ADDR, vhost_user_set_vring_addr, false) \</span></span><br><span class="line"><span class="meta">VHOST_MESSAGE_HANDLER(VHOST_USER_SET_VRING_BASE, vhost_user_set_vring_base, false) \</span></span><br><span class="line"><span class="meta">VHOST_MESSAGE_HANDLER(VHOST_USER_GET_VRING_BASE, vhost_user_get_vring_base, false) \</span></span><br><span class="line"><span class="meta">VHOST_MESSAGE_HANDLER(VHOST_USER_SET_VRING_KICK, vhost_user_set_vring_kick, true) \</span></span><br><span class="line"><span class="meta">VHOST_MESSAGE_HANDLER(VHOST_USER_SET_VRING_CALL, vhost_user_set_vring_call, true) \</span></span><br><span class="line"><span class="meta">VHOST_MESSAGE_HANDLER(VHOST_USER_SET_VRING_ERR, vhost_user_set_vring_err, true) \</span></span><br><span class="line"><span class="meta">VHOST_MESSAGE_HANDLER(VHOST_USER_GET_PROTOCOL_FEATURES, vhost_user_get_protocol_features, false) \</span></span><br><span class="line"><span class="meta">VHOST_MESSAGE_HANDLER(VHOST_USER_SET_PROTOCOL_FEATURES, vhost_user_set_protocol_features, false) \</span></span><br><span class="line"><span class="meta">VHOST_MESSAGE_HANDLER(VHOST_USER_GET_QUEUE_NUM, vhost_user_get_queue_num, false) \</span></span><br><span class="line"><span class="meta">VHOST_MESSAGE_HANDLER(VHOST_USER_SET_VRING_ENABLE, vhost_user_set_vring_enable, false) \</span></span><br><span class="line"><span class="meta">VHOST_MESSAGE_HANDLER(VHOST_USER_SEND_RARP, vhost_user_send_rarp, false) \</span></span><br><span class="line"><span class="meta">VHOST_MESSAGE_HANDLER(VHOST_USER_NET_SET_MTU, vhost_user_net_set_mtu, false) \</span></span><br><span class="line"><span class="meta">VHOST_MESSAGE_HANDLER(VHOST_USER_SET_SLAVE_REQ_FD, vhost_user_set_req_fd, true) \</span></span><br><span class="line"><span class="meta">VHOST_MESSAGE_HANDLER(VHOST_USER_IOTLB_MSG, vhost_user_iotlb_msg, false) \</span></span><br><span class="line"><span class="meta">VHOST_MESSAGE_HANDLER(VHOST_USER_GET_CONFIG, vhost_user_get_config, false) \</span></span><br><span class="line"><span class="meta">VHOST_MESSAGE_HANDLER(VHOST_USER_SET_CONFIG, vhost_user_set_config, false) \</span></span><br><span class="line"><span class="meta">VHOST_MESSAGE_HANDLER(VHOST_USER_POSTCOPY_ADVISE, vhost_user_set_postcopy_advise, false) \</span></span><br><span class="line"><span class="meta">VHOST_MESSAGE_HANDLER(VHOST_USER_POSTCOPY_LISTEN, vhost_user_set_postcopy_listen, false) \</span></span><br><span class="line"><span class="meta">VHOST_MESSAGE_HANDLER(VHOST_USER_POSTCOPY_END, vhost_user_postcopy_end, false) \</span></span><br><span class="line"><span class="meta">VHOST_MESSAGE_HANDLER(VHOST_USER_GET_INFLIGHT_FD, vhost_user_get_inflight_fd, false) \</span></span><br><span class="line"><span class="meta">VHOST_MESSAGE_HANDLER(VHOST_USER_SET_INFLIGHT_FD, vhost_user_set_inflight_fd, true) \</span></span><br><span class="line"><span class="meta">VHOST_MESSAGE_HANDLER(VHOST_USER_SET_STATUS, vhost_user_set_status, false) \</span></span><br><span class="line"><span class="meta">VHOST_MESSAGE_HANDLER(VHOST_USER_GET_STATUS, vhost_user_get_status, false)</span></span><br></pre></td></tr></table></figure>

<h2 id="vdpa设备提供vdpa-ops"><a href="#vdpa设备提供vdpa-ops" class="headerlink" title="vdpa设备提供vdpa ops"></a>vdpa设备提供vdpa ops</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * vdpa device operations</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rte_vdpa_dev_ops</span> &#123;</span></span><br><span class="line">	<span class="comment">/** Get capabilities of this device (Mandatory) */</span></span><br><span class="line">	<span class="type">int</span> (*get_queue_num)(<span class="keyword">struct</span> rte_vdpa_device *dev, <span class="type">uint32_t</span> *queue_num);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Get supported features of this device (Mandatory) */</span></span><br><span class="line">	<span class="type">int</span> (*get_features)(<span class="keyword">struct</span> rte_vdpa_device *dev, <span class="type">uint64_t</span> *features);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Get supported protocol features of this device (Mandatory) */</span></span><br><span class="line">	<span class="type">int</span> (*get_protocol_features)(<span class="keyword">struct</span> rte_vdpa_device *dev,</span><br><span class="line">			<span class="type">uint64_t</span> *protocol_features);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Driver configure the device (Mandatory) */</span></span><br><span class="line">	<span class="type">int</span> (*dev_conf)(<span class="type">int</span> vid);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Driver close the device (Mandatory) */</span></span><br><span class="line">	<span class="type">int</span> (*dev_close)(<span class="type">int</span> vid);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Connection closed, clean up resources */</span></span><br><span class="line">	<span class="type">int</span> (*dev_cleanup)(<span class="type">int</span> vid);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Enable/disable this vring (Mandatory) */</span></span><br><span class="line">	<span class="type">int</span> (*set_vring_state)(<span class="type">int</span> vid, <span class="type">int</span> vring, <span class="type">int</span> state);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Set features when changed (Mandatory) */</span></span><br><span class="line">	<span class="type">int</span> (*set_features)(<span class="type">int</span> vid);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Destination operations when migration done */</span></span><br><span class="line">	<span class="type">int</span> (*migration_done)(<span class="type">int</span> vid);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Get the vfio group fd */</span></span><br><span class="line">	<span class="type">int</span> (*get_vfio_group_fd)(<span class="type">int</span> vid);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Get the vfio device fd */</span></span><br><span class="line">	<span class="type">int</span> (*get_vfio_device_fd)(<span class="type">int</span> vid);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Get the notify area info of the queue */</span></span><br><span class="line">	<span class="type">int</span> (*get_notify_area)(<span class="type">int</span> vid, <span class="type">int</span> qid,</span><br><span class="line">			<span class="type">uint64_t</span> *offset, <span class="type">uint64_t</span> *size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Get statistics name */</span></span><br><span class="line">	<span class="type">int</span> (*get_stats_names)(<span class="keyword">struct</span> rte_vdpa_device *dev,</span><br><span class="line">			<span class="keyword">struct</span> rte_vdpa_stat_name *stats_names,</span><br><span class="line">			<span class="type">unsigned</span> <span class="type">int</span> size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Get statistics of the queue */</span></span><br><span class="line">	<span class="type">int</span> (*get_stats)(<span class="keyword">struct</span> rte_vdpa_device *dev, <span class="type">int</span> qid,</span><br><span class="line">			<span class="keyword">struct</span> rte_vdpa_stat *stats, <span class="type">unsigned</span> <span class="type">int</span> n);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Reset statistics of the queue */</span></span><br><span class="line">	<span class="type">int</span> (*reset_stats)(<span class="keyword">struct</span> rte_vdpa_device *dev, <span class="type">int</span> qid);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Get the device configuration space */</span></span><br><span class="line">	<span class="type">int</span> (*get_config)(<span class="type">int</span> vid, <span class="type">uint8_t</span> *config, <span class="type">uint32_t</span> size);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** Set the device configuration space */</span></span><br><span class="line">	<span class="type">int</span> (*set_config)(<span class="type">int</span> vid, <span class="type">uint8_t</span> *config, <span class="type">uint32_t</span> offset,</span><br><span class="line">		      <span class="type">uint32_t</span> size, <span class="type">uint32_t</span> flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/** get device type: net device, blk device... */</span></span><br><span class="line">	<span class="type">int</span> (*get_dev_type)(<span class="keyword">struct</span> rte_vdpa_device *dev, <span class="type">uint32_t</span> *type);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="ifcvf-get-vdpa-features-如何获取feature？"><a href="#ifcvf-get-vdpa-features-如何获取feature？" class="headerlink" title="ifcvf_get_vdpa_features 如何获取feature？"></a>ifcvf_get_vdpa_features 如何获取feature？</h2><p>ifcvf_pci_probe<br>        -&gt; ifcvf_get_features(&amp;internal-&gt;hw); //发送tlp请求回去feature<br>        -&gt;缓存freature到vdpa_dev, ifcvf_get_vdpa_features 通过缓存获取</p>
<p>ifcvf_get_features<br><img src="d6049c17962cb23c7657b98ac6745a8bbcbcdf6b629b73341334f1f828462fdf.png" alt="图 1">  </p>
<p>这样通过vhost_user 将vdpa相关的操作关联起来，需要提供的操作有：(ifcvf_net_ops)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">rte_vdpa_dev_ops</span> <span class="title">ifcvf_net_ops</span> =</span> &#123;</span><br><span class="line">	.get_queue_num = ifcvf_get_queue_num,</span><br><span class="line">	.get_features = ifcvf_get_vdpa_features,</span><br><span class="line">	.get_protocol_features = ifcvf_get_protocol_features,</span><br><span class="line">	.dev_conf = ifcvf_dev_config,</span><br><span class="line">	.dev_close = ifcvf_dev_close,</span><br><span class="line">	.set_vring_state = ifcvf_set_vring_state,</span><br><span class="line">	.set_features = ifcvf_set_features,</span><br><span class="line">	.migration_done = <span class="literal">NULL</span>,</span><br><span class="line">	.get_vfio_group_fd = ifcvf_get_vfio_group_fd,</span><br><span class="line">	.get_vfio_device_fd = ifcvf_get_vfio_device_fd,</span><br><span class="line">	.get_notify_area = ifcvf_get_notify_area,</span><br><span class="line">	.get_dev_type = ifcvf_get_device_type,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>DPDK</category>
      </categories>
      <tags>
        <tag>DPDK</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode C/C++插件失效</title>
    <url>/2022/03/08/vscode-C-C-%E6%89%A9%E5%B1%95%E5%A4%B1%E6%95%88/</url>
    <content><![CDATA[<h2 id="故障描述"><a href="#故障描述" class="headerlink" title="故障描述"></a>故障描述</h2><ul>
<li><p>打开项目工程后，过一段时间发现c/c++跳转失效</p>
</li>
<li><p>智能感知系统无法补全</p>
<span id="more"></span>
<p><img src="519c09334a7130005ac97e63cdabaf9c19ba78d30a0f27ca94b9996163e6c766.png" alt="图 2">  </p>
</li>
<li><p>并且，大纲无法加载符号<br><img src="da3040ce2169ddc0a1346799e3e1facd423444da76f7dbea51e27ca9dfbbe7bf.png" alt="图 3">  </p>
</li>
</ul>
<h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><ol>
<li>网上搜索常见的C/C++插件失效的解决办法，发现都与设置的无关</li>
<li>终端发现cpptools的cpu利用率飙高，此时可初步判定为项目工程导致符号搜索循环引用了<br><img src="ff1e27ff7a065a725a164291088616be25e5896c385e74c612d9752da83b90a7.png" alt="图 4">  </li>
<li>排查发现项目中的一个文件目录比较大，将其删除后，发现C/C++插件可以继续运作，并且cpptools不会再cpu冲高<br><img src="6ed60181060f1615ed24a7ae6effdcb19a2e4f33cb2d7a9bf19dd88d309d17b6.png" alt="图 9">  </li>
</ol>
<h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><ul>
<li>由于编译依赖该文件目录，删除后会影响编译效率；</li>
<li>通过设置exclude将C/C++插件不再搜索该文件目录，修改如下：</li>
<li>文件-》首选项-》设置，搜索exclude，找到C_Cpp.files.exclude<br><img src="7d723ba1046f38ce1447de4b059ac2e65085ee66c1b440dd4d0984b9c1a4109c.png" alt="图 6">  </li>
<li>添加文件目录名至exclude配置中<br><img src="fb11eed86c18bcb5fe46c797e0e15411e3ee5c6adbb4a6e9cd41565a26218c7d.png" alt="图 8">  </li>
<li>重新加载vscode后，该C/C++插件失效问题得以解决</li>
</ul>
]]></content>
      <categories>
        <category>VSCODE</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>importlib模块</title>
    <url>/2021/07/28/importlib%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<blockquote>
<p>目的： importlib 模块公开了 Python 中 import 语句的实现</p>
</blockquote>
<span id="more"></span>
<p><code>importlib</code> 模块包含实现 Python 导入机制的函数，用于在包和模块中加载代码。 它是动态导入模块的一个访问点，在编写代码时需要导入的模块名称未知的情况下很有用（例如，对于应用程序的插件或扩展）。</p>
<h2 id="示例包"><a href="#示例包" class="headerlink" title="示例包"></a>示例包</h2><p>本节的示例使用了一个包<br>称为 <code>example</code> ，包含有  <code>__init__.py</code> 。</p>
<p><code>example/__init__.py</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(&#x27;Importing example package&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个包还包含 <code>submodule.py</code> 。</p>
<p>`example/submodule.py``</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(&#x27;Importing submodule&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>导入包或模块时，请注意示例中 <code>print()</code> 调用输出的文本。</p>
<h2 id="模块类型"><a href="#模块类型" class="headerlink" title="模块类型"></a>模块类型</h2><p>Python 支持多种样式的模块。 打开模块并将其添加到命名空间时，每个模块都需要自己处理，并且格式的支持因平台而异。 例如，在 Microsoft Windows 下，共享库是从扩展名为 <code>.dll</code> 或 <code>.pyd</code> 的文件加载而不是 <code>.so</code> 。 当使用解释器的调试版本而不是正常版本构建时，C 模块的扩展也可能会发生变化，因为它们也可以进行包含的调试信息编译。如果 C 扩展库或其他模块未按预期加载，请使用 <code>importlib.machinery</code> 中定义的常量来查找当前平台支持的类型以及加载它们的参数。</p>
<p><em>importlib_suffixes.py</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import importlib.machinery</span><br><span class="line"></span><br><span class="line">SUFFIXES = [</span><br><span class="line">    (&#x27;Source:&#x27;, importlib.machinery.SOURCE_SUFFIXES),</span><br><span class="line">    (&#x27;Debug:&#x27;,</span><br><span class="line">     importlib.machinery.DEBUG_BYTECODE_SUFFIXES),</span><br><span class="line">    (&#x27;Optimized:&#x27;,</span><br><span class="line">     importlib.machinery.OPTIMIZED_BYTECODE_SUFFIXES),</span><br><span class="line">    (&#x27;Bytecode:&#x27;, importlib.machinery.BYTECODE_SUFFIXES),</span><br><span class="line">    (&#x27;Extension:&#x27;, importlib.machinery.EXTENSION_SUFFIXES),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    tmpl = &#x27;&#123;:&lt;10&#125;  &#123;&#125;&#x27;</span><br><span class="line">    for name, value in SUFFIXES:</span><br><span class="line">        print(tmpl.format(name, value))</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    main()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>返回值是包含文件扩展名的元组序列，用于打开包含模块的文件的模式，以及来自模块中定义的常量的类型代码。 此表是不完整的，因为某些可导入的模块或包类型不对应到单个文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python3 importlib_suffixes.py</span><br><span class="line"></span><br><span class="line">Source:     [&#x27;.py&#x27;]</span><br><span class="line">Debug:      [&#x27;.pyc&#x27;]</span><br><span class="line">Optimized:  [&#x27;.pyc&#x27;]</span><br><span class="line">Bytecode:   [&#x27;.pyc&#x27;]</span><br><span class="line">Extension:  [&#x27;.cpython-36m-darwin.so&#x27;, &#x27;.abi3.so&#x27;, &#x27;.so&#x27;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h2><p><code>importlib</code> 中的高级 API 使得在给定绝对或相对名称的情况下导入模块变得简单。 使用相对模块名称时，将包含模块的包指定为单独的参数。</p>
<p><em>importlib_import_module.py</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import importlib</span><br><span class="line"></span><br><span class="line">m1 = importlib.import_module(&#x27;example.submodule&#x27;)</span><br><span class="line">print(m1)</span><br><span class="line"></span><br><span class="line">m2 = importlib.import_module(&#x27;.submodule&#x27;, package=&#x27;example&#x27;)</span><br><span class="line">print(m2)</span><br><span class="line"></span><br><span class="line">print(m1 is m2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>import_module()</code> 的返回值是导入创建的模块对象。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python3 importlib_import_module.py</span><br><span class="line"></span><br><span class="line">Importing example package</span><br><span class="line">Importing submodule</span><br><span class="line">&lt;module &#x27;example.submodule&#x27; from &#x27;.../example/submodule.py&#x27;&gt;</span><br><span class="line">&lt;module &#x27;example.submodule&#x27; from &#x27;.../example/submodule.py&#x27;&gt;</span><br><span class="line">True</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果模块不能被导入 <code>import_module()</code> 将引发 <code>ImportError</code> 错误。</p>
<p><em>importlib_import_module_error.py</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import importlib</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    importlib.import_module(&#x27;example.nosuchmodule&#x27;)</span><br><span class="line">except ImportError as err:</span><br><span class="line">    print(&#x27;Error:&#x27;, err)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>错误消息包含缺少的模块的名称。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python3 importlib_import_module_error.py</span><br><span class="line"></span><br><span class="line">Importing example package</span><br><span class="line">Error: No module named &#x27;example.nosuchmodule&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>要重新载入已有模块，使用 <code>reload()</code> 。</p>
<p><em>importlib_reload.py</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import importlib</span><br><span class="line"></span><br><span class="line">m1 = importlib.import_module(&#x27;example.submodule&#x27;)</span><br><span class="line">print(m1)</span><br><span class="line"></span><br><span class="line">m2 = importlib.reload(m1)</span><br><span class="line">print(m1 is m2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>reload()</code> 的返回值是新模块。 根据使用的加载器类型不同，它可能是相同的模块实例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python3 importlib_reload.py</span><br><span class="line"></span><br><span class="line">Importing example package</span><br><span class="line">Importing submodule</span><br><span class="line">&lt;module &#x27;example.submodule&#x27; from &#x27;.../example/submodule.py&#x27;&gt;</span><br><span class="line">Importing submodule</span><br><span class="line">True</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="加载器"><a href="#加载器" class="headerlink" title="加载器"></a>加载器</h2><p><code>importlib</code> 中的低级 API 提供对 loader 对象的访问，如<a href="https://pymotw.com/3/sys/imports.html#sys-imports">模块和导入</a>中 <code>sys</code> 模块一节所述。 要获取模块的加载器，请使用 <code>find_loader()</code> 。 然后获取模块，使用 loader 的 <code>load_module()</code> 方法。</p>
<p><em>importlib_find_loader.py</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import importlib</span><br><span class="line"></span><br><span class="line">loader = importlib.find_loader(&#x27;example&#x27;)</span><br><span class="line">print(&#x27;Loader:&#x27;, loader)</span><br><span class="line"></span><br><span class="line">m = loader.load_module()</span><br><span class="line">print(&#x27;Module:&#x27;, m)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个示例加载了 <code>example</code> 包的顶层。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python3 importlib_find_loader.py</span><br><span class="line"></span><br><span class="line">Loader: &lt;_frozen_importlib_external.SourceFileLoader object at</span><br><span class="line">0x101fe1828&gt;</span><br><span class="line">Importing example package</span><br><span class="line">Module: &lt;module &#x27;example&#x27; from &#x27;.../example/__init__.py&#x27;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>包中的子模块需要使用包中的路径单独加载。 在下面的示例中，首先加载包，然后将其路径传递给 <code>find_loader()</code> 以创建能够加载子模块的加载器。</p>
<p><em>importlib_submodule.py</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import importlib</span><br><span class="line"></span><br><span class="line">pkg_loader = importlib.find_loader(&#x27;example&#x27;)</span><br><span class="line">pkg = pkg_loader.load_module()</span><br><span class="line"></span><br><span class="line">loader = importlib.find_loader(&#x27;submodule&#x27;, pkg.__path__)</span><br><span class="line">print(&#x27;Loader:&#x27;, loader)</span><br><span class="line"></span><br><span class="line">m = loader.load_module()</span><br><span class="line">print(&#x27;Module:&#x27;, m)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>与 <code>import_module()</code> 不同，子模块的名称应该没有任何相对路径前缀，因为加载器已经受到包路径的约束。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ python3 importlib_submodule.py</span><br><span class="line"></span><br><span class="line">Importing example package</span><br><span class="line">Loader: &lt;_frozen_importlib_external.SourceFileLoader object at</span><br><span class="line">0x101fe1f28&gt;</span><br><span class="line">Importing submodule</span><br><span class="line">Module: &lt;module &#x27;submodule&#x27; from &#x27;.../example/submodule.py&#x27;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<h4 id="参见"><a href="#参见" class="headerlink" title="参见"></a>参见</h4><ul>
<li>  <a href="https://docs.python.org/3.6/library/importlib.html">importlib 标准库文档</a></li>
<li>  <a href="https://pymotw.com/3/sys/imports.html#sys-imports">模块和导入</a> – 导入钩子，模块搜索路径以及 <code>sys</code> 模块中的其他相关机器。</li>
<li>  <a href="https://pymotw.com/3/inspect/index.html#module-inspect" title="inspect: Inspect live objects"><code>inspect</code></a> – 以编程方式从模块加载信息。</li>
<li>  <a href="https://www.python.org/dev/peps/pep-0302">PEP 302</a> – 新的 import 钩子。</li>
<li>  <a href="https://www.python.org/dev/peps/pep-0369">PEP 369</a> – 过去的 import 钩子。</li>
<li>  <a href="https://www.python.org/dev/peps/pep-0488">PEP 488</a> – 消除PYO文件。</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python super函数</title>
    <url>/2021/07/27/python-super%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h3 id="super函数简介"><a href="#super函数简介" class="headerlink" title="super函数简介"></a>super函数简介</h3><p>在类的继承中，<strong>如果重定义某个方法，该方法会覆盖父类的同名方法</strong>，但有时，我们希望能同时实现父类的功能，这时，我们就需要调用父类的方法了。<br>调用父类同名方法有两种方式：  </p>
<blockquote>
<p>调用未绑定的父类方法<br>使用super函数来调用</p>
</blockquote>
<span id="more"></span>


<p>先来说下第一种方式：调用未绑定的父类方法。<br><strong>演示：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Base(object):</span><br><span class="line">    def greet(self):</span><br><span class="line">        print(&#x27;hi,I am Base&#x27;)</span><br><span class="line"></span><br><span class="line">class A(Base):</span><br><span class="line">    def greet(self):</span><br><span class="line">        Base.greet(self)  #通过父类Base直接调用greet方法，并把self作为参数</span><br><span class="line">        print(&#x27;hi,I am A&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">a=A()</span><br><span class="line"></span><br><span class="line">a.greet()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\python36\python.exe E:/demo/testPyQt.py</span><br><span class="line">hi,I am Base</span><br><span class="line">hi,I am A</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这种方式简单用还可以，如果在多重继承中就会有问题。<br><strong>演示：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Base(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;enter Base&quot;)</span><br><span class="line">        print(&quot;leave Base&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class A(Base):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;enter A&quot;)</span><br><span class="line">        Base.__init__(self) #调用父类的构造函数进行初始化</span><br><span class="line">        print(&quot;leave A&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class B(Base):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;enter B&quot;)</span><br><span class="line">        Base.__init__(self) #调用父类的构造函数进行初始化</span><br><span class="line">        print(&quot;leave B&quot;)</span><br><span class="line"></span><br><span class="line">class C(A,B):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;enter C&quot;)</span><br><span class="line">        A.__init__(self) #调用父类A的构造函数进行初始化</span><br><span class="line">        B.__init__(self) #调用父类B的构造函数进行初始化</span><br><span class="line">        print(&quot;leave C&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c=C()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\python36\python.exe E:/demo/testPyQt.py</span><br><span class="line">enter C</span><br><span class="line">enter A</span><br><span class="line">enter Base</span><br><span class="line">leave Base</span><br><span class="line">leave A</span><br><span class="line">enter B</span><br><span class="line">enter Base</span><br><span class="line">leave Base</span><br><span class="line">leave B</span><br><span class="line">leave C</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从上面的运行结果可以看出，基类Base的构造函数被调用了两次，这是有问题的，正常的应该是：A的构造函数调用一次，B的构造函数调用一次，基类Base的构造函数调用一次。<br>那么这个问题能不能解决呢，可以的，下面介绍super。<br><strong>演示：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Animal(object):</span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    def greet(self):</span><br><span class="line">        print(&#x27;Hello, I am %s.&#x27; % self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Dog(Animal):</span><br><span class="line">    def greet(self):</span><br><span class="line">        super(Dog, self).greet()  #调用父类Animal的greet方法</span><br><span class="line">        print(&#x27;WangWang...&#x27;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d=Dog(&quot;xiaohuang&quot;)</span><br><span class="line"></span><br><span class="line">d.greet()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上面，Animal 是父类，Dog 是子类，我们在 Dog 类重定义了 greet 方法，为了能同时实现父类的功能，我们又调用了父类的方法，运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\python36\python.exe E:/demo/testPyQt.py</span><br><span class="line">Hello, I am xiaohuang.</span><br><span class="line">WangWang...</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>super 的一个最常见用法可以说是<strong>在子类中调用父类的初始化方法了</strong>。<br><strong>演示：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Base(object):</span><br><span class="line">    def __init__(self, a, b):</span><br><span class="line">        self.a = a</span><br><span class="line">        self.b = b</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class A(Base):</span><br><span class="line">    def __init__(self, a, b, c):</span><br><span class="line">        super(A, self).__init__(a, b)  # Python3 可使用 super().__init__(a, b)</span><br><span class="line">        self.c = c</span><br><span class="line"></span><br><span class="line">a=A(100,200,300)</span><br><span class="line"></span><br><span class="line">print(&quot;a=%d, b=%d, c=%d&quot; % (a.a,a.b,a.c))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\python36\python.exe E:/demo/testPyQt.py</span><br><span class="line">a=100, b=200, c=300</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="深入super"><a href="#深入super" class="headerlink" title="深入super()"></a>深入super()</h3><p>看了上面的使用，你可能会觉得 super 的使用很简单，无非就是获取了父类，并调用父类的方法。其实，在上面的情况下，super 获得的类刚好是父类，但在其他情况就不一定了，super 其实和父类没有实质性的关联。<br>让我们看一个稍微复杂的例子，涉及到多重继承，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Base(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;enter Base&quot;)</span><br><span class="line">        print(&quot;leave Base&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class A(Base):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;enter A&quot;)</span><br><span class="line">        super(A,self).__init__()</span><br><span class="line">        print(&quot;leave A&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class B(Base):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;enter B&quot;)</span><br><span class="line">        super(B,self).__init__()</span><br><span class="line">        print(&quot;leave B&quot;)</span><br><span class="line"></span><br><span class="line">class C(A,B):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;enter C&quot;)</span><br><span class="line">        super(C,self).__init__()</span><br><span class="line">        print(&quot;leave C&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c=C()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\python36\python.exe E:/demo/testPyQt.py</span><br><span class="line">enter C</span><br><span class="line">enter A</span><br><span class="line">enter B</span><br><span class="line">enter Base</span><br><span class="line">leave Base</span><br><span class="line">leave B</span><br><span class="line">leave A</span><br><span class="line">leave C</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>OK，这个运行结果是正常的，类C继承自A,B，而A和B又分别继承类Base，每一个类的构造函数分别被调用了一次。</p>
<p>如果你认为 super 代表『调用父类的方法』，那你很可能会疑惑为什么 enter A 的下一句不是 enter Base 而是 enter B。原因是，super 和父类没有实质性的关联，现在让我们搞清 super 是怎么运作的。</p>
<h3 id="MRO列表"><a href="#MRO列表" class="headerlink" title="MRO列表"></a>MRO列表</h3><p>事实上，对于你定义的每一个类，Python 会计算出一个方法解析顺序（Method Resolution Order, MRO）列表，它代表了类继承的顺序，我们可以使用下面的方式获得某个类的 MRO 列表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">print(C.mro())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.Base&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个列表真实的列出了类C的继承顺序。C-&gt;A-&gt;B-&gt;Base-&gt;object。在方法调用时，是按照这个顺序查找的。<br>那这个 MRO 列表的顺序是怎么定的呢，它是通过一个 C3 线性化算法来实现的，这里我们就不去深究这个算法了，感兴趣的读者可以自己去了解一下，总的来说，一个类的 MRO 列表就是合并所有父类的 MRO 列表，并遵循以下三条原则：</p>
<ul>
<li>  子类永远在父类前面</li>
<li>  如果有多个父类，会根据它们在列表中的顺序被检查</li>
<li>  如果对下一个类存在两个合法的选择，选择第一个父类</li>
</ul>
<h3 id="super-原理"><a href="#super-原理" class="headerlink" title="super 原理"></a>super 原理</h3><p>super 的工作原理如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def super(cls, inst):</span><br><span class="line">    mro = inst.__class__.mro()</span><br><span class="line">    return mro[mro.index(cls) + 1]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，cls 代表类，inst 代表实例，上面的代码做了两件事：</p>
<ul>
<li>  获取 inst 的 MRO 列表</li>
<li>  查找 cls 在当前 MRO 列表中的 index, 并返回它的下一个类，即 mro[index + 1]</li>
</ul>
<p>当你使用 super(cls, inst) 时，Python 会在 inst 的 MRO 列表上搜索 cls 的下一个类。<br>现在，让我们回到前面的例子。</p>
<p>首先看类 C 的 <strong>init</strong> 方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">super(C,self).__init__()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里的 self 是当前 C 的实例，self.<strong>class</strong>.mro() 结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.Base&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到，C 的下一个类是 A，于是，跳到了 A 的 <strong>init</strong>，这时会打印出 enter A，并执行下面一行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">super(A,self).__init__()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意，这里的 self 也是当前 C 的实例，MRO 列表跟上面是一样的，搜索 A 在 MRO 中的下一个类，发现是 B，于是，跳到了 B 的 <strong>init</strong>，这时会打印出 enter B，而不是 enter Base。</p>
<p>整个过程还是比较清晰的，关键是要理解 super 的工作方式，而不是想当然地认为 super 调用了父类的方法。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li>  事实上，super 和父类没有实质性的关联。</li>
<li>  super(cls, inst) 获得的是 cls 在 inst 的 MRO 列表中的下一个类。</li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Paramiko模块的离线安装</title>
    <url>/2021/07/26/Paramiko%E6%A8%A1%E5%9D%97%E7%9A%84%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="离线安装"><a href="#离线安装" class="headerlink" title="离线安装"></a>离线安装</h2><p>安装paramiko主要需要安装3个模块，分别是：ecdsa、paramiko、pycrypto。</p>
<span id="more"></span>

<p>在python3.6的环境下，经过调试成功之后的模块版本为：ecdsa 0.13；paramiko 1.18.4；pycrypto-2.6.1.tar.gz。</p>
<p>他们离线安装的地址如下：</p>
<p>ecdsa-0.13.tar.gz：</p>
<p><a href="https://files.pythonhosted.org/packages/f9/e5/99ebb176e47f150ac115ffeda5fedb6a3dbb3c00c74a59fd84ddf12f5857/ecdsa-0.13.tar.gz">https://files.pythonhosted.org/packages/f9/e5/99ebb176e47f150ac115ffeda5fedb6a3dbb3c00c74a59fd84ddf12f5857/ecdsa-0.13.tar.gz</a></p>
<p>pycrypto-2.6.1.tar.gz：</p>
<p><a href="https://ftp.dlitz.net/pub/dlitz/crypto/pycrypto/pycrypto-2.6.1.tar.gz">https://ftp.dlitz.net/pub/dlitz/crypto/pycrypto/pycrypto-2.6.1.tar.gz</a></p>
<p>paramiko-1.18.4.zip：</p>
<p><a href="https://codeload.github.com/paramiko/paramiko/zip/1.18.4">https://codeload.github.com/paramiko/paramiko/zip/1.18.4</a></p>
<p>解压后分别进入目录，执行python setup.py  build; python setup.py install</p>
<p>（PS：按顺序安装，先ecdsa、再pycrypto、最后paramiko）</p>
<h2 id="在线安装"><a href="#在线安装" class="headerlink" title="在线安装"></a>在线安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install paramiko</span><br></pre></td></tr></table></figure>


<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">import</span> paramiko</span><br><span class="line"><span class="keyword">from</span> paramiko_expect <span class="keyword">import</span> SSHClientInteraction</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># Set login credentials and the server prompt</span></span><br><span class="line">    HOSTNAME = <span class="string">&#x27;10.20.70.22&#x27;</span></span><br><span class="line">    USERNAME = <span class="string">&#x27;root&#x27;</span></span><br><span class="line">    PASSWORD = <span class="string">&#x27;123456&#x27;</span></span><br><span class="line">    PROMPT = <span class="string">&#x27;.*#.*&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Use SSH client to login</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># Create a new SSH client object</span></span><br><span class="line">        client = paramiko.SSHClient()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Set SSH key parameters to auto accept unknown hosts</span></span><br><span class="line">        client.load_system_host_keys()</span><br><span class="line">        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Connect to the host</span></span><br><span class="line">        client.connect(hostname=HOSTNAME, username=USERNAME, password=PASSWORD)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Create a client interaction class which will interact with the host</span></span><br><span class="line">        <span class="keyword">with</span> SSHClientInteraction(client, timeout=<span class="number">10</span>, display=<span class="literal">True</span>) <span class="keyword">as</span> interact:</span><br><span class="line">            interact.expect(PROMPT)</span><br><span class="line"></span><br><span class="line">            interact.send(<span class="string">&#x27;ifconfig&#x27;</span>)</span><br><span class="line">            interact.expect(PROMPT, timeout=<span class="number">5</span>)</span><br><span class="line">            cmd_output_ifconfig = interact.current_output_clean</span><br><span class="line"></span><br><span class="line">            <span class="comment"># Send the exit command and expect EOF (a closed session)</span></span><br><span class="line">            interact.send(<span class="string">&#x27;exit&#x27;</span>)</span><br><span class="line">            interact.expect()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Print the output of each command</span></span><br><span class="line">        <span class="built_in">print</span>(cmd_output_ifconfig)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> Exception:</span><br><span class="line">        traceback.print_exc()</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            client.close()</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p><img src="d80eb5a8ad027bb208d8281dc19c50fc0a98a4d903104d686bedf1488a8d2ef5.png" alt="图 1">  </p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>python装饰器</title>
    <url>/2021/07/26/python%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
    <content><![CDATA[<p>谈装饰器前，还要先要明白一件事，Python 中的函数和 Java、C++不太一样，Python 中的函数可以像普通变量一样当做参数传递给另外一个函数，例如：</p>
<span id="more"></span>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def foo():</span><br><span class="line">    print(&quot;foo&quot;)</span><br><span class="line"></span><br><span class="line">def bar(func):</span><br><span class="line">    func()</span><br><span class="line"></span><br><span class="line">bar(foo)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>正式回到我们的主题。装饰器本质上是一个 Python 函数或类，它可以让其他函数或类在不需要做任何代码修改的前提下增加额外功能，装饰器的返回值也是一个函数/类对象。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景，装饰器是解决这类问题的绝佳设计。有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码到装饰器中并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。</p>
<p>先来看一个简单例子，虽然实际代码可能比这复杂很多：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def foo():</span><br><span class="line">    print(&#x27;i am foo&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在有一个新的需求，希望可以记录下函数的执行日志，于是在代码中添加日志代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def foo():</span><br><span class="line">    print(&#x27;i am foo&#x27;)</span><br><span class="line">    logging.info(&quot;foo is running&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果函数 bar()、bar2() 也有类似的需求，怎么做？再写一个 logging 在 bar 函数里？这样就造成大量雷同的代码，为了减少重复写代码，我们可以这样做，重新定义一个新的函数：专门处理日志 ，日志处理完之后再执行真正的业务代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def use_logging(func):</span><br><span class="line">    logging.warn(&quot;%s is running&quot; % func.__name__)</span><br><span class="line">    func()</span><br><span class="line"></span><br><span class="line">def foo():</span><br><span class="line">    print(&#x27;i am foo&#x27;)</span><br><span class="line"></span><br><span class="line">use_logging(foo)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样做逻辑上是没问题的，功能是实现了，但是我们调用的时候不再是调用真正的业务逻辑 foo 函数，而是换成了 use_logging 函数，这就破坏了原有的代码结构， 现在我们不得不每次都要把原来的那个 foo 函数作为参数传递给 use_logging 函数，那么有没有更好的方式的呢？当然有，答案就是装饰器。</p>
<h3 id="简单装饰器"><a href="#简单装饰器" class="headerlink" title="简单装饰器"></a>简单装饰器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def use_logging(func):</span><br><span class="line"></span><br><span class="line">    def wrapper():</span><br><span class="line">        logging.warn(&quot;%s is running&quot; % func.__name__)</span><br><span class="line">        return func()   # 把 foo 当做参数传递进来时，执行func()就相当于执行foo()</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line">def foo():</span><br><span class="line">    print(&#x27;i am foo&#x27;)</span><br><span class="line"></span><br><span class="line">foo = use_logging(foo)  # 因为装饰器 use_logging(foo) 返回的时函数对象 wrapper，这条语句相当于  foo = wrapper</span><br><span class="line">foo()                   # 执行foo()就相当于执行 wrapper()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>use_logging 就是一个装饰器，它一个普通的函数，它把执行真正业务逻辑的函数 func 包裹在其中，看起来像 foo 被 use_logging 装饰了一样，use_logging 返回的也是一个函数，这个函数的名字叫 wrapper。在这个例子中，函数进入和退出时 ，被称为一个横切面，这种编程方式被称为面向切面的编程。</p>
<h3 id="语法糖"><a href="#语法糖" class="headerlink" title="@ 语法糖"></a>@ 语法糖</h3><p>如果你接触 Python 有一段时间了的话，想必你对 @ 符号一定不陌生了，没错 @ 符号就是装饰器的语法糖，它放在函数开始定义的地方，这样就可以省略最后一步再次赋值的操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def use_logging(func):</span><br><span class="line"></span><br><span class="line">    def wrapper():</span><br><span class="line">        logging.warn(&quot;%s is running&quot; % func.__name__)</span><br><span class="line">        return func()</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line">@use_logging</span><br><span class="line">def foo():</span><br><span class="line">    print(&quot;i am foo&quot;)</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如上所示，有了 @ ，我们就可以省去<code>foo = use_logging(foo)</code>这一句了，直接调用 foo() 即可得到想要的结果。你们看到了没有，foo() 函数不需要做任何修改，只需在定义的地方加上装饰器，调用的时候还是和以前一样，如果我们有其他的类似函数，我们可以继续调用装饰器来修饰函数，而不用重复修改函数或者增加新的封装。这样，我们就提高了程序的可重复利用性，并增加了程序的可读性。</p>
<p>装饰器在 Python 使用如此方便都要归因于 Python 的函数能像普通的对象一样能作为参数传递给其他函数，可以被赋值给其他变量，可以作为返回值，可以被定义在另外一个函数内。</p>
<h3 id="args、-kwargs"><a href="#args、-kwargs" class="headerlink" title="*args、**kwargs"></a>*args、**kwargs</h3><p>可能有人问，如果我的业务逻辑函数 foo 需要参数怎么办？比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def foo(name):</span><br><span class="line">    print(&quot;i am %s&quot; % name)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以在定义 wrapper 函数的时候指定参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def wrapper(name):</span><br><span class="line">        logging.warn(&quot;%s is running&quot; % func.__name__)</span><br><span class="line">        return func(name)</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样 foo 函数定义的参数就可以定义在 wrapper 函数中。这时，又有人要问了，如果 foo 函数接收两个参数呢？三个参数呢？更有甚者，我可能传很多个。当装饰器不知道 foo 到底有多少个参数时，我们可以用 *args 来代替：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def wrapper(*args):</span><br><span class="line">        logging.warn(&quot;%s is running&quot; % func.__name__)</span><br><span class="line">        return func(*args)</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如此一来，甭管 foo 定义了多少个参数，我都可以完整地传递到 func 中去。这样就不影响 foo 的业务逻辑了。这时还有读者会问，如果 foo 函数还定义了一些关键字参数呢？比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def foo(name, age=None, height=None):</span><br><span class="line">    print(&quot;I am %s, age %s, height %s&quot; % (name, age, height))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这时，你就可以把 wrapper 函数指定关键字函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def wrapper(*args, **kwargs):</span><br><span class="line">        # args是一个数组，kwargs一个字典</span><br><span class="line">        logging.warn(&quot;%s is running&quot; % func.__name__)</span><br><span class="line">        return func(*args, **kwargs)</span><br><span class="line">    return wrapper</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h3><p>装饰器还有更大的灵活性，例如带参数的装饰器，在上面的装饰器调用中，该装饰器接收唯一的参数就是执行业务的函数 foo 。装饰器的语法允许我们在调用时，提供其它参数，比如<code>@decorator(a)</code>。这样，就为装饰器的编写和使用提供了更大的灵活性。比如，我们可以在装饰器中指定日志的等级，因为不同业务函数可能需要的日志级别是不一样的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def use_logging(level):</span><br><span class="line">    def decorator(func):</span><br><span class="line">        def wrapper(*args, **kwargs):</span><br><span class="line">            if level == &quot;warn&quot;:</span><br><span class="line">                logging.warn(&quot;%s is running&quot; % func.__name__)</span><br><span class="line">            elif level == &quot;info&quot;:</span><br><span class="line">                logging.info(&quot;%s is running&quot; % func.__name__)</span><br><span class="line">            return func(*args)</span><br><span class="line">        return wrapper</span><br><span class="line"></span><br><span class="line">    return decorator</span><br><span class="line"></span><br><span class="line">@use_logging(level=&quot;warn&quot;)</span><br><span class="line">def foo(name=&#x27;foo&#x27;):</span><br><span class="line">    print(&quot;i am %s&quot; % name)</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的 use_logging 是允许带参数的装饰器。它实际上是对原有装饰器的一个函数封装，并返回一个装饰器。我们可以将它理解为一个含有参数的闭包。当我 们使用<code>@use_logging(level=&quot;warn&quot;)</code>调用的时候，Python 能够发现这一层的封装，并把参数传递到装饰器的环境中。</p>
<p><code>@use_logging(level=&quot;warn&quot;)</code>等价于<code>@decorator</code></p>
<h3 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h3><p>没错，装饰器不仅可以是函数，还可以是类，相比函数装饰器，类装饰器具有灵活度大、高内聚、封装性等优点。使用类装饰器主要依靠类的<code>__call__</code>方法，当使用 @ 形式将装饰器附加到函数上时，就会调用此方法。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line">    def __init__(self, func):</span><br><span class="line">        self._func = func</span><br><span class="line"></span><br><span class="line">    def __call__(self):</span><br><span class="line">        print (&#x27;class decorator runing&#x27;)</span><br><span class="line">        self._func()</span><br><span class="line">        print (&#x27;class decorator ending&#x27;)</span><br><span class="line"></span><br><span class="line">@Foo</span><br><span class="line">def bar():</span><br><span class="line">    print (&#x27;bar&#x27;)</span><br><span class="line"></span><br><span class="line">bar()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="functools-wraps"><a href="#functools-wraps" class="headerlink" title="functools.wraps"></a>functools.wraps</h3><p>使用装饰器极大地复用了代码，但是他有一个缺点就是原函数的元信息不见了，比如函数的<code>docstring</code>、<code>__name__</code>、参数列表，先看例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 装饰器</span><br><span class="line">def logged(func):</span><br><span class="line">    def with_logging(*args, **kwargs):</span><br><span class="line">        print func.__name__      # 输出 &#x27;with_logging&#x27;</span><br><span class="line">        print func.__doc__       # 输出 None</span><br><span class="line">        return func(*args, **kwargs)</span><br><span class="line">    return with_logging</span><br><span class="line"></span><br><span class="line"># 函数</span><br><span class="line">@logged</span><br><span class="line">def f(x):</span><br><span class="line">   &quot;&quot;&quot;does some math&quot;&quot;&quot;</span><br><span class="line">   return x + x * x</span><br><span class="line"></span><br><span class="line">logged(f)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>不难发现，函数 f 被<code>with_logging</code>取代了，当然它的<code>docstring</code>，<code>__name__</code>就是变成了<code>with_logging</code>函数的信息了。好在我们有<code>functools.wraps</code>，<code>wraps</code>本身也是一个装饰器，它能把原函数的元信息拷贝到装饰器里面的 func 函数中，这使得装饰器里面的 func 函数也有和原函数 foo 一样的元信息了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">from functools import wraps</span><br><span class="line">def logged(func):</span><br><span class="line">    @wraps(func)</span><br><span class="line">    def with_logging(*args, **kwargs):</span><br><span class="line">        print func.__name__      # 输出 &#x27;f&#x27;</span><br><span class="line">        print func.__doc__       # 输出 &#x27;does some math&#x27;</span><br><span class="line">        return func(*args, **kwargs)</span><br><span class="line">    return with_logging</span><br><span class="line"></span><br><span class="line">@logged</span><br><span class="line">def f(x):</span><br><span class="line">   &quot;&quot;&quot;does some math&quot;&quot;&quot;</span><br><span class="line">   return x + x * x</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="装饰器顺序"><a href="#装饰器顺序" class="headerlink" title="装饰器顺序"></a>装饰器顺序</h3><p>一个函数还可以同时定义多个装饰器，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@a</span><br><span class="line">@b</span><br><span class="line">@c</span><br><span class="line">def f ():</span><br><span class="line">    pass</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>它的执行顺序是从里到外，最先调用最里层的装饰器，最后调用最外层的装饰器，它等效于</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f = a(b(c(f)))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu18.04设置静态IP地址</title>
    <url>/2021/07/25/ubuntu18-04%E8%AE%BE%E7%BD%AE%E9%9D%99%E6%80%81IP%E5%9C%B0%E5%9D%80/</url>
    <content><![CDATA[<h2 id="netplan"><a href="#netplan" class="headerlink" title="netplan"></a>netplan</h2><p><code>Ubuntu18.04</code>采用的是<code>netplan</code>来管理<code>network</code>。<br>所以可以在<code>/etc/netplan/</code>目录下创建<br>一个以<code>yaml</code>结尾的文件。比如<code>01-network-manager-all.yaml</code>文件。</p>
<span id="more"></span>

<h3 id="编辑文件"><a href="#编辑文件" class="headerlink" title="编辑文件"></a>编辑文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/netplan/01-network-manager-all.yaml</span><br></pre></td></tr></table></figure>

<p>可以看到原始内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Let NetworkManager manage all devices on this system</span></span><br><span class="line">network:</span><br><span class="line">  version: 2</span><br><span class="line">  renderer: NetworkManager</span><br></pre></td></tr></table></figure>

<h3 id="修改固定ip"><a href="#修改固定ip" class="headerlink" title="修改固定ip"></a>修改固定ip</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Let NetworkManager manage all devices on this system</span></span><br><span class="line"><span class="comment">#network:</span></span><br><span class="line"><span class="comment">#  version: 2</span></span><br><span class="line"><span class="comment">#  renderer: NetworkManager</span></span><br><span class="line"><span class="comment">#  ethernets:</span></span><br><span class="line"><span class="comment">#      enp6s0:</span></span><br><span class="line"><span class="comment">#          dhcp4: yes </span></span><br><span class="line"></span><br><span class="line">network:</span><br><span class="line">  version: 2</span><br><span class="line">  ethernets:</span><br><span class="line">      enp6s0:</span><br><span class="line">          dhcp4: no</span><br><span class="line">          addresses: [192.168.1.22/24]</span><br><span class="line">          optional: <span class="literal">true</span></span><br><span class="line">          gateway4: 192.168.1.1</span><br><span class="line">          nameservers:</span><br><span class="line">              addresses: [192.168.1.1]</span><br></pre></td></tr></table></figure>


<h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo netplan apply</span><br></pre></td></tr></table></figure>

<h3 id="如果要还原更改为dhcp，则修改为"><a href="#如果要还原更改为dhcp，则修改为" class="headerlink" title="如果要还原更改为dhcp，则修改为"></a>如果要还原更改为dhcp，则修改为</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Let NetworkManager manage all devices on this system</span></span><br><span class="line">network:</span><br><span class="line">  version: 2</span><br><span class="line">  renderer: NetworkManager</span><br><span class="line">  ethernets:</span><br><span class="line">      enp6s0:</span><br><span class="line">          dhcp4: <span class="built_in">yes</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">#network:</span></span><br><span class="line"><span class="comment">#  version: 2</span></span><br><span class="line"><span class="comment">#  ethernets:</span></span><br><span class="line"><span class="comment">#      enp6s0:</span></span><br><span class="line"><span class="comment">#          dhcp4: no</span></span><br><span class="line"><span class="comment">#          addresses: [192.168.1.22/24]</span></span><br><span class="line"><span class="comment">#          optional: true</span></span><br><span class="line"><span class="comment">#          gateway4: 192.168.1.1</span></span><br><span class="line"><span class="comment">#          nameservers:</span></span><br><span class="line"><span class="comment">#              addresses: [192.168.1.1]</span></span><br></pre></td></tr></table></figure>

<p>再执行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo netplan apply</span><br></pre></td></tr></table></figure>


<h3 id="50-cloud-init-yaml"><a href="#50-cloud-init-yaml" class="headerlink" title="50-cloud-init.yaml"></a>50-cloud-init.yaml</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/netplan/50-cloud-init.yaml</span><br></pre></td></tr></table></figure>

<p>配置内容如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">network:</span><br><span class="line">    ethernets:</span><br><span class="line">        ens33:</span><br><span class="line">            addresses:</span><br><span class="line">            - 192.168.43.123/24</span><br><span class="line">            dhcp4: <span class="literal">false</span></span><br><span class="line">            gateway4: 192.168.43.1</span><br><span class="line">            nameservers:</span><br><span class="line">                addresses: [114.114.114.114,8.8.8.8]</span><br><span class="line">                search: []</span><br><span class="line">    version: 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">network:</span><br><span class="line">    ethernets:</span><br><span class="line">        ens33:</span><br><span class="line">            addresses:</span><br><span class="line">            - 192.168.43.123/24</span><br><span class="line">            dhcp4: <span class="literal">false</span></span><br><span class="line">            gateway4: 192.168.43.1</span><br><span class="line">            nameservers:</span><br><span class="line">                addresses: [114.114.114.114,8.8.8.8]</span><br><span class="line">                search: []</span><br><span class="line">    version: 2</span><br></pre></td></tr></table></figure>
<p>修改对应ip即可，格式不变</p>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>git版本后缀</title>
    <url>/2021/07/24/git%E7%89%88%E6%9C%AC%E5%90%8E%E7%BC%80/</url>
    <content><![CDATA[<h2 id="Alpha、Beta、RC、GA"><a href="#Alpha、Beta、RC、GA" class="headerlink" title="Alpha、Beta、RC、GA"></a>Alpha、Beta、RC、GA</h2><p><code>Alpha</code>：是内部测试版,一般不向外部发布,会有很多Bug.一般只有测试人员使用。<br><code>Beta</code>：也是测试版，这个阶段的版本会一直加入新的功能。在Alpha版之后推出。</p>
<span id="more"></span>

<p><code>RC</code>：(Release　Candidate) 顾名思义么 ! 用在软件上就是候选版本。系统平台上就是发行候选版本。RC版不会再加入新的功能了，主要着重于除错。<br><code>GA</code> :General Availability,正式发布的版本，在国外都是用 GA 来说明release版本的。<br><code>RTM</code>：(Release to Manufacture)是给工厂大量压片的版本，内容跟正式版是一样的，不过RTM版也有出限制、评估版的。但是和正式版本的主要程序代码都是一样的。<br><code>OEM</code>：是给计算机厂商随着计算机贩卖的，也就是随机版。只能随机器出货，不能零售。只能全新安装，不能从旧有操作系统升级。包装不像零售版精美，通常只有一面CD和说明书(授权书)。<br><code>RVL</code>：号称是正式版，其实RVL根本不是版本的名称。它是中文版/英文版文档破解出来的。<br><code>EVAL</code>：而流通在网络上的EVAL版，与“评估版”类似，功能上和零售版没有区别。<br><code>RTL</code>：Retail(零售版)是真正的正式版，正式上架零售版。在安装盘的i386文件夹里有一个eula.txt，最后有一行EULAID，就是你的版本。比如简体中文正式版是EULAID:WX.4_PRO_RTL_CN，繁体中文正式版是WX.4_PRO_RTL_TW。其中：如果是WX.开头是正式版，WB.开头是测试版。_PRE，代表家庭版；_PRO，代表专业版。<br><code>α、β、λ</code>常用来表示 软件测试 过程中的三个阶段，α是第一阶段，一般只供内部测试使用；β是第二个阶段，已经消除了软件中大部分的不完善之处，但仍有可能还存在缺陷和漏洞，一般只提供给特定的用户群来测试使用；λ是第三个阶段，此时产品已经相当成熟，只需在个别地方再做进一步的优化处理即可上市发行。 </p>
]]></content>
      <categories>
        <category>GIT</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>ioctl函数</title>
    <url>/2021/07/23/ioctl%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> fd, <span class="type">unsigned</span> <span class="type">long</span> request, ...)</span>;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>通过ioctl函数完成用户态和内核态之间的交互</p>
<h2 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h2><p>在Linux系统中，用户空间和内核空间之间是相互隔离开的。驱动程序运行在内核空间中，给出的地址也是在内核空间中的地址，运行在用户空间下的用户程序即使拿到这个地址，也不能访问内核空间。这时，我们需要使用到<code>copy_to_user()</code>函数，将要传递的内容从内核空间拷贝到用户空间，用户程序再访问用户空间中的该内容即可。</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ol>
<li><p>fd是文件描述符。当我们的设备作为特殊文件被open()函数打开后，会返回一个文件描述符，通过操作这个文件描述符达到操作设备文件的目的。</p>
</li>
<li><p>request是命令码，应用程序通过下发命令码来控制驱动程序完成对应操作。</p>
</li>
<li><p>第三个参数“…”是可变参数arg，一些情况下应用程序需要向驱动程序传参，参数就通过ag来传递。ioctl函数中的“…”只能传递一个参数，但内核不会检查这个参数的类型。那么，就有两种传参方式：只传一个整数，传递一个指针。</p>
</li>
</ol>
<p>如果ioctl执行成功，它的返回值就是驱动程序中ioctl接口给的返回值，驱动程序可以通过返回值向用户程序传参。但驱动程序最好返回一个非负数，因为用户程序中的ioctl运行失败时一定会返回-1并设置全局变量errorno。</p>
<p>errono不同的值代表的含义如下：</p>
<table>
    <tr>
        <th>错误码</th><th>描述</th>
    </tr>
    <tr>
        <td>EBADF</td><td>fd是一个无效的文件描述符。</td>
    </tr>
    <tr>
        <td>EFAULT</td><td>在arg是指针的前提下，argp指向一个不可访问的内存空间。</td>
    </tr>
    <tr>
        <td>EINVAL</td><td>request或argp是无效的。</td>
    </tr>
    <tr>
        <td>ENOTTY</td><td>fd没有关联到一个字符特殊设备，或该request不适用于文件描述符fd引用的对象类型。（说人话就是fd没有指向一个字符设备，或fd指向的文件不支持ioctl操作）</td>
    </tr>
</table>

<p>因此，在用户空间调用ioctl时，可以使用如下的错误判断处理。包括的两个头文件，string.h声明了strerror函数，errno.h定义了错误码errno。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line">ret = ioctl(fd, MYCMD);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;ioctl: %s\n&quot;</span>, strerror(errno));</span><br></pre></td></tr></table></figure>

<h2 id="驱动程序中的ioctl接口"><a href="#驱动程序中的ioctl接口" class="headerlink" title="驱动程序中的ioctl接口"></a>驱动程序中的ioctl接口</h2><p>在驱动程序的ioctl函数体中，实现了一个switch-case结构，每一个case对应一个命令码，case内部是驱动程序实现该命令的相关操作。</p>
<p>ioctl的实现函数要传递给file_operations结构体中对应的函数指针，函数原型为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ioctl.h&gt;</span></span></span><br><span class="line"><span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file * fp, <span class="type">unsigned</span> <span class="type">int</span> request, <span class="type">unsigned</span> <span class="type">long</span> args);</span><br><span class="line"><span class="type">long</span> (*compat_ioctl) (<span class="keyword">struct</span> file * fp, <span class="type">unsigned</span> <span class="type">int</span> request, <span class="type">unsigned</span> <span class="type">long</span> args);</span><br></pre></td></tr></table></figure>
<p>unlocked_ioctl在无大内核锁（BKL）的情况下调用。64位用户程序运行在64位的kernel，或32位的用户程序运行在32位的kernel上，都是调用unlocked_ioctl函数。</p>
<p>compat_ioctl是64位系统提供32位ioctl的兼容方法，也在无大内核锁的情况下调用。即如果是32位的用户程序调用64位的kernel，则会调用compat_ioctl。如果驱动程序没有实现compat_ioctl，则用户程序在执行ioctl时会返回错误Not a typewriter。</p>
<p>另外，如果32位用户态和64位内核态发生交互时，第三个参数的长度需要保持一致，否则交互协议会出错。</p>
<h2 id="用户与驱动之间的ioctl协议构成"><a href="#用户与驱动之间的ioctl协议构成" class="headerlink" title="用户与驱动之间的ioctl协议构成"></a>用户与驱动之间的ioctl协议构成</h2><p>也就是request或cmd，本质上就是一个32位数字，理论上可以是任何一个数，但为了保证命令码的唯一性，linux定义了一套严格的规定，通过计算得到这个命令吗数字。linux将32位划分为四段。</p>
<table>
    <tr>
        <th>字段名</th><th>大小</th><th>含义</th>
    </tr>
    <tr>
        <td>dir</td><td>2bit</td><td>即direction，表示ioctl命令的访问模式，分为无数据(_IO)、读数据(_IOR)、写数据(_IOW)、读写数据(_IOWR)四种模式。</td>
    </tr>
    <tr>
        <td>size</td><td>14bit</td><td>即device type，表示设备类型，也可翻译成“幻数”或“魔数”，可以是任意一个char型字符，如’a’、‘b’、‘c’等，其主要作用是使ioctl命令具有唯一的设备标识。不过在内核中’w’、‘y’、'z’三个字符已经被使用了。</td>
    </tr>
    <tr>
        <td>type</td><td>8bit</td><td>涉及到ioctl的参数arg，占据13bit或14bit，这个与体系有关，arm使用14bit。用来传递arg的数据类型的长度，比如如果arg是int型，我们就将这个参数填入int，系统会检查数据类型和长度的正确性。</td>
    </tr>
    <tr>
        <td>nr</td><td>8bit</td><td>即number，命令编号/序数，取值范围0~255，在定义了多个ioctl命令的时候，通常从0开始顺次往下编号。</td>
    </tr>
</table>


<p>在上面的四个参数都需要用户自己定义，linux系统提供了宏可以使程序员方便的定义ioctl命令码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">include/uapi/<span class="keyword">asm</span>-generic/ioctl.h</span><br><span class="line">--------------------------------------------</span><br><span class="line"><span class="comment">/* used to create numbers */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO(type,nr)        _IOC(_IOC_NONE,(type),(nr),0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOR(type,nr,size)  _IOC(_IOC_READ,(type),(nr),(_IOC_TYPECHECK(size)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOW(type,nr,size)  _IOC(_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IOWR(type,nr,size) _IOC(_IOC_READ|_IOC_WRITE,(type),(nr),(_IOC_TYPECHECK(size)))</span></span><br></pre></td></tr></table></figure>


<h2 id="ioctl使用的简单实例——整数传参"><a href="#ioctl使用的简单实例——整数传参" class="headerlink" title="ioctl使用的简单实例——整数传参"></a>ioctl使用的简单实例——整数传参</h2><p>本例中，我们让ioctl传递三个命令，分别是一个无参数、写参数、读参数三个指令。首先我们需要确定两个头文件，命名为ioctl_test.h和user_ioctl.h，用来分别定义内核空间和用户空间下的命令码协议。两个头文件中除了引用不同的头文件外，其他内容需要完全一致，以保证协议的一致性。</p>
<p>代码结构图如下<br><img src="8e64e493edb7019f83bfc377b0adc603499aca9d81a9bd6596aa85de5a8b4557.png" alt="图 1">  </p>
<p><strong>ioctl_test.h</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">IOC_ARGS</span> &#123;</span></span><br><span class="line">	<span class="type">char</span>	arg1;</span><br><span class="line">	<span class="type">int</span>		arg2;</span><br><span class="line">&#125;IOC_ARGS;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_IOC_MAGIC	<span class="string">&#x27;a&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_IOC_0		_IOR(CMD_IOC_MAGIC, 0, struct IOC_ARGS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_IOC_1		_IOW(CMD_IOC_MAGIC, 1, struct IOC_ARGS)</span></span><br></pre></td></tr></table></figure>

<p><strong>user_ioctl.h</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IOC_ARGS</span> &#123;</span></span><br><span class="line">	<span class="type">char</span>	arg1;</span><br><span class="line">	<span class="type">int</span>		arg2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_IOC_MAGIC	<span class="string">&#x27;a&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_IOC_0		_IOR(CMD_IOC_MAGIC, 0, struct IOC_ARGS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_IOC_1		_IOW(CMD_IOC_MAGIC, 1, struct IOC_ARGS)</span></span><br></pre></td></tr></table></figure>

<p><strong>ioctl_test.c</strong><br>核心函数是demo_ioctl，使用一个switch-case完成用户程序下发的指令。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/fs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/cdev.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/uaccess.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ioctl_test.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;zz&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">dev_t</span> devno;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">demo_open</span><span class="params">(<span class="keyword">struct</span> inode *ind, <span class="keyword">struct</span> file *fp)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;demo open\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">demo_release</span><span class="params">(<span class="keyword">struct</span> inode *ind, <span class="keyword">struct</span> file *fp)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;demo release\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="title function_">demo_ioctl</span><span class="params">(<span class="keyword">struct</span> file *fp, <span class="type">unsigned</span> <span class="type">int</span> cmd, <span class="type">unsigned</span> <span class="type">long</span> arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> rc = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">IOC_ARGS</span> <span class="title">args_r</span> =</span> &#123;<span class="string">&#x27;k&#x27;</span>, <span class="number">566</span>&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">IOC_ARGS</span> <span class="title">args_w</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (_IOC_TYPE(cmd) != CMD_IOC_MAGIC) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;%s: command type [%c] error.\n&quot;</span>, __func__, _IOC_TYPE(cmd));</span><br><span class="line">		<span class="keyword">return</span> -ENOTTY;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span>(cmd) &#123;</span><br><span class="line">		<span class="keyword">case</span> CMD_IOC_0:</span><br><span class="line">			rc = copy_to_user((<span class="type">char</span> __user *)arg, &amp;args_r, <span class="keyword">sizeof</span>(IOC_ARGS));</span><br><span class="line">			<span class="keyword">if</span> (rc) &#123;</span><br><span class="line">				pr_err(<span class="string">&quot;%s: copy_to_user failed&quot;</span>, __func__);</span><br><span class="line">				<span class="keyword">return</span> rc;</span><br><span class="line">			&#125;</span><br><span class="line">			printk(<span class="string">&quot;%s: ioc read arg1 = %c, arg2 = %d&quot;</span>, __func__, args_r.arg1, args_r.arg2);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> CMD_IOC_1:</span><br><span class="line">			rc = copy_from_user(&amp;args_w, (<span class="type">char</span> __user *)arg, <span class="keyword">sizeof</span>(IOC_ARGS));</span><br><span class="line">			<span class="keyword">if</span> (rc) &#123;</span><br><span class="line">				pr_err(<span class="string">&quot;%s: copy_from_user failed&quot;</span>, __func__);</span><br><span class="line">				<span class="keyword">return</span> rc;</span><br><span class="line">			&#125;</span><br><span class="line">			printk(<span class="string">&quot;%s: ioc write arg1 = %c, arg2 = %d&quot;</span>, __func__, args_w.arg1, args_w.arg2);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			pr_err(<span class="string">&quot;%s: invalid command.\n&quot;</span>, __func__);</span><br><span class="line">			<span class="keyword">return</span> -ENOTTY;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> rc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">fops</span> =</span> &#123;</span><br><span class="line">	.open = demo_open,</span><br><span class="line">	.release = demo_release,</span><br><span class="line">	.unlocked_ioctl = demo_ioctl,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">cdev</span> <span class="title">cd</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">demo_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> rc;</span><br><span class="line">	rc = alloc_chrdev_region(&amp;devno, <span class="number">0</span>, <span class="number">1</span>, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;alloc_chrdev_region failed!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> rc;</span><br><span class="line">	&#125;</span><br><span class="line">	printk(<span class="string">&quot;MAJOR is %d\n&quot;</span>, MAJOR(devno));</span><br><span class="line">	printk(<span class="string">&quot;MINOR is %d\n&quot;</span>, MINOR(devno));</span><br><span class="line"></span><br><span class="line">	cdev_init(&amp;cd, &amp;fops);</span><br><span class="line">	rc = cdev_add(&amp;cd, devno, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		pr_err(<span class="string">&quot;cdev_add failed!&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> rc;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">demo_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	cdev_del(&amp;cd);</span><br><span class="line">	unregister_chrdev_region(devno, <span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(demo_init);</span><br><span class="line">module_exit(demo_exit);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>user_ioctl.c</strong><br>打开设备节点，依次下发三条指令，打印参数和ioctl的返回值，关闭设备节点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;user_ioctl.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> rc;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">IOC_ARGS</span> <span class="title">args_r</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">IOC_ARGS</span> <span class="title">args_w</span> =</span> &#123;<span class="string">&#x27;u&#x27;</span>, <span class="number">233</span>&#125;;</span><br><span class="line">	<span class="type">int</span> fd = open(<span class="string">&quot;/dev/test-0&quot;</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">	rc = ioctl(fd, CMD_IOC_0, &amp;args_r);</span><br><span class="line">	<span class="keyword">if</span> (rc &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ioctl: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ioc read arg1 = %c, arg2 = %d.\n&quot;</span>, args_r.arg1, args_r.arg2);</span><br><span class="line"></span><br><span class="line">	rc = ioctl(fd, CMD_IOC_1, &amp;args_w);</span><br><span class="line">	<span class="keyword">if</span> (rc &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ioctl: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ioc write arg1 = %c, arg2 = %d.\n&quot;</span>, args_w.arg1, args_w.arg2);</span><br><span class="line"></span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Makefile</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ifneq ($(KERNELRELEASE),)</span><br><span class="line">	obj-m := ioctl_test.o</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	KDIR    := /lib/modules/$(shell uname -r)/build</span><br><span class="line">	PWD     := $(shell pwd)</span><br><span class="line">all:</span><br><span class="line">	make -C $(KDIR) M=$(PWD) modules</span><br><span class="line">	gcc user_ioctl.c -o user</span><br><span class="line">clean:</span><br><span class="line">	make -C $(KDIR) M=$(PWD) clean</span><br><span class="line">	rm -rf user</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>

<p><strong>编译</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@node-70-10:/home/rma/ioctl<span class="comment"># make</span></span><br><span class="line">make -C /lib/modules/4.18.0-30501.10.2.el8.x86_64/build M=/home/rma/ioctl modules</span><br><span class="line">make[1]: Entering directory <span class="string">&#x27;/usr/src/kernels/4.18.0-30501.10.2.el8.x86_64&#x27;</span></span><br><span class="line">  CC [M]  /home/rma/ioctl/ioctl_test.o</span><br><span class="line">  Building modules, stage 2.</span><br><span class="line">  MODPOST 1 modules</span><br><span class="line">  CC      /home/rma/ioctl/ioctl_test.mod.o</span><br><span class="line">  LD [M]  /home/rma/ioctl/ioctl_test.ko</span><br><span class="line">make[1]: Leaving directory <span class="string">&#x27;/usr/src/kernels/4.18.0-30501.10.2.el8.x86_64&#x27;</span></span><br><span class="line">gcc user_ioctl.c -o user</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><p><img src="b84cb342a1323d9c654166a8c804f201239c18b30d8d8ef2fb5a8f7727ca8c6d.png" alt="图 2">  </p>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>ioctl</tag>
      </tags>
  </entry>
  <entry>
    <title>SO_REUSEPORT和SO_REUSEADDR的区别</title>
    <url>/2021/07/22/SO-REUSEPORT%E5%92%8CSO-REUSEADDR%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="SO-REUSEPORT"><a href="#SO-REUSEPORT" class="headerlink" title="SO_REUSEPORT"></a>SO_REUSEPORT</h2><p>SO_REUSEPORT支持多个进程或者线程绑定到同一端口，提高服务器程序的性能，解决的问题：</p>
<span id="more"></span>
<ul>
<li>允许多个套接字 bind()/listen() 同一个TCP/UDP端口</li>
<li>每一个线程拥有自己的服务器套接字</li>
<li>在服务器套接字上没有了锁的竞争</li>
<li>内核层面实现负载均衡</li>
<li>安全层面，监听同一个端口的套接字只能位于同一个用户下面</li>
</ul>
<p>其核心的实现主要有三点：</p>
<ul>
<li>扩展 socket option，增加 SO_REUSEPORT 选项，用来设置 reuseport。</li>
<li>修改 bind 系统调用实现，以便支持可以绑定到相同的 IP 和端口</li>
<li>修改处理新建连接的实现，查找 listener 的时候，能够支持在监听相同 IP 和端口的多个 sock 之间均衡选择。</li>
</ul>
<p>有了SO_RESUEPORT后，每个进程可以自己创建socket、bind、listen、accept相同的地址和端口，各自是独立平等的。让多进程监听同一个端口，各个进程中accept socket fd不一样，有新连接建立时，内核只会唤醒一个进程来accept，并且保证唤醒的均衡性。</p>
<h2 id="SO-REUSEPORT和SO-REUSEADDR"><a href="#SO-REUSEPORT和SO-REUSEADDR" class="headerlink" title="SO_REUSEPORT和SO_REUSEADDR"></a>SO_REUSEPORT和SO_REUSEADDR</h2><p>从字面意思理解，SO_REUSEPORT是端口重用，SO_REUSEADDR是地址重用。两者的区别：</p>
<ul>
<li><p>SO_REUSEPORT是允许多个socket绑定到同一个ip+port上。SO_REUSEADDR用于对TCP套接字处于TIME_WAIT状态下的socket，才可以重复绑定使用。</p>
</li>
<li><p>两者使用场景完全不同。SO_REUSEADDR这个套接字选项通知内核，如果端口忙，但TCP状态位于TIME_WAIT，可以重用端口。这个一般用于当你的程序停止后想立即重启的时候，如果没有设定这个选项，会报错EADDRINUSE，需要等到TIME_WAIT结束才能重新绑定到同一个ip+port上。而SO_REUSEPORT用于多核环境下，允许多个线程或者进程绑定和监听同一个ip+port，无论UDP、TCP（以及TCP是什么状态）。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>socket编程</category>
      </categories>
      <tags>
        <tag>SO_REUSEPORT</tag>
        <tag>SO_REUSEADDR</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP和UDP使用同一个端口</title>
    <url>/2021/07/21/TCP%E5%92%8CUDP%E4%BD%BF%E7%94%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E7%AB%AF%E5%8F%A3/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>TCP 和 UDP 服务端网络相似的一个地方，就是会调用 bind 绑定端口。<br>TCP 网络编程如下，服务端执行 listen() 系统调用就是监听端口的动作。</p>
<span id="more"></span>

<p><img src="5c47f0ccac6764e3db1fdf8becea5332f26933e72d19e60953b9f8dbcba8acc9.png" alt="图 1">  </p>
<p>UDP 网络编程如下，服务端是没有监听这个动作的，只有执行 bind() 系统调用来绑定端口的动作。<br><img src="e7611ee214faff293e86562c8ff89141fa68d69f03f9dda38c774a60c6617163.png" alt="图 6">  </p>
<h2 id="TCP-和-UDP-可以同时绑定相同的端口吗？"><a href="#TCP-和-UDP-可以同时绑定相同的端口吗？" class="headerlink" title="TCP 和 UDP 可以同时绑定相同的端口吗？"></a>TCP 和 UDP 可以同时绑定相同的端口吗？</h2><p>答案：可以的。</p>
<p>传输层有两个传输协议分别是 TCP 和 UDP，在内核中是两个完全独立的软件模块。</p>
<p>当主机收到数据包后，可以在 IP 包头的「协议号」字段知道该数据包是 TCP/UDP，所以可以根据这个信息确定送给哪个模块（TCP/UDP）处理，送给 TCP/UDP 模块的报文根据「端口号」确定送给哪个应用程序处理。</p>
<p><img src="214b4de3fc7c48964f1ba94b3bd90c0cc03be771c328500924ae2f8d2098b8b2.png" alt="图 3">  </p>
<h2 id="多个-TCP-服务进程可以绑定同一个端口吗？"><a href="#多个-TCP-服务进程可以绑定同一个端口吗？" class="headerlink" title="多个 TCP 服务进程可以绑定同一个端口吗？"></a>多个 TCP 服务进程可以绑定同一个端口吗？</h2><p>如果想多个进程绑定相同的 IP 地址和端口，也是有办法的，就是对 socket 设置 SO_REUSEPORT 属性（内核 3.9 版本提供的新特性）。</p>
<h2 id="重启-TCP-服务进程时，为什么会有“Address-in-use”的报错信息？"><a href="#重启-TCP-服务进程时，为什么会有“Address-in-use”的报错信息？" class="headerlink" title="重启 TCP 服务进程时，为什么会有“Address in use”的报错信息？"></a>重启 TCP 服务进程时，为什么会有“Address in use”的报错信息？</h2><p>TCP 服务进程需要绑定一个 IP 地址和一个端口，然后就监听在这个地址和端口上，等待客户端连接的到来。</p>
<p>然后在实践中，我们可能会经常碰到一个问题，当 TCP 服务进程重启之后，总是碰到“Address in use”的报错信息，TCP 服务进程不能很快地重启，而是要过一会才能重启成功。</p>
<p>这是为什么呢？</p>
<p>当我们重启 TCP 服务进程的时候，意味着通过服务器端发起了关闭连接操作，于是就会经过四次挥手，而对于主动关闭方，会在 TIME_WAIT 这个状态里停留一段时间，这个时间大约为 2MSL。<br><img src="9e688a34de8b762353fe027f471778dad24003ffda8f9fd56abf6cf092893ef5.png" alt="图 4">  </p>
<p>当 TCP 服务进程重启时，服务端会出现 TIME_WAIT 状态的连接，TIME_WAIT 状态的连接使用的 IP+PORT 仍然被认为是一个有效的 IP+PORT 组合，相同机器上不能够在该 IP+PORT 组合上进行绑定，那么执行 bind() 函数的时候，就会返回了 Address already in use 的错误。</p>
<p>而等 TIME_WAIT 状态的连接结束后，重启 TCP 服务进程就能成功。</p>
<h2 id="重启-TCP-服务进程时，如何避免“Address-in-use”的报错信息？"><a href="#重启-TCP-服务进程时，如何避免“Address-in-use”的报错信息？" class="headerlink" title="重启 TCP 服务进程时，如何避免“Address in use”的报错信息？"></a>重启 TCP 服务进程时，如何避免“Address in use”的报错信息？</h2><p>我们可以在调用 bind 前，对 socket 设置 SO_REUSEADDR 属性，可以解决这个问题。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> on = <span class="number">1</span>;</span><br><span class="line">setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="keyword">sizeof</span>(on));</span><br></pre></td></tr></table></figure>
<p>因为 SO_REUSEADDR 作用是：如果当前启动进程绑定的 IP+PORT 与处于TIME_WAIT 状态的连接占用的 IP+PORT 存在冲突，但是新启动的进程使用了 SO_REUSEADDR 选项，那么该进程就可以绑定成功。</p>
]]></content>
      <categories>
        <category>socket编程</category>
      </categories>
      <tags>
        <tag>端口复用</tag>
      </tags>
  </entry>
  <entry>
    <title>IOMMU</title>
    <url>/2021/07/20/IOMMU/</url>
    <content><![CDATA[<h2 id="IOMMU简介"><a href="#IOMMU简介" class="headerlink" title="IOMMU简介"></a>IOMMU简介</h2><ul>
<li>IOMMU：input/output memory management unit。</li>
<li>连接DMA io bus和主存，完成从设备虚拟地址到物理地址的映射。</li>
<li>提供对故障设备的内存保护的功能。<span id="more"></span></li>
</ul>
<p><img src="0f396221b92ca4e4270f093bd989814bb0ad30c8dd40ba20c95ccd62eef2b210.png" alt="图 1">  </p>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p>因为IOMMU的映射，能够将多个不连续的物理地址映射为大块连续的地址供设备使用，便于简化驱动设计<br>使旧设备（32bit设备）能够使用高位地址<br>（能够改善内存使用，提高性能）<br>内存保护，避免设备使用不属于它的地址<br>提供硬件中断remapping功能</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>地址转换和管理开销带来的性能降级<br>消耗物理内存<br>虚拟化中的应用<br>一般来说，因为内存地址不同，虚拟机中的操作系统无法直接访问host上的设备。通过IOMMU，能够将设备地址在虚拟机中和host中映射为同样的支持，供虚拟机使用。<br>这样的做法也能够缓解IO延时。</p>
<h2 id="Linux开启IOMMU"><a href="#Linux开启IOMMU" class="headerlink" title="Linux开启IOMMU"></a>Linux开启IOMMU</h2><h3 id="修改-etc-default-grub-调整GRUB-CMDLINE-LINUX内容"><a href="#修改-etc-default-grub-调整GRUB-CMDLINE-LINUX内容" class="headerlink" title="修改/etc/default/grub, 调整GRUB_CMDLINE_LINUX内容"></a>修改/etc/default/grub, 调整GRUB_CMDLINE_LINUX内容</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GRUB_TIMEOUT=5</span><br><span class="line">GRUB_DISTRIBUTOR=<span class="string">&quot;<span class="subst">$(sed &#x27;s, release .*$,,g&#x27; /etc/system-release)</span>&quot;</span></span><br><span class="line">GRUB_DEFAULT=saved</span><br><span class="line">GRUB_DISABLE_SUBMENU=<span class="literal">true</span></span><br><span class="line">GRUB_TERMINAL_OUTPUT=<span class="string">&quot;console&quot;</span></span><br><span class="line">GRUB_CMDLINE_LINUX=<span class="string">&quot;crashkernel=auto console=tty0,edd=off intel_iommu=on iommu=pt pci=realloc modprobe.blacklist=virtio_blk&quot;</span></span><br><span class="line">GRUB_DISABLE_RECOVERY=<span class="string">&quot;true&quot;</span></span><br><span class="line">GRUB_ENABLE_BLSCFG=<span class="literal">true</span></span><br><span class="line">(amd_iommu/intel_iommu/AuthenticAMD)</span><br><span class="line">iommu.passthrough=0 pci=realloc</span><br></pre></td></tr></table></figure>

<h3 id="重新创建引导"><a href="#重新创建引导" class="headerlink" title="重新创建引导"></a>重新创建引导</h3><p>如果服务器时UEFI启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grub2-mkconfig -o /boot/efi/EFI/centos/grub.cfg</span><br></pre></td></tr></table></figure>

<p>普通模式启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grub2-mkconfig -o /boot/grub2/grub.cfg</span><br><span class="line">或者</span><br><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure>

<h3 id="在BIOS中开启IOMMU选项，如果网卡有对应的虚拟化选项需同步开启"><a href="#在BIOS中开启IOMMU选项，如果网卡有对应的虚拟化选项需同步开启" class="headerlink" title="在BIOS中开启IOMMU选项，如果网卡有对应的虚拟化选项需同步开启"></a>在BIOS中开启IOMMU选项，如果网卡有对应的虚拟化选项需同步开启</h3><h3 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dmesg | grep -e DMAR -e IOMMU</span></span><br><span class="line">[    0.000000] ACPI: DMAR 0x000000006ABBBBC8 000280 (v01 ALASKA A M I    00000001 INTL 20091013)</span><br><span class="line">[    0.000000] DMAR: IOMMU enabled</span><br><span class="line">[    0.001126] DMAR: Host address width 46</span><br><span class="line">[    0.001241] DMAR: DRHD base: 0x000000d37fc000 flags: 0x0</span><br><span class="line">[    0.001366] DMAR: dmar0: reg_base_addr d37fc000 ver 1:0 <span class="built_in">cap</span> 8d2078c106f0466 ecap f020df</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>虚拟化</category>
      </categories>
      <tags>
        <tag>IOMMU</tag>
      </tags>
  </entry>
  <entry>
    <title>lspci命令详解</title>
    <url>/2021/07/19/lspci%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="PCI简介"><a href="#PCI简介" class="headerlink" title="PCI简介"></a>PCI简介</h2><p>PCI是一种外设总线规范。我们先来看一下什么是总线：总线是一种传输信号的路径或信道。典型情况是，总线是连接于一个或多个导体的电气连线，总线上连接的所有设备可在同一时间收到所有的传输内容。总线由电气接口和编程接口组成。</p>
<span id="more"></span>
<p>PCI是Peripheral Component Interconnect（外围设备互联）的简称，是普遍使用在桌面及更大型的计算机上的外 设总线。PCI架构被设计为ISA标准的替代品，它有三个主要目标：获得在计算机和外设之间传输数据时更好的性能；尽可能的平台无关；简化往系统中添加和删除外设的工作。</p>
<h2 id="PCI寻址"><a href="#PCI寻址" class="headerlink" title="PCI寻址"></a>PCI寻址</h2><p>我们先来看一个例子，我的电脑装有1G的RAM，1G以后的物理内存地址空间都是外部设备IO在系统内存地址空间上的映射。 /proc/iomem描述了系统中所有的设备I/O在内存地址空间上的映射。我们来看地址从1G开始的第一个设备在/proc/iomem中是如何描述 的：<br>        40000000-400003ff : 0000:00:1f.1<br>这是一个PCI设备，40000000-400003ff是它所映射的内存地址空间，占据了内存地址空间的1024 bytes的位置，而 0000:00:1f.1则是一个PCI外设的地址,它以冒号和逗号分隔为4个部分，第一个16位表示域，第二个8位表示一个总线编号，第三个5位表示一 个设备号，最后是3位，表示功能号。</p>
<p>因为PCI规范允许单个系统拥有高达256个总线，所以总线编号是8位。但对于大型系统而言，这是不够的，所以，引入了域的概念，每个 PCI域可以拥有最多256个总线，每个总线上可支持32个设备，所以设备号是5位，而每个设备上最多可有8种功能，所以功能号是3位。由此，我们可以得 出上述的PCI设备的地址是0号域0号总线上的31号设备上的1号功能。</p>
<p>lspci 是一个用来显示系统中所有PCI总线设备或连接到该总线上的所有设备的工具。<br>yum install pciutils</p>
<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-v</span><br><span class="line">使得 lspci 以冗余模式显示所有设备的详细信息。</span><br><span class="line">-vv</span><br><span class="line">使得 lspci 以过冗余模式显示更详细的信息 (事实上是 PCI 设备能给出的所有东西)。这些数据的确切意义没有在此手册页中解释，如果你想知道更多，请参照 /usr/include/linux/pci.h 或者 PCI 规范。</span><br><span class="line">-n</span><br><span class="line">以数字形式显示 PCI 生产厂商和设备号，而不是在 PCI ID 数据库中查找它们。</span><br><span class="line">-x</span><br><span class="line">以十六进制显示 PCI 配置空间 (configuration space) 的前64个字节映像 (标准头部信息)。此参数对调试驱动和 lspci 本身很有用。</span><br><span class="line">-xxx</span><br><span class="line">以十六进制显示所有 PCI 配置空间的映像。此选项只有 root 可用，并且很多 PCI 设备在你试图读取配置空间的未定义部分时会崩溃 (此操作可能不违反PCI标准，但是它至少非常愚蠢)。</span><br><span class="line">-b</span><br><span class="line">以总线为中心进行查看。显示所有 IRQ 号和记忆体地址，就像 PCI 总线上的卡看到的一样，而不是核心看到的内容。</span><br><span class="line">-t</span><br><span class="line">以树形方式显示包含所有总线、桥、设备和它们的连接的图表。</span><br><span class="line">-s [[&lt;bus&gt;]:][&lt;slot&gt;][.[&lt;func&gt;]]</span><br><span class="line">仅显示指定总线、插槽上的设备或设备上的功能块信息。设备地址的任何部分都可以忽略，或以「*」代替 (意味著所有值)。所有数字都是十六进制。例如：「0：」指的是在0号总线上的所有设备；「0」指的是在任意总线上0号设备的所有功能块；「0.3」选择 了所有总线上0号设备的第三个功能块；「.4」则是只列出每一设备上的第四个功能块。</span><br><span class="line">-d [&lt;vendor&gt;]:[&lt;device&gt;]</span><br><span class="line">只显示指定生产厂商和设备 ID 的设备。 这两个 ID 都以十六进制表示，可以忽略或者以「*」代替 (意味著所有值)。</span><br><span class="line">-i &lt;file&gt;</span><br><span class="line">使用 &lt;file&gt; 作为 PCI ID 数据库而不是使用预设的 /usr/share/hwdata/pci.ids。</span><br><span class="line">-p &lt;<span class="built_in">dir</span>&gt;</span><br><span class="line">使用 &lt;<span class="built_in">dir</span>&gt; 作为包含 PCI 总线信息的目录而不是使用预设的目录 /proc/bus/pci。</span><br><span class="line">-m</span><br><span class="line">以机器可读的方式转储 PCI 设备数据 (支持两种模式：普通和冗余)，便於稿本解析。</span><br><span class="line">-M</span><br><span class="line">使用总线映射模式，这种模式对总线进行全面地扫描以查明总线上的所有设备，包括配置错误的桥之后的设备。请注意，此操作只应在调试时使 用，并可能造成系统崩溃 (只在设备有错误的时候，但是不幸的是它们存在)，此命令只有 root 可以使用。同时，在不直接接触硬体的 PCI 访问模式中使用 -M 参数没有意义，因为显示的结果 (排除 lspci 中的 bug 的影响) 与普通的列表模式相同。</span><br><span class="line">--version</span><br><span class="line">显示 lspci 的版本。这个选项应当单独使用。</span><br><span class="line"></span><br><span class="line">PCILIB 选项 PCILIB OPTIONS</span><br><span class="line">PCI 工具使用 PCILIB (一种可移植的库，提供平台独立的函数来访问 PCI 配置空间)来和PCI卡交互。下面的选项用来控制库参数，特别是所用访问模式的指定。预设情况下，PCILIB 使用第一种可用的访问模式，不会显示任何调试信息。每一个开关选项都列出了一组它所支持的硬件/软软件列表。</span><br><span class="line">-P &lt;<span class="built_in">dir</span>&gt;</span><br><span class="line">使用 linux 2.1 风格的配置，直接访问目录 &lt;<span class="built_in">dir</span>&gt; 而非 /proc/bus/pci 目录。(只能在linux 2.1或以上版本中使用)</span><br><span class="line">-H1</span><br><span class="line">通过 Intel 架构 1 来实现直接硬体访问。(只能用於 i386 及其相容机)</span><br><span class="line">-H2</span><br><span class="line">通过Intel 架构2来实现直接硬体访问。警告：此模式只能寻址任何总线上的前16个设备，并且在很多情况下相当不可靠。(只能用於 i386 及其相容机)</span><br><span class="line">-S</span><br><span class="line">使用 PCI 系统调用访问。(只能用於 Alpha 和 Ultra-Sparc 上的 Linux)</span><br><span class="line">-F &lt;file&gt;</span><br><span class="line">从所给的包含 lspci -x命令输出的档案中获取相关信息。这在分析使用者提交的错误报告时很有用，因为你可以用任何方式来显示硬体配置信息而无需为了获取更多信息打扰使用者。(可用於所有系统)</span><br><span class="line">-G</span><br><span class="line">增加库的调试等级。(可用於所有系统)</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>实例1：不必加上任何选项，就能够显示出目前的硬件配备</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lspci</span></span><br><span class="line">00:00.0 Host bridge: Intel Corporation 3200/3210 Chipset DRAM Controller  //主板芯片</span><br><span class="line">00:19.0 Ethernet controller: Intel Corporation 82566DM-2 Gigabit Network Connection (rev 02)</span><br><span class="line">00:1a.0 USB Controller: Intel Corporation 82801I (ICH9 Family) USB UHCI Controller <span class="comment">#4 (rev 02)</span></span><br><span class="line">00:1a.1 USB Controller: Intel Corporation 82801I (ICH9 Family) USB UHCI Controller <span class="comment">#5 (rev 02)</span></span><br><span class="line">00:1a.2 USB Controller: Intel Corporation 82801I (ICH9 Family) USB UHCI Controller <span class="comment">#6 (rev 02)</span></span><br><span class="line">00:1a.7 USB Controller: Intel Corporation 82801I (ICH9 Family) USB2 EHCI Controller <span class="comment">#2 (rev 02)  //USB控制器</span></span><br><span class="line">00:1c.0 PCI bridge: Intel Corporation 82801I (ICH9 Family) PCI Express Port 1 (rev 02)  //接口插槽</span><br><span class="line">00:1c.4 PCI bridge: Intel Corporation 82801I (ICH9 Family) PCI Express Port 5 (rev 02)</span><br><span class="line">00:1d.0 USB Controller: Intel Corporation 82801I (ICH9 Family) USB UHCI Controller <span class="comment">#1 (rev 02)</span></span><br><span class="line">00:1d.1 USB Controller: Intel Corporation 82801I (ICH9 Family) USB UHCI Controller <span class="comment">#2 (rev 02)</span></span><br><span class="line">00:1d.2 USB Controller: Intel Corporation 82801I (ICH9 Family) USB UHCI Controller <span class="comment">#3 (rev 02)</span></span><br><span class="line">00:1d.7 USB Controller: Intel Corporation 82801I (ICH9 Family) USB2 EHCI Controller <span class="comment">#1 (rev 02)</span></span><br><span class="line">00:1e.0 PCI bridge: Intel Corporation 82801 PCI Bridge (rev 92)</span><br><span class="line">00:1f.0 ISA bridge: Intel Corporation 82801IR (ICH9R) LPC Interface Controller (rev 02)</span><br><span class="line">00:1f.2 IDE interface: Intel Corporation 82801IR/IO/IH (ICH9R/DO/DH) 4 port SATA IDE Controller (rev 02)</span><br><span class="line">00:1f.3 SMBus: Intel Corporation 82801I (ICH9 Family) SMBus Controller (rev 02)</span><br><span class="line">00:1f.5 IDE interface: Intel Corporation 82801I (ICH9 Family) 2 port SATA IDE Controller (rev 02)</span><br><span class="line">02:00.0 VGA compatible controller: Matrox Graphics, Inc. MGA G200e [Pilot] ServerEngines (SEP1) (rev 02)  //显卡</span><br><span class="line">03:02.0 Ethernet controller: Intel Corporation 82541GI Gigabit Ethernet Controller (rev 05)  //网卡</span><br></pre></td></tr></table></figure>

<p>实例2：查看一般详细信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lspci -v</span></span><br><span class="line">00:00.0 Host bridge: Intel Corporation 3200/3210 Chipset DRAM Controller</span><br><span class="line">        Subsystem: Intel Corporation Unknown device 34d0</span><br><span class="line">        Flags: bus master, fast devsel, latency 0</span><br><span class="line">        Capabilities: [e0] Vendor Specific Information</span><br><span class="line"></span><br><span class="line">00:19.0 Ethernet controller: Intel Corporation 82566DM-2 Gigabit Network Connection (rev 02)</span><br><span class="line">        Subsystem: Intel Corporation Unknown device 34d0</span><br><span class="line">        Flags: bus master, fast devsel, latency 0, IRQ 50</span><br><span class="line">        Memory at e1a00000 (32-bit, non-prefetchable) [size=128K]</span><br><span class="line">        Memory at e1a20000 (32-bit, non-prefetchable) [size=4K]</span><br><span class="line">        I/O ports at 20e0 [size=32]</span><br><span class="line">        Capabilities: [c8] Power Management version 2</span><br><span class="line">        Capabilities: [d0] Message Signalled Interrupts: 64bit+ Queue=0/0 Enable+</span><br><span class="line">        Capabilities: [e0] <span class="comment">#13 [0306]</span></span><br></pre></td></tr></table></figure>

<p>实例3：查看网卡详细信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lspci -s 03:02.0 -vv  //-s后面接的是每个设备的总线、插槽与相关函数功能</span></span><br><span class="line">03:02.0 Ethernet controller: Intel Corporation 82541GI Gigabit Ethernet Controller (rev 05)</span><br><span class="line">        Subsystem: Intel Corporation Unknown device 34d0</span><br><span class="line">        Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV+ VGASnoop- ParErr+ Stepping- SERR+ FastB2B-</span><br><span class="line">        Status: Cap+ 66MHz+ UDF- FastB2B- ParErr- DEVSEL=medium &gt;TAbort- &lt;tabort- &lt;mabort- &gt;SERR- &lt;perr-</span><br><span class="line">        Latency: 32 (63750ns min), Cache Line Size: 64 bytes</span><br><span class="line">        Interrupt: pin A routed to IRQ 209</span><br><span class="line">        Region 0: Memory at e1920000 (32-bit, non-prefetchable) [size=128K]</span><br><span class="line">        Region 1: Memory at e1900000 (32-bit, non-prefetchable) [size=128K]</span><br><span class="line">        Region 2: I/O ports at 1000 [size=64]</span><br><span class="line">        Expansion ROM at fffe0000 [disabled] [size=128K]</span><br><span class="line">        Capabilities: [dc] Power Management version 2</span><br><span class="line">                Flags: PMEClk- DSI+ D1- D2- AuxCurrent=0mA PME(D0+,D1-,D2-,D3hot+,D3cold+)</span><br><span class="line">                Status: D0 PME-Enable- DSel=0 DScale=1 PME-</span><br><span class="line">        Capabilities: [e4] PCI-X non-bridge device</span><br><span class="line">                Command: DPERE- ERO+ RBC=512 OST=1</span><br><span class="line">                Status: Dev=00:00.0 64bit- 133MHz- SCD- USC- DC=simple DMMRBC=2048 DMOST=1 DMCRS=8 RSCEM- 266MHz- 533MHz-</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>lspci</tag>
      </tags>
  </entry>
  <entry>
    <title>fvisibility=hidden</title>
    <url>/2021/07/18/fvisibility-hidden/</url>
    <content><![CDATA[<h2 id="fvisibility-hidden作用"><a href="#fvisibility-hidden作用" class="headerlink" title="-fvisibility=hidden作用"></a>-fvisibility=hidden作用</h2><p>将编译出的库文件中的全局变量符号默认隐藏，防止其他程序调用库文件时出现重定义。也可以降低库文件体积。</p>
<span id="more"></span>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>主程序依赖了两个库libA的funcA函数和libB的funcB函数<br><strong>main.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">funcA</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">funcB</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d,&quot;</span>, funcA(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, funcB(<span class="number">2</span>, <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">**liba.c**</span><br><span class="line">```c</span><br><span class="line"><span class="type">int</span> <span class="title function_">subfunc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">funcA</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> subfunc(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>libb.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">subfunc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">funcB</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> subfunc(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -f libA.so libB.so main</span><br><span class="line">gcc -fPIC liba.c -shared -o libA.so</span><br><span class="line">gcc -fPIC libb.c -shared -o libB.so</span><br><span class="line">gcc main.c libA.so libB.so -o main</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong><br><img src="eefdc77e82b9cbadccd45e0e83b16f4758b493327b1ee1736658e9e810b6372c.png" alt="图 1">  </p>
<p>我们期望的结果是3,1（funcA和funcB各自调用不同的subfunc实现），<br>实际得到的结果是3,3（funcA和funcB都调用了libA中的subfunc实现）</p>
<p><strong>原因</strong><br>通过readelf来查看符号<br><img src="7e685f4834076186e497417d5c80932a17667542dfa6203c740864092acd7d5a.png" alt="图 2"><br>可见libA和libB里面都有subfunc符号，名字完全一样，而且都是GLOBAL的</p>
<p>GLOBAL的符号即全局的符号，同名的全局符号会被认为是同一个符号，由于main先加载了libA，得到了libA中的subfunc符号，再加载libB时，就把libB中的subfunc忽略了。</p>
<p><strong>解决</strong><br>这其实是符号的可见性（Symbol Visibility）问题，既然有GLOBAL符号，那自然会有LOCAL符号，LOCAL的符号只在当前lib可见，全局不可见。</p>
<p>如何将符号变成LOCAL的呢，最直接的就是加上visibility为hidden的标志，修改后的liba.c：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__attribute__ ((visibility (<span class="string">&quot;hidden&quot;</span>))) <span class="type">int</span> <span class="title function_">subfunc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">funcA</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> subfunc(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>libb.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__attribute__ ((visibility (<span class="string">&quot;hidden&quot;</span>)))  <span class="type">int</span> <span class="title function_">subfunc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">funcB</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> subfunc(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果</strong><br><img src="e0a264c543971f85042cb0c09d9a2c8218c01f5b7fd72b557b1c812c3fdab8de.png" alt="图 3">  </p>
<h2 id="默认LOCAL"><a href="#默认LOCAL" class="headerlink" title="默认LOCAL"></a>默认LOCAL</h2><p>上面的方法可以解决问题，但是，实际情况往往是，libA里面有很多的内部函数，而暴露给外部的只有少数，能不能指定少数符号为GLOBAL，其它的都是LOCAL呢？答案是肯定的，修改<strong>liba.c</strong>如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">subfunc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__ ((visibility (<span class="string">&quot;default&quot;</span>))) <span class="type">int</span> <span class="title function_">funcA</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> subfunc(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>libb.c</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">subfunc</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__ ((visibility (<span class="string">&quot;default&quot;</span>))) <span class="type">int</span> <span class="title function_">funcB</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> subfunc(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>编译</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -f libA.so libB.so main</span><br><span class="line">gcc -fPIC liba.c -shared -fvisibility=hidden -o libA.so</span><br><span class="line">gcc -fPIC libb.c -shared -fvisibility=hidden -o libB.so</span><br><span class="line">gcc main.c libA.so libB.so -o main</span><br></pre></td></tr></table></figure>


<p><strong>运行结果</strong><br><img src="dcbe3d8944d6925a987d1dffae1a1646783b71dede5a110ecee878882ca2c1b7.png" alt="图 4">  </p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>visibility</tag>
      </tags>
  </entry>
  <entry>
    <title>Bsymbolic</title>
    <url>/2021/07/17/Bsymbolic/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>-Wl,option<br>Pass option as an option to the linker. If option contains commas, it is split into multiple options at the commas. You can use this syntax to pass an argument to the option. For example, -Wl,-Map,output.map passes -Map output.map to the linker. When using the GNU linker, you can also get the same effect with -Wl,-Map=output.map.</p>
</blockquote>
<span id="more"></span>

<p>-Wl,-Bsymbolic 其中 Wl 表示将紧跟其后的参数，传递给连接器 ld。Bsymbolic 表示强制采用本地的全局变量定义，这样就不会出现动态链接库的全局变量定义被应用程序 / 动态链接库中的同名定义给覆盖了</p>
<h2 id="Bsymbolic与-attribute-constructor"><a href="#Bsymbolic与-attribute-constructor" class="headerlink" title="Bsymbolic与__attribute__((constructor))"></a>Bsymbolic与__attribute__((constructor))</h2><p>如果动态库不加-Wl,-Bsymbolic，则会出现ldopen时构造函数中再调用非静态函数，此时在非静态函数中，出现的全局静态变量的地址与本进程中的同名变量的地址相同</p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><h3 id="test-so-c"><a href="#test-so-c" class="headerlink" title="test_so.c"></a>test_so.c</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONSTRUCTOR_PRIO(func) \</span></span><br><span class="line"><span class="meta">static void __attribute__((constructor(101), used)) func(void)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DESTRUCTOR_PRIO(func) \</span></span><br><span class="line"><span class="meta">static void __attribute__((destructor(101), used)) func(void)</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> g_test;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;inner func\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;g_test(pointer) %p\n&quot;</span>, &amp;g_test);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CONSTRUCTOR_PRIO(test_cons)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;constructor begin\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;outer func\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;g_test(pointer) %p\n&quot;</span>, &amp;g_test);</span><br><span class="line"></span><br><span class="line">    test2();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;constructor end\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DESTRUCTOR_PRIO(test_des)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;g_test(pointer) %p\n&quot;</span>, &amp;g_test);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="test-c"><a href="#test-c" class="headerlink" title="test.c"></a>test.c</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n\ndlopen begin\n&quot;</span>);</span><br><span class="line">    <span class="type">void</span> *handle = dlopen(<span class="string">&quot;./libtest.so&quot;</span>, RTLD_LAZY);</span><br><span class="line">    <span class="keyword">if</span> (handle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;handle is null, %s\n&quot;</span>, dlerror());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;dlopen end\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    dlclose(handle);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="so编译（不加上-Wl-Bsymbolic）"><a href="#so编译（不加上-Wl-Bsymbolic）" class="headerlink" title="so编译（不加上-Wl,-Bsymbolic）"></a>so编译（不加上-Wl,-Bsymbolic）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -f test_so.o libtest.so</span><br><span class="line">gcc -fPIC -c  test_so.c</span><br><span class="line">gcc -o libtest.so  -shared -fPIC test_so.c</span><br></pre></td></tr></table></figure>

<h3 id="程序运行结果"><a href="#程序运行结果" class="headerlink" title="程序运行结果"></a>程序运行结果</h3><p><img src="e783a55f5f5ac989581c9f0322a7881167a73232521c12bb59905117e68f86fa.png" alt="图 1">  </p>
<h3 id="so编译（加上-Wl-Bsymbolic）"><a href="#so编译（加上-Wl-Bsymbolic）" class="headerlink" title="so编译（加上-Wl,-Bsymbolic）"></a>so编译（加上-Wl,-Bsymbolic）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -f test_so.o libtest.so</span><br><span class="line">gcc -fPIC -c  test_so.c</span><br><span class="line">gcc -o libtest.so -Wl,-Bsymbolic -shared -fPIC test_so.c</span><br></pre></td></tr></table></figure>

<h3 id="程序运行结果-1"><a href="#程序运行结果-1" class="headerlink" title="程序运行结果"></a>程序运行结果</h3><p><img src="7dfdbc135513512c1e754a1d21e7cf98d966d4677d88974b039f8e718d77551a.png" alt="图 2">  </p>
<h3 id="so编译（不加上-Wl-Bsymbolic），并且使用静态调用函数"><a href="#so编译（不加上-Wl-Bsymbolic），并且使用静态调用函数" class="headerlink" title="so编译（不加上-Wl,-Bsymbolic），并且使用静态调用函数"></a>so编译（不加上-Wl,-Bsymbolic），并且使用静态调用函数</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> -f test_so.o libtest.so</span><br><span class="line">gcc -fPIC -c  test_so.c</span><br><span class="line">gcc -o libtest.so  -shared -fPIC test_so.c</span><br></pre></td></tr></table></figure>

<p>修改前</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;inner func\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;g_test(pointer) %p\n&quot;</span>, &amp;g_test);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改后</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">test2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;inner func\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;g_test(pointer) %p\n&quot;</span>, &amp;g_test);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="程序运行结果-2"><a href="#程序运行结果-2" class="headerlink" title="程序运行结果"></a>程序运行结果</h3><p><img src="07ce0cda8e361209f6ac586d23de3a81afa35713a00eabb940a57a2ef2f7dd54.png" alt="图 3">  </p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>Bsymbolic</tag>
      </tags>
  </entry>
  <entry>
    <title>/var/run目录</title>
    <url>/2021/07/16/var-run%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>/var/run</code> 是 Linux 和 Unix 系统上的一个目录，通常用于存储临时运行时文件，如 <code>PID</code> 文件（记录进程 ID）、套接字（<code>socket</code>）和管道（<code>pipe</code>）等。这些文件通常在系统启动时被创建，并在系统运行时用于进程间通信、网络通信等场景。</p>
<span id="more"></span>

<p>这个目录在系统启动时被创建，并且通常被 <code>systemd-tmpfiles</code> 工具用于创建运行时文件。这个目录通常由 root 用户创建，因此只有 root 用户和具有特殊权限的用户才能在这个目录中创建、修改或删除文件。</p>
<p>需要注意的是，<code>/var/run</code>目录是一个运行时文件系统，这意味着它存储在内存中，<strong>并在系统重启后被清空</strong>。因此，如果您需要在系统重启后保留某些数据，应该将它们存储在持久化的文件系统中，例如 /var/lib 或其他可持久化目录。</p>
<p>总之，<code>/var/run</code> 目录是一个用于存储临时运行时文件的目录，通常由系统在启动时创建，并在系统运行时用于进程间通信、网络通信等场景。</p>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>/var/run</tag>
      </tags>
  </entry>
  <entry>
    <title>__attribute__((constructor))</title>
    <url>/2021/07/15/attribute-constructor/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote>
<p>Shared objects may export functions using the<br><strong>attribute</strong>((constructor)) and <strong>attribute</strong>((destructor))<br>function attributes.  Constructor functions are executed before<br>dlopen() returns, and destructor functions are executed before<br>dlclose() returns.  A shared object may export multiple<br>constructors and destructors, and priorities can be associated<br>with each function to determine the order in which they are<br>executed.  See the gcc info pages (under “Function attributes”)<br>for further information.</p>
</blockquote>
<span id="more"></span>


<h2 id="dlopen与-attribute-constructor"><a href="#dlopen与-attribute-constructor" class="headerlink" title="dlopen与__attribute__((constructor))"></a>dlopen与__attribute__((constructor))</h2><p>函数设置__attribute__((constructor))属性，在dlopen时，会先调用该方法。</p>
<p>设置__attribute__((destructor))属性，在dlclose时会调用该方法。</p>
<h2 id="设置优先级"><a href="#设置优先级" class="headerlink" title="设置优先级"></a>设置优先级</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span>  __attribute__((constructor(<span class="number">101</span>))) <span class="type">void</span> <span class="title function_">before1</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;before1\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span>  __attribute__((constructor(<span class="number">102</span>))) <span class="type">void</span> <span class="title function_">before2</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;before2\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span>  __attribute__((constructor(<span class="number">103</span>))) <span class="type">void</span> <span class="title function_">before3</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;before3\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上三个函数会依照优先级的顺序调用.括号内的数值（101，102，103）代表优先级，另外，这个1-100的范围是保留的.<br>即constructor的优先级，数值越小，越先调用。destructor中的数值越大，越先调用。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>so代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">__attribute__((constructor)) <span class="type">void</span> <span class="title function_">test_cons</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test constructor\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__attribute__((destructor)) <span class="type">void</span> <span class="title function_">test_des</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test destructor\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;test body\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>so编译</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -fPIC -shared test.c -o  libtest.so</span><br></pre></td></tr></table></figure>


<p><strong>main代码</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(*testFunc)</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">void</span> *handle = dlopen(<span class="string">&quot;./libtest.so&quot;</span>, RTLD_LAZY);</span><br><span class="line">    <span class="keyword">if</span> (handle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;handle is null, %s\n&quot;</span>, dlerror());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;----------\n&quot;</span>);</span><br><span class="line">    testFunc f = (testFunc)dlsym(handle, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;f is null\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    f();</span><br><span class="line">    dlclose(handle);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>main编译</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc main.c -ldl -O0 -g -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p><strong>测试结果</strong><br><img src="fc5860c6b8b2c801b0576d57de04d010b45726ef08639e48235b6158842320dc.png" alt="图 1">  </p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>constructor</tag>
      </tags>
  </entry>
  <entry>
    <title>dd命令测试磁盘读写</title>
    <url>/2021/07/14/dd%E5%91%BD%E4%BB%A4%E6%B5%8B%E8%AF%95%E7%A3%81%E7%9B%98%E8%AF%BB%E5%86%99/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Linux 中用 dd 命令来测试硬盘读写速度<br>dd 是 Linux/UNIX 下的一个非常有用的命令，作用是用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=path/to/input_file of=/path/to/output_file bs=block_size count=number_of_blocks</span><br></pre></td></tr></table></figure>
<span id="more"></span>


<h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><table>
    <tr>
        <th>参数</th><th>说明</th>
    </tr>
    <tr>
        <td>if=file</td><td>输入文件名，缺省为标准输入</td>
    </tr>
    <tr>
        <td>of=file</td><td>输出文件名，缺省为标准输出</td>
    </tr>
    <tr>
        <td>obs=bytes</td><td>一次写 bytes 个字节(即一个块大小为 bytes 个字节)</td>
    </tr>
    <tr>
        <td>ibs=bytes</td><td>一次读入 bytes 个字节(即一个块大小为 bytes 个字节)</td>
    </tr>
    <tr>
        <td>bs=bytes</td><td>同时设置读写块的大小为 bytes ，可代替 ibs 和 obs</td>
    </tr>
    <tr>
        <td>cbs=bytes</td><td>一次转换 bytes 个字节，即转换缓冲区大小</td>
    </tr>
    <tr>
        <td>skip=blocks</td><td>从输入文件开头跳过 blocks 个块后再开始复制</td>
    </tr>
    <tr>
        <td>seek=blocks</td><td>从输出文件开头跳过 blocks 个块后再开始复制(通常只有当输出文件是磁盘或磁带时才有效)</td>
    </tr>
    <tr>
        <td>count=blocks</td><td>仅拷贝 blocks 个块，块大小等于 bs 指定的字节数</td>
    </tr>
</table>


<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="两个特殊的设备"><a href="#两个特殊的设备" class="headerlink" title="两个特殊的设备"></a>两个特殊的设备</h3><p><code>/dev/null</code>：回收站、无底洞。<br><code>/dev/zero</code>：产生空字符，不产生IO。</p>
<h3 id="测试磁盘写能力"><a href="#测试磁盘写能力" class="headerlink" title="测试磁盘写能力"></a>测试磁盘写能力</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/testw.dbf bs=4k count=100000</span><br></pre></td></tr></table></figure>
<p>因为/dev/zero是一个伪设备，它只产生空字符流，对它不会产生IO，所以，IO都会集中在of文件中，of文件只用于写，所以这个命令相当于测试磁盘的写能力。命令结尾添加oflag=direct将跳过内存缓存，添加oflag=sync将跳过hdd缓存。</p>
<h3 id="测试磁盘读能力"><a href="#测试磁盘读能力" class="headerlink" title="测试磁盘读能力"></a>测试磁盘读能力</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/sdb of=/dev/null bs=4k</span><br></pre></td></tr></table></figure>
<p>因为/dev/sdb是一个物理分区，对它的读取会产生IO，/dev/null是伪设备，相当于黑洞，of到该设备不会产生IO，所以，这个命令的IO只发生在/dev/sdb上，也相当于测试磁盘的读能力。（Ctrl+c终止测试）</p>
<h3 id="测试同时读写能力"><a href="#测试同时读写能力" class="headerlink" title="测试同时读写能力"></a>测试同时读写能力</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/sdb of=/testrw.dbf bs=4k</span><br></pre></td></tr></table></figure>
<p>在这个命令下，一个是物理分区，一个是实际的文件，对它们的读写都会产生IO（对/dev/sdb是读，对/testrw.dbf是写），假设它们都在一个磁盘中，这个命令就相当于测试磁盘的同时读写能力。</p>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>dd</tag>
      </tags>
  </entry>
  <entry>
    <title>内存文件系统</title>
    <url>/2021/07/13/%E5%86%85%E5%AD%98%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="什么是tmpfs"><a href="#什么是tmpfs" class="headerlink" title="什么是tmpfs"></a>什么是tmpfs</h2><p>tmpfs是 Linux系统自带的一种基于内存的文件系统</p>
<span id="more"></span>

<p>优势：<br>速度快<br>tmpfs 的另一个主要的好处是它闪电般的速度。因为典型的 tmpfs 文件系统会完全驻留在内存中，读写几乎可以是瞬间的。</p>
<p>动态大小<br>tmpfs最初会只有很小的空间，但随着文件的增大，tmpfs文件系统会动态分配更多的实际内存。</p>
<p>缺点：<br>系统重启后，数据全部消失。<br>相对于磁盘，受限于物理内存，其空间大小有限。</p>
<p>典型应用场景:<br>临时文件处理<br>临时日志存放<br>内存数据库</p>
<h2 id="tmpfs-文件系统创建"><a href="#tmpfs-文件系统创建" class="headerlink" title="tmpfs 文件系统创建"></a>tmpfs 文件系统创建</h2><p>操作系统自带的一些tmpfs文件系统。<br><img src="915fb3120771ee4136bc0de200a52e8d2c5b0d45c225c50faa6c652895baa8a3.png" alt="图 1">  </p>
<p>创建tmpfs文件系统：</p>
<p><img src="fc479ed2abf81d6efd82688f5c526d8854a1a427ca0f42b52e7b4439106fd52c.png" alt="图 2">  </p>
<p>或者使用已经mount的内存文件系统</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /dev/shm/tmp</span><br><span class="line"><span class="built_in">chmod</span> 1777 /dev/shm/tmp</span><br><span class="line">mount --<span class="built_in">bind</span> /dev/shm/tmp/ <span class="built_in">log</span>/</span><br></pre></td></tr></table></figure>

<h2 id="性能测试机"><a href="#性能测试机" class="headerlink" title="性能测试机"></a>性能测试机</h2><p>华为服务器<br>产品型号：RH2288V3<br>CPU：Intel E5-2620V4<em>2 @2.10GHz<br>内存：2</em>16G 2666<br>万兆网卡双端口+千兆网卡双端口</p>
<p>操作系统：CentOS Linux release 7.4.1708 (Core)<br>Linux内核： 3.10.0-693.el7.x86_64</p>
<h2 id="tmpfs写性能测试"><a href="#tmpfs写性能测试" class="headerlink" title="tmpfs写性能测试"></a>tmpfs写性能测试</h2><p>测试脚本<br><img src="3a9a94107f9767d457e13d7488ba17eea7a97a7e2657a6742b1c6d536a83ea74.png" alt="图 5">  </p>
<p>测试结果：<br><img src="b5e54a8483d488cdc47f326f4d5fa88587d161640e238b5f95d71d97a0ad825f.png" alt="图 6"><br>每次写入块大小越大，性能越好。<br>每次写入大小16K以上，接近最大性能。</p>
<h2 id="tmpfs读性能测试"><a href="#tmpfs读性能测试" class="headerlink" title="tmpfs读性能测试"></a>tmpfs读性能测试</h2><p>测试脚本<br><img src="5301421a2e0c43af05f036046745bce4cf5e5c94c78caea96df4b74b4a628c04.png" alt="图 7"> </p>
<p>测试结果：<br><img src="5d90075e27d4a6d012c780366cc9f068a73acfe1b7620e98d9ec329d5d19687a.png" alt="图 8"><br>每次读入块越大，性能越好。<br>块大小16KB以上，基本可达到最大性能。</p>
<h2 id="tmpfs并发写性能测试-10"><a href="#tmpfs并发写性能测试-10" class="headerlink" title="tmpfs并发写性能测试(10)"></a>tmpfs并发写性能测试(10)</h2><p>测试脚本<br><img src="7c73b81de6f4b180f88d77c4cf4a096687d09c25dd55d5a8839bae96e8eea4c5.png" alt="图 10">  </p>
<p>测试结果<br><img src="33a034c520cef4ea8b9421ee90e3f4719d3788b819f199de5a06f310ea2a11f2.png" alt="图 11"><br>结论： 在10个并发写时，可以认为写能力是线性倍数增加的</p>
<h2 id="tmpfs并发写性能测试-20"><a href="#tmpfs并发写性能测试-20" class="headerlink" title="tmpfs并发写性能测试(20)"></a>tmpfs并发写性能测试(20)</h2><p>测试脚本<br><img src="3871f4f9d492e2e8c4862a9d3d48cb6b7bad19104a8981c308df991c4f63655c.png" alt="图 12">  </p>
<p>测试结果<br><img src="f2d74faa4c197f1321cd42e20752ccfce38174cc421d53877f4877490af4abe9.png" alt="图 14">  </p>
<p>结论： 内存写总带宽受限，接近20GB/s.</p>
<h2 id="tmpfs并发读性能测试-10"><a href="#tmpfs并发读性能测试-10" class="headerlink" title="tmpfs并发读性能测试(10)"></a>tmpfs并发读性能测试(10)</h2><p>测试脚本<br><img src="0cb0831a0d23985571a9abc55478b69ddceae6eb7592c71db03a62537644860e.png" alt="图 15">  </p>
<p>测试结果<br><img src="76d191a9e7c4a401a146a9fc688bab5c85870cc7c6606f12f8df2e416b6f790a.png" alt="图 16">  </p>
<p>结论： 内存读总带宽受限，接近 20GB/s.<br>对比：单个读的性能<br><img src="2512820569b9e8921e984905686d1220d23a1f336a3d91f627ca52d4d9ff9304.png" alt="图 17">  </p>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>tmpfs</tag>
      </tags>
  </entry>
  <entry>
    <title>ubuntu设置默认启动内核</title>
    <url>/2021/07/12/ubuntu%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/</url>
    <content><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>适用于<code>Ubuntu16.04</code>操作系统与云服务器设置默认启动内核，其他Ubuntu版本可能存在差异。</p>
<span id="more"></span>

<h2 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h2><p>打开/etc/default/grub文件（以启动第三内核为例），修改GRUB_DEFAULT的值为”1&gt;2”。<br><img src="962143b0c70490293f0a95a9e9f8049b6d71d6dfd3699e7b842d30518b53d7e6.png" alt="图 1">  </p>
<p>1&gt;2中的1指的是主菜单第二个选项<br><img src="0517dea18b1cdd8a82f4f35bf62972cbc4994872afea2752a0ecc19c405bbe6b.png" alt="图 2">  </p>
<p>1&gt;2中的2指的是主菜单第二个选项中的第三个启动内核选项。<br><img src="d15c9f89f92ee7a97b622c4ff3dd503777ac094c4d777c38ff6451309c7279e8.png" alt="图 3">  </p>
<p>执行以下命令，重新生成grub配置文件。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># update-grub</span></span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li>1&gt;2中的&gt;分隔符号前后不带空格。</li>
<li>整个条目使用一组引号。</li>
</ul>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>内核编译</title>
    <url>/2021/07/11/%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>整个内核编译的过程非常简单，但是内核编译需要花费比较长的时间。这主要是因为内核的代码非常多。当然，如果你​的​计算机性能强劲，时间会短很多。另外需要注意的是，建议在虚拟机环境下编译，这样避免错误导致系统问题。如果在虚拟机测试，建议系统分区和内核源代码分区的大小大于20GB。</p>
<span id="more"></span>

<h2 id="内核编译升级参考"><a href="#内核编译升级参考" class="headerlink" title="内核编译升级参考"></a>内核编译升级参考</h2><p><a href="https://blog.csdn.net/qq_36393978/article/details/118391685">https://blog.csdn.net/qq_36393978/article/details/118391685</a><br><a href="https://www.cnblogs.com/leebri/p/16786685.html">https://www.cnblogs.com/leebri/p/16786685.html</a></p>
<h2 id="下载源代码"><a href="#下载源代码" class="headerlink" title="下载源代码"></a>下载源代码</h2><p>进入Linux 内核的<a href="https://www.kernel.org/">官网</a>，下载最新版本，或者其它版本的内核代码。这里是源代码的压缩包。<br><img src="d92fb39bd747672fed2ad585d565d37e1dcfe4af2c94964960a51efb120af470.png" alt="图 1">  </p>
<p>解压</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xvf linux-6.2.9.tar.xz</span><br></pre></td></tr></table></figure>

<h2 id="安装编译软件包"><a href="#安装编译软件包" class="headerlink" title="安装编译软件包"></a>安装编译软件包</h2><p>以Ubuntu 18.04的编译环境为例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison</span><br></pre></td></tr></table></figure>

<h2 id="配置内核代码"><a href="#配置内核代码" class="headerlink" title="配置内核代码"></a>配置内核代码</h2><p>在编译内核之前，我们可以对内核源代码进行配置。配置的目的主要是确定哪些模块会编译到内核当中。</p>
<p>1、进入源代码目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> linux-6.2.9</span><br></pre></td></tr></table></figure>

<p>2、从当前机器的启动目录拷贝配置信息到源代码目录。这步操作的意思是我们编译内核的配置采用用当前环境一致的配置。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> -v /boot/config-$(<span class="built_in">uname</span> -r) .config </span><br></pre></td></tr></table></figure>

<p>3、可以通过如下命令启动配置界面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>
<p>下面是打开的配置界面。可以看出里面包含所有的内核组件，包括文件系统，网络，IO栈，虚拟化和设备驱动等等。如果你不熟悉，可以不做任何修改。</p>
<p><img src="a6d117a1954b223a19e88110f48a98471a79242d32e4ae603d9ef67344b473ac.png" alt="图 2">  </p>
<h2 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h2><p>1、编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make -j 10</span><br></pre></td></tr></table></figure>
<p>编译时，需要回答 make 命令的问题，一直按enter即可</p>
<p>2、安装模块</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo make modules_install</span><br></pre></td></tr></table></figure>
<p><img src="58abd2c78b809c57b0985723dae8b110d6b8c3e5e01f25629b9760d666be94d2.png" alt="图 4">  </p>
<p>3、安装内核</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo make install</span><br></pre></td></tr></table></figure>
<p><img src="fc908b9512fe78df1c8f82c91c9b8d7bce994a08a8cb1c9a1097fbe35216b26a.png" alt="图 5">  </p>
<p>4、启用内核作为引导<br>一旦 make install 命令完成了，就是时候将内核启用来作为引导。使用这个命令来实现：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo update-initramfs -c -k 6.2.9</span><br></pre></td></tr></table></figure>
<p>当然，你需要将上述内核版本号替换成你编译完的。当命令执行完毕后，使用如下命令来更新 grub：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo update-grub</span><br></pre></td></tr></table></figure>
<p>现在你可以重启系统并且选择新安装的内核了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>

<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">uname</span> -r</span><br></pre></td></tr></table></figure>
<p>如果后面开发内核模块，也是要基于内核代码树的，因此这个是内核开发的基础。</p>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>内核模块ko编译</title>
    <url>/2021/07/10/%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97ko%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h2 id="加载内核简介"><a href="#加载内核简介" class="headerlink" title="加载内核简介"></a>加载内核简介</h2><p>Linux内核的整体架构本就非常庞大，其包含的组件也非常多。而我们怎样把需要的部分都包含在内核中呢？一种方法是把所有需要的功能都编译到Linux内核中。<br>这会导致两个问题，一是生成的内核会很大，二是如果我们要在现有的内核中新增或删除功能，将不得不重新编译内核。</p>
<span id="more"></span>

<p>Linux提供了这样的机制，这种机制被称为模块（Module）。可使得编译出的内核本身并不需要包含所有功能，而在这些功能需要被使用的时候，其对应的代码被动态地加载到内核中。<br>模块本身不被编译入内核映像，从而控制了内核的大小。<br>模块一旦被加载，它就和内核中的其他部分完全一样。</p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><h3 id="文件树"><a href="#文件树" class="headerlink" title="文件树"></a>文件树</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hello.c</span><br><span class="line">Makefile</span><br></pre></td></tr></table></figure>
<p>整个工程只有两个文件，一个hello.c，一个用来控制编译的Makefile。</p>
<h3 id="hello-c"><a href="#hello-c" class="headerlink" title="hello.c"></a>hello.c</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Hello World enter\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">module_init(hello_init);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Hello World exit\n &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;rma &lt;rma215@gmail.com&gt;&quot;</span>);</span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL v2&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;A simple Hello World Module&quot;</span>);</span><br><span class="line">MODULE_ALIAS(<span class="string">&quot;a simplest module&quot;</span>);</span><br></pre></td></tr></table></figure>

<h3 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h3><p>内核模块中用于输出的函数是内核空间的<code>printk()</code>而不是用户空间的<code>printf()</code>，<code>printk()</code>的用法和<code>printf()</code>基本相似，但前者可定义输出级别。<code>printk()</code>可作为一种最基本的内核调试手段。</p>
<p>一个Linux内核模块主要由如下几个部分组成。</p>
<ol>
<li><p>模块加载函数<br>当通过<code>insmod</code>或<code>modprobe</code>命令加载内核模块时，模块的加载函数会自动被内核执行，完成本模块的相关初始化工作。<br>Linux内核模块加载函数一般以__init标识声明，模块加载函数以<code>module_init</code>（函数名）的形式被指定。它返回整型值，若初始化成功，应返回0。而在初始化失败时，应该返回错误编码。在Linux内核里，错误编码是一个接近于0的负值。</p>
</li>
<li><p>模块卸载函数<br>当通过<code>rmmod</code>命令卸载某模块时，模块的卸载函数会自动被内核执行，完成与模块卸载函数相反的功能。<br>Linux内核模块加载函数一般以__exit标识声明，模块卸载函数在模块卸载的时候执行，而不返回任何值，且必须以<code>module_exit</code>（函数名）的形式来指定。</p>
</li>
<li><p>模块许可证声明许可证（LICENSE）<br>声明描述内核模块的许可权限，如果不声明LICENSE，模块被加载时，将收到内核被污染（Kernel Tainted）的警告。在Linux内核模块领域，可接受的LICENSE包括“GPL”、“GPL v2”、“GPLand additional rights”、“Dual BSD/GPL”、“Dual MPL/GPL”和“Proprietary”（关于模块是否可以采用非GPL许可权，如“Proprietary”，这个在学术界和法律界都有争议）。大多数情况下，内核模块应遵循GPL兼容许可权。Linux内核模块最常见的是以MODULE_LICENSE（“GPL v2”）语句声明模块采用GPL v2。</p>
</li>
<li><p>模块参数（可选）<br>模块参数是模块被加载的时候可以传递给它的值，它本身对应模块内部的全局变量。</p>
</li>
<li><p>模块导出符号（可选）<br>内核模块可以导出的符号（symbol，对应于函数或变量），若导出，其他模块则可以使用本模块中的变量或函数。</p>
</li>
<li><p>模块作者等信息声明（可选）<br>MODULE_AUTHOR、MODULE_DESCRIPTION、MODULE_VERSION、MODULE_DEVICE_TABLE、MODULE_ALIAS分别声明模块的作者、描述、版本、设备表和别名</p>
</li>
<li><p>printk<br>printk的日志级别定义如下（在include/linux/kernel.h中）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KERN_EMERG 0</span></span><br><span class="line">　　<span class="meta">#<span class="keyword">define</span> KERN_ALERT 1</span></span><br><span class="line">　　<span class="meta">#<span class="keyword">define</span> KERN_CRIT 2</span></span><br><span class="line">　　<span class="meta">#<span class="keyword">define</span> KERN_ERR 3</span></span><br><span class="line">　　<span class="meta">#<span class="keyword">define</span> KERN_WARNING 4</span></span><br><span class="line">　　<span class="meta">#<span class="keyword">define</span> KERN_NOTICE 5</span></span><br><span class="line">　　<span class="meta">#<span class="keyword">define</span> KERN_INFO 6</span></span><br><span class="line">　　<span class="meta">#<span class="keyword">define</span> KERN_DEBUG 7</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">KVERS = $(shell uname -r)</span><br><span class="line"><span class="meta">#shell中输出uname -r会获得内核版本号，这里将版本号存到变量KVERS</span></span><br><span class="line"># Kernel modules</span><br><span class="line">#将后面的东东编译为“内核模块”， obj-y 编译进内核，obj-n 不编译。</span><br><span class="line">obj-m += hello.o</span><br><span class="line"></span><br><span class="line"># 开启EXTRA_CFLAGS=-g-O0，可以得到包含调试信息的hello.ko模块。</span><br><span class="line">#EXTRA_CFLAGS=-g -O0</span><br><span class="line">#-C 表示让 make 命令进入指定的内核源代码目录</span><br><span class="line">build: kernel_modules</span><br><span class="line">kernel_modules:</span><br><span class="line">	make -C /lib/modules/$(KVERS)/build M=$(CURDIR) modules</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">	make -C /lib/modules/$(KVERS)/build M=$(CURDIR) clean</span><br></pre></td></tr></table></figure>


<h2 id="编译命令"><a href="#编译命令" class="headerlink" title="编译命令"></a>编译命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line"><span class="comment">#make的提示信息中，CC是编译,LD是链接</span></span><br><span class="line">modinfo hello.ko<span class="comment">#获得模块的信息</span></span><br><span class="line">sudo insmod hello.ko <span class="comment">#或者是insmod ./hello.ko</span></span><br><span class="line"><span class="comment">#加载时输出“Hello World enter”</span></span><br><span class="line">lsmod <span class="comment">#获得系统中已加载的所有模块以及模块间的依赖关系</span></span><br><span class="line">sudo rmmod hello</span><br><span class="line"><span class="comment">#卸载时输出“Hello World exit”。</span></span><br><span class="line">lsmod <span class="comment">#获得系统中已加载的所有模块以及模块间的依赖关系</span></span><br></pre></td></tr></table></figure>

<h2 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h2><p><img src="9dd6937f2d9e095231cb9521512316316ec4d704b30e1bf993bab2caf9d2324d.png" alt="图 1">  </p>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>ko</tag>
      </tags>
  </entry>
  <entry>
    <title>vsftpd服务</title>
    <url>/2021/07/09/vsftpd%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在linux环境下，使用最多的FTP服务端软件就是Vsftpd！安装Vsftpd，运行一下命令需要在root用户下进行！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># centos</span></span><br><span class="line">yum install vsftpd -y</span><br><span class="line"><span class="comment"># ubuntu</span></span><br><span class="line">apt-get install vsftpd -y</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service vsftpd start</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">systemctl start vsftpd</span><br></pre></td></tr></table></figure>
<p>重启服务使用<code>restart</code></p>
<h2 id="FTP传输模式"><a href="#FTP传输模式" class="headerlink" title="FTP传输模式"></a>FTP传输模式</h2><p>主动模式：客户端以随机端口（&gt;1024）监听数据连接服务，vsftpd以20端口主动与客户端建立数据连接<br>主动模式对客户端的网络有要求，需要服务端能够连接上客户端<br><img src="58d9f87ed09ff6b01ef055ac4835e3753a1fca419b7a72a64e23c2d30c0a48c2.png" alt="图 1">  </p>
<p>被动模式：服务端以随机端口（&gt;1024）监听数据连接服务，客户端与vsftpd建立数据连接<br><img src="6d864081aa9a5c3771fd159c9110065ca513bc8711deacf107723d3ed1a3d7c0.png" alt="图 2">  </p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p><code>/etc/vsftpd/vsftpd.conf</code>这个文件是vsftpd服务的核心配置文件！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 是否允许匿名登录FTP服务器，默认设置为YES允许</span></span><br><span class="line"><span class="comment"># 用户可使用用户名ftp或anonymous进行ftp登录，口令为用户的E-mail地址。</span></span><br><span class="line"><span class="comment"># 如不允许匿名访问则设置为NO</span></span><br><span class="line">anonymous_enable=YES</span><br><span class="line"><span class="comment"># 是否允许本地用户(即linux系统中的用户帐号)登录FTP服务器，默认设置为YES允许</span></span><br><span class="line"><span class="comment"># 本地用户登录后会进入用户主目录，而匿名用户登录后进入匿名用户的下载目录/var/ftp/pub</span></span><br><span class="line"><span class="comment"># 若只允许匿名用户访问，前面加上#注释掉即可阻止本地用户访问FTP服务器</span></span><br><span class="line">local_enable=YES</span><br><span class="line"><span class="comment"># 是否允许本地用户对FTP服务器文件具有写权限，默认设置为YES允许</span></span><br><span class="line">write_enable=YES </span><br><span class="line"><span class="comment"># 掩码，本地用户默认掩码为077</span></span><br><span class="line"><span class="comment"># 你可以设置本地用户的文件掩码为缺省022，也可根据个人喜好将其设置为其他值</span></span><br><span class="line"><span class="comment">#local_umask=022</span></span><br><span class="line"><span class="comment"># 是否允许匿名用户上传文件，须将全局的write_enable=YES。默认为YES</span></span><br><span class="line"><span class="comment">#anon_upload_enable=YES</span></span><br><span class="line"><span class="comment"># 是否允许匿名用户创建新文件夹</span></span><br><span class="line"><span class="comment">#anon_mkdir_write_enable=YES </span></span><br><span class="line"><span class="comment"># 是否激活目录欢迎信息功能</span></span><br><span class="line"><span class="comment"># 当用户用CMD模式首次访问服务器上某个目录时，FTP服务器将显示欢迎信息</span></span><br><span class="line"><span class="comment"># 默认情况下，欢迎信息是通过该目录下的.message文件获得的</span></span><br><span class="line"><span class="comment"># 此文件保存自定义的欢迎信息，由用户自己建立</span></span><br><span class="line"><span class="comment">#dirmessage_enable=YES</span></span><br><span class="line"><span class="comment"># 是否让系统自动维护上传和下载的日志文件</span></span><br><span class="line"><span class="comment"># 默认情况该日志文件为/var/log/vsftpd.log,也可以通过下面的xferlog_file选项对其进行设定</span></span><br><span class="line"><span class="comment"># 默认值为NO</span></span><br><span class="line">xferlog_enable=YES</span><br><span class="line"><span class="comment"># Make sure PORT transfer connections originate from port 20 (ftp-data).</span></span><br><span class="line"><span class="comment"># 是否设定FTP服务器将启用FTP数据端口的连接请求</span></span><br><span class="line"><span class="comment"># ftp-data数据传输，21为连接控制端口</span></span><br><span class="line">connect_from_port_20=YES</span><br><span class="line"><span class="comment"># 设定是否允许改变上传文件的属主，与下面一个设定项配合使用</span></span><br><span class="line"><span class="comment"># 注意，不推荐使用root用户上传文件</span></span><br><span class="line"><span class="comment">#chown_uploads=YES</span></span><br><span class="line"><span class="comment"># 设置想要改变的上传文件的属主，如果需要，则输入一个系统用户名</span></span><br><span class="line"><span class="comment"># 可以把上传的文件都改成root属主。whoever：任何人</span></span><br><span class="line"><span class="comment">#chown_username=whoever</span></span><br><span class="line"><span class="comment"># 设定系统维护记录FTP服务器上传和下载情况的日志文件</span></span><br><span class="line"><span class="comment"># /var/log/vsftpd.log是默认的，也可以另设其它</span></span><br><span class="line"><span class="comment">#xferlog_file=/var/log/vsftpd.log</span></span><br><span class="line"><span class="comment"># 是否以标准xferlog的格式书写传输日志文件</span></span><br><span class="line"><span class="comment"># 默认为/var/log/xferlog，也可以通过xferlog_file选项对其进行设定</span></span><br><span class="line"><span class="comment"># 默认值为NO</span></span><br><span class="line"><span class="comment">#xferlog_std_format=YES</span></span><br><span class="line"><span class="comment"># 以下是附加配置，添加相应的选项将启用相应的设置</span></span><br><span class="line"><span class="comment"># 是否生成两个相似的日志文件</span></span><br><span class="line"><span class="comment"># 默认在/var/log/xferlog和/var/log/vsftpd.log目录下</span></span><br><span class="line"><span class="comment"># 前者是wu_ftpd类型的传输日志，可以利用标准日志工具对其进行分析；后者是vsftpd类型的日志</span></span><br><span class="line"><span class="comment">#dual_log_enable</span></span><br><span class="line"><span class="comment"># 是否将原本输出到/var/log/vsftpd.log中的日志，输出到系统日志</span></span><br><span class="line"><span class="comment">#syslog_enable</span></span><br><span class="line"><span class="comment"># 设置数据传输中断间隔时间，此语句表示空闲的用户会话中断时间为600秒</span></span><br><span class="line"><span class="comment"># 即当数据传输结束后，用户连接FTP服务器的时间不应超过600秒。可以根据实际情况对该值进行修改</span></span><br><span class="line"><span class="comment">#idle_session_timeout=600</span></span><br><span class="line"><span class="comment"># 设置数据连接超时时间，该语句表示数据连接超时时间为120秒，可根据实际情况对其个修改</span></span><br><span class="line"><span class="comment">#data_connection_timeout=120</span></span><br><span class="line"><span class="comment"># 运行vsftpd需要的非特权系统用户，缺省是nobody</span></span><br><span class="line"><span class="comment">#nopriv_user=ftpsecure</span></span><br><span class="line"><span class="comment"># 是否识别异步ABOR请求。</span></span><br><span class="line"><span class="comment"># 如果FTP client会下达“async ABOR”这个指令时，这个设定才需要启用</span></span><br><span class="line"><span class="comment"># 而一般此设定并不安全，所以通常将其取消</span></span><br><span class="line"><span class="comment">#async_abor_enable=YES</span></span><br><span class="line"><span class="comment"># 是否以ASCII方式传输数据。默认情况下，服务器会忽略ASCII方式的请求。</span></span><br><span class="line"><span class="comment"># 启用此选项将允许服务器以ASCII方式传输数据</span></span><br><span class="line"><span class="comment"># 不过，这样可能会导致由&quot;SIZE /big/file&quot;方式引起的DoS攻击</span></span><br><span class="line"><span class="comment">#ascii_upload_enable=YES</span></span><br><span class="line"><span class="comment">#ascii_download_enable=YES</span></span><br><span class="line"><span class="comment"># 登录FTP服务器时显示的欢迎信息</span></span><br><span class="line"><span class="comment"># 如有需要，可在更改目录欢迎信息的目录下创建名为.message的文件，并写入欢迎信息保存后</span></span><br><span class="line"><span class="comment">#ftpd_banner=Welcome to blah FTP service.</span></span><br><span class="line"><span class="comment"># 黑名单设置。如果很讨厌某些email address，就可以使用此设定来取消他的登录权限</span></span><br><span class="line"><span class="comment"># 可以将某些特殊的email address抵挡住。</span></span><br><span class="line"><span class="comment">#deny_email_enable=YES</span></span><br><span class="line"><span class="comment"># 当上面的deny_email_enable=YES时，可以利用这个设定项来规定哪些邮件地址不可登录vsftpd服务器</span></span><br><span class="line"><span class="comment"># 此文件需用户自己创建，一行一个email address即可</span></span><br><span class="line"><span class="comment">#banned_email_file=/etc/vsftpd/banned_emails</span></span><br><span class="line"><span class="comment"># 用户登录FTP服务器后是否具有访问自己目录以外的其他文件的权限</span></span><br><span class="line"><span class="comment"># 设置为YES时，用户被锁定在自己的home目录中，vsftpd将在下面chroot_list_file选项值的位置寻找chroot_list文件</span></span><br><span class="line"><span class="comment"># 必须与下面的设置项配合</span></span><br><span class="line"><span class="comment">#chroot_list_enable=YES</span></span><br><span class="line"><span class="comment"># 被列入此文件的用户，在登录后将不能切换到自己目录以外的其他目录</span></span><br><span class="line"><span class="comment"># 从而有利于FTP服务器的安全管理和隐私保护。此文件需自己建立</span></span><br><span class="line"><span class="comment">#chroot_list_file=/etc/vsftpd/chroot_list</span></span><br><span class="line"><span class="comment"># 是否允许递归查询。默认为关闭，以防止远程用户造成过量的I/O</span></span><br><span class="line"><span class="comment">#ls_recurse_enable=YES</span></span><br><span class="line"><span class="comment"># 是否允许监听。</span></span><br><span class="line"><span class="comment"># 如果设置为YES，则vsftpd将以独立模式运行，由vsftpd自己监听和处理IPv4端口的连接请求</span></span><br><span class="line">listen=YES</span><br><span class="line"><span class="comment"># 设定是否支持IPV6。如要同时监听IPv4和IPv6端口，</span></span><br><span class="line"><span class="comment"># 则必须运行两套vsftpd，采用两套配置文件</span></span><br><span class="line"><span class="comment"># 同时确保其中有一个监听选项是被注释掉的</span></span><br><span class="line"><span class="comment">#listen_ipv6=YES</span></span><br><span class="line"><span class="comment"># 设置PAM外挂模块提供的认证服务所使用的配置文件名，即/etc/pam.d/vsftpd文件</span></span><br><span class="line"><span class="comment"># 此文件中file=/etc/vsftpd/ftpusers字段，说明了PAM模块能抵挡的帐号内容来自文件/etc/vsftpd/ftpusers中</span></span><br><span class="line"><span class="comment">#pam_service_name=vsftpd</span></span><br><span class="line"><span class="comment"># 是否允许ftpusers文件中的用户登录FTP服务器，默认为NO</span></span><br><span class="line"><span class="comment"># 若此项设为YES，则user_list文件中的用户允许登录FTP服务器</span></span><br><span class="line"><span class="comment"># 而如果同时设置了userlist_deny=YES，则user_list文件中的用户将不允许登录FTP服务器，甚至连输入密码提示信息都没有</span></span><br><span class="line"><span class="comment">#userlist_enable=YES/NO</span></span><br><span class="line"><span class="comment"># 设置是否阻扯user_list文件中的用户登录FTP服务器，默认为YES</span></span><br><span class="line"><span class="comment">#userlist_deny=YES/NO</span></span><br><span class="line"><span class="comment"># 是否使用tcp_wrappers作为主机访问控制方式。</span></span><br><span class="line"><span class="comment"># tcp_wrappers可以实现linux系统中网络服务的基于主机地址的访问控制</span></span><br><span class="line"><span class="comment"># 在/etc目录中的hosts.allow和hosts.deny两个文件用于设置tcp_wrappers的访问控制</span></span><br><span class="line"><span class="comment"># 前者设置允许访问记录，后者设置拒绝访问记录。</span></span><br><span class="line"><span class="comment"># 如想限制某些主机对FTP服务器192.168.57.2的匿名访问，编缉/etc/hosts.allow文件，如在下面增加两行命令：</span></span><br><span class="line"><span class="comment"># vsftpd:192.168.57.1:DENY 和vsftpd:192.168.57.9:DENY</span></span><br><span class="line"><span class="comment"># 表明限制IP为192.168.57.1/192.168.57.9主机访问IP为192.168.57.2的FTP服务器</span></span><br><span class="line"><span class="comment"># 此时FTP服务器虽可以PING通，但无法连接</span></span><br><span class="line">tcp_wrappers=YES</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>/etc/vsftpd/ftpusers</code>这个文件是<strong>禁止</strong>使用vsftpd的用户列表文件。记录不允许访问FTP服务器的用户名单，管理员可以把一些对系统安全有威胁的用户账号记录在此文件中，以免用户从FTP登录后获得大于上传下载操作的权利，而对系统造成损坏。</p>
<p><code>/etc/vsftpd/user_list</code>这个文件<strong>禁止或允许</strong>使用vsftpd的用户列表文件。这个文件中指定的用户缺省情况（即在<code>/etc/vsftpd/vsftpd.conf</code>中设置<code>userlist_deny=YES</code>）下也不能访问FTP服务器，在设置了userlist_deny=NO时,仅允许user_list中指定的用户访问FTP服务器。</p>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>vsftpd</tag>
      </tags>
  </entry>
  <entry>
    <title>FTP主动和被动模式</title>
    <url>/2021/07/08/FTP%E4%B8%BB%E5%8A%A8%E5%92%8C%E8%A2%AB%E5%8A%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="FTP-主动模式-PORT-和被动模式-PASV"><a href="#FTP-主动模式-PORT-和被动模式-PASV" class="headerlink" title="FTP-主动模式(PORT)和被动模式(PASV)"></a>FTP-主动模式(PORT)和被动模式(PASV)</h2><p>FTP协议要用到两个TCP连接， 一个是命令连接，用来在FTP客户端与服务器之间传递命令； 另一个是数据连接，用来上传或下载数据。 <br>无论是主动模式还是被动模式，其要进行文件传输都必须依次建立两个连接，分别为<code>命令连接</code>与<code>数据连接</code>。而主动模式与被动模式的差异主要体现在数据连结通道上。</p>
<span id="more"></span>


<h2 id="FTP主动模式-PORT"><a href="#FTP主动模式-PORT" class="headerlink" title="FTP主动模式(PORT)"></a>FTP主动模式(PORT)</h2><ol>
<li><p>命令连接<br>当FTP客户端需要登陆到FTP服务器上的时候，服务器与客户端需要进行一系列的身份验证过程，这个过程就叫做命令连接</p>
</li>
<li><p>数据连接<br>如果此时客户端需要往FTP服务器上上传或者下载文件的话，就需要在客户端与服务器端再建立一条额外的数据传输连接</p>
</li>
</ol>
<p>主动模式的FTP是指<strong>服务器主动连接客户端</strong>的数据端口</p>
<p><strong>工作过程</strong><br>FTP服务器命令（21）端口接受客户端随机非特权端口N （&gt;1024）（客户端初始连接）<br>FTP服务器命令（21）端口到客户端端口N（&gt;1024）（服务器响应客户端命令）,同时客户端开始监听 N+1端口<br>FTP服务器数据（20）端口到客户端端口N+1（&gt;1024）（服务器初始化数据连接到客户端数据端口）<br>FTP服务器数据（20）端口接受客户端端口N+1（&gt;1024）（客户端发送ACK包到服务器的数据端口）</p>
<p><img src="8c7b7405cc00bc9f9774fe8b1fb3a0534aa1ad13f3e0ff8e78ef41ba917ea79d.png" alt="图 1"><br><img src="61ae6bc65e03757734d1e493b2740d395042804be8f502b0e78b509f3b82f4b6.png" alt="图 2">  </p>
<p><strong>优点</strong><br>服务端配置简单，利于服务器安全管理，服务器只需要开放21和20端口。</p>
<p><strong>缺点</strong><br>如果客户端开启了防火墙，或客户端处于内网（NAT网关之后）， 那么服务器对客户端端口发起的连接可能会失败。</p>
<h2 id="FTP被动模式-PASV"><a href="#FTP被动模式-PASV" class="headerlink" title="FTP被动模式(PASV)"></a>FTP被动模式(PASV)</h2><p>被动模式的FTP是指服务器<strong>被动地等待客户端连接自己的数据端口</strong></p>
<p><strong>工作过程</strong><br>FTP服务器命令（21）端口接受客户端非特权端口N（客户端初始连接）<br>FTP服务器命令（21）端口到客户端端口N（&gt;1024）（服务器响应客户端命令）<br>FTP服务器数据端口（&gt;1024）接受客户端端口N+1（&gt;1024）（客户端初始化数据连接到服务器指定的任意端口）<br>FTP服务器数据端口（&gt;1024）到客户端端口N+1（&gt;1024）（服务器发送ACK响应和数据到客户端的数据端口）<br><img src="296c2c1ba284c0b248ab4c9be5d036f8fea5355969dc3ae127b376b6ef8ba707.png" alt="图 3"><br><img src="ade1151c94426c7f0b2c7ffdd622b1dc42e1a378ed35457649541ce0ca38cd0f.png" alt="图 4">  </p>
<p><strong>优点</strong><br>对客户端网络环境没有要求。</p>
<p><strong>缺点</strong><br>服务器配置管理稍显复杂，不利于安全，服务器需要开放随机高位端口以便客户端可以连接，因此大多数FTP服务软件都可以手动配置被动端口的范围。</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>当ftp正常连接后输入:passive 打开或者关闭被动模式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ftp&gt; passive</span><br><span class="line">Passive mode on.</span><br><span class="line">ftp&gt; </span><br><span class="line">227 Entering Passive Mode (10,20,70,10,86,80).</span><br><span class="line">ftp&gt; passive</span><br><span class="line">Passive mode off.</span><br><span class="line">ftp&gt; </span><br><span class="line">200 PORT <span class="built_in">command</span> successful. Consider using PASV.</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>主动模式<br><img src="905ee33e70b8f574a661b8808e867eb02f873519ccb0185daa563dd993a896f1.png" alt="图 5">  </p>
<p>被动模式<br><img src="801ec172b2e8d94c4511f3be06eba6b66de4d860bcd890fc093b976c119aec82.png" alt="图 6">  </p>
<h2 id="选择策略"><a href="#选择策略" class="headerlink" title="选择策略"></a>选择策略</h2><p>当FTP服务器部署在防火墙或NAT（Network Address Translation）等服务器后面的时候，采用被动模式为宜。若采用主动模式，则FTP服务器与客户端之间只能够建立命令连接通道，而无法建立起数据传输通道。</p>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>FTP</tag>
      </tags>
  </entry>
  <entry>
    <title>软链接与硬链接</title>
    <url>/2021/07/05/%E8%BD%AF%E9%93%BE%E6%8E%A5%E4%B8%8E%E7%A1%AC%E9%93%BE%E6%8E%A5/</url>
    <content><![CDATA[<h2 id="软链接（符号链接）"><a href="#软链接（符号链接）" class="headerlink" title="软链接（符号链接）"></a>软链接（符号链接）</h2><p>软链接可以理解为一个文件的快捷方式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s 源文件 目标文件</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p><img src="160f15690b22ffe8de6809f954b6118c86bc09683d8e4ab7c9667a43916ab90d.png" alt="图 1">  </p>
<h2 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span>  源文件 目标文件</span><br></pre></td></tr></table></figure>
<p><img src="b01f016a41b77342873f0d80c9170f923c9f169674737af3c694c4599f451703.png" alt="图 5">  </p>
<h2 id="软链接、硬链接和cp区别"><a href="#软链接、硬链接和cp区别" class="headerlink" title="软链接、硬链接和cp区别"></a>软链接、硬链接和cp区别</h2><p><code>硬链接</code>：有相同的inode值，创建时间一样，支持数据同步，源文件删除之后，链接的文件可以继续访问<br><code>软链接</code>：有不同的inode值，创建时间不一样，支持数据同步，源文件删除之后，链接的文件无法继续访问<br><code>cp</code>：有不同的inode值，创建时间不一样（cp -p来保持一致），不支持数据同步，源文件删除之后，链接的文件可以继续访问</p>
<h2 id="简单描述一下inode"><a href="#简单描述一下inode" class="headerlink" title="简单描述一下inode"></a>简单描述一下inode</h2><p>查看inode信息：<code>stat $&#123;filename&#125;</code><br><img src="1a9cdcf00b4bfddd33d027b03190d22f9737380e8dfd463433e16b375e12c391.png" alt="图 2">  </p>
<p>查看inode值：<code>ll -i</code><br><img src="518e11f79cdcb13d934e4eec27be79fa3643ad08dfdd088b754a178127086322.png" alt="图 3">  </p>
<p>linux操作系统只认inode，不认文件名，文件名只是方便用户识别，<br>inode值可以理解为指针，指针所指向的内容即为数据，同样可以通过inode值，找到文件数据<br>如下图，用户打开文件的过程<br>step1：linux系统找到这个文件名对应的inode值<br>step2: 通过inode值，获取inode信息<br>step3：根据inode信息，找到文件数据所在的block，读取数据</p>
<p><img src="6f35d939bfc9b08a2b156aa5cd36e6b41d5df291e7000981badc6dace25b1a96.png" alt="图 4">  </p>
<p>删除带特殊字符的文件，比如中文名文件，可以通过删除文件对应的inode值来删除：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find ./* -inum 1049741 -delete</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>软链接</tag>
        <tag>硬链接</tag>
      </tags>
  </entry>
  <entry>
    <title>logrotate使用</title>
    <url>/2021/06/28/logrotate%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在linux上logrotate是一个日志文件管理工具。用于分割日志文件，删除旧的日志文件，并创建新的日志文件，起到“转储”作用，它是默认随linux一起被安装的。</p>
<span id="more"></span>

<h2 id="logrotate基本介绍"><a href="#logrotate基本介绍" class="headerlink" title="logrotate基本介绍"></a>logrotate基本介绍</h2><p>Logrotate是基于CRON来运行的，其脚本是<code>/etc/cron.daily/logrotate</code>，内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /etc/cron.daily/logrotate</span></span><br><span class="line"><span class="comment">#!/bin/sh</span></span><br><span class="line"> </span><br><span class="line">/usr/sbin/logrotate /etc/logrotate.conf &gt;/dev/null 2&gt;&amp;1</span><br><span class="line">EXITVALUE=$?</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$EXITVALUE</span> != 0 ]; <span class="keyword">then</span></span><br><span class="line">    /usr/bin/logger -t logrotate <span class="string">&quot;ALERT exited abnormally with [<span class="variable">$EXITVALUE</span>]&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">logrotate [OPTION...] &lt;configfile&gt;</span><br><span class="line">-d, --debug ：debug模式，测试配置文件是否有错误，不真实执行。</span><br><span class="line">-f, --force ：强制转储文件。</span><br><span class="line">-m, --mail=<span class="built_in">command</span> ：压缩日志后，发送日志到指定邮箱。</span><br><span class="line">-s, --state=statefile ：使用指定的状态文件。</span><br><span class="line">-v, --verbose ：显示转储过程。</span><br></pre></td></tr></table></figure>

<h2 id="logrotate配置"><a href="#logrotate配置" class="headerlink" title="logrotate配置"></a>logrotate配置</h2><p>默认使用 /etc/logrotate.conf 文件，作为全局配置，而不同应用的具体配置则在 /etc/logrotate.d 目录下，通常以应用程序的名称命名，例如 nginx、mysql、syslog、yum 等配置。<br>例如：/etc/logrotate.d/nginx</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/var/log/nginx/*.<span class="built_in">log</span> /var/log/tomcat/*<span class="built_in">log</span> &#123;   <span class="comment"># 可以指定多个路径</span></span><br><span class="line">    daily                      <span class="comment"># 日志轮询周期，weekly,monthly,yearly</span></span><br><span class="line">    rotate 30                  <span class="comment"># 保存30天数据，超过的则删除</span></span><br><span class="line">    size +100M                 <span class="comment"># 超过100M时分割，单位K,M,G，优先级高于daily</span></span><br><span class="line">    compress                   <span class="comment"># 切割后压缩，也可以为nocompress</span></span><br><span class="line">    delaycompress              <span class="comment"># 切割时对上次的日志文件进行压缩</span></span><br><span class="line">    dateext                    <span class="comment"># 日志文件切割时添加日期后缀</span></span><br><span class="line">    missingok                  <span class="comment"># 如果没有日志文件也不报错</span></span><br><span class="line">    notifempty                 <span class="comment"># 日志为空时不进行切换，默认为ifempty</span></span><br><span class="line">    create 640 nginx nginx     <span class="comment"># 使用该模式创建日志文件</span></span><br><span class="line">    sharedscripts              <span class="comment"># 所有的文件切割之后只执行一次下面脚本</span></span><br><span class="line">    postrotate</span><br><span class="line">        <span class="keyword">if</span> [ -f /var/run/nginx.pid ]; <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">kill</span> -USR1 `<span class="built_in">cat</span> /var/run/nginx.pid`</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">    endscript</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>/etc/logrotate.d/xxx</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@xxx:/etc/logrotate.d<span class="comment"># cat xxx</span></span><br><span class="line">/var/log/xxx/*.<span class="built_in">log</span></span><br><span class="line">&#123;</span><br><span class="line">    missingok</span><br><span class="line">    notifempty</span><br><span class="line">    size 40M</span><br><span class="line">    copytruncate</span><br><span class="line">    create 0600 root root</span><br><span class="line">    compress</span><br><span class="line">    nodelaycompress</span><br><span class="line">    rotate 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">----- 可直接手动执行</span><br><span class="line">$ logrotate --force /etc/logrotate.d/nginx</span><br><span class="line">----- 显示详细的信息；而且--debug/-d实际上不会操作具体文件(Dry Run)</span><br><span class="line">$ logrotate --debug --verbose --force /etc/logrotate.d/nginx</span><br></pre></td></tr></table></figure>
<p>定时执行<code>crontab -e</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*/3 * * * * /usr/sbin/logrotate -v /etc/logrotate.d/xxx</span><br></pre></td></tr></table></figure>

<h2 id="日志机制"><a href="#日志机制" class="headerlink" title="日志机制"></a>日志机制</h2><p>首先，介绍下在 Linux 系统中是如何处理文件的。</p>
<p>进程每打开一个文件，系统会分配一个新的文件描述符给这个文件；这个文件描述符中保存了文件的状态信息、当前文件位置以及文件的 inode 信息。对文件的操作是通过文件描述符完成，所以文件路径发生改变不会影响文件操作。</p>
<p>测试：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/bin/python</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;/tmp/foobar.txt&quot;</span>, <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        file.write(<span class="string">&quot;test\n&quot;</span>)</span><br><span class="line">        file.flush()</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>当通过 mv /tmp/foobar.txt /tmp/test.txt 移动文件之后，可以看到 test.txt 文件仍然在写入。原因如上所述，Linux 在执行 mv 操作时，文件描述符是不变的，只修改了文件名。</p>
<p>其中 logrotate 提供了两种方式，分别为 create 和 copytruncate 。</p>
<h3 id="create"><a href="#create" class="headerlink" title="create"></a>create</h3><p>这也就是默认的方案，可以通过 create 命令配置文件的权限和属组设置；这个方案的思路是重命名原日志文件，创建新的日志文件。详细步骤如下：</p>
<p>重命名正在输出日志文件，因为重命名只修改目录以及文件的名称，而进程操作文件使用的是 inode，所以并不影响原程序继续输出日志。</p>
<p>创建新的日志文件，文件名和原日志文件一样，注意，此时只是文件名称一样，而 inode 编号不同，原程序输出的日志还是往原日志文件输出。</p>
<p>最后通过某些方式通知程序，重新打开日志文件；由于重新打开日志文件会用到文件路径而非 inode 编号，所以打开的是新的日志文件。</p>
<p>如上也就是 logrotate 的默认操作方式，也就是 mv+create 执行完之后，通知应用重新在新文件写入即可。mv+create 成本都比较低，几乎是原子操作，如果应用支持重新打开日志文件，如 syslog, nginx, mysql 等，那么这是最好的方式。</p>
<p>不过，有些程序并不支持这种方式，压根没有提供重新打开日志的接口；而如果重启应用程序，必然会降低可用性，为此引入了如下方式。</p>
<h3 id="copytruncate"><a href="#copytruncate" class="headerlink" title="copytruncate"></a>copytruncate</h3><p>该方案是把正在输出的日志拷 (copy) 一份出来，再清空 (trucate) 原来的日志；详细步骤如下：</p>
<p>将当前正在输出的日志文件复制为目标文件，此时程序仍然将日志输出到原来文件中，此时，原文件名也没有变。</p>
<p>清空日志文件，原程序仍然还是输出到预案日志文件中，因为清空文件只把文件的内容删除了，而 inode 并没改变，后续日志的输出仍然写入该文件中。</p>
<p>如上所述，对于 copytruncate 也就是先复制一份文件，然后清空原有文件。</p>
<p>通常来说，清空操作比较快，但是如果日志文件太大，那么复制就会比较耗时，从而可能导致部分日志丢失。不过这种方式不需要应用程序的支持即可。</p>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>logrotate</tag>
      </tags>
  </entry>
  <entry>
    <title>sshpass使用</title>
    <url>/2021/06/27/sshpass%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><strong>Ubuntu</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install sshpass -y</span><br></pre></td></tr></table></figure>
<p><strong>Centos</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install sshpass -y</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><code>sshpass</code>：<strong>用于非交互的ssh密码验证</strong><br>使用 <code>-p</code> 参数指定明文密码，然后直接登录远程服务器。 它支持密码从<code>命令行</code>,<code>文件</code>,<code>环境变量</code>中读取</p>
<h3 id="从命令行方式传递密码"><a href="#从命令行方式传递密码" class="headerlink" title="从命令行方式传递密码"></a>从命令行方式传递密码</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sshpass -p user_password ssh user_name@192.168.1.2  【登录远程机器】</span><br><span class="line">sshpass -p user_password scp -P22 root@192.168.1.2:/home/test  ./ 【远程机器/home/test 复制到本机当前目录】</span><br></pre></td></tr></table></figure>
<p>还可以加参数 <code>-q</code> 【去掉进度显示】</p>
<h3 id="从文件读取密码"><a href="#从文件读取密码" class="headerlink" title="从文件读取密码"></a>从文件读取密码</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;user_password&quot;</span> &gt; user.passwd</span><br><span class="line">sshpass -f user.passwd ssh user_name@192.168.1.2</span><br></pre></td></tr></table></figure>

<h3 id="从环境变量获取密码"><a href="#从环境变量获取密码" class="headerlink" title="从环境变量获取密码"></a>从环境变量获取密码</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> SSHPASS=<span class="string">&quot;user_password&quot;</span></span><br><span class="line">sshpass -e ssh user_name@192.168.1.2</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><code>-o StrictHostKeyChecking=no</code><br>表示远程连接时不提示是否输入yes/no</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sshpass -p user_password ssh  -o StrictHostKeyChecking=no  user_name@192.168.1.2 </span><br></pre></td></tr></table></figure>

<p><strong>使用sshpass远程免密，在远程主机上执行shell命令</strong>，如下远程执行命令：<code>touch /opt/file.txt</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sshpass -p user_password ssh  -o StrictHostKeyChecking=no  user_name@192.168.1.2 <span class="built_in">touch</span> /opt/file.txt</span><br></pre></td></tr></table></figure>
<p>[注：shell命令要和sshpass命令写在一行]</p>
<p><strong>远程连接指定ssh的端口</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sshpass -p 123456 ssh -p 1000 root@192.168.11.11         (当远程主机不是默认的22端口时候)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>sshpass</tag>
      </tags>
  </entry>
  <entry>
    <title>dpkg使用</title>
    <url>/2021/06/26/dpkg%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>dpkg</code>是<code>Debian package</code>的简写，为<code>Debian</code>操作系统专门开发的套件管理系统，用于软件的安装，更新和移除。<br>所有源自<code>Debian</code>的Linux的发行版都使用<code>dpkg</code>, 例如<code>Ubuntu</code></p>
<span id="more"></span>

<h2 id="解压deb"><a href="#解压deb" class="headerlink" title="解压deb"></a>解压deb</h2><ol>
<li><p>首先下载deb包，比如：将其放在 /home/tools/ 根目录下：</p>
</li>
<li><p>进入到tools根目录下的终端，输入下面命令创建文件夹extract，并在extract文件夹下创建DEBIAN文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p extract/DEBIAN</span><br></pre></td></tr></table></figure></li>
<li><p>将deb包解压到extract文件夹下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg -X ./xxx.deb extract</span><br></pre></td></tr></table></figure></li>
<li><p>解压deb包中的control信息(包的依赖在这里面的control文件中)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg -e ./xxx.deb extract/DEBIAN</span><br></pre></td></tr></table></figure></li>
<li><p>创建build文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build</span><br></pre></td></tr></table></figure></li>
<li><p>将解压到extract文件夹中所有的内容重新打包为deb包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg-deb -b extract build/</span><br></pre></td></tr></table></figure></li>
<li><p>安装deb包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg -i xxx.deb　　(如果出现权限拒绝，在 dpkg 前加上 sudo 即可)</span><br></pre></td></tr></table></figure></li>
<li><p>卸载deb包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg -r xxx.deb　　( -r 参数只是删除了软件包，不能完全删除其配置文件，如果想要连同配置文件一起删除，可以使用 -P 参数)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="常用命令参数实例"><a href="#常用命令参数实例" class="headerlink" title="常用命令参数实例"></a>常用命令参数实例</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dpkg -i package.deb <span class="comment">#安装包 </span></span><br><span class="line">dpkg -r package <span class="comment">#删除包 </span></span><br><span class="line">dpkg -P package <span class="comment">#删除包（包括配置文件） </span></span><br><span class="line">dpkg -L package <span class="comment">#列出与该包关联的文件 </span></span><br><span class="line">dpkg -l package <span class="comment">#显示该包的版本 </span></span><br><span class="line">dpkg --unpack package.deb <span class="comment">#解开deb包的内容 </span></span><br><span class="line">dpkg -S keyword <span class="comment">#搜索所属的包内容 </span></span><br><span class="line">dpkg -l <span class="comment">#列出当前已安装的包 </span></span><br><span class="line">dpkg -c package.deb <span class="comment">#列出deb包的内容 </span></span><br><span class="line">dpkg --configure package <span class="comment">#配置包</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>dpkg</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ ACE</title>
    <url>/2021/06/25/C-ACE/</url>
    <content><![CDATA[<h4 id="ACE库"><a href="#ACE库" class="headerlink" title="ACE库"></a>ACE库</h4><p>ACE是一个面向对象的C++网络编程库，包含了常见的网络基础设施，例如：事件处理、并发编程、线程池、Socket编程、Reactor模式等。</p>
<span id="more"></span>

<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul>
<li>高可用性</li>
<li>可移植性高</li>
<li>支持多线程</li>
<li>提供了丰富的网络开发接口</li>
</ul>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>ACE库被广泛应用于以下领域：</p>
<ul>
<li>计算机网络领域</li>
<li>高性能分布式系统</li>
<li>多媒体领域</li>
<li>游戏服务器</li>
</ul>
<h4 id="ACE库的结构"><a href="#ACE库的结构" class="headerlink" title="ACE库的结构"></a>ACE库的结构</h4><p>ACE库大致分为三个部分：</p>
<ul>
<li>ACE核心组件：负责处理事件驱动和多线程</li>
<li>ACE套接字封装层：封装了C++网络编程中的Socket</li>
<li>ACE应用开发组件：属于增值服务组件，包括了高级网络编程接口、高级服务开发模板等。</li>
</ul>
<h4 id="ACE库的使用"><a href="#ACE库的使用" class="headerlink" title="ACE库的使用"></a>ACE库的使用</h4><p>ACE库的使用方式大致如下：</p>
<ol>
<li>安装ACE库<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install libace-dev -y</span><br></pre></td></tr></table></figure></li>
<li>创建ACE工程</li>
<li>根据需要选择ACE核心组件、ACE套接字封装层、ACE应用开发组件进行开发</li>
<li>编译、链接ACE工程，生成可执行文件<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ test.cpp -g -lACE -o <span class="built_in">test</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><h5 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ace/Message_Queue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ace/Asynch_IO.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ace/OS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ace/Proactor.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ace/Asynch_Acceptor.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HA_Proactive_Service</span> : <span class="keyword">public</span> ACE_Service_Handler</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~<span class="built_in">HA_Proactive_Service</span> ()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;<span class="built_in">handle</span> () != ACE_INVALID_HANDLE)</span><br><span class="line">ACE_OS::<span class="built_in">closesocket</span> (<span class="keyword">this</span>-&gt;<span class="built_in">handle</span> ());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">open</span> <span class="params">(ACE_HANDLE h, ACE_Message_Block&amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">this</span>-&gt;<span class="built_in">handle</span> (h);</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;reader_.<span class="built_in">open</span> (*<span class="keyword">this</span>) != <span class="number">0</span> )</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">ACE_ERROR</span> ((LM_ERROR, <span class="built_in">ACE_TEXT</span> (<span class="string">&quot;%p\n&quot;</span>),</span><br><span class="line">             <span class="built_in">ACE_TEXT</span> (<span class="string">&quot;HA_Proactive_Service open&quot;</span>)));</span><br><span class="line">         <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ACE_Message_Block *mb = <span class="keyword">new</span> <span class="built_in">ACE_Message_Block</span>(buffer,<span class="number">1024</span>);</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;reader_.<span class="built_in">read</span> (*mb, mb-&gt;<span class="built_in">space</span> ()) != <span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         ACE_OS::<span class="built_in">printf</span>(<span class="string">&quot;Begin read fail\n&quot;</span>);</span><br><span class="line">         <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//异步读完成后会调用此函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handle_read_stream</span></span></span><br><span class="line"><span class="function"><span class="params">(<span class="type">const</span> ACE_Asynch_Read_Stream::Result &amp;result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     ACE_Message_Block &amp;mb = result.<span class="built_in">message_block</span> ();</span><br><span class="line">     <span class="keyword">if</span> (!result.<span class="built_in">success</span> () || result.<span class="built_in">bytes_transferred</span> () == <span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         mb.<span class="built_in">release</span> ();</span><br><span class="line">         <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     mb.<span class="built_in">copy</span>(<span class="string">&quot;&quot;</span>);    <span class="comment">//为字符串添加结束标记&#x27;\0&#x27;</span></span><br><span class="line">     ACE_OS::<span class="built_in">printf</span>(<span class="string">&quot;rev:\t%s\n&quot;</span>,mb.<span class="built_in">rd_ptr</span>());</span><br><span class="line">     mb.<span class="built_in">release</span>();</span><br><span class="line"></span><br><span class="line">     ACE_Message_Block *nmb = <span class="keyword">new</span> <span class="built_in">ACE_Message_Block</span>(buffer,<span class="number">1024</span>);</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;reader_.<span class="built_in">read</span> (*nmb, nmb-&gt;<span class="built_in">space</span> ()) != <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">ACE_Asynch_Read_Stream reader_;</span><br><span class="line"><span class="type">char</span> buffer[<span class="number">1024</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> port=<span class="number">3000</span>;</span><br><span class="line">    ACE_Asynch_Acceptor&lt;HA_Proactive_Service&gt; acceptor;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (acceptor.<span class="built_in">open</span> (<span class="built_in">ACE_INET_Addr</span> (port)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        ACE_Proactor::<span class="built_in">instance</span> ()-&gt;<span class="built_in">handle_events</span> ();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ace/Message_Queue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ace/Asynch_IO.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ace/OS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ace/Proactor.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ace/Asynch_Connector.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HA_Proactive_Service</span> : <span class="keyword">public</span> ACE_Service_Handler</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">~<span class="built_in">HA_Proactive_Service</span> ()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;<span class="built_in">handle</span> () != ACE_INVALID_HANDLE)</span><br><span class="line">ACE_OS::<span class="built_in">closesocket</span> (<span class="keyword">this</span>-&gt;<span class="built_in">handle</span> ());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">open</span> <span class="params">(ACE_HANDLE h, ACE_Message_Block&amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="keyword">this</span>-&gt;<span class="built_in">handle</span> (h);</span><br><span class="line">     <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;writer_.<span class="built_in">open</span> (*<span class="keyword">this</span>) != <span class="number">0</span> )</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">ACE_ERROR</span> ((LM_ERROR, <span class="built_in">ACE_TEXT</span> (<span class="string">&quot;%p\n&quot;</span>),</span><br><span class="line">             <span class="built_in">ACE_TEXT</span> (<span class="string">&quot;HA_Proactive_Service open&quot;</span>)));</span><br><span class="line">         <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     ACE_OS::<span class="built_in">printf</span>(<span class="string">&quot;connceted&quot;</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)    <span class="comment">//每隔秒中发送时间至服务器</span></span><br><span class="line">     &#123;</span><br><span class="line">         ACE_OS::<span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">         <span class="type">time_t</span> now = ACE_OS::<span class="built_in">gettimeofday</span>().<span class="built_in">sec</span>();</span><br><span class="line">         <span class="type">char</span> *time = <span class="built_in">ctime</span>(&amp;now);        <span class="comment">//获取当前时间的字符串格式</span></span><br><span class="line">         ACE_Message_Block *mb = <span class="keyword">new</span> <span class="built_in">ACE_Message_Block</span>(<span class="number">100</span>);</span><br><span class="line">         mb-&gt;<span class="built_in">copy</span>(time);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;writer_.<span class="built_in">write</span>(*mb,mb-&gt;<span class="built_in">length</span>()) !=<span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">             ACE_OS::<span class="built_in">printf</span>(<span class="string">&quot;Begin read fail\n&quot;</span>);</span><br><span class="line">             <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">             <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//异步写完成后会调用此函数</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">handle_write_dgram</span></span></span><br><span class="line"><span class="function"><span class="params">(<span class="type">const</span> ACE_Asynch_Write_Stream::Result &amp;result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     ACE_Message_Block &amp;mb = result.<span class="built_in">message_block</span> ();</span><br><span class="line">     mb.<span class="built_in">release</span>();</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">ACE_Asynch_Write_Stream writer_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ACE_INET_Addr <span class="title">addr</span><span class="params">(<span class="number">3000</span>,<span class="string">&quot;127.0.0.1&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    HA_Proactive_Service *client = <span class="keyword">new</span> <span class="built_in">HA_Proactive_Service</span>();</span><br><span class="line">    ACE_Asynch_Connector&lt;HA_Proactive_Service&gt; connector;</span><br><span class="line">    </span><br><span class="line">    connector.<span class="built_in">open</span>();</span><br><span class="line">    <span class="keyword">if</span> (connector.<span class="built_in">connect</span>(addr) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        ACE_Proactor::<span class="built_in">instance</span> ()-&gt;<span class="built_in">handle_events</span> ();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@YBNJ0101:/home/rma/mr_work/test/cpp_test/ace_test<span class="comment"># ./test</span></span><br><span class="line">(16189 | 140174321361600) ACE_POSIX_AIOCB_Proactor::Max Number of AIOs=1024</span><br><span class="line">rev:    Thu Mar 23 14:47:31 2021</span><br><span class="line"></span><br><span class="line">rev:    Thu Mar 23 14:47:33 2021</span><br><span class="line"></span><br><span class="line">rev:    Thu Mar 23 14:47:35 2021</span><br><span class="line"></span><br><span class="line">rev:    Thu Mar 23 14:47:37 2021</span><br><span class="line"></span><br><span class="line">rev:    Thu Mar 23 14:47:39 2021</span><br><span class="line"></span><br><span class="line">rev:    Thu Mar 23 14:47:41 2021</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>ACE</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ STL</title>
    <url>/2021/06/24/C-STL/</url>
    <content><![CDATA[<h1 id="C-STL-Standard-Template-Library"><a href="#C-STL-Standard-Template-Library" class="headerlink" title="C++ STL (Standard Template Library)"></a>C++ STL (Standard Template Library)</h1><p>C++ STL (Standard Template Library) 是 C++ 的标准库，其中包含了许多常用的数据结构和算法。这些数据结构和算法被封装为 STL 组件，利用它们可以更简单、更高效地编写 C++ 程序。</p>
<span id="more"></span>

<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>容器是一种数据结构，可以用来存储和访问数据。C++ STL 提供了多种类型的容器，包括：</p>
<h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>vector 是一个动态数组，可以快速的在尾部添加和删除元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>list 是一个双向链表。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt; l = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h3><p>deque 是一个双端队列，可以快速地在两端添加和删除元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line">deque&lt;<span class="type">int</span>&gt; d = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>set 是一个有序集合，不允许重复元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>&gt; s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map 是一种键值对集合，键是唯一的，值可以重复。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; m = &#123;&#123;<span class="string">&quot;apple&quot;</span>, <span class="number">1</span>&#125;, &#123;<span class="string">&quot;banana&quot;</span>, <span class="number">2</span>&#125;, &#123;<span class="string">&quot;cherry&quot;</span>, <span class="number">3</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器用于遍历容器中的元素，STL 提供了多种类型的迭代器，包括：</p>
<h3 id="vector-迭代器"><a href="#vector-迭代器" class="headerlink" title="vector 迭代器"></a>vector 迭代器</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator iter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (iter = v.<span class="built_in">begin</span>(); iter != v.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">    cout &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="list-迭代器"><a href="#list-迭代器" class="headerlink" title="list 迭代器"></a>list 迭代器</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; l = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator iter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (iter = l.<span class="built_in">begin</span>(); iter != l.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">    cout &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="set-迭代器"><a href="#set-迭代器" class="headerlink" title="set 迭代器"></a>set 迭代器</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; s = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator iter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (iter = s.<span class="built_in">begin</span>(); iter != s.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">    cout &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>STL 提供了许多常用的算法，比如查找、排序、比较等等。这些算法都是在容器上执行的，因此它们具有通用性，可以用于不同类型的容器。</p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator iter;</span><br><span class="line"></span><br><span class="line">iter = <span class="built_in">find</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (iter != v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Found: &quot;</span> &lt;&lt; *iter &lt;&lt; endl; <span class="comment">// Found: 2</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Not found&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    cout &lt;&lt; v[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">string s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s1 &lt; s2) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1 comes before s2 in the dictionary&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;s1 comes after s2 in the dictionary&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>C++ STL 提供了多种数据结构、迭代器和算法，可以帮助我们更加高效地编写 C++ 程序。熟练掌握 STL 的使用方法可以使代码更加简洁、可读性更好，提高程序的效率和质量。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>解决iptables DNAT不生效</title>
    <url>/2021/06/24/%E8%A7%A3%E5%86%B3iptables-DNAT%E4%B8%8D%E7%94%9F%E6%95%88/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>设置ssh登录10.20.69.30，且端口为2222转发到内网192.168.122.22的虚拟机</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -d 10.20.69.30 -p tcp --dport 2222 -j DNAT --to-destination 192.168.122.22:22</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>无法访问，提示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh: connect to host 10.20.69.30 port 2222: Connection timed out</span><br></pre></td></tr></table></figure>

<h2 id="问题根因"><a href="#问题根因" class="headerlink" title="问题根因"></a>问题根因</h2><p>查看内核ip_forward转发功能尚未开启<br><img src="ce9ae90e4f0f5832995a940f5f36b72c45a5033888246772808db2a5b6267456.png" alt="图 1">  </p>
<h2 id="问题修复"><a href="#问题修复" class="headerlink" title="问题修复"></a>问题修复</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.ipv4.ip_forward=1&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title>docker镜像制作</title>
    <url>/2021/06/23/docker%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/</url>
    <content><![CDATA[<p>docker编译/运行镜像制作</p>
<span id="more"></span>
<p>•<br>•    拉取基础镜像：<br>•    在本地虚机运行容器：<br>•    容器内安装操作：<br>•    将容器保存到镜像：<br>•    编译环境上的工具或库的源码下载<br>拉取基础镜像：<br>    docker pull 10.20.69.14:8266/centos8.4:base<br>在本地虚机运行容器：<br>    docker run –name centos_build -it 10.20.69.14:8266/centos8.4:base /bin/bash</p>
<p>容器内安装操作：<br>进入容器执行：</p>
<p>1.配置yum源：<br>rm -rf /etc/yum.repos.d/*</p>
<p>cat &gt; /etc/yum.repos.d/jmnd_priv.repo &lt;&lt; EOF<br>[jmnd_repo]<br>name=repo for jmnd<br>baseurl=<a href="http://10.20.69.22:8099/repo/">http://10.20.69.22:8099/repo/</a><br>enabled=1<br>gpgcheck=0</p>
<p>[jmnd_repo_static]<br>name=repo for jmnd static<br>baseurl=<a href="http://10.20.69.22:8099/repo_static/">http://10.20.69.22:8099/repo_static/</a><br>enabled=0<br>gpgcheck=0<br>EOF</p>
<p>yum makecache</p>
<p>2.下载安装脚本：<br>mkdir -p /opt/install/<br>cd /opt/install/<br>yum install -y wget.x86_64<br>wget <a href="http://10.20.69.22:8099/script/auto_install.sh">http://10.20.69.22:8099/script/auto_install.sh</a><br>chmod 777 auto_install.sh</p>
<ol start="3">
<li><p>执行安装脚本：<br>制作编译环境：./auto_install.sh dev<br>制作运行环境：./auto_install.sh<br>安装的最后需要敲回车才能结束(ssh-keygen需要)</p>
</li>
<li><p>可以选择将yum源切换成公司的：<br>下载文件夹：wget -r -nH –cut-dirs=1 <a href="http://10.20.69.22:8099/source/yum.repos.d.jaguar">http://10.20.69.22:8099/source/yum.repos.d.jaguar</a><br>将下载的文件夹覆盖/etc/yum.repos.d 后 yum makecache<br>将容器保存到镜像：<br> docker commit centos_build centos_build:full<br>编译环境上的工具或库的源码下载<br>浏览器上：<a href="http://10.20.69.22:8099/source">http://10.20.69.22:8099/source</a><br>点击需要下载的源码包下载。<br>修改源码后拷贝到容器中重新参考auto_install.sh中编译安装</p>
</li>
</ol>
]]></content>
      <categories>
        <category>DOCKER</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>iptables</title>
    <url>/2021/06/23/iptables/</url>
    <content><![CDATA[<h2 id="什么是iptables"><a href="#什么是iptables" class="headerlink" title="什么是iptables?"></a>什么是iptables?</h2><p>iptables是一个在Linux系统中使用的防火墙工具。它可以使用规则来过滤、屏蔽、重定向和修改数据包。iptables在网络安全方面扮演了很重要的角色。<br><a href="https://wangchujiang.com/linux-command/c/iptables.html">详情参考</a></p>
<span id="more"></span>

<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><p><code>iptables -L</code> - 查看当前的iptables规则<br><code>iptables -A</code> - 添加一条规则<br><code>iptables -D</code> - 删除一条规则<br><code>iptables -P</code> - 设置规则的默认策略<br><code>iptables -F</code> - 清除所有规则</p>
<h2 id="iptables的规则结构"><a href="#iptables的规则结构" class="headerlink" title="iptables的规则结构"></a>iptables的规则结构</h2><p><code>表（Table）</code>：标识要执行哪个表的规则。默认情况下，iptables使用filter表。<br><code>链 （Chain）</code>：包含一组规则的有序列表。iptables中预定义的三个链分别是INPUT、OUTPUT和FORWARD。<br><code>匹配条件（Match）</code>：iptables会将收到的每个数据包使用匹配条件来测试是否与规则匹配。例如，匹配源IP地址、目的IP地址、端口等。<br><code>动作（Target）</code>：匹配成功后要执行的操作。例如，接受、拒绝、重定向等。</p>
<h2 id="命令选项输入顺序"><a href="#命令选项输入顺序" class="headerlink" title="命令选项输入顺序"></a>命令选项输入顺序</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -t 表名 &lt;-A/I/D/P&gt; 规则链名 [规则号] &lt;-i/o 网卡名&gt; -p 协议名 &lt;-s 源IP/源子网&gt; --sport 源端口 &lt;-d 目标IP/目标子网&gt; --dport 目标端口 -j 动作</span><br></pre></td></tr></table></figure>

<h2 id="iptables表"><a href="#iptables表" class="headerlink" title="iptables表"></a>iptables表</h2><p>filter<br>这是iptables中默认的表。它用于过滤数据包。当数据包通过iptables时，它会被传递到filter表的三个默认链中的一个：INPUT、OUTPUT或FORWARD。</p>
<p>nat<br>这个表被用于网络地址转换。它可以用来隐藏内部网络的IP地址，或将IP地址转换为其他地址。如果你需要在服务器上配置NAT网关，这个表会很有用。</p>
<p>mangle<br>这个表可以修改数据包头，如修改TTL值、标记数据包等。</p>
<p>raw<br>这个表涉及到一些底层的网络细节，它用来禁用NAT记号和连接追踪功能。你不应该使用这个表除非你非常清楚自己在做什么。</p>
<p>security<br>这个表是CentOS和Red Hat Enterprise Linux的SELinux规则，通常不需要手动设置或修改它。</p>
<h2 id="iptables链"><a href="#iptables链" class="headerlink" title="iptables链"></a>iptables链</h2><p>INPUT<br>这个链处理服务器收到的数据包。例如，当你远程连接到服务器时，数据包通过INPUT链进入iptables。</p>
<p>OUTPUT<br>这个链处理从服务器发出的数据包。例如，当你从服务器下载文件时，数据包通过OUTPUT链离开iptables。</p>
<p>FORWARD<br>FORWARD链用于路由数据包。当一个数据包应该从一个接口转发到另一个接口时，这个链就会被用到。</p>
<p>PREROUTING<br>在路由之前更改数据包。即在数据包到达系统之后（并且在路由之前）立即发生数据包转换。这有助于将数据包的目标 IP 地址转换为与本地服务器上的路由匹配的内容。这用于 DNAT（目标 NAT）。</p>
<p>POSTROUTING<br>在路由后更改数据包。即当数据包离开系统时发生数据包转换。这有助于将数据包的源 IP 地址转换为可能与目标服务器上的路由匹配的内容。这用于 SNAT（源 NAT）。</p>
<p><img src="5377285be5187989b312f02f8a5a4250396c4b9a60547e438ade55f651f405ef.png" alt="图 3">  </p>
<h2 id="iptables匹配条件"><a href="#iptables匹配条件" class="headerlink" title="iptables匹配条件"></a>iptables匹配条件</h2><p>-p, –protocol<br>指定使用哪个协议。例如，TCP、UDP、ICMP等等。</p>
<p>-s, –source<br>指定源IP地址或地址段。可以使用CIDR的格式指定IP地址段。</p>
<p>-d, –destination<br>指定目标IP地址或地址段。同样也可以使用CIDR格式。</p>
<p>-i, –in-interface<br>指定进入数据包的接口。</p>
<p>-o, –out-interface<br>指定离开数据包的接口。</p>
<p>-m, –match<br>指定特定的匹配条件模块。这个参数允许你使用额外的匹配条件，例如mac地址、时间、字符串和其他更高级的条件。</p>
<h2 id="iptables动作"><a href="#iptables动作" class="headerlink" title="iptables动作"></a>iptables动作</h2><p>ACCEPT<br>接收数据包</p>
<p>REJECT<br>拒绝数据包，发送一个ICMP消息通知。</p>
<p>DROP<br>静默地丢弃数据包，不发送任何消息。</p>
<p>LOG<br>记录数据包到日志中并继续处理规则。</p>
<p>RETURN<br>从一个自定义链返回。</p>
<h2 id="iptables规则示例"><a href="#iptables规则示例" class="headerlink" title="iptables规则示例"></a>iptables规则示例</h2><p><strong>公网210.14.67.7让内网192.168.188.0/24上网</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -s 192.168.188.0/24 -j SNAT --to 210.14.67.127</span><br></pre></td></tr></table></figure>

<p><strong>公网主机10.20.69.36让虚机内网192.168.122.19上网</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 内网虚机设置默认路由，网关为公网主机连接虚机内网的ip 192.168.122.1</span></span><br><span class="line">route add default gw 192.168.122.1</span><br><span class="line"></span><br><span class="line"><span class="comment">## 公网主机设置ip_forward转发功能</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.ipv4.ip_forward=1&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line">sysctl -p</span><br><span class="line"></span><br><span class="line"><span class="comment">## 公网主机设置SNAT</span></span><br><span class="line">iptables -t nat -A POSTROUTING -s 192.168.122.19 -j SNAT --to 10.20.69.36</span><br></pre></td></tr></table></figure>

<p><strong>内网ip（本机无法直连）通过外网ip（本机可以直连）转发流量到本机代理访问外网</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#在外网ip上</span><br><span class="line">socat -d -d TCP-LISTEN:22890,reuseaddr,fork TCP:10.20.18.193:7890</span><br><span class="line"></span><br><span class="line">#在内网ip上</span><br><span class="line">https_proxy=http://10.20.69.52:22890 http_proxy=http://10.20.69.52:22890 wget www.google.com</span><br><span class="line"></span><br><span class="line">10.20.18.78:7890是自己电脑ip和代理端口</span><br></pre></td></tr></table></figure>

<p><strong>本机的 2222 端口映射到内网 虚拟机的22 端口</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -d 10.20.69.36 -p tcp --dport 2222  -j DNAT --to-dest 192.168.122.19:22</span><br></pre></td></tr></table></figure>

<p><strong>删除nat表POSTROUTING链的第1条已添加规则</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -t nat -D POSTROUTING 1</span><br></pre></td></tr></table></figure>

<p><strong>查看 nat 表</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iptables -t nat -nvL</span></span><br></pre></td></tr></table></figure>

<p><strong>查看 filter 表</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># iptables -t filter -nvL</span></span><br><span class="line">(or)</span><br><span class="line"><span class="comment"># iptables -nvL</span></span><br></pre></td></tr></table></figure>

<p><strong>允许所有本地流量</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -P INPUT ACCEPT</span><br><span class="line">iptables -P OUTPUT ACCEPT</span><br><span class="line">iptables -P FORWARD ACCEPT</span><br></pre></td></tr></table></figure>

<p><strong>禁止所有入站流量</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -P INPUT DROP</span><br><span class="line">iptables -A INPUT -j LOG --log-prefix <span class="string">&quot;DROP INPUT&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>禁止所有出站流量</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -P OUTPUT DROP</span><br><span class="line">iptables -A OUTPUT -j LOG --log-prefix <span class="string">&quot;DROP OUTPUT&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>允许SSH连接</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 22 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>

<p><strong>允许HTTP和HTTPS连接</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -A INPUT -p tcp --dport 443 -m state --state NEW,ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -p tcp --sport 80 -m state --state ESTABLISHED -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -p tcp --sport 443 -m state --state ESTABLISHED -j ACCEPT</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title>bash自动补全</title>
    <url>/2021/06/22/bash%E8%87%AA%E5%8A%A8%E8%A1%A5%E5%85%A8/</url>
    <content><![CDATA[<h2 id="compgen"><a href="#compgen" class="headerlink" title="compgen"></a>compgen</h2><p>这个命令，用来筛选生成 匹配单词的 候选补全结果。</p>
<table>
    <tr>
        <th>选项</th><th>描述</th>
    </tr>
    <tr>
        <td>-W wordlist</td><td>分割 wordlist 中的单词，生成候选补全列表</td>
    </tr>
</table>
<span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment">#compgen -W &#x27;word1 word2 test&#x27;</span></span><br><span class="line">word1</span><br><span class="line">word2</span><br><span class="line"><span class="built_in">test</span></span><br><span class="line">[root@localhost ~]<span class="comment">#compgen -W &#x27;word1 word2 test&#x27; word</span></span><br><span class="line">word1</span><br><span class="line">word2</span><br><span class="line">[root@localhost ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure>

<h2 id="complete"><a href="#complete" class="headerlink" title="complete"></a>complete</h2><p>complete补全命令</p>
<table>
    <tr>
        <th>选项</th><th>描述/th>
    </th></tr>
    <tr>
        <td>-F function</td><td>执行shell 函数，函数中生成COMPREPLY作为候选的补全结果</td>
    </tr>
</table>


<h2 id="内置补全变量"><a href="#内置补全变量" class="headerlink" title="内置补全变量"></a>内置补全变量</h2><table>
    <tr>
        <th>名称</th><th>描述/th>
    </th></tr>
    <tr>
        <td>COMP_WORDS</td><td>类型为数组，存放当前命令行中输入的所有单词</td>
    </tr>
    <tr>
        <td>COMP_CWORD</td><td>类型为整数，当前光标下输入的单词位于COMP_WORDS数组中的索引</td>
    </tr>
    <tr>
        <td>COMPREPLY</td><td>类型为数组，候选的补全结果</td>
    </tr>
    <tr>
        <td>COMP_WORDBREAKS</td><td>类型为字符串，表示单词之间的分隔符</td>
    </tr>
    <tr>
        <td>COMP_LINE</td><td>类型为字符串，表示当前命令行输入</td>
    </tr>
</table>


<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>使用tab键进行补全，补全脚本分成两部分：编写一个补全函数和使用complete命令应用补全函数。</p>
<p>一般补全函数都会定义以下两个变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">local</span> cur prev</span><br></pre></td></tr></table></figure>
<p>其中cur表示当前光标下的单词，而prev则对应上一个单词：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cur=<span class="string">&quot;<span class="variable">$&#123;COMP_WORDS[COMP_CWORD]&#125;</span>&quot;</span></span><br><span class="line">prev=<span class="string">&quot;<span class="variable">$&#123;COMP_WORDS[COMP_CWORD-1]&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>初始化相应的变量之后，我们需要定义补全行为，即输入什么的情况下补全什么内容，例如当输入-开头的选项时，我们将所有的选项作为候选的补全结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">local</span> opts=<span class="string">&quot;-h --help -f --file -o --output&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;cur&#125;</span> == -* ]]; <span class="keyword">then</span></span><br><span class="line">    COMPREPLY=( $(compgen -W <span class="string">&quot;<span class="variable">$&#123;opts&#125;</span>&quot;</span> -- <span class="variable">$&#123;cur&#125;</span>) )</span><br><span class="line">    <span class="built_in">return</span> 0</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<p>不过在给COMPREPLY赋值之前，最好将它重置清空，避免被其他补全函数干扰</p>
<p>foo_complete文件如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">complete -F _foo foo</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">_foo</span></span>() &#123;</span><br><span class="line">        <span class="built_in">local</span> cur prev opts</span><br><span class="line"> </span><br><span class="line">        COMPREPLY=()</span><br><span class="line"> </span><br><span class="line">        cur=<span class="string">&quot;<span class="variable">$&#123;COMP_WORDS[COMP_CWORD]&#125;</span>&quot;</span></span><br><span class="line">        prev=<span class="string">&quot;<span class="variable">$&#123;COMP_WORDS[COMP_CWORD-1]&#125;</span>&quot;</span></span><br><span class="line">        opts=<span class="string">&quot;-h --help -f --file -o --output&quot;</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> [[ <span class="variable">$&#123;cur&#125;</span> == -* ]] ; <span class="keyword">then</span></span><br><span class="line">                COMPREPLY=( $(compgen -W <span class="string">&quot;<span class="variable">$&#123;opts&#125;</span>&quot;</span> -- <span class="variable">$&#123;cur&#125;</span>) )</span><br><span class="line">                <span class="built_in">return</span> 0</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>现在在命令行下就可以对foo命令进行参数补全了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:~$ <span class="built_in">source</span> foo_complete</span><br><span class="line">:~$ foo -</span><br><span class="line">-f        --file    -h        --<span class="built_in">help</span>    -o        --output </span><br></pre></td></tr></table></figure>
<p>利用号prev变量可以让补全结果更完整，例如当输入–file之后，我们希望补全特殊的文件（假设以.sh结尾的文件）</p>
<p>foo_complete文件如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">complete -F _foo foo</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">_foo</span></span>() &#123;</span><br><span class="line">        <span class="built_in">local</span> cur prev opts</span><br><span class="line"> </span><br><span class="line">        COMPREPLY=()</span><br><span class="line"> </span><br><span class="line">        cur=<span class="string">&quot;<span class="variable">$&#123;COMP_WORDS[COMP_CWORD]&#125;</span>&quot;</span></span><br><span class="line">        prev=<span class="string">&quot;<span class="variable">$&#123;COMP_WORDS[COMP_CWORD-1]&#125;</span>&quot;</span></span><br><span class="line">        opts=<span class="string">&quot;-h --help -f --file -o --output&quot;</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> [[ <span class="variable">$&#123;cur&#125;</span> == -* ]] ; <span class="keyword">then</span></span><br><span class="line">                COMPREPLY=( $(compgen -W <span class="string">&quot;<span class="variable">$&#123;opts&#125;</span>&quot;</span> -- <span class="variable">$&#123;cur&#125;</span>) )</span><br><span class="line">                <span class="built_in">return</span> 0</span><br><span class="line">        <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;<span class="variable">$&#123;prev&#125;</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">            -f|--file)</span><br><span class="line">                COMPREPLY=( $(compgen -o filenames -W <span class="string">&quot;`ls *.sh`&quot;</span> -- <span class="variable">$&#123;cur&#125;</span>) )</span><br><span class="line">                ;;</span><br><span class="line">        <span class="keyword">esac</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在再执行foo命令，–file参数的值也可以补全了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:~/TEST/sh$ foo --file</span><br><span class="line">hello.sh                      test.sh</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SHELL</category>
      </categories>
      <tags>
        <tag>compgen</tag>
        <tag>complete</tag>
      </tags>
  </entry>
  <entry>
    <title>yum私有仓库</title>
    <url>/2021/06/22/yum%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<h2 id="docker的yum私有仓库"><a href="#docker的yum私有仓库" class="headerlink" title="docker的yum私有仓库"></a>docker的yum私有仓库</h2><p>启动容器</p>
<span id="more"></span>

<p>docker run –name centos_repo -ti -p 8099:8099 -v /home/gaohaibao/priv_repo:/home/gaohaibao/priv_repo 10.20.69.14:8266/centos8.4:base /bin/bash</p>
<h2 id="配置yum源"><a href="#配置yum源" class="headerlink" title="配置yum源"></a>配置yum源</h2><p>rm -rf /etc/yum.repos.d/*<br>cat &gt;/etc/yum.repos.d/jmnd_priv.repo &lt;&lt;EOF<br>[jmnd_repo]<br>name=repo for jmnd<br>baseurl=<a href="http://10.20.69.22:8099/repo/">http://10.20.69.22:8099/repo/</a><br>enabled=1<br>gpgcheck=0</p>
<p>[jmnd_repo_static]<br>name=repo for jmnd static<br>baseurl=<a href="http://10.20.69.22:8099/repo_static/">http://10.20.69.22:8099/repo_static/</a><br>enabled=0<br>gpgcheck=0</p>
<p>yum makecache</p>
<h2 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h2><p>yum install -y libnsl.x86_64 –allowerasing<br>yum install -y yum-utils.noarch<br>yum install -y chkconfig.x86_64<br>yum install -y python36.x86_64<br>yum install -y modulemd-tools.noarch<br>yum install -y createrepo_c.x86_64<br>pip3 install –upgrade pip -i <a href="http://10.20.69.22:8099/pypi/simple">http://10.20.69.22:8099/pypi/simple</a> –trusted-host 10.20.69.22<br>pip3 install pip2pi -i <a href="http://10.20.69.22:8099/pypi/simple">http://10.20.69.22:8099/pypi/simple</a> –trusted-host 10.20.69.22</p>
<h2 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h2><p>cd /home/gaohaibao/priv_repo/<br>createrepo_c repo<br>repo2module -s stable  repo/ modules.yaml<br>modifyrepo_c –mdtype=modules modules.yaml repo/repodata<br>dir2pi ./pypi<br>python3 -m http.server 8099</p>
<h2 id="更新下载源"><a href="#更新下载源" class="headerlink" title="更新下载源"></a>更新下载源</h2><p>sed -e “s|^mirrorlist=|#mirrorlist=|g” -e “s|^baseurl=<a href="http://mirror.centos.org//$contentdir//$releasever|baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-vault/8.4.2105|g&quot;">http://mirror.centos.org/\$contentdir/\$releasever|baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-vault/8.4.2105|g&quot;</a> -e “s|#baseurl=<a href="http://mirror.centos.org//$contentdir//$releasever|baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-vault/8.4.2105|g&quot;">http://mirror.centos.org/\$contentdir/\$releasever|baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-vault/8.4.2105|g&quot;</a> -e “s|enabled=0|enabled=1|g” -i /etc/yum.repos.d/CentOS-*.repo<br>sed -e “s|enabled=1|enabled=0|g” -i /etc/yum.repos.d/jmnd_priv.repo<br>sed -e “s|enabled=1|enabled=0|g” -i /etc/yum.repos.d/CentOS-Linux-Media.repo</p>
<p>sed -e “s|^mirrorlist=|#mirrorlist=|g” -e “s|^baseurl=<a href="http://mirror.centos.org//$contentdir/8-stream|baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-vault/8.4.2105|g&quot;">http://mirror.centos.org/\$contentdir/8-stream|baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-vault/8.4.2105|g&quot;</a> -e “s|^#baseurl=<a href="http://mirror.centos.org//$contentdir/8-stream|baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-vault/8.4.2105|g&quot;">http://mirror.centos.org/\$contentdir/8-stream|baseurl=https://mirrors.tuna.tsinghua.edu.cn/centos-vault/8.4.2105|g&quot;</a> -e “s|enabled=0|enabled=1|g” -i /etc/yum.repos.d/CentOS-*.repo<br>sed -e “s|enabled=1|enabled=0|g” -i /etc/yum.repos.d/jmnd_priv.repo<br>sed -e “s|enabled=1|enabled=0|g” -i /etc/yum.repos.d/CentOS-Linux-Media.repo</p>
<h2 id="自动化部署"><a href="#自动化部署" class="headerlink" title="自动化部署"></a>自动化部署</h2><p>配置yum源<br>#rm -rf /etc/yum.repos.d/*<br>sed -e ‘s|$releasever|8-stream|g’ -e ‘s|enabled=1|enabled=0|g’ -i /etc/yum.repos.d/CentOS-*.repo<br>cat &gt;/etc/yum.repos.d/jmnd_priv.repo &lt;&lt;EOF<br>[jmnd_repo]<br>name=repo for jmnd<br>baseurl=<a href="http://10.20.69.22:8099/repo/">http://10.20.69.22:8099/repo/</a><br>enabled=1<br>gpgcheck=0</p>
<p>[jmnd_repo_static]<br>name=repo for jmnd static<br>baseurl=<a href="http://10.20.69.22:8099/repo_static/">http://10.20.69.22:8099/repo_static/</a><br>enabled=0<br>gpgcheck=0<br>EOF</p>
<p>yum makecache</p>
<p>安装wget<br>yum install -y wget.x86_64</p>
<p>下载脚本<br>wget <a href="http://10.20.69.22:8099/script/auto_install.sh">http://10.20.69.22:8099/script/auto_install.sh</a></p>
<p>运行安装<br>./auto_install.sh  (运行镜像)</p>
<p>./auto_install.sh  dev (构建镜像)</p>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>yum</tag>
      </tags>
  </entry>
  <entry>
    <title>yum源替换</title>
    <url>/2021/06/21/yum%E6%BA%90%E6%9B%BF%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="CentOS-8-更换yum国内源"><a href="#CentOS-8-更换yum国内源" class="headerlink" title="CentOS 8 更换yum国内源"></a>CentOS 8 更换yum国内源</h2><ul>
<li>在不删除源文件的基础上，将源文件备份</li>
<li>下载最新centos8国内的yum源文件</li>
<li>更换地址<span id="more"></span></li>
</ul>
<h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><ul>
<li><p>进入root，切换至yum.repos.d目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /etc/yum.repos.d/</span><br></pre></td></tr></table></figure></li>
<li><p>创建新文件夹并将源文件备份为repo.bak</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> backup &amp;&amp; <span class="built_in">mv</span> *repo backup/</span><br></pre></td></tr></table></figure></li>
<li><p>下载国内yum源文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-8.repo</span><br></pre></td></tr></table></figure></li>
<li><p>更新下载yum源地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i -e<span class="string">&quot;s|mirrors.cloud.aliyuncs.com|mirrors.aliyun.com|g &quot;</span> /etc/yum.repos.d/CentOS-*</span><br><span class="line">sed -i -e <span class="string">&quot;s|releasever|releasever-stream|g&quot;</span> /etc/yum.repos.d/CentOS-*</span><br></pre></td></tr></table></figure></li>
<li><p>生成缓存</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum clean all &amp;&amp; yum makecache</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="epel"><a href="#epel" class="headerlink" title="epel"></a>epel</h2><p>如果既想获得 RHEL 的高质量、高性能、高可靠性，又需要方便易用(关键是免费)的软件包更新功能，那么 Fedora Project 推出的 EPEL(Extra Packages for Enterprise Linux)正好适合你。EPEL(<a href="http://fedoraproject.org/wiki/EPEL">http://fedoraproject.org/wiki/EPEL</a>) 是由 Fedora 社区打造，为 RHEL 及衍生发行版如 CentOS、Scientific Linux 等提供高质量软件包的项目。</p>
<p>使用心得：</p>
<ol>
<li>不用去换原来yum源，安装后会产生新repo</li>
<li>epel会有很多源地址，如果一个下不到，会去另外一个下<br>   <a href="http://mirror.suhu.com/fedora-epel/6/x86_64/epel-release-6-8.noarch.rpm">http://mirror.suhu.com/fedora-epel/6/x86_64/epel-release-6-8.noarch.rpm</a></li>
<li>更新时如果下载的包不全，就不会进行安装。这样的话，依赖关系可以保重</li>
</ol>
<p>安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install epel-release -y</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>yum</tag>
      </tags>
  </entry>
  <entry>
    <title>yum的repo文件详解</title>
    <url>/2021/06/20/yum%E7%9A%84repo%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="repo文件"><a href="#repo文件" class="headerlink" title="repo文件"></a>repo文件</h2><p>    repo文件是Fedora中yum源（软件仓库）的配置文件，通常一个repo文件定义了一个或者多个软件仓库的细节内容，例如我们将从哪里下载需要安装或者升级的软件包，repo文件中的设置内容将被yum读取和应用！</p>
<span id="more"></span>

<h2 id="etc-yum-repo-d-xx-repo"><a href="#etc-yum-repo-d-xx-repo" class="headerlink" title="/etc/yum.repo.d/xx.repo"></a>/etc/yum.repo.d/xx.repo</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[appstream]</span><br><span class="line">name=CentOS Linux 8-stream - AppStream</span><br><span class="line">mirrorlist=http://mirrorlist.centos.org/?release=8-stream&amp;<span class="built_in">arch</span>=<span class="variable">$basearch</span>&amp;repo=AppStream&amp;infra=<span class="variable">$infra</span></span><br><span class="line"><span class="comment">#baseurl=http://mirror.centos.org/$contentdir/8-stream/AppStream/$basearch/os/</span></span><br><span class="line">gpgcheck=1</span><br><span class="line">enabled=1</span><br><span class="line">gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-centosofficial</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>name</strong>=Some name for this server<br>#name，是对repository的描述，支持像$releasever $basearch这样的变量; name=Fedora Core $releasever - $basearch - Released Updates</p>
<p><strong>baseurl</strong>=url://path/to/repository/<br>#baseurl是服务器设置中最重要的部分，只有设置正确，才能从上面获取软件。</p>
<p><strong>mirrorlist</strong>=<a href="http://mirrors.fedoraproject.org/mirrorlist?repo=fedora-$releasever&amp;arch=$basearch">http://mirrors.fedoraproject.org/mirrorlist?repo=fedora-$releasever&amp;arch=$basearch</a><br>#上面的这一行是指定一个镜像服务器的地址列表，</p>
<p>两者的区别<br><code>mirrorlist</code>是指向远程服务器上的一个文件，那个文件里面保存着多条url，默认轮询模式；<br><code>baseurl</code>是直接指定一个url。</p>
<p><strong>gpgcheck</strong>=[1 or 0]<br>#gpgchkeck= 有1和0两个选择，分别代表是否是否进行gpg校验，如果没有这一项，默认是检查的。</p>
<p><strong>enabled</strong>=[1 or 0]<br>#当某个软件仓库被配置成 enabled=0 时，yum 在安装或升级软件包时不会将该仓库做为软件包提供源。使用这个选项，可以启用或禁用软件仓库。<br>#通过 yum 的 –enablerepo=[repo_name] 和 –disablerepo=[repo_name] 选项，或者通过 PackageKit 的”添加/删除软件”工具，也能够方便地启用和禁用指定的软件仓库</p>
<p><strong>gpgkey</strong><br>yum可以使用gpg对包进行校验，确保下载包的完整性，所以我们先要到各个repository站点找到gpg key，一般都会放在首页的醒目位置，一些名字诸如 RPM-GPG-KEY.txt之类的纯文本文件，把它们下载，然后用rpm –import xxx.txt命令将它们导入，最好把发行版自带GPG-KEY也导入，rpm –import /usr/share/doc/redhat-release-*/RPM-GPG-KEY 官方软件升级用的上</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><code>$releasever</code>，发行版的版本，从[main]部分的distroverpkg获取，如果没有，则根据redhat-release包进行判断。<br><code>$arch</code>，cpu体系，如i686,athlon等<br><code>$basearch</code>，cpu的基本体系组，如i686和athlon同属i386，alpha和alphaev6同属alpha。</p>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>yum</tag>
      </tags>
  </entry>
  <entry>
    <title>python pdb</title>
    <url>/2021/06/19/python-gdb/</url>
    <content><![CDATA[<h2 id="pdb"><a href="#pdb" class="headerlink" title="pdb"></a>pdb</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -m pdb test.py</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(Pdb) 会自动停在第一行，等待调试，这时你可以看看帮助</span><br><span class="line">(Pdb) h</span><br></pre></td></tr></table></figure>

<h2 id="几个关键命令"><a href="#几个关键命令" class="headerlink" title="几个关键命令"></a>几个关键命令</h2><p><strong>断点设置</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(Pdb)b 10 <span class="comment">#断点设置在本py的第10行</span></span><br><span class="line">或(Pdb)b ots.py:20 <span class="comment">#断点设置到 ots.py第20行</span></span><br><span class="line">删除断点（Pdb）b <span class="comment">#查看断点编号</span></span><br><span class="line">(Pdb)cl 2 <span class="comment">#删除第2个断点</span></span><br></pre></td></tr></table></figure>

<p><strong>运行</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(Pdb)n <span class="comment">#单步运行</span></span><br><span class="line">(Pdb)s <span class="comment">#细点运行 也就是会下到，方法</span></span><br><span class="line">(Pdb)c <span class="comment">#跳到下个断点</span></span><br></pre></td></tr></table></figure>

<p><strong>查看</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(Pdb)p param <span class="comment">#查看当前 变量值</span></span><br><span class="line">(Pdb)l <span class="comment">#查看运行到某处代码</span></span><br><span class="line">(Pdb)a <span class="comment">#查看全部栈内变量</span></span><br></pre></td></tr></table></figure>

<h2 id="命令集合"><a href="#命令集合" class="headerlink" title="命令集合"></a>命令集合</h2><table>
    <tr>
        <th>命令</th><th>解释</th>
    </tr>
    <tr>
        <td>break 或 b</td><td>设置断点</td>
    </tr>
    <tr>
        <td>continue 或 c</td><td>继续执行程序</td>
    </tr>
    <tr>
        <td>list 或 l</td><td>查看当前行的代码段</td>
    </tr>
    <tr>
        <td>step 或 s</td><td>进入函数</td>
    </tr>
    <tr>
        <td>return 或 r</td><td>执行代码直到从当前函数返回</td>
    </tr>
    <tr>
        <td>exit 或 q</td><td>中止并退出</td>
    </tr>
    <tr>
        <td>next 或 n</td><td>执行下一行</td>
    </tr>
    <tr>
        <td>pp</td><td>打印变量的值</td>
    </tr>
    <tr>
        <td>help</td><td>帮助</td>
    </tr>
</table>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>委托构造与继承构造</title>
    <url>/2021/06/18/%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E4%B8%8E%E7%BB%A7%E6%89%BF%E6%9E%84%E9%80%A0/</url>
    <content><![CDATA[<h2 id="委托构造函数"><a href="#委托构造函数" class="headerlink" title="委托构造函数"></a>委托构造函数</h2><p>委托构造函数允许使用同一个类中的一个构造函数调用其它的构造函数，从而简化相关变量的初始化。</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() &#123;&#125;;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> max)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_max = max &gt; <span class="number">0</span> ? max : <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_max = max &gt; <span class="number">0</span> ? max : <span class="number">100</span>;              <span class="comment">// 冗余代码</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_min = min &gt; <span class="number">0</span> &amp;&amp; min &lt; max ? min : <span class="number">1</span>;   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min, <span class="type">int</span> mid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_max = max &gt; <span class="number">0</span> ? max : <span class="number">100</span>;             <span class="comment">// 冗余代码</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_min = min &gt; <span class="number">0</span> &amp;&amp; min &lt; max ? min : <span class="number">1</span>;  <span class="comment">// 冗余代码</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_middle = mid &lt; max &amp;&amp; mid &gt; min ? mid : <span class="number">50</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_min;</span><br><span class="line">    <span class="type">int</span> m_max;</span><br><span class="line">    <span class="type">int</span> m_middle;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">t</span><span class="params">(<span class="number">90</span>, <span class="number">30</span>, <span class="number">60</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;min: &quot;</span> &lt;&lt; t.m_min &lt;&lt; <span class="string">&quot;, middle: &quot;</span> </span><br><span class="line">         &lt;&lt; t.m_middle &lt;&lt; <span class="string">&quot;, max: &quot;</span> &lt;&lt; t.m_max &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的程序中有三个构造函数，但是这三个函数中都有重复的代码，在 C++11 之前构造函数是不能调用构造函数的，加入了委托构造之后，我们就可以轻松地完成代码的优化了：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() &#123;&#125;;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> max)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_max = max &gt; <span class="number">0</span> ? max : <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min):<span class="built_in">Test</span>(max)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_min = min &gt; <span class="number">0</span> &amp;&amp; min &lt; max ? min : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min, <span class="type">int</span> mid):<span class="built_in">Test</span>(max, min)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_middle = mid &lt; max &amp;&amp; mid &gt; min ? mid : <span class="number">50</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_min;</span><br><span class="line">    <span class="type">int</span> m_max;</span><br><span class="line">    <span class="type">int</span> m_middle;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Test <span class="title">t</span><span class="params">(<span class="number">90</span>, <span class="number">30</span>, <span class="number">60</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;min: &quot;</span> &lt;&lt; t.m_min &lt;&lt; <span class="string">&quot;, middle: &quot;</span> </span><br><span class="line">         &lt;&lt; t.m_middle &lt;&lt; <span class="string">&quot;, max: &quot;</span> &lt;&lt; t.m_max &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在修改之后的代码中可以看到，重复的代码全部没有了，并且在一个构造函数中调用了其他的构造函数用于相关数据的初始化，相当于是一个链式调用。在使用委托构造函数的时候还需要注意一些几个问题：</p>
<p>这种链式的构造函数调用<strong>不能形成一个闭环</strong>（死循环），否则会在运行期抛异常。</p>
<p>如果要进行多层构造函数的链式调用，建议将构造函数的调用的写在<strong>初始列表中而不是函数体内部</strong>，否则编译器会提示形参的重复定义。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> max)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_max = max &gt; <span class="number">0</span> ? max : <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Test</span>(max);	<span class="comment">// error, 此处编译器会报错, 提示形参max被重复定义</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;m_min = min &gt; <span class="number">0</span> &amp;&amp; min &lt; max ? min : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在初始化列表中调用了代理构造函数初始化某个类成员变量之后，<strong>就不能在初始化列表中再次初始化这个变量了</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误, 使用了委托构造函数就不能再次m_max初始化了</span></span><br><span class="line"><span class="built_in">Test</span>(<span class="type">int</span> max, <span class="type">int</span> min) : <span class="built_in">Test</span>(max), <span class="built_in">m_max</span>(max)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;m_min = min &gt; <span class="number">0</span> &amp;&amp; min &lt; max ? min : <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="继承构造函数"><a href="#继承构造函数" class="headerlink" title="继承构造函数"></a>继承构造函数</h2><p>C++11 中提供的继承构造函数可以让派生类直接使用基类的构造函数，而无需自己再写构造函数，尤其是在基类有很多构造函数的情况下，可以极大地简化派生类构造函数的编写。先来看没有继承构造函数之前的处理方式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i) :<span class="built_in">m_i</span>(i) &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i, <span class="type">double</span> j) :<span class="built_in">m_i</span>(i), <span class="built_in">m_j</span>(j) &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i, <span class="type">double</span> j, string k) :<span class="built_in">m_i</span>(i), <span class="built_in">m_j</span>(j), <span class="built_in">m_k</span>(k) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_i;</span><br><span class="line">    <span class="type">double</span> m_j;</span><br><span class="line">    string m_k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Child</span>(<span class="type">int</span> i) :<span class="built_in">Base</span>(i) &#123;&#125;</span><br><span class="line">    <span class="built_in">Child</span>(<span class="type">int</span> i, <span class="type">double</span> j) :<span class="built_in">Base</span>(i, j) &#123;&#125;</span><br><span class="line">    <span class="built_in">Child</span>(<span class="type">int</span> i, <span class="type">double</span> j, string k) :<span class="built_in">Base</span>(i, j, k) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Child <span class="title">c</span><span class="params">(<span class="number">520</span>, <span class="number">13.14</span>, <span class="string">&quot;i love you&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int: &quot;</span> &lt;&lt; c.m_i &lt;&lt; <span class="string">&quot;, double: &quot;</span> </span><br><span class="line">         &lt;&lt; c.m_j &lt;&lt; <span class="string">&quot;, string: &quot;</span> &lt;&lt; c.m_k &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++11 中通过添加<strong>继承构造函数</strong>这个新特性完美的解决了这个问题，使得代码更加精简。</p>
<p>继承构造函数的使用方法是这样的：通过使用 <strong>using 类名::构造函数名</strong>（其实类名和构造函数名是一样的）来声明使用基类的构造函数，这样子类中就可以不定义相同的构造函数了，直接使用基类的构造函数来构造派生类对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i) :<span class="built_in">m_i</span>(i) &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i, <span class="type">double</span> j) :<span class="built_in">m_i</span>(i), <span class="built_in">m_j</span>(j) &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i, <span class="type">double</span> j, string k) :<span class="built_in">m_i</span>(i), <span class="built_in">m_j</span>(j), <span class="built_in">m_k</span>(k) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_i;</span><br><span class="line">    <span class="type">double</span> m_j;</span><br><span class="line">    string m_k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Child <span class="title">c1</span><span class="params">(<span class="number">520</span>, <span class="number">13.14</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int: &quot;</span> &lt;&lt; c1.m_i &lt;&lt; <span class="string">&quot;, double: &quot;</span> &lt;&lt; c1.m_j &lt;&lt; endl;</span><br><span class="line">    <span class="function">Child <span class="title">c2</span><span class="params">(<span class="number">520</span>, <span class="number">13.14</span>, <span class="string">&quot;i love you&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int: &quot;</span> &lt;&lt; c2.m_i &lt;&lt; <span class="string">&quot;, double: &quot;</span> </span><br><span class="line">         &lt;&lt; c2.m_j &lt;&lt; <span class="string">&quot;, string: &quot;</span> &lt;&lt; c2.m_k &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外如果在子类中隐藏了父类中的同名函数，也可以通过 using 的方式在子类中使用基类中的这些父类函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i) :<span class="built_in">m_i</span>(i) &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i, <span class="type">double</span> j) :<span class="built_in">m_i</span>(i), <span class="built_in">m_j</span>(j) &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> i, <span class="type">double</span> j, string k) :<span class="built_in">m_i</span>(i), <span class="built_in">m_j</span>(j), <span class="built_in">m_k</span>(k) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;base class: i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i, string str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;base class: i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, str = &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> m_i;</span><br><span class="line">    <span class="type">double</span> m_j;</span><br><span class="line">    string m_k;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Child</span> : <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::Base;</span><br><span class="line">    <span class="keyword">using</span> Base::func;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;child class: i&#x27;am luffy!!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Child <span class="title">c</span><span class="params">(<span class="number">250</span>)</span></span>;</span><br><span class="line">    c.<span class="built_in">func</span>();</span><br><span class="line">    c.<span class="built_in">func</span>(<span class="number">19</span>);</span><br><span class="line">    c.<span class="built_in">func</span>(<span class="number">19</span>, <span class="string">&quot;luffy&quot;</span>);</span><br><span class="line">    c.Base::<span class="built_in">func</span>(<span class="number">19</span>);</span><br><span class="line">    c.Base::<span class="built_in">func</span>(<span class="number">19</span>, <span class="string">&quot;luffy&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述示例代码输出的结果为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">child <span class="keyword">class</span>: i<span class="number">&#x27;</span>am luffy!!!</span><br><span class="line">base <span class="keyword">class</span>: i = <span class="number">19</span></span><br><span class="line">base <span class="keyword">class</span>: i = <span class="number">19</span>, str = luffy</span><br><span class="line">base <span class="keyword">class</span>: i = <span class="number">19</span></span><br><span class="line">base <span class="keyword">class</span>: i = <span class="number">19</span>, str = luffy</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>类成员初始化</title>
    <url>/2021/06/17/%E7%B1%BB%E6%88%90%E5%91%98%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<h2 id="C-98-标准的类成员初始化"><a href="#C-98-标准的类成员初始化" class="headerlink" title="C++98 标准的类成员初始化"></a>C++98 标准的类成员初始化</h2><p>在 C++98 中，支持了在类声明中使用等号 = 加初始值的方式，来初始化类中静态成员常量。</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Base</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Base</span>() : <span class="built_in">a</span>(<span class="number">250</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> num) : <span class="built_in">a</span>(num) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">1</span>;	</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> c = <span class="number">0</span>;	</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">double</span> d = <span class="number">3.14</span>;	</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> e = <span class="string">&quot;i am luffy&quot;</span>;	</span><br><span class="line">    <span class="type">const</span> <span class="type">static</span> <span class="type">int</span> f = <span class="number">0</span>;	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果按照 C++98 标准来解读上面这段代码 ，其中有这么几行语法是错误的：<br>第 7 行：<strong>类的非静态成员，必须在构造函数中进行初始化</strong></p>
<p>第 8 行：类的静态成员，必须在类的外部进行初始化</p>
<p>第 9 行：类的静态常量成员，但不是整形或者枚举，无法通过编译</p>
<p>如果使用 g++ 可能发现就地初始化 double 类型的静态常量是可以通过编译的，不过这实际是 GNU 对 C++ 的一个扩展，并不遵从 C++ 标准。</p>
<p>第 10 行：类的静态常量成员，但不是整形或者枚举，无法通过编译</p>
<p>第 8、9、10 行的变量初始化方式是一样的，都是在类的外部</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> Base::c = <span class="number">110</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> Base::d = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> Base::e = <span class="string">&quot;i am luffy&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>上面程序中的 static const 和 const static 是等价的。</p>
<h2 id="C-11-标准的类成员初始化"><a href="#C-11-标准的类成员初始化" class="headerlink" title="C++11 标准的类成员初始化"></a>C++11 标准的类成员初始化</h2><h3 id="初始化类的非静态成员"><a href="#初始化类的非静态成员" class="headerlink" title="初始化类的非静态成员"></a>初始化类的非静态成员</h3><p>在进行类成员变量初始化的时候，C++11 标准对于 C++98 做了补充，允许在定义类的时候在类内部直接对非静态成员变量进行初始化，在初始化的时候可以使用等号 = 也可以 使用花括号 {} 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a = <span class="number">9</span>;</span><br><span class="line">    <span class="type">int</span> b = &#123;<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> c&#123;<span class="number">12</span>&#125;;</span><br><span class="line">    <span class="type">double</span> array[<span class="number">4</span>] = &#123; <span class="number">3.14</span>, <span class="number">3.15</span>, <span class="number">3.16</span>, <span class="number">3.17</span>&#125;;</span><br><span class="line">    <span class="type">double</span> array1[<span class="number">4</span>] &#123; <span class="number">3.14</span>, <span class="number">3.15</span>, <span class="number">3.16</span>, <span class="number">3.17</span> &#125;;</span><br><span class="line">    <span class="function">string <span class="title">s1</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;     <span class="comment">// error</span></span><br><span class="line">    string s2&#123; <span class="string">&quot;hello, world&quot;</span> &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到如果使用花括号 {} 的方式对类的非静态成员进行初始化，等号是可以省略不写的。</p>
<p>第 9 行：错误，不能使用小括号 () 初始化对象，应该使用 花括号 {}</p>
<h3 id="类内部赋值和初始化列表"><a href="#类内部赋值和初始化列表" class="headerlink" title="类内部赋值和初始化列表"></a>类内部赋值和初始化列表</h3><p>在 C++11 之前对于非静态的类成员变量我们除了在构造函数内部进行赋值，也可以在类的初始化列表中进行初始化（这种方式比在构造函数内部赋值效率高）。那么，如果<strong>同时</strong>在类内部对非静态成员变量就地初始化和在初始化列表中进行初始化会怎么样呢？下面来测试一下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Init</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Init</span>(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z) :<span class="built_in">a</span>(x), <span class="built_in">b</span>(y), <span class="built_in">c</span>(z) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Init <span class="title">tmp</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; tmp.a &lt;&lt; <span class="string">&quot;, b: &quot;</span> &lt;&lt; tmp.b &lt;&lt; <span class="string">&quot;, c: &quot;</span> &lt;&lt; tmp.c &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第 4 行：使用初始化列表对类的非静态成员进行初始化<br>第 6、7、8 行：在类内部对非静态成员变量就地初始化（C++11 新特性）<br>执行程序，输出的结果如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">a: <span class="number">10</span>, b: <span class="number">20</span>, c: <span class="number">30</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>constexpr</title>
    <url>/2021/06/16/constexpr/</url>
    <content><![CDATA[<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>在 C++11 之前只有 const 关键字，从功能上来说这个关键字有双重语义：变量只读，修饰常量</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> count = <span class="number">24</span>;</span><br><span class="line">    <span class="type">int</span> array[num];            <span class="comment">// error，num是一个只读变量，不是常量</span></span><br><span class="line">    <span class="type">int</span> array1[count];         <span class="comment">// ok，count是一个常量</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a1 = <span class="number">520</span>;</span><br><span class="line">    <span class="type">int</span> a2 = <span class="number">250</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; b = a1;</span><br><span class="line">    b = a2;                         <span class="comment">// error</span></span><br><span class="line">    a1 = <span class="number">1314</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;b: &quot;</span> &lt;&lt; b &lt;&lt; endl;     <span class="comment">// 输出结果为1314</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数 void func(const int num) 的参数 num 表示这个变量是只读的，但不是常量，因此使用 int array[num]; 这种方式定义一个数组，编译器是会报错的，提示 num不可用作为常量来使用。<br>const int count = 24; 中的 count 却是一个常量，因此可以使用这个常量来定义一个静态数组。<br>另外，变量只读并不等价于常量，二者是两个概念不能混为一谈，分析一下这句测试代码 const int&amp; b = a1;：</p>
<p>b 是一个常量的引用，所以 b 引用的变量是不能被修改的，也就是说 b = a2; 这句代码语法是错误的。</p>
<p>在 const 对于变量 a1 是没有任何约束的，a1 的值变了 b 的值也就变了</p>
<p>引用 b 是只读的，但是并不能保证它的值是不可改变的，也就是说它不是常量。</p>
<h2 id="constexpr"><a href="#constexpr" class="headerlink" title="constexpr"></a>constexpr</h2><p>在 C++11 中添加了一个新的关键字 constexpr，这个关键字是用来修饰常量表达式的。所谓常量表达式，指的就是由多个（≥1）常量（值不会改变）组成并且在编译过程中就得到计算结果的表达式。</p>
<p>在介绍 gcc/g++ 工作流程的时候说过，C++ 程序从编写完毕到执行分为四个阶段：预处理、 编译、汇编和链接 4 个阶段，得到可执行程序之后就可以运行了。需要额外强调的是，常量表达式和非常量表达式的计算时机不同，非常量表达式只能在程序运行阶段计算出结果，但是常量表达式的计算往往发生在程序的编译阶段，这可以极大提高程序的执行效率，因为表达式只需要在编译阶段计算一次，节省了每次程序运行时都需要计算一次的时间。</p>
<p>那么问题来了，编译器如何识别表达式是不是常量表达式呢？在 C++11 中添加了 constexpr 关键字之后就可以在程序中使用它来修改常量表达式，用来提高程序的执行效率。在使用中建议将 const 和 constexpr 的功能区分开，即凡是表达“只读”语义的场景都使用 const，表达“常量”语义的场景都使用 constexpr。</p>
<p>在定义常量时，const 和 constexpr 是等价的，都可以在程序的编译阶段计算出结果，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> m = <span class="built_in">f</span>();  <span class="comment">// 不是常量表达式，m的值只有在运行时才会获取。</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> i=<span class="number">520</span>;    <span class="comment">// 是一个常量表达式</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> j=i+<span class="number">1</span>;    <span class="comment">// 是一个常量表达式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> i=<span class="number">520</span>;    <span class="comment">// 是一个常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> j=i+<span class="number">1</span>;    <span class="comment">// 是一个常量表达式</span></span><br></pre></td></tr></table></figure>
<p>对于 C++ 内置类型的数据，可以直接用 constexpr 修饰，但如果是自定义的数据类型（用 struct 或者 class 实现），直接用 constexpr 修饰是不行的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 此处的constexpr修饰是无效的</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果要定义一个结构体 / 类常量对象，可以这样写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> Test t&#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> id = t.id;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> num = t.num;</span><br><span class="line">    <span class="comment">// error，不能修改常量</span></span><br><span class="line">    t.num += <span class="number">100</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;id: &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;, num: &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象 t 是一个常量，因此它的成员也是常量，常量是不能被修改的。</p>
<h2 id="常量表达式函数"><a href="#常量表达式函数" class="headerlink" title="常量表达式函数"></a>常量表达式函数</h2><p>普通函数/类成员函数、类的构造函数、模板函数。</p>
<h3 id="普通函数-类成员函数"><a href="#普通函数-类成员函数" class="headerlink" title="普通函数/类成员函数"></a>普通函数/类成员函数</h3><p>限定条件：</p>
<p>函数必须要有返回值，并且 return 返回的表达式必须是常量表达式。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// error，不是常量表达式函数</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error，不是常量表达式函数</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数 func1() 没有返回值，不满足常量表达式函数要求<br>函数 func2() 返回值不是常量表达式，不满足常量表达式函数要求<br>函数在使用之前，必须有对应的定义语句。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> num = <span class="built_in">func1</span>();	<span class="comment">// error</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个函数的函数体中，不能出现非常量表达式之外的语句（using 指令、typedef 语句以及 static_assert 断言、return 语句除外）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// error</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;i: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> mytype = <span class="type">int</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> mytype a = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> mytype b = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> mytype c = a * b;</span><br><span class="line">    <span class="keyword">return</span> c - (a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数体内部的 for 循环是一个非法操作。</p>
<p>以上三条规则不仅对应普通函数适用，对应类的成员函数也是适用的</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">constexpr</span> <span class="type">int</span> var = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span> * var;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test t;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> num = t.<span class="built_in">func</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;num: &quot;</span> &lt;&lt; num &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="模板函数"><a href="#模板函数" class="headerlink" title="模板函数"></a>模板函数</h3><p>如果 constexpr 修饰的模板函数实例化结果不满足常量表达式函数的要求，则 constexpr 会被自动忽略，即该函数就等同于一个普通函数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数模板</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T <span class="title">dispaly</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Person</span> p &#123; <span class="string">&quot;luffy&quot;</span>, <span class="number">19</span> &#125;;</span><br><span class="line">    <span class="comment">//普通函数</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Person</span> ret = <span class="built_in">dispaly</span>(p);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;luffy&#x27;s name: &quot;</span> &lt;&lt; ret.name &lt;&lt; <span class="string">&quot;, age: &quot;</span> &lt;&lt; ret.age &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//常量表达式函数</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> ret1 = <span class="built_in">dispaly</span>(<span class="number">250</span>);</span><br><span class="line">    cout &lt;&lt; ret1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">Person</span> p1 &#123; <span class="string">&quot;luffy&quot;</span>, <span class="number">19</span> &#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">Person</span> p2 = <span class="built_in">dispaly</span>(p1);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;luffy&#x27;s name: &quot;</span> &lt;&lt; p2.name &lt;&lt; <span class="string">&quot;, age: &quot;</span> &lt;&lt; p2.age &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>struct Person ret = dispaly(p);</code> 由于参数 p 是变量，所以实例化后的函数不是常量表达式函数，此时 constexpr 是无效的<br><code>constexpr int ret1 = dispaly(250);</code> 参数是常量，符合常量表达式函数的要求，此时 constexpr 是有效的<br><code>constexpr struct Person p2 = dispaly(p1);</code> 参数是常量，符合常量表达式函数的要求，此时 constexpr 是有效的</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数的函数体必须为空，并且必须采用初始化列表的方式为各个成员赋值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Person</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p, <span class="type">int</span> age)</span> :name(p), age(age)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">Person</span> <span class="built_in">p1</span>(<span class="string">&quot;luffy&quot;</span>, <span class="number">19</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;luffy&#x27;s name: &quot;</span> &lt;&lt; p1.name &lt;&lt; <span class="string">&quot;, age: &quot;</span> &lt;&lt; p1.age &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>nullptr</title>
    <url>/2021/06/15/nullptr/</url>
    <content><![CDATA[<h2 id="指针初始化"><a href="#指针初始化" class="headerlink" title="指针初始化"></a>指针初始化</h2><p>在 C++ 程序开发中，为了提高程序的健壮性，一般会在定义指针的同时完成初始化操作，或者在指针的指向尚未明确的情况下，都会给指针初始化为 NULL，避免产生野指针（没有明确指向的指针，操作也这种指针极可能导致程序发生异常）。C++98/03 标准中，将一个指针初始化为空指针的方式有 2 种：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *ptr = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> *ptr = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>在底层源码中 NULL 这个宏是这样定义的:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NULL</span></span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> NULL 0</span></span><br><span class="line">    <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="meta">#<span class="keyword">define</span> NULL ((void *)0)</span></span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>也就是说如果源码是 C++ 程序 NULL 就是 0，如果是 C 程序 NULL 表示 (void*)0。那么为什么要这样做呢？ 是由于 C++ 中，void * 类型无法隐式转换为其他类型的指针，此时使用 0 代替 ((void *)0)，用于解决空指针的问题。这个 0（0x0000 0000）表示的就是虚拟地址空间中的 0 地址，这块地址是只读的。</p>
<h2 id="虚拟地址空间结构图"><a href="#虚拟地址空间结构图" class="headerlink" title="虚拟地址空间结构图"></a>虚拟地址空间结构图</h2><p>C++ 中将 NULL 定义为字面常量 0，并不能保证在所有场景下都能很好的工作，比如，函数重载时，NULL 和 0 无法区分：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;void func(char *p)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;void func(int p)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="literal">NULL</span>);   <span class="comment">// 想要调用重载函数 void func(char *p)</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="number">250</span>);    <span class="comment">// 想要调用重载函数 void func(int p)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码打印的结果为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> p)</span></span></span><br></pre></td></tr></table></figure>
<p>通过打印的结果可以看到，虽然调用 func(NULL); 最终链接到的还是 void func(int p) 和预期是不一样的，其实这个原因前边已经说的很明白了，在 C++ 中 NULL 和 0 是等价的。</p>
<h2 id="nullptr"><a href="#nullptr" class="headerlink" title="nullptr"></a>nullptr</h2><p>出于兼容性的考虑，C++11 标准并没有对 NULL 的宏定义做任何修改，而是另其炉灶，引入了一个新的关键字 nullptr。nullptr 专用于初始化空类型指针，不同类型的指针变量都可以使用 nullptr 来初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>*    ptr1 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">char</span>*   ptr2 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">double</span>* ptr3 = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
<p>对应上面的代码编译器会分别将 nullptr 隐式转换成 int<em>、char</em> 以及 double* 指针类型。</p>
<p>使用 nullptr 可以很完美的解决上边提到的函数重载问题:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">char</span> *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;void func(char *p)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;void func(int p)&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">250</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码输出的结果:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">char</span> *p)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> p)</span></span></span><br></pre></td></tr></table></figure>
<p>通过输出的结果可以看出，nullptr 无法隐式转换为整形，但是可以隐式匹配指针类型。在 C++11 标准下，相比 NULL 和 0，使用 nullptr 初始化空指针可以令我们编写的程序更加健壮。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb watch命令</title>
    <url>/2021/06/14/gdb-watch%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>使用 GDB 调试程序的过程中，借助观察断点可以监控程序中某个变量或者表达式的值，只要发生改变，程序就会停止执行。相比普通断点，观察断点不需要我们预测变量（表达式）值发生改变的具体位置。</p>
<span id="more"></span>

<p><code>rwatch</code>：只要程序中出现读取目标变量（表达式）的值的操作，程序就会停止运行；<br><code>awatch</code>：只要程序中出现读取目标变量（表达式）的值或者改变值的操作，程序就会停止运行。<br><code>watch</code> ：只有当被监控变量（表达式）的值发生改变，程序才会停止运行。</p>
<h2 id="gdb内存监控"><a href="#gdb内存监控" class="headerlink" title="gdb内存监控"></a>gdb内存监控</h2><p>gdb的watch的内存功能，使用场景一般是发现的情况，要查清楚一块内存被谁给踩了，我们直接使用watch 监控它就可以了。</p>
<p><code>watch *(int*)内存地址</code>: 当监控的内存的内容发生变化（即写操作）时，程序停止运行。<br><code>rwatch *(int*)内存地址</code>: 当监控的内存的内容发生读操作时， 程序停止运行。<br><code>awatch *(int*)内存地址</code>: 当监控的内存被读或被写时，程序停止运行。<br>例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(gdb) watch *(<span class="keyword">volatile</span> guint *)<span class="number">0x5632520866f8</span></span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Thread <span class="number">6</span> <span class="string">&quot;MONITOR_1&quot;</span> hit Hardware watchpoint <span class="number">3</span>: *(<span class="keyword">volatile</span> guint *)<span class="number">0x5632520866f8</span></span><br><span class="line"></span><br><span class="line">Old value = <span class="number">1</span></span><br><span class="line">New value = <span class="number">2</span></span><br><span class="line"><span class="number">0x00007ffba96d0c01</span> in g_object_ref () from /usr/lib/x86_64-linux-gnu/libgobject<span class="number">-2.0</span>.so<span class="number">.0</span></span><br><span class="line">(gdb) p *(<span class="keyword">volatile</span> guint *)<span class="number">0x5632520866f8</span></span><br><span class="line">$<span class="number">6</span> = <span class="number">2</span></span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="comment">//调用栈</span></span><br></pre></td></tr></table></figure>

<h2 id="多线程调试"><a href="#多线程调试" class="headerlink" title="多线程调试"></a>多线程调试</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">&#125;test;</span><br><span class="line"></span><br><span class="line">test *t;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">func</span><span class="params">(<span class="type">void</span> *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *num = (<span class="type">int</span> *)args;</span><br><span class="line">    <span class="keyword">while</span>(*num &lt;= <span class="number">100</span>)</span><br><span class="line">    &#123;</span><br><span class="line">       *num *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    t = (test *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(test));</span><br><span class="line">    t-&gt;num = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_t</span> th;</span><br><span class="line">    pthread_create(&amp;th, <span class="literal">NULL</span>, func, &amp;t-&gt;num);</span><br><span class="line">    pthread_join(th, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; t-&gt;num &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调试记录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) b 28</span><br><span class="line">Breakpoint 1 at 0xa64: file test.cpp, line 28.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/rma/mr_work/test/cpp_test/test </span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library <span class="string">&quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;</span>.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at test.cpp:28</span><br><span class="line">28          t = (<span class="built_in">test</span> *)malloc(sizeof(<span class="built_in">test</span>));</span><br><span class="line">(gdb) watch t-&gt;num</span><br><span class="line">Hardware watchpoint 2: t-&gt;num</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Hardware watchpoint 2: t-&gt;num</span><br><span class="line"></span><br><span class="line">Old value = &lt;unreadable&gt;</span><br><span class="line">New value = 0</span><br><span class="line">main () at test.cpp:29</span><br><span class="line">29          t-&gt;num = 1;</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Hardware watchpoint 2: t-&gt;num</span><br><span class="line"></span><br><span class="line">Old value = 0</span><br><span class="line">New value = 1</span><br><span class="line">main () at test.cpp:32</span><br><span class="line">32          pthread_create(&amp;th, NULL, func, &amp;t-&gt;num);</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line">[New Thread 0x7ffff6e83700 (LWP 17075)]</span><br><span class="line">[Switching to Thread 0x7ffff6e83700 (LWP 17075)]</span><br><span class="line"></span><br><span class="line">Thread 2 <span class="string">&quot;test&quot;</span> hit Hardware watchpoint 2: t-&gt;num</span><br><span class="line"></span><br><span class="line">Old value = 1</span><br><span class="line">New value = 2</span><br><span class="line">func (args=0x555555614e70) at test.cpp:18</span><br><span class="line">18          <span class="keyword">while</span>(*num &lt;= 100)</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Thread 2 <span class="string">&quot;test&quot;</span> hit Hardware watchpoint 2: t-&gt;num</span><br><span class="line"></span><br><span class="line">Old value = 2</span><br><span class="line">New value = 4</span><br><span class="line">func (args=0x555555614e70) at test.cpp:18</span><br><span class="line">18          <span class="keyword">while</span>(*num &lt;= 100)</span><br><span class="line">(gdb) c</span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Thread 2 <span class="string">&quot;test&quot;</span> hit Hardware watchpoint 2: t-&gt;num</span><br><span class="line"></span><br><span class="line">Old value = 4</span><br><span class="line">New value = 8</span><br><span class="line">func (args=0x555555614e70) at test.cpp:18</span><br><span class="line">18          <span class="keyword">while</span>(*num &lt;= 100)</span><br><span class="line">(gdb) </span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Thread 2 <span class="string">&quot;test&quot;</span> hit Hardware watchpoint 2: t-&gt;num</span><br><span class="line"></span><br><span class="line">Old value = 8</span><br><span class="line">New value = 16</span><br><span class="line">func (args=0x555555614e70) at test.cpp:18</span><br><span class="line">18          <span class="keyword">while</span>(*num &lt;= 100)</span><br><span class="line">(gdb) </span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Thread 2 <span class="string">&quot;test&quot;</span> hit Hardware watchpoint 2: t-&gt;num</span><br><span class="line"></span><br><span class="line">Old value = 16</span><br><span class="line">New value = 32</span><br><span class="line">func (args=0x555555614e70) at test.cpp:18</span><br><span class="line">18          <span class="keyword">while</span>(*num &lt;= 100)</span><br><span class="line">(gdb) </span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Thread 2 <span class="string">&quot;test&quot;</span> hit Hardware watchpoint 2: t-&gt;num</span><br><span class="line"></span><br><span class="line">Old value = 32</span><br><span class="line">New value = 64</span><br><span class="line">func (args=0x555555614e70) at test.cpp:18</span><br><span class="line">18          <span class="keyword">while</span>(*num &lt;= 100)</span><br><span class="line">(gdb) </span><br><span class="line">Continuing.</span><br><span class="line"></span><br><span class="line">Thread 2 <span class="string">&quot;test&quot;</span> hit Hardware watchpoint 2: t-&gt;num</span><br><span class="line"></span><br><span class="line">Old value = 64</span><br><span class="line">New value = 128</span><br><span class="line">func (args=0x555555614e70) at test.cpp:18</span><br><span class="line">18          <span class="keyword">while</span>(*num &lt;= 100)</span><br><span class="line">(gdb) </span><br><span class="line">Continuing.</span><br><span class="line">128</span><br><span class="line">[Thread 0x7ffff6e83700 (LWP 17075) exited]</span><br><span class="line">[Inferior 1 (process 17006) exited normally]</span><br><span class="line">(gdb) </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>当监控的变量（表达式）为局部变量（表达式）时，一旦局部变量（表达式）失效，则监控操作也随即失效；</li>
<li>如果监控的是一个指针变量（例如 *p），则 watch *p 和 watch p 是有区别的，前者监控的是 p 所指数据的变化情况，而后者监控的是 p 指针本身有没有改变指向；</li>
<li>这 3 个监控命令还可以用于监控数组中元素值的变化情况，例如对于 a[10] 这个数组，watch a 表示只要 a 数组中存储的数据发生改变，程序就会停止执行。</li>
<li>调试多线程的时候尽量使用全局变量</li>
</ul>
]]></content>
      <categories>
        <category>进程调试</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11 noexcept关键字</title>
    <url>/2021/06/13/C-11-noexcept%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>C++11新标准引入的noexcept运算符，可以用于指定某个函数不抛出异常。预先知道函数不会抛出异常有助于简化调用该函数的代码，而且编译器确认函数不会抛出异常，它就能执行某些特殊的优化操作。</p>
<span id="more"></span>

<h2 id="noexcept异常说明"><a href="#noexcept异常说明" class="headerlink" title="noexcept异常说明"></a>noexcept异常说明</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span> <span class="keyword">noexcept</span></span>;  <span class="comment">//不抛出异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(<span class="type">int</span> x)</span></span>;  <span class="comment">//抛出异常</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对于一个函数来说，noexcept说明要么出现在该函数的所有生命语句和定义语句中，要么一次也不出现。</li>
<li>可以在函数指针的声明和定义中指定noexcept。</li>
<li>在typedef和类型别名中不可以出现noexcept。</li>
<li>在成员函数中，noexcept需要跟在const以及引用限定符之后，在final、override或虚函数=0之前。</li>
</ul>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>week_ptr</title>
    <url>/2021/06/12/week-ptr/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>std::weak_ptr</code> 可以看做是 shared_ptr 的助手，它不管理 shared_ptr 内部的指针。std::weak_ptr 没有重载操作符 * 和 -&gt;，因为它不共享指针，不能操作资源，所以它的构造不会增加引用计数，析构也不会减少引用计数，它的主要作用就是作为一个旁观者监视 shared_ptr 中管理的资源是否存在。</p>
<span id="more"></span>

<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">weak_ptr</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"><span class="comment">// 拷贝构造</span></span><br><span class="line"><span class="built_in">weak_ptr</span> (<span class="type">const</span> weak_ptr&amp; x) <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt; <span class="built_in">weak_ptr</span> (<span class="type">const</span> weak_ptr&lt;U&gt;&amp; x) <span class="keyword">noexcept</span>;</span><br><span class="line"><span class="comment">// 通过shared_ptr对象构造</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U</span>&gt; <span class="built_in">weak_ptr</span> (<span class="type">const</span> shared_ptr&lt;U&gt;&amp; x) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure>

<p>在 C++11 中，weak_ptr 的初始化可以通过以上提供的构造函数来完成初始化，具体使用方法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; wp1;</span><br><span class="line">    <span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp2</span><span class="params">(wp1)</span></span>;</span><br><span class="line">    <span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp3</span><span class="params">(sp)</span></span>;</span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; wp4;</span><br><span class="line">    wp4 = sp;</span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; wp5;</span><br><span class="line">    wp5 = wp3;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// weak_ptr&lt;int&gt; wp1; 构造了一个空 weak_ptr 对象</span></span><br><span class="line"><span class="comment">// weak_ptr&lt;int&gt; wp2(wp1); 通过一个空 weak_ptr 对象构造了另一个空 weak_ptr 对象</span></span><br><span class="line"><span class="comment">// weak_ptr&lt;int&gt; wp3(sp); 通过一个 shared_ptr 对象构造了一个可用的 weak_ptr 实例对象</span></span><br><span class="line"><span class="comment">// wp4 = sp; 通过一个 shared_ptr 对象构造了一个可用的 weak_ptr 实例对象（这是一个隐式类型转换）</span></span><br><span class="line"><span class="comment">// wp5 = wp3; 通过一个 weak_ptr 对象构造了一个可用的 weak_ptr 实例对象</span></span><br></pre></td></tr></table></figure>

<h2 id="其他常用方法"><a href="#其他常用方法" class="headerlink" title="其他常用方法"></a>其他常用方法</h2><h3 id="use-count"><a href="#use-count" class="headerlink" title="use_count()"></a>use_count()</h3><p>通过调用 std::weak_ptr 类提供的 use_count() 方法可以获得当前所观测资源的引用计数<br>修改一下上面的测试程序，添加打印资源引用计数的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; wp1;</span><br><span class="line">    <span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp2</span><span class="params">(wp1)</span></span>;</span><br><span class="line">    <span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp3</span><span class="params">(sp)</span></span>;</span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; wp4;</span><br><span class="line">    wp4 = sp;</span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; wp5;</span><br><span class="line">    wp5 = wp3;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use_count: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;wp1: &quot;</span> &lt;&lt; wp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;wp2: &quot;</span> &lt;&lt; wp2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;wp3: &quot;</span> &lt;&lt; wp3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;wp4: &quot;</span> &lt;&lt; wp4.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;wp5: &quot;</span> &lt;&lt; wp5.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">use_count:</span></span><br><span class="line"><span class="comment">wp1: 0</span></span><br><span class="line"><span class="comment">wp2: 0</span></span><br><span class="line"><span class="comment">wp3: 1</span></span><br><span class="line"><span class="comment">wp4: 1</span></span><br><span class="line"><span class="comment">wp5: 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>通过打印的结果可以知道，虽然弱引用智能指针 wp3、wp4、wp5 监测的资源是同一个，但是它的引用计数并没有发生任何的变化，也进一步证明了 weak_ptr只是监测资源，并不管理资源。</p>
<h3 id="expired"><a href="#expired" class="headerlink" title="expired()"></a>expired()</h3><p>通过调用 std::weak_ptr 类提供的 expired() 方法来判断观测的资源是否已经被释放，函数原型如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回true表示资源已经被释放, 返回false表示资源没有被释放</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">expired</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数的使用方法如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">shared</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">weak</span><span class="params">(shared)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1. weak &quot;</span> &lt;&lt; (weak.<span class="built_in">expired</span>() ? <span class="string">&quot;is&quot;</span> : <span class="string">&quot;is not&quot;</span>) &lt;&lt; <span class="string">&quot; expired&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    shared.<span class="built_in">reset</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2. weak &quot;</span> &lt;&lt; (weak.<span class="built_in">expired</span>() ? <span class="string">&quot;is&quot;</span> : <span class="string">&quot;is not&quot;</span>) &lt;&lt; <span class="string">&quot; expired&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. weak is not expired</span></span><br><span class="line"><span class="comment">2. weak is expired</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>weak_ptr 监测的就是 shared_ptr 管理的资源，当共享智能指针调用 shared.reset(); 之后管理的资源被释放，因此 weak.expired() 函数的结果返回 true，表示监测的资源已经不存在了。</p>
<h3 id="lock"><a href="#lock" class="headerlink" title="lock()"></a>lock()</h3><p>通过调用 std::weak_ptr 类提供的 lock() 方法来获取管理所监测资源的 shared_ptr 对象，函数原型如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;element_type&gt; <span class="title">lock</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数的使用方法如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; sp1, sp2;</span><br><span class="line">    weak_ptr&lt;<span class="type">int</span>&gt; wp;</span><br><span class="line"></span><br><span class="line">    sp1 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">520</span>);</span><br><span class="line">    wp = sp1;</span><br><span class="line">    sp2 = wp.<span class="built_in">lock</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use_count: &quot;</span> &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    sp1.<span class="built_in">reset</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use_count: &quot;</span> &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    sp1 = wp.<span class="built_in">lock</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use_count: &quot;</span> &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*sp1: &quot;</span> &lt;&lt; *sp1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;*sp2: &quot;</span> &lt;&lt; *sp2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">use_count: 2</span></span><br><span class="line"><span class="comment">use_count: 1</span></span><br><span class="line"><span class="comment">use_count: 2</span></span><br><span class="line"><span class="comment">*sp1: 520</span></span><br><span class="line"><span class="comment">*sp2: 520</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><code>sp2 = wp.lock();</code> lock()方法得到一个shared_ptr，使用这个对象初始化sp2，此时所监测资源的引用计数为 2<br><code>sp1.reset();</code> 共享智能指针 sp1 被重置，weak_ptr 对象所监测的资源的引用计数减 1<br><code>sp1 = wp.lock();</code>sp1 重新被初始化，并且管理的还是 weak_ptr 对象所监测的资源，因此引用计数加 1</p>
<h3 id="reset"><a href="#reset" class="headerlink" title="reset()"></a>reset()</h3><p>通过调用 std::weak_ptr 类提供的 reset() 方法来清空对象，使其不监测任何资源，函数原型如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>
<p>函数的使用是非常简单的，示例代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp</span><span class="params">(sp)</span></span>;</span><br><span class="line">    cout &lt;&lt; sp.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1. wp &quot;</span> &lt;&lt; (wp.<span class="built_in">expired</span>() ? <span class="string">&quot;is&quot;</span> : <span class="string">&quot;is not&quot;</span>) &lt;&lt; <span class="string">&quot; expired&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    wp.<span class="built_in">reset</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2. wp &quot;</span> &lt;&lt; (wp.<span class="built_in">expired</span>() ? <span class="string">&quot;is&quot;</span> : <span class="string">&quot;is not&quot;</span>) &lt;&lt; <span class="string">&quot; expired&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; sp.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">1. wp is not expired</span></span><br><span class="line"><span class="comment">2. wp is expired</span></span><br><span class="line"><span class="comment">1</span></span><br><span class="line"><span class="comment">0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>weak_ptr 对象 sp 被重置之后 wp.reset(); 变成了空对象，不再监测任何资源，因此 wp.expired() 返回 true</p>
<h2 id="返回管理-this-的-shared-ptr"><a href="#返回管理-this-的-shared-ptr" class="headerlink" title="返回管理 this 的 shared_ptr"></a>返回管理 this 的 shared_ptr</h2><p>如果在一个类中编写了一个函数，通过这个得到管理当前对象的共享智能指针，我们可能会写出如下代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;Test&gt; <span class="title">getSharedPtr</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;Test&gt;(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">Test</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;class Test is disstruct ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;Test&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> Test)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use_count: &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    shared_ptr&lt;Test&gt; sp2 = sp1-&gt;<span class="built_in">getSharedPtr</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use_count: &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">use_count: 1</span></span><br><span class="line"><span class="comment">use_count: 1</span></span><br><span class="line"><span class="comment">class Test is disstruct ...</span></span><br><span class="line"><span class="comment">class Test is disstruct ...</span></span><br><span class="line"><span class="comment">free(): double free detected in tcache 2</span></span><br><span class="line"><span class="comment">Aborted</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>通过输出的结果可以看到一个对象被析构了两次，其原因是这样的：在这个例子中使用同一个指针 this 构造了两个智能指针对象 sp1 和 sp2，这二者之间是没有任何关系的，因为 sp2 并不是通过 sp1 初始化得到的实例对象。在离开作用域之后 this 将被构造的两个智能指针各自析构，导致重复析构的错误。</p>
<p>这个问题可以通过 weak_ptr 来解决，通过 weak_ptr 返回管理 this 资源的共享智能指针对象 shared_ptr。C++11 中为我们提供了一个模板类叫做 std::enable_shared_from_this<T>，这个类中有一个方法叫做 shared_from_this()，通过这个方法可以返回一个共享智能指针，在函数的内部就是使用 weak_ptr 来监测 this 对象，并通过调用 weak_ptr 的 lock() 方法返回一个 shared_ptr 对象。</T></p>
<p>修改之后的代码为：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span> : <span class="keyword">public</span> enable_shared_from_this&lt;Test&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;Test&gt; <span class="title">getSharedPtr</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">shared_from_this</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;class Test is disstruct ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;Test&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> Test)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use_count: &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    shared_ptr&lt;Test&gt; sp2 = sp1-&gt;<span class="built_in">getSharedPtr</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;use_count: &quot;</span> &lt;&lt; sp1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">use_count: 1</span></span><br><span class="line"><span class="comment">use_count: 2</span></span><br><span class="line"><span class="comment">class Test is disstruct ...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="解决循环引用问题"><a href="#解决循环引用问题" class="headerlink" title="解决循环引用问题"></a>解决循环引用问题</h2><p>智能指针如果循环引用会导致内存泄露，比如下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TA</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TA</span></span><br><span class="line">&#123;</span><br><span class="line">    shared_ptr&lt;TB&gt; bptr;</span><br><span class="line">    ~<span class="built_in">TA</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;class TA is disstruct ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TB</span></span><br><span class="line">&#123;</span><br><span class="line">    shared_ptr&lt;TA&gt; aptr;</span><br><span class="line">    ~<span class="built_in">TB</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;class TB is disstruct ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testPtr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;TA&gt; <span class="title">ap</span><span class="params">(<span class="keyword">new</span> TA)</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;TB&gt; <span class="title">bp</span><span class="params">(<span class="keyword">new</span> TB)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;TA object use_count: &quot;</span> &lt;&lt; ap.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;TB object use_count: &quot;</span> &lt;&lt; bp.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ap-&gt;bptr = bp;</span><br><span class="line">    bp-&gt;aptr = ap;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;TA object use_count: &quot;</span> &lt;&lt; ap.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;TB object use_count: &quot;</span> &lt;&lt; bp.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">testPtr</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">TA object use_count: 1</span></span><br><span class="line"><span class="comment">TB object use_count: 1</span></span><br><span class="line"><span class="comment">TA object use_count: 2</span></span><br><span class="line"><span class="comment">TB object use_count: 2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>在测试程序中，共享智能指针 ap、bp 对 TA、TB 实例对象的引用计数变为 2，在共享智能指针离开作用域之后引用计数只能减为1，这种情况下不会去删除智能指针管理的内存，导致类 TA、TB 的实例对象不能被析构，最终造成内存泄露。通过使用 weak_ptr 可以解决这个问题，只要将类 TA 或者 TB 的任意一个成员改为 weak_ptr，修改之后的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TA</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TA</span></span><br><span class="line">&#123;</span><br><span class="line">    weak_ptr&lt;TB&gt; bptr;</span><br><span class="line">    ~<span class="built_in">TA</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;class TA is disstruct ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TB</span></span><br><span class="line">&#123;</span><br><span class="line">    shared_ptr&lt;TA&gt; aptr;</span><br><span class="line">    ~<span class="built_in">TB</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;class TB is disstruct ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testPtr</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;TA&gt; <span class="title">ap</span><span class="params">(<span class="keyword">new</span> TA)</span></span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;TB&gt; <span class="title">bp</span><span class="params">(<span class="keyword">new</span> TB)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;TA object use_count: &quot;</span> &lt;&lt; ap.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;TB object use_count: &quot;</span> &lt;&lt; bp.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ap-&gt;bptr = bp;</span><br><span class="line">    bp-&gt;aptr = ap;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;TA object use_count: &quot;</span> &lt;&lt; ap.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;TB object use_count: &quot;</span> &lt;&lt; bp.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">testPtr</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">TA object use_count: 1</span></span><br><span class="line"><span class="comment">TB object use_count: 1</span></span><br><span class="line"><span class="comment">TA object use_count: 2</span></span><br><span class="line"><span class="comment">TB object use_count: 1</span></span><br><span class="line"><span class="comment">class TB is disstruct ...</span></span><br><span class="line"><span class="comment">class TA is disstruct ...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>通过输出的结果可以看到类 TA 或者 TB 的对象被成功析构了。</p>
<p>上面程序中，在对类 TA 成员赋值时 ap-&gt;bptr = bp; 由于 bptr 是 weak_ptr 类型，这个赋值操作并不会增加引用计数，所以 bp 的引用计数仍然为 1，在离开作用域之后 bp 的引用计数减为 0，类 TB 的实例对象被析构。</p>
<p>在类 TB 的实例对象被析构的时候，内部的 aptr 也被析构，其对 TA 对象的管理解除，内存的引用计数减为 1，当共享智能指针 ap 离开作用域之后，对 TA 对象的管理也解除了，内存的引用计数减为 0，类 TA 的实例对象被析构。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>unique_ptr</title>
    <url>/2021/06/11/unique-ptr/</url>
    <content><![CDATA[<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p><code>std::unique_ptr</code> 是一个独占型的智能指针，它不允许其他的智能指针共享其内部的指针，可以通过它的<strong>构造函数</strong>初始化一个独占智能指针对象，但是<strong>不允许通过赋值</strong>将一个 unique_ptr 赋值给另一个 unique_ptr。</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过构造函数初始化对象</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line"><span class="comment">// error, 不允许将一个unique_ptr赋值给另一个unique_ptr</span></span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1;</span><br></pre></td></tr></table></figure>
<p>std::unique_ptr 不允许复制，但是可以通过函数返回给其他的 std::unique_ptr，还可以通过 <code>std::move</code> 来转译给其他的 std::unique_ptr，这样原始指针的所有权就被转移了，这个原始指针还是被独占的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;<span class="type">int</span>&gt;(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">520</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 通过构造函数初始化</span></span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="comment">// 通过转移所有权的方式初始化</span></span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = <span class="built_in">move</span>(ptr1);</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; ptr3 = <span class="built_in">func</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 reset 方法可以让 unique_ptr 解除对原始内存的管理，也可以用来初始化一个独占的智能指针。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = <span class="built_in">move</span>(ptr1);</span><br><span class="line"></span><br><span class="line">    ptr1.<span class="built_in">reset</span>();</span><br><span class="line">    ptr2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">250</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">ptr1.<span class="built_in">reset</span>(); 解除对原始内存的管理</span><br><span class="line">ptr2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">250</span>)); 重新指定智能指针管理的原始内存</span><br></pre></td></tr></table></figure>
<p>如果想要获取独占智能指针管理的原始地址，可以调用 get () 方法</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt; ptr2 = <span class="built_in">move</span>(ptr1);</span><br><span class="line"></span><br><span class="line">    ptr2.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">250</span>));</span><br><span class="line">    cout &lt;&lt; *ptr2.<span class="built_in">get</span>() &lt;&lt; endl;	<span class="comment">// 得到内存地址中存储的实际数值 250</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除器"><a href="#删除器" class="headerlink" title="删除器"></a>删除器</h2><p>unique_ptr 指定删除器和 shared_ptr 指定删除器是有区别的，unique_ptr 指定删除器的时候需要确定删除器的类型，所以不能像 shared_ptr 那样直接指定删除器，举例说明：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>), [](<span class="type">int</span>*p) &#123;<span class="keyword">delete</span> p; &#125;)</span></span>;	<span class="comment">// ok</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>), [](<span class="type">int</span>*p) &#123;<span class="keyword">delete</span> p; &#125;)</span></span>;	<span class="comment">// error</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> func_ptr = <span class="built_in">void</span>(*)(<span class="type">int</span>*);</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>, func_ptr&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>), [](<span class="type">int</span>*p) &#123;<span class="keyword">delete</span> p; &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中第 7 行，func_ptr 的类型和 lambda表达式的类型是一致的。在 lambda 表达式没有捕获任何变量的情况下是正确的，如果捕获了变量，编译时则会报错：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> func_ptr = <span class="built_in">void</span>(*)(<span class="type">int</span>*);</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>, func_ptr&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>), [&amp;](<span class="type">int</span>*p) &#123;<span class="keyword">delete</span> p; &#125;)</span></span>;	<span class="comment">// error</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中错误原因是这样的，在 lambda 表达式没有捕获任何外部变量时，可以直接转换为函数指针，一旦捕获了就无法转换了，如果想要让编译器成功通过编译，那么需要使用可调用<strong>对象包装器</strong>来处理声明的函数指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> func_ptr = <span class="built_in">void</span>(*)(<span class="type">int</span>*);</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>, function&lt;<span class="type">void</span>(<span class="type">int</span>*)&gt;&gt; <span class="built_in">ptr1</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>), [&amp;](<span class="type">int</span>*p) &#123;<span class="keyword">delete</span> p; &#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>shared_ptr</title>
    <url>/2021/06/10/shared-ptr/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>智能指针是存储指向动态分配（堆）对象指针的类，用于生存期的控制，能够确保在离开指针所在作用域时，自动地销毁动态分配的对象，防止内存泄露。</li>
<li>智能指针的核心实现技术是<strong>引用计数</strong>，每使用它一次，内部引用计数加1，每析构一次内部的引用计数减1，减为0时，删除所指向的堆内存。<span id="more"></span></li>
</ul>
<p>C++11 中提供了三种智能指针，使用这些智能指针时需要引用头文件 <memory>：</memory></p>
<p><code>std::shared_ptr</code>：共享的智能指针<br><code>std::unique_ptr</code>：独占的智能指针<br><code>std::weak_ptr</code>：弱引用的智能指针，它不共享指针，不能操作资源，是用来监视 shared_ptr 的。</p>
<h2 id="shared-ptr-的初始化"><a href="#shared-ptr-的初始化" class="headerlink" title="shared_ptr 的初始化"></a>shared_ptr 的初始化</h2><p>共享智能指针是指多个智能指针可以同时管理同一块有效的内存，共享智能指针 <strong>shared_ptr 是一个模板类</strong>，如果要进行初始化有三种方式：</p>
<ul>
<li>通过构造函数</li>
<li>通过拷贝和移动构造函数初始化</li>
<li>std::make_shared </li>
</ul>
<p>如果想要查看当前有多少个智能指针同时管理着这块内存可以使用 <code>use_count</code></p>
<h3 id="通过构造函数初始化"><a href="#通过构造函数初始化" class="headerlink" title="通过构造函数初始化"></a>通过构造函数初始化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// shared_ptr&lt;T&gt; 类模板中，提供了多种实用的构造函数, 语法格式如下:</span></span><br><span class="line">std::shared_ptr&lt;T&gt; 智能指针名字(创建堆内存);</span><br></pre></td></tr></table></figure>
<p>测试代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用智能指针管理一块 int 型的堆内存</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">520</span>))</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1管理的内存引用计数: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 使用智能指针管理一块字符数组对应的堆内存</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">char</span>&gt; <span class="title">ptr2</span><span class="params">(<span class="keyword">new</span> <span class="type">char</span>[<span class="number">12</span>])</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr2管理的内存引用计数: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 创建智能指针对象, 不管理任何内存</span></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr3;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr3管理的内存引用计数: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">// 创建智能指针对象, 初始化为空</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr4</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr4管理的内存引用计数: &quot;</span> &lt;&lt; ptr4.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ptr1管理的内存引用计数: 1</span></span><br><span class="line"><span class="comment">// ptr2管理的内存引用计数: 1</span></span><br><span class="line"><span class="comment">// ptr3管理的内存引用计数: 0</span></span><br><span class="line"><span class="comment">// ptr4管理的内存引用计数: 0</span></span><br></pre></td></tr></table></figure>
<p>如果智能指针被初始化了一块有效内存，那么这块内存的引用计数 + 1，<br>如果智能指针没有被初始化或者被初始化为 nullptr 空指针，引用计数不会 + 1。<br>另外，<strong>不要使用一个原始指针初始化多个 shared_ptr</strong>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(p)</span></span>;</span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(p)</span></span>;		<span class="comment">// error, 编译不会报错, 运行会出错</span></span><br></pre></td></tr></table></figure>

<h3 id="通过拷贝和移动构造函数初始化"><a href="#通过拷贝和移动构造函数初始化" class="headerlink" title="通过拷贝和移动构造函数初始化"></a>通过拷贝和移动构造函数初始化</h3><p>当一个智能指针被初始化之后，就可以通过这个智能指针初始化其他新对象。在创建新对象的时候，对应的拷贝构造函数或者移动构造函数就被自动调用了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">520</span>))</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1管理的内存引用计数: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//调用拷贝构造函数</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr2</span><span class="params">(ptr1)</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr2管理的内存引用计数: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr3 = ptr1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr3管理的内存引用计数: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//调用移动构造函数</span></span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr4</span><span class="params">(std::move(ptr1))</span></span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr4管理的内存引用计数: &quot;</span> &lt;&lt; ptr4.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    std::shared_ptr&lt;<span class="type">int</span>&gt; ptr5 = std::<span class="built_in">move</span>(ptr2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr5管理的内存引用计数: &quot;</span> &lt;&lt; ptr5.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ptr1管理的内存引用计数: 1</span></span><br><span class="line"><span class="comment">// ptr2管理的内存引用计数: 2</span></span><br><span class="line"><span class="comment">// ptr3管理的内存引用计数: 3</span></span><br><span class="line"><span class="comment">// ptr4管理的内存引用计数: 3</span></span><br><span class="line"><span class="comment">// ptr5管理的内存引用计数: 3</span></span><br></pre></td></tr></table></figure>
<p>如果使用拷贝的方式初始化共享智能指针对象，这两个对象会同时管理同一块堆内存，堆内存对应的引用计数也会增加；如果使用移动的方式初始智能指针对象，只是转让了内存的所有权，管理内存的对象并不会增加，因此内存的引用计数不会变化。</p>
<h3 id="通过-std-make-shared-初始化"><a href="#通过-std-make-shared-初始化" class="headerlink" title="通过 std::make_shared 初始化"></a>通过 std::make_shared 初始化</h3><p>通过 C++ 提供的 <code>std::make_shared()</code> 就可以完成内存对象的创建并将其初始化给智能指针，函数原型如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> T, <span class="keyword">class</span>... Args &gt;</span></span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">make_shared</span><span class="params">( Args&amp;&amp;... args )</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>T</code>：模板参数的数据类型<br><code>Args&amp;&amp;... args</code> ：要初始化的数据，如果是通过 make_shared 创建对象，需按照构造函数的参数列表指定<br>测试代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct Test...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> x) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct Test, x = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Test</span>(string str) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct Test, str = &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Test</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;destruct Test ...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1</span></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">520</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1管理的内存引用计数: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;Test&gt; ptr2 = <span class="built_in">make_shared</span>&lt;Test&gt;();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr2管理的内存引用计数: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;Test&gt; ptr3 = <span class="built_in">make_shared</span>&lt;Test&gt;(<span class="number">520</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr3管理的内存引用计数: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;Test&gt; ptr4 = <span class="built_in">make_shared</span>&lt;Test&gt;(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr4管理的内存引用计数: &quot;</span> &lt;&lt; ptr4.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    Test *ptr5 = <span class="keyword">new</span> <span class="built_in">Test</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// delete ptr5;       // 不写delete的话不会释放内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ptr1管理的内存引用计数: 1</span></span><br><span class="line"><span class="comment">construct Test...</span></span><br><span class="line"><span class="comment">ptr2管理的内存引用计数: 1</span></span><br><span class="line"><span class="comment">construct Test, x = 520</span></span><br><span class="line"><span class="comment">ptr3管理的内存引用计数: 1</span></span><br><span class="line"><span class="comment">construct Test, str = test</span></span><br><span class="line"><span class="comment">ptr4管理的内存引用计数: 1</span></span><br><span class="line"><span class="comment">construct Test, x = 5</span></span><br><span class="line"><span class="comment">destruct Test ...</span></span><br><span class="line"><span class="comment">destruct Test ...</span></span><br><span class="line"><span class="comment">destruct Test ...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>使用 std::make_shared() 模板函数可以完成内存地址的创建，并将最终得到的内存地址传递给共享智能指针对象管理。如果申请的内存是普通类型，通过函数的（）可完成地址的初始化，如果要创建一个类对象，函数的（）内部需要指定构造对象需要的参数，也就是类构造函数的参数。</p>
<h3 id="通过-reset-方法初始化"><a href="#通过-reset-方法初始化" class="headerlink" title="通过 reset 方法初始化"></a>通过 reset 方法初始化</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用智能指针管理一块 int 型的堆内存, 内部引用计数为 1</span></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">520</span>);</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr2 = ptr1;</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr3 = ptr1;</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr4 = ptr1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1管理的内存引用计数: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr2管理的内存引用计数: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr3管理的内存引用计数: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr4管理的内存引用计数: &quot;</span> &lt;&lt; ptr4.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    ptr4.<span class="built_in">reset</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr1管理的内存引用计数: &quot;</span> &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr2管理的内存引用计数: &quot;</span> &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr3管理的内存引用计数: &quot;</span> &lt;&lt; ptr3.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr4管理的内存引用计数: &quot;</span> &lt;&lt; ptr4.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr5;</span><br><span class="line">    ptr5.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">250</span>));</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ptr5管理的内存引用计数: &quot;</span> &lt;&lt; ptr5.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ptr1管理的内存引用计数: 4</span></span><br><span class="line"><span class="comment">ptr2管理的内存引用计数: 4</span></span><br><span class="line"><span class="comment">ptr3管理的内存引用计数: 4</span></span><br><span class="line"><span class="comment">ptr4管理的内存引用计数: 4</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">ptr1管理的内存引用计数: 3</span></span><br><span class="line"><span class="comment">ptr2管理的内存引用计数: 3</span></span><br><span class="line"><span class="comment">ptr3管理的内存引用计数: 3</span></span><br><span class="line"><span class="comment">ptr4管理的内存引用计数: 0</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">ptr5管理的内存引用计数: 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>对于一个未初始化的共享智能指针，可以通过 reset 方法来初始化，当智能指针中有值的时候，调用 reset 会使引用计数减 1。</p>
<h2 id="获取原始指针"><a href="#获取原始指针" class="headerlink" title="获取原始指针"></a>获取原始指针</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">T* <span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="number">128</span>;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">char</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">char</span>[len])</span></span>;</span><br><span class="line">    <span class="comment">// 得到指针的原始地址</span></span><br><span class="line">    <span class="type">char</span>* add = ptr.<span class="built_in">get</span>();</span><br><span class="line">    <span class="built_in">memset</span>(add, <span class="number">0</span>, len);</span><br><span class="line">    <span class="built_in">strcpy</span>(add, <span class="string">&quot;test&quot;</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;string: &quot;</span> &lt;&lt; add &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line">    *p = <span class="number">100</span>;</span><br><span class="line">    cout &lt;&lt; *p.<span class="built_in">get</span>() &lt;&lt; <span class="string">&quot;  &quot;</span> &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">string: test</span></span><br><span class="line"><span class="comment">100  100</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="指定删除器"><a href="#指定删除器" class="headerlink" title="指定删除器"></a>指定删除器</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义删除器函数，释放int型内存</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteIntPtr</span><span class="params">(<span class="type">int</span>* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int 型内存被释放了...&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">250</span>), deleteIntPtr)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除器函数也可以是 lambda 表达式，因此代码也可以写成下面这样：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">250</span>), [](<span class="type">int</span>* p)&#123;<span class="keyword">delete</span> p;cout &lt;&lt; <span class="string">&quot;int 型内存被释放了...&quot;</span> &lt;&lt; endl;&#125;)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 C++11 中使用 shared_ptr <strong>管理动态数组</strong>时，需要指定删除器，因为 std::shared_ptr的<strong>默认删除器不支持数组对象</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], [](<span class="type">int</span>* p) &#123;<span class="keyword">delete</span>[]p; &#125;)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在删除数组内存时，除了自己编写删除器，也可以使用 C++ 提供的 <code>std::default_delete&lt;T&gt;()</code> 函数作为删除器，这个函数内部的删除功能也是通过调用 delete 来实现的，要释放什么类型的内存就将模板类型 T 指定为什么类型即可。具体处理代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], default_delete&lt;<span class="type">int</span>[]&gt;())</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，我们还可以自己封装一个 make_shared_array 方法来让 shared_ptr 支持数组，代码如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">make_share_array</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 返回匿名对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;T&gt;(<span class="keyword">new</span> T[size], <span class="built_in">default_delete</span>&lt;T[]&gt;());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    shared_ptr&lt;<span class="type">int</span>&gt; ptr1 = <span class="built_in">make_share_array</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; ptr1.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    shared_ptr&lt;<span class="type">char</span>&gt; ptr2 = <span class="built_in">make_share_array</span>&lt;<span class="type">char</span>&gt;(<span class="number">128</span>);</span><br><span class="line">    cout &lt;&lt; ptr2.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>using的使用</title>
    <url>/2021/06/09/using%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在 C++ 中 using 用于声明命名空间，使用命名空间也可以防止命名冲突。在程序中声明了命名空间之后，就可以直接使用命名空间中的定义的类了。在 C++11 中赋予了 using 新的功能，让 C++ 变得更年轻，更灵活。</p>
<span id="more"></span>

<h2 id="模板重定义"><a href="#模板重定义" class="headerlink" title="模板重定义"></a>模板重定义</h2><p>大家都知道，在 C++ 中可以通过 typedef 重定义一个类型：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint_t</span>;</span><br></pre></td></tr></table></figure>

<p>使用 typedef 重定义类型是很方便的，但它也有一些限制，比如，<strong>无法重定义一个模板</strong>。</p>
<p>想象下面这个场景：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> std::map&lt;std::string, <span class="type">int</span>&gt; <span class="type">map_int_t</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">typedef</span> std::map&lt;std::string, std::string&gt; <span class="type">map_str_t</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>我们需要的其实是一个固定以 std::string 为 key 的 map，它可以映射到 int 或另一个 std::string。然而这个简单的需求仅通过 typedef 却很难办到。</p>
<p>因此，在 C++98/03 中往往不得不这样写：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Val&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str_map</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> std::map&lt;std::string, Val&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">str_map&lt;<span class="type">int</span>&gt;::type map1;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>一个虽然简单但却略显烦琐的 str_map 外敷类是必要的。这明显让我们在复用某些泛型代码时非常难受。</p>
<p>现在，在 C++11 中终于出现了可以重定义一个模板的语法。请看下面的示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Val&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">str_map_t</span> = std::map&lt;std::string, Val&gt;;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">str_map_t</span>&lt;<span class="type">int</span>&gt; map1;</span><br></pre></td></tr></table></figure>
<p>这里使用新的 using 别名语法定义了 std::map 的模板别名 str_map_t。比起前面使用外敷模板加 typedef 构建的 str_map，它完全就像是一个新的 map 类模板，因此，简洁了很多。</p>
<p>实际上，using 的别名语法覆盖了 typedef 的全部功能。先来看看对普通类型的重定义示例，将这两种语法对比一下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重定义unsigned int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint_t</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="type">uint_t</span> = <span class="type">unsigned</span> <span class="type">int</span>;</span><br><span class="line"><span class="comment">// 重定义std::map</span></span><br><span class="line"><span class="keyword">typedef</span> std::map&lt;std::string, <span class="type">int</span>&gt; <span class="type">map_int_t</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="type">map_int_t</span> = std::map&lt;std::string, <span class="type">int</span>&gt;;</span><br></pre></td></tr></table></figure>
<p>可以看到，在重定义普通类型上，两种使用方法的效果是等价的，唯一不同的是定义语法。</p>
<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p><strong>typedef</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="type">func_t</span>)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>using</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="type">func_t</span> = <span class="built_in">void</span> (*)(<span class="type">int</span>, <span class="type">int</span>);</span><br></pre></td></tr></table></figure>
<p>从上面的对比中可以发现，C++11 的 using 别名语法比 typedef 更加清晰。因为 typedef 的别名语法本质上类似一种解方程的思路。而 using 语法通过赋值来定义别名，和我们平时的思考方式一致。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>lambda表达式</title>
    <url>/2021/06/08/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>lambda 表达式是 C++11 最重要也是最常用的特性之一，这是现代编程语言的一个特点，可以方便的定义和创建匿名函数</p>
<span id="more"></span>

<h2 id="声明Lambda表达式"><a href="#声明Lambda表达式" class="headerlink" title="声明Lambda表达式"></a>声明Lambda表达式</h2><p>Lambda表达式完整的声明格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[capture list] (params list) <span class="keyword">mutable</span> exception-&gt; <span class="keyword">return</span> type &#123; function body &#125;</span><br></pre></td></tr></table></figure>
<p>各项具体含义如下<br><code>capture list</code>：捕获外部变量列表<br><code>params list</code>：形参列表<br><code>mutable</code>：用来说用是否可以修改捕获的变量<br><code>exception</code>：异常设定，如抛出整数类型的异常，可以使用 throw ();<br><code>return type</code>：返回类型<br><code>function body</code>：函数体<br>此外，我们还可以省略其中的某些成分来声明“不完整”的Lambda表达式，常见的有以下几种：</p>
<table>
    <tr>
        <th>说明</th><th>格式</th>
    </tr>
    <tr>
        <td>捕获，参数，返回值类型</td><td>[capture list] (params list) -> return type {function body}</td>
    </tr>
    <tr>
        <td>返回值类型自动类型推导</td><td>[capture list] (params list) {function body}</td>
    </tr>
    <tr>
        <td>不带参数</td><td>[capture list] {function body}</td>
    </tr>
</table>


<h2 id="捕获列表"><a href="#捕获列表" class="headerlink" title="捕获列表"></a>捕获列表</h2><table>
    <tr>
        <th>捕获形式</th><th>说明</th>
    </tr>
    <tr>
        <td>[]</td><td>不捕获任何外部变量</td>
    </tr>
    <tr>
        <td>[变量名, …]</td><td>默认以值得形式捕获指定的多个外部变量（用逗号分隔），如果引用捕获，需要显示声明（使用&说明符）</td>
    </tr>
    <tr>
        <td>[this]</td><td>以值的形式捕获this指针</td>
    </tr>
    <tr>
        <td>[=]</td><td>以值的形式捕获所有外部变量</td>
    </tr>
    <tr>
        <td>[&]</td><td>以引用形式捕获所有外部变量</td>
    </tr>
    <tr>
        <td>[=, &x]</td><td>变量x以引用形式捕获，其余变量以传值形式捕获</td>
    </tr>
    <tr>
        <td>[&, x]</td><td>变量x以值的形式捕获，其余变量以引用形式捕获</td>
    </tr>
</table>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> x1 = [] &#123;<span class="keyword">return</span> m_number; &#125;;                      <span class="comment">// error</span></span><br><span class="line">        <span class="keyword">auto</span> x2 = [=] &#123;<span class="keyword">return</span> m_number + x + y; &#125;;             <span class="comment">// ok</span></span><br><span class="line">        <span class="keyword">auto</span> x3 = [&amp;] &#123;<span class="keyword">return</span> m_number + x + y; &#125;;             <span class="comment">// ok</span></span><br><span class="line">        <span class="keyword">auto</span> x4 = [<span class="keyword">this</span>] &#123;<span class="keyword">return</span> m_number; &#125;;                  <span class="comment">// ok</span></span><br><span class="line">        <span class="keyword">auto</span> x5 = [<span class="keyword">this</span>] &#123;<span class="keyword">return</span> m_number + x + y; &#125;;          <span class="comment">// error</span></span><br><span class="line">        <span class="keyword">auto</span> x6 = [<span class="keyword">this</span>, x, y] &#123;<span class="keyword">return</span> m_number + x + y; &#125;;    <span class="comment">// ok</span></span><br><span class="line">        <span class="keyword">auto</span> x7 = [<span class="keyword">this</span>] &#123;<span class="keyword">return</span> m_number++; &#125;;                <span class="comment">// ok</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_number = <span class="number">100</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// x1：错误，没有捕获外部变量，不能使用类成员 m_number</span></span><br><span class="line"><span class="comment">// x2：正确，以值拷贝的方式捕获所有外部变量</span></span><br><span class="line"><span class="comment">// x3：正确，以引用的方式捕获所有外部变量</span></span><br><span class="line"><span class="comment">// x4：正确，捕获 this 指针，可访问对象内部成员</span></span><br><span class="line"><span class="comment">// x5：错误，捕获 this 指针，可访问类内部成员，没有捕获到变量 x，y，因此不能访问。</span></span><br><span class="line"><span class="comment">// x6：正确，捕获 this 指针，x，y</span></span><br><span class="line"><span class="comment">// x7：正确，捕获 this 指针，并且可以修改对象内部变量的值</span></span><br></pre></td></tr></table></figure>

<p>如果希望修改这些外部变量，需要通过引用的方式进行捕获。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">auto</span> f1 = [] &#123;<span class="keyword">return</span> a; &#125;;                        <span class="comment">// error</span></span><br><span class="line">    <span class="keyword">auto</span> f2 = [&amp;] &#123;<span class="keyword">return</span> a++; &#125;;                     <span class="comment">// ok</span></span><br><span class="line">    <span class="keyword">auto</span> f3 = [=] &#123;<span class="keyword">return</span> a; &#125;;                       <span class="comment">// ok</span></span><br><span class="line">    <span class="keyword">auto</span> f4 = [=] &#123;<span class="keyword">return</span> a++; &#125;;                     <span class="comment">// error</span></span><br><span class="line">    <span class="keyword">auto</span> f5 = [a] &#123;<span class="keyword">return</span> a + b; &#125;;                   <span class="comment">// error</span></span><br><span class="line">    <span class="keyword">auto</span> f6 = [a, &amp;b] &#123;<span class="keyword">return</span> a + (b++); &#125;;           <span class="comment">// ok</span></span><br><span class="line">    <span class="keyword">auto</span> f7 = [=, &amp;b] &#123;<span class="keyword">return</span> a + (b++); &#125;;           <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// f1：错误，没有捕获外部变量，因此无法访问变量 a</span></span><br><span class="line"><span class="comment">// f2：正确，使用引用的方式捕获外部变量，可读写</span></span><br><span class="line"><span class="comment">// f3：正确，使用值拷贝的方式捕获外部变量，可读</span></span><br><span class="line"><span class="comment">// f4：错误，使用值拷贝的方式捕获外部变量，可读不能写</span></span><br><span class="line"><span class="comment">// f5：错误，使用拷贝的方式捕获了外部变量 a，没有捕获外部变量 b，因此无法访问变量 b</span></span><br><span class="line"><span class="comment">// f6：正确，使用拷贝的方式捕获了外部变量 a，只读，使用引用的方式捕获外部变量 b，可读写</span></span><br><span class="line"><span class="comment">// f7：正确，使用值拷贝的方式捕获所有外部变量以及 b 的引用，b 可读写，其他只读</span></span><br></pre></td></tr></table></figure>

<h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>很多时候，lambda 表达式的返回值是非常明显的，因此在 C++11 中允许省略 lambda 表达式的返回值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 完整的lambda表达式定义</span></span><br><span class="line"><span class="keyword">auto</span> f = [](<span class="type">int</span> a) -&gt; <span class="type">int</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a+<span class="number">10</span>;  </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 忽略返回值的lambda表达式定义</span></span><br><span class="line"><span class="keyword">auto</span> f = [](<span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a+<span class="number">10</span>;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>labmda表达式不能通过<strong>列表初始化</strong>自动推导出返回值类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ok，可以自动推导出返回值类型</span></span><br><span class="line"><span class="keyword">auto</span> f = [](<span class="type">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// error，不能推导出返回值类型</span></span><br><span class="line"><span class="keyword">auto</span> f1 = []()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;	<span class="comment">// 基于列表初始化推导返回值，错误</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ok</span></span><br><span class="line"><span class="keyword">auto</span> f1 = []() -&gt; initializer_list&lt;<span class="type">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="函数本质"><a href="#函数本质" class="headerlink" title="函数本质"></a>函数本质</h2><p>使用 lambda 表达式捕获列表捕获外部变量，如果希望去修改按值捕获的外部变量，那么应该如何处理呢？这就需要使用 mutable 选项，被mutable修改是lambda表达式就算没有参数也要写明参数列表，并且可以去掉按值捕获的外部变量的只读（const）属性。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f1 = [=] &#123;<span class="keyword">return</span> a++; &#125;;              <span class="comment">// error, 按值捕获外部变量, a是只读的</span></span><br><span class="line"><span class="keyword">auto</span> f2 = [=]()<span class="keyword">mutable</span> &#123;<span class="keyword">return</span> a++; &#125;;     <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
<p>最后再剖析一下为什么通过值拷贝的方式捕获的外部变量是只读的:</p>
<p>lambda表达式的类型在C++11中会被看做是一个带operator()的类，即仿函数。<br>按照C++标准，lambda表达式的operator()默认是const的，一个const成员函数是无法修改成员变量值的。<br>mutable 选项的作用就在于取消 operator () 的 const 属性。</p>
<p>因为 lambda 表达式在 C++ 中会被看做是一个仿函数，因此可以使用std::function和std::bind来存储和操作lambda表达式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 包装可调用函数</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; f1 = [](<span class="type">int</span> a) &#123;<span class="keyword">return</span> a; &#125;;</span><br><span class="line">    <span class="comment">// 绑定可调用函数</span></span><br><span class="line">    std::function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; f2 = <span class="built_in">bind</span>([](<span class="type">int</span> a) &#123;<span class="keyword">return</span> a; &#125;, placeholders::_1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数调用</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">f1</span>(<span class="number">100</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">f2</span>(<span class="number">200</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于没有捕获任何变量的 lambda 表达式，还可以转换成一个普通的函数指针：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> func_ptr = <span class="built_in">int</span>(*)(<span class="type">int</span>);</span><br><span class="line"><span class="comment">// 没有捕获任何外部变量的匿名函数</span></span><br><span class="line">func_ptr f = [](<span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 函数调用</span></span><br><span class="line"><span class="built_in">f</span>(<span class="number">1314</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>基于范围的for循环</title>
    <url>/2021/06/07/%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84for%E5%BE%AA%E7%8E%AF/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在 C++98/03 中，不同的容器和数组遍历的方式不尽相同，写法不统一，也不够简洁，而 C++11 基于范围的 for 循环可以以简洁、统一的方式来遍历容器和数组，用起来也更方便了。</p>
<span id="more"></span>

<h2 id="for-循环新语法"><a href="#for-循环新语法" class="headerlink" title="for 循环新语法"></a>for 循环新语法</h2><p>在介绍新语法之前，先来看一个使用迭代器遍历容器的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; t&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = t.<span class="built_in">begin</span>(); it != t.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在遍历的过程中需要给出容器的两端：开头（begin）和结尾（end），因为这种遍历方式不是基于范围来设计的。在基于范围的for循环中，不需要再传递容器的两端，循环会自动以容器为范围展开，并且循环中也屏蔽掉了迭代器的遍历细节，直接抽取容器中的元素进行运算，使用这种方式进行循环遍历会让编码和维护变得更加简便。</p>
<p>C++98/03 中普通的 for 循环，语法格式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式 <span class="number">1</span>; 表达式 <span class="number">2</span>; 表达式 <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++11 基于范围的 for 循环，语法格式：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (declaration : expression)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的语法格式中 declaration 表示遍历声明，在遍历过程中，当前被遍历到的元素会被存储到声明的变量中。expression 是要遍历的对象，它可以是表达式、容器、数组、初始化列表等。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; t&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> value : t)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>写操作需要使用引用</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; t&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;遍历修改之前的容器: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;value : t)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; value++ &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; <span class="string">&quot;遍历修改之后的容器: &quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;value : t)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码输出的结果：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">遍历修改之前的容器: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br><span class="line">遍历修改之后的容器: <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>对容器的遍历过程中，如果只是读数据，不允许修改元素的值，可以使用 const 定义保存元素数据的变量，在定义的时候建议使用 const auto &amp;，这样相对于 const auto 效率要更高一些。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; t&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; value : t)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; value &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用细节"><a href="#使用细节" class="headerlink" title="使用细节"></a>使用细节</h2><h3 id="关系型容器"><a href="#关系型容器" class="headerlink" title="关系型容器"></a>关系型容器</h3><p>使用基于范围的 for 循环有一些需要注意的细节，先来看一下对关系型容器 map 的遍历：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt; m&#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="string">&quot;lucy&quot;</span>&#125;,&#123;<span class="number">2</span>, <span class="string">&quot;lily&quot;</span>&#125;,&#123;<span class="number">3</span>, <span class="string">&quot;tom&quot;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于范围的for循环方式</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; it : m)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;id: &quot;</span> &lt;&lt; it.first &lt;&lt; <span class="string">&quot;, name: &quot;</span> &lt;&lt; it.second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通的for循环方式</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = m.<span class="built_in">begin</span>(); it != m.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;id: &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot;, name: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中使用两种方式对 map 进行了遍历，通过对比有两点需要注意的事项：</p>
<p>使用普通的 for 循环方式（基于迭代器）遍历关联性容器， auto 自动推导出的是一个迭代器类型，需要使用迭代器的方式取出元素中的键值对（和指针的操作方法相同）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">it-&gt;first</span><br><span class="line">it-&gt;second</span><br></pre></td></tr></table></figure>
<p>使用基于范围的 for 循环遍历关联性容器，auto 自动推导出的类型是容器中的 value_type，相当于一个对组（std::pair）对象，提取键值对的方式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">it.first</span><br><span class="line">it.second</span><br></pre></td></tr></table></figure>
<h3 id="元素只读"><a href="#元素只读" class="headerlink" title="元素只读"></a>元素只读</h3><p>通过对基于范围的 for 循环语法的介绍可以得知，在 for 循环内部声明一个变量的引用就可以修改遍历的表达式中的元素的值，但是这并不适用于所有的情况，对应 set 容器来说，内部元素都是只读的，这是由容器的特性决定的，因此在 for 循环中 auto &amp; 会被视为 const auto &amp; 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; st&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;item : st) </span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; item++ &lt;&lt; endl;		<span class="comment">// error, 不能给常量赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除此之外，在遍历关联型容器时也会出现同样的问题，基于范围的for循环中，虽然可以得到一个std::pair引用，但是我们是不能修改里边的first值的，也就是key值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt; m&#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="string">&quot;lucy&quot;</span>&#125;,&#123;<span class="number">2</span>, <span class="string">&quot;lily&quot;</span>&#125;,&#123;<span class="number">3</span>, <span class="string">&quot;tom&quot;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; item : m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// item.first 是一个常量</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;id: &quot;</span> &lt;&lt; item.first++ &lt;&lt; <span class="string">&quot;, name: &quot;</span> &lt;&lt; item.second &lt;&lt; endl;  <span class="comment">// error</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="访问次数"><a href="#访问次数" class="headerlink" title="访问次数"></a>访问次数</h3><p>基于范围的 for 循环遍历的对象可以是一个表达式或者容器 / 数组等。假设我们对一个容器进行遍历，在遍历过程中 for 循环对这个容器的访问频率是一次还是多次呢？我们通过下面的例子验证一下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt;&amp; <span class="title">getRange</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;get vector range...&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> val : <span class="built_in">getRange</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出的结果如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">get vector range...</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>从上面的结果中可以看到，不论基于范围的 for 循环迭代了多少次，函数 getRange () 只在第一次迭代之前被调用，得到这个容器对象之后就不会再去重新获取这个对象了。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11列表初始化</title>
    <url>/2021/06/06/C-11%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>关于 C++ 中的变量，数组，对象等都有不同的初始化方法，在这些繁琐的初始化方法中没有任何一种方式适用于所有的情况。为了统一初始化方式，并且让初始化行为具有确定的效果，在 C++11 中提出了列表初始化的概念。</p>
<span id="more"></span>

<p>我们知道，在 C++98/03 中的对象初始化方法有很多种，请看下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化列表</span></span><br><span class="line"><span class="type">int</span> i_arr[<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;  <span class="comment">//普通数组</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">    &#125; b;</span><br><span class="line">&#125; a = &#123; <span class="number">1</span>, &#123; <span class="number">2</span>, <span class="number">3</span> &#125; &#125;;  <span class="comment">//POD类型</span></span><br><span class="line"><span class="comment">//拷贝初始化（copy-initialization）</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span>) &#123;&#125;</span><br><span class="line">&#125; foo = <span class="number">123</span>;  <span class="comment">//需要拷贝构造函数</span></span><br><span class="line"><span class="comment">//直接初始化（direct-initialization）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">j</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">Foo <span class="title">bar</span><span class="params">(<span class="number">123</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这些不同的初始化方法，都有各自的适用范围和作用。最关键的是，这些种类繁多的初始化方法，没有一种可以通用所有情况。</p>
<p><strong>为了统一初始化方式</strong>，并且让初始化行为具有确定的效果，C++11 中提出了列表初始化（<code>List-initialization</code>）的概念。<br>POD 类型即 plain old data 类型，简单来说，是可以直接使用 memcpy 复制的对象。</p>
<h2 id="统一的初始化"><a href="#统一的初始化" class="headerlink" title="统一的初始化"></a>统一的初始化</h2><p>在上面我们已经看到了，对于普通数组和 POD 类型，C++98/03 可以使用初始化列表（initializer list）进行初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i_arr[<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">long</span> l_arr[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125; a = &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>但是这种初始化方式的适用性非常狭窄，只有上面提到的这两种数据类型可以使用初始化列表。</p>
<p>在 C++11 中，初始化列表的适用性被大大增加了。它现在可以用于任何类型对象的初始化，请看下面的代码。</p>
<p>【实例】通过初始化列表初始化对象。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> Foo &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Foo <span class="title">a1</span><span class="params">(<span class="number">123</span>)</span></span>;</span><br><span class="line">    Foo a2 = <span class="number">123</span>;  <span class="comment">//error: &#x27;Foo::Foo(const Foo &amp;)&#x27; is private</span></span><br><span class="line">    Foo a3 = &#123; <span class="number">123</span> &#125;;</span><br><span class="line">    Foo a4 &#123; <span class="number">123</span> &#125;;</span><br><span class="line">    <span class="type">int</span> a5 = &#123; <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="type">int</span> a6 &#123; <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上例中，a3、a4 使用了新的初始化方式来初始化对象，效果如同 a1 的直接初始化。</p>
<p>a5、a6 则是基本数据类型的列表初始化方式。可以看到，它们的形式都是统一的。</p>
<p>这里需要注意的是，a3 虽然使用了等于号，但它仍然是列表初始化，因此，私有的拷贝构造并不会影响到它。</p>
<p>a4 和 a6 的写法，是 C++98/03 所不具备的。在 C++11 中，可以直接在变量名后面跟上初始化列表，来进行对象的初始化。</p>
<p>这种变量名后面跟上初始化列表方法同样适用于普通数组和 POD 类型的初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i_arr[<span class="number">3</span>] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;  <span class="comment">//普通数组</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">    &#125; b;</span><br><span class="line">&#125; a &#123; <span class="number">1</span>, &#123; <span class="number">2</span>, <span class="number">3</span> &#125; &#125;;  <span class="comment">//POD类型</span></span><br></pre></td></tr></table></figure>
<p>在初始化时，{}前面的等于号是否书写对初始化行为没有影响。</p>
<p>new 操作符等可以用圆括号进行初始化的地方，也可以使用初始化列表：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* a = <span class="keyword">new</span> <span class="type">int</span> &#123; <span class="number">123</span> &#125;;</span><br><span class="line"><span class="type">double</span> b = <span class="type">double</span> &#123; <span class="number">12.12</span> &#125;;</span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>指针 a 指向了一个 new 操作符返回的内存，通过初始化列表方式在内存初始化时指定了值为 123。</p>
<p>b 则是对匿名对象使用列表初始化后，再进行拷贝初始化。</p>
<p>这里让人眼前一亮的是 arr 的初始化方式。堆上动态分配的数组终于也可以使用初始化列表进行初始化了。</p>
<p>除了上面所述的内容之外，列表初始化还可以直接使用在函数的返回值上：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span>, <span class="type">double</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Foo <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="number">123</span>, <span class="number">321.0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 return 语句就如同返回了一个 Foo(123, 321.0)。</p>
<p>由上面的这些例子可以看到，在 C++11 中使用初始化列表是非常便利的。它不仅统一了各种对象的初始化方式，而且还使代码的书写更加简单清晰。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>自动类型推导</title>
    <url>/2021/06/05/%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC/</url>
    <content><![CDATA[<h2 id="auto"><a href="#auto" class="headerlink" title="auto"></a>auto</h2><p>在 C++11 之前 auto 和 static 是对应的，表示变量是自动存储的，但是非 static 的局部变量默认都是自动存储的，因此这个关键字变得非常鸡肋，在 C++11 中他们赋予了新的含义，使用这个关键字能够像别的语言一样自动推导出变量的实际类型。</p>
<span id="more"></span>

<h3 id="推导规则"><a href="#推导规则" class="headerlink" title="推导规则"></a>推导规则</h3><p>C++11 中 auto 并不代表一种实际的数据类型，只是一个类型声明的 “占位符”，使用auto声明的变量<strong>必须要进行初始化</strong>，以让编译器推导出它的实际类型，在编译时将auto占位符替换为真正的类型。使用语法如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> 变量名 = 变量值;</span><br></pre></td></tr></table></figure>
<p>根据上述语法，来列举一些简单的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">3.14</span>;      <span class="comment">// x 是浮点型 double</span></span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">520</span>;       <span class="comment">// y 是整形 int</span></span><br><span class="line"><span class="keyword">auto</span> z = <span class="string">&#x27;a&#x27;</span>;       <span class="comment">// z 是字符型 char</span></span><br><span class="line"><span class="keyword">auto</span> nb;            <span class="comment">// error，变量必须要初始化</span></span><br><span class="line"><span class="keyword">auto</span> <span class="type">double</span> nbl;    <span class="comment">// 语法错误, 不能修改数据类型   </span></span><br></pre></td></tr></table></figure>
<p>不仅如此，auto 还可以和指针、引用结合起来使用也可以带上 <code>const</code>、<code>volatile</code> 限定符，在不同的场景下有对应的推导规则，规则内容如下：</p>
<ul>
<li>当变量不是指针或者引用类型时，推导的结果中不会保留 <code>const</code>、<code>volatile</code> 关键字</li>
<li>当变量是指针或者引用类型时，推导的结果中会保留 <code>const</code>、<code>volatile</code> 关键字</li>
</ul>
<p>先来看一组变量带指针和引用并使用 auto 进行类型推导的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> temp = <span class="number">110</span>; </span><br><span class="line"><span class="keyword">auto</span> *a = &amp;temp;	<span class="comment">//变量 a 的数据类型为 int*，因此 auto 关键字被推导为 int类型</span></span><br><span class="line"><span class="keyword">auto</span> b = &amp;temp;		<span class="comment">//变量 b 的数据类型为 int*，因此 auto 关键字被推导为 int* 类型</span></span><br><span class="line"><span class="keyword">auto</span> &amp;c = temp;		<span class="comment">//变量 c 的数据类型为 int&amp;，因此 auto 关键字被推导为 int类型</span></span><br><span class="line"><span class="keyword">auto</span> d = temp;		<span class="comment">//变量 d 的数据类型为 int，因此 auto 关键字被推导为 int 类型</span></span><br></pre></td></tr></table></figure>

<p>在来看一组带 const 限定的变量，使用 auto 进行类型推导的例子:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> tmp = <span class="number">250</span>;</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> a1 = tmp;</span><br><span class="line"><span class="keyword">auto</span> a2 = a1;</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> &amp;a3 = tmp;</span><br><span class="line"><span class="keyword">auto</span> &amp;a4 = a3;</span><br><span class="line"><span class="comment">//变量 a1 的数据类型为 const int，因此 auto 关键字被推导为 int 类型</span></span><br><span class="line"><span class="comment">//变量 a2 的数据类型为 int，但是 a2 没有声明为指针或引用因此 const 属性被去掉，auto 被推导为 int</span></span><br><span class="line"><span class="comment">//变量 a3 的数据类型为 const int&amp;，a3 被声明为引用因此 const 属性被保留，auto 关键字被推导为 int 类型</span></span><br><span class="line"><span class="comment">//变量 a4 的数据类型为 const int&amp;，a4 被声明为引用因此 const 属性被保留，auto 关键字被推导为 const int 类型</span></span><br></pre></td></tr></table></figure>

<h3 id="auto-的限制"><a href="#auto-的限制" class="headerlink" title="auto 的限制"></a>auto 的限制</h3><p>不能作为函数参数使用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">(<span class="keyword">auto</span> a, <span class="keyword">auto</span> b)</span>	<span class="comment">// error</span></span></span><br><span class="line"><span class="function"></span>&#123;	</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt;<span class="string">&quot;, b: &quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不能用于类的静态非常量成员变量的初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> v1 = <span class="number">0</span>;                    <span class="comment">// error</span></span><br><span class="line">    <span class="type">static</span> <span class="keyword">auto</span> v2 = <span class="number">0</span>;             <span class="comment">// error,类的静态非常量成员不允许在类内部直接初始化</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="keyword">auto</span> v3 = <span class="number">10</span>;      <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不能使用 auto 关键字定义数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> array[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;  <span class="comment">// 定义数组</span></span><br><span class="line">    <span class="keyword">auto</span> t1 = array;            <span class="comment">// ok, t1被推导为 int* 类型</span></span><br><span class="line">    <span class="keyword">auto</span> t2[] = array;          <span class="comment">// error, auto无法定义数组</span></span><br><span class="line">    <span class="keyword">auto</span> t3[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;;   <span class="comment">// error, auto无法定义数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无法使用 auto 推导出模板参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Test</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test&lt;<span class="type">double</span>&gt; t;</span><br><span class="line">    Test&lt;<span class="keyword">auto</span>&gt; t1 = t;           <span class="comment">// error, 无法推导出模板类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="auto-的应用"><a href="#auto-的应用" class="headerlink" title="auto 的应用"></a>auto 的应用</h3><p>用于STL的容器遍历</p>
<p>在 C++11 之前，定义了一个 stl 容器之后，遍历的时候常常会写出这样的代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt; person;</span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt;::iterator it = person.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">for</span> (; it != person.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在定义迭代器变量 it 的时候代码是很长的，写起来就很麻烦，使用了 auto 之后，就变得清爽了不少：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>, string&gt; person;</span><br><span class="line">    <span class="comment">// 代码简化</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = person.<span class="built_in">begin</span>(); it != person.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用于泛型编程</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">T2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> string <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello, world&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">A</span>&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> val = A::<span class="built_in">get</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;val: &quot;</span> &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>&lt;T1&gt;();</span><br><span class="line">    <span class="built_in">func</span>&lt;T2&gt;();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="decltype"><a href="#decltype" class="headerlink" title="decltype"></a>decltype</h2><p>在某些情况下，不需要或者不能定义变量，但是希望得到某种类型，这时候就可以使用 C++11 提供的 decltype 关键字了，它的作用是在编译器编译的时候推导出一个表达式的类型，语法格式如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span> (表达式)</span><br></pre></td></tr></table></figure>

<p>decltype 是 “declare type” 的缩写，意思是 “声明类型”。decltype 的推导是在<strong>编译期</strong>完成的，它只是用于表达式类型的推导，并不会计算表达式的值。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a) b = <span class="number">99</span>;                 <span class="comment">// b -&gt; int</span></span><br><span class="line"><span class="keyword">decltype</span>(a+<span class="number">3.14</span>) c = <span class="number">52.13</span>;         <span class="comment">// c -&gt; double</span></span><br><span class="line"><span class="keyword">decltype</span>(a+b*c) d = <span class="number">520.1314</span>;       <span class="comment">// d -&gt; double</span></span><br></pre></td></tr></table></figure>
<p>可以看到 decltype 推导的表达式可简单可复杂，在这一点上 auto 是做不到的，<strong>auto 只能推导已初始化的变量类型</strong>。</p>
<h3 id="推导规则-1"><a href="#推导规则-1" class="headerlink" title="推导规则"></a>推导规则</h3><p>通过上面的例子我们初步感受了一下 decltype 的用法，但不要认为 decltype 就这么简单，在它简单的背后隐藏着很多的细节，下面分三个场景依次讨论一下：</p>
<p>表达式为普通变量或者普通表达式或者类表达式，在这种情况下，使用 decltype 推导出的类型和表达式的类型是一致的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string text;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">110</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">99</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;y = x;</span><br><span class="line">    <span class="keyword">decltype</span>(x) a = x;</span><br><span class="line">    <span class="keyword">decltype</span>(y) b = x;</span><br><span class="line">    <span class="keyword">decltype</span>(Test::value) c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Test t;</span><br><span class="line">    <span class="keyword">decltype</span>(t.text) d = <span class="string">&quot;hello, world&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//变量 a 被推导为 int 类型</span></span><br><span class="line"><span class="comment">//变量 b 被推导为 const int &amp; 类型</span></span><br><span class="line"><span class="comment">//变量 c 被推导为 const int 类型</span></span><br><span class="line"><span class="comment">//变量 d 被推导为 string 类型</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>表达式是一个左值，或者被括号 ( ) 包围，使用 decltype 推导出的是表达式类型的引用（如果有 const、volatile 限定符不能忽略）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> Test obj;</span><br><span class="line">    <span class="comment">//带有括号的表达式</span></span><br><span class="line">    <span class="keyword">decltype</span>(obj.num) a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">decltype</span>((obj.num)) b = a;</span><br><span class="line">    <span class="comment">//加法表达式</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>, m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(n + m) c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(n = n + m) d = n;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// obj.num 为类的成员访问表达式，因此 a 的类型为 int</span></span><br><span class="line"><span class="comment">// obj.num 带有括号，因此 b 的类型为 const int&amp;。</span></span><br><span class="line"><span class="comment">// n+m 得到一个右值，，因此 c 的类型为 int</span></span><br><span class="line"><span class="comment">// n=n+m 得到一个左值 n，因此 d 的类型为 int&amp;</span></span><br></pre></td></tr></table></figure>
<h3 id="decltype-的应用"><a href="#decltype-的应用" class="headerlink" title="decltype 的应用"></a>decltype 的应用</h3><p>关于 decltype 的应用多出现在泛型编程中。比如我们编写一个类模板，在里边添加遍历容器的函数，操作如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Container</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp; c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (m_it = c.<span class="built_in">begin</span>(); m_it != c.<span class="built_in">end</span>(); ++m_it)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; *m_it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">decltype</span>(<span class="built_in">T</span>().<span class="built_in">begin</span>()) m_it;  <span class="comment">// 这里不能确定迭代器类型</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> list&lt;<span class="type">int</span>&gt; lst&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    Container&lt;<span class="type">const</span> list&lt;<span class="type">int</span>&gt;&gt; obj;</span><br><span class="line">    obj.<span class="built_in">func</span>(lst);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="返回类型后置"><a href="#返回类型后置" class="headerlink" title="返回类型后置"></a>返回类型后置</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 符号 -&gt; 后边跟随的是函数返回值的类型</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(参数<span class="number">1</span>, 参数<span class="number">2</span>, ...)</span> -&gt; <span class="title">decltype</span><span class="params">(参数表达式)</span></span></span><br></pre></td></tr></table></figure>
<p>通过对上述返回类型后置语法代码的分析，得到结论：auto 会追踪 decltype() 推导出的类型，因此上边的 add() 函数可以做如下的修改：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="comment">// 返回类型后置语法</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> -&gt; <span class="title">decltype</span><span class="params">(t+u)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">520</span>;</span><br><span class="line">    <span class="type">double</span> y = <span class="number">13.14</span>;</span><br><span class="line">    <span class="comment">// auto z = add&lt;int, double&gt;(x, y);</span></span><br><span class="line">    <span class="keyword">auto</span> z = <span class="built_in">add</span>(x, y);		<span class="comment">// 简化之后的写法</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;z: &quot;</span> &lt;&lt; z &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了进一步说明这个语法，我们再看一个例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">test</span><span class="params">(<span class="type">int</span> &amp;i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">test</span><span class="params">(<span class="type">double</span> &amp;d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    d = d + <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="comment">// 返回类型后置语法</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">myFunc</span><span class="params">(T&amp; t)</span> -&gt; <span class="title">decltype</span><span class="params">(test(t))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">test</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">520</span>;</span><br><span class="line">    <span class="type">double</span> y = <span class="number">13.14</span>;</span><br><span class="line">    <span class="comment">// auto z = myFunc&lt;int&gt;(x);</span></span><br><span class="line">    <span class="keyword">auto</span> z = <span class="built_in">myFunc</span>(x);             <span class="comment">// 简化之后的写法</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;z: &quot;</span> &lt;&lt; z &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// auto z = myFunc&lt;double&gt;(y);</span></span><br><span class="line">    <span class="keyword">auto</span> z1 = <span class="built_in">myFunc</span>(y);            <span class="comment">// 简化之后的写法</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;z1: &quot;</span> &lt;&lt; z1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，通过 decltype 结合返回值后置语法很容易推导出来 test(t) 函数可能出现的返回值类型，并将其作用到了函数 myFunc() 上。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11模板优化</title>
    <url>/2021/06/04/C-11%E6%A8%A1%E6%9D%BF%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="模板的右尖括号"><a href="#模板的右尖括号" class="headerlink" title="模板的右尖括号"></a>模板的右尖括号</h2><p>在泛型编程中，模板实例化有一个非常繁琐的地方，那就是连续的两个右尖括号（&gt;&gt;）会被编译器解析成右移操作符，而不是模板参数表的结束。</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(T&amp; t)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = t.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">for</span> (; it != t.<span class="built_in">end</span>(); ++it)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line">    Base&lt;vector&lt;<span class="type">int</span>&gt;&gt; b;</span><br><span class="line">    b.<span class="built_in">traversal</span>(v);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用 C++98/03 标准来编译上边的这段代码，就会得到如下的错误提示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">test.cpp:25:20: error: <span class="string">&#x27;&gt;&gt;&#x27;</span> should be <span class="string">&#x27;&gt; &gt;&#x27;</span> within a nested template argument list</span><br><span class="line">     Base&lt;vector&lt;int&gt;&gt; b;</span><br></pre></td></tr></table></figure>
<p>根据错误提示中描述模板的两个右尖括之间需要添加空格，这样写起来就非常的麻烦，C++11改进了编译器的解析规则，尽可能地将多个右尖括号（&gt;）解析成模板参数结束符，方便我们编写模板相关的代码。</p>
<p>上面的这段代码，在支持 C++11 的编译器中编译是没有任何问题的，如果使用 g++ 直接编译需要加参数 -std=c++11：</p>
<h2 id="默认模板参数"><a href="#默认模板参数" class="headerlink" title="默认模板参数"></a>默认模板参数</h2><p>在 C++98/03 标准中，类模板可以有默认的模板参数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T=<span class="type">int</span>, T t=<span class="number">520</span>&gt;</span><br><span class="line"><span class="keyword">class</span> Test</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> <span class="built_in">print</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;current value: &quot;</span> &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Test&lt;&gt; t;</span><br><span class="line">    t.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    Test&lt;<span class="type">int</span>, <span class="number">1024</span>&gt; t1;</span><br><span class="line">    t1.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是不支持函数的默认模板参数，在C++11中添加了对函数模板默认参数的支持:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T=<span class="type">int</span>&gt;	<span class="comment">// C++98/03不支持这种写法, C++11中支持这种写法</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">func</span>(T t)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;current value: &quot;</span> &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用 C++98/03 标准来编译上边的这段代码，就会得到如下的错误提示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">test.cpp:5:14: error: default template arguments may not be used <span class="keyword">in</span> <span class="keyword">function</span> templates without -std=c++11 or -std=gnu++11</span><br><span class="line"> void func(T t)</span><br></pre></td></tr></table></figure>

<p>我们可以指定函数模板中的一部分模板参数使用默认参数，另一部分使用自动推导，比如下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R = <span class="type">int</span>, <span class="keyword">typename</span> N&gt;</span><br><span class="line">R <span class="built_in">func</span>(N arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ret1 = <span class="built_in">func</span>(<span class="number">520</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;return value-1: &quot;</span> &lt;&lt; ret1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ret2 = <span class="built_in">func</span>&lt;<span class="type">double</span>&gt;(<span class="number">52.134</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;return value-2: &quot;</span> &lt;&lt; ret2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ret3 = <span class="built_in">func</span>&lt;<span class="type">int</span>&gt;(<span class="number">52.134</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;return value-3: &quot;</span> &lt;&lt; ret3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> ret4 = <span class="built_in">func</span>&lt;<span class="type">char</span>, <span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;return value-4: &quot;</span> &lt;&lt; ret4 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试代码输出的结果为:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> value<span class="number">-1</span>: <span class="number">520</span></span><br><span class="line"><span class="keyword">return</span> value<span class="number">-2</span>: <span class="number">52.134</span></span><br><span class="line"><span class="keyword">return</span> value<span class="number">-3</span>: <span class="number">52</span></span><br><span class="line"><span class="keyword">return</span> value<span class="number">-4</span>: d</span><br></pre></td></tr></table></figure>
<p>根据得到的日志输出，分析一下示例代码中调用的模板函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> ret = <span class="built_in">func</span>(<span class="number">520</span>);</span><br><span class="line"><span class="comment">//函数返回值类型使用了默认的模板参数，函数的参数类型是自动推导出来的为 int 类型。</span></span><br><span class="line"><span class="keyword">auto</span> ret1 = <span class="built_in">func</span>&lt;<span class="type">double</span>&gt;(<span class="number">52.134</span>);</span><br><span class="line"><span class="comment">//函数的返回值指定为 double 类型，函数参数是通过实参推导出来的，为 double 类型</span></span><br><span class="line"><span class="keyword">auto</span> ret3 = <span class="built_in">func</span>&lt;<span class="type">int</span>&gt;(<span class="number">52.134</span>);</span><br><span class="line"><span class="comment">//函数的返回值指定为 int 类型，函数参数是通过实参推导出来的，为 double 类型</span></span><br><span class="line"><span class="keyword">auto</span> ret4 = <span class="built_in">func</span>&lt;<span class="type">char</span>, <span class="type">int</span>&gt;(<span class="number">100</span>);</span><br><span class="line"><span class="comment">//函数的参数为指定为 int 类型，函数返回值指定为 char 类型，不需要推导</span></span><br></pre></td></tr></table></figure>
<p>当默认模板参数和模板参数自动推导同时使用时（优先级从高到低）：</p>
<ul>
<li>如果可以推导出参数类型则使用推导出的类型</li>
<li>如果函数模板无法推导出参数类型，那么编译器会使用默认模板参数</li>
<li>如果无法推导出模板参数类型并且没有设置默认模板参数，编译器就会报错。</li>
</ul>
<p>看一下下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U = <span class="type">char</span>&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">func</span>(T arg1 = <span class="number">100</span>, U arg2 = <span class="number">100</span>)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;arg1: &quot;</span> &lt;&lt; arg1 &lt;&lt; <span class="string">&quot;, arg2: &quot;</span> &lt;&lt; arg2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 模板函数调用</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">97</span>, <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    <span class="comment">// func();    //编译报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出的结果为:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">arg1: a, arg2: d</span><br><span class="line">arg1: <span class="number">97</span>, arg2: a</span><br></pre></td></tr></table></figure>
<p>分析一下调用的模板函数 func()：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">func</span>(<span class="string">&#x27;a&#x27;</span>)：参数 T 被自动推导为 <span class="type">char</span> 类型，U 使用的默认模板参数为 <span class="type">char</span> 类型</span><br><span class="line"><span class="built_in">func</span>(<span class="number">97</span>, <span class="string">&#x27;a&#x27;</span>);：参数 T 被自动推导为 <span class="type">int</span> 类型，U 使用推导出的类型为 <span class="function"><span class="type">char</span></span></span><br><span class="line"><span class="function"><span class="title">func</span><span class="params">()</span></span>;：参数 T 没有指定默认模板类型，并且无法自动推导，编译器会直接报错</span><br></pre></td></tr></table></figure>
<p>模板参数类型的自动推导是根据模板函数调用时指定的实参进行推断的，没有实参则无法推导<br>模板参数类型的自动推导不会参考函数模板中指定的默认参数。</p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++中public、protected、private的区别</title>
    <url>/2021/06/03/C-%E4%B8%ADpublic%E3%80%81protected%E3%80%81private%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="private-public-protected的访问范围"><a href="#private-public-protected的访问范围" class="headerlink" title="private,public,protected的访问范围"></a>private,public,protected的访问范围</h2><p><code>private</code>: 只能由该类中的函数、其友元函数访问,不能被任何其他访问，该类的对象也不能访问.<br><code>protected</code>: 可以被该类中的函数、子类的函数、以及其友元函数访问,但不能被该类的对象访问<br><code>public</code>: 可以被该类中的函数、子类的函数、其友元函数访问,也可以由该类的对象访问<br>注：友元函数包括两种：设为友元的全局函数，设为友元类中的成员函数</p>
<span id="more"></span>


<h2 id="类的继承后方法属性变化"><a href="#类的继承后方法属性变化" class="headerlink" title="类的继承后方法属性变化"></a>类的继承后方法属性变化</h2><p>使用<code>private</code>继承,父类的所有方法在子类中变为private;<br>使用<code>protected</code>继承,父类的protected和public方法在子类中变为protected,private方法不变;<br>使用<code>public</code>继承,父类中的方法属性不发生改变;<br>class继承默认是private继承，而struct继承默认是public继承</p>
<table>
    <tr>
        <th>继承方式</th><th>public</th><th>protected</th><th>private</th>
    </tr>
    <tr>
        <td>共有继承</td><td>public</td><td>protected</td><td>不可见</td>
    </tr>
    <tr>
        <td>私有继承</td><td>private</td><td>private</td><td>不可见</td>
    </tr>
    <tr>
        <td>保护继承</td><td>protected</td><td>protected</td><td>不可见</td>
    </tr>
</table>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11 friend</title>
    <url>/2021/06/02/friend/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>私有成员只能在类的成员函数内部访问，如果想在别处访问对象的私有成员，只能通过类提供的接口（成员函数）间接地进行。这固然能够带来数据隐藏的好处，利于将来程序的扩充，但也会增加程序书写的麻烦。<br>因此，<code>C++</code> 就有了友元（<code>friend</code>）的概念。</p>
<p>友元分为两种：友元函数和友元类。</p>
<span id="more"></span>

<h2 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h2><p>在定义一个类的时候，可以把一些函数（包括<code>全局函数</code>和<code>其他类的成员函数</code>）声明为“友元”，这样那些函数就成为该类的友元函数，在友元函数内部就可以访问该类对象的私有成员了。</p>
<p>将全局函数声明为友元的写法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">friend  返回值类型  函数名(参数表);</span><br></pre></td></tr></table></figure>

<p>将其他类的成员函数声明为友元的写法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">friend  返回值类型  其他类的类名::成员函数名(参数表);</span><br></pre></td></tr></table></figure>

<p>但是，<strong>不能把其他类的私有成员函数声明为友元</strong>。</p>
<p>关于友元，看下面的程序示例。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span>;</span>  <span class="comment">//提前声明CCar类，以便后面的CDriver类使用</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDriver</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">ModifyCar</span><span class="params">(CCar* pCar)</span>;  <span class="comment">//改装汽车</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> price;</span><br><span class="line">    friend <span class="type">int</span> <span class="title function_">MostExpensiveCar</span><span class="params">(CCar cars[], <span class="type">int</span> total)</span>;  <span class="comment">//声明友元</span></span><br><span class="line">    friend <span class="type">void</span> <span class="title function_">CDriver::ModifyCar</span><span class="params">(CCar* pCar)</span>;  <span class="comment">//声明友元</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">CDriver::ModifyCar</span><span class="params">(CCar* pCar)</span></span><br><span class="line">&#123;</span><br><span class="line">    pCar-&gt;price += <span class="number">1000</span>;  <span class="comment">//汽车改装后价值增加</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">MostExpensiveCar</span><span class="params">(CCar cars[], <span class="type">int</span> total)</span>  <span class="comment">//求最贵气车的价格</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tmpMax = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;total; ++i)</span><br><span class="line">        <span class="keyword">if</span> (cars[i].price &gt; tmpMax)</span><br><span class="line">            tmpMax = cars[i].price;</span><br><span class="line">    <span class="keyword">return</span> tmpMax;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将全局函数 MostExpensiveCar 声明为 CCar 类的友元，因此可以访问 cars[i] 的私有成员 price。<br>将 CDriver 类的 ModifyCar 成员函数声明为友元，可以访问 pCar 指针所指向的对象的私有成员变量 price。</p>
<h2 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h2><p>一个类 A 可以将另一个类 B 声明为自己的友元，类 B 的所有成员函数就都可以访问类 A 对象的私有成员。在类定义中声明友元类的写法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">friend  <span class="class"><span class="keyword">class</span>  类名;</span></span><br></pre></td></tr></table></figure>

<p>来看如下例程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CCar</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">private:</span><br><span class="line">    <span class="type">int</span> price;</span><br><span class="line">    friend <span class="class"><span class="keyword">class</span> <span class="title">CDriver</span>;</span>  <span class="comment">//声明 CDriver 为友元类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDriver</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">public:</span><br><span class="line">    CCar myCar;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">ModifyCar</span><span class="params">()</span>  <span class="comment">//改装汽车</span></span><br><span class="line">    &#123;</span><br><span class="line">        myCar.price += <span class="number">1000</span>;  <span class="comment">//因CDriver是CCar的友元类，故此处可以访问其私有成员</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="c-11语法改进"><a href="#c-11语法改进" class="headerlink" title="c++11语法改进"></a>c++11语法改进</h2><p>在 <code>C++11</code> 标准中对 friend 关键字进行了一些改进，以保证其更加好用：</p>
<p>声明一个类为另外一个类的友元时，<strong>不再需要使用 class 关键字</strong>，并且还可以使用类的别名（使用 typedef 或者 using 定义）。<br>我们可以看看下面的例子：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tom</span>;</span><br><span class="line"><span class="comment">// 定义别名</span></span><br><span class="line"><span class="keyword">using</span> Honey = Tom;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义两个测试类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Jack</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 声明友元</span></span><br><span class="line">    <span class="comment">// friend class Tom;    // C++98 标准语法</span></span><br><span class="line">    <span class="keyword">friend</span> Tom;             <span class="comment">// C++11 标准语法 </span></span><br><span class="line">    string name = <span class="string">&quot;jack&quot;</span>;   <span class="comment">// 默认私有</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span>            <span class="comment">// 默认私有</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;my name is &quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Lucy</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 声明友元</span></span><br><span class="line">    <span class="comment">// friend class Tom;    // C++98 标准语法</span></span><br><span class="line">    <span class="keyword">friend</span> Honey;           <span class="comment">// C++11 标准语法 </span></span><br><span class="line">    string name = <span class="string">&quot;lucy&quot;</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;my name is &quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tom</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 通过类成员对象访问其私有成员</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;invoke Jack private member: &quot;</span> &lt;&lt; jObj.name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;invoke Jack private function: &quot;</span> &lt;&lt; endl;</span><br><span class="line">        jObj.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;invoke Lucy private member: &quot;</span> &lt;&lt; lObj.name &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;invoke Lucy private function: &quot;</span> &lt;&lt; endl;</span><br><span class="line">        lObj.<span class="built_in">print</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name = <span class="string">&quot;tom&quot;</span>;</span><br><span class="line">    Jack jObj;</span><br><span class="line">    Lucy lObj;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tom t;</span><br><span class="line">    t.<span class="built_in">print</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中 Tom 类分别作为了 Jack类和 Lucy类的友元类，然后在 Tom类中定义了 Jack类和 Lucy类的对象 jObj 和 lObj，这样我们就可以在 Tom类中通过这两个类对象直接访问它们各自的私有或者受保护的成员变量或者成员函数了。<br><img src="cda65555b1a1622bebcc979abd11f9b38b4495ed4022d4267e8ae9fef3abbe24.png" alt="图 1">  </p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Python调用C</title>
    <url>/2021/05/31/Python%E8%B0%83%E7%94%A8C/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>一个python项目快速开发完以后，常常针对瓶颈进行优化，其中一种方式就是对于性能至关重要的部分，使用C重写，这已经是一种最佳实践。如果整个项目完全使用C，开发效率就没有保障。python运行环境(CPython)是用C开发的，因此python与C结合起来很容易，而且方式多种多样。使用C重写了关键部分后，需要在python中调用，本文介绍三种最常用的调用C函数的方式，分别是<code>c extension</code>，<code>Cython</code>和<code>ctypes</code></p>
<span id="more"></span>

<h2 id="c-extension"><a href="#c-extension" class="headerlink" title="c extension"></a>c extension</h2><p>介绍<br>python标准库包含了很多使用C开发的扩展模块，比如对性能要求很高的json库。开发者同样可以使用C开发扩展，这是最原始也是最底层的扩展python的方式。</p>
<p>示例<br><code>demomodule.c</code><br>python的扩展模块由以下几部分组成：</p>
<ul>
<li>Python.h</li>
<li>C函数</li>
<li>接口函数（python代码调用的函数）到C函数的映射表</li>
<li>初始化函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pulls in the Python API </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Python.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// C function always has two arguments, conventionally named self and args</span></span><br><span class="line"><span class="comment">// The args argument will be a pointer to a Python tuple object containing the arguments.</span></span><br><span class="line"><span class="comment">// Each item of the tuple corresponds to an argument in the call’s argument list.</span></span><br><span class="line"><span class="type">static</span> PyObject *</span><br><span class="line"><span class="title function_">demo_add</span><span class="params">(PyObject *self, PyObject *args)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> a, b;</span><br><span class="line">    <span class="comment">// convert PyObject to C values</span></span><br><span class="line">    <span class="keyword">if</span> (!PyArg_ParseTuple(args, <span class="string">&quot;ii&quot;</span>, &amp;a, &amp;b))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> Py_BuildValue(<span class="string">&quot;i&quot;</span>, a+b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// module&#x27;s method table</span></span><br><span class="line"><span class="type">static</span> PyMethodDef DemoMethods[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;add&quot;</span>, demo_add, METH_VARARGS, <span class="string">&quot;Add two integers&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// module’s initialization function</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">PyModuleDef</span> <span class="title">demo</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">    PyModuleDef_HEAD_INIT,</span><br><span class="line">    <span class="string">&quot;demo&quot;</span>, <span class="comment">/* name of module */</span></span><br><span class="line">    <span class="string">&quot;&quot;</span>,          <span class="comment">/* module documentation, may be NULL */</span></span><br><span class="line">    <span class="number">-1</span>,          <span class="comment">/* size of per-interpreter state of the module, or -1 if the module keeps state in global variables. */</span></span><br><span class="line">    DemoMethods</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">PyMODINIT_FUNC <span class="title function_">PyInit_demo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> PyModule_Create(&amp;demo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><code>setup.py</code><br>编译扩展模块通常使用<code>distutils</code>或<code>setuptools</code>，它会自动调用gcc完成编译和链接。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup, Extension</span><br><span class="line"></span><br><span class="line">module1 = Extension(<span class="string">&#x27;demo&#x27;</span>,</span><br><span class="line">                    sources = [<span class="string">&#x27;demomodule.c&#x27;</span>]</span><br><span class="line">                    )</span><br><span class="line"></span><br><span class="line">setup (name = <span class="string">&#x27;a demo extension module&#x27;</span>,</span><br><span class="line">       version = <span class="string">&#x27;1.0&#x27;</span>,</span><br><span class="line">       description = <span class="string">&#x27;This is a demo package&#x27;</span>,</span><br><span class="line">       ext_modules = [module1])</span><br></pre></td></tr></table></figure>
<p>执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python setup.py build_ext --inplace</span><br></pre></td></tr></table></figure>
<p>会在当前目录生成一个<code>demo.so</code>。一个python扩展模块其实就是一个共享库(.so)，它可以直接在python解释器中<code>import</code>。<br><code>--inplace</code>表示将生成的扩展放到源码所在的目录，即当前目录，这样就可以直接<code>import</code>而不需要安装到<code>site-packages</code>目录。</p>
<p>测试<br><img src="c04af79bec761d8d27b2ceb55a9326e001fd850ac810e6702aaf033f58fd40d0.png" alt="图 1">  </p>
<h2 id="Cython"><a href="#Cython" class="headerlink" title="Cython"></a>Cython</h2><p>用官网的一句话介绍Cython的作用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">extending the CPython interpreter with fast binary modules, and interfacing Python code with external C libraries.</span><br></pre></td></tr></table></figure>
<p>简单的说，Cython的两个主要作用是：</p>
<ul>
<li>将python代码编译成二进制的扩展模块，以获得加速；同时可以在python中使用类型声明，进一步提升性能；这就意味着可以使用python代替c编写python扩展</li>
<li>在python代码里调用外部的c库</li>
</ul>
<p>示例<br>现在使用Cython重新实现上面的例子——编写C函数的包装器。</p>
<p>最终的目录结构如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── add_wrapper.c</span><br><span class="line">├── add_wrapper.pyx</span><br><span class="line">├── add_wrapper.so</span><br><span class="line">├── build</span><br><span class="line">│   └── temp.linux-x86_64-2.7</span><br><span class="line">│       └── add_wrapper.o</span><br><span class="line">├── libadd.a</span><br><span class="line">├── libadd.c</span><br><span class="line">├── libadd.h</span><br><span class="line">├── libadd.o</span><br><span class="line">└── setup.py</span><br></pre></td></tr></table></figure>
<h3 id="编译C程序"><a href="#编译C程序" class="headerlink" title="编译C程序"></a>编译C程序</h3><p>libadd.h</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br></pre></td></tr></table></figure>
<p>libadd.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般都是通过python调用动态链接库，需要将生成的库文件(.so)安装到标准路径下（比如/usr/lib)下，链接和运行的时候才能找到该文件，为了方便这里以静态链接库为例。</p>
<p>首先将c文件编译成静态链接库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -c libadd.c</span><br><span class="line">ar rcs libadd.a libadd.o</span><br></pre></td></tr></table></figure>

<p>第一步会在当前目录下生成libadd.o，第二步创建静态链接库libadd.a。</p>
<h3 id="使用Cython包装C函数"><a href="#使用Cython包装C函数" class="headerlink" title="使用Cython包装C函数"></a>使用Cython包装C函数</h3><p>使用Cython调用c函数很简单，只需要在Cython中声明函数的签名，然后编译的时候正确地链接外部的动态或静态库。</p>
<p>下面就是一个add函数的python包装器： add_wrapper.pyx</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cdef extern <span class="keyword">from</span> <span class="string">&quot;libadd.h&quot;</span>:</span><br><span class="line">    cpdef <span class="built_in">int</span> add(<span class="built_in">int</span> a, <span class="built_in">int</span> b)</span><br></pre></td></tr></table></figure>
<p>第一行表示引入头文件libadd.h。第二行声明该头文件中的add函数，直接从libadd.h拷贝过来即可，此时只有在Cython模块内部能调用该C函数，还需要在前面加cpdef声明，表示暴露出接口给python调用。</p>
<h3 id="编译Cython代码"><a href="#编译Cython代码" class="headerlink" title="编译Cython代码"></a>编译Cython代码</h3><p>Cython是需要编译成二进制模块才能使用的，编译过程包含两步：</p>
<p>Cython将Cython文件(.pyx)编译成c代码(.c)<br>gcc将c代码编译成共享库(.so)<br>怎么编译呢？最常用的方式是编写一个setup.py文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup, Extension</span><br><span class="line"><span class="keyword">from</span> Cython.Build <span class="keyword">import</span> cythonize</span><br><span class="line"></span><br><span class="line">ext_modules=[</span><br><span class="line">    Extension(<span class="string">&quot;add_wrapper&quot;</span>,</span><br><span class="line">              sources=[<span class="string">&quot;add_wrapper.pyx&quot;</span>],</span><br><span class="line">              extra_objects=[<span class="string">&#x27;libadd.a&#x27;</span>]</span><br><span class="line">    )</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">setup(</span><br><span class="line">  name = <span class="string">&#x27;wrapper for libadd&#x27;</span>,</span><br><span class="line">  ext_modules = cythonize(ext_modules),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>extra_objects表示需要链接的静态库文件，也可以替换成libraries=[“add”],library_dirs=[“.”]，连接器会自动搜索libadd.so和libadd.a，动态链接库优先。<br>执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python setup.py build_ext --inplace</span><br></pre></td></tr></table></figure>
<p>在当前目录下会生成add_wrapper.c和add_wrapper.so，add_wrapper.c是第一步编译生成的中间文件，内容比较长。add_wrapper.so是最终的python二进制模块，将它放到PYTHONPATH的某个路径下，就可以直接import。<br>如果需要重新build，你可能需要加上<code>--force</code>选项，否则可能不会生效。</p>
<p>测试<br><img src="415c8042d5fbefe1a2a09afac631c73f100216ebd8de87a200782c771d65b976.png" alt="图 2">  </p>
<p>由此可见，Cython会自动检查参数类型并完成python对象到C类型的转换。</p>
<h2 id="ctypes"><a href="#ctypes" class="headerlink" title="ctypes"></a>ctypes</h2><p>介绍<br>ctypes的主要作用就是在python中调用C动态链接库（shared library）中的函数。</p>
<p>示例</p>
<h3 id="编译成动态链接库"><a href="#编译成动态链接库" class="headerlink" title="编译成动态链接库"></a>编译成动态链接库</h3><p>libadd.c</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -shared -o libadd.so libadd.c</span><br></pre></td></tr></table></figure>
<h3 id="加载共享库"><a href="#加载共享库" class="headerlink" title="加载共享库"></a>加载共享库</h3><p>使用<code>CDLL</code>动态加载共享库，一个共享库对应一个cdll对象。调用cdll的LoadLibrary()方法或直接调用CDLL的构造函数创建一个CDLL对象。<br><img src="9478e834d2120b06e656123fbd96875922c08bacb17ea0204d7d3208af1e94ba.png" alt="图 3">  </p>
<p>指定函数类型<br>ctypes并不会校验参数的数量和类型，通过设置函数的argtypes的属性可以指定函数参数的类型：<br><img src="e7806d7025443c79a6beb821881735dc66017ba84d345157dc59aba0456d0560.png" alt="图 4">  </p>
<h2 id="benchmark"><a href="#benchmark" class="headerlink" title="benchmark"></a>benchmark</h2><p>调用C库的一个主要目的是优化性能，因此我们更关心三种方式对性能的影响。 下面通过一个简单的benchmark来比较，即使10000000次加法操作也很快，很难看出调用C函数对性能带来的提升，但这无所谓，因为我们的主要目的是对比不同调用方式在调用共享库时的性能开销。</p>
<p>测试的代码如下，由于模块名以及import的方式不同，所以每次测试需要稍微修改一下注释的地方。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># c ext</span></span><br><span class="line"><span class="comment">#from demo import add</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Cython</span></span><br><span class="line"><span class="comment">#from add_wrapper import add</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ctypes</span></span><br><span class="line"><span class="comment"># from ctypes import *</span></span><br><span class="line"><span class="comment"># mylib = CDLL(&#x27;/home/rma/mr_work/test/gobject_test/script/benchmark/libadd.so&#x27;)</span></span><br><span class="line"><span class="comment"># add = mylib.add</span></span><br><span class="line"><span class="comment"># add.argtypes = [c_int, c_int]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># python</span></span><br><span class="line"><span class="comment"># def add(a,b):</span></span><br><span class="line"><span class="comment">#    return a+b</span></span><br><span class="line"></span><br><span class="line">s=time()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10000000</span>):</span><br><span class="line">    r = add(i, i)</span><br><span class="line"><span class="built_in">print</span>(time()-s)</span><br></pre></td></tr></table></figure>

<p><img src="fb5cb16dcfc20e0e3b9f51f0161f9831affbaa3f9fbb8df895909a9d39934ea8.png" alt="图 5">  </p>
<table>
    <tr>
        <th>method</th><th>cost(s)</th>
    </tr>
    <tr>
        <td>c extension</td><td>1.5673637390136719</td>
    </tr>
    <tr>
        <td>Cython</td><td>1.3251597881317139</td>
    </tr>
    <tr>
        <td>ctypes</td><td>5.036816835403442</td>
    </tr>
    <tr>
        <td>python</td><td>1.5019426345825195</td>
    </tr>
</table>]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>C调用Python</title>
    <url>/2021/05/30/C%E8%B0%83%E7%94%A8Python/</url>
    <content><![CDATA[<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>在一个C/C++应用程序中，我们可以用一组插件来实现一些具有统一接口的功能，一般插件都是使用动态链接库实现，如果插件的变化比较频繁，我们可以使用 Python 来代替动态链接库形式的插件，这样可以很方便地更具需要求的变化改写脚本代码（进行不同的数据处理），而不是必须重新编译链接二进制的动态链接库。</p>
<span id="more"></span>

<h2 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h2><p>c/c++ 调用 python ，本质上是在 c/c++ 中启动了一个 python 解释器，由解释器对 python 相关的代码进行执行，执行完毕后释放资源，达到调用目的。</p>
<p>下边的代码 main.c 包含了调用流程内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;python3.6m/Python.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">  <span class="comment">// 初始化python解释器.C/C++中调用Python之前必须先初始化解释器</span></span><br><span class="line">  Py_Initialize();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 执行一个简单的执行python脚本命令</span></span><br><span class="line">  PyRun_SimpleString(<span class="string">&quot;print(&#x27;hello world&#x27;)\n&quot;</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 撤销Py_Initialize()和随后使用Python/C API函数进行的所有初始化</span></span><br><span class="line">  Py_Finalize();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译方法（注意这里要替换为你实际使用的 python 库和头文件路径，可以使用 whereis python 指令找到）</p>
<p>编译链接-lpython3.6m<br>运行后输出如下<br><img src="738c89d44b143100ecee0ba1e53e3d3f6fc164403dc849ea8a971b473ccc9e8f.png" alt="图 1">  </p>
<h2 id="无参函数调用"><a href="#无参函数调用" class="headerlink" title="无参函数调用"></a>无参函数调用</h2><p>在上边的例子中，我们介绍了在 c/c++ 中执行 python 语句的方法，简单的完成了一个 print 功能。而实际使用时，我们需要调用 python 模块以及模块中的函数，并且有可能需要参数传递以及返回值获取。我们首先先实现一个简单的无参数传递的函数调用功能。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;python3.6m/Python.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1、初始化python接口  </span></span><br><span class="line">	Py_Initialize();</span><br><span class="line">	<span class="keyword">if</span>(!Py_IsInitialized())&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 2、初始化python系统文件路径，保证可以访问到 .py文件</span></span><br><span class="line">	PyRun_SimpleString(<span class="string">&quot;import sys&quot;</span>);</span><br><span class="line">	PyRun_SimpleString(<span class="string">&quot;sys.path.append(&#x27;./script&#x27;)&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 3、调用python文件名，不用写后缀</span></span><br><span class="line">	PyObject* pModule = PyImport_ImportModule(<span class="string">&quot;sayhello&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>( pModule == <span class="literal">NULL</span> )&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 4、调用函数</span></span><br><span class="line">	PyObject* pFunc = PyObject_GetAttrString(pModule, <span class="string">&quot;say&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>( !pFunc || !PyCallable_Check(pFunc))&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    PyObject_CallObject(pFunc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 5、结束python接口初始化</span></span><br><span class="line">	Py_Finalize();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>sayhello.py</code> 脚本内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">say</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>执行结果<br><img src="6685d1160ec7dbec5d2d9d7f58c9fbe07c67be31c6975f39ecddacf174a444e0.png" alt="图 2">  </p>
<h2 id="有参函数调用"><a href="#有参函数调用" class="headerlink" title="有参函数调用"></a>有参函数调用</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;python3.6m/Python.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    Py_Initialize(); <span class="comment">//1、初始化python接口</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化使用的变量</span></span><br><span class="line">    PyObject* pModule = <span class="literal">NULL</span>;</span><br><span class="line">    PyObject* pFunc = <span class="literal">NULL</span>;</span><br><span class="line">    PyObject* pName = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2、初始化python系统文件路径，保证可以访问到 .py文件</span></span><br><span class="line">    PyRun_SimpleString(<span class="string">&quot;import sys&quot;</span>);</span><br><span class="line">    PyRun_SimpleString(<span class="string">&quot;sys.path.append(&#x27;./script&#x27;)&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3、调用python文件名。当前的测试python文件名是 myadd.py</span></span><br><span class="line">    <span class="comment">// 在使用这个函数的时候，只需要写文件的名称就可以了。不用写后缀。</span></span><br><span class="line">    pModule = PyImport_ImportModule(<span class="string">&quot;myadd&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4、调用函数</span></span><br><span class="line">    pFunc = PyObject_GetAttrString(pModule, <span class="string">&quot;AdditionFc&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//5、给python传参数</span></span><br><span class="line">    <span class="comment">// 函数调用的参数传递均是以元组的形式打包的,2表示参数个数</span></span><br><span class="line">    <span class="comment">// 如果AdditionFc中只有一个参数时，写1就可以了</span></span><br><span class="line">    PyObject* pArgs = PyTuple_New(<span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 0：第一个参数，传入 int 类型的值 2</span></span><br><span class="line">    PyTuple_SetItem(pArgs, <span class="number">0</span>, Py_BuildValue(<span class="string">&quot;i&quot;</span>, <span class="number">2</span>)); </span><br><span class="line">    <span class="comment">// 1：第二个参数，传入 int 类型的值 4</span></span><br><span class="line">    PyTuple_SetItem(pArgs, <span class="number">1</span>, Py_BuildValue(<span class="string">&quot;i&quot;</span>, <span class="number">4</span>)); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 6、使用C++的python接口调用该函数</span></span><br><span class="line">    PyObject* pReturn = PyEval_CallObject(pFunc, pArgs);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 7、接收python计算好的返回值</span></span><br><span class="line">    <span class="type">int</span> nResult;</span><br><span class="line">    <span class="comment">// i表示转换成int型变量。</span></span><br><span class="line">    <span class="comment">// 在这里，最需要注意的是：PyArg_Parse的最后一个参数，必须加上“&amp;”符号</span></span><br><span class="line">    PyArg_Parse(pReturn, <span class="string">&quot;i&quot;</span>, &amp;nResult);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;return result is %d\n&quot;</span>, nResult);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//8、结束python接口初始化</span></span><br><span class="line">    Py_Finalize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>myadd.py</code> 脚本内容</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">AdditionFc</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Now is in python module&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>.<span class="built_in">format</span>(a, b, a+b))</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure>

<p>测试如下<br><img src="5d9a0f8756be7222b0eb0dd1ba55a2befe3b9f0835efa3e59ccebad48af5cd44.png" alt="图 3">  </p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>gobject</title>
    <url>/2021/05/29/gobject/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>Gobject , 亦称 Glib 对象系统，是一个程序库，它可以帮助我们使用 C 语言编写面向对象程序；它提供了一个通用的动态类型系统（ GType ）、一个基本类型的实现集（如整型、枚举等）、一个基本对象类型 - Gobject 、一个信号系统以及一个可扩展的参数 / 变量体系</p>
</blockquote>
<span id="more"></span>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.gimp.org/api/2.0/glib/">https://developer.gimp.org/api/2.0/glib/</a><br><a href="https://www.freedesktop.org/software/gstreamer-sdk/data/docs/2012.5/gobject/gobject-The-Base-Object-Type.html">https://www.freedesktop.org/software/gstreamer-sdk/data/docs/2012.5/gobject/gobject-The-Base-Object-Type.html</a><br><a href="https://docs.gtk.org/gobject/func.DECLARE_DERIVABLE_TYPE.html">https://docs.gtk.org/gobject/func.DECLARE_DERIVABLE_TYPE.html</a><br><a href="https://docs.gtk.org/gobject/tutorial.html">https://docs.gtk.org/gobject/tutorial.html</a><br><a href="https://docs.gtk.org/gobject/concepts.html">https://docs.gtk.org/gobject/concepts.html</a><br><a href="https://blog.csdn.net/acs713/article/details/7778051">https://blog.csdn.net/acs713/article/details/7778051</a><br><a href="http://garfileo.is-programmer.com/categories/6934/posts">http://garfileo.is-programmer.com/categories/6934/posts</a><br><a href="http://code.google.com/p/gobject-learing/">http://code.google.com/p/gobject-learing/</a><br><a href="https://www.manpagez.com/html/gobject/gobject-2.56.0/gobject-Type-Information.php">https://www.manpagez.com/html/gobject/gobject-2.56.0/gobject-Type-Information.php</a></p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>gobject</tag>
      </tags>
  </entry>
  <entry>
    <title>NFS使用</title>
    <url>/2021/05/28/NFS%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="NFS简介"><a href="#NFS简介" class="headerlink" title="NFS简介"></a>NFS简介</h2><blockquote>
<p>NFS，是Network File System的简写，即网络文件系统。网络文件系统是FreeBSD支持的文件系统中的一种，也被称为NFS. NFS允许一个系统在网络上与他人共享目录和文件。 通过使用NFS，用户和程序可以像访问本地文件一样访问远端系统上的文件。</p>
</blockquote>
<span id="more"></span>

<h2 id="NFS的安装与配置"><a href="#NFS的安装与配置" class="headerlink" title="NFS的安装与配置"></a>NFS的安装与配置</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><p>NFS需要安装<code>nfs-utils</code>、<code>rpcbind</code>两个包。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#可以先检查下本地是否已经安装，如果安装则无需重复安装包</span></span><br><span class="line"><span class="comment"># rpm -qa|grep rpcbind</span></span><br><span class="line">rpcbind-0.2.0-42.el7.x86_64</span><br><span class="line"></span><br><span class="line"><span class="comment"># rpm -qa|grep nfs</span></span><br><span class="line">nfs-utils-1.3.0-0.48.el7_4.x86_64</span><br></pre></td></tr></table></figure>

<p>安装<code>nfs-utils</code>、<code>rpcbind</code>两个包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#centos系统</span></span><br><span class="line">yum -y install nfs-utils rpcbind</span><br><span class="line"></span><br><span class="line"><span class="comment">#Ubuntu系统</span></span><br><span class="line"><span class="comment">#服务端</span></span><br><span class="line">apt-get install nfs-kernel-server</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="创建共享目录"><a href="#创建共享目录" class="headerlink" title="创建共享目录"></a>创建共享目录</h3><p>服务端共享目录：/data/nfs-storage/</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /data/nfs-storage/</span><br></pre></td></tr></table></figure>

<h3 id="NFS共享目录文件配置"><a href="#NFS共享目录文件配置" class="headerlink" title="NFS共享目录文件配置"></a>NFS共享目录文件配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/exports </span><br><span class="line"><span class="comment">#添加以下信息</span></span><br><span class="line">/data/nfs-storage *(rw,insecure,<span class="built_in">sync</span>,no_subtree_check,no_root_squash)</span><br></pre></td></tr></table></figure>
<p>以上配置分为三个部分：</p>
<ul>
<li>第一部分就是本地要共享出去的目录。</li>
<li>第二部分为允许访问的主机（可以是一个IP也可以是一个IP段），*代表允许所有的网段访问。</li>
<li>第三部分小括号里面的，为一些权限选项。</li>
</ul>
<p>权限说明</p>
<p><code>rw</code> ：读写；<br><code>ro</code> ：只读；<br><code>sync</code> ：同步模式，内存中数据时时写入磁盘；<br><code>async</code> ：不同步，把内存中数据定期写入磁盘中；<br><code>secure</code> ：nfs通过1024以下的安全TCP/IP端口发送<br><code>insecure</code> ：nfs通过1024以上的端口发送<br><code>no_root_squash</code> ：加上这个选项后，root用户就会对共享的目录拥有至高的权限控制，就像是对本机的目录操作一样。不安全，不建议使用；<br><code>root_squash</code> ：和上面的选项对应，root用户对共享目录的权限不高，只有普通用户的权限，即限制了root；<br><code>subtree_check</code> ：如果共享/usr/bin之类的子目录时，强制nfs检查父目录的权限（默认）<br><code>no_subtree_check</code> ：和上面相对，不检查父目录权限<br><code>all_squash</code> ：不管使用NFS的用户是谁，他的身份都会被限定成为一个指定的普通用户身份；<br><code>anonuid/anongid</code> ：要和root_squash 以及 all_squash一同使用，用于指定使用NFS的用户限定后的uid和gid，前提是本机的/etc/passwd中存在这个uid和gid。</p>
<h3 id="启动NFS服务"><a href="#启动NFS服务" class="headerlink" title="启动NFS服务"></a>启动NFS服务</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#先启动rpcbind</span></span><br><span class="line">service rpcbind start</span><br><span class="line"></span><br><span class="line"><span class="comment">#后启动nfs</span></span><br><span class="line">service nfs start</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">service nfs-server restart</span><br><span class="line"></span><br><span class="line"><span class="comment">#可以设置开机启动（可能失效）</span></span><br><span class="line">chkconfig rpcbind on</span><br><span class="line">chkconfig nfs on</span><br></pre></td></tr></table></figure>
<h3 id="服务端验证"><a href="#服务端验证" class="headerlink" title="服务端验证"></a>服务端验证</h3><p>通过<code>showmount -e</code>命令如果正常显示共享目录，表示安装正常。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># showmount -e</span></span><br><span class="line"></span><br><span class="line">Export list <span class="keyword">for</span> @hostname@:</span><br><span class="line">/data/nfs-storage *</span><br></pre></td></tr></table></figure>

<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><h3 id="安装nfs-utils的包"><a href="#安装nfs-utils的包" class="headerlink" title="安装nfs-utils的包"></a>安装nfs-utils的包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#centos系统</span></span><br><span class="line">yum install nfs-utils.x86_64  -y</span><br><span class="line"><span class="comment">#Ubuntu系统</span></span><br><span class="line">apt-get install nfs-common</span><br></pre></td></tr></table></figure>

<h3 id="创建挂载点"><a href="#创建挂载点" class="headerlink" title="创建挂载点"></a>创建挂载点</h3><p>客户端挂载目录：/mnt/store</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /mnt/store</span><br></pre></td></tr></table></figure>

<h3 id="查看NFS服务器的共享"><a href="#查看NFS服务器的共享" class="headerlink" title="查看NFS服务器的共享"></a>查看NFS服务器的共享</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># showmount -e 172.16.5.4</span></span><br><span class="line">Export list <span class="keyword">for</span> 172.16.5.4:</span><br><span class="line">/data/nfs-storage *</span><br></pre></td></tr></table></figure>
<h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount -t nfs &lt;NFS_SERVER_IP&gt;:&lt;NFS_SERVER_SHARED_DIR&gt; &lt;NFS_CLIENT_MOUNT_DIR&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#例如：</span></span><br><span class="line">mount -t nfs 172.16.5.4:/data/nfs-storage /mnt/store</span><br></pre></td></tr></table></figure>
<h3 id="验证挂载信息"><a href="#验证挂载信息" class="headerlink" title="验证挂载信息"></a>验证挂载信息</h3><p><strong>使用mount命令</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mount |grep /mnt/store</span></span><br><span class="line">172.16.5.4:/data/nfs-storage/k8s-storage/ssd on /mnt/store <span class="built_in">type</span> nfs4 (rw,relatime,vers=4.0,rsize=1048576,wsize=1048576,namlen=255,hard,proto=tcp,port=0,timeo=600,retrans=2,sec=sys,clientaddr=172.16.200.24,local_lock=none,addr=172.16.5.4)</span><br></pre></td></tr></table></figure>
<p><strong>使用df -h命令</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># df -h|grep nfs</span></span><br><span class="line">172.16.5.4:/data/nfs-storage                                                                                             40G   25G   13G  67% /mnt/store</span><br></pre></td></tr></table></figure>
<p><strong>创建文件测试</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#进入客户端的挂载目录，创建文件</span></span><br><span class="line"><span class="built_in">cd</span> /mnt/store</span><br><span class="line"><span class="built_in">touch</span> test.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">#进入服务端的共享目录，查看客户端创建的文件是否同步</span></span><br><span class="line"><span class="built_in">cd</span> /data/nfs-storage </span><br><span class="line"><span class="built_in">ls</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>mount命令详解</title>
    <url>/2021/05/27/mount%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="mount命令（用来挂载硬盘或镜像等）"><a href="#mount命令（用来挂载硬盘或镜像等）" class="headerlink" title="mount命令（用来挂载硬盘或镜像等）"></a>mount命令（用来挂载硬盘或镜像等）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount [-t vfstype] [-o options] device <span class="built_in">dir</span></span><br></pre></td></tr></table></figure>

<span id="more"></span>
<p><code>-t vfstype</code> 指定文件系统的类型，通常不必指定。mount 会自动选择正确的类型。常用类型有：<br>DOS fat16文件系统：msdos<br>Windows 9x fat32文件系统：vfat<br>Windows NT ntfs文件系统：ntfs<br>Windows网络文件共享：smbfs （默认的windows系统都支持的）</p>
<p>windows网络共享文件：cifs （cifs是smbfs的升级版，默认的windows系统都支持的，首先推荐）</p>
<p>光盘或光盘镜像：iso9660<br>UNIX(LINUX) 文件网络共享：nfs</p>
<p><code>-o options</code> 主要用来描述设备或档案的挂接方式。常用的参数有：<br>loop：用来把一个文件当成硬盘分区挂接上系统<br>ro：采用只读方式挂接设备<br>rw：采用读写方式挂接设备<br>iocharset：指定访问文件系统所用字符集<br><code>device</code> 要挂接(mount)的设备。<br><code>dir</code>设备在系统上的挂接点(mount point)。 </p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>挂载本机的iso：<code>mount -o loop -t iso9660 /home/sunky/mydisk.iso /mnt/vcdrom</code><br>挂载远程的fat32的共享目录：<code>mount //10.167.20.20/shared /mnt/mywinshare</code><br>Windows 的C分区挂到linux的/mnt/winc目录下: <code>mount -t vfat /dev/hda1 /mnt/winc</code> ,如果中文显示有问题：<code>#mount -t vfat -o iocharset=cp936 /dev/hda1 /mnt/winc</code>。（要挂载本地的windows分区，在ubuntu下使用命令<code>sudo fdisk -l </code>来查看磁盘分区情况。）<br>当插入闪盘后，闪盘被识别为一个SCSI盘，通常输入以下命令：<code>mount /dev/sda1 /usb</code></p>
<h2 id="mount的基本用法"><a href="#mount的基本用法" class="headerlink" title="mount的基本用法"></a>mount的基本用法</h2><p>格式：mount [-参数] [设备名称] [挂载点]<br>其中常用的参数有：<br>-a 安装在/etc/fstab文件中类出的所有文件系统。<br>-f 伪装mount，作出检查设备和目录的样子，但并不真正挂载文件系统。<br>-n 不把安装记录在/etc/mtab 文件中。<br>-r 讲文件系统安装为只读。<br>-v 详细显示安装信息。<br>-w 将文件系统安装为可写，为命令默认情况。</p>
<p>-t &lt;文件系统类型&gt; 指定设备的文件系统类型，常见的有：<br>ext2  linux目前常用的文件系统<br>msdos  MS-DOS的fat，就是fat16<br>vfat  windows98常用的fat32<br>nfs  网络文件系统<br>iso9660  CD-ROM光盘标准文件系统<br>ntfs  windows NT/2000/XP的文件系统<br>auto 自动检测文件系统 </p>
<p>-o &lt;选项&gt; 指定挂载文件系统时的选项，有些也可写到在/etc/fstab中。常用的有：<br>defaults 使用所有选项的默认值（auto、nouser、rw、suid）<br>auto/noauto 允许/不允许以 –a选项进行安装<br>dev/nodev 对/不对文件系统上的特殊设备进行解释<br>exec/noexec 允许/不允许执行二进制代码<br>suid/nosuid 确认/不确认suid和sgid位<br>user /nouser 允许/不允许一般用户挂载<br>codepage=XXX 代码页<br>iocharset=XXX 字符集<br>ro 以只读方式挂载<br>rw 以读写方式挂载<br>remount 重新安装已经安装了的文件系统<br>loop 挂载回旋设备<br>username/password用来设置有访问权限的用户名和密码</p>
<p>需要注意的是，<strong>挂载点必须是一个已经存在的目录</strong>，这个目录可以不为空，但挂载后这个目录下以前的内容将不可用，umount以后会恢复正常。使用多个-o参数的时候，-o 只用一次，参数之间用半角逗号隔开：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mount –o remount,rw XXX XXX</span></span><br></pre></td></tr></table></figure>

<h2 id="umount基本用法"><a href="#umount基本用法" class="headerlink" title="umount基本用法"></a>umount基本用法</h2><p>譬如 /dev/hda5 已经挂载在/mnt/hda5上,用一下三条命令均可卸载挂载的文件系统</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># umount /dev/hda5</span></span><br><span class="line"><span class="comment"># umount /mnt/hda5</span></span><br><span class="line"><span class="comment"># umount /dev/hda5 /mnt/hda5</span></span><br></pre></td></tr></table></figure>

<h2 id="umount显示-device-busy"><a href="#umount显示-device-busy" class="headerlink" title="umount显示 device busy"></a>umount显示 device busy</h2><p>这是因为有程序正在访问这个设备，最简单的办法就是让访问该设备的程序退出以后再umount。可能有时候用户搞不清除究竟是什么程序在访问设备，如果用户不急着umount，则可以用:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># umount -l /mnt/hda5</span></span><br></pre></td></tr></table></figure>
<p>来卸载设备。选项 –l 并不是马上umount，而是在该目录空闲后再umount。还可以先用命令 ps aux 来查看占用设备的程序PID，然后用命令kill来杀死占用设备的进程。</p>
<h2 id="fdisk恢复分区"><a href="#fdisk恢复分区" class="headerlink" title="fdisk恢复分区"></a>fdisk恢复分区</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看当前块设备分区情况</span></span><br><span class="line">root@localhost:/home/data<span class="comment"># lsblk</span></span><br><span class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS</span><br><span class="line">sda      8:0    0 223.6G  0 disk </span><br><span class="line">├─sda1   8:1    0   538M  0 part /boot/efi</span><br><span class="line">├─sda2   8:2    0   512M  0 part /boot</span><br><span class="line">└─sda3   8:3    0    63G  0 part /</span><br><span class="line"></span><br><span class="line"><span class="comment">#对/dev/sda进行分区恢复</span></span><br><span class="line">root@localhost:/home/data<span class="comment"># fdisk /dev/sda</span></span><br><span class="line"></span><br><span class="line">Welcome to fdisk (util-linux 2.34).</span><br><span class="line">Changes will remain <span class="keyword">in</span> memory only, until you decide to write them.</span><br><span class="line">Be careful before using the write <span class="built_in">command</span>.</span><br><span class="line"></span><br><span class="line">GPT PMBR size mismatch (134217727 != 468862127) will be corrected by write.</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n</span><br><span class="line">Partition number (4-128, default 4): 4</span><br><span class="line">First sector (134217695-468862094, default 134217728): </span><br><span class="line">Last sector, +/-sectors or +/-size&#123;K,M,G,T,P&#125; (134217728-468862094, default 468862094): </span><br><span class="line"></span><br><span class="line">Created a new partition 4 of <span class="built_in">type</span> <span class="string">&#x27;Linux filesystem&#x27;</span> and of size 159.6 GiB.</span><br><span class="line">Partition <span class="comment">#4 contains a ext4 signature.</span></span><br><span class="line"></span><br><span class="line">Do you want to remove the signature? [Y]es/[N]o: N</span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): w</span><br><span class="line"></span><br><span class="line">The partition table has been altered.</span><br><span class="line">Syncing disks.</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看当前块设备分区情况</span></span><br><span class="line">root@localhost:/home/data<span class="comment"># lsblk</span></span><br><span class="line">NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS</span><br><span class="line">sda      8:0    0 223.6G  0 disk </span><br><span class="line">├─sda1   8:1    0   538M  0 part /boot/efi</span><br><span class="line">├─sda2   8:2    0   512M  0 part /boot</span><br><span class="line">├─sda3   8:3    0    63G  0 part /</span><br><span class="line">└─sda4   8:4    0 159.6G  0 part </span><br><span class="line"></span><br><span class="line"><span class="comment">#查看当前块设备挂载情况</span></span><br><span class="line">root@localhost:/home/data<span class="comment"># df -h</span></span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">udev             15G  8.4M   15G   1% /dev</span><br><span class="line">tmpfs           3.0G  2.3M  3.0G   1% /run</span><br><span class="line">/dev/sda3        62G   18G   42G  30% /</span><br><span class="line">/dev/sda2       488M  297M  155M  66% /boot</span><br><span class="line">/dev/sda1       537M  5.1M  532M   1% /boot/efi</span><br><span class="line"></span><br><span class="line"><span class="comment">#挂载恢复的分区</span></span><br><span class="line">root@localhost:/home/data<span class="comment"># mount /dev/sda4 /home/data</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看当前块设备挂载情况</span></span><br><span class="line">root@localhost:/home/data<span class="comment"># df -h</span></span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">udev             15G  8.4M   15G   1% /dev</span><br><span class="line">tmpfs           3.0G  2.3M  3.0G   1% /run</span><br><span class="line">/dev/sda3        62G   18G   42G  30% /</span><br><span class="line">/dev/sda2       488M  297M  155M  66% /boot</span><br><span class="line">/dev/sda1       537M  5.1M  532M   1% /boot/efi</span><br><span class="line">/dev/sda4       157G  138G   11G  94% /home/data</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看数据是否恢复</span></span><br><span class="line">root@localhost:/home/data<span class="comment"># ll</span></span><br><span class="line">total 110261428</span><br><span class="line">drwxr-xr-x 5 root root        4096 1月   2 02:16 ./</span><br><span class="line">drwxr-xr-x 6 root root        4096 1月   1 08:48 ../</span><br><span class="line">-rw-r--r-- 1 root root   104857600 1月   1 10:59 data0.raw</span><br><span class="line">-rw-r--r-- 1 root root   104857600 1月   1 10:59 data1.raw</span><br><span class="line">-rw-r--r-- 1 root root   104857600 1月   1 10:59 data2.raw</span><br><span class="line">-rw-r--r-- 1 root root   104857600 1月   1 10:59 data3.raw</span><br><span class="line">-rw-r--r-- 1 root root   104857600 1月   1 10:59 data4.raw</span><br><span class="line">-rw-r--r-- 1 root root   104857600 1月   1 11:00 data5.raw</span><br><span class="line">-rw-r--r-- 1 root root   104857600 1月   1 11:00 data6.raw</span><br><span class="line">-rw-r--r-- 1 root root    10485760 1月   1 11:00 data7.raw</span><br></pre></td></tr></table></figure>


<h2 id="配置开机自动挂载"><a href="#配置开机自动挂载" class="headerlink" title="配置开机自动挂载"></a>配置开机自动挂载</h2><p>因为mount命令会在重启服务器后失效，所以要将分区信息写到/etc/fstab文件中让它永久挂载：</p>
<blockquote>
<p>sudo vim /etc/fstab</p>
</blockquote>
<p>加入：</p>
<blockquote>
<p>/dev/sda4 /home/data ext4 defaults 0 0</p>
</blockquote>
<blockquote>
<p><fs spec> <fs file> <fs vfstype> <fs mntops> <fs freq> <fs passno><br>具体说明，以挂载/dev/sdb1为例：<br><fs spec>：分区定位，可以给UUID或LABEL，例如：UUID=6E9ADAC29ADA85CD或LABEL=software<br><fs file>：具体挂载点的位置，例如：/data<br><fs vfstype>：挂载磁盘类型，linux分区一般为ext4，windows分区一般为ntfs<br><fs mntops>：挂载参数，一般为defaults<br><fs freq>：磁盘检查，默认为0<br><fs passno>：磁盘检查，默认为0，不需要检查</fs></fs></fs></fs></fs></fs></fs></fs></fs></fs></fs></fs></p>
</blockquote>
<p>修改完/etc/fstab文件后，运行</p>
<blockquote>
<p>sudo mount -a</p>
</blockquote>
<p>命令验证一下配置是否正确。如果配置不正确可能会导致系统无法正常启动。</p>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>CentOS网络设置</title>
    <url>/2021/05/26/CentOS%E7%BD%91%E7%BB%9C%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="设置静态IP"><a href="#设置静态IP" class="headerlink" title="设置静态IP"></a>设置静态IP</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line"></span><br><span class="line">DEVICE=eth0         <span class="comment">#描述网卡对应的设备别名，例如ifcfg-eth0的文件中它为eth0</span></span><br><span class="line">BOOTPROTO=static       <span class="comment">#设置网卡获得ip地址的方式，可能的选项为static，dhcp或bootp，分别对应静态指定的 ip地址，通过dhcp协议获得的ip地址，通过bootp协议获得的ip地址</span></span><br><span class="line">BROADCAST=192.168.0.255   <span class="comment">#对应的子网广播地址</span></span><br><span class="line">HWADDR=00:07:E9:05:E8:B4   <span class="comment">#对应的网卡物理地址</span></span><br><span class="line">IPADDR=12.168.0.33      <span class="comment">#如果设置网卡获得 ip地址的方式为静态指定，此字段就指定了网卡对应的ip地址</span></span><br><span class="line">NETMASK=255.255.255.0    <span class="comment">#网卡对应的网络掩码</span></span><br><span class="line">NETWORK=192.168.0.0     <span class="comment">#网卡对应的网络地址</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="修改网关配置"><a href="#修改网关配置" class="headerlink" title="修改网关配置"></a>修改网关配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/sysconfig/network</span><br><span class="line"></span><br><span class="line">NETWORKING=<span class="built_in">yes</span>     <span class="comment">#(表示系统是否使用网络，一般设置为yes。如果设为no，则不能使用网络，而且很多系统服务程序将无法启动)</span></span><br><span class="line">HOSTNAME=centos    <span class="comment">#(设置本机的主机名，这里设置的主机名要和/etc/hosts中设置的主机名对应)</span></span><br><span class="line">GATEWAY=192.168.0.1  <span class="comment">#(设置本机连接的网关的IP地址。)</span></span><br></pre></td></tr></table></figure>
<p>一般情况下是添加最后一行。</p>
<h2 id="修改DNS配置"><a href="#修改DNS配置" class="headerlink" title="修改DNS配置"></a>修改DNS配置</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/resolv.conf</span><br><span class="line"></span><br><span class="line">nameserver　<span class="comment">#即是DNS服务器ＩＰ地址，第一个是首选，第二个是备用。 </span></span><br></pre></td></tr></table></figure>

<h2 id="重启网络"><a href="#重启网络" class="headerlink" title="重启网络"></a>重启网络</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service network restart</span><br><span class="line"></span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line"></span><br><span class="line">/etc/init.d/network restart</span><br></pre></td></tr></table></figure>

<h2 id="修改hostname"><a href="#修改hostname" class="headerlink" title="修改hostname"></a>修改hostname</h2><p>方法1：修改配置文件<br>主机名保存在<code>/etc/hostname</code>文件里，所以我们可以打开这个文件，手动编辑主机名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo vim /etc/hostname</span><br><span class="line"></span><br><span class="line">#立即生效，重登终端</span><br><span class="line">sudo hostname -F /etc/hostname</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方法2：<code>hostnamectl</code>命令<br>命令语法为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo hostnamectl set-hostname &lt;newhostname&gt;</span><br></pre></td></tr></table></figure>

<p>这条命令会删除<code>/etc/hostname</code>文件中的主机名，然后替换为新的主机名。和第一种方法一样，我们也需要更新<code>/etc/hosts</code>文件。这两种方法的本质都是一样的。</p>
<p>方法3：<code>hostname</code>命令进行临时更改<br>如果只需要临时更改主机名，可以使用hostname命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo hostname &lt;new-hostname&gt;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sysctl kernel.hostname=&lt;new-hostname&gt;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &lt;new-hostname&gt; &gt; /proc/sys/kernel/hostname</span><br></pre></td></tr></table></figure>

<h2 id="etc-hostname与-etc-hosts"><a href="#etc-hostname与-etc-hosts" class="headerlink" title="/etc/hostname与/etc/hosts"></a>/etc/hostname与/etc/hosts</h2><p>/etc/hostname 存放主机名，/etc/hosts 存放域名与ip的对应关系，其实主机名和 /etc/hosts 没什么关系，只不过如果 /etc/hosts 中的IP和主机名不对应的话，就不能用主机名来访问这台主机了</p>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>pyinstaller使用</title>
    <url>/2021/05/25/pyinstaller%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>考虑到代码、数据的隐私安全，所以我们就需要使用PyInstaller将自己的运行主程序打包起来，从而创建得到独立应用（自包含该应用的依赖包）。最重要的是可以使用 PyInstaller 将 Python 程序生成可直接运行的程序，这个程序就可以被分发到对应的 Windows 或 Mac OS X 平台上运行。</p>
</blockquote>
<span id="more"></span>

<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install pyinstaller</span><br></pre></td></tr></table></figure>
<p><img src="804adcfccd404c52549b74b96f372841d4d7b9bac4443336b55b87acdede5aec.png" alt="图 4">  </p>
<h2 id="使用-F-打包程序"><a href="#使用-F-打包程序" class="headerlink" title="使用 -F 打包程序"></a>使用 -F 打包程序</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pyinstaller -F qmp.py</span><br></pre></td></tr></table></figure>

<p>生成目录树如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── __pycache__</span><br><span class="line">│   └── qmp.cpython-36.pyc</span><br><span class="line">├── build</span><br><span class="line">│   └── qmp</span><br><span class="line">│       ├── Analysis-00.toc</span><br><span class="line">│       ├── EXE-00.toc</span><br><span class="line">│       ├── PKG-00.toc</span><br><span class="line">│       ├── PYZ-00.pyz</span><br><span class="line">│       ├── PYZ-00.toc</span><br><span class="line">│       ├── base_library.zip</span><br><span class="line">│       ├── qmp.pkg</span><br><span class="line">│       ├── warn-qmp.txt</span><br><span class="line">│       └── xref-qmp.html</span><br><span class="line">├── dist</span><br><span class="line">│   └── qmp</span><br><span class="line">├── qmp.py</span><br><span class="line">└── qmp.spec</span><br></pre></td></tr></table></figure>
<p>可以看到在dist目录下生成可执行文件</p>
<h2 id="使用-D-打包程序"><a href="#使用-D-打包程序" class="headerlink" title="使用 -D 打包程序"></a>使用 -D 打包程序</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pyinstaller -D qmp.py</span><br></pre></td></tr></table></figure>
<p>将会在当前目录下看到多了一个dist目录，并在该目录下看到有一个qmp子目录，在该子目录下包含了.so 文件，它们都是可执行程序的支撑文件<br>生成目录树如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── __pycache__</span><br><span class="line">│   └── qmp.cpython-36.pyc</span><br><span class="line">├── build</span><br><span class="line">│   └── qmp</span><br><span class="line">│       ├── Analysis-00.toc</span><br><span class="line">│       ├── COLLECT-00.toc</span><br><span class="line">│       ├── EXE-00.toc</span><br><span class="line">│       ├── PKG-00.toc</span><br><span class="line">│       ├── PYZ-00.pyz</span><br><span class="line">│       ├── PYZ-00.toc</span><br><span class="line">│       ├── base_library.zip</span><br><span class="line">│       ├── qmp</span><br><span class="line">│       ├── qmp.pkg</span><br><span class="line">│       ├── warn-qmp.txt</span><br><span class="line">│       └── xref-qmp.html</span><br><span class="line">├── dist</span><br><span class="line">│   └── qmp</span><br><span class="line">│       ├── base_library.zip</span><br><span class="line">│       ├── lib-dynload</span><br><span class="line">│       │   ├── _bz2.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">│       │   ├── _codecs_cn.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">│       │   ├── _codecs_hk.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">│       │   ├── _codecs_iso2022.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">│       │   ├── _codecs_jp.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">│       │   ├── _codecs_kr.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">│       │   ├── _codecs_tw.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">│       │   ├── _hashlib.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">│       │   ├── _json.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">│       │   ├── _lzma.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">│       │   ├── _multibytecodec.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">│       │   ├── _opcode.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">│       │   ├── _ssl.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">│       │   ├── readline.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">│       │   ├── resource.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">│       │   └── termios.cpython-36m-x86_64-linux-gnu.so</span><br><span class="line">│       ├── libbz2.so.1.0</span><br><span class="line">│       ├── libcrypto.so.1.1</span><br><span class="line">│       ├── libexpat.so.1</span><br><span class="line">│       ├── liblzma.so.5</span><br><span class="line">│       ├── libpython3.6m.so.1.0</span><br><span class="line">│       ├── libreadline.so.7</span><br><span class="line">│       ├── libssl.so.1.1</span><br><span class="line">│       ├── libtinfo.so.5</span><br><span class="line">│       ├── libz.so.1</span><br><span class="line">│       └── qmp</span><br><span class="line">├── qmp.py</span><br><span class="line">└── qmp.spec</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>meson语法</title>
    <url>/2021/05/24/meson%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="手册"><a href="#手册" class="headerlink" title="手册"></a>手册</h2><p><a href="https://mesonbuild.com/Reference-manual.html">Reference-manual</a></p>
<span id="more"></span>

<h2 id="project"><a href="#project" class="headerlink" title="project()"></a>project()</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The first function called in each project, to initialize Meson</span></span><br><span class="line">void project(</span><br><span class="line">  <span class="built_in">str</span> project_name,     <span class="comment"># The name of the project</span></span><br><span class="line">  <span class="built_in">str</span> language...,      <span class="comment"># The languages that Meson should initialize</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Keyword arguments:</span></span><br><span class="line">  default_options : <span class="built_in">list</span>[<span class="built_in">str</span>]        <span class="comment"># Accecpts strings in the form `key=value`</span></span><br><span class="line">  license         : <span class="built_in">str</span> | <span class="built_in">list</span>[<span class="built_in">str</span>]  <span class="comment"># Takes a string or array of strings describing the license(s) the code is under</span></span><br><span class="line">  meson_version   : <span class="built_in">str</span>              <span class="comment"># Takes a string describing which Meson version the project requires</span></span><br><span class="line">  subproject_dir  : <span class="built_in">str</span>              <span class="comment"># Specifies the top level directory name that holds Meson subprojects</span></span><br><span class="line">  version         : <span class="built_in">str</span> | file       <span class="comment"># A free form string describing the version of this project</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>每个项目中调用的第一个函数，用于初始化 Meson。<br>此函数的第一个参数必须是定义此项目名称的字符串。<br>语言支持的值为c, cpp(for C++), cuda, d, objc, objcpp, fortran, java, cs(for C#),vala和rust.</p>
<p><strong>参数</strong></p>
<table>
    <tr>
        <th>名称</th><th>类型</th><th>描述</th>
    </tr>
    <tr>
        <td>project_name</td><td>str</td><td>项目的名称</td>
    </tr>
    <tr>
        <td>default_options</td><td>list[str]</td><td>key=value 接受格式与选项相同格式的字符串meson configure。例如，要设置默认项目类型，您可以这样设置：default_options : ['buildtype=debugoptimized']. 请注意，这些设置仅在首次运行 Meson 时使用。buildtype只能在主项目中指定的全局选项，子项目中的设置将被忽略。即使在子项目中也通常使用项目特定选项</td>
    </tr>
    <tr>
        <td>license</td><td>str|list[str]</td><td>采用描述代码所依据的许可证的字符串或字符串数​​组</td>
    </tr>
    <tr>
        <td>meson_version</td><td>str</td><td>获取一个描述项目需要哪个 Meson 版本的字符串。通常像>=0.28.0</td>
    </tr>
    <tr>
        <td>subproject_dir</td><td>str</td><td>指定保存 Meson 子项目的顶级目录名称。这只是作为现有代码库的兼容性选项，这些代码库将其嵌入式源代码存放在自定义目录中。所有新项目都不应设置此项，而应使用默认值。应该注意的是，这个关键字参数在子项目中被忽略。只能有一个子项目目录，它在顶层 Meson 文件中设置</td>
    </tr>
    <tr>
        <td>version</td><td>str|file</td><td>描述此项目版本的自由格式字符串。您可以使用以下方法访问 Meson 构建文件中的值meson.project_version(). （自 0.57.0 起）这也可以是 file指向一个只包含一行文本的文件的对象</td>
    </tr>
</table>


<p><strong>示例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">project(<span class="string">&#x27;DPDK&#x27;</span>, <span class="string">&#x27;C&#x27;</span>,</span><br><span class="line">	<span class="comment"># Get version number from file.</span></span><br><span class="line">	<span class="comment"># Fallback to &quot;more&quot; for Windows compatibility.</span></span><br><span class="line">	version: run_command(find_program(<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;more&#x27;</span>),</span><br><span class="line">		files(<span class="string">&#x27;VERSION&#x27;</span>)).stdout().strip(),</span><br><span class="line">	license: <span class="string">&#x27;BSD&#x27;</span>,</span><br><span class="line">	default_options: [<span class="string">&#x27;buildtype=release&#x27;</span>, <span class="string">&#x27;default_library=static&#x27;</span>],</span><br><span class="line">	meson_version: <span class="string">&#x27;&gt;= 0.47.1&#x27;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="meson-get-compiler"><a href="#meson-get-compiler" class="headerlink" title="meson.get_compiler()"></a>meson.get_compiler()</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Returns a compiler object describing a compiler.</span></span><br><span class="line">compiler get_compiler(</span><br><span class="line">  <span class="built_in">str</span> language,     <span class="comment"># The language of the compiler to return</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Keyword arguments:</span></span><br><span class="line">  native : <span class="built_in">bool</span>  <span class="comment"># When set to `true` Meson returns the compiler for the build</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>返回一个compiler描述编译器的对象。</p>
<p><strong>参数</strong></p>
<table>
    <tr>
        <th>名称</th><th>类型</th><th>描述</th>
    </tr>
    <tr>
        <td>language</td><td>str</td><td>编译器返回的语言</td>
    </tr>
    <tr>
        <td>native</td><td>bool</td><td>当设置为true，Meson 时返回构建机器的编译器（“本机”编译器），当false它返回主机编译器（“交叉”编译器）时。如果native被省略，如果我们当前正在交叉编译，Meson 将返回“交叉”编译器，如果不是，则返回“本机”编译器。</td>
    </tr>
</table>

<p><strong>示例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cc = meson.get_compiler(<span class="string">&#x27;c&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="configuration-data"><a href="#configuration-data" class="headerlink" title="configuration_data()"></a>configuration_data()</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Creates an empty configuration object</span></span><br><span class="line">cfg_data configuration_data(</span><br><span class="line">  <span class="built_in">dict</span>[<span class="built_in">str</span> | <span class="built_in">bool</span> | <span class="built_in">int</span>] [data],   <span class="comment"># Optional dictionary to specify an initial data set</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>创建一个空的配置对象。你应该添加你的配置cfg_data方法调用，最后在调用中使用它configure_file()</p>
<p><strong>参数</strong></p>
<table>
    <tr>
        <th>名称</th><th>类型</th><th>描述</th>
    </tr>
    <tr>
        <td>data</td><td>dict[str|bool|int]</td><td>用于指定初始数据集的可选字典。如果提供，每个键/值对被添加到cfg_data对象就好像cfg_data.set()为他们每个人调用了方法。</td>
    </tr>
</table>

<p><strong>示例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dpdk_conf = configuration_data()</span><br></pre></td></tr></table></figure>

<h2 id="configure-file"><a href="#configure-file" class="headerlink" title="configure_file()"></a>configure_file()</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This function can run in three modes depending on the keyword arguments</span></span><br><span class="line">file configure_file(</span><br><span class="line">  capture       : <span class="built_in">bool</span>                               <span class="comment"># When this argument is set to true,</span></span><br><span class="line">  command       : <span class="built_in">list</span>[<span class="built_in">str</span> | file]                   <span class="comment"># As explained above, if specified, Meson does not create</span></span><br><span class="line">  configuration : cfg_data | <span class="built_in">dict</span>[<span class="built_in">str</span> | <span class="built_in">int</span> | <span class="built_in">bool</span>]  <span class="comment"># As explained above, when passed this will provide the replacement</span></span><br><span class="line">  copy          : <span class="built_in">bool</span>                               <span class="comment"># As explained above, if specified Meson only</span></span><br><span class="line">  depfile       : <span class="built_in">str</span>                                <span class="comment"># A dependency file that the command can write listing</span></span><br><span class="line">  encoding      : <span class="built_in">str</span>                                <span class="comment"># Set the file encoding for the input and output file</span></span><br><span class="line">  <span class="built_in">format</span>        : <span class="built_in">str</span>                                <span class="comment"># The format of defines</span></span><br><span class="line">  <span class="built_in">input</span>         : <span class="built_in">str</span> | file                         <span class="comment"># The input file name</span></span><br><span class="line">  install       : <span class="built_in">bool</span>                               <span class="comment"># When true, this generated file is installed during</span></span><br><span class="line">  install_dir   : <span class="built_in">str</span>                                <span class="comment"># The subdirectory to install the generated file to</span></span><br><span class="line">  install_mode  : <span class="built_in">list</span>[<span class="built_in">str</span> | <span class="built_in">int</span>]                    <span class="comment"># Specify the file mode in symbolic format</span></span><br><span class="line">  install_tag   : <span class="built_in">str</span>                                <span class="comment"># A string used by the `meson install --tags` command</span></span><br><span class="line">  output        : <span class="built_in">str</span>                                <span class="comment"># The output file name</span></span><br><span class="line">  output_format : <span class="built_in">str</span>                                <span class="comment"># The format of the output to generate when no input</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>根据传递给它的关键字参数，此函数可以以三种模式运行。<br>当一个cfg_data object 被传递给configuration:关键字参数，它采用模板文件作为input:（可选）并output:通过替换配置数据中的值来生成（必需），如配置文件文档中所述。（自 0.49.0 起） 可以传递字典而不是 cfg_data目的。</p>
<p>将字符串列表传递给command:关键字参数时，它会将任何源文件或配置文件作为input:并假定在output:运行指定命令时生成。</p>
<p>（自 0.47.0 起）当copy:关键字参数设置为 时true，此函数会将提供的文件复制input:到构建目录中的文件中，名称output:在当前目录中。</p>
<p><strong>参数</strong></p>
<table>
    <tr>
        <th>名称</th><th>类型</th><th>描述</th>
    </tr>
    <tr>
        <td>capture</td><td>bool</td><td>当此参数设置为 true 时，Meson 捕获stdout并将command其写入指定为output。</td>
    </tr>
    <tr>
        <td>command</td><td>list[str|file]</td><td>如上所述，如果指定，Meson 不会自己创建文件，而是运行指定的命令，这样您就可以生成完全自定义的文件。（自 0.52.0 起）该命令可以包含文件对象，并且可以将多个文件传递给input关键字参数，请参阅custom_target()有关字符串替换的详细信息。</td>
    </tr>
    <tr>
        <td>configuration</td><td>cfg_data|dict[str|int|bool]</td><td>如上所述，当通过时，这将为输入文件（如果提供）或要写入输出的键值对提供替换数据。</td>
    </tr>
    <tr>
        <td>copy</td><td>bool</td><td>如上所述，如果指定, Meson则仅将文件从输入复制到输出。</td>
    </tr>
    <tr>
        <td>depfile</td><td>str</td><td>命令可以写入的依赖文件，列出该目标依赖的所有附加文件。这些文件中的任何一个发生更改都会触发重新配置。</td>
    </tr>
    <tr>
        <td>encoding</td><td>str</td><td>设置输入和输出文件的文件编码。支持的编码是 python3 的编码，请参阅 standard-encodings。</td>
    </tr>
    <tr>
        <td>format</td><td>str</td><td>定义的格式。default = 'meson'，因此替换 #mesondefine由字符包围的语句和变量@，您还可以使用语法'cmake' 替换#cmakedefine语句和变量${variable}。最后，您可以使用 'cmake@'在这种情况下替换将应用于具有语法的#cmakedefine语句和变量。@variable@</td>
    </tr>
    <tr>
        <td>input</td><td>str|file</td><td>输入文件名。如果未在配置模式中指定，则configuration:对象中的所有变量（见上文）都将写入output:文件</td>
    </tr>
    <tr>
        <td>install</td><td>bool</td><td>为真时，此生成的文件将在安装步骤中安装，并且install_dir必须设置且不能为空。为 false 时，无论 . 的值如何，都不会安装此生成的文件install_dir。当省略时，它在设置时默认为 true，install_dir而不是空的，否则为 false。</td>
    </tr>
    <tr>
        <td>install_dir</td><td>str</td><td>将生成的文件安装到的子目录（例如share/myproject），如果省略或给出空字符串的值，则不会安装该文件。</td>
    </tr>
    <tr>
        <td>install_mode</td><td>list[str|int]</td><td>以符号格式指定文件模式，并可选地指定已安装文件的所有者/uid 和组/gid。</td>
    </tr>
    <tr>
        <td>install_tag</td><td>str</td><td>meson install --tags该命令用于仅安装文件子集的字符串。默认情况下，该文件没有安装标签，这意味着在--tags指定参数时它不会被安装。</td>
    </tr>
    <tr>
        <td>output</td><td>str</td><td>输出文件名。（自 0.41.0 起）可能包含 @PLAINNAME@或@BASENAME@替换。在配置模式下，输入文件的权限（如果指定）被复制到输出文件。</td>
    </tr>
    <tr>
        <td>output_format</td><td>str|file</td><td>未指定输入时生成的输出格式。它默认为c，在这种情况下，预处理器指令将以 为前缀#，您也可以使用nasm，在这种情况下，前缀为%。</td>
    </tr>
</table>


<p><strong>示例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># write the build config</span></span><br><span class="line">build_cfg = <span class="string">&#x27;rte_build_config.h&#x27;</span></span><br><span class="line">configure_file(output: build_cfg,</span><br><span class="line">		configuration: dpdk_conf,</span><br><span class="line">		install_dir: join_paths(get_option(<span class="string">&#x27;includedir&#x27;</span>),</span><br><span class="line">				get_option(<span class="string">&#x27;include_subdir_arch&#x27;</span>)))</span><br></pre></td></tr></table></figure>


<h2 id="files"><a href="#files" class="headerlink" title="files()"></a>files()</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This command takes the strings given to it in arguments and returns</span></span><br><span class="line"><span class="built_in">list</span>[file] files(</span><br><span class="line">  <span class="built_in">str</span> file...,  <span class="comment"># Path to the file</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>此命令采用参数中提供给它的字符串，并返回相应的 File 对象，您可以将这些对象用作构建目标的源。不同之处在于文件对象会记住它们在其中定义的子目录，并且可以在源代码树中的任何位置使用。</p>
<p><strong>示例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">abi_version_file = files(<span class="string">&#x27;ABI_VERSION&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="host-machine-cpu-family"><a href="#host-machine-cpu-family" class="headerlink" title="host_machine.cpu_family()"></a>host_machine.cpu_family()</h2><p>获取目标机器的cpu架构</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> host_machine.cpu_family().startswith(<span class="string">&#x27;x86&#x27;</span>)</span><br><span class="line">	arch_subdir = <span class="string">&#x27;x86&#x27;</span></span><br><span class="line"><span class="keyword">elif</span> host_machine.cpu_family().startswith(<span class="string">&#x27;arm&#x27;</span>) <span class="keyword">or</span> host_machine.cpu_family().startswith(<span class="string">&#x27;aarch&#x27;</span>)</span><br><span class="line">	arch_subdir = <span class="string">&#x27;arm&#x27;</span></span><br><span class="line"><span class="keyword">elif</span> host_machine.cpu_family().startswith(<span class="string">&#x27;ppc&#x27;</span>)</span><br><span class="line">	arch_subdir = <span class="string">&#x27;ppc&#x27;</span></span><br><span class="line">endif</span><br></pre></td></tr></table></figure>

<h2 id="include-directories"><a href="#include-directories" class="headerlink" title="include_directories()"></a>include_directories()</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Returns an opaque object which contains the directories (relative to</span></span><br><span class="line">inc include_directories(</span><br><span class="line">  <span class="built_in">str</span> includes...,  <span class="comment"># Include paths to add</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Keyword arguments:</span></span><br><span class="line">  is_system : <span class="built_in">bool</span>  <span class="comment"># If set to `true`, flags the specified directories as system directories</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>头文件的搜索路径</p>
<p><strong>示例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">global_inc = include_directories(<span class="string">&#x27;.&#x27;</span>, <span class="string">&#x27;config&#x27;</span>,</span><br><span class="line">	<span class="string">&#x27;lib/librte_eal/include&#x27;</span>,</span><br><span class="line">	<span class="string">&#x27;lib/librte_eal/@0@/include&#x27;</span>.<span class="built_in">format</span>(host_machine.system()),</span><br><span class="line">	<span class="string">&#x27;lib/librte_eal/@0@/include&#x27;</span>.<span class="built_in">format</span>(arch_subdir),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="custom-target"><a href="#custom-target" class="headerlink" title="custom_target()"></a>custom_target()</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Create a custom top level build target</span></span><br><span class="line">custom_tgt custom_target(</span><br><span class="line">  <span class="built_in">str</span> [name],   <span class="comment"># The *unique* id of the custom target</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Keyword arguments:</span></span><br><span class="line">  build_always       : <span class="built_in">bool</span>                                       <span class="comment"># If `true` this target is always considered out of</span></span><br><span class="line">  build_always_stale : <span class="built_in">bool</span>                                       <span class="comment"># If `true` the target is always considered out of date</span></span><br><span class="line">  build_by_default   : <span class="built_in">bool</span>                                       <span class="comment"># Causes, when set to true, to</span></span><br><span class="line">  capture            : <span class="built_in">bool</span>                                       <span class="comment"># There are some compilers that can&#x27;t be told to write</span></span><br><span class="line">  command            : <span class="built_in">list</span>[<span class="built_in">str</span> | file | exe | external_program]  <span class="comment"># Command to run to create outputs from inputs</span></span><br><span class="line">  console            : <span class="built_in">bool</span>                                       <span class="comment"># Keyword argument conflicts with `capture`, and is meant</span></span><br><span class="line">  depend_files       : <span class="built_in">list</span>[<span class="built_in">str</span> | file]                           <span class="comment"># files (str,</span></span><br><span class="line">  depends            : <span class="built_in">list</span>[build_tgt | custom_tgt]               <span class="comment"># Specifies that this target depends on the specified</span></span><br><span class="line">  depfile            : <span class="built_in">str</span>                                        <span class="comment"># A dependency file that the command can write listing</span></span><br><span class="line">  env                : env | <span class="built_in">list</span>[<span class="built_in">str</span>] | <span class="built_in">dict</span>[<span class="built_in">str</span>]                <span class="comment"># environment variables to set, such as</span></span><br><span class="line">  feed               : <span class="built_in">bool</span>                                       <span class="comment"># There are some compilers that can&#x27;t be told to read</span></span><br><span class="line">  <span class="built_in">input</span>              : <span class="built_in">list</span>[<span class="built_in">str</span> | file]                           <span class="comment"># List of source files</span></span><br><span class="line">  install            : <span class="built_in">bool</span>                                       <span class="comment"># When true, one or more files of this target are installed during the install step (see `install_dir` for details)</span></span><br><span class="line">  install_dir        : <span class="built_in">str</span> | <span class="built_in">list</span>[<span class="built_in">str</span> | <span class="built_in">bool</span>]                     <span class="comment"># If only one install_dir is provided, all outputs are installed there</span></span><br><span class="line">  install_mode       : <span class="built_in">list</span>[<span class="built_in">str</span> | <span class="built_in">int</span>]                            <span class="comment"># The file mode and optionally the owner/uid and group/gid</span></span><br><span class="line">  install_tag        : <span class="built_in">list</span>[<span class="built_in">str</span>]                                  <span class="comment"># A list of strings, one per output, used by the `meson install --tags` command</span></span><br><span class="line">  output             : <span class="built_in">list</span>[<span class="built_in">str</span>]                                  <span class="comment"># List of output files</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>有时，源文件在传递给实际编译器之前需要进行预处理。例如，您可能希望构建一个 IDL 编译器，然后通过它运行一些文件以生成实际的源文件。</p>
<p>假设有一个必须使用编译器生成的源代码构建的构建目标。编译器可以是内置目标：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mycomp = executable(<span class="string">&#x27;mycompiler&#x27;</span>, <span class="string">&#x27;compiler.c&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>或者系统提供的外部程序，或者源码树里面的脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mycomp = find_program(<span class="string">&#x27;mycompiler&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>自定义目标可以采用零个或多个输入文件并使用它们生成一个或多个输出文件。使用自定义目标，可以在构建时运行此编译器以生成源代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gen_src = custom_target(<span class="string">&#x27;gen-output&#x27;</span>,</span><br><span class="line">                        <span class="built_in">input</span> : [<span class="string">&#x27;somefile1.c&#x27;</span>, <span class="string">&#x27;file2.c&#x27;</span>],</span><br><span class="line">                        output : [<span class="string">&#x27;out.c&#x27;</span>, <span class="string">&#x27;out.h&#x27;</span>],</span><br><span class="line">                        command : [mycomp, <span class="string">&#x27;@INPUT@&#x27;</span>,</span><br><span class="line">                                   <span class="string">&#x27;--c-out&#x27;</span>, <span class="string">&#x27;@OUTPUT0@&#x27;</span>,</span><br><span class="line">                                   <span class="string">&#x27;--h-out&#x27;</span>, <span class="string">&#x27;@OUTPUT1@&#x27;</span>])</span><br></pre></td></tr></table></figure>
<p>那里将<code>@INPUT@</code>被转换为<code>&#39;somefile1.c&#39;</code> <code>&#39;file2.c&#39;</code>。就像输出一样，也可以通过索引<code>&#39;@OUTPUT0@&#39;</code> <code>&#39;@OUTPUT1@&#39;</code>单独引用每个输入文件</p>
<p><strong>示例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">prog_python = <span class="keyword">import</span>(<span class="string">&#x27;python&#x27;</span>).find_installation(<span class="string">&#x27;python3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">foo_c = custom_target(</span><br><span class="line">    <span class="string">&#x27;foo.c&#x27;</span>,</span><br><span class="line">    output : <span class="string">&#x27;foo.c&#x27;</span>,</span><br><span class="line">    <span class="built_in">input</span> : <span class="string">&#x27;my_gen.py&#x27;</span>,</span><br><span class="line">    command : [prog_python, <span class="string">&#x27;@INPUT@&#x27;</span>, <span class="string">&#x27;--code&#x27;</span>, <span class="string">&#x27;@OUTPUT@&#x27;</span>],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">foo_h = custom_target(</span><br><span class="line">    <span class="string">&#x27;foo.h&#x27;</span>,</span><br><span class="line">    output : <span class="string">&#x27;foo.h&#x27;</span>,</span><br><span class="line">    <span class="built_in">input</span> : <span class="string">&#x27;my_gen.py&#x27;</span>,</span><br><span class="line">    command : [prog_python, <span class="string">&#x27;@INPUT@&#x27;</span>, <span class="string">&#x27;--header&#x27;</span>, <span class="string">&#x27;@OUTPUT@&#x27;</span>],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">libfoo = static_library(<span class="string">&#x27;foo&#x27;</span>, [foo_c, foo_h])</span><br><span class="line"></span><br><span class="line">executable(<span class="string">&#x27;myexe&#x27;</span>, [<span class="string">&#x27;main.c&#x27;</span>, foo_h], link_with : libfoo)</span><br></pre></td></tr></table></figure>

<p><strong>一次生成多个文件</strong><br>custom_target可以像列表一样对其进行索引，以分别获取每个输出文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">prog_python = <span class="keyword">import</span>(<span class="string">&#x27;python&#x27;</span>).find_installation(<span class="string">&#x27;python3&#x27;</span>)</span><br><span class="line"></span><br><span class="line">foo_ch = custom_target(</span><br><span class="line">    <span class="string">&#x27;foo.[ch]&#x27;</span>,</span><br><span class="line">    output : [<span class="string">&#x27;foo.c&#x27;</span>, <span class="string">&#x27;foo.h&#x27;</span>],</span><br><span class="line">    <span class="built_in">input</span> : <span class="string">&#x27;my_gen.py&#x27;</span>,</span><br><span class="line">    command : [prog_python, <span class="string">&#x27;@INPUT@&#x27;</span>, <span class="string">&#x27;@OUTPUT@&#x27;</span>],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">libfoo = static_library(<span class="string">&#x27;foo&#x27;</span>, [foo_ch])</span><br><span class="line"></span><br><span class="line">executable(<span class="string">&#x27;myexe&#x27;</span>, [<span class="string">&#x27;main.c&#x27;</span>, foo_ch[<span class="number">1</span>]], link_with : libfoo)</span><br></pre></td></tr></table></figure>
<p>在这种情况下libfoo，取决于foo.c且foo.h仅myexe 取决于foo.h，第二个输出。</p>
<h2 id="find-program"><a href="#find-program" class="headerlink" title="find_program()"></a>find_program()</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># `program_name` here is a string that can be an executable or script</span></span><br><span class="line">external_program find_program(</span><br><span class="line">  <span class="built_in">str</span> | file program_name,     <span class="comment"># The name of the program to search, or a file object to be used</span></span><br><span class="line">  <span class="built_in">str</span> | file fallback...,      <span class="comment"># These parameters are used as fallback names to search for</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Keyword arguments:</span></span><br><span class="line">  dirs     : <span class="built_in">list</span>[<span class="built_in">str</span>]       <span class="comment"># extra list of absolute paths where to look for program names</span></span><br><span class="line">  disabler : <span class="built_in">bool</span>            <span class="comment"># If `true` and the program couldn&#x27;t be found, return a disabler object</span></span><br><span class="line">  native   : <span class="built_in">bool</span>            <span class="comment"># Defines how this executable should be searched</span></span><br><span class="line">  required : <span class="built_in">bool</span> | feature  <span class="comment"># When `true`, Meson will abort if no program can be found</span></span><br><span class="line">  version  : <span class="built_in">str</span>             <span class="comment"># specifies the required version, see</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>在环境变量PATH中查找，或者其他地方查找</p>
<p><strong>示例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pkgconf = find_program(<span class="string">&#x27;pkg-config&#x27;</span>, <span class="string">&#x27;pkgconf&#x27;</span>, required: false)</span><br><span class="line">pmdinfo = find_program(<span class="string">&#x27;gen-pmdinfo-cfile.sh&#x27;</span>)</span><br><span class="line">check_symbols = find_program(<span class="string">&#x27;check-symbols.sh&#x27;</span>)</span><br><span class="line">ldflags_ibverbs_static = find_program(<span class="string">&#x27;options-ibverbs-static.sh&#x27;</span>)</span><br><span class="line">binutils_avx512_check = find_program(<span class="string">&#x27;binutils-avx512-check.sh&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="executable"><a href="#executable" class="headerlink" title="executable()"></a>executable()</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Creates a new executable</span></span><br><span class="line">exe executable(</span><br><span class="line">  <span class="built_in">str</span>                                                   target_name,     <span class="comment"># The *unique* name of the build target</span></span><br><span class="line">  <span class="built_in">str</span> | file | custom_tgt | custom_idx | generated_list source...,       <span class="comment"># Input source to compile</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Keyword arguments:</span></span><br><span class="line">  &lt;lang&gt;_args                  : <span class="built_in">list</span>[<span class="built_in">str</span>]                                                               <span class="comment"># compiler flags to use for the given language;</span></span><br><span class="line">  &lt;lang&gt;_pch                   : <span class="built_in">str</span>                                                                     <span class="comment"># precompiled header file to use for the given language</span></span><br><span class="line">  build_by_default             : <span class="built_in">bool</span>                                                                    <span class="comment"># Causes, when set to `true`, to have this target be built by default</span></span><br><span class="line">  build_rpath                  : <span class="built_in">str</span>                                                                     <span class="comment"># A string to add to target&#x27;s rpath definition in the build dir,</span></span><br><span class="line">  d_debug                      : <span class="built_in">list</span>[<span class="built_in">str</span>]                                                               <span class="comment"># The [D version identifiers](https://dlang</span></span><br><span class="line">  d_import_dirs                : <span class="built_in">list</span>[<span class="built_in">str</span>]                                                               <span class="comment"># List of directories to look in for string imports used in the D programming language</span></span><br><span class="line">  d_module_versions            : <span class="built_in">list</span>[<span class="built_in">str</span> | <span class="built_in">int</span>]                                                         <span class="comment"># List of module version identifiers set when compiling D sources</span></span><br><span class="line">  d_unittest                   : <span class="built_in">bool</span>                                                                    <span class="comment"># When set to true, the D modules are compiled in debug mode</span></span><br><span class="line">  dependencies                 : <span class="built_in">list</span>[dep]                                                               <span class="comment"># one or more dependency objects</span></span><br><span class="line">  export_dynamic               : <span class="built_in">bool</span>                                                                    <span class="comment"># when set to true causes the target&#x27;s symbols to be</span></span><br><span class="line">  extra_files                  : <span class="built_in">str</span> | file | custom_tgt | custom_idx                                    <span class="comment"># Not used for the build itself but are shown as source files in IDEs</span></span><br><span class="line">  gnu_symbol_visibility        : <span class="built_in">str</span>                                                                     <span class="comment"># Specifies how symbols should be exported, see</span></span><br><span class="line">  gui_app                      : <span class="built_in">bool</span>                                                                    <span class="comment"># When set to true flags this target as a GUI application</span></span><br><span class="line">  implib                       : <span class="built_in">bool</span> | <span class="built_in">str</span>                                                              <span class="comment"># When set to true, an import library is generated for the</span></span><br><span class="line">  implicit_include_directories : <span class="built_in">bool</span>                                                                    <span class="comment"># Controls whether Meson adds the current source and build directories to the include path</span></span><br><span class="line">  include_directories          : <span class="built_in">list</span>[inc | <span class="built_in">str</span>]                                                         <span class="comment"># one or more objects created with the include_directories() function,</span></span><br><span class="line">  install                      : <span class="built_in">bool</span>                                                                    <span class="comment"># When set to true, this executable should be installed</span></span><br><span class="line">  install_dir                  : <span class="built_in">str</span>                                                                     <span class="comment"># override install directory for this file</span></span><br><span class="line">  install_mode                 : <span class="built_in">list</span>[<span class="built_in">str</span> | <span class="built_in">int</span>]                                                         <span class="comment"># Specify the file mode in symbolic format</span></span><br><span class="line">  install_rpath                : <span class="built_in">str</span>                                                                     <span class="comment"># A string to set the target&#x27;s rpath to after install</span></span><br><span class="line">  install_tag                  : <span class="built_in">str</span>                                                                     <span class="comment"># A string used by the `meson install --tags` command</span></span><br><span class="line">  link_args                    : <span class="built_in">list</span>[<span class="built_in">str</span>]                                                               <span class="comment"># Flags to use during linking</span></span><br><span class="line">  link_depends                 : <span class="built_in">str</span> | file | custom_tgt | custom_idx                                    <span class="comment"># Strings, files, or custom targets the link step depends on</span></span><br><span class="line">  link_language                : <span class="built_in">str</span>                                                                     <span class="comment"># Makes the linker for this target be for the specified language</span></span><br><span class="line">  link_whole                   : <span class="built_in">list</span>[lib | custom_tgt | custom_idx]                                     <span class="comment"># Links all contents of the given static libraries</span></span><br><span class="line">  link_with                    : <span class="built_in">list</span>[lib | custom_tgt | custom_idx]                                     <span class="comment"># One or more shared or static libraries</span></span><br><span class="line">  name_prefix                  : <span class="built_in">str</span> | <span class="built_in">list</span>[void]                                                        <span class="comment"># The string that will be used as the prefix for the</span></span><br><span class="line">  name_suffix                  : <span class="built_in">str</span> | <span class="built_in">list</span>[void]                                                        <span class="comment"># The string that will be used as the extension for the</span></span><br><span class="line">  native                       : <span class="built_in">bool</span>                                                                    <span class="comment"># Controls whether the target is compiled for the build or host machines</span></span><br><span class="line">  objects                      : <span class="built_in">list</span>[extracted_obj | file | <span class="built_in">str</span>]                                        <span class="comment"># List of object files that should be linked in this target</span></span><br><span class="line">  override_options             : <span class="built_in">list</span>[<span class="built_in">str</span>]                                                               <span class="comment"># takes an array of strings in the same format as `project`&#x27;s `default_options`</span></span><br><span class="line">  pie                          : <span class="built_in">bool</span>                                                                    <span class="comment"># Build a position-independent executable</span></span><br><span class="line">  rust_crate_type              : <span class="built_in">str</span>                                                                     <span class="comment"># Set the specific type of rust crate to compile (when compiling rust)</span></span><br><span class="line">  sources                      : <span class="built_in">str</span> | file | custom_tgt | custom_idx | generated_list | structured_src  <span class="comment"># Additional source files</span></span><br><span class="line">  win_subsystem                : <span class="built_in">str</span>                                                                     <span class="comment"># Specifies the subsystem type to use</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>创建一个新的可执行文件。第一个参数指定其名称，其余位置参数定义要使用的输入文件。</p>
<p><strong>示例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">executable(<span class="string">&#x27;dpdk-&#x27;</span> + name,</span><br><span class="line">        sources,</span><br><span class="line">        c_args: cflags,</span><br><span class="line">        link_args: ldflags,</span><br><span class="line">        link_whole: link_libs,</span><br><span class="line">        dependencies: dep_objs,</span><br><span class="line">        include_directories: includes,</span><br><span class="line">        install_rpath: join_paths(get_option(<span class="string">&#x27;prefix&#x27;</span>),</span><br><span class="line">                    driver_install_path),</span><br><span class="line">        install: true)</span><br></pre></td></tr></table></figure>

<h2 id="subdir"><a href="#subdir" class="headerlink" title="subdir()"></a>subdir()</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Enters the specified subdirectory and executes the `meson</span></span><br><span class="line">void subdir(</span><br><span class="line">  <span class="built_in">str</span> dir_name,     <span class="comment"># Directory relative to the current `meson</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Keyword arguments:</span></span><br><span class="line">  if_found : <span class="built_in">list</span>[dep]  <span class="comment"># Only enter the subdir if all dep.found() methods return `true`.</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>进入指定的子目录并执行其中的meson.build文件。完成后，它返回并继续执行此subdir()命令后的行。<br>然后，该文件中定义的变量 meson.build可用于当前构建文件的后续部分以及使用 subdir()。<br>请注意，这意味着meson.build源代码树中的每个文件只能执行一次。</p>
<p><strong>示例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">subdir(<span class="string">&#x27;buildtools&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="install-subdir"><a href="#install-subdir" class="headerlink" title="install_subdir()"></a>install_subdir()</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Installs the entire given subdirectory and its contents from the</span></span><br><span class="line">void install_subdir(</span><br><span class="line">  <span class="built_in">str</span> subdir_name,     <span class="comment"># The sub-directory to install</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Keyword arguments:</span></span><br><span class="line">  exclude_directories : <span class="built_in">list</span>[<span class="built_in">str</span>]        <span class="comment"># A list of directory names that should not be installed</span></span><br><span class="line">  exclude_files       : <span class="built_in">list</span>[<span class="built_in">str</span>]        <span class="comment"># A list of file names that should not be installed</span></span><br><span class="line">  install_dir         : <span class="built_in">str</span>              <span class="comment"># Where to install to</span></span><br><span class="line">  install_mode        : <span class="built_in">list</span>[<span class="built_in">str</span> | <span class="built_in">int</span>]  <span class="comment"># Specify the file mode in symbolic format</span></span><br><span class="line">  install_tag         : <span class="built_in">str</span>              <span class="comment"># A string used by the `meson install --tags` command</span></span><br><span class="line">  strip_directory     : <span class="built_in">bool</span>             <span class="comment"># Install directory contents</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>将整个给定子目录及其内容从源代码树安装到关键字参数指定的位置 install_dir。</p>
<p>（自 0.45.0 起，自 0.60.0 起弃用）如果子目录在源树中不存在，则会在指定位置创建一个空目录。<br>新创建的子目录只能在关键字参数中创建 install_dir。<br>此方法存在许多缺陷，并且从未有意设计为以这种方式工作，请使用install_emptydir()替代。</p>
<p><strong>示例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">install_subdir(<span class="string">&#x27;examples&#x27;</span>,</span><br><span class="line">	install_dir: get_option(<span class="string">&#x27;datadir&#x27;</span>) + <span class="string">&#x27;/dpdk&#x27;</span>,</span><br><span class="line">	exclude_files: ex_file_excludes)</span><br></pre></td></tr></table></figure>


<h2 id="get-option"><a href="#get-option" class="headerlink" title="get_option()"></a>get_option()</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">str</span> | <span class="built_in">int</span> | <span class="built_in">bool</span> | feature | <span class="built_in">list</span>[<span class="built_in">str</span> | <span class="built_in">int</span> | <span class="built_in">bool</span>] get_option(</span><br><span class="line">  <span class="built_in">str</span> option_name,     <span class="comment"># Name of the option to query</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>获取 在位置参数中指定的项目构建选项的值。</p>
<p><strong>示例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># build kernel modules if enabled</span></span><br><span class="line"><span class="keyword">if</span> get_option(<span class="string">&#x27;enable_kmods&#x27;</span>)</span><br><span class="line">	subdir(<span class="string">&#x27;kernel&#x27;</span>)</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>


<h2 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h2><p>要对可迭代对象的所有元素执行操作，请使用foreach 命令。</p>
<p><strong>带有数组的 Foreach</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">progs = [[<span class="string">&#x27;prog1&#x27;</span>, [<span class="string">&#x27;prog1.c&#x27;</span>, <span class="string">&#x27;foo.c&#x27;</span>]],</span><br><span class="line">         [<span class="string">&#x27;prog2&#x27;</span>, [<span class="string">&#x27;prog2.c&#x27;</span>, <span class="string">&#x27;bar.c&#x27;</span>]]]</span><br><span class="line"></span><br><span class="line">foreach p : progs</span><br><span class="line">  exe = executable(p[<span class="number">0</span>], p[<span class="number">1</span>])</span><br><span class="line">  test(p[<span class="number">0</span>], exe)</span><br><span class="line">endforeach</span><br></pre></td></tr></table></figure>

<p><strong>带有字典的 Foreach</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">components = &#123;</span><br><span class="line">  <span class="string">&#x27;foo&#x27;</span>: [<span class="string">&#x27;foo.c&#x27;</span>],</span><br><span class="line">  <span class="string">&#x27;bar&#x27;</span>: [<span class="string">&#x27;bar.c&#x27;</span>],</span><br><span class="line">  <span class="string">&#x27;baz&#x27;</span>: [<span class="string">&#x27;baz.c&#x27;</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># compute a configuration based on system dependencies, custom logic</span></span><br><span class="line">conf = configuration_data()</span><br><span class="line">conf.<span class="built_in">set</span>(<span class="string">&#x27;USE_FOO&#x27;</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Determine the sources to compile</span></span><br><span class="line">sources_to_compile = []</span><br><span class="line">foreach name, sources : components</span><br><span class="line">  <span class="keyword">if</span> conf.get(<span class="string">&#x27;USE_@0@&#x27;</span>.<span class="built_in">format</span>(name.to_upper()), <span class="number">0</span>) == <span class="number">1</span></span><br><span class="line">    sources_to_compile += sources</span><br><span class="line">  endif</span><br><span class="line">endforeach</span><br></pre></td></tr></table></figure>

<p><strong>break_continue</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">items = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;continue&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;break&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">result = []</span><br><span class="line">foreach i : items</span><br><span class="line">  <span class="keyword">if</span> i == <span class="string">&#x27;continue&#x27;</span></span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">  <span class="keyword">elif</span> i == <span class="string">&#x27;break&#x27;</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  endif</span><br><span class="line">  result += i</span><br><span class="line">endforeach</span><br><span class="line"><span class="comment"># result is [&#x27;a&#x27;, &#x27;b&#x27;]</span></span><br></pre></td></tr></table></figure>

<h2 id="message"><a href="#message" class="headerlink" title="message()"></a>message()</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This function prints its argument to stdout</span></span><br><span class="line">void message(</span><br><span class="line">  <span class="built_in">str</span> | <span class="built_in">int</span> | <span class="built_in">bool</span> | <span class="built_in">list</span>[<span class="built_in">str</span> | <span class="built_in">int</span> | <span class="built_in">bool</span>] | <span class="built_in">dict</span>[<span class="built_in">str</span> | <span class="built_in">int</span> | <span class="built_in">bool</span>] text,          <span class="comment"># The message to print</span></span><br><span class="line">  <span class="built_in">str</span> | <span class="built_in">int</span> | <span class="built_in">bool</span> | <span class="built_in">list</span>[<span class="built_in">str</span> | <span class="built_in">int</span> | <span class="built_in">bool</span>] | <span class="built_in">dict</span>[<span class="built_in">str</span> | <span class="built_in">int</span> | <span class="built_in">bool</span>] more_text...,  <span class="comment"># Additional text that will be printed separated by spaces</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>此函数将其参数打印到标准输出。</p>
<p><strong>示例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">message(output_message + <span class="string">&#x27;\n&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="get-variable"><a href="#get-variable" class="headerlink" title="get_variable()"></a>get_variable()</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># This function can be used to dynamically obtain a variable</span></span><br><span class="line"><span class="built_in">any</span> get_variable(</span><br><span class="line">  <span class="built_in">str</span> variable_name,     <span class="comment"># Name of the variable to get</span></span><br><span class="line">  <span class="built_in">any</span> [default],         <span class="comment"># Fallback value to return when the variable does not exist</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>此函数可用于动态获取变量。res = get_variable(varname, fallback)取值varname（必须是字符串）并将该名称的变量存储到res. 如果变量不存在，则将变量fallback存储到 res。如果未指定回退，则尝试读取不存在的变量将导致致命错误。</p>
<p><strong>示例</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">reason = get_variable(lib.underscorify() + <span class="string">&#x27;_disable_reason&#x27;</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>meson</category>
      </categories>
      <tags>
        <tag>meson</tag>
      </tags>
  </entry>
  <entry>
    <title>meson &amp; ninja编译</title>
    <url>/2021/05/23/meson-ninja%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">##安装pip3，有些系统默认没有安装</span></span><br><span class="line">sudo apt install python3-pip</span><br><span class="line">sudo pip3 install meson ninja</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装编译器</span></span><br><span class="line">sudo apt-get install ninja-build</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#构建</span></span><br><span class="line">meson build</span><br><span class="line"></span><br><span class="line"><span class="comment">#编译</span></span><br><span class="line">ninja -C build</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装</span></span><br><span class="line">sudo ninja -C build install</span><br></pre></td></tr></table></figure>

<h2 id="通过Meson指定编译选项"><a href="#通过Meson指定编译选项" class="headerlink" title="通过Meson指定编译选项"></a>通过Meson指定编译选项</h2><p>通过<code>meson configure</code>命令查看<code>meson</code>内置的选项、默认值及可选值。<br>项目可以通过<code>meson_options.txt</code>来增加项目特有的选项。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ meson configure</span><br><span class="line">...</span><br><span class="line">Project options:</span><br><span class="line">  Option  Default Value  Possible Values            Description</span><br><span class="line">  gtk_doc auto           [enabled, disabled, auto]  Generate API documentation with gtk-doc</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>在生成编译配置时，可以通过<code>-D</code>指定编译选项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ meson builddir -Dprefix=/usr -Dgtk_doc=disabled -Dtests=disabled</span><br><span class="line">$ <span class="built_in">cd</span> builddir &amp;&amp; ninja -j8</span><br><span class="line">$ meson install</span><br></pre></td></tr></table></figure>

<p>可以在源码根目录通过<code>configure</code>更新编译选项，再执行<code>ninja</code>重新编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ meson configure builddir -Dprefix=/home/dev/tmp</span><br><span class="line">$ <span class="built_in">cd</span> builddir &amp;&amp; ninja -j8</span><br><span class="line">$ meson install</span><br></pre></td></tr></table></figure>

<h2 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h2><p>meson.build:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">project(<span class="string">&#x27;tutorial&#x27;</span>, <span class="string">&#x27;cpp&#x27;</span>)</span><br><span class="line">executable(<span class="string">&#x27;demo&#x27;</span>, <span class="string">&#x27;test.cpp&#x27;</span>, install:<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p>test.cpp:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译脚本build.sh：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">rm</span> -rf build</span><br><span class="line">meson --prefix=/home/rma/mr_work/test/cpp_test/meson_test build</span><br><span class="line">ninja -C build</span><br><span class="line">ninja -C build install</span><br></pre></td></tr></table></figure>

<p>执行结果：<br><img src="b9b50c38d1df8082d02e05be089948c464392c40c1e335812ac63d8ec171f18d.png" alt="图 1">  </p>
<h2 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h2><p>交叉编译文件arm.txt</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[binaries]</span><br><span class="line">c = <span class="string">&#x27;aarch64-none-linux-gnu-gcc&#x27;</span></span><br><span class="line">cpp = <span class="string">&#x27;aarch64-none-linux-gnu-g++&#x27;</span></span><br><span class="line">ar = <span class="string">&#x27;aarch64-none-linux-gnu-ar&#x27;</span></span><br><span class="line">strip = <span class="string">&#x27;aarch64-none-linux-gnu-strip&#x27;</span></span><br><span class="line"></span><br><span class="line">[host_machine]</span><br><span class="line">system = <span class="string">&#x27;linux&#x27;</span></span><br><span class="line">cpu_family = <span class="string">&#x27;aarch64&#x27;</span></span><br><span class="line">cpu = <span class="string">&#x27;aarch64&#x27;</span></span><br><span class="line">endian = <span class="string">&#x27;little&#x27;</span></span><br></pre></td></tr></table></figure>

<p>通过<code>--cross-file</code>指定交叉编译文件<br>编译脚本build.sh：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">rm</span> -rf build</span><br><span class="line"><span class="comment"># meson --prefix=/home/rma/mr_work/test/cpp_test/meson_test build </span></span><br><span class="line">meson build --prefix=/home/rma/mr_work/test/cpp_test/meson_test --cross-file arm.txt</span><br><span class="line">ninja -C build</span><br><span class="line">ninja -C build install</span><br></pre></td></tr></table></figure>

<p>编译，可以看到Build machine为x86_64，而Host machine和Target machine为aarch64<br><img src="c9954f6ae3b93cde2143c526b54c30328ef80743fff0a011c8c1fbabe623c31f.png" alt="图 2">  </p>
<p>查看可执行文件的架构<br><img src="eb73e9f80f4fb5f00e9e07ac715ee2ef2ab6b1b8a55cbed7567e799260da9bbf.png" alt="图 3">  </p>
<p>在arm环境运行结果<br><img src="4c7218c645cb807c22406d933da61e03f238c7038b9498d0dfacbf7c938bd614.png" alt="图 4"><br><img src="1e439e96aefbd7e765bfbb6388de5d0da1e597d8c81ae5cc483aedfd70f6a01d.png" alt="图 5">  </p>
]]></content>
      <categories>
        <category>meson</category>
      </categories>
      <tags>
        <tag>meson</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake语法</title>
    <url>/2021/05/22/cmake%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h2 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h2><ul>
<li>变量使用<code>$&#123;&#125;</code>方式取值, 但是在 <code>IF</code> 控制语句中是直接使用变量名</li>
<li><code>指令(参数1 参数2 …)</code>,参数使用括弧括起,参数之间使用空格或分号分开。</li>
<li>指令是大小写无关的,参数和变量是大小写相关的。但,<strong>推荐你全部使用大写指令</strong>。</li>
<li>cmake 并不支持 <code>make distclean</code></li>
<li>强烈推荐的是外部构建<span id="more"></span></li>
</ul>
<h2 id="ADD-DEFINITIONS"><a href="#ADD-DEFINITIONS" class="headerlink" title="ADD_DEFINITIONS"></a>ADD_DEFINITIONS</h2><p>向 C/C++编译器添加-D 定义,比如:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADD_DEFINITIONS(-DENABLE_DEBUG -DABC)#,参数之间用空格分割。</span><br></pre></td></tr></table></figure>
<p>如果你的代码中定义了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ENABLE_DEBUG</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这个代码块就会生效。如果要添加其他的编译器开关,可以通过 <code>CMAKE_C_FLAGS</code> 变量和 <code>CMAKE_CXX_FLAGS</code> 变量设置。</p>
<h2 id="ADD-DEPENDENCIES"><a href="#ADD-DEPENDENCIES" class="headerlink" title="ADD_DEPENDENCIES"></a>ADD_DEPENDENCIES</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADD_DEPENDENCIES(target-name depend-target1 depend-target2 ...)</span><br></pre></td></tr></table></figure>
<p>定义 target 依赖的其他 target,确保在编译本 target 之前,其他的 target 已经被构建。</p>
<h2 id="ADD-EXECUTABLE"><a href="#ADD-EXECUTABLE" class="headerlink" title="ADD_EXECUTABLE"></a>ADD_EXECUTABLE</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADD_EXECUTABLE(hello $&#123;SRC_LIST&#125;)</span><br></pre></td></tr></table></figure>
<p>编译成可执行文件</p>
<h2 id="ADD-LIBRARY"><a href="#ADD-LIBRARY" class="headerlink" title="ADD_LIBRARY"></a>ADD_LIBRARY</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADD_LIBRARY(libname</span><br><span class="line">	[SHARED|STATIC|MODULE]</span><br><span class="line">	[EXCLUDE_FROM_ALL]</span><br><span class="line">	source1 source2 ... sourceN)</span><br></pre></td></tr></table></figure>
<p>类型有三种:<br><code>SHARED</code>: 动态库<br><code>STATIC</code>: 静态库<br><code>MODULE</code>: 在使用 dyld 的系统有效,如果不支持 dyld,则被当作 SHARED 对待。</p>
<p><code>EXCLUDE_FROM_ALL</code> 参数的意思是这个库不会被默认构建,除非有其他的组件依赖或者手工构建。</p>
<p><code>libname</code>不需要写全 <code>libhello.so</code>,只需要填写 <code>hello</code> 即可,cmake 系统会自动为你生成<code>libhello.X</code></p>
<p>同样使用上面的指令,我们在支持动态库的基础上再为工程添加一个静态库,按照一般的习惯,静态库名字跟动态库名字应该是一致的,只不过后缀是 .a 罢了。用以上方法同时构建动态库和静态库会发现静态库根本没有被构建,只生成了一个动态库。这种结果显示不是我们想要的,我们需要的是名字相同的静态库和动态库,因为 target 名称是唯一的,所以,我们肯定不能通过 ADD_LIBRARY 指令来实现了。这时候我们需要用到另外一个指令:<code>SET_TARGET_PROPERTIES</code></p>
<h2 id="ADD-SUBDIRECTORY"><a href="#ADD-SUBDIRECTORY" class="headerlink" title="ADD_SUBDIRECTORY"></a>ADD_SUBDIRECTORY</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL])</span><br></pre></td></tr></table></figure>
<p>这个指令用于向当前工程添加存放源文件的子目录,并可以指定中间二进制和目标二进制存放的位置。<br><code>EXCLUDE_FROM_ALL</code> 参数的含义是将这个目录从编译过程中排除,比如,工程 的 example,可能就需要工程构建完成后,再进入 example 目录单独进行构建(当然,你也可以通过定义依赖来解决此类问题)。</p>
<p>例如：<code>ADD_SUBDIRECTORY(src bin)</code> 定义了将 src 子目录加入工程,并指定编译输出(包含编译中间结果)路径为 bin 目录。如果不进行 bin 目录的指定,那么编译结果(包括中间结果)都将存放在 build/src 目录(这个目录跟原有的 src 目录对应),指定 bin 目录后,相当于在编译时将 src 重命名为 bin,所有的中间结果和目标二进制都将存放在 bin 目录。</p>
<p>可以通过 <code>SET</code> 指令重新定义 <code>EXECUTABLE_OUTPUT_PATH</code> 和 <code>LIBRARY_OUTPUT_PATH</code> 变量来指定最终的目标二进制的位置(指最终生成的 hello 或者最终的共享库,不包含编译生成的中间文件)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SET(EXECUTABLE_OUTPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;/bin)</span><br><span class="line">SET(LIBRARY_OUTPUT_PATH $&#123;PROJECT_BINARY_DIR&#125;/lib)</span><br></pre></td></tr></table></figure>
<p><code>PROJECT_BINARY_DIR</code> 变量指的编译发生的当前目录,如果是<strong>内部编译</strong>,就相当于 <code>PROJECT_SOURCE_DIR</code> 也就是工程代码所在目录,<br>如果是外部编译,指的是外部编译所在目录,也就是本例中的 <code>build</code> 目录。所以,上面两个指令分别定义了:可执行二进制的输出路径为 <code>build/bin</code> 和库的输出路径为 <code>build/lib</code>.</p>
<h2 id="ADD-TEST"><a href="#ADD-TEST" class="headerlink" title="ADD_TEST"></a>ADD_TEST</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADD_TEST(testname Exename arg1 arg2 ...)</span><br></pre></td></tr></table></figure>
<p>testname 是自定义的 test 名称,<br>Exename 可以是构建的目标文件也可以是外部脚本等等。后面连接传递给可执行文件的参数。<br>如果没有在同一个 CMakeLists.txt 中打开 <code>ENABLE_TESTING()</code>指令,任何 <code>ADD_TEST</code> 都是无效的。</p>
<h2 id="AUX-SOURCE-DIRECTORY"><a href="#AUX-SOURCE-DIRECTORY" class="headerlink" title="AUX_SOURCE_DIRECTORY"></a>AUX_SOURCE_DIRECTORY</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">AUX_SOURCE_DIRECTORY(dir VARIABLE)</span><br></pre></td></tr></table></figure>
<p>作用是发现一个目录下所有的源代码文件并将列表存储在一个变量中,这个指令临时被用来 自动构建源文件列表。因为目前 cmake 还不能自动发现新添加的源文件。<br>比如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">AUX_SOURCE_DIRECTORY(. SRC_LIST)</span><br><span class="line">ADD_EXECUTABLE(main $&#123;SRC_LIST&#125;)</span><br></pre></td></tr></table></figure>
<p>你也可以通过后面提到的 <code>FOREACH</code> 指令来处理这个 LIST</p>
<h2 id="CMAKE-MINIMUM-REQUIRED"><a href="#CMAKE-MINIMUM-REQUIRED" class="headerlink" title="CMAKE_MINIMUM_REQUIRED"></a>CMAKE_MINIMUM_REQUIRED</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CMAKE_MINIMUM_REQUIRED(VERSION versionNumber [FATAL_ERROR])</span><br></pre></td></tr></table></figure>
<p>如果 cmake 版本小于设置版本,则出现严重错误,整个过程中止。</p>
<h2 id="ENABLE-TESTING"><a href="#ENABLE-TESTING" class="headerlink" title="ENABLE_TESTING"></a>ENABLE_TESTING</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ENABLE_TESTING()</span><br></pre></td></tr></table></figure>
<p>指令用来控制 Makefile 是否构建 test 目标,涉及工程所有目录。语法很简单,没有任何参数,一般情况这个指令放在工程的主 CMakeLists.txt 中.</p>
<h2 id="EXEC-PROGRAM"><a href="#EXEC-PROGRAM" class="headerlink" title="EXEC_PROGRAM"></a>EXEC_PROGRAM</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXEC_PROGRAM(Executable [directory in which to run]</span><br><span class="line">	[ARGS &lt;arguments to executable&gt;]</span><br><span class="line">	[OUTPUT_VARIABLE &lt;var&gt;]</span><br><span class="line">	[RETURN_VALUE &lt;var&gt;])</span><br></pre></td></tr></table></figure>
<p>在 CMakeLists.txt 处理过程中执行命令,并不会在生成的 Makefile 中执行。<br>用于在指定的目录运行某个程序,通过 <code>ARGS</code> 添加参数,如果要获取输出和返回值,可通过 <code>OUTPUT_VARIABLE</code> 和 <code>RETURN_VALUE</code> 分别定义两个变量。<br>这个指令可以帮助你在 CMakeLists.txt 处理过程中支持任何命令,比如根据系统情况去修改代码文件等等。</p>
<p>举个简单的例子,我们要在 src 目录执行 ls 命令,并把结果和返回值存下来。可以直接在 src/CMakeLists.txt 中添加:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXEC_PROGRAM(ls ARGS <span class="string">&quot;*.c&quot;</span> OUTPUT_VARIABLE LS_OUTPUT RETURN_VALUE</span><br><span class="line">LS_RVALUE)</span><br><span class="line">IF(not LS_RVALUE)</span><br><span class="line">MESSAGE(STATUS <span class="string">&quot;ls result: &quot;</span> $&#123;LS_OUTPUT&#125;)</span><br><span class="line">ENDIF(not LS_RVALUE)</span><br></pre></td></tr></table></figure>
<p>在 cmake 生成 Makefile 的过程中,就会执行 ls 命令,如果返回 0,则说明成功执行,那么就输出 ls *.c 的结果。关于 IF 语句,后面的控制指令会提到。</p>
<h2 id="FILE"><a href="#FILE" class="headerlink" title="FILE"></a>FILE</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FILE(WRITE filename <span class="string">&quot;message to write&quot;</span>... )</span><br><span class="line">FILE(APPEND filename <span class="string">&quot;message to write&quot;</span>... )</span><br><span class="line">FILE(READ filename variable)</span><br><span class="line">FILE(GLOB variable [RELATIVE path] [globbing expressions]...)</span><br><span class="line">FILE(GLOB_RECURSE variable [RELATIVE path] [globbing expressions]...)</span><br><span class="line">FILE(REMOVE [directory]...)</span><br><span class="line">FILE(REMOVE_RECURSE [directory]...)</span><br><span class="line">FILE(MAKE_DIRECTORY [directory]...)</span><br><span class="line">FILE(RELATIVE_PATH variable directory file)</span><br><span class="line">FILE(TO_CMAKE_PATH path result)</span><br><span class="line">FILE(TO_NATIVE_PATH path result)</span><br></pre></td></tr></table></figure>
<p>文件操作指令</p>
<h2 id="FIND"><a href="#FIND" class="headerlink" title="FIND"></a>FIND</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FIND_FILE(&lt;VAR&gt; name1 path1 path2 ...)</span><br><span class="line">## VAR 变量代表找到的文件全路径,包含文件名</span><br><span class="line"></span><br><span class="line">FIND_LIBRARY(&lt;VAR&gt; name1 path1 path2 ...)</span><br><span class="line">## VAR 变量表示找到的库全路径,包含库文件名</span><br><span class="line"></span><br><span class="line">FIND_PATH(&lt;VAR&gt; name1 path1 path2 ...)</span><br><span class="line">## VAR 变量代表包含这个文件的路径。</span><br><span class="line"></span><br><span class="line">FIND_PROGRAM(&lt;VAR&gt; name1 path1 path2 ...)</span><br><span class="line">## VAR 变量代表包含这个程序的全路径。</span><br><span class="line"></span><br><span class="line">FIND_PACKAGE(&lt;name&gt; [major.minor] [QUIET] [NO_MODULE]</span><br><span class="line">	[[REQUIRED|COMPONENTS] [componets...]])</span><br><span class="line">## 用来调用预定义在 CMAKE_MODULE_PATH 下的 Find&lt;name&gt;.cmake 模块,你也可以自己定义 Find&lt;name&gt;模块,通过 SET(CMAKE_MODULE_PATH dir)将其放入工程的某个目录中供工程使用,我们在后面的章节会详细介绍 FIND_PACKAGE 的使用方法和 Find 模块的编写。</span><br></pre></td></tr></table></figure>

<h2 id="GET-TARGET-PROPERTY"><a href="#GET-TARGET-PROPERTY" class="headerlink" title="GET_TARGET_PROPERTY"></a>GET_TARGET_PROPERTY</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GET_TARGET_PROPERTY(VAR target property)</span><br></pre></td></tr></table></figure>

<h2 id="INCLUDE"><a href="#INCLUDE" class="headerlink" title="INCLUDE"></a>INCLUDE</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">INCLUDE(file1 [OPTIONAL])</span><br><span class="line">INCLUDE(module [OPTIONAL])</span><br></pre></td></tr></table></figure>
<p>OPTIONAL 参数的作用是文件不存在也不会产生错误。</p>
<p>用来载入 CMakeLists.txt 文件,也用于载入预定义的 cmake 模块。你可以指定载入一个文件,如果定义的是一个模块,那么将在 CMAKE_MODULE_PATH 中搜索这个模块并载入。载入的内容将在处理到 INCLUDE 语句是直接执行。</p>
<h2 id="INCLUDE-DIRECTORIES"><a href="#INCLUDE-DIRECTORIES" class="headerlink" title="INCLUDE_DIRECTORIES"></a>INCLUDE_DIRECTORIES</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">INCLUDE_DIRECTORIES([AFTER|BEFORE] [SYSTEM] dir1 dir2 ...)</span><br></pre></td></tr></table></figure>
<p>这条指令可以用来向工程添加多个特定的头文件搜索路径,路径之间用空格分割,如果路径中包含了空格,可以使用双引号将它括起来,默认的行为是追加到当前的头文件搜索路径的后面,你可以通过两种方式来进行控制搜索路径添加的方式:<br>CMAKE_INCLUDE_DIRECTORIES_BEFORE,通过 SET 这个 cmake 变量为 on,可以将添加的头文件搜索路径放在已有路径的前面。<br>通过 AFTER 或者 BEFORE 参数,也可以控制是追加还是置前。</p>
<h2 id="INSTALL"><a href="#INSTALL" class="headerlink" title="INSTALL"></a>INSTALL</h2><p>目标文件的安装:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">INSTALL(TARGETS targets...</span><br><span class="line">        [[ARCHIVE|LIBRARY|RUNTIME]</span><br><span class="line">		[DESTINATION &lt;dir&gt;]</span><br><span class="line">		[PERMISSIONS permissions...]</span><br><span class="line">		[CONFIGURATIONS [Debug|Release|...]]</span><br><span class="line">		[COMPONENT &lt;component&gt;]</span><br><span class="line">		[OPTIONAL]</span><br><span class="line">		] [...])</span><br></pre></td></tr></table></figure>
<p>参数中的 TARGETS 后面跟的就是我们通过 <code>ADD_EXECUTABLE</code> 或者 <code>ADD_LIBRARY</code> 定义的目标文件,可能是可执行二进制、动态库、静态库。<br><code>ARCHIVE</code> 特指静态库,<code>LIBRARY</code> 特指动态库,<code>RUNTIME</code> 特指可执行目标二进制。</p>
<p>DESTINATION 定义了安装的路径,如果路径<code>以/开头</code>,那么指的是绝对路径,这时候 <code>CMAKE_INSTALL_PREFIX</code> 其实就无效了。<br>如果是相对路径,即不要以/开头,那么安装后的路径就是 <code>$&#123;CMAKE_INSTALL_PREFIX&#125;/&lt;DESTINATION 定义的路径&gt;</code></p>
<p>举个简单的例子:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">INSTALL(TARGETS myrun mylib mystaticlib</span><br><span class="line">	RUNTIME DESTINATION bin</span><br><span class="line">	LIBRARY DESTINATION lib</span><br><span class="line">	ARCHIVE DESTINATION libstatic</span><br><span class="line">	)</span><br></pre></td></tr></table></figure>
<p>上面的例子会将:<br>可执行二进制 myrun 安装到<code>$&#123;CMAKE_INSTALL_PREFIX&#125;/bin</code> 目录<br>动态库 libmylib 安装到<code>$&#123;CMAKE_INSTALL_PREFIX&#125;/lib</code> 目录<br>静态库 libmystaticlib 安装到<code>$&#123;CMAKE_INSTALL_PREFIX&#125;/libstatic</code> 目录<br>特别注意的是你不需要关心 TARGETS 具体生成的路径,只需要写上 TARGETS 名称就可以了。<br>普通文件的安装:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">INSTALL(FILES files... DESTINATION &lt;dir&gt;</span><br><span class="line">	[PERMISSIONS permissions...]</span><br><span class="line">	[CONFIGURATIONS [Debug|Release|...]]</span><br><span class="line">	[COMPONENT &lt;component&gt;]</span><br><span class="line">	[RENAME &lt;name&gt;] [OPTIONAL])</span><br></pre></td></tr></table></figure>
<p>如果默认不定义权限 <code>PERMISSIONS</code>,安装后的权限为: <code>OWNER_WRITE</code>, <code>OWNER_READ</code>,<code>GROUP_READ</code>,和 <code>WORLD_READ</code>,即 <code>644</code> 权限。</p>
<p>非目标文件的可执行程序安装(比如脚本之类):</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">INSTALL(PROGRAMS files... DESTINATION &lt;dir&gt;</span><br><span class="line">	[PERMISSIONS permissions...]</span><br><span class="line">	[CONFIGURATIONS [Debug|Release|...]]</span><br><span class="line">	[COMPONENT &lt;component&gt;]</span><br><span class="line">	[RENAME &lt;name&gt;] [OPTIONAL])</span><br></pre></td></tr></table></figure>
<p>跟上面的 <code>FILES</code> 指令使用方法一样,唯一的不同是安装后权限为: <code>OWNER_EXECUTE</code>, <code>GROUP_EXECUTE</code>, 和 <code>WORLD_EXECUTE</code>,即 <code>755</code> 权限</p>
<p>目录的安装:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">INSTALL(DIRECTORY dirs... DESTINATION &lt;dir&gt;</span><br><span class="line">	[FILE_PERMISSIONS permissions...]</span><br><span class="line">	[DIRECTORY_PERMISSIONS permissions...]</span><br><span class="line">	[USE_SOURCE_PERMISSIONS]</span><br><span class="line">	[CONFIGURATIONS [Debug|Release|...]]</span><br><span class="line">	[COMPONENT &lt;component&gt;]</span><br><span class="line">	[[PATTERN &lt;pattern&gt; | REGEX &lt;regex&gt;]</span><br><span class="line">	[EXCLUDE] [PERMISSIONS permissions...]] [...])</span><br></pre></td></tr></table></figure>
<p>这里主要介绍其中的 <code>DIRECTORY</code>、<code>PATTERN</code> 以及 <code>PERMISSIONS</code> 参数。</p>
<p><code>DIRECTORY</code> 后面连接的是所在 Source 目录的相对路径;<br>注意:abc 和 abc/有很大的区别。如果目录名不以/结尾,那么这个目录将被安装为目标路径下的 abc,如果目录名以/结尾,代表将这个目录中的内容安装到目标路径,但不包括这个目录本身。<br><code>PATTERN</code> 用于使用正则表达式进行过滤,<code>PERMISSIONS</code> 用于指定 PATTERN 过滤后的文件权限。</p>
<h2 id="LINK-DIRECTORIES"><a href="#LINK-DIRECTORIES" class="headerlink" title="LINK_DIRECTORIES"></a>LINK_DIRECTORIES</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LINK_DIRECTORIES(directory1 directory2 ...)</span><br></pre></td></tr></table></figure>
<p>这个指令非常简单,添加非标准的共享库搜索路径,比如,在工程内部同时存在共享库和可执行二进制,在编译时就需要指定一下这些共享库的路径。</p>
<h2 id="MESSAGE"><a href="#MESSAGE" class="headerlink" title="MESSAGE"></a>MESSAGE</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MESSAGE([SEND_ERROR | STATUS | FATAL_ERROR] <span class="string">&quot;message to display&quot;</span> ...)</span><br></pre></td></tr></table></figure>
<p>这个指令用于向终端输出用户定义的信息,包含了三种类型:<br><code>SEND_ERROR</code>,产生错误,生成过程被跳过。<br><code>SATUS</code> ,输出前缀为 — 的信息。<br><code>FATAL_ERROR</code>,立即终止所有 cmake 过程.</p>
<h2 id="PROJECT"><a href="#PROJECT" class="headerlink" title="PROJECT"></a>PROJECT</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PROJECT(projectname [CXX] [C] [Java])</span><br></pre></td></tr></table></figure>
<p>可以用这个指令定义工程名称,并可指定工程支持的语言,支持的语言列表是可以忽略的,默认情况表示支持所有语言。</p>
<p>cmake 系统也帮助我们预定义了 PROJECT_BINARY_DIR 和 PROJECT_SOURCE_DIR 变量</p>
<h2 id="SET"><a href="#SET" class="headerlink" title="SET"></a>SET</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]])</span><br></pre></td></tr></table></figure>
<p>比如我们用到的是 <code>SET(SRC_LIST main.c)</code>,如果有多个源文件,也可以定义成: <code>SET(SRC_LIST main.c t1.c t2.c)</code>。</p>
<h2 id="SET-TARGET-PROPERTIES"><a href="#SET-TARGET-PROPERTIES" class="headerlink" title="SET_TARGET_PROPERTIES"></a>SET_TARGET_PROPERTIES</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SET_TARGET_PROPERTIES(target1 target2 ...</span><br><span class="line">	PROPERTIES prop1 value1 prop2 value2 ...)</span><br></pre></td></tr></table></figure>
<p>这条指令可以用来设置输出的名称,对于动态库,还可以用来指定动态库版本和 API 版本。</p>
<p>以下是同时生成动态、静态库的示例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ADD_LIBRARY(hello SHARED $&#123;LIBHELLO_SRC&#125;)</span><br><span class="line">ADD_LIBRARY(hello_static STATIC $&#123;LIBHELLO_SRC&#125;)</span><br><span class="line">SET_TARGET_PROPERTIES(hello_static PROPERTIES OUTPUT_NAME <span class="string">&quot;hello&quot;</span>)</span><br><span class="line">GET_TARGET_PROPERTY(OUTPUT_VALUE hello_static OUTPUT_NAME)</span><br><span class="line">SET_TARGET_PROPERTIES(hello PROPERTIES CLEAN_DIRECT_OUTPUT <span class="number">1</span>)</span><br><span class="line">SET_TARGET_PROPERTIES(hello_static PROPERTIES CLEAN_DIRECT_OUTPUT <span class="number">1</span>)</span><br></pre></td></tr></table></figure>


<h2 id="TARGET-LINK-LIBRARIES"><a href="#TARGET-LINK-LIBRARIES" class="headerlink" title="TARGET_LINK_LIBRARIES"></a>TARGET_LINK_LIBRARIES</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TARGET_LINK_LIBRARIES(target library1</span><br><span class="line">	&lt;debug | optimized&gt; library2</span><br><span class="line">		...)</span><br></pre></td></tr></table></figure>
<p>这个指令可以用来为 <code>target</code> 添加需要链接的共享库,本例中是一个可执行文件,但是同样可以用于为自己编写的共享库添加共享库链接。</p>
<h2 id="动态库版本号"><a href="#动态库版本号" class="headerlink" title="动态库版本号"></a>动态库版本号</h2><p>按照规则,动态库是应该包含一个版本号的,我们可以看一下系统的动态库,一般情况是:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">libhello.so<span class="number">.1</span><span class="number">.2</span></span><br><span class="line">libhello.so -&gt;libhello.so<span class="number">.1</span></span><br><span class="line">libhello.so<span class="number">.1</span>-&gt;libhello.so<span class="number">.1</span><span class="number">.2</span></span><br></pre></td></tr></table></figure>

<p>为了实现动态库版本号,我们仍然需要使用 <code>SET_TARGET_PROPERTIES</code> 指令。</p>
<p>具体使用方法如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SET_TARGET_PROPERTIES(hello PROPERTIES VERSION <span class="number">1.2</span> SOVERSION <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><code>VERSION</code> 指代动态库版本,<code>SOVERSION</code> 指代 API 版本。</p>
<p>将上述指令加入 <code>lib/CMakeLists.txt</code> 中,重新构建看看结果。<br>在 <code>build/lib</code> 目录会生成:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">libhello.so<span class="number">.1</span><span class="number">.2</span></span><br><span class="line">libhello.so<span class="number">.1</span>-&gt;libhello.so<span class="number">.1</span><span class="number">.2</span></span><br><span class="line">libhello.so -&gt;libhello.so<span class="number">.1</span></span><br></pre></td></tr></table></figure>

<h2 id="cmake-常用变量"><a href="#cmake-常用变量" class="headerlink" title="cmake 常用变量"></a>cmake 常用变量</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CMAKE_BINARY_DIR</span><br><span class="line">PROJECT_BINARY_DIR</span><br><span class="line">&lt;projectname&gt;_BINARY_DIR</span><br></pre></td></tr></table></figure>
<p>这三个变量指代的内容是一致的,如果是 <code>in source</code> 编译,指得就是<strong>工程顶层目录</strong>,如果是 <code>out-of-source</code> 编译,指的是<strong>工程编译发生的目录</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CMAKE_SOURCE_DIR</span><br><span class="line">PROJECT_SOURCE_DIR</span><br><span class="line">&lt;projectname&gt;_SOURCE_DIR</span><br></pre></td></tr></table></figure>
<p>这三个变量指代的内容是一致的,不论采用何种编译方式,都是<strong>工程顶层目录</strong>。也就是在 <code>in source</code> 编译时,他跟 <code>CMAKE_BINARY_DIR</code> 等变量一致。</p>
<p><code>CMAKE_CURRENT_SOURCE_DIR</code><br>指的是当前处理的 CMakeLists.txt 所在的路径。</p>
<p><code>CMAKE_CURRRENT_BINARY_DIR</code><br>如果是 in-source 编译,它跟 <code>CMAKE_CURRENT_SOURCE_DIR</code> 一致,如果是 out-of-source 编译,他指的是 target 编译目录。<br>使用我们上面提到的 <code>ADD_SUBDIRECTORY(src bin)</code>可以更改这个变量的值。<br>使用 <code>SET(EXECUTABLE_OUTPUT_PATH &lt;新路径&gt;)</code>并不会对这个变量造成影响,它仅仅修改了最终目标文件存放的路径。</p>
<p><code>CMAKE_CURRENT_LIST_FILE</code><br>输出调用这个变量的 CMakeLists.txt 的完整路径</p>
<p><code>CMAKE_CURRENT_LIST_LINE</code><br>输出这个变量所在的行</p>
<p><code>CMAKE_MODULE_PATH</code><br>这个变量用来定义自己的 cmake 模块所在的路径。如果你的工程比较复杂,有可能会自己编写一些 cmake 模块,这些 cmake 模块是随你的工程发布的,为了让 cmake 在处理 CMakeLists.txt 时找到这些模块,你需要通过 SET 指令,将自己的 cmake 模块路径设置一下。 比如 SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake) 这时候你就可以通过 INCLUDE 指令来调用自己的模块了。</p>
<p><code>EXECUTABLE_OUTPUT_PATH LIBRARY_OUTPUT_PATH</code><br>分别用来重新定义最终结果的存放目录,前面我们已经提到了这两个变量。</p>
<p><code>PROJECT_NAME</code><br>返回通过 PROJECT 指令定义的项目名称。</p>
<p><code>CMAKE_C_FLAGS</code><br>设置 C 编译选项,也可以通过指令 <code>ADD_DEFINITIONS()</code>添加。</p>
<p><code>CMAKE_CXX_FLAGS</code><br>设置 C++编译选项,也可以通过指令 <code>ADD_DEFINITIONS()</code>添加。</p>
<h2 id="cmake-调用环境变量"><a href="#cmake-调用环境变量" class="headerlink" title="cmake 调用环境变量"></a>cmake 调用环境变量</h2><p>使用<code>$ENV&#123;NAME&#125;</code>指令就可以调用系统的环境变量了。<br>比如 <code>MESSAGE(STATUS “HOME dir: $ENV&#123;HOME&#125;”)</code><br>设置环境变量的方式是:<br><code>SET(ENV&#123;变量名&#125; 值)</code></p>
<h2 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h2><p><code>CMAKE_MAJOR_VERSION</code>,CMAKE 主版本号,比如 2.4.6 中的 2<br><code>CMAKE_MINOR_VERSION</code>,CMAKE 次版本号,比如 2.4.6 中的 4<br><code>CMAKE_PATCH_VERSION</code>,CMAKE 补丁等级,比如 2.4.6 中的 6<br><code>CMAKE_SYSTEM</code>,系统名称,比如 Linux-2.6.22<br><code>CMAKE_SYSTEM_NAME</code>,不包含版本的系统名,比如 Linux<br><code>CMAKE_SYSTEM_VERSION</code>,系统版本,比如 2.6.22<br><code>CMAKE_SYSTEM_PROCESSOR</code>,处理器名称,比如 i686.<br><code>UNIX</code>,在所有的类 UNIX 平台为 TRUE,包括 OS X 和 cygwin<br><code>WIN32</code>,在所有的 win32 平台为 TRUE,包括 cygwin</p>
]]></content>
      <categories>
        <category>cmake</category>
      </categories>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake使用cpack生成安装包</title>
    <url>/2021/05/21/cmake%E4%BD%BF%E7%94%A8cpack%E7%94%9F%E6%88%90%E5%AE%89%E8%A3%85%E5%8C%85/</url>
    <content><![CDATA[<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>假如想将我们的项目分发给其他人，以便他们可以安装并使用它，可以在根目录。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># build a CPack driven installer package</span></span><br><span class="line">include (InstallRequiredSystemLibraries)</span><br><span class="line"><span class="built_in">set</span> (CPACK_RESOURCE_FILE_LICENSE  </span><br><span class="line">     <span class="string">&quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/License.txt&quot;</span>)</span><br><span class="line"><span class="built_in">set</span> (CPACK_PACKAGE_VERSION_MAJOR <span class="string">&quot;$&#123;Tutorial_VERSION_MAJOR&#125;&quot;</span>)</span><br><span class="line"><span class="built_in">set</span> (CPACK_PACKAGE_VERSION_MINOR <span class="string">&quot;$&#123;Tutorial_VERSION_MINOR&#125;&quot;</span>)</span><br><span class="line">include (CPack)</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="打包安装包"><a href="#打包安装包" class="headerlink" title="打包安装包"></a>打包安装包</h2><p>cpack –config CPackConfig.cmake<br><img src="5c97302c72d2166f1c5e3025d5d7c416e910e6abe8a38b1d5a22f0330126e681.png" alt="图 1"><br>目录文件如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tar -tf Tutorial-1.0.1-Linux.tar.gz</span></span><br><span class="line">Tutorial-1.0.1-Linux/include/</span><br><span class="line">Tutorial-1.0.1-Linux/include/TutorialConfig.h</span><br><span class="line">Tutorial-1.0.1-Linux/include/MathFunctions.h</span><br><span class="line">Tutorial-1.0.1-Linux/bin/</span><br><span class="line">Tutorial-1.0.1-Linux/bin/Tutorial</span><br><span class="line">Tutorial-1.0.1-Linux/bin/libMathFunctions.a</span><br></pre></td></tr></table></figure>
<h2 id="打包源码"><a href="#打包源码" class="headerlink" title="打包源码"></a>打包源码</h2><p>cpack –config CPackConfig.cmake<br><img src="d4845a21d6419a5009c665e0e5d7e1f0da3b73d9c3cca1eccbe36f9ecbae511a.png" alt="图 2">  </p>
<p>目录文件如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tar -tf Tutorial-1.0.1-Source.tar.gz </span></span><br><span class="line">Tutorial-1.0.1-Source/CMakeLists.txt</span><br><span class="line">Tutorial-1.0.1-Source/TutorialConfig.h.in</span><br><span class="line">Tutorial-1.0.1-Source/tutorial.cxx</span><br><span class="line">Tutorial-1.0.1-Source/MathFunctions/</span><br><span class="line">Tutorial-1.0.1-Source/MathFunctions/MakeTable.cxx</span><br><span class="line">Tutorial-1.0.1-Source/MathFunctions/mysqrt.cxx</span><br><span class="line">Tutorial-1.0.1-Source/MathFunctions/CMakeLists.txt</span><br><span class="line">...</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cmake</category>
      </categories>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake安装、测试、系统自检</title>
    <url>/2021/05/20/cmake%E5%AE%89%E8%A3%85%E3%80%81%E6%B5%8B%E8%AF%95%E3%80%81%E7%B3%BB%E7%BB%9F%E8%87%AA%E6%A3%80/</url>
    <content><![CDATA[<h2 id="设置安装规则"><a href="#设置安装规则" class="headerlink" title="设置安装规则"></a>设置安装规则</h2><p>在<code>mathfunction/CMakeLists.txt</code>中使用<code>install</code>命令来安装头文件和静态库:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">install (TARGETS MathFunctions DESTINATION bin)</span><br><span class="line">install (FILES MathFunctions.h DESTINATION include)</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>根目录下的CMakeLists.txt添加：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># add the install targets</span></span><br><span class="line">install (TARGETS Tutorial DESTINATION bin)</span><br><span class="line">install (FILES <span class="string">&quot;$&#123;PROJECT_BINARY_DIR&#125;/TutorialConfig.h&quot;</span> DESTINATION include)</span><br></pre></td></tr></table></figure>

<p><code>TARGETS</code>包含六种形式：<code>ARCHIVE</code>, <code>LIBRARY</code>, <code>RUNTIME</code>, <code>OBJECTS</code>, <code>FRAMEWORK</code>, <code>BUNDLE</code>。<br><code>Mathfunction</code>安装的是<code>LIBRARY</code>，而<code>根目录</code>下的可执行文件是<code>RUNTIME</code>类型。<br><code>FILE</code> 将给定的文件复制到指定目录。如果没有给定权限参数，则由该表单安装的文件默认为<code>OWNER_WRITE、OWNER_READ、GROUP_READ和WORLD_READ</code>。<br>TARGETS和FILE可指定为相对目录和绝对目录。<br>DESTINATION在这里是一个相对路径，取默认值。在unix系统中指向 <code>/usr/local</code>。<br>也可以通过设置<code>CMAKE_INSTALL_PREFIX</code>这个变量来设置安装的路径，那么安装位置不指向/usr/local，而指向你所指定的目录。</p>
<h3 id="不指定安装路径"><a href="#不指定安装路径" class="headerlink" title="不指定安装路径"></a>不指定安装路径</h3><p><img src="9c10f638df29e37ccc03d7050774b7bd3f6ab0a7326d64dcb446d354a512821c.png" alt="图 1">  </p>
<h3 id="指定安装路径"><a href="#指定安装路径" class="headerlink" title="指定安装路径"></a>指定安装路径</h3><p><img src="89abf5ea5ed2c4bebc473fbb09f171539b231456c725d08cd49a7dd8794d0fe3.png" alt="图 2">  </p>
<h2 id="添加测试"><a href="#添加测试" class="headerlink" title="添加测试"></a>添加测试</h2><p>使用 <code>enable_testing()</code> 命令可以启用测试。一定要在根目录下的CMakeLists.txt中开启，<code>ctest</code>命令来运行测试</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># enable testing</span></span><br><span class="line">enable_testing ()</span><br><span class="line"></span><br><span class="line"><span class="meta"># does the application run</span></span><br><span class="line">add_test (TutorialRuns Tutorial <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta"># does it sqrt of 25</span></span><br><span class="line">add_test (TutorialComp25 Tutorial <span class="number">25</span>)</span><br><span class="line">set_tests_properties (TutorialComp25</span><br><span class="line">  PROPERTIES PASS_REGULAR_EXPRESSION <span class="string">&quot;25 is 5&quot;</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="meta"># does it handle negative numbers</span></span><br><span class="line">add_test (TutorialNegative Tutorial <span class="number">-25</span>)</span><br><span class="line">set_tests_properties (TutorialNegative</span><br><span class="line">  PROPERTIES PASS_REGULAR_EXPRESSION <span class="string">&quot;-25 is 0&quot;</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="meta"># does it handle small numbers</span></span><br><span class="line">add_test (TutorialSmall Tutorial <span class="number">0.0001</span>)</span><br><span class="line">set_tests_properties (TutorialSmall</span><br><span class="line">  PROPERTIES PASS_REGULAR_EXPRESSION <span class="string">&quot;0.0001 is 0.01&quot;</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="meta"># does the usage message work?</span></span><br><span class="line">add_test (TutorialUsage Tutorial)</span><br><span class="line">set_tests_properties (TutorialUsage</span><br><span class="line">  PROPERTIES</span><br><span class="line">  PASS_REGULAR_EXPRESSION <span class="string">&quot;Usage:.*number&quot;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>

<p>运行结果：<br><img src="4c9ee991578a3deafc74eea5b9ffdb34f00beaec861fb86fed47fd22f830d222.png" alt="图 3">  </p>
<p><code>PASS_REGULAR_EXPRESSION</code>测试的输出是否包含特定的字符串。</p>
<h3 id="macro"><a href="#macro" class="headerlink" title="macro"></a>macro</h3><p>简化测试代码的编写:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> a macro to simplify adding tests, then use it</span></span><br><span class="line">macro (do_test arg result)</span><br><span class="line">  add_test (TutorialComp$&#123;arg&#125; Tutorial $&#123;arg&#125;)</span><br><span class="line">  set_tests_properties (TutorialComp$&#123;arg&#125;</span><br><span class="line">    PROPERTIES PASS_REGULAR_EXPRESSION $&#123;result&#125;)</span><br><span class="line">endmacro (do_test)</span><br><span class="line"></span><br><span class="line">do_test (<span class="number">36</span> <span class="string">&quot;36 is 6&quot;</span>)</span><br><span class="line">do_test (<span class="number">49</span> <span class="string">&quot;49 is 6&quot;</span>)</span><br><span class="line">do_test (<span class="number">-25</span> <span class="string">&quot;-25 is 0&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>运行结果：<br><img src="9fb2babc7681db363be246a3cb00715c5967f30a4e5fb44db72c737c6b9f9357.png" alt="图 4">  </p>
<h2 id="添加系统自检"><a href="#添加系统自检" class="headerlink" title="添加系统自检"></a>添加系统自检</h2><p>多种平台开发程序，而有的平台包含某个库，有的平台不包含这个库，那么我们就可以通过系统自检来判断是使用平台系统提供的库还是自己编写的库。<br>在根目录CMakeLists.txt添加:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># does this system provide the log and exp functions?</span></span><br><span class="line">include (CheckFunctionExists)</span><br><span class="line">check_function_exists (<span class="built_in">log</span> HAVE_LOG)</span><br><span class="line">check_function_exists (<span class="built_in">exp</span> HAVE_EXP)</span><br></pre></td></tr></table></figure>

<p>在TutorialConfig.h.in中添加：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// does the platform provide exp and log functions?</span></span><br><span class="line"><span class="meta">#cmakedefine HAVE_LOG</span></span><br><span class="line"><span class="meta">#cmakedefine HAVE_EXP</span></span><br></pre></td></tr></table></figure>

<p><code>mysqrt.cxx</code>实现代码:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// if we have both log and exp then use them</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined (HAVE_LOG) &amp;&amp; defined (HAVE_EXP)</span></span><br><span class="line">  result = <span class="built_in">exp</span>(<span class="built_in">log</span>(x)*<span class="number">0.5</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span> <span class="comment">// otherwise use an iterative approach</span></span></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<p>执行结果：<br><img src="c7d31852cc4a1795238b9bbb15702bc742daf69f629ab7f530e2647f04f2ea53.png" alt="图 5">  </p>
]]></content>
      <categories>
        <category>cmake</category>
      </categories>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake添加库</title>
    <url>/2021/05/19/cmake%E6%B7%BB%E5%8A%A0%E5%BA%93/</url>
    <content><![CDATA[<h2 id="构建自己的库"><a href="#构建自己的库" class="headerlink" title="构建自己的库"></a>构建自己的库</h2><p>这个库将包含我们自己计算一个数字的平方根的计算方法。生成的程序可以使用这个库，而不是由编译器提供的标准平方根函数(math.h)。<br>相关语法:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">add_library()</span><br><span class="line">target_link_libraries()</span><br></pre></td></tr></table></figure>
<span id="more"></span>


<p>工程目录新建文件夹MathFunctions，新建MathFunctions/CMakeLists.txt文件，包含以下一行代码:<br><code>add_library(MathFunctions mysqrt.cxx)</code></p>
<p>新建<code>MathFunctions/MathFunctions.h</code>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">mysqrt</span><span class="params">(<span class="type">double</span> x)</span>;</span><br></pre></td></tr></table></figure>

<p>新建<code>MathFunctions/mysqrt.cxx</code>代码如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MathFunctions.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a hack square root calculation using simple operations</span></span><br><span class="line"><span class="type">double</span> <span class="title function_">mysqrt</span><span class="params">(<span class="type">double</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> result;</span><br><span class="line">  <span class="type">double</span> delta;</span><br><span class="line">  result = x;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// do ten iterations</span></span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (result &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      result = <span class="number">0.1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    delta = x - (result * result);</span><br><span class="line">    result = result + <span class="number">0.5</span> * delta / result;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;Computing sqrt of %g to be %g\n&quot;</span>, x, result);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="option"><a href="#option" class="headerlink" title="option"></a>option</h2><p>MathFunctions是我们自己构建的库，有时候我们需要控制这个库是否应该使用，那么可以为使用这个库添加一个开关，在构建大型项目时非常有用。<br>在项目根目录下的CMakeLists.txt文件中添加如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># should we use our own math functions?</span></span><br><span class="line">option (USE_MYMATH <span class="string">&quot;Use tutorial provided math implementation&quot;</span> ON)</span><br></pre></td></tr></table></figure>
<p>修改根目录下CMakeLists.txt:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># add the MathFunctions library?</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta"><span class="keyword">if</span> (USE_MYMATH)</span></span><br><span class="line">  include_directories (<span class="string">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/MathFunctions&quot;</span>)</span><br><span class="line">  add_subdirectory (MathFunctions)</span><br><span class="line">  <span class="built_in">set</span> (EXTRA_LIBS $&#123;EXTRA_LIBS&#125; MathFunctions)</span><br><span class="line">endif (USE_MYMATH)</span><br><span class="line"> </span><br><span class="line"><span class="meta"># add the executable</span></span><br><span class="line">add_executable (Tutorial tutorial.cxx)</span><br><span class="line">target_link_libraries (Tutorial  $&#123;EXTRA_LIBS&#125;)</span><br></pre></td></tr></table></figure>

<p>需要在Configure.h.in文件中添加以下内容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#cmakedefine USE_MYMATH</span></span><br></pre></td></tr></table></figure>
<p>最后修改Tutorial.cxx源代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A simple program that computes the square root of a number</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TutorialConfig.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_MYMATH</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;MathFunctions.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">&quot;%s Version %d.%d\n&quot;</span>, argv[<span class="number">0</span>],</span><br><span class="line">            Tutorial_VERSION_MAJOR,</span><br><span class="line">            Tutorial_VERSION_MINOR);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">&quot;Usage: %s number\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="type">double</span> inputValue = atof(argv[<span class="number">1</span>]);</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> USE_MYMATH</span></span><br><span class="line">  <span class="type">double</span> outputValue = mysqrt(inputValue);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="type">double</span> outputValue = <span class="built_in">sqrt</span>(inputValue);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"> </span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">&quot;The square root of %g is %g\n&quot;</span>,</span><br><span class="line">          inputValue, outputValue);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终文件目录如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── MathFunctions</span><br><span class="line">│   ├── CMakeLists.txt</span><br><span class="line">│   ├── MathFunctions.h</span><br><span class="line">│   └── mysqrt.cxx</span><br><span class="line">├── TutorialConfig.h.in</span><br><span class="line">└── tutorial.cxx</span><br></pre></td></tr></table></figure>

<h2 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h2><h3 id="USE-MYMATH-ON"><a href="#USE-MYMATH-ON" class="headerlink" title="USE_MYMATH=ON"></a>USE_MYMATH=ON</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@YBNJ0101:/home/rma/mr_work/test/cpp_test/tutorial-master/Step2/build<span class="comment"># cmake .. -DUSE_MYMATH=ON</span></span><br><span class="line">-- The C compiler identification is GNU 7.5.0</span><br><span class="line">-- The CXX compiler identification is GNU 7.5.0</span><br><span class="line">-- Check <span class="keyword">for</span> working C compiler: /usr/bin/cc</span><br><span class="line">-- Check <span class="keyword">for</span> working C compiler: /usr/bin/cc -- works</span><br><span class="line">-- Detecting C compiler ABI info</span><br><span class="line">-- Detecting C compiler ABI info - <span class="keyword">done</span></span><br><span class="line">-- Detecting C compile features</span><br><span class="line">-- Detecting C compile features - <span class="keyword">done</span></span><br><span class="line">-- Check <span class="keyword">for</span> working CXX compiler: /usr/bin/c++</span><br><span class="line">-- Check <span class="keyword">for</span> working CXX compiler: /usr/bin/c++ -- works</span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - <span class="keyword">done</span></span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - <span class="keyword">done</span></span><br><span class="line">-- Configuring <span class="keyword">done</span></span><br><span class="line">-- Generating <span class="keyword">done</span></span><br><span class="line">-- Build files have been written to: /home/rma/mr_work/test/cpp_test/tutorial-master/Step2/build</span><br><span class="line">root@YBNJ0101:/home/rma/mr_work/test/cpp_test/tutorial-master/Step2/build<span class="comment"># ls</span></span><br><span class="line">CMakeCache.txt  CMakeFiles  Makefile  MathFunctions  TutorialConfig.h  cmake_install.cmake</span><br><span class="line">root@YBNJ0101:/home/rma/mr_work/test/cpp_test/tutorial-master/Step2/build<span class="comment"># make</span></span><br><span class="line">Scanning dependencies of target MathFunctions</span><br><span class="line">[ 25%] Building CXX object MathFunctions/CMakeFiles/MathFunctions.<span class="built_in">dir</span>/mysqrt.cxx.o</span><br><span class="line">[ 50%] Linking CXX static library libMathFunctions.a</span><br><span class="line">[ 50%] Built target MathFunctions</span><br><span class="line">Scanning dependencies of target Tutorial</span><br><span class="line">[ 75%] Building CXX object CMakeFiles/Tutorial.<span class="built_in">dir</span>/tutorial.cxx.o</span><br><span class="line">[100%] Linking CXX executable Tutorial</span><br><span class="line">[100%] Built target Tutorial</span><br><span class="line">root@YBNJ0101:/home/rma/mr_work/test/cpp_test/tutorial-master/Step2/build<span class="comment"># ./Tutorial</span></span><br><span class="line">./Tutorial Version 1.0</span><br><span class="line">Usage: ./Tutorial number</span><br><span class="line">root@YBNJ0101:/home/rma/mr_work/test/cpp_test/tutorial-master/Step2/build<span class="comment"># ./Tutorial 2</span></span><br><span class="line">Computing sqrt of 2 to be 1.5</span><br><span class="line">Computing sqrt of 2 to be 1.41667</span><br><span class="line">Computing sqrt of 2 to be 1.41422</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">Computing sqrt of 2 to be 1.41421</span><br><span class="line">The square root of 2 is 1.41421</span><br></pre></td></tr></table></figure>

<h3 id="USE-MYMATH-OFF"><a href="#USE-MYMATH-OFF" class="headerlink" title="USE_MYMATH=OFF"></a>USE_MYMATH=OFF</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@YBNJ0101:/home/rma/mr_work/test/cpp_test/tutorial-master/Step2/build<span class="comment"># cmake .. -DUSE_MYMATH=OFF</span></span><br><span class="line">-- The C compiler identification is GNU 7.5.0</span><br><span class="line">-- The CXX compiler identification is GNU 7.5.0</span><br><span class="line">-- Check <span class="keyword">for</span> working C compiler: /usr/bin/cc</span><br><span class="line">-- Check <span class="keyword">for</span> working C compiler: /usr/bin/cc -- works</span><br><span class="line">-- Detecting C compiler ABI info</span><br><span class="line">-- Detecting C compiler ABI info - <span class="keyword">done</span></span><br><span class="line">-- Detecting C compile features</span><br><span class="line">-- Detecting C compile features - <span class="keyword">done</span></span><br><span class="line">-- Check <span class="keyword">for</span> working CXX compiler: /usr/bin/c++</span><br><span class="line">-- Check <span class="keyword">for</span> working CXX compiler: /usr/bin/c++ -- works</span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - <span class="keyword">done</span></span><br><span class="line">-- Detecting CXX compile features</span><br><span class="line">-- Detecting CXX compile features - <span class="keyword">done</span></span><br><span class="line">-- Configuring <span class="keyword">done</span></span><br><span class="line">-- Generating <span class="keyword">done</span></span><br><span class="line">-- Build files have been written to: /home/rma/mr_work/test/cpp_test/tutorial-master/Step2/build</span><br><span class="line">root@YBNJ0101:/home/rma/mr_work/test/cpp_test/tutorial-master/Step2/build<span class="comment"># make</span></span><br><span class="line">Scanning dependencies of target Tutorial</span><br><span class="line">[ 50%] Building CXX object CMakeFiles/Tutorial.<span class="built_in">dir</span>/tutorial.cxx.o</span><br><span class="line">[100%] Linking CXX executable Tutorial</span><br><span class="line">[100%] Built target Tutorial</span><br><span class="line">root@YBNJ0101:/home/rma/mr_work/test/cpp_test/tutorial-master/Step2/build<span class="comment"># ./Tutorial</span></span><br><span class="line">./Tutorial Version 1.0</span><br><span class="line">Usage: ./Tutorial number</span><br><span class="line">root@YBNJ0101:/home/rma/mr_work/test/cpp_test/tutorial-master/Step2/build<span class="comment"># ./Tutorial 2</span></span><br><span class="line">The square root of 2 is 1.41421</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cmake</category>
      </categories>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake编译</title>
    <url>/2021/05/18/cmake%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>CMake是一个构建系统，可以用于构建跨平台的C和C++项目。<br>官方教程可参考<a href="https://cmake.org/cmake-tutorial/">cmake tutorial</a></p>
<span id="more"></span>

<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><p>一个最基本的CmakeLists.txt文件最少需要包含以下三行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required (VERSION 2.6)</span><br><span class="line">project (Tutorial)</span><br><span class="line">add_executable(Tutorial tutorial.cxx)</span><br></pre></td></tr></table></figure>

<p>注意：cmake的语法支持<strong>大写、小写和大小写混合</strong>，如下语法同样生效</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required</span><br><span class="line">CMAKE_MINIMUM_REQUIRED</span><br><span class="line">cmake_MINUMUM_required</span><br></pre></td></tr></table></figure>
<p>注意：只有系统指令是不区分大小写的，<strong>变量和字符串是区分大小写的</strong>。<br>创建一个tutorial.cxx文件，用来计算一个数字的平方根，内容如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A simple program that computes the square root of a number</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">&quot;Usage: %s number\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="type">double</span> inputValue = atof(argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="type">double</span> outputValue = <span class="built_in">sqrt</span>(inputValue);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>,<span class="string">&quot;The square root of %g is %g\n&quot;</span>,</span><br><span class="line">          inputValue, outputValue);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用外部构建运行结果如下<br><img src="7fc8de266de6bc403670eded14d1b7600be63781bbc066e161ea1d479ddcb597.png" alt="图 1">  </p>
<h2 id="添加版本号"><a href="#添加版本号" class="headerlink" title="添加版本号"></a>添加版本号</h2><p>CmakeLists.txt中使用<code>configure_file</code>命令和<code>config.h.in</code>文件生成<code>config.h</code>头文件。<br><code>set(KEY VALUE)</code>接受两个参数，用来声明变量。<br>在camke语法中使用KEY并不能直接取到VALUE,必须使用${KEY}这种写法来取到VALUE。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake_minimum_required (VERSION 2.6)</span><br><span class="line">project (Tutorial)</span><br><span class="line"><span class="comment"># The version number.</span></span><br><span class="line"><span class="built_in">set</span> (Tutorial_VERSION_MAJOR 1)</span><br><span class="line"><span class="built_in">set</span> (Tutorial_VERSION_MINOR 0)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># configure a header file to pass some of the CMake settings</span></span><br><span class="line"><span class="comment"># to the source code</span></span><br><span class="line">configure_file (</span><br><span class="line">  <span class="string">&quot;<span class="variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/TutorialConfig.h.in&quot;</span></span><br><span class="line">  <span class="string">&quot;<span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>/TutorialConfig.h&quot;</span></span><br><span class="line">  )</span><br><span class="line"> </span><br><span class="line"><span class="comment"># add the binary tree to the search path for include files</span></span><br><span class="line"><span class="comment"># so that we will find TutorialConfig.h</span></span><br><span class="line">include_directories(<span class="string">&quot;<span class="variable">$&#123;PROJECT_BINARY_DIR&#125;</span>&quot;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># add the executable</span></span><br><span class="line">add_executable(Tutorial tutorial.cxx)</span><br></pre></td></tr></table></figure>

<p>新建一个TutorialConfig.h.in,内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// the configured options and settings <span class="keyword">for</span> Tutorial</span><br><span class="line"><span class="comment">#define Tutorial_VERSION_MAJOR @Tutorial_VERSION_MAJOR@</span></span><br><span class="line"><span class="comment">#define Tutorial_VERSION_MINOR @Tutorial_VERSION_MINOR@</span></span><br></pre></td></tr></table></figure>
<p>@Tutorial_VERSION_MAJOR@和@Tutorial_VERSION_MINOR@将会被替换为CmakeLists.txt中的1和0。<br>然后修改Tutorial.cxx文件如下，用来在不输入额外参数的情况下输出版本信息：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A simple program that computes the square root of a number</span></span><br><span class="line"><span class="comment">// A simple program that computes the square root of a number</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TutorialConfig.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;%s Version %d.%d\n&quot;</span>, argv[<span class="number">0</span>], Tutorial_VERSION_MAJOR,</span><br><span class="line">            Tutorial_VERSION_MINOR);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;Usage: %s number\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">double</span> inputValue = atof(argv[<span class="number">1</span>]);</span><br><span class="line">  <span class="type">double</span> outputValue = <span class="built_in">sqrt</span>(inputValue);</span><br><span class="line">  <span class="built_in">fprintf</span>(<span class="built_in">stdout</span>, <span class="string">&quot;The square root of %g is %g\n&quot;</span>, inputValue, outputValue);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译运行结果如下：<br><img src="f8bd542ae5541ca16f7e94cf6aae3dfd923558ced3f43ba256a3dd88bef29841.png" alt="图 2">  </p>
<h2 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h2><p>指定交叉编译工具链：<code>CMAKE_C_COMPILER</code>、<code>CMAKE_CXX_COMPILER</code><br>在项目根目录下，新建<code>arm_linux_setup.cmake</code>文件：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>(CMAKE_SYSTEM_NAME <span class="string">&quot;Linux&quot;</span>)</span><br><span class="line"><span class="built_in">set</span>(tools <span class="string">&quot;/home/rma/mr_work/dral_git/gcc-arm-10.2-2020.11-x86_64-aarch64-none-linux-gnu&quot;</span>)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_C_COMPILER <span class="string">&quot;$&#123;tools&#125;/bin/aarch64-none-linux-gnu-gcc&quot;</span>)</span><br><span class="line"><span class="built_in">set</span>(CMAKE_CXX_COMPILER <span class="string">&quot;$&#123;tools&#125;/bin/aarch64-none-linux-gnu-g++&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>使用外部构建，<code>-DCMAKE_TOOLCHAIN_FILE</code>指定交叉编译文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cmake -DCMAKE_TOOLCHAIN_FILE=../arm_linux_setup.cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure>

<p>结果：<br><img src="76c25cc3e715c3ff62f23494fa5cfc03539d30b11d35781aec205b05fc7662e3.png" alt="图 3"><br><img src="804ba62fe81739f24c1939fa6a32ddb8cc092163e4be1c93cf4cdee45c4c6560.png" alt="图 4">  </p>
<p>将可执行文件放到arm环境上运行<br><img src="16f71477d34ae18cf29539828c7c01e3cdc9f7e89fe4ce2060a595306cafc919.png" alt="图 5">  </p>
]]></content>
      <categories>
        <category>cmake</category>
      </categories>
      <tags>
        <tag>cmake</tag>
      </tags>
  </entry>
  <entry>
    <title>automake简介</title>
    <url>/2021/05/17/automake%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote>
<p>GNU Automake是一种编程工具，可以产生供make程序使用的Makefile，用来编译程序。它是自由软件基金会发起的GNU计划的其中一项，作为GNU构建系统的一部分。automake所产生的Makefile符合GNU编程标准。</p>
</blockquote>
<span id="more"></span>

<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p>可以依次执行:<br><code>aclocal; autoconf; automake --add-missing; ./configure</code><br>来生成Makefile<br><img src="3d77be5b76bfbe0723418605adb75c23614fe744ad1841471be42eeb293855ad.png" alt="图 2">  </p>
<p>上述流程也可简化为:<br><code>autoreconf --instal; ./configure</code><br><img src="b5fbf2411f69db3a2153b64051d5371bb4363b4e6e0b92b9d0adab68b8385fb4.png" alt="图 3">  </p>
<p>实际项目中，我们只需要关注configure.ac和Makefile.am的编写即可</p>
<h2 id="configure-ac常用宏定义"><a href="#configure-ac常用宏定义" class="headerlink" title="configure.ac常用宏定义"></a>configure.ac常用宏定义</h2><table>
    <tr>
        <th>宏定义</th><th>含义</th>
    </tr>
    <tr>
        <td>AC_INIT([FULL-PACKAGE-NAME], [VERSION], [BUG-REPORT-ADDRESS])</td><td>指明工程的名字，当前工程的版本号，工程所有者的邮箱</td>
    </tr>
    <tr>
        <td>AC_CONFIG_FILES([makefile1_path makefile2_path])</td><td>指明了所有要生成的Makefile的相对路径</td>
    </tr>
    <tr>
        <td>AC_CONFIG_HEADER([config.h])</td><td>指定了要创建的头文件</td>
    </tr>
    <tr>
        <td>AC_SUBST(xxx)</td><td>定义外部变量，am文件可以通过@xxx@来引用</td>
    </tr>
    <tr>
        <td>AC_ARG_WITH (package, help-string, [action-if-given], [action-if-not-given])</td><td>为./configure添加自定义参数--with-xxx=path ，可通过./configure -h 列出配置参数</td>
    </tr>
    <tr>
        <td>AC_ARG_ENABLE (feature, help-string, [action-if-given], [action-if-not-given])</td><td>./configure --enable-xxx</td>
    </tr>
    <tr>
        <td>AC_CHECK_HEADERS([unistd.h windows.h])</td><td>在当前环境下检查unistd.h,windows.h是否存在</td>
    </tr>
    <tr>
        <td>AC_CHECK_FUNCS (function…, [action-if-found], [action-if-not-found])</td><td>检查函数是否存在，如果存在执行动作action-if-found,没有发现执行动作action-if-not-found。</td>
    </tr>
    <tr>
        <td>AC_MSG_CHECKING(message)</td><td>在执行 configure 命令时输出“checking <message>”等信息</message></td>
    </tr>
    <tr>
        <td>AC_MSG_RESULT(value)</td><td>取得 AC_MSG_CHECKING 的执行结果，一般情况下 value 应为 yes 或 no</td>
    </tr>
    <tr>
        <td>AC_DEFINE(VARIABLE, VALUE, DESCRIPTION)</td><td>输出到config.h中</td>
    </tr>
    <tr>
        <td>AC_PROG_CC, AC_PROG_CXX</td><td>编译器检测</td>
    </tr>
    <tr>
        <td>AC_MSG_ERROR(ERROR-DESCRIPTION, [EXIT-STATUS])</td><td>打印错误信息ERROR-DESCRIPTION并退出，EXIT-STATUS设置退出状态</td>
    </tr>
    <tr>
        <td>AC_MSG_WARN(ERROR-DESCRIPTION)</td><td>打印但是不退出</td>
    </tr>
    <tr>
        <td>AC_PREREQ(VERSION)</td><td>需要的最低autoconf版本，如：AC_PREREQ([2.65])</td>
    </tr>
</table>





<h2 id="Makefile-am基本语法"><a href="#Makefile-am基本语法" class="headerlink" title="Makefile.am基本语法"></a>Makefile.am基本语法</h2><table>
    <tr>
        <th>文件类型</th><th>书写格式</th><th>含义</th>
    </tr>
    <tr>
        <td rowspan="4" align="center">可执行文件</td><td>bin_PROGRAMS = foo</td><td>指定生成的可执行程序foo</td>
    </tr>
    <tr>
        <td>foo_SOURCES = xxx.c xxxx.c</td><td>源文件</td>
    </tr>
    <tr>
        <td>foo_LDADD =  xxx.a</td><td>需要链接的库</td>
    </tr>
    <tr>
        <td>INCLUDES = -I.../include/</td><td>头文件</td>
    </tr>
    <tr>
        <td rowspan="3" align="center">静态库</td><td>noinst_LIBRARIES = xxx.a</td><td>生成的静态库文件，不安装</td>
    </tr>
    <tr>
        <td>xxx_a_SOURCES = a.c b.c xxx.c</td><td>源文件</td>
    </tr>
    <tr>
        <td>INCLUDES = -I.../include/</td><td>头文件</td>
    </tr>
    <tr>
        <td rowspan="3" align="center">动态库</td><td>noinst_LTLIBRARIES = foo.la</td><td>生成的动态库文件，不安装</td>
    </tr>
    <tr>
        <td>foo_la_SOURCES = xxx.c xxxx.c</td><td>源文件</td>
    </tr>
    <tr>
        <td>INCLUDES = -I.../include/</td><td>头文件</td>
    </tr>
</table>]]></content>
      <categories>
        <category>automake</category>
      </categories>
      <tags>
        <tag>automake</tag>
      </tags>
  </entry>
  <entry>
    <title>cross compile</title>
    <url>/2021/05/16/cross-compile/</url>
    <content><![CDATA[<h2 id="GCC编译过程"><a href="#GCC编译过程" class="headerlink" title="GCC编译过程"></a>GCC编译过程</h2><p>linux系统默认安装了GCC 编译工具链，当我们使用GCC来编译Hello World程序时，只需要使用简单的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; gcc hello.c -o hello</span><br><span class="line">&gt; ./hello</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>事实上，上述过程可以分解为4个步骤，分别是<strong>预处理、编译、汇编和链接</strong></p>
<p><img src="7f0fc4070152272cf544d20a7f356a77f8e90f3f6e2c090c36ce8eb41ccdf91b.png" alt="图 1">  </p>
<ol>
<li><p>预处理<br>预处理是将包含(include)的文件插入原文件中、将<strong>宏定义展开</strong>、根据条件编译命令选择要使用的代码，最后将这些东西输出到一个.i文件中并等待进一步处理。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; gcc -E hello.c -o hello.i</span><br></pre></td></tr></table></figure></li>
<li><p>编译<br>语法分析及优化，生产汇编代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; gcc -S hello.i -o hello.s</span><br></pre></td></tr></table></figure></li>
<li><p>汇编<br>汇编代码生成机器代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; gcc -c hello.s -o hello.o</span><br></pre></td></tr></table></figure></li>
<li><p>链接<br>链接静态、动态库、.o文件，生成可执行文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; gcc hello.o -o hello</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="交叉编译简介"><a href="#交叉编译简介" class="headerlink" title="交叉编译简介"></a>交叉编译简介</h2><p>交叉编译和本地编译为相对应的概念。所谓的交叉编译就是在一种平台上编译出来的程序，是放到别的平台环境运行，<strong>即编译的环境和运行的环境不一样</strong>，属于交叉的，或称为cross。交叉编译的概念，主要使用在嵌入式开发当中（资源有限）。</p>
<h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><p>步骤一、下载<a href="https://developer.arm.com/-/media/Files/downloads/gnu-a/10.2-2020.11/binrel/gcc-arm-10.2-2020.11-x86_64-aarch64-none-linux-gnu.tar.xz?revision=972019b5-912f-4ae6-864a-f61f570e2e7e&rev=972019b5912f4ae6864af61f570e2e7e&hash=90B272942CAC63CBE2787E5F43E7B2C6D0AB20D6">gcc-arm-10.2-2020.11-aarch64-aarch64-none-elf.tar.xz</a></p>
<p>步骤二、拷贝源码到Ubuntu系统中/home/rma/mr_work/dral_git（创建的一个目录）的文件夹下.</p>
<p>步骤三、进入存放目录，解压</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xvf gcc-arm-10.2-2020.11-aarch64-aarch64-none-elf.tar.xz</span><br></pre></td></tr></table></figure>

<p>步骤四、修改环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.bashrc</span><br><span class="line"><span class="built_in">export</span> ARM64_HOME=/home/rma/mr_work/dral_git/gcc-arm-10.2-2020.11-x86_64-aarch64-none-linux-gnu</span><br><span class="line"><span class="built_in">export</span> ARM64_NONE_HOME=<span class="variable">$&#123;ARM64_HOME&#125;</span>/aarch64-none-linux-gnu</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$&#123;ARM64_HOME&#125;</span>/bin:<span class="variable">$&#123;ARM64_NONE_HOME&#125;</span>/bin</span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$&#123;ARM64_HOME&#125;</span>/lib:<span class="variable">$&#123;ARM64_HOME&#125;</span>/lib64:<span class="variable">$&#123;ARM64_HOME&#125;</span>/libexec:<span class="variable">$&#123;ARM64_NONE_HOME&#125;</span>/lib:<span class="variable">$&#123;ARM64_NONE_HOME&#125;</span>/lib64:<span class="variable">$&#123;ARM64_NONE_HOME&#125;</span>/libc</span><br></pre></td></tr></table></figure>

<p>步骤五、生效环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>

<p>步骤六、验证工具链是否安装成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># aarch64-none-linux-gnu-gcc -v</span></span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=aarch64-none-linux-gnu-gcc</span><br><span class="line">COLLECT_LTO_WRAPPER=/home/rma/mr_work/dral_git/gcc-arm-10.2-2020.11-x86_64-aarch64-none-linux-gnu/bin/../libexec/gcc/aarch64-none-linux-gnu/10.2.1/lto-wrapper</span><br><span class="line">Target: aarch64-none-linux-gnu</span><br><span class="line">Configured with: /tmp/dgboter/bbs/build04--cen7x86_64/buildbot/cen7x86_64--aarch64-none-linux-gnu/build/src/gcc/configure --target=aarch64-none-linux-gnu --prefix= --with-sysroot=/aarch64-none-linux-gnu/libc --with-build-sysroot=/tmp/dgboter/bbs/build04--cen7x86_64/buildbot/cen7x86_64--aarch64-none-linux-gnu/build/build-aarch64-none-linux-gnu/install//aarch64-none-linux-gnu/libc --with-bugurl=https://bugs.linaro.org/ --enable-gnu-indirect-function --enable-shared --disable-libssp --disable-libmudflap --enable-checking=release --enable-languages=c,c++,fortran --with-gmp=/tmp/dgboter/bbs/build04--cen7x86_64/buildbot/cen7x86_64--aarch64-none-linux-gnu/build/build-aarch64-none-linux-gnu/host-tools --with-mpfr=/tmp/dgboter/bbs/build04--cen7x86_64/buildbot/cen7x86_64--aarch64-none-linux-gnu/build/build-aarch64-none-linux-gnu/host-tools --with-mpc=/tmp/dgboter/bbs/build04--cen7x86_64/buildbot/cen7x86_64--aarch64-none-linux-gnu/build/build-aarch64-none-linux-gnu/host-tools --with-isl=/tmp/dgboter/bbs/build04--cen7x86_64/buildbot/cen7x86_64--aarch64-none-linux-gnu/build/build-aarch64-none-linux-gnu/host-tools --enable-fix-cortex-a53-843419 --with-pkgversion=<span class="string">&#x27;GNU Toolchain for the A-profile Architecture 10.2-2020.11 (arm-10.16)&#x27;</span></span><br><span class="line">Thread model: posix</span><br><span class="line">Supported LTO compression algorithms: zlib</span><br><span class="line">gcc version 10.2.1 20201103 (GNU Toolchain <span class="keyword">for</span> the A-profile Architecture 10.2-2020.11 (arm-10.16)) </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>交叉编译</category>
      </categories>
      <tags>
        <tag>cross_compile</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile函数</title>
    <url>/2021/05/15/Makefile%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="Makefile-函数"><a href="#Makefile-函数" class="headerlink" title="Makefile 函数"></a>Makefile 函数</h2><p>GNU make 提供了大量的函数用来处理文件名、变量、文本和命令。通过这些函数，用户可以节省很多精力，编写出更加灵活和健壮的Makefile。函数的使用和变量引用的展开方式相同：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$(<span class="keyword">function</span> arg1,arg2,arg3)</span><br><span class="line"><span class="variable">$&#123;function arg1,arg2,arg3&#125;</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>关于函数的使用格式，有以下需要注意的地方：</p>
<ul>
<li>函数主要分为两类：make内嵌函数和用户自定义函数。</li>
<li>对于 GNU make内嵌的函数，直接引用就可以了；对于用户自定义的函数，要通过make的<code>call</code>函数来间接调用。</li>
<li>函数和参数列表之间要用空格隔开，多个参数之间使用逗号隔开。</li>
<li>如果在参数中引用了变量，变量的引用建议和函数引用使用统一格式：要么是一对小括号，要么是一对大括号。</li>
</ul>
<p><strong>wildcard</strong><br>函数使用示例：如果我们想要获取某个目录下所有的C文件列表，可以使用扩展通配符函数：wildcard</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SRC  = $(wildcard *.c)</span><br><span class="line">HEAD = $(wildcard *.h)</span><br><span class="line">all:</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;SRC = <span class="subst">$(SRC)</span>&quot;</span></span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;HEAD = <span class="subst">$(HEAD)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>在当前目录下，我们新建一些C文件和H文件，然后使用make命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ls</span></span><br><span class="line">add.c  add.h  hello.c  main.c  makefile  sub.c  sub.h</span><br><span class="line"><span class="comment"># make</span></span><br><span class="line">SRC = hello.c main.c add.c sub.c</span><br><span class="line">HEAD = add.h sub.h</span><br></pre></td></tr></table></figure>

<h3 id="用户自定义函数"><a href="#用户自定义函数" class="headerlink" title="用户自定义函数"></a>用户自定义函数</h3><p>GNU make提供了大量的内嵌函数，大大方便了用户Makefile的编写。但有时候根据需要，用户也可以自定义一些函数，然后在Makefile中引用它们：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">PHONY: all</span><br><span class="line">define func</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;pram1 = <span class="subst">$(0)</span>&quot;</span></span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;pram2 = <span class="subst">$(1)</span>&quot;</span></span><br><span class="line">endef</span><br><span class="line">all:</span><br><span class="line">    $(call func, hello world)</span><br></pre></td></tr></table></figure>
<p>用户自定义函以<code>define</code>开头，<code>endef</code>结束，给函数传递的参数在函数中使用$(0)、$(1)引用，分别表示第1个参数、第2个参数…</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line">pram1 = func</span><br><span class="line">pram2 =  hello world</span><br></pre></td></tr></table></figure>

<h2 id="文本处理函数"><a href="#文本处理函数" class="headerlink" title="文本处理函数"></a>文本处理函数</h2><p>GNU make提供了一系列文本处理函数：<br><code>subst</code>、<code>patsubst</code>、<code>strip</code>、<code>findstring</code>、<code>filter</code>、<code>filer-out</code>、<code>sort</code>、<code>word</code>、<code>wordlist</code>、<code>words</code>、<code>fistword</code>。接下来我们一一讲解：</p>
<p><strong>subst函数</strong><br>subst函数用来实现字符串的替换，将字符串text中的old替换为new</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$(subst old,new,text)</span><br></pre></td></tr></table></figure>
<p>编写一个Makefile，将当前目录下的所有c文件的名称xx.c转换为xx.o</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: all</span><br><span class="line">SRC  = $(wildcard *.c)</span><br><span class="line">OBJ  = $(subst .c,.o,$(SRC))</span><br><span class="line">all:</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;OBJ = <span class="subst">$(OBJ)</span>&quot;</span></span><br><span class="line">    @<span class="built_in">echo</span> $(subst banana, apple, <span class="string">&quot;banana is good, I like banana&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>执行make命令，可以看到执行结果：字符串中的banana替换成了apple，SRC变量中的所有.c 替换成了 .o：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ls</span></span><br><span class="line">add.c  add.h  hello.c  main.c  makefile  sub.c  sub.h</span><br><span class="line"><span class="comment"># make</span></span><br><span class="line">OBJ = hello.o main.o add.o sub.o</span><br><span class="line">apple is good, I like  apple</span><br></pre></td></tr></table></figure>

<p><strong>patsubst函数</strong><br>patsubst函数主要用来模式替换：使用通配符 <code>%</code> 代表一个单词中的若干字符，在PATTERN和REPLACEMENT如果都包含这个通配符，表示两者表示的是相同的若干个字符，并执行替换操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$(patsubst PATTERN, REPLACEMENT, TEXT)</span><br></pre></td></tr></table></figure>
<p>如果我们想把某个目录下的所有.c文件皆为的文件名转换为以.o皆为的目标文件名，相比subst，使用patsubst会更加方便：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: all</span><br><span class="line">SRC  = $(wildcard *.c)</span><br><span class="line">OBJ  = $(patsubst %.c, %.o, $(SRC))</span><br><span class="line">all:</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;OBJ = <span class="subst">$(OBJ)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>SRC变量中包括多个字符串，代表各个文件名，各个字符串之间使用空格隔开，使用OBJ变量保存转换后的字符串。在当前目录下直接执行make，可以看到运行结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ls</span></span><br><span class="line">add.c  add.h  hello.c  main.c  makefile  sub.c  sub.h</span><br><span class="line"><span class="comment"># make</span></span><br><span class="line">OBJ =  hello.o  main.o  add.o  sub.o</span><br></pre></td></tr></table></figure>
<p>在Makefile中，如果我们已经得到了需要编译的C文件，想要得到它们对应的目标文件，经常使用上面的patsubst函数进行转换。</p>
<p><strong>strip函数</strong><br>strip函数是一个去空格函数：一个字符串通常有多个单词，单词之间使用一个或多个空格进行分割，<br>strip函数用来<strong>将多个连续的空字符合并成一个</strong>，并去掉字符串开头、末尾的空字符。空字符包括：空格、多个空格、tab等不可显示的字符。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: all</span><br><span class="line">STR =     hello a    b   c   </span><br><span class="line">STRIP_STR = $(strip $(STR))</span><br><span class="line">all:</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;STR = <span class="subst">$(STR)</span>&quot;</span></span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;STRIP_STR = <span class="subst">$(STRIP_STR)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>执行make后的结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line">STR = hello a    b   c   </span><br><span class="line">STRIP_STR = hello a b c</span><br></pre></td></tr></table></figure>

<p><strong>strip函数经常用在条件判断语句的表达式中</strong>，去掉多余的空格等因素，确保表达式比较的可靠和健壮。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifeq ($(strip $(foo)),)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;foo is empty&quot;</span></span><br><span class="line">endif</span><br></pre></td></tr></table></figure>


<p><strong>findstring 函数</strong><br>findstring函数用来查找一个字符串。使用格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$(findstring FIND, IN)</span><br></pre></td></tr></table></figure>

<p>findstring函数会在字符串IN中查找“FIND”字符串，如果找到，则返回字符串FIND，否则，返回空。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: all</span><br><span class="line">STR =     hello a    b   c   </span><br><span class="line">FIND = $(findstring hello, $(STR))</span><br><span class="line">all:</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;STR = <span class="subst">$(STR)</span>&quot;</span></span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;FIND = <span class="subst">$(FIND)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>执行make，运行结果为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line">STR = hello a    b   c   </span><br><span class="line">FIND = hello</span><br></pre></td></tr></table></figure>

<p><strong>filter 函数</strong><br>filter函数用来过滤掉一个指定的字符串，使用格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$(filter PATTERN…,TEXT)</span><br></pre></td></tr></table></figure>

<p>filter函数用来过滤掉字符串TEXT中所有不符合PATTERN模式的单词，只留下符合PATTERN格式的单词。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: all</span><br><span class="line">FILE = a.c b.h c.s d.cpp   </span><br><span class="line">SRC = $(filter %.c, $(FILE))</span><br><span class="line">all:</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;FILE = <span class="subst">$(FILE)</span>&quot;</span></span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;SRC = <span class="subst">$(SRC)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>执行make，运行结果为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line">FILE = a.c b.h c.s d.cpp   </span><br><span class="line">SRC = a.c</span><br></pre></td></tr></table></figure>

<p><strong>filter-out 函数</strong><br>filer-out函数是一个反过滤函数，功能和filter函数恰恰相反：该函数会过滤掉所有符合PATTERN模式的单词，保留所有不符合此模式的单词。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: all</span><br><span class="line">FILE = a.c b.h c.s d.cpp   </span><br><span class="line">SRC = $(filter-out %.c, $(FILE))</span><br><span class="line">all:</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;FILE = <span class="subst">$(FILE)</span>&quot;</span></span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;SRC = <span class="subst">$(SRC)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>在上面的Makefile中，使用filter-out %.c 过滤掉所有的.c文件。执行make，运行结果为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line">FILE = a.c b.h c.s d.cpp   </span><br><span class="line">SRC = b.h c.s d.cpp</span><br></pre></td></tr></table></figure>

<p><strong>sort函数：单词排序</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">sort</span> LIST)</span><br></pre></td></tr></table></figure>
<p>sort函数对字符串LIST中的单词以首字母为准进行排序，并删除重复的单词。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: all</span><br><span class="line">LIST = banana pear apple peach apple orange  </span><br><span class="line">STR = $(<span class="built_in">sort</span> $(LIST))</span><br><span class="line">all:</span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;LIST = <span class="subst">$(LIST)</span>&quot;</span></span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;STR = <span class="subst">$(STR)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>执行make，运行结果为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line">LIST = banana pear apple peach apple orange </span><br><span class="line">STR = apple banana orange peach pear</span><br></pre></td></tr></table></figure>

<p><strong>word函数：取单词</strong><br>word函数的作用是从一个字符串TEXT中，按照指定的数目N取单词：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$(word N,TEXT)</span><br></pre></td></tr></table></figure>
<p>函数的返回值是字符串TEXT中的第N个单词。如果N的值大于字符串中单词的个数，返回空；如果N为0，则出错。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: all</span><br><span class="line">LIST = banana pear apple peach orange </span><br><span class="line">word1 = $(word 1, $(LIST))</span><br><span class="line">word2 = $(word 2, $(LIST))</span><br><span class="line">word3 = $(word 3, $(LIST))</span><br><span class="line">word4 = $(word 4, $(LIST))</span><br><span class="line">word5 = $(word 5, $(LIST))</span><br><span class="line">word6 = $(word 6, $(LIST))</span><br><span class="line">all:</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;word1 = <span class="subst">$(word1)</span>&quot;</span></span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;word2 = <span class="subst">$(word2)</span>&quot;</span></span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;word3 = <span class="subst">$(word3)</span>&quot;</span></span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;word4 = <span class="subst">$(word4)</span>&quot;</span></span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;word5 = <span class="subst">$(word5)</span>&quot;</span></span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;word6 = <span class="subst">$(word6)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>执行make，运行结果为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line">word1 = banana</span><br><span class="line">word2 = pear</span><br><span class="line">word3 = apple</span><br><span class="line">word4 = peach</span><br><span class="line">word5 = orange</span><br><span class="line">word6 =</span><br></pre></td></tr></table></figure>
<p>如果N的值为0，则会报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">makefile:9: *** first argument to <span class="string">&#x27;word&#x27;</span> <span class="keyword">function</span> must be greater than 0.  Stop.</span><br></pre></td></tr></table></figure>

<p><strong>wordlist函数：取字串</strong><br>wordlist函数用来从一个字符串TEXT中取出从N到M之间的一个单词串：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$(wordlist N, M, TEXT)</span><br></pre></td></tr></table></figure>
<p>N 和 M都是从1开始的一个数字，函数的返回值是字符串TEXT中从N到M的一个单词串。当N比字符串TEXT中的单词个数大时，函数返回空。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: all</span><br><span class="line">LIST = banana pear apple peach orange </span><br><span class="line">sub_list = $(wordlist 1, 3, $(LIST))</span><br><span class="line">all:</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;LIST = <span class="subst">$(LIST)</span>&quot;</span></span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;sub_list = <span class="subst">$(sub_list)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>执行make时，wordlist函数会将字符串LIST中的前三个单词赋值给sub_list：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line">LIST = banana pear apple peach orange </span><br><span class="line">sub_list = banana pear apple</span><br></pre></td></tr></table></figure>

<p><strong>words函数：统计单词数目</strong><br>words函数用来统计一个字符串TEXT中单词的个数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$(words TEXT)</span><br></pre></td></tr></table></figure>
<p>words函数的返回值为字符串TEXT中单词的个数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: all</span><br><span class="line">LIST = banana pear apple peach orange </span><br><span class="line">all:</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;LIST = <span class="subst">$(LIST)</span>&quot;</span></span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;LIST len = <span class="subst">$(words $(LIST)</span>)</span></span><br></pre></td></tr></table></figure>
<p>执行make，运行结果为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line">LIST = banana pear apple peach orange </span><br><span class="line">LIST len = 5</span><br></pre></td></tr></table></figure>

<p><strong>firstword函数：取首个单词</strong><br>firstword函数用来取一个字符串中的首个单词。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$(firstword NAMES…)</span><br><span class="line">$(word 1,TEXT)</span><br></pre></td></tr></table></figure>
<p>firstword函数其实就相当于<code>$(word 1,TEXT)</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: all</span><br><span class="line">LIST = banana pear apple peach orange </span><br><span class="line">all:</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;LIST = <span class="subst">$(LIST)</span>&quot;</span></span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;first word = <span class="subst">$(firstword $(LIST)</span>)&quot;</span></span><br></pre></td></tr></table></figure>
<p>执行make，运行结果为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line">LIST = banana pear apple peach orange </span><br><span class="line">first word = banana</span><br></pre></td></tr></table></figure>

<h2 id="文件名处理函数"><a href="#文件名处理函数" class="headerlink" title="文件名处理函数"></a>文件名处理函数</h2><p>GNU make提供了一系列对文件名进行各种操作的函数：文件名替换、加前缀、去目录等。</p>
<p><strong>dir函数：取路径名的目录</strong><br>dir函数用来从一个路径名中截取目录的部分。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">dir</span> NAMES…)</span><br></pre></td></tr></table></figure>
<p>dir函数会从NAMES文件名序列中，取出各个文件路径名中的目录部分并返回</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: all</span><br><span class="line">LIST = /home/wit/banana.c /usr/include/stdio.h</span><br><span class="line">all:</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;LIST = <span class="subst">$(LIST)</span>&quot;</span></span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;dir = <span class="subst">$(dir $(LIST)</span>)&quot;</span></span><br></pre></td></tr></table></figure>
<p>执行make命令，运行结果为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line">LIST = /home/wit/banana.c /usr/include/stdio.h</span><br><span class="line"><span class="built_in">dir</span> = /home/wit/ /usr/include/</span><br></pre></td></tr></table></figure>

<p><strong>notdir函数：取文件名</strong><br><code>notdir</code>函数和<code>dir</code>函数实现完全相反的功能：从一个文件路径名中去文件名，而不是目录。notdir函数的使用方法和dir函数相同。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: all</span><br><span class="line">LIST = /home/wit/banana.c /usr/include/stdio.h</span><br><span class="line">all:</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;LIST = <span class="subst">$(LIST)</span>&quot;</span></span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;file = <span class="subst">$(notdir $(LIST)</span>)&quot;</span></span><br></pre></td></tr></table></figure>
<p>执行make命令，运行结果为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line">LIST = /home/wit/banana.c /usr/include/stdio.h</span><br><span class="line">file = banana.c stdio.h</span><br></pre></td></tr></table></figure>

<p><strong>suffix函数：取文件名后缀</strong><br>suffix函数从一系列文件名序列中，取出各个文件名的后缀。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$(suffix NAMES…)</span><br></pre></td></tr></table></figure>
<p>文件名的后缀是文件名中以点号 . 开始（包括点号）的部分。<strong>若文件名没有后缀， suffix函数则返回空</strong>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: all</span><br><span class="line">LIST = /home/wit/banana.c /usr/include/stdio.h</span><br><span class="line">all:</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;LIST = <span class="subst">$(LIST)</span>&quot;</span></span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;suffix = <span class="subst">$(suffix $(LIST)</span>)&quot;</span></span><br></pre></td></tr></table></figure>
<p>执行make命令，运行结果为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line">LIST = /home/wit/banana.c /usr/include/stdio.h</span><br><span class="line">suffix = .c .h</span><br></pre></td></tr></table></figure>

<p><strong>basename函数：取文件名前缀</strong><br>basename函数从一系列文件名序列中，取出各个文件名的前缀部分：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">basename</span> NAMES…)</span><br></pre></td></tr></table></figure>

<p>如果一个文件名中包括多个点号，basename函数返回最后一个点号之前的文件名部分；<strong>如果一个文件名没有前缀，函数返回原字符串</strong>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: all</span><br><span class="line">LIST = /home/wit/banana.c /usr/include/vmlinux.lds.S</span><br><span class="line">all:</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;LIST = <span class="subst">$(LIST)</span>&quot;</span></span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;basename = <span class="subst">$(basename $(LIST)</span>)&quot;</span></span><br></pre></td></tr></table></figure>

<p>执行make命令，运行结果为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line">LIST = /home/wit/banana.c /usr/include/vmlinux.lds.S</span><br><span class="line"><span class="built_in">basename</span> = /home/wit/banana /usr/include/vmlinux.lds</span><br></pre></td></tr></table></figure>


<p><strong>addsuffix函数：给文件名加后缀</strong><br>addsuffix函数的作用是：给文件列表中的每个文件名添加后缀SUFFIX</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$(addsuffix SUFFIX, NAMES…)</span><br></pre></td></tr></table></figure>
<p>使用示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: all</span><br><span class="line">LIST = apple banana peach</span><br><span class="line">all:</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;LIST = <span class="subst">$(LIST)</span>&quot;</span></span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;addsuffix = <span class="subst">$(addsuffix .c, $(LIST)</span>)&quot;</span></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line">LIST = apple banana peach</span><br><span class="line">addsuffix = apple.c banana.c peach.c</span><br></pre></td></tr></table></figure>

<p><strong>addprefix函数：给文件名加前缀</strong><br>addprefix函数的作用是：给文件列表中的每个文件名添加一个前缀PREFIX</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$(addprefix PREFIX, NAMES…)</span><br></pre></td></tr></table></figure>
<p>使用示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: all</span><br><span class="line">LIST = apple.c banana.c peach.c</span><br><span class="line">all:</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;LIST = <span class="subst">$(LIST)</span>&quot;</span></span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;addsuffix = <span class="subst">$(addprefix /home/wit/, $(LIST)</span>)&quot;</span></span><br></pre></td></tr></table></figure>
<p>执行make命令，运行结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line">LIST = apple.c banana.c peach.c</span><br><span class="line">addsuffix = /home/wit/apple.c /home/wit/banana.c /home/wit/peach.c</span><br></pre></td></tr></table></figure>

<p><strong>join函数：单词连接</strong></p>
<p>join函数的作用是：将字符串LIST1和字符串LIST2的各个单词依次连接，合并为新的单词构成的字符串</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">join</span> LIST1,LIST2)</span><br></pre></td></tr></table></figure>
<p>使用示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: all</span><br><span class="line">LIST1 = apple banana peach</span><br><span class="line">LIST2 = .c .h .s</span><br><span class="line">LIST  = $(<span class="built_in">join</span> $(LIST1), $(LIST2))</span><br><span class="line">all:</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;LIST1 = <span class="subst">$(LIST1)</span>&quot;</span></span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;LIST2 = <span class="subst">$(LIST2)</span>&quot;</span></span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;LIST = <span class="subst">$(LIST)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line">LIST1 = apple banana peach</span><br><span class="line">LIST2 = .c .h .s</span><br><span class="line">LIST = apple.c banana.h peach.s</span><br></pre></td></tr></table></figure>
<p>如果两个字符串中的单词个数不相等，则只合并前面的单词，剩下的单词不合并。如下面的Makefile：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: all</span><br><span class="line">LIST1 = apple banana peach</span><br><span class="line">LIST2 = .c .h </span><br><span class="line">LIST  = $(<span class="built_in">join</span> $(LIST1), $(LIST2))</span><br><span class="line">all:</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;LIST1 = <span class="subst">$(LIST1)</span>&quot;</span></span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;LIST2 = <span class="subst">$(LIST2)</span>&quot;</span></span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;LIST = <span class="subst">$(LIST)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line">LIST1 = apple banana peach</span><br><span class="line">LIST2 = .c .h </span><br><span class="line">LIST = apple.c banana.h peach</span><br></pre></td></tr></table></figure>
<p>因为LIST2中只有2个单词，所以我们可以看到最后一个单词peach没有参与合并，但仍作为一个新的单词合并到LIST变量中。</p>
<p><strong>wildcard函数：列出所有符号匹配模式的文件</strong><br>wildcard函数的作用是：列出当前目录下所有符合PATTREN模式的文件名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$(wildcard PATTERN)</span><br></pre></td></tr></table></figure>
<p>其中PATTREN可以使用shell能识别的通配符：？、*等。</p>
<p>使用示例：列出当前目录下的所有C文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: all</span><br><span class="line">LIST  = $(wildcard *.c)</span><br><span class="line">all:</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;LIST = <span class="subst">$(LIST)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>执行make命令，运行结果为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ls</span></span><br><span class="line">add.c  add.h  hello.c  main.c  makefile  sub.c  sub.h</span><br><span class="line"><span class="comment"># make</span></span><br><span class="line">LIST = hello.c main.c add.c sub.c</span><br></pre></td></tr></table></figure>

<h2 id="foreach函数"><a href="#foreach函数" class="headerlink" title="foreach函数"></a>foreach函数</h2><p>在Makefile中如果想做一些循环或遍历操作时，可以使用foreach函数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$(foreach VAR,LIST,TEXT)</span><br></pre></td></tr></table></figure>
<p>foreach函数的工作过程是：把<code>LIST</code>中使用<code>空格</code>分割的单词依次取出并<strong>赋值给变量VAR</strong>，然后<strong>执行TEXT表达式</strong>。<br>重复这个过程，直到遍历完LIST中的最后一个单词。函数的返回值是TEXT多次计算的结果。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tree</span></span><br><span class="line">.</span><br><span class="line">├── keyboard</span><br><span class="line">│   └── key.c</span><br><span class="line">├── lcd</span><br><span class="line">│   └── lcd.c</span><br><span class="line">├── makefile</span><br><span class="line">├── media</span><br><span class="line">│   └── decode.c</span><br><span class="line">└── usb</span><br><span class="line">    └── usb.c</span><br></pre></td></tr></table></figure>
<p>现在编写一个Makefile，自动搜索各个目录下的C源文件。Makefile的写法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: all</span><br><span class="line"><span class="built_in">dirs</span> = lcd usb media keyboard</span><br><span class="line">srcs = $(foreach <span class="built_in">dir</span>, $(<span class="built_in">dirs</span>), $(wildcard $(<span class="built_in">dir</span>)/*))</span><br><span class="line">all:</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;srcs = <span class="subst">$(srcs)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>执行make命令，运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line">srcs =  lcd/lcd.c  usb/usb.c  media/decode.c  keyboard/key.c</span><br></pre></td></tr></table></figure>
<p>当然，我们也可以根据搜索到的这些C源文件名，生成对应的目标文件名，对应的Makefile如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: all</span><br><span class="line"><span class="built_in">dirs</span> = lcd usb media keyboard</span><br><span class="line">srcs = $(foreach <span class="built_in">dir</span>, $(<span class="built_in">dirs</span>), $(wildcard $(<span class="built_in">dir</span>)/*.c))</span><br><span class="line">objs = $(foreach src, $(srcs), $(subst .c,.o,$(src)))</span><br><span class="line">all:</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;srcs = <span class="subst">$(srcs)</span>&quot;</span></span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;objs = <span class="subst">$(objs)</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>执行make命令，运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line">srcs =  lcd/lcd.c  usb/usb.c  media/decode.c  keyboard/key.c</span><br><span class="line">objs =  lcd/lcd.o  usb/usb.o  media/decode.o  keyboard/key.o</span><br></pre></td></tr></table></figure>

<h2 id="if-函数"><a href="#if-函数" class="headerlink" title="if 函数"></a>if 函数</h2><p>Makefile 中的 if 函数提供了在一个函数上下文中实现条件判断的功能，类似于<code>ifeq</code>关键字，if函数的使用格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$(<span class="keyword">if</span> CONDITION,THEN-PART)</span><br><span class="line">$(<span class="keyword">if</span> CONDITION,THEN-PART[,ELSE-PART])</span><br></pre></td></tr></table></figure>
<p>if 函数的第一个参数 CONDITION表示条件判断，展开后如果非空，则条件为真，执行 THEN-PART部分；否则，如果有ELSE-PART部分，则执行ELSE-PART部分。</p>
<p>if函数的返回值即执行分支（THEN-PART或ELSE-PART）的表达式值。如果没有ELSE-PART，则返回一个空字符串。</p>
<p>if 函数使用示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: all</span><br><span class="line">install_path = $(<span class="keyword">if</span> $(install__path), $(install__path), /usr/local)</span><br><span class="line">all:</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;install_path = <span class="subst">$(install_path)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>当我们使用make编译安装一个软件时，通常会指定一个安装路径，如果没有指定的话，则会默认安装在/usr/local目录下。在上面这个Makefile中，我们定义了一个install_path变量，通过if函数来判断这个变量是否为空，来决定最终的安装路径。执行make命令，可以看到运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line">install_path =  /usr/local</span><br><span class="line"><span class="comment"># make install_path=/opt</span></span><br><span class="line">install_path = /opt</span><br></pre></td></tr></table></figure>

<h2 id="call-函数"><a href="#call-函数" class="headerlink" title="call 函数"></a>call 函数</h2><p>如果想调用用户自定义的函数，则只能使用call函数来间接调用了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$(call &lt;expression&gt;,&lt;parm1&gt;,&lt;parm2&gt;,&lt;parm3&gt;...)</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: all</span><br><span class="line">define func</span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;pram1 = <span class="subst">$(0)</span>&quot;</span></span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;pram2 = <span class="subst">$(1)</span>&quot;</span></span><br><span class="line">	@<span class="built_in">echo</span> <span class="string">&quot;pram3 = <span class="subst">$(2)</span>&quot;</span></span><br><span class="line">endef</span><br><span class="line">all:</span><br><span class="line">	$(call func,hello world,hahaha)</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line">pram1 = func</span><br><span class="line">pram2 = hello world</span><br><span class="line">pram3 = hahaha</span><br></pre></td></tr></table></figure>

<h2 id="origin函数"><a href="#origin函数" class="headerlink" title="origin函数"></a>origin函数</h2><p>origin函数的作用就是告诉你，你所关注的一个变量是从哪里来的。函数的使用格式为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$(origin &lt;variable&gt;)</span><br></pre></td></tr></table></figure>
<p>如果变量没有定义，origin函数的返回值为：<code>undefined</code>，不同的返回值代表变量的类型不同。常见的返回值如下;</p>
<p><code>default</code>：变量是一个默认的定义，比如 CC 这个变量<br><code>file</code>：这个变量被定义在Makefile中<br><code>command line</code>：这个变量是被命令行定义的<br><code>overrid</code>e：这个变量是被override指示符重新定义过的<br><code>automatic</code>：一个命令运行中的自动化变量<br>使用示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: all</span><br><span class="line">WEB = www.123.cc</span><br><span class="line">web_type = $(origin WEB)</span><br><span class="line">all:</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;web_type = <span class="subst">$(web_type)</span>&quot;</span></span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;cc_type  = <span class="subst">$(origin CC)</span>&quot;</span></span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;cmd_type = <span class="subst">$(origin CMD)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>执行make命令，运行结果为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line">web_type = file</span><br><span class="line">cc_type = default</span><br><span class="line">cmd_type = undefined</span><br><span class="line"><span class="comment"># make CMD=pwd</span></span><br><span class="line">web_type = file</span><br><span class="line">cc_type = default</span><br><span class="line">cmd_type = <span class="built_in">command</span> line</span><br></pre></td></tr></table></figure>

<h2 id="shell-函数"><a href="#shell-函数" class="headerlink" title="shell 函数"></a>shell 函数</h2><p>如果你想在Makefile中运行shell命令，可以使用 shell 函数来完成这个功能。shell 函数的参数是shell命令，它和反引号 `` 具有相同的功能。shell命令的运行结果即为shell函数的返回值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: all</span><br><span class="line">current_path = $(shell <span class="built_in">pwd</span>)</span><br><span class="line">all:</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;current_path = <span class="subst">$(current_path)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>执行make命令，可以看到运行结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root@ubuntu:/home/makefile/demo<span class="comment"># make</span></span><br><span class="line">current_path = /home/makefile/demo</span><br></pre></td></tr></table></figure>

<h2 id="error-和-warning-函数"><a href="#error-和-warning-函数" class="headerlink" title="error 和 warning 函数"></a>error 和 warning 函数</h2><p>make提供了两个可以控制make运行方式的函数：error和warning。如果这两个函数在Makefile中使用，当make执行过程中检测到某些错误，就可以给用户提供一些信息，并且可以控制make的是否继续执行下去。</p>
<p><strong>error 函数</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$(error TEXT…)</span><br></pre></td></tr></table></figure>
<p>使用示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: all</span><br><span class="line">all:</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;make command start...&quot;</span></span><br><span class="line">    $(error find a error)</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;make command end...&quot;</span></span><br></pre></td></tr></table></figure>
<p>当执行make命令时，make会执行默认目标all下的命令，当遇到error函数时，就会给用户一个错误提示信息，并终止make的继续执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line">makefile:5: *** find a error.  Stop.</span><br></pre></td></tr></table></figure>
<p>需要注意的是：error函数是在函数被调用时才会提示信息并终止make的继续执行。如果函数出现在命令中，或者出现在一个递归变量的定义里，在读取Makefile时不会出现错误。而只有包含error函数引用的命令执行时，或者包含这个函数的定义变量被展开时，才会提示错误信息TEXT，并终止make的运行。</p>
<p><strong>warning 函数</strong><br>warning函数跟error函数类似，也会给用户提示信息，唯一的区别是：warning函数不会终止make的运行，make会继续运行下去。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$(warning TEXT…)</span><br></pre></td></tr></table></figure>
<p>使用示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: all</span><br><span class="line">all:</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;make command start...&quot;</span></span><br><span class="line">    $(warning find a error)</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;make command end...&quot;</span></span><br></pre></td></tr></table></figure>
<p>执行make命令，运行结果为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line">makefile:5: find a error</span><br><span class="line">make <span class="built_in">command</span> start...</span><br><span class="line">make <span class="built_in">command</span> end...</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Makefile</category>
      </categories>
      <tags>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>override+条件判断+通配符</title>
    <url>/2021/05/14/override-%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD/</url>
    <content><![CDATA[<h2 id="Makefile-override-指示符"><a href="#Makefile-override-指示符" class="headerlink" title="Makefile override 指示符"></a>Makefile override 指示符</h2><p>一个在Makefile中定义的变量，如果在执行make命令时又定义了一次，那么它将替代在Makefile中出现的同名变量。</p>
<span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: all</span><br><span class="line">web = www.123.cc</span><br><span class="line">all:</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;web = <span class="subst">$(web)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>在上面的Makefile中，我们定义了一个变量：web，在执行make时如果重新给web赋值，然后在Makefile中就可以打印出重新赋的值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line">web = www.123.cc</span><br><span class="line"><span class="comment"># make web=456.com</span></span><br><span class="line">web = 456.com</span><br></pre></td></tr></table></figure>

<p>如果不希望在命令行指定的变量值替代在Makefile中的原来定义，那么我们可以在Makefile中使用指示符 <code>override</code> 对这个变量进行声明：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: all</span><br><span class="line">override web = www.123.cc</span><br><span class="line">all:</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;web = <span class="subst">$(web)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>一个变量使用override修饰后，用户在命令行中重新赋值，不会对Makefile中的变量定义产生影响，无论用户在命令行中如何修改，make始终打印的是Makefile中定义的值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make web=456.com</span></span><br><span class="line">web = www.123.cc</span><br></pre></td></tr></table></figure>

<h3 id="override存在的意义"><a href="#override存在的意义" class="headerlink" title="override存在的意义"></a>override存在的意义</h3><p>比如在编译程序时，无论在命令行指定什么参数，编译器在编译时必需打开 <code>-Wall</code>选项，那么在Makefile中的CFLAGS应该这样定义：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: all</span><br><span class="line">override CFLAGS += -Wall</span><br><span class="line">all:</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;CFLAGS = <span class="subst">$(CFLAGS)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>当执行make命令时，默认的CFLAGS是<code>-Wall</code>；当执行<code>make CFLAGS=-g</code>时，CFLAGS就变成了 <code>-Wall -g</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line">CFLAGS = -Wall</span><br><span class="line"><span class="comment"># make CFLAGS=-g</span></span><br><span class="line">CFLAGS = -g -Wall</span><br></pre></td></tr></table></figure>
<p>如果在Makefile中定义CFLAGS变量时，不使用override修饰：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: all</span><br><span class="line">CFLAGS += -Wall</span><br><span class="line">all:</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;CFLAGS = <span class="subst">$(CFLAGS)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>再次执行上面的make命令，运行结果就发生了变化：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line">CFLAGS = -Wall</span><br><span class="line"><span class="comment"># make CFLAGS=-g</span></span><br><span class="line">CFLAGS = -g</span><br></pre></td></tr></table></figure>
<p>这就跟我们预先设定的不一致了：当在命令行中给CFLAGS追加赋值时，原来的-Wall选项就被覆盖掉了。而使用override修饰就不会发生这种情况。</p>
<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><p>使用条件判断，可以让make在编译程序时，根据不同的情况，执行不同的分支：可以执行不同的命令，使用不同的编译参数，生成不同的目标。<br>在Makefile中，可以使用<code>ifeq</code>、<code>ifneq</code>、<code>ifdef</code>、<code>ifndef</code> 等关键字来进行条件判断。</p>
<h3 id="ifeq-关键字"><a href="#ifeq-关键字" class="headerlink" title="ifeq 关键字"></a>ifeq 关键字</h3><p>ifeq关键字用来判断两个参数是够相等，相等时条件成立为true，不相等为false。ifeq一般和变量结合使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mode = debug</span><br><span class="line">hello: hello.c</span><br><span class="line">ifeq ($(mode),debug)</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;debug mode&quot;</span> </span><br><span class="line">    gcc -g -o hello hello.c</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;release mode&quot;</span></span><br><span class="line">    gcc -o hello hello.c</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>当使用make编译程序时，就会执行debug分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line">debug mode</span><br><span class="line">gcc -g -o hello hello.c</span><br></pre></td></tr></table></figure>

<p>条件判断语句由三个关键字组成：<code>ifeq</code>、<code>else</code>、<code>endif</code>。<br><code>ifeq</code>后面的比较语句使用小括号包起来，ifeq和小括号之间要用空格隔开，小括号里的两个参数用逗号隔开。<br>当小括号里的条件满足时，make就会执行这个分支的命令，否则执行else部分。endif表示一个条件语句的结束。</p>
<h3 id="ifneq-关键字"><a href="#ifneq-关键字" class="headerlink" title="ifneq 关键字"></a>ifneq 关键字</h3><p><code>ifneq</code> 关键字和ifeq关键字恰恰相反，用来判断参数是否不相等。当比较的参数不相等时，条件语句才成立，值为true，否则为false。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mode = debug</span><br><span class="line">hello: hello.c</span><br><span class="line">ifneq ($(mode),)</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;debug mode&quot;</span> </span><br><span class="line">    gcc -g -o hello hello.c</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;release mode&quot;</span></span><br><span class="line">    gcc -o hello hello.c</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>在上面的语句中，我们让mode变量和一个空字符串比较，不相等，条件语句成立，执行if 分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line">  debug mode</span><br><span class="line">  gcc -g -o hello hello.c</span><br></pre></td></tr></table></figure>
<h3 id="ifdef-关键字"><a href="#ifdef-关键字" class="headerlink" title="ifdef 关键字"></a>ifdef 关键字</h3><p><code>ifdef</code> 关键字用来判断一个变量是否已经定义。如果变量的值非空（在Makefile中，<strong>没有定义的变量的值为空</strong>），表达式为真。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mode = </span><br><span class="line">hello: hello.c</span><br><span class="line">ifdef mode</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;debug mode&quot;</span> </span><br><span class="line">    gcc -g -o hello hello.c</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;release mode&quot;</span></span><br><span class="line">    gcc -o hello hello.c</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>如果在Makefile定义一个变量没有赋值，或者没有定义变量，那么这个变量的值都为空。在上面的Makefile中，当使用ifdef判断时，因为mode的值为空，所以make会执行else分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line">release mode</span><br><span class="line">gcc -o hello hello.c</span><br></pre></td></tr></table></figure>
<h3 id="ifndef-关键字"><a href="#ifndef-关键字" class="headerlink" title="ifndef 关键字"></a>ifndef 关键字</h3><p>ifndef关键字和ifdef相反，如果一个变量没有定义，表达式为真。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mode = </span><br><span class="line">hello: hello.c</span><br><span class="line">ifndef mode</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;debug mode&quot;</span> </span><br><span class="line">    gcc -g -o hello hello.c</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;release mode&quot;</span></span><br><span class="line">    gcc -o hello hello.c</span><br><span class="line">endif</span><br></pre></td></tr></table></figure>
<p>如上面的Makefile，如果没有定义mode，则表达式为真，make执行if分支：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line">debug mode</span><br><span class="line">gcc -o hello hello.c</span><br></pre></td></tr></table></figure>


<h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><p>在Makefile中表示一个文件名时，可以使用通配符。在Makefile中可以使用的通配符有：* 、? 、 […]。通配符的使用方法和含义和在shell中一样。比如：*.c 表示当前目录下所有以“.c”结尾的文件。除此之外，Makefile还有经常使用的几个自动变量也可以看做特殊通配符：</p>
<p><code>$@</code>：所有目标文件<br><code>$^</code>：目标依赖的所有文件<br><code>$&lt;</code>：第一个依赖文件<br><code>$?</code>：所有更新过的依赖文件<br>在Makefile中，通配符主要用在两个场合：</p>
<p>用在规则的目标和依赖中：make在读取Makefile时会自动对其进行匹配处理（通配符展开）。如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">test</span>: *.o</span><br><span class="line">    gcc -o <span class="variable">$@</span> $^</span><br><span class="line">*.o: *.c</span><br><span class="line">    gcc -c $^</span><br></pre></td></tr></table></figure>
<p>用在规则的命令中：通配符的通配处理在shell执行命令时完成。如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clean:</span><br><span class="line">    <span class="built_in">rm</span> -f *.o</span><br></pre></td></tr></table></figure>
<p>除了以上两种情况，在其他地方都不能直接使用通配符。需要一些函数（如wildcard）来实现。如果想列举当前目录下的所有C文件，可以直接使用wildcard函数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$(wildcard *.c)</span><br></pre></td></tr></table></figure>

<p><strong>波浪线 ~</strong><br>在Linux系统中，波浪线表示HOME目录，以波浪线表示的文件名也表示特殊的含义。以我当前使用的Ubuntu为例，登录用户名为wit，则</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~：表示/home/wit这个目录</span><br><span class="line">~/.bashrc：表示/home/wit/.bashrc文件</span><br><span class="line">~wit：表示用户wit的HOME目录，即/home/wit</span><br><span class="line">~root：表示用户root的HOME目录，即/root</span><br><span class="line">~wit/.bashrc：表示/home/wit/.bashrc文件</span><br><span class="line">~root/.bashrc：表示/root/.bashrc文件</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Makefile</category>
      </categories>
      <tags>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile递归</title>
    <url>/2021/05/13/Makefile%E9%80%92%E5%BD%92/</url>
    <content><![CDATA[<h2 id="Makefile-递归执行"><a href="#Makefile-递归执行" class="headerlink" title="Makefile 递归执行"></a>Makefile 递归执行</h2><p>在实际工程项目中，各个源文件通常存放在各个不同的目录中，make在编译工程项目时，会依次遍历各个不同的子目录，编译每个子目录下的源文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make -C subdir1 subdir2 subdir3 ...</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>make会依次到subdir1、subdir2、subdir3子目录下去执行make程序。上面的make 命令就等价于：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cd subdir1 &amp;&amp; $(MAKE)</span></span><br><span class="line"><span class="comment"># cd subdir2 &amp;&amp; $(MAKE)</span></span><br><span class="line"><span class="comment"># cd subdir3 &amp;&amp; $(MAKE)</span></span><br></pre></td></tr></table></figure>
<p>当然，在subdir1、subdir2、subdir3子目录下，也得有对应的<code>Makefile</code>文件，否则make就会运行报错。为了给大家演示下make是如何遍历各个子目录的，我们新建一个工程如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># tree</span></span><br><span class="line">.</span><br><span class="line">├── makefile</span><br><span class="line">├── subdir1</span><br><span class="line">│   └── makefile</span><br><span class="line">├── subdir2</span><br><span class="line">│   └── makefile</span><br><span class="line">└── subdir3</span><br><span class="line">    └── makefile</span><br><span class="line">3 directories, 4 files</span><br></pre></td></tr></table></figure>
<p>这个项目有3个子目录，每个子目录下分别有对应的源文件和Makefile，为了简化，我们只添加了Makefile文件，每个Makefile文件的内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#subdir1/makefile:</span></span><br><span class="line">all:</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;make in subdir1&quot;</span></span><br><span class="line"><span class="comment">#subdir2/makefile:</span></span><br><span class="line">all:</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;make in subdir2&quot;</span></span><br><span class="line"><span class="comment">#subdir3/makefile:</span></span><br><span class="line">all:</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;make in subdir3&quot;</span></span><br></pre></td></tr></table></figure>
<p>项目底层目录的Makefile文件内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY:all</span><br><span class="line">all:</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;make start&quot;</span></span><br><span class="line">    make -C subdir1</span><br><span class="line">    make -C subdir2</span><br><span class="line">    make -C subdir3</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;make done&quot;</span></span><br></pre></td></tr></table></figure>
<p>在项目根目录下执行make命令，可以看到make的顺序如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line">make start</span><br><span class="line">make -C subdir1</span><br><span class="line">make[1]: Entering directory <span class="string">&#x27;/home/makefile/demo/subdir1&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;make in subdir1&quot;</span></span><br><span class="line">make <span class="keyword">in</span> subdir1</span><br><span class="line">make[1]: Leaving directory <span class="string">&#x27;/home/makefile/demo/subdir1&#x27;</span></span><br><span class="line">make -C subdir2</span><br><span class="line">make[1]: Entering directory <span class="string">&#x27;/home/makefile/demo/subdir2&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;make in subdir2&quot;</span></span><br><span class="line">make <span class="keyword">in</span> subdir2</span><br><span class="line">make[1]: Leaving directory <span class="string">&#x27;/home/makefile/demo/subdir2&#x27;</span></span><br><span class="line">make -C subdir3</span><br><span class="line">make[1]: Entering directory <span class="string">&#x27;/home/makefile/demo/subdir3&#x27;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;make in subdir3&quot;</span></span><br><span class="line">make <span class="keyword">in</span> subdir3</span><br><span class="line">make[1]: Leaving directory <span class="string">&#x27;/home/makefile/demo/subdir3&#x27;</span></span><br><span class="line">make <span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>通过打印信息我们看到，make通过 -C subdir参数，会分别到各个子目录下去执行，解析各个子目录下的Makefile并运行，遍历完所有的子目录，make最后才会退出。</p>
<h2 id="递归传递变量"><a href="#递归传递变量" class="headerlink" title="递归传递变量"></a>递归传递变量</h2><p>当make依次遍历到各个子目录下解析新的Makefile时，项目顶层目录的主Makefile定义的一些变量，是如何传递到子目录的Makefile文件中的呢？我们还是以上面的Makefile为例，在项目顶层目录的Makefile中，定义了一个变量：<code>WEB=test</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY:all</span><br><span class="line">WEB = <span class="built_in">test</span></span><br><span class="line">all:</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;make start&quot;</span></span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;WEB = <span class="subst">$(WEB)</span>&quot;</span></span><br><span class="line">    make -C subdir1</span><br><span class="line">    make -C subdir2</span><br><span class="line">    make -C subdir3</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;make done&quot;</span></span><br></pre></td></tr></table></figure>
<p>然后在各个子目录的Makefile下面分别打印这个WEB变量的值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#subdir1/makefile:</span></span><br><span class="line">all:</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;make in subdir1&quot;</span></span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;sundir1:WEB = <span class="subst">$(WEB)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>在工程项目的顶层目录执行make命令，可以看到WEB变量在各个子目录下的打印值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line">make start</span><br><span class="line">WEB = <span class="built_in">test</span></span><br><span class="line">make -C subdir1</span><br><span class="line">make[1]: Entering directory <span class="string">&#x27;/home/makefile/demo/subdir1&#x27;</span></span><br><span class="line">make <span class="keyword">in</span> subdir1</span><br><span class="line">sundir1:WEB = </span><br><span class="line">make[1]: Leaving directory <span class="string">&#x27;/home/makefile/demo/subdir1&#x27;</span></span><br><span class="line">make -C subdir2</span><br><span class="line">make[1]: Entering directory <span class="string">&#x27;/home/makefile/demo/subdir2&#x27;</span></span><br><span class="line">make <span class="keyword">in</span> subdir2</span><br><span class="line">sundir2: WEB = </span><br><span class="line">make[1]: Leaving directory <span class="string">&#x27;/home/makefile/demo/subdir2&#x27;</span></span><br><span class="line">make -C subdir3</span><br><span class="line">make[1]: Entering directory <span class="string">&#x27;/home/makefile/demo/subdir3&#x27;</span></span><br><span class="line">make <span class="keyword">in</span> subdir3</span><br><span class="line">sundir3: WEB = </span><br><span class="line">make[1]: Leaving directory <span class="string">&#x27;/home/makefile/demo/subdir3&#x27;</span></span><br><span class="line">make <span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>通过打印值我们可以看到：除了在顶层目录的Makefile中WEB变量的值是<code>test</code>，在其他三个子目录中WEB变量的值都是为空，这说明底层目录Makefile中的变量并没有传递到各个子目录中。</p>
<p>修改顶层目录的主Makefile，将变量WEB使用<code>export</code>声明为环境变量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY:all</span><br><span class="line"><span class="built_in">export</span> WEB = <span class="built_in">test</span></span><br><span class="line">all:</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;make start&quot;</span></span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;WEB = <span class="subst">$(WEB)</span>&quot;</span></span><br><span class="line">    make -C subdir1</span><br><span class="line">    make -C subdir2</span><br><span class="line">    make -C subdir3</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;make done&quot;</span></span><br></pre></td></tr></table></figure>
<p>再次运行make命令，通过各个子目录下的打印值可以看到：在主Makefile通过export声明的变量WEB已经正确地传递到各个子目录的Makefile中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line">make start</span><br><span class="line">WEB = <span class="built_in">test</span></span><br><span class="line">make -C subdir1</span><br><span class="line">make[1]: Entering directory <span class="string">&#x27;/home/makefile/demo/subdir1&#x27;</span></span><br><span class="line">make <span class="keyword">in</span> subdir1</span><br><span class="line">sundir1:WEB = <span class="built_in">test</span></span><br><span class="line">make[1]: Leaving directory <span class="string">&#x27;/home/makefile/demo/subdir1&#x27;</span></span><br><span class="line">make -C subdir2</span><br><span class="line">make[1]: Entering directory <span class="string">&#x27;/home/makefile/demo/subdir2&#x27;</span></span><br><span class="line">make <span class="keyword">in</span> subdir2</span><br><span class="line">sundir2: WEB = <span class="built_in">test</span></span><br><span class="line">make[1]: Leaving directory <span class="string">&#x27;/home/makefile/demo/subdir2&#x27;</span></span><br><span class="line">make -C subdir3</span><br><span class="line">make[1]: Entering directory <span class="string">&#x27;/home/makefile/demo/subdir3&#x27;</span></span><br><span class="line">make <span class="keyword">in</span> subdir3</span><br><span class="line">sundir3: WEB = <span class="built_in">test</span></span><br><span class="line">make[1]: Leaving directory <span class="string">&#x27;/home/makefile/demo/subdir3&#x27;</span></span><br><span class="line">make <span class="keyword">done</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Makefile</category>
      </categories>
      <tags>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>yaml解析</title>
    <url>/2021/05/12/yaml%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p><code>YAML</code>（YAML 不是标记语言）是一种人类可读的数据序列化语言。它通常用于配置文件，但也用于数据存储或传输。YAML 本身支持三种基本数据类型：标量（例如字符串、整数和浮点数）、列表和映射（字典/哈希）。我们使用 <code>yaml.v3</code> 包来解析yaml文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go get gopkg.in/yaml.v3</span><br></pre></td></tr></table></figure>
<span id="more"></span>


<h4 id="解析yaml"><a href="#解析yaml" class="headerlink" title="解析yaml"></a>解析yaml</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func Unmarshal(in []byte, out interface&#123;&#125;) (err error)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们使用 Unmarshal来解析yaml yaml文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- name: wanger</span><br><span class="line">  age: 24</span><br><span class="line">  address: beijing</span><br><span class="line">  hobby:</span><br><span class="line">    - literature</span><br><span class="line">    - social</span><br><span class="line">- name: 冬哥</span><br><span class="line">  age: 30</span><br><span class="line">  address: chengdu</span><br><span class="line">  hobby:</span><br><span class="line">    - basketball</span><br><span class="line">    - guitar</span><br><span class="line">- name: 华子</span><br><span class="line">  age: 27</span><br><span class="line">  address: shenzhen</span><br><span class="line">  hobby:</span><br><span class="line">    - 王者荣耀</span><br><span class="line">- name: 乔克</span><br><span class="line">  age: 29</span><br><span class="line">  address: chongqing</span><br><span class="line">  hobby:</span><br><span class="line">    - 阅读</span><br><span class="line">    - 王者荣耀</span><br><span class="line">- name: 夏老师</span><br><span class="line">  age: 27</span><br><span class="line">  address: chengdu</span><br><span class="line">  hobby:</span><br><span class="line">    - 吃吃喝喝</span><br><span class="line">- name: 姜总</span><br><span class="line">  age: 25</span><br><span class="line">  address: shanghai</span><br><span class="line">  hobby:</span><br><span class="line">    - talkshow</span><br><span class="line">- name: 郑哥</span><br><span class="line">  age: 30</span><br><span class="line">  address: beijing</span><br><span class="line">  hobby:</span><br><span class="line">    - 阅读</span><br><span class="line">    - 复读机</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>读取test.yaml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line"> &quot;fmt&quot;</span><br><span class="line"> &quot;gopkg.in/yaml.v2&quot;</span><br><span class="line"> &quot;io/ioutil&quot;</span><br><span class="line"> &quot;gopkg.in/yaml.v3&quot;</span><br><span class="line"> &quot;log&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">type Users struct &#123;</span><br><span class="line"> Name   string      `yaml:&quot;name&quot;`</span><br><span class="line"> Age    int8        `yaml:&quot;age&quot;`</span><br><span class="line"> Address  string `yaml:&quot;address&quot;`</span><br><span class="line"> Hobby []string `yaml:&quot;hobby&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line"> file, err := ioutil.ReadFile(&quot;test.yaml&quot;)</span><br><span class="line"> if err != nil &#123;</span><br><span class="line">  log.Fatal(err)</span><br><span class="line"> &#125;</span><br><span class="line"> var data [7]Users</span><br><span class="line"> err2 := yaml.Unmarshal(file, &amp;data)</span><br><span class="line"></span><br><span class="line"> if err2 != nil &#123;</span><br><span class="line">  log.Fatal(err2)</span><br><span class="line"> &#125;</span><br><span class="line"> for _, v := range data &#123;</span><br><span class="line">  fmt.Println(v)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出内容如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;wanger 24 beijing [literature social]&#125;</span><br><span class="line">&#123;冬哥 30 chengdu [basketball guitar]&#125;</span><br><span class="line">&#123;华子 27 shenzhen [王者荣耀]&#125;</span><br><span class="line">&#123;乔克 29 chongqing [阅读 王者荣耀]&#125;</span><br><span class="line">&#123;夏老师 27 chengdu [吃吃喝喝]&#125;</span><br><span class="line">&#123;姜总 25 shanghai [钓鱼  音乐 美食  酒talkshow]&#125;</span><br><span class="line">&#123;郑哥 30 beijing [阅读 复读机]&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="生成yaml"><a href="#生成yaml" class="headerlink" title="生成yaml"></a><strong>生成yaml</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">func Marshal(in interface&#123;&#125;) (out []byte, err error)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们使用 Marshal来生成yaml，生成一个关于我们团队信息的yaml文件吧 可以通过定义结构体yaml标签来自定义输出的yaml文件的键名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line"> &quot;fmt&quot;</span><br><span class="line"> &quot;gopkg.in/yaml.v3&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">type Users struct &#123;</span><br><span class="line"> Name   string      `yaml:&quot;name&quot;`</span><br><span class="line"> Age    int8        `yaml:&quot;age&quot;`</span><br><span class="line"> Address  string `yaml:&quot;address&quot;`</span><br><span class="line"> Hobby []string `yaml:&quot;hobby&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"> wanger := Users&#123;</span><br><span class="line">  Name: &quot;wanger&quot;,</span><br><span class="line">  Age:  24,</span><br><span class="line">  Address: &quot;beijing&quot;,</span><br><span class="line">  Hobby: []string&#123;&quot;literature&quot;, &quot;social&quot;&#125;,</span><br><span class="line"> &#125;</span><br><span class="line"> dongdong := Users&#123;</span><br><span class="line">  Name: &quot;冬哥&quot;,</span><br><span class="line">  Age:  30,</span><br><span class="line">  Address: &quot;chengdu&quot;,</span><br><span class="line">  Hobby: []string&#123;&quot;basketball&quot;, &quot;guitar&quot;&#125;,</span><br><span class="line"> &#125;</span><br><span class="line"> xialaoshi := Users&#123;</span><br><span class="line">  Name: &quot;夏老师&quot;,</span><br><span class="line">  Age:  29,</span><br><span class="line">  Address: &quot;chengdu&quot;,</span><br><span class="line">  Hobby: []string&#123;&quot;吃吃喝喝&quot;&#125;,</span><br><span class="line"> &#125;</span><br><span class="line"> huazai := Users&#123;</span><br><span class="line">  Name: &quot;华子&quot;,</span><br><span class="line">  Age:  28,</span><br><span class="line">  Address: &quot;shenzhen&quot;,</span><br><span class="line">  Hobby: []string&#123;&quot;王者荣耀&quot;&#125;,</span><br><span class="line"> &#125;</span><br><span class="line"> qiaoke := Users&#123;</span><br><span class="line">  Name: &quot;乔克&quot;,</span><br><span class="line">  Age:  30,</span><br><span class="line">  Address: &quot;chongqing&quot;,</span><br><span class="line">  Hobby: []string&#123;&quot;阅读&quot;, &quot;王者荣耀&quot;&#125;,</span><br><span class="line"> &#125;</span><br><span class="line"> jiangzong := Users&#123;</span><br><span class="line">  Name: &quot;姜总&quot;,</span><br><span class="line">  Age:  25,</span><br><span class="line">  Address: &quot;shanghai&quot;,</span><br><span class="line">  Hobby: []string&#123;&quot;钓鱼&quot;,&quot;音乐&quot;,&quot;美食&quot;,&quot;酒&quot;&#125;,</span><br><span class="line"> &#125;</span><br><span class="line"> zhengge := Users&#123;</span><br><span class="line">  Name: &quot;郑哥&quot;,</span><br><span class="line">  Age:  30,</span><br><span class="line">  Address: &quot;beijing&quot;,</span><br><span class="line">  Hobby: []string&#123;&quot;阅读&quot;, &quot;复读机&quot;&#125;,</span><br><span class="line"> &#125;</span><br><span class="line">    userlist:=[7]Users&#123;wanger,dongdong,huazai,qiaoke,xialaoshi,jiangzong,zhengge&#125;</span><br><span class="line"></span><br><span class="line"> yamlData, err := yaml.Marshal(&amp;userlist)</span><br><span class="line"></span><br><span class="line"> if err != nil &#123;</span><br><span class="line">  fmt.Printf(&quot;Error while Marshaling. %v&quot;, err)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> fmt.Println(string(yamlData))</span><br><span class="line">    fileName := &quot;test.yaml&quot;</span><br><span class="line">    err = ioutil.WriteFile(fileName, yamlData, 0644)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        panic(&quot;Unable to write data into the file&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>生成的yaml信息如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- name: wanger</span><br><span class="line">  age: 24</span><br><span class="line">  address: beijing</span><br><span class="line">  hobby:</span><br><span class="line">    - literature</span><br><span class="line">    - social</span><br><span class="line">- name: 冬哥</span><br><span class="line">  age: 30</span><br><span class="line">  address: chengdu</span><br><span class="line">  hobby:</span><br><span class="line">    - basketball</span><br><span class="line">    - guitar</span><br><span class="line">- name: 华子</span><br><span class="line">  age: 27</span><br><span class="line">  address: shenzhen</span><br><span class="line">  hobby:</span><br><span class="line">    - 王者荣耀</span><br><span class="line">- name: 乔克</span><br><span class="line">  age: 29</span><br><span class="line">  address: chongqing</span><br><span class="line">  hobby:</span><br><span class="line">    - 阅读</span><br><span class="line">    - 王者荣耀</span><br><span class="line">- name: 夏老师</span><br><span class="line">  age: 27</span><br><span class="line">  address: chengdu</span><br><span class="line">  hobby:</span><br><span class="line">    - 吃吃喝喝</span><br><span class="line">- name: 姜总</span><br><span class="line">  age: 25</span><br><span class="line">  address: shanghai</span><br><span class="line">  hobby:</span><br><span class="line">    - 钓鱼  </span><br><span class="line">    - 音乐</span><br><span class="line">    - 美食 </span><br><span class="line">    - 酒</span><br><span class="line">- name: 郑哥</span><br><span class="line">  age: 30</span><br><span class="line">  address: beijing</span><br><span class="line">  hobby:</span><br><span class="line">    - 阅读</span><br><span class="line">    - 复读机</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>yaml</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile变量</title>
    <url>/2021/05/12/Makefile%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h2 id="Makefile-变量"><a href="#Makefile-变量" class="headerlink" title="Makefile 变量"></a>Makefile 变量</h2><p>为了更好地编写和维护Makefile，在Makefile中通常会使用很多变量。我们可以在Makefile中定义一个变量val，使用使用 <code>$(val)</code> 或 <code>$&#123;val&#125;</code> 的形式去引用它。</p>
<span id="more"></span>

<p>以上面的Makefile为例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: clean</span><br><span class="line">a.out: hello.o module.o</span><br><span class="line">    gcc -o a.out hello.o module.o</span><br><span class="line">hello.o: hello.c</span><br><span class="line">    gcc -c -o hello.o hello.c</span><br><span class="line">module.o: module.c</span><br><span class="line">    gcc -c -o module.o module.c</span><br><span class="line">clean:</span><br><span class="line">    <span class="built_in">rm</span> -f a.out hello.o</span><br></pre></td></tr></table></figure>
<p>我们可以定义一些变量，分别表示编译器名称、目标、目标依赖文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: clean</span><br><span class="line">CC  = gcc</span><br><span class="line">BIN = a.out</span><br><span class="line">OBJS = hello.o module.o</span><br><span class="line">$(BIN): $(OBJS)</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;start compiling...&quot;</span></span><br><span class="line">    @<span class="built_in">echo</span> $(CC)</span><br><span class="line">    $(CC) -o $(BIN) $(OBJS)</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;compile done&quot;</span></span><br><span class="line">hello.o: hello.c</span><br><span class="line">    $(CC) -c -o hello.o hello.c</span><br><span class="line">module.o: module.c</span><br><span class="line">    $(CC) -c -o module.o module.c</span><br><span class="line">clean:</span><br><span class="line">    <span class="built_in">rm</span> -f $(BIN) $(OBJS)</span><br></pre></td></tr></table></figure>

<h3 id="条件赋值"><a href="#条件赋值" class="headerlink" title="条件赋值"></a>条件赋值</h3><p>Makefile中的变量赋值有多种形式，比如：</p>
<ul>
<li>条件赋值：?=</li>
<li>追加赋值：+=<br>条件赋值是指一个变量如果没有被定义过，就直接给它赋值；<br>如果之前被定义过，那么这条赋值语句就什么都不做。如下面的语句：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CC = gcc</span><br><span class="line">CC ?= arm-linux-gnueabi-gcc</span><br><span class="line">$(BIN): $(OBJS)</span><br><span class="line">    @<span class="built_in">echo</span> $(CC)</span><br><span class="line">    $(CC) -o $(BIN) $(OBJS)</span><br></pre></td></tr></table></figure>
当make解析Makefile，遇到上面的条件赋值语句时，因为CC已经被定义过而且被赋值，所以这个条件语句就会什么都不做。<br>在Makefile中使用<code>echo $(CC)</code>打印变量CC的值，你会发现<code>$(CC)</code>的值是<code>gcc</code></li>
</ul>
<h3 id="追加赋值"><a href="#追加赋值" class="headerlink" title="追加赋值"></a>追加赋值</h3><p>追加赋值是指一个变量，以前已经被赋值，现在想给它增加新的值，此时可以使用+=追加赋值。如下面的语句：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">OBJS = hello.o</span><br><span class="line">OBJS += module.o</span><br><span class="line">就等价于：</span><br><span class="line"></span><br><span class="line">OBJS = hello.o module.o</span><br></pre></td></tr></table></figure>

<h2 id="Makefile-立即变量和延迟变量"><a href="#Makefile-立即变量和延迟变量" class="headerlink" title="Makefile 立即变量和延迟变量"></a>Makefile 立即变量和延迟变量</h2><p>在Makefile中最容易让人引困惑的是立即变量和延迟变量。立即变量和延迟变量是按展开时间来划分的。<br><strong>立即变量</strong>使用 <code>:=</code> 操作符进行赋值，在解析阶段就直接展开了，顾名思义，立即展开变量。<br><strong>延迟变量</strong>则是使用 <code>=</code> 操作符进行赋值，在make解析Makefile阶段不会立即展开，而是等到实际使用这个变量时才展开，获得其真正的值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a = 1</span><br><span class="line">b = 2</span><br><span class="line">val_a := $(a)</span><br><span class="line">val_b  = $(b)</span><br><span class="line">a = 10</span><br><span class="line">b = 20</span><br><span class="line"><span class="built_in">test</span>:</span><br><span class="line">    <span class="built_in">echo</span> $(val_a)</span><br><span class="line">    <span class="built_in">echo</span> $(val_b)</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，<code>val_a</code>是立即变量，当make解析到<code>:=</code>赋值符号时，会把<code>$(a)</code>变量的值立即赋值给val_a，虽然后面a的值发生了变化，但val_a因为已经展开，所以值就不再发生变化。<br>而<code>val_b</code>则不同，因为是延迟展开变量，所以，当make解析到 <code>=</code> 符号时，并没有立即把<code>$(b)</code>的值赋值给val_b，而是在运行echo命令时才对其展开，因为此时b的值已经是20，所以$(val_b)的值也是20</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line"><span class="built_in">echo</span> 1</span><br><span class="line">1</span><br><span class="line"><span class="built_in">echo</span> 20</span><br><span class="line">20</span><br></pre></td></tr></table></figure>
<p>立即展开变量一般用在规则中的目标、目标依赖中。make在解析Makefile阶段，需要这些变量有确切的值来构建依赖关系树。一个项目中的文件依赖关系在程序编译期间是固定不变的，因此需要立即变量在解析阶段就要有明确的值，立即展开。</p>
<p>延迟展开变量一般用在规则的命令行中，这些变量在make编译过程中被引用到才会展开，获得其实际的值。</p>
<h2 id="Makefile-自动变量"><a href="#Makefile-自动变量" class="headerlink" title="Makefile 自动变量"></a>Makefile 自动变量</h2><p>在Makefile中，大家经常会见到类似<code>$@</code>、<code>$^</code>、<code>$&lt;</code>这种类型的变量。这种变量一般称为自动变量，自动变量是局部变量，作用域范围在当前的规则内，它们分别代表不同的含义：</p>
<p><code>$@</code>：目标<br><code>$^</code>：所有目标依赖<br><code>$&lt;</code>：目标依赖列表中的第一个依赖<br><code>$?</code>：所有目标依赖中被修改过的文件<br>有了这些自动变量，我们就可以改进下面的Makefile：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: clean</span><br><span class="line">CC  = gcc</span><br><span class="line">BIN = a.out</span><br><span class="line">OBJS = hello.o</span><br><span class="line">OBJS += module.o</span><br><span class="line">$(BIN): $(OBJS)</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;start compiling...&quot;</span></span><br><span class="line">    @<span class="built_in">echo</span> $(OBJS)</span><br><span class="line">    $(CC) -o $(BIN) $(OBJS)</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;compile done&quot;</span></span><br><span class="line">hello.o: hello.c</span><br><span class="line">    $(CC) -c -o hello.o hello.c</span><br><span class="line">module.o: module.c</span><br><span class="line">    $(CC) -c -o module.o module.c</span><br><span class="line">clean:</span><br><span class="line">    <span class="built_in">rm</span> -f $(BIN) $(OBJS)</span><br></pre></td></tr></table></figure>
<p>将这个Makefile中命令行中的目标和目标依赖分别使用$@和$^代替，Makefile就变成了下面的样子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: clean</span><br><span class="line">CC  = gcc</span><br><span class="line">BIN = a.out</span><br><span class="line">OBJS = hello.o module.o</span><br><span class="line">$(BIN): $(OBJS)</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;start compiling...&quot;</span></span><br><span class="line">    @<span class="built_in">echo</span> $(OBJS)</span><br><span class="line">    $(CC) -o <span class="variable">$@</span> $^</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;compile done&quot;</span></span><br><span class="line">hello.o: hello.c</span><br><span class="line">    $(CC) -c -o <span class="variable">$@</span> $^</span><br><span class="line">module.o: module.c</span><br><span class="line">    $(CC) -c -o <span class="variable">$@</span> $^</span><br><span class="line">clean:</span><br><span class="line">    <span class="built_in">rm</span> -f $(BIN) $(OBJS)</span><br></pre></td></tr></table></figure>
<p>除了上面几个常用的自动变量外，还有一些自动变量不太常用，但是大家在以后阅读Makefile时可能会遇到，比如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$%：当规则的目标是一个静态库文件时，$%代表静态库的一个成员名</span><br><span class="line">$+：类似$^，但是保留了依赖文件中重复出现的文件</span><br><span class="line">$*：在模式匹配和静态模式规则中，代表目标模式中%的部分。比如hello.c，当匹配模式为%.c时，$*表示hello</span><br><span class="line">$(@D)：表示目标文件的目录部分</span><br><span class="line">$(@F)：表示目标文件的文件名部分</span><br><span class="line">$(*D)：在模式匹配中，表示目标模式中%的目录部分</span><br><span class="line">$(*F)：在模式匹配中，表示目标模式中%的文件名部分</span><br><span class="line">-: ：告诉make在编译时忽略所有的错误</span><br><span class="line">@: ：告诉make在执行命令前不要显示命令</span><br></pre></td></tr></table></figure>

<h2 id="Makefile-变量替换"><a href="#Makefile-变量替换" class="headerlink" title="Makefile 变量替换"></a>Makefile 变量替换</h2><p>使用指定字符串替换掉变量中的字符串</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: all</span><br><span class="line">SRC := main.c sub.c</span><br><span class="line">OBJ := $(SRC:.c=.o)</span><br><span class="line">all:</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;SRC = <span class="subst">$(SRC)</span>&quot;</span></span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;OBJ = <span class="subst">$(OBJ)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>执行make命令，运行结果为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line">SRC = main.c sub.c</span><br><span class="line">OBJ = main.o sub.o</span><br></pre></td></tr></table></figure>
<h3 id="模式匹配替换"><a href="#模式匹配替换" class="headerlink" title="模式匹配替换"></a>模式匹配替换</h3><p>使用匹配符<code>%</code>匹配变量，然后其他部分使用指定字符串代替。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: all</span><br><span class="line">SRC := main.c sub.c</span><br><span class="line">OBJ := $(SRC:%.c=%.o)</span><br><span class="line">all:</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;SRC = <span class="subst">$(SRC)</span>&quot;</span></span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;OBJ = <span class="subst">$(OBJ)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>执行make命令，运行结果为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line">SRC = main.c sub.c</span><br><span class="line">OBJ = main.o sub.o</span><br></pre></td></tr></table></figure>


<h2 id="Makefile-环境变量"><a href="#Makefile-环境变量" class="headerlink" title="Makefile 环境变量"></a>Makefile 环境变量</h2><p>make在解析Makefile中还会引入一些系统环境变量，如编译参数<code>CFLAGS</code>、<code>SHELL</code>、<code>MAKE</code>等。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY:all</span><br><span class="line">CFLAGS = -g</span><br><span class="line">all:</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;CFLAGS = <span class="subst">$(CFLAGS)</span>&quot;</span></span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;SHELL = <span class="subst">$(SHELL)</span>&quot;</span></span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;MAKE = <span class="subst">$(MAKE)</span>&quot;</span></span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;HOSTNAME = <span class="subst">$(HOSTNAME)</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>在上面的Makefile中，默认情况下，echo会打印各个系统变量的值：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line">CFLAGS = -g</span><br><span class="line">SHELL = /bin/sh</span><br><span class="line">MAKE = make</span><br><span class="line">HOSTNAME =</span><br></pre></td></tr></table></figure>

<h2 id="通过export传递变量"><a href="#通过export传递变量" class="headerlink" title="通过export传递变量"></a>通过export传递变量</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY:all</span><br><span class="line">all:</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;WEB = <span class="subst">$(WEB)</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>在上面的Makefile中，在命令行中打印变量WEB的值，但WEB在Makefile中并没有定义，但我们可以通过export传递给它：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line">WEB = </span><br><span class="line"><span class="comment"># export WEB=test</span></span><br><span class="line"><span class="comment"># make</span></span><br><span class="line">WEB = <span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<p>在shell环境下使用export命令，就相当于将WEB变量声明为系统环境变量。当make解析Makefile时，<strong>会自动引入系统环境变量</strong>，包括刚刚声明的WEB，所以我们就可以在Makefile中看到WEB变量的打印值了。</p>
]]></content>
      <categories>
        <category>Makefile</category>
      </categories>
      <tags>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>xml解析</title>
    <url>/2021/05/11/xml%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>XML 作为一种数据交换和信息传递的格式已经十分普及。而随着 Web 服务日益广泛的应用，现在 XML 在日常的开发工作中也扮演了愈发重要的角色。这一小节， 我们将就 Go 语言标准包中的 XML 相关处理的包进行介绍。</p>
<span id="more"></span>

<p>这个小节不会涉及 XML 规范相关的内容（如需了解相关知识请参考其他文献），而是介绍如何用 Go 语言来编解码 XML 文件相关的知识。</p>
<p>假如你是一名运维人员，你为你所管理的所有服务器生成了如下内容的 xml 的配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;servers version=&quot;1&quot;&gt;</span><br><span class="line">    &lt;server&gt;</span><br><span class="line">        &lt;serverName&gt;Shanghai_VPN&lt;/serverName&gt;</span><br><span class="line">        &lt;serverIP&gt;127.0.0.1&lt;/serverIP&gt;</span><br><span class="line">    &lt;/server&gt;</span><br><span class="line">    &lt;server&gt;</span><br><span class="line">        &lt;serverName&gt;Beijing_VPN&lt;/serverName&gt;</span><br><span class="line">        &lt;serverIP&gt;127.0.0.2&lt;/serverIP&gt;</span><br><span class="line">    &lt;/server&gt;</span><br><span class="line">&lt;/servers&gt;</span><br></pre></td></tr></table></figure>

<p>上面的 XML 文档描述了两个服务器的信息，包含了服务器名和服务器的 IP 信息，接下来的 Go 例子以此 XML 描述的信息进行操作。</p>
<h2 id="解析-XML"><a href="#解析-XML" class="headerlink" title="解析 XML"></a>解析 XML</h2><p>如何解析如上这个 XML 文件呢？ 我们可以通过 xml 包的 <code>Unmarshal</code> 函数来达到我们的目的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">func Unmarshal(data []byte, v interface&#123;&#125;) error</span><br></pre></td></tr></table></figure>

<p>data 接收的是 XML 数据流，v 是需要输出的结构，定义为 interface，也就是可以把 XML 转换为任意的格式。我们这里主要介绍 struct 的转换，因为 struct 和 XML 都有类似树结构的特征。</p>
<p>示例代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;encoding/xml&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;io/ioutil&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Recurlyservers struct &#123;</span><br><span class="line">    XMLName     xml.Name `xml:&quot;servers&quot;`</span><br><span class="line">    Version     string   `xml:&quot;version,attr&quot;`</span><br><span class="line">    Svs         []server `xml:&quot;server&quot;`</span><br><span class="line">    Description string   `xml:&quot;,innerxml&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type server struct &#123;</span><br><span class="line">    XMLName    xml.Name `xml:&quot;server&quot;`</span><br><span class="line">    ServerName string   `xml:&quot;serverName&quot;`</span><br><span class="line">    ServerIP   string   `xml:&quot;serverIP&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    file, err := os.Open(&quot;servers.xml&quot;) // For read access.     </span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Printf(&quot;error: %v&quot;, err)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    defer file.Close()</span><br><span class="line">    data, err := ioutil.ReadAll(file)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Printf(&quot;error: %v&quot;, err)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    v := Recurlyservers&#123;&#125;</span><br><span class="line">    err = xml.Unmarshal(data, &amp;v)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Printf(&quot;error: %v&quot;, err)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>XML 本质上是一种树形的数据格式，而我们可以定义与之匹配的 go 语言的 struct 类型，然后通过 xml.Unmarshal 来将 xml 中的数据解析成对应的 struct 对象。如上例子输出如下数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;&#123; servers&#125; 1 [&#123;&#123; server&#125; Shanghai_VPN 127.0.0.1&#125; &#123;&#123; server&#125; Beijing_VPN 127.0.0.2&#125;]</span><br><span class="line">&lt;server&gt;</span><br><span class="line">    &lt;serverName&gt;Shanghai_VPN&lt;/serverName&gt;</span><br><span class="line">    &lt;serverIP&gt;127.0.0.1&lt;/serverIP&gt;</span><br><span class="line">&lt;/server&gt;</span><br><span class="line">&lt;server&gt;</span><br><span class="line">    &lt;serverName&gt;Beijing_VPN&lt;/serverName&gt;</span><br><span class="line">    &lt;serverIP&gt;127.0.0.2&lt;/serverIP&gt;</span><br><span class="line">&lt;/server&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的例子中，将 xml 文件解析成对应的 struct 对象是通过 <code>xml.Unmarshal</code> 来完成的，这个过程是如何实现的？可以看到我们的 struct 定义后面多了一些类似于 <code>xml:&quot;serverName&quot;</code> 这样的内容, 这个是 struct 的一个特性，它们被称为 struct tag，它们是用来辅助反射的。我们来看一下 <code>Unmarshal</code> 的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">func Unmarshal(data []byte, v interface&#123;&#125;) error</span><br></pre></td></tr></table></figure>

<p>我们看到函数定义了两个参数，第一个是 XML 数据流，第二个是存储的对应类型，目前支持 struct、slice 和 string，XML 包内部采用了反射来进行数据的映射，所以 v 里面的字段必须是导出的。<code>Unmarshal</code> 解析的时候 XML 元素和字段怎么对应起来的呢？这是有一个优先级读取流程的，首先会读取 struct tag，如果没有，那么就会对应字段名。必须注意一点的是解析的时候 tag、字段名、XML 元素都是大小写敏感的，所以必须一一对应字段。</p>
<p>Go 语言的反射机制，可以利用这些 tag 信息来将来自 XML 文件中的数据反射成对应的 struct 对象，关于反射如何利用 struct tag 的更多内容请参阅 reflect 中的相关内容。</p>
<p>解析 XML 到 struct 的时候遵循如下的规则：</p>
<ul>
<li>  如果 struct 的一个字段是 string 或者 []byte 类型且它的 tag 含有 <code>&quot;,innerxml&quot;</code>，Unmarshal 将会将此字段所对应的元素内所有内嵌的原始 xml 累加到此字段上，如上面例子 Description 定义。最后的输出是</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;server&gt;</span><br><span class="line">    &lt;serverName&gt;Shanghai_VPN&lt;/serverName&gt;</span><br><span class="line">    &lt;serverIP&gt;127.0.0.1&lt;/serverIP&gt;</span><br><span class="line">&lt;/server&gt;</span><br><span class="line">&lt;server&gt;</span><br><span class="line">    &lt;serverName&gt;Beijing_VPN&lt;/serverName&gt;</span><br><span class="line">    &lt;serverIP&gt;127.0.0.2&lt;/serverIP&gt;</span><br><span class="line">&lt;/server&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>  如果 struct 中有一个叫做 XMLName，且类型为 xml.Name 字段，那么在解析的时候就会保存这个 element 的名字到该字段,如上面例子中的 servers。</li>
<li>  如果某个 struct 字段的 tag 定义中含有 XML 结构中 element 的名称，那么解析的时候就会把相应的 element 值赋值给该字段，如上 servername和 serverip 定义。</li>
<li>  如果某个 struct 字段的 tag 定义了中含有 <code>&quot;,attr&quot;</code>，那么解析的时候就会将该结构所对应的 element 的与字段同名的属性的值赋值给该字段，如上 version 定义。</li>
<li>  如果某个 struct 字段的 tag 定义 型如 <code>&quot;a&gt;b&gt;c&quot;</code>, 则解析的时候，会将 xml 结构 a 下面的 b 下面的 c 元素的值赋值给该字段。</li>
<li>  如果某个 struct 字段的 tag 定义了 <code>&quot;-&quot;</code>, 那么不会为该字段解析匹配任何 xml 数据。</li>
<li>  如果 struct 字段后面的 tag 定义了 <code>&quot;,any&quot;</code>，如果他的子元素在不满足其他的规则的时候就会匹配到这个字段。</li>
<li>  如果某个 XML 元素包含一条或者多条注释，那么这些注释将被累加到第一个 tag 含有 “,comments” 的字段上，这个字段的类型可能是 []byte 或 string, 如果没有这样的字段存在，那么注释将会被抛弃。</li>
</ul>
<p>上面详细讲述了如何定义 struct的tag。 只要设置对了 tag，那么 XML 解析就如上面示例般简单，tag 和 XML 的 element 是一一对应的关系，如上所示，我们还可以通过 slice 来表示多个同级元素。</p>
<blockquote>
<p>注意： 为了正确解析，go 语言的 xml 包要求 struct 定义中的所有字段必须是可导出的（即首字母大写）</p>
</blockquote>
<h2 id="输出-XML"><a href="#输出-XML" class="headerlink" title="输出 XML"></a>输出 XML</h2><p>假若我们不是要解析如上所示的 XML 文件，而是生成它，那么在 go 语言中又该如何实现呢？ xml 包中提供了 <code>Marshal</code> 和 <code>MarshalIndent</code> 两个函数，来满足我们的需求。这两个函数主要的区别是第二个函数会增加前缀和缩进，函数的定义如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">func Marshal(v interface&#123;&#125;) ([]byte, error)</span><br><span class="line">func MarshalIndent(v interface&#123;&#125;, prefix, indent string) ([]byte, error)</span><br></pre></td></tr></table></figure>

<p>两个函数第一个参数是用来生成 XML 的结构定义类型数据，都是返回生成的 XML 数据流。</p>
<p>下面我们来看一下如何输出如上的 XML：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;encoding/xml&quot;</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Servers struct &#123;</span><br><span class="line">    XMLName xml.Name `xml:&quot;servers&quot;`</span><br><span class="line">    Version string   `xml:&quot;version,attr&quot;`</span><br><span class="line">    Svs     []server `xml:&quot;server&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type server struct &#123;</span><br><span class="line">    ServerName string `xml:&quot;serverName&quot;`</span><br><span class="line">    ServerIP   string `xml:&quot;serverIP&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    v := &amp;Servers&#123;Version: &quot;1&quot;&#125;</span><br><span class="line">    v.Svs = append(v.Svs, server&#123;&quot;Shanghai_VPN&quot;, &quot;127.0.0.1&quot;&#125;)</span><br><span class="line">    v.Svs = append(v.Svs, server&#123;&quot;Beijing_VPN&quot;, &quot;127.0.0.2&quot;&#125;)</span><br><span class="line">    output, err := xml.MarshalIndent(v, &quot;  &quot;, &quot;    &quot;)</span><br><span class="line">    if err != nil &#123;</span><br><span class="line">        fmt.Printf(&quot;error: %v\n&quot;, err)</span><br><span class="line">    &#125;</span><br><span class="line">    os.Stdout.Write([]byte(xml.Header))</span><br><span class="line"></span><br><span class="line">    os.Stdout.Write(output)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的代码输出如下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;servers version=&quot;1&quot;&gt;</span><br><span class="line">&lt;server&gt;</span><br><span class="line">    &lt;serverName&gt;Shanghai_VPN&lt;/serverName&gt;</span><br><span class="line">    &lt;serverIP&gt;127.0.0.1&lt;/serverIP&gt;</span><br><span class="line">&lt;/server&gt;</span><br><span class="line">&lt;server&gt;</span><br><span class="line">    &lt;serverName&gt;Beijing_VPN&lt;/serverName&gt;</span><br><span class="line">    &lt;serverIP&gt;127.0.0.2&lt;/serverIP&gt;</span><br><span class="line">&lt;/server&gt;</span><br><span class="line">&lt;/servers&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>和我们之前定义的文件的格式一模一样，之所以会有 <code>os.Stdout.Write([]byte(xml.Header))</code> 这句代码的出现，是因为 <code>xml.MarshalIndent</code> 或者 <code>xml.Marshal</code> 输出的信息都是不带 XML 头的，为了生成正确的 xml 文件，我们使用了 xml 包预定义的 Header 变量。</p>
<p>我们看到 <code>Marshal</code> 函数接收的参数 v 是 interface{} 类型的，即它可以接受任意类型的参数，那么 xml 包，根据什么规则来生成相应的 XML 文件呢？</p>
<ul>
<li>  如果 v 是 array 或者 slice，那么输出每一个元素，类似 value</li>
<li>  如果 v 是指针，那么会 Marshal 指针指向的内容，如果指针为空，什么都不输出</li>
<li>  如果 v 是 interface，那么就处理 interface 所包含的数据</li>
<li>  如果 v 是其他数据类型，就会输出这个数据类型所拥有的字段信息</li>
</ul>
<p>生成的 XML 文件中的 element 的名字又是根据什么决定的呢？元素名按照如下优先级从 struct 中获取：</p>
<ul>
<li>  如果 v 是 struct，XMLName 的 tag 中定义的名称</li>
<li>  类型为 xml.Name 的名叫 XMLName 的字段的值</li>
<li>  通过 struct 中字段的 tag 来获取</li>
<li>  通过 struct 的字段名用来获取</li>
<li>  marshall 的类型名称</li>
</ul>
<p>我们应如何设置 struct 中字段的 tag 信息以控制最终 xml 文件的生成呢？</p>
<ul>
<li>  XMLName 不会被输出</li>
<li>  tag 中含有 <code>&quot;-&quot;</code> 的字段不会输出</li>
<li>  tag 中含有 <code>&quot;name,attr&quot;</code>，会以 name 作为属性名，字段值作为值输出为这个 XML 元素的属性，如上 version 字段所描述</li>
<li>  tag 中含有 <code>&quot;,attr&quot;</code>，会以这个 struct 的字段名作为属性名输出为 XML 元素的属性，类似上一条，只是这个 name 默认是字段名了。</li>
<li>  tag 中含有 <code>&quot;,chardata&quot;</code>，输出为 xml 的 character data 而非 element。</li>
<li>  tag 中含有 <code>&quot;,innerxml&quot;</code>，将会被原样输出，而不会进行常规的编码过程</li>
<li>  tag 中含有 <code>&quot;,comment&quot;</code>，将被当作 xml 注释来输出，而不会进行常规的编码过程，字段值中不能含有”–”字符串</li>
<li>  tag 中含有 <code>&quot;omitempty&quot;</code>, 如果该字段的值为空值那么该字段就不会被输出到 XML，空值包括：false、0、nil 指针或 nil 接口，任何长度为 0 的 array, slice, map 或者 string</li>
<li>  tag 中含有 <code>&quot;a&gt;b&gt;c&quot;</code>，那么就会循环输出三个元素 a 包含 b，b 包含 c，例如如下代码就会输出</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FirstName string   `xml:&quot;name&gt;first&quot;`</span><br><span class="line">LastName  string   `xml:&quot;name&gt;last&quot;`</span><br><span class="line"></span><br><span class="line">&lt;name&gt;</span><br><span class="line">&lt;first&gt;Asta&lt;/first&gt;</span><br><span class="line">&lt;last&gt;Xie&lt;/last&gt;</span><br><span class="line">&lt;/name&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>xml</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile规则</title>
    <url>/2021/05/11/Makefile%E8%A7%84%E5%88%99/</url>
    <content><![CDATA[<h2 id="Makefile-规则"><a href="#Makefile-规则" class="headerlink" title="Makefile 规则"></a>Makefile 规则</h2><p>在程序编译过程中，Makefile的主要作用就是：构建生成可执行文件的依赖关系树。一个可执行文件需要哪些源文件、哪些库，我们都可以在Makefile里指定。在程序编译阶段，make工具会首先解析这个Makefile，根据Makefile里的指定，构建出编译可执行文件所需要的完整依赖关系。</p>
<span id="more"></span>

<p>根据这个依赖关系，make工具接下来就可以分别去编译需要的文件；<br>通过时间戳，可以动态识别哪些是新添加的文件，哪些是已经编译过的文件，哪些文件做了新的修改，这样就不用每次都重新编译了，只编译那些新修改或新添加的源文件就可以了，大大提升了编译的效率。</p>
<p>那Makefile是如何构建可执行文件编译所依赖的关系树的呢？很简单，通过规则。</p>
<h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>规则是Makefile的基本组成单元。一个规则通常由目标、目标依赖和命令三部分构成：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">目标：目标依赖</span><br><span class="line">    命令</span><br><span class="line">a.out: hello.c</span><br><span class="line">    gcc -o a.out hello.c</span><br></pre></td></tr></table></figure>
<p>如上所示，a.out就是我们要生成的目标，目标一般是一个可执行文件。目标依赖是指生成这个可执行文件所依赖的源文件，如 hello.c。而命令则是如何将这些目标依赖生成对应的目标，一般是gcc命令、链接命令、objcopy命令，一些shell命令等。<br><strong>命令必须使用tab键进行缩进，否则Makefile就会报错</strong>。</p>
<p>一个规则中的三个部分并不是都必须要有的。一个Makefile文件中可能包含多个规则，有的规则可能无目标依赖，仅仅是为了实现某种操作。如下面的clean命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clean:</span><br><span class="line">    <span class="built_in">rm</span> -f a.out hello.o</span><br></pre></td></tr></table></figure>
<p>当我们使用make clean命令清理编译的文件时，会调用这个规则中的命令，不需要什么依赖，仅仅是执行删除操作，所以这个规则中并没有目标依赖。</p>
<p>当然，一个规则中也可以没有命令，仅仅包含目标和目标依赖，仅仅用来描述一种依赖关系。<br><strong>但一个规则中一定要有一个目标</strong>。</p>
<h3 id="默认目标"><a href="#默认目标" class="headerlink" title="默认目标"></a>默认目标</h3><p>一个Makefile文件里通常会有多个目标，<strong>一般会选择第一个作为默认目标</strong>。正常情况下，当你想编译生成a.out时，要使用make a.out命令，但为什么直接使用make，没有指定参数，也能生成a.out的呢？这是因为在上面的Makefile文件中，a.out是文件中的第一个目标，当我们在make编译时没有给make指定要生成的目标，make就会选择Makefile文件中的第一个目标作为默认目标。</p>
<h3 id="多目标"><a href="#多目标" class="headerlink" title="多目标"></a>多目标</h3><p>一个规则中也可以有多个目标，多个目标具有相同的生成命令和依赖文件。</p>
<p>如一个目标文件%.o都是由其对应的源文件%.c编译生成的，生成命令也是相同的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">%.o: %.c</span><br><span class="line">    gcc -o %.o %.c</span><br></pre></td></tr></table></figure>

<h3 id="多规则目标"><a href="#多规则目标" class="headerlink" title="多规则目标"></a>多规则目标</h3><p>多个规则可能是同一个目标，make在解析Makefile文件时，会将具有相同目标的规则的依赖文件合并。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a.out: hello.c</span><br><span class="line">    gcc -o a.out hello.c</span><br><span class="line">a.out: module.c</span><br></pre></td></tr></table></figure>
<p>Make在解析Makefile构建依赖关系树时，会将这两个规则合并为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a.out: hello.c module.c</span><br><span class="line">    gcc -o a.out hello.c other.c</span><br></pre></td></tr></table></figure>

<h3 id="伪目标"><a href="#伪目标" class="headerlink" title="伪目标"></a>伪目标</h3><p>伪目标可防止工程目录下同名目标文件的存在导致命令无法执行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: clean</span><br><span class="line">a.out: hello.o</span><br><span class="line">    gcc -o a.out hello.o</span><br><span class="line">hello.o: hello.c</span><br><span class="line">    gcc -c -o hello.o hello.c</span><br><span class="line">clean:</span><br><span class="line">    <span class="built_in">rm</span> -f a.out hello.o</span><br></pre></td></tr></table></figure>

<p>伪目标一般没有依赖关系，也不会生成对应的目标文件，<strong>可以无条件执行，纯粹是为了执行某一个命令</strong>，如clean执行清理工作。</p>
<h2 id="Makefile-命令"><a href="#Makefile-命令" class="headerlink" title="Makefile 命令"></a>Makefile 命令</h2><p>在一个规则中，除了目标和目标依赖外，还有一个重要的部分：命令。<br>命令一般由shell命令（<code>echo</code>、<code>ls</code>）和编译器的一些工具（<code>gcc</code>、<code>ld</code>、<code>ar</code>、<code>objcopy</code>等）组成，使用tab键缩进。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: clean</span><br><span class="line">a.out: hello.c</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;start compiling...&quot;</span></span><br><span class="line">    gcc -o a.out hello.c</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;compile done&quot;</span></span><br><span class="line">clean:</span><br><span class="line">    <span class="built_in">rm</span> -f a.out hello.o</span><br></pre></td></tr></table></figure>
<p>命令是make在编译程序时真正要执行的部分。对于规则中的每一个命令，make会开一个进程执行，每条命令执行完，make会监测每个命令的返回码。</p>
<p>若命令返回成功，make继续执行下一个命令<br>若命令执行出错，make会终止执行当前的规则，退出编译流程<br>make每执行一条命令，会把当前的命令打印出来。如上面的Makefile，当你使用make命令编译时，Makefile的打印信息如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;start compiling...&quot;</span></span><br><span class="line">start compiling...</span><br><span class="line">gcc -o a.out hello.c</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;compile done&quot;</span></span><br><span class="line">compile <span class="keyword">done</span></span><br></pre></td></tr></table></figure>
<p>如果你不想在make编译的时候打印正在执行的执行，可以在每条命令的前面加一个<code>@</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">.PHONY: clean</span><br><span class="line">a.out: hello.c</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;start compiling...&quot;</span></span><br><span class="line">    @gcc -o a.out hello.c</span><br><span class="line">    @<span class="built_in">echo</span> <span class="string">&quot;compile done&quot;</span></span><br><span class="line">clean:</span><br><span class="line">    <span class="built_in">rm</span> -f a.out hello.o</span><br></pre></td></tr></table></figure>
<p>添加@以后，make在编译时就不会打印每条正在执行的命令了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># make</span></span><br><span class="line">start compiling...</span><br><span class="line">compile <span class="keyword">done</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Makefile</category>
      </categories>
      <tags>
        <tag>Makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>omitempty关键字</title>
    <url>/2021/05/10/omitempty%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>结构体有标签名时, 标签名会作为key进行<code>json.Marshal</code>，<br>当结构体某个字段没有赋值时，<code>json.Marshal</code>无需序列化该字段，此时就要用到<code>omitempty</code>关键字</p>
</blockquote>
<span id="more"></span>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> address <span class="keyword">struct</span> &#123;</span><br><span class="line">	Street  <span class="type">string</span> <span class="string">`json:&quot;street&quot;`</span>  <span class="comment">// 街道</span></span><br><span class="line">	Ste     <span class="type">string</span> <span class="string">`json:&quot;suite&quot;`</span>   <span class="comment">// 单元（可以不存在）</span></span><br><span class="line">	City    <span class="type">string</span> <span class="string">`json:&quot;city&quot;`</span>    <span class="comment">// 城市</span></span><br><span class="line">	State   <span class="type">string</span> <span class="string">`json:&quot;state&quot;`</span>   <span class="comment">// 州/省</span></span><br><span class="line">	Zipcode <span class="type">string</span> <span class="string">`json:&quot;zipcode&quot;`</span> <span class="comment">// 邮编</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	data := <span class="string">`&#123;</span></span><br><span class="line"><span class="string">		  &quot;street&quot;: &quot;200 Larkin St&quot;,</span></span><br><span class="line"><span class="string">		  &quot;city&quot;: &quot;San Francisco&quot;,</span></span><br><span class="line"><span class="string">		  &quot;state&quot;: &quot;CA&quot;,</span></span><br><span class="line"><span class="string">		  &quot;zipcode&quot;: &quot;94102&quot;</span></span><br><span class="line"><span class="string">	  &#125;`</span></span><br><span class="line">	addr := <span class="built_in">new</span>(address)</span><br><span class="line">	json.Unmarshal([]<span class="type">byte</span>(data), &amp;addr)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理了一番 addr 变量...</span></span><br><span class="line"></span><br><span class="line">	addressBytes, _ := json.MarshalIndent(addr, <span class="string">&quot;&quot;</span>, <span class="string">&quot;    &quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, <span class="type">string</span>(addressBytes))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到运行结果如下：<br><img src="4cd9ff01cf4568afd7712d2d5d2023d88c4746fa0ebcb6d3dd41a6be20744048.png" alt="图 1">  </p>
<p>多了一行 “suite”: “”, ，而这则信息在原本的 json 数据中是没有的，此时再序列化有点浪费字节空间了</p>
<p>可以将结构体定义为:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> address <span class="keyword">struct</span> &#123;</span><br><span class="line">	Street  <span class="type">string</span> <span class="string">`json:&quot;street&quot;`</span></span><br><span class="line">	Ste     <span class="type">string</span> <span class="string">`json:&quot;suite,omitempty&quot;`</span></span><br><span class="line">	City    <span class="type">string</span> <span class="string">`json:&quot;city&quot;`</span></span><br><span class="line">	State   <span class="type">string</span> <span class="string">`json:&quot;state&quot;`</span></span><br><span class="line">	Zipcode <span class="type">string</span> <span class="string">`json:&quot;zipcode&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到预期结果：<br><img src="ef7e859c46b3844078ad6c9800293e6b95a28ffabaa6f20fd9dfa09694841688.png" alt="图 2">  </p>
<h2 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h2><p>带来方便的同时，使用 omitempty 也有些小陷阱，一个是该关键字无法忽略掉嵌套结构体。还是拿地址类型说事，这回我们想要往地址结构体中加一个新 field 来表示经纬度，如果缺乏相关的数据，暂时可以忽略。新的结构体定义如下所示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> address <span class="keyword">struct</span> &#123;</span><br><span class="line">	Street     <span class="type">string</span>     <span class="string">`json:&quot;street&quot;`</span></span><br><span class="line">	Ste        <span class="type">string</span>     <span class="string">`json:&quot;suite,omitempty&quot;`</span></span><br><span class="line">	City       <span class="type">string</span>     <span class="string">`json:&quot;city&quot;`</span></span><br><span class="line">	State      <span class="type">string</span>     <span class="string">`json:&quot;state&quot;`</span></span><br><span class="line">	Zipcode    <span class="type">string</span>     <span class="string">`json:&quot;zipcode&quot;`</span></span><br><span class="line">	Coordinate coordinate <span class="string">`json:&quot;coordinate,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> coordinate <span class="keyword">struct</span> &#123;</span><br><span class="line">	Lat <span class="type">float64</span> <span class="string">`json:&quot;latitude&quot;`</span></span><br><span class="line">	Lng <span class="type">float64</span> <span class="string">`json:&quot;longitude&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读入原来的地址数据，处理后序列化输出，我们就会发现即使加上了 omitempty 关键字，输出的 json 还是带上了一个空的坐标信息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;street&quot;</span>: <span class="string">&quot;200 Larkin St&quot;</span>,</span><br><span class="line">    <span class="string">&quot;city&quot;</span>: <span class="string">&quot;San Francisco&quot;</span>,</span><br><span class="line">    <span class="string">&quot;state&quot;</span>: <span class="string">&quot;CA&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zipcode&quot;</span>: <span class="string">&quot;94102&quot;</span>,</span><br><span class="line">    <span class="string">&quot;coordinate&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;latitude&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&quot;longitude&quot;</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了达到我们想要的效果，可以把坐标定义为指针类型，这样 Golang 就能知道一个指针的“空值”是多少了，否则面对一个我们自定义的结构， Golang 是猜不出我们想要的空值的。于是有了如下的结构体定义</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> address <span class="keyword">struct</span> &#123;</span><br><span class="line">	Street     <span class="type">string</span>      <span class="string">`json:&quot;street&quot;`</span></span><br><span class="line">	Ste        <span class="type">string</span>      <span class="string">`json:&quot;suite,omitempty&quot;`</span></span><br><span class="line">	City       <span class="type">string</span>      <span class="string">`json:&quot;city&quot;`</span></span><br><span class="line">	State      <span class="type">string</span>      <span class="string">`json:&quot;state&quot;`</span></span><br><span class="line">	Zipcode    <span class="type">string</span>      <span class="string">`json:&quot;zipcode&quot;`</span></span><br><span class="line">	Coordinate *coordinate <span class="string">`json:&quot;coordinate,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> coordinate <span class="keyword">struct</span> &#123;</span><br><span class="line">	Lat <span class="type">float64</span> <span class="string">`json:&quot;latitude&quot;`</span></span><br><span class="line">	Lng <span class="type">float64</span> <span class="string">`json:&quot;longitude&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相应的输出为</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;street&quot;</span>: <span class="string">&quot;200 Larkin St&quot;</span>,</span><br><span class="line">    <span class="string">&quot;city&quot;</span>: <span class="string">&quot;San Francisco&quot;</span>,</span><br><span class="line">    <span class="string">&quot;state&quot;</span>: <span class="string">&quot;CA&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zipcode&quot;</span>: <span class="string">&quot;94102&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个“陷阱”是，对于用 omitempty 定义的 field ，如果给它赋的值恰好等于默认空值的话，在转为 json 之后也不会输出这个 field 。比如说上面定义的经纬度坐标结构体，如果我们将经纬度两个 field 都加上 omitempty</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> coordinate <span class="keyword">struct</span> &#123;</span><br><span class="line">	Lat <span class="type">float64</span> <span class="string">`json:&quot;latitude,omitempty&quot;`</span></span><br><span class="line">	Lng <span class="type">float64</span> <span class="string">`json:&quot;longitude,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们对非洲几内亚湾的“原点坐标”非常感兴趣，于是编写了如下代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cData := <span class="string">`&#123;</span></span><br><span class="line"><span class="string">		&quot;latitude&quot;: 0.0,</span></span><br><span class="line"><span class="string">		&quot;longitude&quot;: 0.0</span></span><br><span class="line"><span class="string">	&#125;`</span></span><br><span class="line">	c := <span class="built_in">new</span>(coordinate)</span><br><span class="line">	json.Unmarshal([]<span class="type">byte</span>(cData), &amp;c)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 具体处理逻辑...</span></span><br><span class="line"></span><br><span class="line">	coordinateBytes, _ := json.MarshalIndent(c, <span class="string">&quot;&quot;</span>, <span class="string">&quot;    &quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, <span class="type">string</span>(coordinateBytes))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终我们得到了一个<br><code>&#123;&#125;</code></p>
<p>这个坐标消失不见了！但我们的设想是，如果一个地点没有经纬度信息，则悬空，这没有问题，但对于“原点坐标”，我们在确切知道它的经纬度的情况下，（0.0, 0.0）仍然被忽略了。正确的写法也是将结构体内的定义改为指针</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> coordinate <span class="keyword">struct</span> &#123;</span><br><span class="line">	Lat *<span class="type">float64</span> <span class="string">`json:&quot;latitude,omitempty&quot;`</span></span><br><span class="line">	Lng *<span class="type">float64</span> <span class="string">`json:&quot;longitude,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样空值就从 float64 的 0.0 变为了指针类型的 nil ，我们就能看到正确的经纬度输出。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;latitude&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&quot;longitude&quot;</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>json包使用</title>
    <url>/2021/05/09/json%E5%8C%85%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>使用 <code>json.Unmarshal</code> 和 <code>json.Marshal</code> 函数，可以将 JSON 格式的二进制数据反序列化到指定的 Go 结构体中，以及将 Go 结构体序列化为二进制流。</p>
</blockquote>
<span id="more"></span>

<h2 id="Map转JSON"><a href="#Map转JSON" class="headerlink" title="Map转JSON"></a>Map转JSON</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="comment">// map里面</span></span><br><span class="line">	map1 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span> &#123;</span><br><span class="line">		<span class="string">&quot;name&quot;</span>:<span class="string">&quot;张三&quot;</span>,</span><br><span class="line">		<span class="string">&quot;age&quot;</span>:<span class="string">&quot;18&quot;</span>,</span><br><span class="line">		<span class="string">&quot;home&quot;</span>:<span class="string">&quot;北京&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将map解析成json</span></span><br><span class="line">	json1, err := json.Marshal(map1)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;json1: %s  类型: %T \n&quot;</span>,json1,json1)</span><br><span class="line">  </span><br><span class="line">	map2 := <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span> &#123;</span><br><span class="line">		<span class="string">&quot;fruit&quot;</span>: &#123;<span class="string">&quot;香蕉&quot;</span>,<span class="string">&quot;葡萄&quot;</span>&#125;,</span><br><span class="line">		<span class="string">&quot;coder&quot;</span>:&#123;<span class="string">&quot;PHP&quot;</span>,<span class="string">&quot;Go&quot;</span>,<span class="string">&quot;Java&quot;</span>&#125;,</span><br><span class="line">		<span class="string">&quot;likes&quot;</span>:&#123;<span class="string">&quot;打游戏&quot;</span>,<span class="string">&quot;看动漫&quot;</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	json2, err := json.Marshal(map2)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;json2: %s  类型: %T \n&quot;</span>,json2,json2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">json1: &#123;&quot;age&quot;:&quot;18&quot;,&quot;home&quot;:&quot;北京&quot;,&quot;name&quot;:&quot;张三&quot;&#125;  类型: []uint8 </span></span><br><span class="line"><span class="comment">json2: &#123;&quot;coder&quot;:[&quot;PHP&quot;,&quot;Go&quot;,&quot;Java&quot;],&quot;fruit&quot;:[&quot;香蕉&quot;,&quot;葡萄&quot;],&quot;likes&quot;:[&quot;打游戏&quot;,&quot;看动漫&quot;]&#125;  类型: []uint8 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="Json转Map"><a href="#Json转Map" class="headerlink" title="Json转Map"></a>Json转Map</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	json1 := <span class="string">`&#123;&quot;age&quot;:&quot;18&quot;,&quot;home&quot;:&quot;北京&quot;,&quot;name&quot;:&quot;张三&quot;&#125;`</span></span><br><span class="line">	map1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">	err := json.Unmarshal([]<span class="type">byte</span>(json1), &amp;map1)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;map1: %v T: %T\n&quot;</span>,map1,map1)</span><br><span class="line"></span><br><span class="line">	json2 := <span class="string">`&#123;&quot;coder&quot;:[&quot;PHP&quot;,&quot;Go&quot;,&quot;Java&quot;],&quot;fruit&quot;:[&quot;香蕉&quot;,&quot;葡萄&quot;],&quot;likes&quot;:[&quot;打游戏&quot;,&quot;看动漫&quot;]&#125;`</span></span><br><span class="line">	map2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>)</span><br><span class="line">	err = json.Unmarshal([]<span class="type">byte</span>(json2), &amp;map2)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;map2: %v T: %T\n&quot;</span>,map2,map2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">map1: map[age:18 home:北京 name:张三] T: map[string]string</span></span><br><span class="line"><span class="comment">map2: map[coder:[PHP Go Java] fruit:[香蕉 葡萄] likes:[打游戏 看动漫]] T: map[string][]string</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="结构体转JSON"><a href="#结构体转JSON" class="headerlink" title="结构体转JSON"></a>结构体转JSON</h2><p><strong>无字段标签</strong><br>结构体转换成JSON在开发中经常会用到。encoding/json包是通过反射机制来实现编解码的，因此结构体必须导出所转换的字段，没有导出的字段不会被encoding/json包解析。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age <span class="type">int</span></span><br><span class="line">	Class <span class="type">string</span></span><br><span class="line">	phone <span class="type">string</span> <span class="comment">//小写字段，则不是会导出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	s := Student&#123;</span><br><span class="line">		Name:  <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">		Age:   <span class="number">17</span>,</span><br><span class="line">		Class: <span class="string">&quot;三年级&quot;</span>,</span><br><span class="line">		phone: <span class="string">&quot;17600112222&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	json1, err := json.Marshal(s)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;json: %s \n&quot;</span>,json1)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 json: &#123;&quot;Name&quot;:&quot;张三&quot;,&quot;Age&quot;:17,&quot;Class&quot;:&quot;三年级&quot;&#125; </span></span><br></pre></td></tr></table></figure>

<p><strong>有字段标签</strong><br>json包在解析结构体时，如果遇到key为JSON的字段标签，则会按照一定规则解析该标签。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 定义一个学生结构体</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name  <span class="type">string</span> <span class="string">`json:&quot;_name&quot;`</span> <span class="comment">// 字段标签的语法</span></span><br><span class="line">	Age   <span class="type">int</span>    <span class="string">`json:&quot;_age&quot;`</span></span><br><span class="line">	Class <span class="type">string</span> <span class="string">`json:&quot;-&quot;`</span> <span class="comment">// 不解析</span></span><br><span class="line">	Phone <span class="type">string</span> <span class="string">`json:&quot;phone&quot;`</span></span><br><span class="line">	Score <span class="type">float32</span> <span class="comment">// 没有标签时，则用字段名</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	s := Student&#123;</span><br><span class="line">		Name:  <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">		Age:   <span class="number">17</span>,</span><br><span class="line">		Class: <span class="string">&quot;三年级&quot;</span>,</span><br><span class="line">		Phone: <span class="string">&quot;17600112222&quot;</span>,</span><br><span class="line">		Score: <span class="number">88.5</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	json1, err := json.Marshal(s)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;json: %s \n&quot;</span>,json1)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出-&gt; json: &#123;&quot;_name&quot;:&quot;张三&quot;,&quot;_age&quot;:17,&quot;phone&quot;:&quot;17600112222&quot;,&quot;Score&quot;:88.5&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>规则总结</strong></p>
<ul>
<li>有标签名时,标签名会作为key</li>
<li>没有标签时,则会使用字段名。</li>
<li>有标签名时，但是标签名的值为-，则不会导出</li>
</ul>
<p><strong>匿名字段</strong><br>json包在解析匿名字段时，会将匿名字段的字段当成该结构体的字段处理。<br>而不会嵌套</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name  <span class="type">string</span> <span class="string">`json:&quot;_name&quot;`</span></span><br><span class="line">	Age   <span class="type">int</span>    <span class="string">`json:&quot;_age&quot;`</span></span><br><span class="line">    Top <span class="comment">// 匿名字段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Top <span class="keyword">struct</span> &#123;</span><br><span class="line">	Sort <span class="type">int</span> <span class="string">`json:&quot;sort&quot;`</span></span><br><span class="line">	Score <span class="type">float64</span></span><br><span class="line">	Class <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	s := Student&#123;</span><br><span class="line">		Name: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">		Age:  <span class="number">18</span>,</span><br><span class="line">		Top:  Top&#123;<span class="number">1</span>,<span class="number">99.5</span>,<span class="string">&quot;一年级&quot;</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	json1, err := json.Marshal(s)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;json: %s \n&quot;</span>,json1)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出-&gt; json: &#123;&quot;_name&quot;:&quot;张三&quot;,&quot;_age&quot;:18,&quot;sort&quot;:1,&quot;Score&quot;:99.5,&quot;Class&quot;:&quot;一年级&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="JSON转结构体"><a href="#JSON转结构体" class="headerlink" title="JSON转结构体"></a>JSON转结构体</h2><p>JSON可以转换成结构体。同编码一样，json包是通过反射机制来实现解码的，因此结构体必须导出所转换的字段，不导出的字段不会被json包解析。另外解析时不区分大小写。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name  <span class="type">string</span> <span class="string">`json:&quot;_name&quot;`</span></span><br><span class="line">	Age   <span class="type">int</span>    <span class="string">`json:&quot;_age&quot;`</span></span><br><span class="line">    Top <span class="comment">// 匿名字段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Top <span class="keyword">struct</span> &#123;</span><br><span class="line">	Sort <span class="type">int</span> <span class="string">`json:&quot;sort&quot;`</span></span><br><span class="line">	Score <span class="type">float64</span></span><br><span class="line">	Class <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	student := Student&#123;&#125;</span><br><span class="line">	js := <span class="string">`&#123;&quot;_name&quot;:&quot;张三&quot;,&quot;_age&quot;:18,&quot;sort&quot;:1,&quot;Score&quot;:99.5,&quot;Class&quot;:&quot;一年级&quot;&#125;`</span></span><br><span class="line">	err := json.Unmarshal([]<span class="type">byte</span>(js), &amp;student)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;v: %+v  t: %T \n&quot;</span>,student,student)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出: v: &#123;Name:张三 Age:18 Top:&#123;Sort:1 Score:99.5 Class:一年级&#125;&#125;  t: main.Student</span></span><br></pre></td></tr></table></figure>

<h2 id="切片转JSON"><a href="#切片转JSON" class="headerlink" title="切片转JSON"></a>切片转JSON</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	student := []<span class="type">string</span> &#123;</span><br><span class="line">		<span class="string">&quot;张三&quot;</span>,</span><br><span class="line">		<span class="string">&quot;李四&quot;</span>,</span><br><span class="line">		<span class="string">&quot;小米&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	marshal, err := json.Marshal(student)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;v :%s T:%T&quot;</span>,marshal,marshal)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 v :[&quot;张三&quot;,&quot;李四&quot;,&quot;小米&quot;] T:[]uint8</span></span><br></pre></td></tr></table></figure>

<h2 id="JSON转切片"><a href="#JSON转切片" class="headerlink" title="JSON转切片"></a>JSON转切片</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	json1 := <span class="string">`[&quot;张三&quot;,&quot;李四&quot;,&quot;小米&quot;]`</span></span><br><span class="line">	<span class="keyword">var</span> sc []<span class="type">string</span></span><br><span class="line">	err := json.Unmarshal([]<span class="type">byte</span>(json1), &amp;sc)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;v :%v T:%T&quot;</span>,sc,sc)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出: v :[张三 李四 小米] T:[]string</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go文件操作</title>
    <url>/2021/05/08/go%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote>
<p>在Go语言中，文件操作的大多数函数都在os包里面，文件的信息包括文件名、文件大小、修改权限、修改时间等。</p>
</blockquote>
<span id="more"></span>

<h3 id="文件接口属性-FileInfo"><a href="#文件接口属性-FileInfo" class="headerlink" title="文件接口属性(FileInfo)"></a>文件接口属性(FileInfo)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> FileInfo <span class="keyword">interface</span> &#123;</span><br><span class="line"> Name() <span class="type">string</span>       <span class="comment">// 文件名</span></span><br><span class="line"> Size() <span class="type">int64</span>        <span class="comment">// 文件大小</span></span><br><span class="line"> Mode() FileMode     <span class="comment">// 修改权限</span></span><br><span class="line"> ModTime() time.Time <span class="comment">// 最后修改时间</span></span><br><span class="line"> IsDir() <span class="type">bool</span>        <span class="comment">// 判断是否是目录</span></span><br><span class="line"> Sys() <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// 文件的详细信息，获取的值是*syscall.Stat_t类型 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件信息结构体-fileStat"><a href="#文件信息结构体-fileStat" class="headerlink" title="文件信息结构体(fileStat)"></a>文件信息结构体(fileStat)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> fileStat <span class="keyword">struct</span> &#123;</span><br><span class="line"> name    <span class="type">string</span></span><br><span class="line"> size    <span class="type">int64</span></span><br><span class="line"> mode    FileMode</span><br><span class="line"> modTime time.Time</span><br><span class="line"> sys     syscall.Stat_t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="fileStat结构体的常用方法汇总"><a href="#fileStat结构体的常用方法汇总" class="headerlink" title="fileStat结构体的常用方法汇总"></a>fileStat结构体的常用方法汇总</h3><table>
    <tr>
        <th>方法名</th><th>描述</th>
    </tr>
    <tr>
        <td>Name() string</td><td>返回文件名</td>
    </tr>
    <tr>
        <td>IsDir() bool</td><td>判断是否是目录</td>
    </tr>
    <tr>
        <td>Size() int64</td><td>返回文件大小</td>
    </tr>
    <tr>
        <td>Mode() FileMode</td><td>返回文件权限</td>
    </tr>
    <tr>
        <td>ModTime() time.Time</td><td>文件的最后修改时间</td>
    </tr>
    <tr>
        <td>Sys() interface{}</td><td>文件的详细信息，获取的值是*syscall.Stat_t类型</td>
    </tr>
</table>

<p><strong>使用示例</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fp := <span class="string">&quot;./test.txt&quot;</span></span><br><span class="line">	fileInfo, err := os.Stat(fp)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err.Error())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;类型: %T\n&quot;</span>, fileInfo)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;文件名: %v\n&quot;</span>, fileInfo.Name())</span><br><span class="line">	fmt.Printf(<span class="string">&quot;文件大小: %v\n&quot;</span>, fileInfo.Size())</span><br><span class="line">	fmt.Printf(<span class="string">&quot;是否为目录: %v\n&quot;</span>, fileInfo.IsDir())</span><br><span class="line">	fmt.Printf(<span class="string">&quot;文件权限: %v\n&quot;</span>, fileInfo.Mode())</span><br><span class="line">	fmt.Printf(<span class="string">&quot;文件最后修改的时间: %v\n&quot;</span>, fileInfo.ModTime())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><img src="f7ba8d9a73981205670855cc27c8b705258faf5008f71308c710d1f3a28cbfe8.png" alt="图 1">  </p>
<h2 id="求路径方法"><a href="#求路径方法" class="headerlink" title="求路径方法"></a>求路径方法</h2><p><strong>方法列表</strong><br>方法的所属包: <code>path/filepath</code></p>
<table>
    <tr>
        <th>方法名</th><th>描述</th>
    </tr>
    <tr>
        <td>IsAbs(path string) bool</td><td>判断是否是绝对路径</td>
    </tr>
    <tr>
        <td>Rel(basepath, targpath string) (string, error)</td><td>返回一个相对于basepath的路径</td>
    </tr>
    <tr>
        <td>Abs(path string) (string, error)</td><td>返回绝对路径</td>
    </tr>
    <tr>
        <td>Join(elem ...string) string</td><td>拼接路径</td>
    </tr>
</table>

<p><strong>使用示例</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	basePath, _ := filepath.Abs(filepath.Dir(os.Args[<span class="number">0</span>]))</span><br><span class="line">	fp1 := <span class="string">&quot;./test.txt&quot;</span></span><br><span class="line">	fp2 := <span class="string">&quot;/home/rma/mr_work/go_test/pkg/test.log&quot;</span></span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;当前程序的绝对路径:  %v\n&quot;</span>, basePath)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;是绝对路径？: %t\n&quot;</span>, filepath.IsAbs(fp1))</span><br><span class="line">	<span class="comment">// 相对路径</span></span><br><span class="line">	rel, err := filepath.Rel(basePath, fp2)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;fp2的相对路径:  %v\n&quot;</span>, rel)</span><br><span class="line">	<span class="comment">// 绝对路径</span></span><br><span class="line">	abs, err := filepath.Abs(fp1)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;fp1的绝对路径:  %s\n&quot;</span>, abs)</span><br><span class="line">	<span class="comment">// 拼接路径</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;拼接路径1: %s \n&quot;</span>, path.Join(<span class="string">&quot;/home/Item&quot;</span>, <span class="string">&quot;go&quot;</span>, <span class="string">&quot;study&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><img src="2af4c1123ebb00e55e56c87056a39c3ee9b37ce0175259158bbf541cc6a72d37.png" alt="图 2">  </p>
<h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><p><strong>方法列表</strong></p>
<table>
    <tr>
        <th>方法名</th><th>描述</th>
    </tr>
    <tr>
        <td>os.Mkdir(name string, perm FileMode) error</td><td>创建名称为name的目录，权限设置是perm</td>
    </tr>
    <tr>
        <td>os.MkdirAll(path string, perm FileMode) error</td><td>根据path创建多级子目录</td>
    </tr>
</table>

<p><strong>使用示例</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	dirName := <span class="string">&quot;./img&quot;</span></span><br><span class="line">	<span class="comment">// 创建目录,并分配权限</span></span><br><span class="line">	err := os.Mkdir(dirName, os.ModePerm)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(dirName + <span class="string">&quot;  创建成功!&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建多级目录</span></span><br><span class="line">	dirName2 := <span class="string">&quot;./public/static/css&quot;</span></span><br><span class="line">	err = os.MkdirAll(dirName2, os.ModePerm)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(dirName2 + <span class="string">&quot;  创建成功!&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><img src="f326d3b1e256fdf20ecc79c9d5e8daef8a114651ae0cc1e934258482bff3db7b.png" alt="图 3">  </p>
<h3 id="删除目录-文件"><a href="#删除目录-文件" class="headerlink" title="删除目录/文件"></a>删除目录/文件</h3><p><strong>方法列表</strong></p>
<table>
    <tr>
        <th>方法名</th><th>描述</th>
    </tr>
    <tr>
        <td>os.Remove(name string) error</td><td>删除名称为name的目录/文件，当目录下有文件或者其他目录会出错</td>
    </tr>
    <tr>
        <td>os.RemoveAll(path string) error error</td><td>根据path删除多级子目录</td>
    </tr>
</table>

<p><strong>使用示例</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	err := os.Remove(<span class="string">&quot;./img&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Remove-&gt; 删除失败: &quot;</span> + err.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Remove-&gt; 删除成功!&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err1 := os.Remove(<span class="string">&quot;./test.log&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Remove-&gt; 删除失败: &quot;</span> + err1.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Remove-&gt; 删除成功!&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err1 = os.Remove(<span class="string">&quot;./public&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Remove-&gt; 删除失败: &quot;</span> + err1.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Remove-&gt; 删除成功!&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除多级子目录</span></span><br><span class="line">	err2 := os.RemoveAll(<span class="string">&quot;./public&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err2 != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;RemoveAll-&gt; 删除失败: &quot;</span> + err2.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;RemoveAll-&gt; 删除成功!&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="162909921ab7efbe9f64ac26c5fd54ca0849730f534838dbf0bfe71ebeb69a34.png" alt="图 4">  </p>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><p><code>os.Create()</code>创建文件，如果文件存在，会将其覆盖。<code>os.Create()</code>本质上调用的是<code>OpenFile</code>, 源码如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">(name <span class="type">string</span>)</span></span> (*File, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, <span class="number">0666</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用示例</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fileName := <span class="string">&quot;./file/a.txt&quot;</span></span><br><span class="line">	<span class="comment">//如果文件存在,则会覆盖</span></span><br><span class="line">	create, err := os.Create(fileName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;创建失败: &quot;</span> + err.Error())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;创建成功! %v\n&quot;</span>, create)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建成功! &amp;&#123;0xc00006e180&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="打开和关闭文件"><a href="#打开和关闭文件" class="headerlink" title="打开和关闭文件"></a>打开和关闭文件</h3><p><strong>方法列表</strong></p>
<table>
    <tr>
        <th>方法名</th><th>描述</th>
    </tr>
    <tr>
        <td>Open(name string) (*File, error)</td><td>只读模式打开文件，本质上调用的是OpenFile</td>
    </tr>
    <tr>
        <td>OpenFile(name string, flag int, perm FileMode) (*File, error)</td><td>打开文件，可以传入模式和权限</td>
    </tr>
</table>

<p><strong>OpenFile入参介绍</strong></p>
<table>
    <tr>
        <th>flag值</th><th>代表的模式</th>
    </tr>
    <tr>
        <td>O_RDONLY</td><td>只读模式</td>
    </tr>
    <tr>
        <td>O_WRONLY</td><td>只写模式</td>
    </tr>
    <tr>
        <td>O_RDWR</td><td>读写模式</td>
    </tr>
    <tr>
        <td>O_APPEND</td><td>追加模式</td>
    </tr>
    <tr>
        <td>O_CREATE</td><td>文件不存在，则创建</td>
    </tr>
    <tr>
        <td>O_EXCL</td><td>和O_CREATE配合使用，文件必须不存在</td>
    </tr>
    <tr>
        <td>O_SYNC</td><td>打开文件用于同步I/O</td>
    </tr>
    <tr>
        <td>O_TRUNC</td><td>如果可能，打开时清空文件</td>
    </tr>
</table>

<p><strong>使用示例</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 该文件不存在</span></span><br><span class="line">	fileName := <span class="string">&quot;./public/test.txt&quot;</span></span><br><span class="line">	file1, err := os.Open(fileName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;os.Open 打开文件失败，err:%s \n&quot;</span>, err.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;os.Open 打开文件成功，open:%v \n&quot;</span>, file1)</span><br><span class="line">		<span class="comment">// 关闭文件</span></span><br><span class="line">		<span class="keyword">defer</span> file1.Close()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 文件不存在，则会创建文件</span></span><br><span class="line">	file2, err1 := os.OpenFile(fileName, os.O_CREATE, os.ModePerm)</span><br><span class="line">	<span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;os.OpenFile 打开文件失败，err:%s \n&quot;</span>, err1.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;os.OpenFile 打开文件成功，open:%v \n&quot;</span>, file2)</span><br><span class="line">		<span class="comment">// 关闭文件</span></span><br><span class="line">		<span class="keyword">defer</span> file2.Close()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">os.Open 打开文件失败，err:open ./public/test.txt: no such file or directory </span></span><br><span class="line"><span class="comment">os.OpenFile 打开文件成功，open:&amp;&#123;0xc0000b0120&#125; </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p>读取文件步骤: 打开文件(<code>Open</code>) 、读取文件(<code>Read</code>)、关闭文件(<code>Close</code>)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fileName := <span class="string">&quot;./public/test.txt&quot;</span></span><br><span class="line">	file1, err := os.Open(fileName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;os.Open 打开文件失败，err:%s \n&quot;</span>, err.Error())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 定义一个变量存储读取的内容</span></span><br><span class="line">	b := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">	<span class="comment">// 读取文件</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		read, _ := file1.Read(b)</span><br><span class="line">		<span class="keyword">if</span> read == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;读取内容: %s \n&quot;</span>, b)</span><br><span class="line">	<span class="comment">// 关闭文件</span></span><br><span class="line">	_ = file1.Close()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">读取内容: hello world</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><p>写入文件步骤: 打开文件(<code>OpenFile</code>) 、写入文件(<code>Write</code>)、关闭文件(<code>Close</code>)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fileName := <span class="string">&quot;./public/hello.txt&quot;</span></span><br><span class="line">	<span class="comment">// 读写|创建|追加的模式 模式打开文件</span></span><br><span class="line">	file1, err := os.OpenFile(fileName, os.O_RDWR|os.O_CREATE|os.O_APPEND, os.ModePerm)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;os.OpenFile 打开文件失败，err:%s \n&quot;</span>, err.Error())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 写入文件</span></span><br><span class="line">	write, err := file1.Write([]<span class="type">byte</span>(<span class="string">&quot;Go! Go! Let&#x27;s Go!! 汉字 \n&quot;</span>))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;写入失败: %s \n&quot;</span>, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;写入字节数: %d \n&quot;</span>, write)</span><br><span class="line">	<span class="comment">// 关闭文件</span></span><br><span class="line">	_ = file1.Close()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">写入字节数: 27</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h3><p>Go语言提供了<code>io.copy()</code>方法，用来复制文件。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 把fileA文件复制给fileB</span></span><br><span class="line">	fileA := <span class="string">&quot;./public/hello.txt&quot;</span></span><br><span class="line">	fileB := <span class="string">&quot;./public/new.txt&quot;</span></span><br><span class="line">	<span class="comment">// 打开源文件</span></span><br><span class="line">	sourceA, err := os.Open(fileA)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;os.Open 打开文件失败，err:%s \n&quot;</span>, err.Error())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 关闭文件A</span></span><br><span class="line">	<span class="keyword">defer</span> sourceA.Close()</span><br><span class="line">	<span class="comment">// 打开新文件</span></span><br><span class="line">	targetB, err := os.Create(fileB)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;os.Create 创建新文件失败，err:%s \n&quot;</span>, err.Error())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 关闭文件B</span></span><br><span class="line">	<span class="keyword">defer</span> targetB.Close()</span><br><span class="line">	<span class="comment">// 把fileA文件复制给fileB</span></span><br><span class="line">	written, err := io.Copy(targetB, sourceA)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;文件复制失败，err:%s \n&quot;</span>, err.Error())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;文件复制成功: %d \n&quot;</span>, written)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">文件复制成功: 54</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>os系统基本操作包使用</title>
    <url>/2021/05/07/os%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%8C%85%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote>
<p>os包中提供了操作系统函数的接口，是一个比较重要的包。它的作用主要是在服务器上进行系统的基本操作，如文件操作、目录操作、执行命令、信号与中断、进程、系统状态等等。下面分模块归纳一些常用函数。</p>
</blockquote>
<span id="more"></span>

<h2 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h2><p><strong>函数列表</strong></p>
<table>
    <tr>
        <th>函数</th><th>功能</th>
    </tr>
    <tr>
        <td>Hostname()</td><td>获取当前主机名</td>
    </tr>
    <tr>
        <td>Getpid()</td><td>返回调用者所在进程的进程ID</td>
    </tr>
    <tr>
        <td>Getppid()</td><td>返回调用者所在进程的父进程的进程ID</td>
    </tr>
    <tr>
        <td>Exit()</td><td>让程序以状态码code退出。状态码0表示成功，非0表示出错。code取值范围： [0,125]</td>
    </tr>
</table>

<p><strong>代码示例</strong><br><strong>系统相关</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	hostname, _ := os.Hostname()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;主机名:%v \n&quot;</span>, hostname)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;调用者所在进程的进程ID: %v \n&quot;</span>, os.Getpid())</span><br><span class="line">	fmt.Printf(<span class="string">&quot;调用者所在进程的进程的父进程ID: %v \n&quot;</span>, os.Getppid())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><img src="25716b6374e3cdaa9cca7b44ac92f5a570725bfb9f503c6d170ce72cdeb12ea7.png" alt="图 1">  </p>
<p><strong>Exit</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;调用前打印...&quot;</span>)</span><br><span class="line">	<span class="comment">// 调用退出程序：code范围应在 0 &lt;= x &lt;= 125</span></span><br><span class="line">	os.Exit(<span class="number">0</span>)</span><br><span class="line">	<span class="comment">// 后面代码不会执行</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;调用后，这里不会输出&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><img src="be49c0cb5940e2f06b09cd48e0b638be6d7027904b67f257b44349c917b2ef31.png" alt="图 2">  </p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p><strong>函数列表</strong></p>
<table>
    <tr>
        <th>函数</th><th>功能</th>
    </tr>
    <tr>
        <td>Environ()</td><td>获取所有环境变量</td>
    </tr>
    <tr>
        <td>Setenv(key, value string)</td><td>设置环境变量</td>
    </tr>
    <tr>
        <td>Getenv(key string)</td><td>获取环境变量</td>
    </tr>
    <tr>
        <td>Clearenv()</td><td>清空所有环境变量</td>
    </tr>
</table>

<p><strong>代码示例</strong><br><strong>环境变量相关</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 所有环境变量</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;所有环境变量:%+v \n&quot;</span>, os.Environ())</span><br><span class="line">	<span class="comment">// 设置环境变量</span></span><br><span class="line">	_ = os.Setenv(<span class="string">&quot;my-name&quot;</span>, <span class="string">&quot;张三&quot;</span>)</span><br><span class="line">	<span class="comment">// 获取环境变量</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;获取环境变量: %v \n&quot;</span>, os.Getenv(<span class="string">&quot;my-name&quot;</span>))</span><br><span class="line">	<span class="comment">// 清空所有环境变量</span></span><br><span class="line">	os.Clearenv()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;清空环境变量后:%+v \n&quot;</span>, os.Environ())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><img src="9dd404b3c1d594ab4b191d9b9ecec66551749e6d89620b8e744b0ca87540b88c.png" alt="图 3">  </p>
<h2 id="文件相关"><a href="#文件相关" class="headerlink" title="文件相关"></a>文件相关</h2><p>关于文件相关的函数，参见之前的文章 go文件操作</p>
<h2 id="进程相关"><a href="#进程相关" class="headerlink" title="进程相关"></a>进程相关</h2><p><strong>方法列表</strong></p>
<table>
    <tr>
        <th>函数名</th><th>功能</th>
    </tr>
    <tr>
        <td>os.StartProcess(..) (*Process, error)</td><td>根据提供的参数创建一个新进程</td>
    </tr>
    <tr>
        <td>p.Signal(sig Signal)</td><td>向进程发送一个信号</td>
    </tr>
    <tr>
        <td>p.Wait()</td><td>阻塞到进程退出,返回类型*os.ProcessState</td>
    </tr>
    <tr>
        <td>ps.Pid()</td><td>返回一个已退出进程的id</td>
    </tr>
    <tr>
        <td>ps.Exited()</td><td>报告进程是否已退出</td>
    </tr>
    <tr>
        <td>ps.Success()</td><td>报告进程是否成功退出，在Unix中状态码0代表退出。</td>
    </tr>
    <tr>
        <td>ps.SystemTime()</td><td>退出进程及子进程耗费的系统CPU时间</td>
    </tr>
    <tr>
        <td>ps.UserTime()</td><td>退出进程及子进程耗费的用户CPU时间</td>
    </tr>
    <tr>
        <td>ps.String()</td><td>退出进程的状态信息</td>
    </tr>
</table>

<p>上表中<code>p</code>代表: <code>*os.Process</code>,  <code>ps</code>代表: <code>*os.ProcessState</code></p>
<p><strong>代码示例</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个新进程执行； ls /</span></span><br><span class="line">	args := []<span class="type">string</span>&#123;<span class="string">&quot;/&quot;</span>&#125;</span><br><span class="line">	process, err := os.StartProcess(<span class="string">&quot;/bin/ls&quot;</span>, args, &amp;os.ProcAttr&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;创建新进程失败: &quot;</span> + err.Error())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;当前新线程信息: %+v \n&quot;</span>, process)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2秒后向进程发送信号</span></span><br><span class="line">	time.AfterFunc(<span class="number">2</span>*time.Second, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;发送进程退出信号...&quot;</span>)</span><br><span class="line">		_ = process.Signal(os.Kill)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">// 手动阻塞看是否执行：发送信号</span></span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待进程退出,返回ProcessState类型</span></span><br><span class="line">	processState, _ := process.Wait()</span><br><span class="line">	<span class="comment">// 返回一个已退出进程的id</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;当前进程Id: %v \n&quot;</span>, processState.Pid())</span><br><span class="line">	<span class="comment">// 报告进程是否已退出</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;进程是否已退出: %v \n&quot;</span>, processState.Exited())</span><br><span class="line">	<span class="comment">// 报告进程是否成功退出，如在Unix里以状态码0退出。</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;进程是否成功退出: %v \n&quot;</span>, processState.Success())</span><br><span class="line">	<span class="comment">// 返回已退出进程及其子进程耗费的系统CPU时间。</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;进程及子进程耗费系统CPU时间: %v \n&quot;</span>, processState.SystemTime())</span><br><span class="line">	<span class="comment">// 返回已退出进程及其子进程耗费的用户CPU时间。</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;进程及子进程耗费用户CPU时间: %v \n&quot;</span>, processState.UserTime())</span><br><span class="line">	fmt.Printf(<span class="string">&quot;进程状态: %s \n&quot;</span>, processState.String())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:<br><img src="e92f9e91fc71640b2a8c1309f422cebddff4e062b3925d0bf7b90fd1df2275b6.png" alt="图 4">  </p>
<h2 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h2><p><code>os/exec</code>包执行外部命令。它包装了<code>os.StartProcess</code>函数以便更容易的修正输入和输出，使用管道连接I/O，以及其它的一些优化。</p>
<p><strong>方法列表</strong></p>
<table>
    <tr>
        <th>函数名</th><th>功能</th>
    </tr>
    <tr>
        <td>LookPath(file string) (string, error)</td><td>在环境变量PATH中搜索可执行文件</td>
    </tr>
    <tr>
        <td>(c *Cmd) Run() error</td><td>执行c包含的命令，并阻塞直到完成</td>
    </tr>
    <tr>
        <td>(c *Cmd) Start() error</td><td>执行c包含的命令即刻返回，但不会等待该命令完成。</td>
    </tr>
    <tr>
        <td>(c *Cmd) Wait() error</td><td>会阻塞直到该命令执行完成,和Start()结合使用</td>
    </tr>
    <tr>
        <td>(c *Cmd) Output() ([]byte, error)</td><td>执行命令并返回标准输出的切片</td>
    </tr>
    <tr>
        <td>(c *Cmd) CombinedOutput() ([]byte, error)</td><td>执行命令并返回标准输出和错误输出合并的切片。</td>
    </tr>
</table>


<p><strong>使用示例</strong><br><code>LookPath</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在环境变量PATH中搜索可执行文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	path, err := exec.LookPath(<span class="string">&quot;go&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><img src="ea3f85148064bee0fdd191e68ce25d2976499e77d1570616931eec0bf19aafed.png" alt="图 5">  </p>
<p><code>Run</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用Run()执行命令</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cmd := exec.Command(<span class="string">&quot;sleep&quot;</span>, <span class="string">&quot;3s&quot;</span>)</span><br><span class="line">	<span class="comment">// 具体执行</span></span><br><span class="line">	err := cmd.Run()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;执行失败:%v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;cmd.Path: %v \n&quot;</span>, cmd.Path)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;cmd.Args: %v \n&quot;</span>, cmd.Args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><img src="897245d982566520021da8587f21c86f1813a8a9a1ac1c17bacd8a9c2fcf9d9b.png" alt="图 6">  </p>
<p><code>Start</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用Start执行命令</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cmd := exec.Command(<span class="string">&quot;sleep&quot;</span>, <span class="string">&quot;3s&quot;</span>)</span><br><span class="line">	<span class="comment">// Start开始执行c包含的命令，但并不会等待该命令完成即返回</span></span><br><span class="line">	err := cmd.Start()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;执行失败:%v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//Wait会阻塞直到该命令执行完成</span></span><br><span class="line">	err = cmd.Wait()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;执行完成: %v \n&quot;</span>, err)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;cmd.Path: %v \n&quot;</span>, cmd.Path)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;cmd.Args: %v \n&quot;</span>, cmd.Args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：<br><img src="25db6b3665963391aa957243a001cac77e91cf956ddcf773d26c122a0e3fb24c.png" alt="图 7">  </p>
<p><code>Output</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行命令并获取输出结果</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	output, _ := exec.Command(<span class="string">&quot;go&quot;</span>, <span class="string">&quot;version&quot;</span>).Output()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;结果: %s&quot;</span>, output)</span><br><span class="line">	<span class="comment">// 执行: du -sh .</span></span><br><span class="line">	output2, _ := exec.Command(<span class="string">&quot;du&quot;</span>, <span class="string">&quot;-sh&quot;</span>, <span class="string">&quot;.&quot;</span>).Output()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;结果: %s&quot;</span>, output2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><img src="78341914658e18326703cb8e438ce6ed7a4fe687ce368984b81ebe5a3b3e7a5d.png" alt="图 8">  </p>
<p><code>CombinedOutput</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行命令并返回标准输出和错误输出合并的切片</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 执行: go version-1 故意写错</span></span><br><span class="line">	output, _ := exec.Command(<span class="string">&quot;go&quot;</span>, <span class="string">&quot;version-1&quot;</span>).Output()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;结果1: %s \n&quot;</span>, output)</span><br><span class="line"></span><br><span class="line">	output, _ = exec.Command(<span class="string">&quot;go&quot;</span>, <span class="string">&quot;version-1&quot;</span>).CombinedOutput()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;结果2: %s \n&quot;</span>, output)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><img src="c83901869a7a52f6d0eec8e4269aece5cabee87d8918ff1a347a74f75841cb5f.png" alt="图 9">  </p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>rune字符操作包(unicode)</title>
    <url>/2021/05/06/rune%E5%AD%97%E7%AC%A6%E6%93%8D%E4%BD%9C%E5%8C%85-unicode/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote>
<p>unicode包提供了诸多处理rune字符相关功能的函数（比如区分字母和数字，或者是字母的大写和小写转换等)</p>
</blockquote>
<span id="more"></span>

<p><strong>说明</strong>：<br>golang中的字符有两种，<code>uint8（byte）</code>代表<code>ASCII</code>的一个字符，<code>rune</code>代表一个<code>utf-8</code>字符。<br>当需要处理中文、日文或者其他复合字符时，则需要用到<code>rune</code>类型，rune实际是一个<code>int32</code></p>
<h2 id="判断函数"><a href="#判断函数" class="headerlink" title="判断函数"></a>判断函数</h2><h3 id="是否为空格-IsSpace"><a href="#是否为空格-IsSpace" class="headerlink" title="是否为空格(IsSpace)"></a>是否为空格(IsSpace)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rune1 := <span class="string">&#x27; &#x27;</span></span><br><span class="line">	rune2 := <span class="string">&#x27;h&#x27;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%c] 是空格? %t\n&quot;</span>, rune1, unicode.IsSpace(rune1))</span><br><span class="line">	<span class="comment">// 输出 [ ] 是空格? true</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%c] 是空格? %t\n&quot;</span>, rune2, unicode.IsSpace(rune2))</span><br><span class="line">	<span class="comment">// 输出 [h] 是空格? false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="是否为十进制数-IsDigit"><a href="#是否为十进制数-IsDigit" class="headerlink" title="是否为十进制数(IsDigit)"></a>是否为十进制数(IsDigit)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	d1 := <span class="string">&#x27;1&#x27;</span></span><br><span class="line">	d2 := <span class="string">&#x27;w&#x27;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%c] 是十进制数? %t\n&quot;</span>, d1, unicode.IsDigit(d1))</span><br><span class="line">	<span class="comment">// 输出: [1] 是十进制数? true</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%c] 是十进制数? %t\n&quot;</span>, d2, unicode.IsDigit(d2))</span><br><span class="line">	<span class="comment">// 输出: [w] 是十进制数? false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="是否为数字-IsNumber"><a href="#是否为数字-IsNumber" class="headerlink" title="是否为数字(IsNumber)"></a>是否为数字(IsNumber)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	d1 := <span class="string">&#x27;1&#x27;</span></span><br><span class="line">	d2 := <span class="string">&#x27;w&#x27;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%c] 是数字? %t\n&quot;</span>, d1, unicode.IsNumber(d1))</span><br><span class="line">	<span class="comment">// 输出: [1] 是数字? true</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%c] 是数字? %t\n&quot;</span>, d2, unicode.IsNumber(d2))</span><br><span class="line">	<span class="comment">// 输出: [w] 是数字? false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="是否为字母字符-IsLetter"><a href="#是否为字母字符-IsLetter" class="headerlink" title="是否为字母字符(IsLetter)"></a>是否为字母字符(IsLetter)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str1 := <span class="string">&#x27;刘&#x27;</span></span><br><span class="line">	str2 := <span class="string">&#x27;l&#x27;</span></span><br><span class="line">	str3 := <span class="string">&#x27;W&#x27;</span></span><br><span class="line">	str4 := <span class="string">&#x27;!&#x27;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%c] 是字母? %t\n&quot;</span>, str1, unicode.IsLetter(str1))</span><br><span class="line">	<span class="comment">// [刘] 是字母? true</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%c] 是字母? %t\n&quot;</span>, str2, unicode.IsLetter(str2))</span><br><span class="line">	<span class="comment">// [l] 是字母? true</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%c] 是字母? %t\n&quot;</span>, str3, unicode.IsLetter(str3))</span><br><span class="line">	<span class="comment">// [W] 是字母? true</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%c] 是字母? %t\n&quot;</span>, str4, unicode.IsLetter(str4))</span><br><span class="line">	<span class="comment">// [!] 是字母? false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>: 汉字也是一个字母字符</p>
<h3 id="是否为标点符号-IsPunct"><a href="#是否为标点符号-IsPunct" class="headerlink" title="是否为标点符号(IsPunct)"></a>是否为标点符号(IsPunct)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str1 := <span class="string">&#x27;刘&#x27;</span></span><br><span class="line">	str2 := <span class="string">&#x27;l&#x27;</span></span><br><span class="line">	str3 := <span class="string">&#x27;!&#x27;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%c] 是标点符号? %t\n&quot;</span>, str1, unicode.IsPunct(str1))</span><br><span class="line">	<span class="comment">// [刘] 是标点符号? false</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%c] 是标点符号? %t\n&quot;</span>, str2, unicode.IsPunct(str2))</span><br><span class="line">	<span class="comment">// [l] 是标点符号? false</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%c] 是标点符号? %t\n&quot;</span>, str3, unicode.IsPunct(str3))</span><br><span class="line">	<span class="comment">// [!] 是标点符号? true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="是否为小写字母-IsLower"><a href="#是否为小写字母-IsLower" class="headerlink" title="是否为小写字母(IsLower)"></a>是否为小写字母(IsLower)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str1 := <span class="string">&#x27;刘&#x27;</span></span><br><span class="line">str2 := <span class="string">&#x27;l&#x27;</span></span><br><span class="line">str3 := <span class="string">&#x27;W&#x27;</span></span><br><span class="line">str4 := <span class="string">&#x27;!&#x27;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%c] 是小写字母? %t\n&quot;</span>, str1, unicode.IsLower(str1))</span><br><span class="line"><span class="comment">// [刘] 是小写字母? false</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%c] 是小写字母? %t\n&quot;</span>, str2, unicode.IsLower(str2))</span><br><span class="line"><span class="comment">// [l] 是小写字母? true</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%c] 是小写字母? %t\n&quot;</span>, str3, unicode.IsLower(str3))</span><br><span class="line"><span class="comment">// [W] 是小写字母? false</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%c] 是小写字母? %t\n&quot;</span>, str4, unicode.IsLower(str4))</span><br><span class="line"><span class="comment">// [!] 是小写字母? false</span></span><br></pre></td></tr></table></figure>

<h3 id="是否为大写字母-IsUpper"><a href="#是否为大写字母-IsUpper" class="headerlink" title="是否为大写字母(IsUpper)"></a>是否为大写字母(IsUpper)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str1 := <span class="string">&#x27;刘&#x27;</span></span><br><span class="line">	str2 := <span class="string">&#x27;l&#x27;</span></span><br><span class="line">	str3 := <span class="string">&#x27;W&#x27;</span></span><br><span class="line">	str4 := <span class="string">&#x27;!&#x27;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%c] 是大写字母? %t\n&quot;</span>, str1, unicode.IsUpper(str1))</span><br><span class="line">	<span class="comment">// [刘] 是大写字母? false</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%c] 是大写字母? %t\n&quot;</span>, str2, unicode.IsUpper(str2))</span><br><span class="line">	<span class="comment">// [l] 是大写字母? false</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%c] 是大写字母? %t\n&quot;</span>, str3, unicode.IsUpper(str3))</span><br><span class="line">	<span class="comment">// [W] 是大写字母? true</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%c] 是大写字母? %t\n&quot;</span>, str4, unicode.IsUpper(str4))</span><br><span class="line">	<span class="comment">// [!] 是大写字母? false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="是否为汉字"><a href="#是否为汉字" class="headerlink" title="是否为汉字"></a>是否为汉字</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str1 := <span class="string">&#x27;刘&#x27;</span></span><br><span class="line">	str2 := <span class="string">&#x27;l&#x27;</span></span><br><span class="line">	str3 := <span class="string">&#x27;!&#x27;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%c] 是汉字? %t\n&quot;</span>, str1, unicode.Is(unicode.Scripts[<span class="string">&quot;Han&quot;</span>], str1))</span><br><span class="line">	<span class="comment">// [刘] 是汉字? true</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%c] 是汉字? %t\n&quot;</span>, str2, unicode.Is(unicode.Scripts[<span class="string">&quot;Han&quot;</span>], str2))</span><br><span class="line">	<span class="comment">// [l] 是汉字? false</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%c] 是汉字? %t\n&quot;</span>, str3, unicode.Is(unicode.Scripts[<span class="string">&quot;Han&quot;</span>], str3))</span><br><span class="line">	<span class="comment">// [!] 是汉字? false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h2><h3 id="转成小写-ToLower"><a href="#转成小写-ToLower" class="headerlink" title="转成小写(ToLower)"></a>转成小写(ToLower)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str1 := <span class="string">&#x27;W&#x27;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%c] 转成小写: %c \n&quot;</span>, str1, unicode.ToLower(str1))</span><br><span class="line"><span class="comment">// [W] 转成小写: w </span></span><br></pre></td></tr></table></figure>

<h3 id="转成大写-ToUpper"><a href="#转成大写-ToUpper" class="headerlink" title="转成大写(ToUpper)"></a>转成大写(ToUpper)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str2 := <span class="string">&#x27;a&#x27;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%c] 转成大写: %c \n&quot;</span>, str2, unicode.ToUpper(str2))</span><br><span class="line"><span class="comment">// [a] 转成大写: A</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>sort排序和查询</title>
    <url>/2021/04/30/sort%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote>
<p>sort包实现了四种基本排序算法：插入排序、归并排序、堆排序、快速排序。 但是这四种排序方法是不公开的，它们只能在 sort 包内部使用。sort 包会根据实际数据自动选择高效的排序算法，所以在对数据集合排序时不必考虑应当选择哪一种排序方法，只要实现了 sort.Interface 定义的三个方法,就可以顺利对数据集合进行排序</p>
</blockquote>
<span id="more"></span>

<p><code>Len() int</code>: 获取数据集合长度。<br><code>Less() bool</code>: 比较两个元素大小。<br><code>Swap()</code>: 交换两个元素位置。</p>
<h3 id="支持功能"><a href="#支持功能" class="headerlink" title="支持功能"></a>支持功能</h3><p>sort 包对[]int 、[]float64 、[]string 切片提供了完整的支持，主要功能有：</p>
<p>对基本数据类型切片的排序。<br>基本数据元素查找。<br>判断基本数据类型切片是否已经排序。<br>对排好序的数据集合逆序。</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 定义整数序列</span></span><br><span class="line">	nums := sort.IntSlice&#123;<span class="number">10</span>, <span class="number">40</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">23</span>, <span class="number">72</span>, <span class="number">89</span>&#125;</span><br><span class="line">	<span class="comment">// 排序</span></span><br><span class="line">	nums.Sort()</span><br><span class="line">	<span class="comment">// 判断是否已排序</span></span><br><span class="line">	<span class="keyword">if</span> sorted := sort.IsSorted(nums); sorted &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;排序结果:%+v\n&quot;</span>, nums)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;排序失败！&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 输出:</span></span><br><span class="line"><span class="comment">排序结果:[6 9 10 23 40 72 89]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="sort-Ints"><a href="#sort-Ints" class="headerlink" title="sort.Ints"></a>sort.Ints</h3><p>将 []int 进行升序排序。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="type">int</span>&#123;<span class="number">23</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">89</span>&#125;</span><br><span class="line">	<span class="comment">// 调用排序</span></span><br><span class="line">	sort.Ints(a)</span><br><span class="line">	<span class="comment">// 检测是否已经排序</span></span><br><span class="line">	<span class="keyword">if</span> sorted := sort.IntsAreSorted(a); sorted &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;排序成功: %v\n&quot;</span>, a)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;排序失败: %v\n&quot;</span>, a)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 查找元素</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;查找元素(存在): %v 索引:%v \n&quot;</span>, <span class="number">12</span>, sort.SearchInts(a, <span class="number">12</span>))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;查找元素(不存在): %v 索引:%v \n&quot;</span>, <span class="number">22</span>, sort.SearchInts(a, <span class="number">22</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 输出</span></span><br><span class="line"><span class="comment">排序成功: [2 3 9 12 12 23 89]</span></span><br><span class="line"><span class="comment">查找元素(存在): 12 索引:3 </span></span><br><span class="line"><span class="comment">查找元素(不存在): 22 索引:5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>同样的方法还有：<br><code>sort.Float64s</code>、<code>sort.Strings</code></p>
<h3 id="降序"><a href="#降序" class="headerlink" title="降序"></a>降序</h3><p>降序原理<br>前面介绍的都是排序规则都是升序(sort包默认都是升序),如果想要降序，可以使用sort.Reverse来调换Less()参数，从而实现降序的目的。</p>
<p><code>sort.Reverse</code> 源码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接收一个Interface类型参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(data Interface)</span></span> Interface &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;reverse&#123;data&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以看到这里是把参数 i,j 互换成 j,i</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r reverse)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.Interface.Less(j, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 使用sort包中的数据类型</span></span><br><span class="line">	intSlice := sort.IntSlice&#123;<span class="number">23</span>, <span class="number">15</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">89</span>&#125;</span><br><span class="line">	<span class="comment">// 互换j,i</span></span><br><span class="line">	reverse := sort.Reverse(intSlice)</span><br><span class="line">	<span class="comment">// 排序</span></span><br><span class="line">	sort.Sort(reverse)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;排序结果: %v\n&quot;</span>, intSlice)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 输出</span></span><br><span class="line"><span class="comment">排序结果: [89 23 15 12 9 3 2]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p><strong>查找步骤</strong></p>
<ul>
<li>步骤一：定义类型变量</li>
<li>步骤二：先排序后查找(查找是基于排序后的结果)</li>
<li>步骤三：查询可能存在的索引</li>
<li>步骤四：判断是否相等</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search_var</span><span class="params">(searchVal <span class="type">int</span>, intSlice sort.IntSlice)</span></span> &#123;</span><br><span class="line">	searchIndex := intSlice.Search(searchVal)</span><br><span class="line">	<span class="comment">// 判断是否相等</span></span><br><span class="line">	<span class="keyword">if</span> searchIndex &gt;= <span class="built_in">len</span>(intSlice) &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;未找到：%v\n&quot;</span>, searchVal)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> searchVal == intSlice[searchIndex] &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;找到: %v 索引为: %v \n&quot;</span>, searchVal, searchIndex)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;未找到：%v\n&quot;</span>, searchVal)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1.定义类型</span></span><br><span class="line">	intSlice := sort.IntSlice&#123;<span class="number">10</span>, <span class="number">40</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">23</span>, <span class="number">72</span>, <span class="number">89</span>&#125;</span><br><span class="line">	<span class="comment">// 2.排序后查找</span></span><br><span class="line">	intSlice.Sort()</span><br><span class="line">	<span class="comment">// 3.查询可能存在的索引</span></span><br><span class="line">	search_var(<span class="number">6</span>, intSlice)</span><br><span class="line">	<span class="comment">// 4.查找不存在情况</span></span><br><span class="line">	search_var(<span class="number">90</span>, intSlice)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">找到: 6 索引为: 0 </span></span><br><span class="line"><span class="comment">未找到：90</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>根据查询出的索引,取出对应的值，看是否与查找的值相等。如果相等则认为找到，不相等则认为没有找到。</p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>flag包使用</title>
    <url>/2021/04/29/flag%E5%8C%85%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote>
<p>在 Go中，如果要接收命令行参数，需要使用 flag包进行解析。不同的参数类型可以通过不同的方法接收。</p>
</blockquote>
<span id="more"></span>

<h2 id="参数接受"><a href="#参数接受" class="headerlink" title="参数接受"></a>参数接受</h2><h3 id="接受方式"><a href="#接受方式" class="headerlink" title="接受方式"></a>接受方式</h3><p>使用<code>flag</code>接收参数，可以由以下三种方式接受：</p>
<ul>
<li>方式一: flag.Type(name,defaultVal,desc)</li>
<li>方式二: flag.TypeVar(&amp;flagVar,name,defaultVal,desc)</li>
<li>方式三: flag.Var(&amp;flagVar,name,desc)</li>
<li>方式四: flag.Args()</li>
<li>方式五: flag.Arg(i)</li>
</ul>
<table>
    <tr>
        <th>字段</th><th>说明</th>
    </tr>
    <tr>
        <td>flag.Type</td><td>这里的Type是个抽象的概念,不是具体函数名</td>
    </tr>
    <tr>
        <td>defaultVal</td><td>默认值</td>
    </tr>
    <tr>
        <td>desc</td><td>描述信息</td>
    </tr>
</table>
    
    
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>上面接收方式一、二、三，都是最后调用<code>flag.Parse()</code>,而方式四和方式五是提前调用<code>flag.Parse()</code>。<br>方式一、二、三传参时，注意布尔类型，尽量设置成-flag=val，否则会影响后面的参数解析。<br>方式四、五不能使用-flag=val这种格式传参。</p>
<h2 id="flag-Type"><a href="#flag-Type" class="headerlink" title="flag.Type"></a>flag.Type</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	<span class="comment">// 接收字符串</span></span><br><span class="line">	str =  flag.String(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;默认名&quot;</span>,<span class="string">&quot;用户姓名&quot;</span>)</span><br><span class="line">	<span class="comment">// 接收整型</span></span><br><span class="line">	age = flag.Int(<span class="string">&quot;age&quot;</span>,<span class="number">18</span>,<span class="string">&quot;用户年龄&quot;</span>)</span><br><span class="line">	<span class="comment">// 接收布尔型</span></span><br><span class="line">	smoking = flag.Bool(<span class="string">&quot;smoking&quot;</span>,<span class="literal">false</span>,<span class="string">&quot;是否吸烟&quot;</span>)</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="comment">// 解析</span></span><br><span class="line">	flag.Parse()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;str: %v\n&quot;</span>,*str)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;age: %v\n&quot;</span>,*age)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;smoking: %v\n&quot;</span>,*smoking)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">str: 默认名</span></span><br><span class="line"><span class="comment">age: 18</span></span><br><span class="line"><span class="comment">smoking: false</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>运行(传参数时)</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># go run main.go -name 张三 -age 100 -smoking=true</span></span><br><span class="line">str: 张三</span><br><span class="line">age: 100</span><br><span class="line">smoking: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="flag-TypeVar"><a href="#flag-TypeVar" class="headerlink" title="flag.TypeVar"></a>flag.TypeVar</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 先定义变量</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	age <span class="type">int</span></span><br><span class="line">	smoking <span class="type">bool</span></span><br><span class="line">	weight <span class="type">float64</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="comment">// 接收字符串</span></span><br><span class="line">	flag.StringVar(&amp;name,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;默认名字&quot;</span>,<span class="string">&quot;用户名&quot;</span>)</span><br><span class="line">	<span class="comment">// 接收整型</span></span><br><span class="line">	flag.IntVar(&amp;age,<span class="string">&quot;age&quot;</span>,<span class="number">18</span>,<span class="string">&quot;用户年龄&quot;</span>)</span><br><span class="line">	<span class="comment">// 接收布尔类型</span></span><br><span class="line">	flag.BoolVar(&amp;smoking,<span class="string">&quot;smoking&quot;</span>,<span class="literal">false</span>,<span class="string">&quot;是否吸烟？&quot;</span>)</span><br><span class="line">	<span class="comment">// 接收浮点型</span></span><br><span class="line">	flag.Float64Var(&amp;weight,<span class="string">&quot;w&quot;</span>,<span class="number">60.0</span>,<span class="string">&quot;体重&quot;</span>)</span><br><span class="line">	<span class="comment">// 解析</span></span><br><span class="line">	flag.Parse()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;姓名: %v\n&quot;</span>,name)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;年龄: %v\n&quot;</span>,age)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;是否吸烟？: %v\n&quot;</span>,smoking)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;体重: %v\n&quot;</span>,weight)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">姓名: 默认名字</span></span><br><span class="line"><span class="comment">年龄: 18</span></span><br><span class="line"><span class="comment">是否吸烟？: false</span></span><br><span class="line"><span class="comment">体重: 60</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>运行(传参数时)</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># go run main.go -name 张三 -age 22 -smoking=true  -w=88.9</span></span><br><span class="line">姓名: 张三</span><br><span class="line">年龄: 22</span><br><span class="line">是否吸烟？: <span class="literal">true</span></span><br><span class="line">体重: 88.9</span><br></pre></td></tr></table></figure>
<p><strong>细节</strong><br>在传参数过程中，发现布尔型传参如果不设置=，会影响后面的参数接收,具体如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 布尔型不设置 = (发现名字没有被接收)</span></span><br><span class="line"><span class="comment"># go run main.go -smoking true -name 哈哈 </span></span><br><span class="line">姓名: 默认名字</span><br><span class="line">年龄: 18</span><br><span class="line">是否吸烟？: <span class="literal">true</span></span><br><span class="line">体重: 60</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 布尔型设置 = </span></span><br><span class="line"><span class="comment"># go run main.go -smoking=true -name 哈哈 </span></span><br><span class="line">姓名: 哈哈</span><br><span class="line">年龄: 18</span><br><span class="line">是否吸烟？: <span class="literal">true</span></span><br><span class="line">体重: 60</span><br></pre></td></tr></table></figure>

<h2 id="flag-Var"><a href="#flag-Var" class="headerlink" title="flag.Var"></a>flag.Var</h2><p>通过 <code>flag.Var()</code> 绑定自定义类型，自定义类型需要实现 Value 接口(Receives必须为指针)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义变量，并实现flag.Value接口</span></span><br><span class="line"><span class="keyword">type</span> Likes []<span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Likes)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%v&quot;</span>, *l)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Likes)</span></span> Set(s <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// 分割字符串</span></span><br><span class="line">	split := strings.Split(s, <span class="string">&quot;,&quot;</span>)</span><br><span class="line">	*l = split</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> likeList Likes</span><br><span class="line">	<span class="comment">// 接收自定义类型</span></span><br><span class="line">	flag.Var(&amp;likeList, <span class="string">&quot;likes&quot;</span>, <span class="string">&quot;接收自定义类型&quot;</span>)</span><br><span class="line">	<span class="comment">// 解析</span></span><br><span class="line">	flag.Parse()</span><br><span class="line">	fmt.Println(likeList)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># go run main.go -likes=篮球,足球,游戏</span></span><br><span class="line">[篮球 足球 游戏]</span><br></pre></td></tr></table></figure>

<h2 id="flag-Args"><a href="#flag-Args" class="headerlink" title="flag.Args"></a>flag.Args</h2><p>一次打印出全部的入参，注意入参格式不能是<code>-flag=val</code>格式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 注意Parse是在Args之前调用</span></span><br><span class="line">	flag.Parse()</span><br><span class="line">	<span class="comment">// 一次接收所有的参数</span></span><br><span class="line">	args := flag.Args()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> args &#123;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># go run main.go 篮球 足球 游戏</span></span><br><span class="line">篮球</span><br><span class="line">足球</span><br><span class="line">游戏</span><br><span class="line">[篮球 足球 游戏]</span><br></pre></td></tr></table></figure>

<h2 id="flag-Arg-i"><a href="#flag-Arg-i" class="headerlink" title="flag.Arg(i)"></a>flag.Arg(i)</h2><p>获取指定索引位置的参数，默认索引位置是0;注意入参格式不能是<code>-flag=val</code>格式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 注意Parse是在Arg之前调用</span></span><br><span class="line">	flag.Parse()</span><br><span class="line">	<span class="comment">// 获取指定索引位置参数</span></span><br><span class="line">	p0 := flag.Arg(<span class="number">0</span>)</span><br><span class="line">	p1 := flag.Arg(<span class="number">1</span>)</span><br><span class="line">	p2 := flag.Arg(<span class="number">2</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;索引=0，v=%v\n&quot;</span>,p0)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;索引=1，v=%v\n&quot;</span>,p1)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;索引=2，v=%v\n&quot;</span>,p2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># go run main.go 篮球 足球 游戏</span></span><br><span class="line">索引=0，v=篮球</span><br><span class="line">索引=1，v=足球</span><br><span class="line">索引=2，v=游戏</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>sync包使用</title>
    <url>/2021/04/28/sync%E5%8C%85%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote>
<p>sync包提供了互斥锁。除了Once和WaitGroup类型，其余多数适用于低水平的程序，多数情况下，高水平的同步使用channel通信性能会更优一些。</p>
</blockquote>
<span id="more"></span>

<h2 id="并发等待组-WaitGroup"><a href="#并发等待组-WaitGroup" class="headerlink" title="并发等待组(WaitGroup)"></a>并发等待组(WaitGroup)</h2><p><code>WaitGroup</code>，即等待一组Goroutine结束。父Goroutine调用Add()方法来设置应等待Goroutine的数量。每个被等待的Goroutine在结束时应该调用Done()方法。与此同时，主Goroutine可调用Wait()方法阻塞至所有Goroutine结束。</p>
<p><strong>WaitGroup结构</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A WaitGroup must not be copied after first use.</span></span><br><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">	noCopy noCopy</span><br><span class="line">	state1 [<span class="number">3</span>]<span class="type">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法列表</strong></p>
<table>
    <tr>
        <th>方法名</th><th>功能</th>
    </tr>
    <tr>
        <td>(wg *WaitGroup) Add(delta int)</td><td>等待组的计数器 +1</td>
    </tr>
    <tr>
        <td>(wg *WaitGroup) Done()</td><td>等待组的计数器 -1</td>
    </tr>
    <tr>
        <td>(wg *WaitGroup) Wait()</td><td>当等待组计数器不等于0时,阻塞直到0</td>
    </tr>
</table>


<p><strong>Add参数取值范围</strong><br>等待组内部拥有一个计数器，计数器的值可以通过Add(delta int)方法调用实现计数器的增加和减少。该方法应该在创建新的Goroutine之前调用。</p>
<p>参数值x取值</p>
<table>
    <tr>
        <th>取值</th><th>描述</th>
    </tr>
    <tr>
        <td>delta < 0</td><td>x小于0时,但会报错: panic: sync: negative WaitGroup counter</td>
    </tr>
    <tr>
        <td>delta = 0</td><td>x等于0时,会释放Wait()方法阻塞等待的所有Goroutine</td>
    </tr>
    <tr>
        <td>delta > 0</td><td>x大于0时,Wait()方法会阻塞Goroutine直到WaitGroup计数减为0</td>
    </tr>
</table>

<p><strong>不使用WaitGroup示例</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建通道</span></span><br><span class="line">	intChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算1-50的和</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(intChan <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		sum := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++ &#123;</span><br><span class="line">			sum += i</span><br><span class="line">		&#125;</span><br><span class="line">		intChan &lt;- sum</span><br><span class="line">	&#125;(intChan)</span><br><span class="line">	<span class="comment">// 计算51-100的和</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(intChan <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		sum := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">51</span>; i &lt;= <span class="number">100</span>; i++ &#123;</span><br><span class="line">			sum += i</span><br><span class="line">		&#125;</span><br><span class="line">		intChan &lt;- sum</span><br><span class="line">	&#125;(intChan)</span><br><span class="line">	<span class="comment">// 另外创建个channle聚合结果</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(intChan <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		sum1 := &lt;-intChan</span><br><span class="line">		sum2 := &lt;-intChan</span><br><span class="line">		fmt.Printf(<span class="string">&quot;sum1 = %d sum2 = %d  \nsum1 + sum2 = %d \n&quot;</span>, sum1, sum2, sum1+sum2)</span><br><span class="line">	&#125;(intChan)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注意,需求手动sleep</span></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;运行结束&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 输出:</span></span><br><span class="line"><span class="comment">  sum1 = 1275 sum2 = 3775  </span></span><br><span class="line"><span class="comment">  sum1 + sum2 = 5050 </span></span><br><span class="line"><span class="comment">  运行结束</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>使用WaitGroup示例</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 声明等待组</span></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="comment">// 设置，需要等待3个协程执行完成</span></span><br><span class="line">	wg.Add(<span class="number">3</span>)</span><br><span class="line">	<span class="comment">// 创建通道</span></span><br><span class="line">	intChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	<span class="comment">// 计算1-50的和</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(intChan <span class="keyword">chan</span> <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">		sum := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++ &#123;</span><br><span class="line">			sum += i</span><br><span class="line">		&#125;</span><br><span class="line">		intChan &lt;- sum</span><br><span class="line">		<span class="comment">// 计数器减一</span></span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;(intChan, &amp;wg)</span><br><span class="line">	<span class="comment">// 计算51-100的和</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(intChan <span class="keyword">chan</span> <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">		sum := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">51</span>; i &lt;= <span class="number">100</span>; i++ &#123;</span><br><span class="line">			sum += i</span><br><span class="line">		&#125;</span><br><span class="line">		intChan &lt;- sum</span><br><span class="line">		<span class="comment">// 计数器减一</span></span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;(intChan, &amp;wg)</span><br><span class="line">	<span class="comment">// 另外创建个channle聚合结果</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(intChan <span class="keyword">chan</span> <span class="type">int</span>,wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">		sum1 := &lt;-intChan</span><br><span class="line">		sum2 := &lt;-intChan</span><br><span class="line">		fmt.Printf(<span class="string">&quot;sum1 = %d sum2 = %d  \nsum1 + sum2 = %d \n&quot;</span>, sum1, sum2, sum1+sum2)</span><br><span class="line">		<span class="comment">// 计数器减一</span></span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;(intChan,&amp;wg)</span><br><span class="line">	<span class="comment">// 阻塞，直到等待组的计数器等于0</span></span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;运行结束&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">  sum1 = 1275 sum2 = 3775 </span></span><br><span class="line"><span class="comment">  sum1 + sum2 = 5050 </span></span><br><span class="line"><span class="comment">  运行结束</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="互斥锁-Mutex"><a href="#互斥锁-Mutex" class="headerlink" title="互斥锁(Mutex)"></a>互斥锁(Mutex)</h2><p><code>Mutex</code>是一个互斥锁，保证同时只有一个Goroutine可以访问共享资源。Mutex类型的锁和Goroutine无关，可以由不同的Goroutine加锁和解锁。也可以为其他结构体的字段，零值为解锁状态。</p>
<p><strong>结构介绍</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	state <span class="type">int32</span> <span class="comment">// state 表示当前互斥锁的状态</span></span><br><span class="line">	sema  <span class="type">uint32</span> <span class="comment">// sema 是用于控制锁状态的信号量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法列表</strong></p>
<table>
    <tr>
        <th>方法名</th><th>功能</th>
    </tr>
    <tr>
        <td>(m *Mutex) Lock()</td><td>方法锁住m，如果 m 已经加锁，则阻塞直到 m 解锁</td>
    </tr>
    <tr>
        <td>(m *Mutex) Unlock()</td><td>解锁 m，如果 m 未加锁会导致运行时错误</td>
    </tr>
</table>

<p><strong>模拟多个窗口售票</strong><br>不作为结构体属性使用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 声明全局等待组</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="comment">// 声明全局锁</span></span><br><span class="line"><span class="keyword">var</span> mutex sync.Mutex</span><br><span class="line"><span class="comment">// 声明全局余票</span></span><br><span class="line"><span class="keyword">var</span> ticket <span class="type">int</span> = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 设置等待组计数器</span></span><br><span class="line">	wg.Add(<span class="number">3</span>)</span><br><span class="line">	<span class="comment">// 窗口卖票</span></span><br><span class="line">	<span class="keyword">go</span> saleTicket(<span class="string">&quot;窗口A&quot;</span>,&amp;wg)</span><br><span class="line">	<span class="keyword">go</span> saleTicket(<span class="string">&quot;窗口B&quot;</span>,&amp;wg)</span><br><span class="line">	<span class="keyword">go</span> saleTicket(<span class="string">&quot;窗口C&quot;</span>,&amp;wg)</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;运行结束!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 卖票流程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">saleTicket</span><span class="params">(windowName <span class="type">string</span>, wg *sync.WaitGroup)</span></span>  &#123;</span><br><span class="line">	<span class="comment">// 卖票流程结束后关闭</span></span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 加锁</span></span><br><span class="line">		mutex.Lock()</span><br><span class="line">		<span class="keyword">if</span>  ticket &gt; <span class="number">0</span>&#123;</span><br><span class="line">			time.Sleep(<span class="number">10</span> * time.Millisecond)</span><br><span class="line">			ticket--</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%s 卖出一张票，余票: %d \n&quot;</span>,windowName,ticket)</span><br><span class="line">		&#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%s 票已卖完! \n&quot;</span>,windowName)</span><br><span class="line">			<span class="comment">// 解锁</span></span><br><span class="line">			mutex.Unlock()</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 解锁</span></span><br><span class="line">		mutex.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">  窗口C 卖出一张票，余票: 9 </span></span><br><span class="line"><span class="comment">  窗口C 卖出一张票，余票: 8 </span></span><br><span class="line"><span class="comment">  窗口B 卖出一张票，余票: 7 </span></span><br><span class="line"><span class="comment">  窗口A 卖出一张票，余票: 6 </span></span><br><span class="line"><span class="comment">  窗口C 卖出一张票，余票: 5 </span></span><br><span class="line"><span class="comment">  窗口B 卖出一张票，余票: 4 </span></span><br><span class="line"><span class="comment">  窗口A 卖出一张票，余票: 3 </span></span><br><span class="line"><span class="comment">  窗口C 卖出一张票，余票: 2 </span></span><br><span class="line"><span class="comment">  窗口B 卖出一张票，余票: 1 </span></span><br><span class="line"><span class="comment">  窗口A 卖出一张票，余票: 0 </span></span><br><span class="line"><span class="comment">  窗口C 票已卖完! </span></span><br><span class="line"><span class="comment">  窗口B 票已卖完! </span></span><br><span class="line"><span class="comment">  窗口A 票已卖完! </span></span><br><span class="line"><span class="comment">  运行结束!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>作为结构体属性使用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 声明一个票池</span></span><br><span class="line"><span class="keyword">type</span> ticketPool <span class="keyword">struct</span> &#123;</span><br><span class="line">	over <span class="type">int</span></span><br><span class="line">	lock sync.Mutex</span><br><span class="line">	wg   sync.WaitGroup</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义售票方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *ticketPool)</span></span> sellTicket(windowName <span class="type">string</span>) &#123;</span><br><span class="line">	<span class="comment">// 等待组减一</span></span><br><span class="line">	<span class="keyword">defer</span> t.wg.Done()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 加锁</span></span><br><span class="line">		t.lock.Lock()</span><br><span class="line">		<span class="keyword">if</span> t.over &gt; <span class="number">0</span> &#123;</span><br><span class="line">			time.Sleep(<span class="number">10</span> * time.Millisecond)</span><br><span class="line">			t.over--</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%s 卖出一张票，余票: %d \n&quot;</span>, windowName, t.over)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 无票，跳无限循环并解锁</span></span><br><span class="line">			t.lock.Unlock()</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%s 票已卖完! \n&quot;</span>, windowName)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 正常售票流程解锁</span></span><br><span class="line">		t.lock.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个票池</span></span><br><span class="line">	ticketP := ticketPool&#123;over: <span class="number">10</span>&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;T:%T v: %v \n&quot;</span>, ticketP, ticketP)</span><br><span class="line">	<span class="comment">// 设置窗口数量</span></span><br><span class="line">	windowNum := <span class="number">3</span></span><br><span class="line">	<span class="comment">// 设置等待组计数器</span></span><br><span class="line">	ticketP.wg.Add(windowNum)</span><br><span class="line">	<span class="comment">// 定义3个窗口售票</span></span><br><span class="line">	<span class="keyword">for</span> i:= <span class="number">1</span> ; i &lt;= windowNum; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> ticketP.sellTicket(<span class="string">&quot;窗口&quot;</span> + strconv.Itoa(i))</span><br><span class="line">	&#125;</span><br><span class="line">	ticketP.wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;运行结束!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">  窗口3 卖出一张票，余票: 9 </span></span><br><span class="line"><span class="comment">  窗口3 卖出一张票，余票: 8 </span></span><br><span class="line"><span class="comment">  窗口1 卖出一张票，余票: 7 </span></span><br><span class="line"><span class="comment">  窗口2 卖出一张票，余票: 6 </span></span><br><span class="line"><span class="comment">  窗口3 卖出一张票，余票: 5 </span></span><br><span class="line"><span class="comment">  窗口1 卖出一张票，余票: 4 </span></span><br><span class="line"><span class="comment">  窗口2 卖出一张票，余票: 3 </span></span><br><span class="line"><span class="comment">  窗口3 卖出一张票，余票: 2 </span></span><br><span class="line"><span class="comment">  窗口1 卖出一张票，余票: 1 </span></span><br><span class="line"><span class="comment">  窗口2 卖出一张票，余票: 0 </span></span><br><span class="line"><span class="comment">  窗口1 票已卖完! </span></span><br><span class="line"><span class="comment">  窗口2 票已卖完! </span></span><br><span class="line"><span class="comment">  窗口3 票已卖完! </span></span><br><span class="line"><span class="comment">  运行结束!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="读写锁-RWMutex"><a href="#读写锁-RWMutex" class="headerlink" title="读写锁(RWMutex)"></a>读写锁(RWMutex)</h2><p><strong>结构介绍</strong><br><code>RWMutex</code>是读写互斥锁，简称读写锁。该锁可以同时被多个读取者持有或被唯一个写入者持有。RWMutex类型锁跟Goroutine无关，可以由不同的Goroutine加锁、解锁。RWMutex也可以创建为其他结构体的字段；零值为解锁状态。</p>
<p><strong>RWMutex锁结构</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    w  Mutex <span class="comment">//用于控制多个写锁，获得写锁首先要获取该锁，如果有一个写锁在进行，那么再到来的写锁将会阻塞于此</span></span><br><span class="line">    writerSem  <span class="type">uint32</span> <span class="comment">//写阻塞等待的信号量，最后一个读者释放锁时会释放信号量</span></span><br><span class="line">    readerSem  <span class="type">uint32</span> <span class="comment">//读阻塞的协程等待的信号量，持有写锁的协程释放锁后会释放信号量</span></span><br><span class="line">    readerCount <span class="type">int32</span>  <span class="comment">//记录读者个数</span></span><br><span class="line">    readerWait  <span class="type">int32</span>  <span class="comment">//记录写阻塞时读者个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>读写锁堵塞场景</strong></p>
<table>
    <tr>
        <th>场景</th><th>描述</th>
    </tr>
    <tr>
        <td>写锁需要阻塞写锁</td><td>一个协程拥有写锁时，其他协程写锁需要阻塞</td>
    </tr>
    <tr>
        <td>写锁需要阻塞读锁</td><td>一个协程拥有写锁时，其他协程读锁需要阻塞</td>
    </tr>
    <tr>
        <td>读锁需要阻塞写锁</td><td>一个协程拥有读锁时，其他协程写锁需要阻塞</td>
    </tr>
    <tr>
        <td>读锁不能阻塞读锁</td><td>一个协程拥有读锁时，其他协程也可以拥有读锁</td>
    </tr>
</table>

<p><strong>方法列表</strong></p>
<table>
    <tr>
        <th>方法名</th><th>描述</th>
    </tr>
    <tr>
        <td>(rw *RWMutex) RLock()</td><td>获取读锁,当一个协程拥有读锁时，其他协程写锁需要阻塞</td>
    </tr>
    <tr>
        <td>(rw *RWMutex) RUnlock()</td><td>释放读锁</td>
    </tr>
    <tr>
        <td>(rw *RWMutex) Lock()</td><td>获取写锁，与Mutex完全一致</td>
    </tr>
    <tr>
        <td>(rw *RWMutex) Unlock()</td><td>释放写锁</td>
    </tr>
</table>

<p><strong>读写文件</strong><br>不作为结构体属性使用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 声明全局变量，文件内容</span></span><br><span class="line"><span class="keyword">var</span> fileContext <span class="type">string</span></span><br><span class="line"><span class="comment">// 声明全局读写互斥锁</span></span><br><span class="line"><span class="keyword">var</span> rxMutex sync.RWMutex</span><br><span class="line"><span class="comment">// 声明全局等待组</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 设置计数器</span></span><br><span class="line">	wg.Add(<span class="number">5</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">		name := <span class="string">&quot;同学-&quot;</span> + strconv.Itoa(i)</span><br><span class="line">		<span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">go</span> readFile(name)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">go</span> writeFile(name, strconv.Itoa(i))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 等待所有计数器执行完成</span></span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;运行结束!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">(name <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 释放读锁</span></span><br><span class="line">	<span class="keyword">defer</span> rxMutex.RUnlock()</span><br><span class="line">	<span class="comment">// 获取读锁</span></span><br><span class="line">	rxMutex.RLock()</span><br><span class="line">	<span class="comment">// 打印读取内容</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s 获取读锁，读取内容为: %s \n&quot;</span>, name, fileContext)</span><br><span class="line">	<span class="comment">// 计数器减一</span></span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeFile</span><span class="params">(name, s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 释放写锁</span></span><br><span class="line">	<span class="keyword">defer</span> rxMutex.Unlock()</span><br><span class="line">	<span class="comment">// 获取写锁</span></span><br><span class="line">	rxMutex.Lock()</span><br><span class="line">	<span class="comment">// 写入内容</span></span><br><span class="line">	fileContext = fileContext + <span class="string">&quot; &quot;</span> + s</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s 获取写锁，写入内容: %s。 文件内容变成: %s \n&quot;</span>, name, s, fileContext)</span><br><span class="line">	<span class="comment">// 计数器减一</span></span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">  同学-1 获取写锁，写入内容: 1。 文件内容变成:  1 </span></span><br><span class="line"><span class="comment">  同学-4 获取读锁，读取内容为:  1 </span></span><br><span class="line"><span class="comment">  同学-2 获取读锁，读取内容为:  1 </span></span><br><span class="line"><span class="comment">  同学-5 获取写锁，写入内容: 5。 文件内容变成:  1 5 </span></span><br><span class="line"><span class="comment">  同学-3 获取写锁，写入内容: 3。 文件内容变成:  1 5 3 </span></span><br><span class="line"><span class="comment">  运行结束!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>作为结构体属性使用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 定义一个文件结构体</span></span><br><span class="line"><span class="keyword">type</span> fileResource <span class="keyword">struct</span> &#123;</span><br><span class="line">	content <span class="type">string</span></span><br><span class="line">	wg sync.WaitGroup</span><br><span class="line">	rwLock sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *fileResource)</span></span>readFile(name <span class="type">string</span>) &#123;</span><br><span class="line">	<span class="comment">// 释放读锁</span></span><br><span class="line">	<span class="keyword">defer</span> f.rwLock.RUnlock()</span><br><span class="line">	<span class="comment">// 获取读锁</span></span><br><span class="line">	f.rwLock.RLock()</span><br><span class="line">	<span class="comment">// 打印读取内容</span></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s 获取读锁，读取内容为: %s \n&quot;</span>, name, f.content)</span><br><span class="line">	<span class="comment">// 计数器减一</span></span><br><span class="line">	f.wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *fileResource)</span></span>writeFile(name, s <span class="type">string</span>) &#123;</span><br><span class="line">	<span class="comment">// 释放写锁</span></span><br><span class="line">	<span class="keyword">defer</span> f.rwLock.Unlock()</span><br><span class="line">	<span class="comment">// 获取写锁</span></span><br><span class="line">	f.rwLock.Lock()</span><br><span class="line">	<span class="comment">// 写入内容</span></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	f.content = f.content + <span class="string">&quot; &quot;</span> + s</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s 获取写锁，写入内容: %s。 文件内容变成: %s \n&quot;</span>, name, s, f.content)</span><br><span class="line">	<span class="comment">// 计数器减一</span></span><br><span class="line">	f.wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 声明结构体</span></span><br><span class="line">	<span class="keyword">var</span> file fileResource</span><br><span class="line">	<span class="comment">// 设置计数器</span></span><br><span class="line">	file.wg.Add(<span class="number">5</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">		name := <span class="string">&quot;同学-&quot;</span> + strconv.Itoa(i)</span><br><span class="line">		<span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">go</span> file.readFile(name)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">go</span> file.writeFile(name, strconv.Itoa(i))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 等待所有计数器执行完成</span></span><br><span class="line">	file.wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;运行结束!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">  同学-5 获取写锁，写入内容: 5。 文件内容变成:  5 </span></span><br><span class="line"><span class="comment">  同学-1 获取写锁，写入内容: 1。 文件内容变成:  5 1 </span></span><br><span class="line"><span class="comment">  同学-2 获取读锁，读取内容为:  5 1 </span></span><br><span class="line"><span class="comment">  同学-3 获取写锁，写入内容: 3。 文件内容变成:  5 1 3 </span></span><br><span class="line"><span class="comment">  同学-4 获取读锁，读取内容为:  5 1 3 </span></span><br><span class="line"><span class="comment">  运行结束!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="条件变量-Cond"><a href="#条件变量-Cond" class="headerlink" title="条件变量(Cond)"></a>条件变量(Cond)</h2><p><strong>介绍</strong><br>与互斥锁不同，条件变量的作用并不是保证在同一时刻仅有一个线程访问某一个共享数据，而是在对应的共享数据的状态发生变化时，通知其他因此而被阻塞的线程。条件变量总是与互斥锁组合使用，互斥锁为共享数据的访问提供互斥支持，而条件变量可以就共享数据的状态的变化向相关线程发出通知。</p>
<p>使用场景:  我需要完成一项任务，但是这项任务需要满足一定条件才可以执行，否则我就等着。</p>
<p><strong>方法列表</strong></p>
<table>
    <tr>
        <th>方法名</th><th>描述</th>
    </tr>
    <tr>
        <td>NewCond(l Locker) *Cond</td><td>生成一个cond,需要传入实现Locker接口的变量，一般是*Mutex或*RWMutex类型的值</td>
    </tr>
    <tr>
        <td>(c *Cond) Wait()</td><td>等待通知</td>
    </tr>
    <tr>
        <td>(c *Cond) Signal()</td><td>发送单个通知</td>
    </tr>
    <tr>
        <td>(c *Cond) Broadcast()</td><td>广播(多个通知)</td>
    </tr>
</table>

<p><strong>使用示例</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 声明互斥锁</span></span><br><span class="line">	<span class="keyword">var</span> mutex sync.Mutex</span><br><span class="line">	<span class="comment">// 声明条件变量</span></span><br><span class="line">	cond := sync.NewCond(&amp;mutex)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="comment">// 获取锁</span></span><br><span class="line">			cond.L.Lock()</span><br><span class="line">			<span class="comment">// 释放锁</span></span><br><span class="line">			<span class="keyword">defer</span> cond.L.Unlock()</span><br><span class="line">			<span class="comment">// 等待通知,阻塞当前协程</span></span><br><span class="line">			cond.Wait()</span><br><span class="line">			<span class="comment">// 等待通知后打印输出</span></span><br><span class="line">			fmt.Printf(<span class="string">&quot;输出:%d ! \n&quot;</span>, i)</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 单个通知</span></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;单个通知A！&quot;</span>)</span><br><span class="line">	cond.Signal()</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;单个通知B！&quot;</span>)</span><br><span class="line">	cond.Signal()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 广播通知</span></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;广播通知！并睡眠1秒，等待其他协程输出!&quot;</span>)</span><br><span class="line">	cond.Broadcast()</span><br><span class="line">	<span class="comment">// 等待其他协程处理完</span></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;运行结束！&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">  单个通知A！</span></span><br><span class="line"><span class="comment">  输出:1 ! </span></span><br><span class="line"><span class="comment">  单个通知B！</span></span><br><span class="line"><span class="comment">  输出:4 ! </span></span><br><span class="line"><span class="comment">  广播通知！并睡眠1秒，等待其他协程输出!</span></span><br><span class="line"><span class="comment">  输出:10 ! </span></span><br><span class="line"><span class="comment">  输出:2 ! </span></span><br><span class="line"><span class="comment">  输出:3 ! </span></span><br><span class="line"><span class="comment">  输出:8 ! </span></span><br><span class="line"><span class="comment">  输出:9 ! </span></span><br><span class="line"><span class="comment">  输出:6 ! </span></span><br><span class="line"><span class="comment">  输出:5 ! </span></span><br><span class="line"><span class="comment">  输出:7 ! </span></span><br><span class="line"><span class="comment">  运行结束！</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="一次-Once"><a href="#一次-Once" class="headerlink" title="一次(Once)"></a>一次(Once)</h2><p><code>sync.Once</code> 是使Go方法只执行一次的对象实现，作用与 init 函数类似,但也有所不同。区别如下:</p>
<p><code>init</code> 函数是在文件包首次被加载的时候执行，且只执行一次<br><code>sync.Onc</code> 是在代码运行中需要的时候执行，且只执行一次</p>
<p><strong>方法介绍</strong></p>
<table>
    <tr>
        <th>方法名</th><th>描述</th>
    </tr>
    <tr>
        <td>(o *Once) Do(f func())</td><td>函数只会执行一次，并保证在返回时，传入Do的函数已经执行完成。</td>
    </tr>
</table>
多个 goroutine 同时执行 once.Do 的时候，可以保证抢占到 once.Do 执行权的 goroutine 执行完 once.Do 后，其他goroutine才能得到返回 。

<p><strong>重复调用只执行一次</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	echo := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		t := time.Now().Unix()</span><br><span class="line">		fmt.Printf(<span class="string">&quot;输出时间 %v &quot;</span>,strconv.FormatInt(t,<span class="number">10</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> one sync.Once</span><br><span class="line">  <span class="comment">// 虽然遍历调用，但是只会执行一次</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i&lt; <span class="number">10</span> ; i++  &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(a,b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			one.Do(echo)</span><br><span class="line">		&#125;(i,i+<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;运行结束！&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">  输出时间 1608083525 </span></span><br><span class="line"><span class="comment">  运行结束！</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="对象池-Pool"><a href="#对象池-Pool" class="headerlink" title="对象池(Pool)"></a>对象池(Pool)</h2><p><strong>为什么使用?</strong><br>Go语言是支持垃圾自动回收的。对于一些暂时用不到但是后续会用到的对象，为了提升性能，可以先暂存起来，这虽然会占用一些内存，但是比起销毁了再新建，要节省运行时间。Go语言专门提供了暂存对象的工具，就是sync.Pool。</p>
<p><code>sync.Pool</code>是一个对象池，它是并发安全的，而且大小是可伸缩的，仅受限于内存。当需要使用对象的时候可以从对象池中直接取出使用。</p>
<p><strong>数据结构</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">	noCopy noCopy <span class="comment">//禁止复制</span></span><br><span class="line">	local     unsafe.Pointer <span class="comment">//本地缓冲池指针,每个处理器分配一个;其类型是[P]poolLocal数组</span></span><br><span class="line">	localSize <span class="type">uintptr</span> <span class="comment">//数组大小</span></span><br><span class="line"></span><br><span class="line">	victim     unsafe.Pointer <span class="comment">// local from previous cycle</span></span><br><span class="line">	victimSize <span class="type">uintptr</span>        <span class="comment">// size of victims array</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 缓存池没有对象时,调用此方法创建</span></span><br><span class="line">	New <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法列表</strong><br>sync.Pool提供以下两个公共方法，用来操作对象池。</p>
<table>
    <tr>
        <th>方法名</th><th>描述</th>
    </tr>
    <tr>
        <td>(p *Pool) Put(x interface{})</td><td>向池中添加对象</td>
    </tr>
    <tr>
        <td>(p *Pool) Get() interface{}</td><td>从池中获取对象</td>
    </tr>
</table>

<p>Get方法是从池中获取对象，如果没有对象则调用New方法创建生成，如果未设置New则返回nil。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建对象池</span></span><br><span class="line">	pool := sync.Pool&#123;</span><br><span class="line">		New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">make</span>([]<span class="type">string</span>,<span class="number">5</span>)</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 首次获取</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;不设置直接获取: %v\n&quot;</span>,pool.Get())</span><br><span class="line">	<span class="comment">// 设置后获取</span></span><br><span class="line">	pool.Put([]<span class="type">string</span>&#123;<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;Word&quot;</span>&#125;)</span><br><span class="line">	<span class="comment">// 设置后获取</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;设置后,第一次获取: %v\n&quot;</span>,pool.Get())</span><br><span class="line">	fmt.Printf(<span class="string">&quot;设置后,第二次获取: %v\n&quot;</span>,pool.Get())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意事项</strong><br>存入sync.Pool的对象可能会在不通知的情况下被释放，这一点一定要注意。比如一些socket长连接就不适合存入sync.Pool内。</p>
<h2 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h2><p>如果要缓存的数据量不大，可以考虑使用sync.Map(Go 1.9+版本支持)。在1.6版本以前，Go语言自带标准的map类型是并发读安全的，但是并发写不安全。</p>
<h3 id="查询和新增"><a href="#查询和新增" class="headerlink" title="查询和新增"></a>查询和新增</h3><p><strong>查找方法</strong><br><code>Load</code>: 通过参数key查询对应的value，如果不存在则返回nil；ok表示是否找到对应的值。</p>
<p><strong>新增方法</strong><br><code>Store</code>: 对sync.Map的更新或新增，参数是键值对<br><code>LoadOrStore</code>: 参数为key和value。根据参数key查找对应的value，如果找到,则不修改原来的值并通过actual返回，并且loaded为true；如果未找到，则存储key-value并且将存储的value通过actual返回，loaded为false。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 定义map 类型</span></span><br><span class="line">	<span class="keyword">var</span> syncMap sync.Map</span><br><span class="line">	<span class="comment">// 新增</span></span><br><span class="line">	syncMap.Store(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;张三&quot;</span>)</span><br><span class="line">	load, _ := syncMap.Load(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Store新增-&gt;name:%v\n&quot;</span>,load)</span><br><span class="line">	<span class="comment">// 找到则不更新，返回旧值</span></span><br><span class="line">	store, loaded := syncMap.LoadOrStore(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;李四&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;找到则返回旧值-&gt; name:%v loaded:%v \n&quot;</span>,store,loaded)</span><br><span class="line">	<span class="comment">// 找不到则新增</span></span><br><span class="line">	age, loaded := syncMap.LoadOrStore(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;找不到则新增-&gt; age:%v loaded:%v \n&quot;</span>,age,loaded)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出:</span></span><br><span class="line"><span class="comment">Store新增-&gt;name:张三</span></span><br><span class="line"><span class="comment">找到则返回旧值-&gt; name:张三 loaded:true </span></span><br><span class="line"><span class="comment">找不到则新增-&gt; age:20 loaded:false </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><code>LoadAndDelete</code>: 根据参数key删除对应的value，如果找到则删除，并通过value返回删除的值，并设置loaded为true；如果未找到，则value返回nil，loaded为false。<br><code>Delete</code>：根据参数key删除对应的value。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 定义map 类型</span></span><br><span class="line">	<span class="keyword">var</span> syncMap sync.Map</span><br><span class="line">	<span class="comment">// 新增</span></span><br><span class="line">	syncMap.Store(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;张三&quot;</span>)</span><br><span class="line">	syncMap.Store(<span class="string">&quot;age&quot;</span>,<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 找到情况</span></span><br><span class="line">	andDelete, loaded := syncMap.LoadAndDelete(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;找到-&gt; val:%v loaded:%v \n&quot;</span>,andDelete,loaded)</span><br><span class="line">	search, ok := syncMap.Load(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;删除name后查找-&gt; search:%v ok:%v \n&quot;</span>,search,ok)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 找不到情况</span></span><br><span class="line">	andDelete2, loaded := syncMap.LoadAndDelete(<span class="string">&quot;name2&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;找不到-&gt; val:%v loaded:%v \n&quot;</span>,andDelete2,loaded)</span><br><span class="line"></span><br><span class="line">	syncMap.Delete(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">	searchAge, ok := syncMap.Load(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;删除age后查找-&gt; searchAge:%v ok:%v \n&quot;</span>,searchAge,ok)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 输出</span></span><br><span class="line"><span class="comment">找到-&gt; val:张三 loaded:true </span></span><br><span class="line"><span class="comment">删除name后查找-&gt; search:&lt;nil&gt; ok:false </span></span><br><span class="line"><span class="comment">找不到-&gt; val:&lt;nil&gt; loaded:false </span></span><br><span class="line"><span class="comment">删除age后查找-&gt; searchAge:&lt;nil&gt; ok:false </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>sync.Map不能通过for…range遍历，只能通过包提供的方法Range进行遍历。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 定义map 类型</span></span><br><span class="line">	<span class="keyword">var</span> syncMap sync.Map</span><br><span class="line">	<span class="comment">// 新增</span></span><br><span class="line">	syncMap.Store(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>)</span><br><span class="line">	syncMap.Store(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>)</span><br><span class="line">	syncMap.Store(<span class="string">&quot;home&quot;</span>, <span class="string">&quot;天津永和大区&quot;</span>)</span><br><span class="line">	syncMap.Range(<span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;key: %v value: %v \n&quot;</span>, key, value)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">key: name value: 张三 </span></span><br><span class="line"><span class="comment">key: age value: 20 </span></span><br><span class="line"><span class="comment">key: home value: 天津永和大区 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>context包使用</title>
    <url>/2021/04/27/context%E5%8C%85%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="什么是上下文"><a href="#什么是上下文" class="headerlink" title="什么是上下文?"></a>什么是上下文?</h2><blockquote>
<p>从Go 1.7开始, 标准库引入context(上下文)，他主要用来在goroutine之间传递上下文信息(同步信号、超时时间、截止时间、Key-Val值对)。</p>
</blockquote>
<span id="more"></span>

<h2 id="为什么要用上下文"><a href="#为什么要用上下文" class="headerlink" title="为什么要用上下文?"></a>为什么要用上下文?</h2><p><strong>场景说明</strong><br>在实际开发过程中，我们往往会在main.goroutine(主协程)中开启N 个goroutine(子协程)来处理其他逻辑，那么主协程和 子协程之间信号怎么同步呢？列举以下几个需要信号同步的场景。</p>
<p>当主协程报错或者因为其他原因需要取消时，需要通知子协程取消任务。<br>创建子协程时,希望指定超时时间或截止时间后，自动取消任务。</p>
<p><strong>怎么解决？</strong><br>context 包提供了一些函数，协助用户从现有的 Context 对象创建新的 Context 对象。<br>这些 Context 对象形成一棵树：当一个 Context 对象被取消时，继承自它的所有 Context 都会被取消。</p>
<p>Background 是所有 Context 对象树的根，它不能被取消。</p>
<h2 id="上下文接口"><a href="#上下文接口" class="headerlink" title="上下文接口"></a>上下文接口</h2><p>context包中定义了一个接口context.Context,具体定义代码如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="comment">// deadline: 返回取消的时间点(到点Context会自动取消请求)</span></span><br><span class="line">  <span class="comment">// ok：false代表没有设置截止时间</span></span><br><span class="line">	Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 返回一个只读的Chan</span></span><br><span class="line">  <span class="comment">// 这个Channel 会在当前工作完成或者上下文被取消后关闭,</span></span><br><span class="line">  <span class="comment">// 多次调用 Done 方法会返回同一个 Channel；</span></span><br><span class="line">	Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//返回 context.Context 结束的原因，</span></span><br><span class="line">  <span class="comment">// 它只会在 Done 方法对应的 Channel 关闭时返回非空的值；</span></span><br><span class="line">	Err() <span class="type">error</span></span><br><span class="line">	<span class="comment">// 从 context.Context 中获取键对应的值</span></span><br><span class="line">  <span class="comment">// 对于同一个上下文来说，多次调用 Value 并传入相同的 Key 会返回相同的结果</span></span><br><span class="line">	Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建父上下文"><a href="#创建父上下文" class="headerlink" title="创建父上下文"></a>创建父上下文</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span></span> Context &#123;</span><br><span class="line">	<span class="keyword">return</span> background</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TODO</span><span class="params">()</span></span> Context &#123;</span><br><span class="line">	<span class="keyword">return</span> todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>context</code> 包中最常用的方法是 <code>context.Background</code>、<code>context.TODO</code>，这两个方法都会返回预先初始化好的私有变量 <code>background</code> 和 <code>todo</code>,使用区别如下:<br><code>Background</code>: 主要用于main函数、初始化以及测试代码中，作为最顶层的Context，也就是根Context。<br><code>TODO</code>: 当我们不知道该使用什么类型的Context的时候，可以使用这个。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 基于context.Background()为根，创建新的超时上下文</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Begin:%s\n&quot;</span>, time.Now())</span><br><span class="line">	timeoutCtx, cancelFunc := context.WithTimeout(context.Background(), <span class="number">3</span>*time.Second)</span><br><span class="line">	<span class="comment">// 3秒后自动取消</span></span><br><span class="line">	<span class="keyword">defer</span> cancelFunc()</span><br><span class="line">	<span class="comment">// 子协程执行取消</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;子协程输出...&quot;</span>)</span><br><span class="line">	&#125;(timeoutCtx)</span><br><span class="line">	<span class="comment">// 等待上下文处于完成状态</span></span><br><span class="line">	&lt;-timeoutCtx.Done()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;等待超时结束：%s \n&quot;</span>, time.Now())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出()</span></span><br><span class="line"><span class="comment">Begin:2021-04-19 17:10:26.625493 +0800 CST m=+0.000780950</span></span><br><span class="line"><span class="comment">子协程输出...</span></span><br><span class="line"><span class="comment">等待超时结束：2021-04-19 17:10:29.627471 +0800 CST m=+3.002727432 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="创建子上下文"><a href="#创建子上下文" class="headerlink" title="创建子上下文"></a>创建子上下文</h2><h3 id="可取消的-WithCancel"><a href="#可取消的-WithCancel" class="headerlink" title="可取消的(WithCancel)"></a>可取消的(WithCancel)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// parent 父上下文</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc)</span><br></pre></td></tr></table></figure>

<p><code>context.WithCancel</code> 函数能够从 <code>context.Context</code> 中衍生出一个新的子上下文并返回用于取消该上下文的函数。一旦我们执行返回的取消函数，当前上下文以及它的子上下文都会被取消，所有的 Goroutine 都会同步收到这一取消信号。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Begin:%s\n&quot;</span>, time.Now())</span><br><span class="line">	<span class="comment">// 基于context.Background()为根，创建一个可取消的子Context</span></span><br><span class="line">	cancelCtx, cancelFunc := context.WithCancel(context.Background())</span><br><span class="line">	<span class="comment">// 子协程执行取消</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">				fmt.Println(<span class="string">&quot;子协程终止,上下文已被取消&quot;</span>)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">				fmt.Printf(<span class="string">&quot;%s: 子协程输出\n&quot;</span>, time.Now())</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(cancelCtx)</span><br><span class="line">	<span class="comment">// 3秒后执行取消操作</span></span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">	<span class="comment">// 取消上下文，子协程也会停止输出</span></span><br><span class="line">	cancelFunc()</span><br><span class="line">	<span class="comment">// 看看子协程是否停止</span></span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;End：%s \n&quot;</span>, time.Now())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出</span></span><br><span class="line"><span class="comment">Begin:2021-04-20 11:08:29.77314 +0800 CST m=+0.000635148</span></span><br><span class="line"><span class="comment">2021-04-20 11:08:30.776474 +0800 CST m=+1.003963915: 子协程输出</span></span><br><span class="line"><span class="comment">2021-04-20 11:08:31.780469 +0800 CST m=+2.007953399: 子协程输出</span></span><br><span class="line"><span class="comment">2021-04-20 11:08:32.781569 +0800 CST m=+3.009048079: 子协程输出</span></span><br><span class="line"><span class="comment">子协程终止,上下文已被取消</span></span><br><span class="line"><span class="comment">End：2021-04-20 11:08:33.778543 +0800 CST m=+4.006016052 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="指定超时时间-WithTimeout"><a href="#指定超时时间-WithTimeout" class="headerlink" title="指定超时时间(WithTimeout)"></a>指定超时时间(WithTimeout)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc)</span><br></pre></td></tr></table></figure>
<p><code>context.WithTimeout</code> 函数接收父上下文(parent)和一个超时时间，能够从 <code>context.Context </code>中衍生出一个新的子上下文并返回用于取消该上下文的函数。执行取消函数时功能和WithCancel一样。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 等待超时，自动取消</span></span><br><span class="line">	waitTimeOut()</span><br><span class="line">	<span class="comment">// 子协程主动发送取消信号</span></span><br><span class="line">	subSendCancel()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待超时，自动取消</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">waitTimeOut</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;等待超时——&gt; Begin:%s\n&quot;</span>, time.Now())</span><br><span class="line">	<span class="comment">// 基于context.Background()为根，创建一个3秒后自动取消的子Context</span></span><br><span class="line">	ctx, cancelFunc := context.WithTimeout(context.Background(), <span class="number">3</span>*time.Second)</span><br><span class="line">	<span class="comment">// 延迟关闭</span></span><br><span class="line">	<span class="keyword">defer</span> cancelFunc()</span><br><span class="line">	<span class="comment">// 创建子协程</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">				fmt.Println(<span class="string">&quot;子协程收到取消信号，终止&quot;</span>)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">				fmt.Printf(<span class="string">&quot;子协程输出:%s\n&quot;</span>, time.Now())</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(ctx)</span><br><span class="line">	<span class="comment">// 等待超时，自动取消</span></span><br><span class="line">	&lt;-ctx.Done()</span><br><span class="line">	<span class="comment">// 超时后，查看子协程输出</span></span><br><span class="line">	time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;End：%s \n&quot;</span>, time.Now())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子协程主动发送取消信号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subSendCancel</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;子协程主动发送取消信号——&gt; Begin:%s\n&quot;</span>, time.Now())</span><br><span class="line">	<span class="comment">// 基于context.Background()为根，创建一个可取消的子Context</span></span><br><span class="line">	cancelCtx, cancelFunc := context.WithTimeout(context.Background(), <span class="number">5</span>*time.Second)</span><br><span class="line">	<span class="comment">// 创建子协程</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(cancelFunc context.CancelFunc)</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;子协程发送-&gt;取消信号&quot;</span>)</span><br><span class="line">		cancelFunc()</span><br><span class="line">	&#125;(cancelFunc)</span><br><span class="line">	<span class="comment">// 同步阻塞</span></span><br><span class="line">	&lt;-cancelCtx.Done()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;End：%s \n&quot;</span>, time.Now())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">等待超时——&gt; Begin:2021-04-20 11:43:59.232983 +0800 CST m=+0.000634095</span></span><br><span class="line"><span class="comment">子协程输出:2021-04-20 11:44:00.237187 +0800 CST m=+1.004832384</span></span><br><span class="line"><span class="comment">子协程输出:2021-04-20 11:44:01.240217 +0800 CST m=+2.007856775</span></span><br><span class="line"><span class="comment">子协程输出:2021-04-20 11:44:02.24042 +0800 CST m=+3.008054083</span></span><br><span class="line"><span class="comment">子协程收到取消信号，终止</span></span><br><span class="line"><span class="comment">End：2021-04-20 11:44:04.239543 +0800 CST m=+5.007166176 </span></span><br><span class="line"><span class="comment">子协程主动发送取消信号——&gt; Begin:2021-04-20 11:44:04.239701 +0800 CST m=+5.007323972</span></span><br><span class="line"><span class="comment">子协程发送-&gt;取消信号</span></span><br><span class="line"><span class="comment">End：2021-04-20 11:44:04.239809 +0800 CST m=+5.007432189 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="指定截止时间-WithDeadline"><a href="#指定截止时间-WithDeadline" class="headerlink" title="指定截止时间(WithDeadline)"></a>指定截止时间(WithDeadline)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span></span> (Context, CancelFunc) </span><br></pre></td></tr></table></figure>
<p><code>context.WithDeadline</code> 函数接收父上下文(parent)和一个截止时间，能够从 <code>context.Context</code> 中衍生出一个新的子上下文并返回用于取消该上下文的函数。执行取消函数时功能和WithCancel一样。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Begin:%s\n&quot;</span>, time.Now())</span><br><span class="line">	<span class="comment">// 基于context.Background()为根，创建一个5秒后自动取消的子Context</span></span><br><span class="line">	deadlineCtx, cancelFunc := context.WithDeadline(context.Background(), time.Now().Add(<span class="number">3</span>*time.Second))</span><br><span class="line">	<span class="keyword">defer</span> cancelFunc()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span>  &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">				fmt.Println(<span class="string">&quot;子协程终止,上下文已被取消&quot;</span>)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">				fmt.Printf(<span class="string">&quot;子协程输出: %s\n&quot;</span>,time.Now())</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(deadlineCtx)</span><br><span class="line">	<span class="comment">// 同步阻塞，直到上下文被完成或取消</span></span><br><span class="line">	&lt;-deadlineCtx.Done()</span><br><span class="line">	<span class="comment">// 查看子协程是否收到取消信号</span></span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;End：%s \n&quot;</span>, time.Now())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">Begin:2021-04-20 13:54:56.224477 +0800 CST m=+0.000826415</span></span><br><span class="line"><span class="comment">子协程输出: 2021-04-20 13:54:57.227495 +0800 CST m=+1.003830376</span></span><br><span class="line"><span class="comment">子协程输出: 2021-04-20 13:54:58.229607 +0800 CST m=+2.005927050</span></span><br><span class="line"><span class="comment">子协程输出: 2021-04-20 13:54:59.230173 +0800 CST m=+3.006503681</span></span><br><span class="line"><span class="comment">子协程输出: 2021-04-20 13:55:00.233766 +0800 CST m=+4.010057104</span></span><br><span class="line"><span class="comment">子协程终止,上下文已被取消</span></span><br><span class="line"><span class="comment">End：2021-04-20 13:55:00.233781 +0800 CST m=+4.010072336 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="上下文中传值"><a href="#上下文中传值" class="headerlink" title="上下文中传值"></a>上下文中传值</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// parent:父上下文</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span></span> Context </span><br></pre></td></tr></table></figure>
<p><code>context.WithValue</code> 能从父 Context中创建一个子子 Context,并传体一个键值对信息给子 Context，在子 Context中，通过context.Value获取对应的值信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Begin:%s\n&quot;</span>, time.Now())</span><br><span class="line">	<span class="comment">// 基于context.Background()为根，创建一个5秒后自动取消的子Context</span></span><br><span class="line">	parentCtx, cancelFunc := context.WithCancel(context.Background())</span><br><span class="line">	<span class="comment">// 传体信息</span></span><br><span class="line">	valueCtx := context.WithValue(parentCtx, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, cancelFunc2 context.CancelFunc)</span></span> &#123;</span><br><span class="line">		<span class="comment">// 取出上下文中key=name的值</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;取出上下文中的name: %v\n&quot;</span>, ctx.Value(<span class="string">&quot;name&quot;</span>))</span><br><span class="line">		<span class="comment">// 子协程发送取消信号</span></span><br><span class="line">		cancelFunc()</span><br><span class="line">	&#125;(valueCtx, cancelFunc)</span><br><span class="line">	<span class="comment">// 等待工作完成或者上下文被取消</span></span><br><span class="line">	&lt;-parentCtx.Done()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;End：%s \n&quot;</span>, time.Now())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">Begin:2021-04-20 14:15:57.243469 +0800 CST m=+0.000674192</span></span><br><span class="line"><span class="comment">取出上下文中的name: 张三</span></span><br><span class="line"><span class="comment">End：2021-04-20 14:15:57.243699 +0800 CST m=+0.000904753 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>bufio包使用</title>
    <url>/2021/04/26/bufio%E5%8C%85%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote>
<p>bufio包实现了有缓冲的I/O。它包装一个io.Reader或io.Writer接口对象，使用这个包可以大幅提高文件读写的效率。</p>
</blockquote>
<span id="more"></span>

<h2 id="如何提高效率"><a href="#如何提高效率" class="headerlink" title="如何提高效率?"></a>如何提高效率?</h2><p><img src="9c1c4f918059c695ae7814b606b654bdd3800fe60c5fa57c4c590c42f8035381.png" alt="图 1">  </p>
<p><strong>写入流程梳理</strong>:<br>当写入内容小于缓冲区(buf)的可用大小时,内容写入缓存区(buf)；<br>当缓冲区(buf)空间不够时，一次性将缓冲区(buf)内容写入文件,并清空缓存区(buf)；<br>当写入内容大于缓冲区(buf)空间时，将内容直接写入文件；</p>
<p><strong>读取流程梳理</strong>:<br>当缓冲区(buf)内容为空时，一次性从文件中读取大小等于缓冲区(buf)的内容；<br>当读取内容小于缓冲区(buf)空间时,从缓存区(buf)读取；<br>当读取内容大于缓冲区(buf)空间时，将内容从文件直接读取；</p>
<p><strong>总结</strong>:  避免频繁操作文件、减少访问本地磁盘次数，从而提高效率。</p>
<h2 id="读取-Read"><a href="#读取-Read" class="headerlink" title="读取(Read*)"></a>读取(Read*)</h2><h3 id="创建读取器"><a href="#创建读取器" class="headerlink" title="创建读取器"></a>创建读取器</h3><p><strong>创建默认缓冲大小 (NewReader)</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(rd io.Reader)</span></span> *Reader</span><br></pre></td></tr></table></figure>
<p>根据rd创建一个具有默认大小缓冲的*Reader。默认大小:4096字节</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">reader := bufio.NewReader(strings.NewReader(<span class="string">&quot;hello Word&quot;</span>))</span><br><span class="line">fmt.Printf(<span class="string">&quot;默认大小:%v&quot;</span>,reader.Size())</span><br><span class="line"><span class="comment">// 输出: 默认大小:4096</span></span><br></pre></td></tr></table></figure>

<p><strong>创建指定缓冲大小( NewReaderSize)</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReaderSize</span><span class="params">(rd io.Reader, size <span class="type">int</span>)</span></span> *Reader</span><br></pre></td></tr></table></figure>
<p>根据rd创建指定size大小缓冲的*Reader。最小大小为16字节</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">reader := bufio.NewReaderSize(strings.NewReader(<span class="string">&quot;hello Word&quot;</span>),<span class="number">40</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;大于16字节:%v\n&quot;</span>,reader.Size())</span><br><span class="line">reader2 := bufio.NewReaderSize(strings.NewReader(<span class="string">&quot;hello Word&quot;</span>),<span class="number">4</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;小于16字节:%v\n&quot;</span>,reader2.Size())</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">大于16字节:40</span></span><br><span class="line"><span class="comment">小于16字节:16</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="读取指定字节-Read"><a href="#读取指定字节-Read" class="headerlink" title="读取指定字节(Read)"></a>读取指定字节(Read)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span></span> Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p>将读取数据写入p。返回写入p的字节数和错误信息。当读取到达结尾时，返回值n将为0而err将为io.EOF。</p>
<p>现有文件a.txt,内容如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">张三 23 北京 男</span><br><span class="line">李四 22 南京 男</span><br><span class="line">郭明 32 上海 男</span><br><span class="line">王英 18 武汉 女</span><br></pre></td></tr></table></figure>

<p>读取程序如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//打开一个文件</span></span><br><span class="line">	file, err := os.Open(<span class="string">&quot;./a.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 关闭文件</span></span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	<span class="comment">// 创建读取器</span></span><br><span class="line">	reader := bufio.NewReader(file)</span><br><span class="line">	<span class="keyword">for</span>  &#123;</span><br><span class="line">		<span class="comment">// 一次读取21个字节</span></span><br><span class="line">		context := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">21</span>)</span><br><span class="line">		_, err = reader.Read(context)</span><br><span class="line">		<span class="comment">// 读取完毕，则跳出</span></span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;读取内容:%s&quot;</span>, context)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出</span></span><br><span class="line"><span class="comment">读取内容:张三 23 北京 男</span></span><br><span class="line"><span class="comment">读取内容:李四 22 南京 男</span></span><br><span class="line"><span class="comment">读取内容:郭明 32 上海 男</span></span><br><span class="line"><span class="comment">读取内容:王英 18 武汉 女</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="读取一个字节-ReadByte"><a href="#读取一个字节-ReadByte" class="headerlink" title="读取一个字节(ReadByte)"></a>读取一个字节(ReadByte)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span></span> ReadByte() (<span class="type">byte</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p>每次读取一个字节返回。当读取到达结尾时，返回值n将为0而err将为io.EOF。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 基于字符串创建读取器</span></span><br><span class="line">	reader := bufio.NewReader(strings.NewReader(<span class="string">&quot;Go,Word!&quot;</span>))</span><br><span class="line">	<span class="keyword">for</span>  &#123;</span><br><span class="line">		<span class="comment">// 一次读取1个字节</span></span><br><span class="line">		readByte, err := reader.ReadByte()</span><br><span class="line">		<span class="comment">// 读取完毕，则跳出</span></span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;读取内容:%s\n&quot;</span>, <span class="type">string</span>(readByte))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">读取内容:G</span></span><br><span class="line"><span class="comment">读取内容:o</span></span><br><span class="line"><span class="comment">读取内容:,</span></span><br><span class="line"><span class="comment">读取内容:W</span></span><br><span class="line"><span class="comment">读取内容:o</span></span><br><span class="line"><span class="comment">读取内容:r</span></span><br><span class="line"><span class="comment">读取内容:d</span></span><br><span class="line"><span class="comment">读取内容:!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="读取一行-ReadLine"><a href="#读取一行-ReadLine" class="headerlink" title="读取一行(ReadLine)"></a>读取一行(ReadLine)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span></span> ReadLine() (line []<span class="type">byte</span>, isPrefix <span class="type">bool</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p><code>ReadLine</code>尝试读取返回一行数据，不包括行尾标志的字节,但是有以下几个场景需要注意:</p>
<p>如果行太长超过了缓冲，返回值isPrefix=true,Line为行的前一部分。<br>该行剩下部分将在下一次读取中返回并且此时的isPrefix=false,<strong>即isPrefix会在行的最后一个片段时才设为false</strong>。<br>如果行内小于等于缓冲,isPrefix=false,Line为一整行的内容。<br>官方文档中推荐使用 <code>ReadBytes</code>(‘\n’)或<code>ReadString</code>(‘\n’)来代替ReadLine。</p>
<p><strong>当行超过了缓冲缓存时</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建字符串，每行超过16个字节</span></span><br><span class="line">	str := strings.Repeat(<span class="string">&quot;Hello,Hello,Hello,Hello!\n&quot;</span>, <span class="number">3</span>)</span><br><span class="line">	<span class="comment">// 基于字符串创建一个缓冲区=16字节的读取器</span></span><br><span class="line">	reader := bufio.NewReaderSize(strings.NewReader(str), <span class="number">16</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 每次读取一行</span></span><br><span class="line">		line, prefix, err := reader.ReadLine()</span><br><span class="line">		<span class="comment">// 读取完毕，则跳出</span></span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;line:%s isPrefix:%t \n&quot;</span>, line, prefix)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:<br><img src="100d5bb2c02b34eac47eea2aa1738aadf03ba71c8a708bc855081f988cd06d93.png" alt="图 4">  </p>
<p><strong>当行小于缓冲缓存时</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 每行不超过16个字节</span></span><br><span class="line">	str := strings.Repeat(<span class="string">&quot;Hello Word!\n&quot;</span>, <span class="number">3</span>)</span><br><span class="line">	<span class="comment">// 基于字符串创建读取器</span></span><br><span class="line">	reader := bufio.NewReaderSize(strings.NewReader(str), <span class="number">16</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 每次读取一行</span></span><br><span class="line">		line, prefix, err := reader.ReadLine()</span><br><span class="line">		<span class="comment">// 读取完毕，则跳出</span></span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;line:%s isPrefix:%t \n&quot;</span>, line, prefix)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:<br><img src="5d468f8e153fe27014650ee38ec32342ea7eae6a63fd65b0d802ec42a5924cbf.png" alt="图 3">  </p>
<h3 id="读取到指定的字符"><a href="#读取到指定的字符" class="headerlink" title="读取到指定的字符"></a>读取到指定的字符</h3><p><strong>同类方法列表</strong></p>
<table>
    <tr>
        <th>方法</th><th>无delim是否报错</th>
    </tr>
    <tr>
        <td>ReadSlice(delim byte) (line []byte, err error)</td><td>报错(bufio: buffer full)</td>
    </tr>
    <tr>
        <td>ReadBytes(delim byte) ([]byte, error)/td></td><td>不会</td>
    </tr>
    <tr>
        <td>ReadString(delim byte) (string, error)</td><td>不会</td>
    </tr>
</table>

<p><strong>每次读取到字符delim(包含)</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 基于字符串创建读取器</span></span><br><span class="line">	reader := bufio.NewReaderSize(strings.NewReader(<span class="string">&quot;Go,PHP,Java,Python,C&quot;</span>), <span class="number">16</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 读取</span></span><br><span class="line">		s, err := reader.ReadString(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">		<span class="comment">// 读取完毕，则跳出</span></span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;err:%s&quot;</span>, err.Error())</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, s)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">Go,</span></span><br><span class="line"><span class="comment">PHP,</span></span><br><span class="line"><span class="comment">Java,</span></span><br><span class="line"><span class="comment">Python,</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>上述例子中C后面没有<code>,</code>,所以不会读出</p>
<p><strong>模拟每次读取一行</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 设置每行超过缓冲区大小</span></span><br><span class="line">	repeat := strings.Repeat(<span class="string">&quot;Hello,Hello,Hello,Hello\n&quot;</span>, <span class="number">3</span>)</span><br><span class="line">	<span class="comment">// 基于字符串创建读取器</span></span><br><span class="line">	reader := bufio.NewReaderSize(strings.NewReader(repeat), <span class="number">16</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 读取</span></span><br><span class="line">		s, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="comment">// 读取完毕，则跳出</span></span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;err:%s&quot;</span>, err.Error())</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s&quot;</span>, s)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 输出</span></span><br><span class="line"><span class="comment">Hello,Hello,Hello,Hello</span></span><br><span class="line"><span class="comment">Hello,Hello,Hello,Hello</span></span><br><span class="line"><span class="comment">Hello,Hello,Hello,Hello</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>虽然每行超过缓冲区大小，但是依然可以整行读出</p>
<h3 id="每次读取前几个字节-Peek"><a href="#每次读取前几个字节-Peek" class="headerlink" title="每次读取前几个字节(Peek)"></a>每次读取前几个字节(Peek)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span></span> Peek(n <span class="type">int</span>) ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p>每次读取输入流的前n个字节，<strong>且不会移动读取位置</strong>,所以当输入流不变时，每次读取都是一样的。<br>当内容小于n时，error会返回io.EOF<br>当n大于缓冲区大小时，error会返回ErrBufferFull</p>
<p><strong>内容小于n时</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 基于字符串创建读取器</span></span><br><span class="line">	reader := bufio.NewReaderSize(strings.NewReader(<span class="string">&quot;hello&quot;</span>), <span class="number">16</span>)</span><br><span class="line">	<span class="comment">// 读取</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">		s, err := reader.Peek(<span class="number">16</span>)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;结果: %s &quot;</span>, s)</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, <span class="string">&quot;已读完&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;err:%s\n&quot;</span>, err.Error())</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出-&gt; 结果: hello 已读完</span></span><br></pre></td></tr></table></figure>

<p><strong>当n大于缓冲区大小时</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 基于字符串创建读取器</span></span><br><span class="line">	reader := bufio.NewReaderSize(strings.NewReader(<span class="string">&quot;hello&quot;</span>), <span class="number">16</span>)</span><br><span class="line">	<span class="comment">// 读取</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">		<span class="comment">// 大于缓冲区大小</span></span><br><span class="line">		s, err := reader.Peek(<span class="number">17</span>)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;结果: %s &quot;</span>, s)</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, <span class="string">&quot;已读完&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;err:%s\n&quot;</span>, err.Error())</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出-&gt; 结果: hello err:bufio: buffer full</span></span><br></pre></td></tr></table></figure>

<h2 id="写入-Write"><a href="#写入-Write" class="headerlink" title="写入(Write*)"></a>写入(Write*)</h2><h3 id="创建写入器"><a href="#创建写入器" class="headerlink" title="创建写入器"></a>创建写入器</h3><p><strong>创建默认缓冲大小(NewWriter)</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriter</span><span class="params">(w io.Writer)</span></span> *Writer</span><br></pre></td></tr></table></figure>
<p>根据w创建一个具有默认大小缓冲的*Writer。默认大小:4096字节</p>
<p><strong>创建指定缓冲大小(NewWriterSize)</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriterSize</span><span class="params">(w io.Writer, size <span class="type">int</span>)</span></span> *Writer</span><br></pre></td></tr></table></figure>

<h3 id="Write"><a href="#Write" class="headerlink" title="Write*"></a>Write*</h3><p><strong>方法列表</strong></p>
<table>
    <tr>
        <th>方法名</th><th>描述</th>
    </tr>
    <tr>
        <td>Write(p []byte) (nn int, err error)</td><td>Write将p的内容写入缓冲。返回写入的字节数。如果返回值nn < len(p)，还会返回一个错误说明原因。</td>
    </tr>
    <tr>
        <td>WriteString(s string) (int, error)</td><td>同上,只是入参变成字符串。</td>
    </tr>
</table>

<p><strong>当写入内容大于缓冲区时</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	file, _ := os.OpenFile(<span class="string">&quot;./test.txt&quot;</span>, os.O_APPEND|os.O_WRONLY, os.ModePerm)</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	reader := bufio.NewWriterSize(file, <span class="number">20</span>)</span><br><span class="line">	<span class="comment">// 当写入的内容字节大于缓冲区大小时,会直接写入文件</span></span><br><span class="line">	write, err := reader.Write([]<span class="type">byte</span>(<span class="string">&quot;hello,hello,hello 你好！\n&quot;</span>))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;直接写入文件: %d\n&quot;</span>, write)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出——&gt; 直接写入文件: 28</span></span><br></pre></td></tr></table></figure>

<p><strong>当写入内容小于缓冲区时</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	file, _ := os.OpenFile(<span class="string">&quot;./test.txt&quot;</span>, os.O_APPEND|os.O_WRONLY, os.ModePerm)</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	reader := bufio.NewWriterSize(file, <span class="number">20</span>)</span><br><span class="line">	<span class="comment">// 当写入的内容字节小于缓冲区大小时,不会直接写入文件</span></span><br><span class="line">	write, err := reader.Write([]<span class="type">byte</span>(<span class="string">&quot;\nhello,Go!&quot;</span>))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 该函数会使缓冲区的内容，直接写入文件</span></span><br><span class="line">	reader.Flush()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Flush写入文件: %d\n&quot;</span>, write)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出-&gt; Flush写入文件: 10</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>ioutil包使用</title>
    <url>/2021/04/25/ioutil%E5%8C%85%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote>
<p>在Go语言中，io包主要声明的是对I/O操作的基本接口，而io/ioutil包则实现了对应的方法，方便我们直接使用。</p>
</blockquote>
<span id="more"></span>

<p><strong>方法列表</strong></p>
<table>
    <tr>
        <th>方法名</th><th>描述</th>
    </tr>
    <tr>
        <td>NopCloser</td><td>对Reader进行封装，返回一个ReadCloser</td>
    </tr>
    <tr>
        <td>ReadAll</td><td>对Reader进行读取，直到发生错误或者遇到EOF为止，然后返回被读取的数据</td>
    </tr>
    <tr>
        <td>ReadFile</td><td>读取指定文件的内容，并返回</td>
    </tr>
    <tr>
        <td>ReadDir</td><td>读取指定的目录， 并返回排序后的目录列表(根据名称排序)</td>
    </tr>
    <tr>
        <td>TempDir</td><td>在指定目录新创建一个临时文件，以可读写的方式打开它，并返回 *os.File 指针</td>
    </tr>
    <tr>
        <td>WriteFile</td><td>将给定的数据写入到指定文件里面</td>
    </tr>
</table>

<p><strong>注意</strong><br><code>WriteFile</code>：如果文件不存在，则去创建它；<br>如果文件已经存在，则再写入之前会先清空文件中已有的内容。</p>
<h2 id="ReadAll"><a href="#ReadAll" class="headerlink" title="ReadAll"></a>ReadAll</h2><p><strong>方法签名</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadAll</span><span class="params">(r io.Reader)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p><code>ReadAll</code>从r读取数据直到EOF或error，返回读取内容([]byte)和错误(error)。读取成功时err返回nil。<br>因为本函数定义为读取r直到EOF，它不会将读取返回的EOF视为应报告的错误。</p>
<p><strong>使用</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// NewReader创建一个从s读取数据的Reader。本函数类似bytes.NewBufferString</span></span><br><span class="line">	reader := strings.NewReader(<span class="string">&quot;Hello word !&quot;</span>)</span><br><span class="line">	all, err := ioutil.ReadAll(reader)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s&quot;</span>,all)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出: Hello word !</span></span><br></pre></td></tr></table></figure>

<h2 id="ReadFile"><a href="#ReadFile" class="headerlink" title="ReadFile"></a>ReadFile</h2><p><strong>方法签名</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(filename <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p><code>ReadFile</code>从filename指定的文件中读取内容并返回。读取成功时err返回nil。<br>因为本函数定义为读取r直到EOF，它不会将读取返回的EOF视为应报告的错误。</p>
<p><strong>使用</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 文件路径</span></span><br><span class="line">   fileName := <span class="string">&quot;./test.log&quot;</span></span><br><span class="line">   data, err := ioutil.ReadFile(fileName)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;%s&quot;</span>,data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ReadDir"><a href="#ReadDir" class="headerlink" title="ReadDir"></a>ReadDir</h2><p><strong>方法签名</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadDir</span><span class="params">(dirname <span class="type">string</span>)</span></span> ([]os.FileInfo, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p>返回dirname指定的目录的目录信息的有序列表。</p>
<p><strong>使用</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	dirName := <span class="string">&quot;./log&quot;</span></span><br><span class="line">	dirList, err := ioutil.ReadDir(dirName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, info := <span class="keyword">range</span> dirList &#123;</span><br><span class="line">		fmt.Println(info.Name())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TempDir"><a href="#TempDir" class="headerlink" title="TempDir"></a>TempDir</h2><p><strong>方法签名</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TempDir</span><span class="params">(dir, pattern <span class="type">string</span>)</span></span> (name <span class="type">string</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p>在dir目录里创建一个新的、使用pattern作为前缀的临时文件夹，并返回文件夹的路径。</p>
<p>如果dir是空字符串，TempDir使用默认用于临时文件的目录。<br>不同程序同时调用该函数会创建不同的临时目录，<br>创建的临时文件夹时在不使用时，需要删除。</p>
<p><strong>使用</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> pathList []<span class="type">string</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">var</span> path <span class="type">string</span></span><br><span class="line">		<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">		<span class="keyword">switch</span> i &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">			<span class="comment">// 指定目录和前缀</span></span><br><span class="line">			path, err = ioutil.TempDir(<span class="string">&quot;./log&quot;</span>,<span class="string">&quot;tmp_&quot;</span>)</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			<span class="comment">// 只指定目录</span></span><br><span class="line">			path, err = ioutil.TempDir(<span class="string">&quot;./log&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			<span class="comment">// 目录为空、前缀不为空</span></span><br><span class="line">			path, err = ioutil.TempDir(<span class="string">&quot;&quot;</span>,<span class="string">&quot;tmp_&quot;</span>)</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			<span class="comment">// 目录和前缀都是空</span></span><br><span class="line">			path, err = ioutil.TempDir(<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		pathList = <span class="built_in">append</span>(pathList, path)</span><br><span class="line">    <span class="comment">// 删除临时目录,测试时注释</span></span><br><span class="line">		<span class="comment">// _ = os.RemoveAll(path)</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(pathList)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">[./log/tmp_1985114812 ./log/3136642706 /tmp/tmp_3038884210 /tmp/80588905]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="TempFile"><a href="#TempFile" class="headerlink" title="TempFile"></a>TempFile</h2><p><strong>方法签名</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TempFile</span><span class="params">(dir, pattern <span class="type">string</span>)</span></span> (f *os.File, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p>在dir目录下创建一个新的、使用pattern为前缀的临时文件，以读写模式打开该文件并返回os.File指针。</p>
<p>如果dir是空字符串，TempFile使用默认用于临时文件的目录。<br>不同程序同时调用该函数会创建不同的临时文件。<br>创建的临时文件夹时在不使用时，需要删除。</p>
<p><strong>使用</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> fileList []<span class="type">string</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">var</span> file *os.File</span><br><span class="line">		<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">		<span class="keyword">switch</span> i &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">			<span class="comment">// 指定目录和前缀</span></span><br><span class="line">			file, err = ioutil.TempFile(<span class="string">&quot;./log&quot;</span>, <span class="string">&quot;tmp_&quot;</span>)</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			<span class="comment">// 只指定目录</span></span><br><span class="line">			file, err = ioutil.TempFile(<span class="string">&quot;./log&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			<span class="comment">// 目录为空、前缀不为空</span></span><br><span class="line">			file, err = ioutil.TempFile(<span class="string">&quot;&quot;</span>, <span class="string">&quot;tmp_&quot;</span>)</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			<span class="comment">// 目录和前缀都是空</span></span><br><span class="line">			file, err = ioutil.TempFile(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		fileList = <span class="built_in">append</span>(fileList, file.Name())</span><br><span class="line">		<span class="comment">//删除</span></span><br><span class="line">		<span class="comment">//_ = os.Remove(file.Name())</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(fileList)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">[./log/tmp_810405943 ./log/3229488309 /tmp/tmp_691615726 /tmp/1459961838]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


<h2 id="WriteFile"><a href="#WriteFile" class="headerlink" title="WriteFile"></a>WriteFile</h2><p><strong>方法签名</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteFile</span><span class="params">(filename <span class="type">string</span>, data []<span class="type">byte</span>, perm os.FileMode)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure>
<p>函数向filename指定的文件中写入数据。</p>
<p>如果文件不存在,将按给出的权限创建文件，<br>如果文件存在,在写入数据之前清空文件。</p>
<p><strong>使用</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fileName := <span class="string">&quot;./test.txt&quot;</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		_ = ioutil.WriteFile(fileName, []<span class="type">byte</span>(<span class="string">&quot;Hello Word!&quot;</span>), os.ModePerm)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>fmt包使用</title>
    <url>/2021/04/24/fmt%E5%8C%85%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="输出到控制台"><a href="#输出到控制台" class="headerlink" title="输出到控制台"></a>输出到控制台</h2><h3 id="Printf"><a href="#Printf" class="headerlink" title="Printf"></a>Printf</h3><blockquote>
<p>Printf根据format参数生成格式化的字符串并写入标准输出。返回写入的字节数和遇到的任何错误。</p>
</blockquote>
<span id="more"></span>

<p><strong>format格式</strong></p>
<table>
    <tr>
        <th>动 词</th><th>功 能</th>
    </tr>
    <tr>
        <td>%v</td><td>按值的本来值输出</td>
    </tr>
    <tr>
        <td>%+v</td><td>在 %v 基础上，对结构体字段名和值进行展开</td>
    </tr>
    <tr>
        <td>%#v</td><td>输出 Go 语言语法格式的值</td>
    </tr>
    <tr>
        <td>%T</td><td>输出 Go 语言语法格式的类型和值</td>
    </tr>
    <tr>
        <td>%%</td><td>输出 % 本体</td>
    </tr>
    <tr>
        <td>%b</td><td>整型以二进制方式显示</td>
    </tr>
    <tr>
        <td>%o</td><td>整型以八进制方式显示</td>
    </tr>
    <tr>
        <td>%d</td><td>整型以十进制方式显示</td>
    </tr>
    <tr>
        <td>%x</td><td>整型以十六进制方式显示</td>
    </tr>
    <tr>
        <td>%X</td><td>整型以十六进制、字母大写方式显示</td>
    </tr>
    <tr>
        <td>%U</td><td>Unicode 字符</td>
    </tr>
    <tr>
        <td>%f</td><td>浮点数</td>
    </tr>
    <tr>
        <td>%p</td><td>指针，十六进制方式显示</td>
    </tr>
    <tr>
        <td>%c</td><td>数值对应的 Unicode 编码字符</td>
    </tr>
    <tr>
        <td>%s</td><td>直接输出字符串或者[]byte</td>
    </tr>
    <tr>
        <td>%t</td><td>输出值的 true 或 false</td>
    </tr>
</table>

<p><strong>打印字符串</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str := <span class="string">&quot;hello word&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%%s-&gt; %s \n&quot;</span>,str)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%%v-&gt; %v \n&quot;</span>,str)</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">%s-&gt; hello word </span></span><br><span class="line"><span class="comment">%v-&gt; hello word </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>打印布尔类型</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;%%t-&gt; %t \n&quot;</span>, b)</span><br></pre></td></tr></table></figure>

<p><strong>打印浮点型</strong></p>
<table>
    <tr>
        <th>格式</th><th>描述</th>
    </tr>
    <tr>
        <td>%f</td><td>默认宽度，默认精度</td>
    </tr>
    <tr>
        <td>%9f</td><td>宽度9，默认精度</td>
    </tr>
    <tr>
        <td>%.2f</td><td>默认宽度，精度2</td>
    </tr>
    <tr>
        <td>%9.2f</td><td>宽度9，精度2</td>
    </tr>
    <tr>
        <td>%9.f</td><td>宽度9，精度0</td>
    </tr>
</table>


<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f := <span class="number">1.234567890</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;默认宽度，默认精度:%f \n&quot;</span>, f)</span><br><span class="line">fmt.Printf(<span class="string">&quot;宽度9，默认精度:%9f \n&quot;</span>, f)</span><br><span class="line">fmt.Printf(<span class="string">&quot;默认宽度，精度2:%.2f \n&quot;</span>, f)</span><br><span class="line">fmt.Printf(<span class="string">&quot;宽度9，精度2:%9.2f \n&quot;</span>, f)</span><br><span class="line">fmt.Printf(<span class="string">&quot;宽度9，精度0 :%9.f \n&quot;</span>, f)</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">默认宽度，默认精度:1.234568 </span></span><br><span class="line"><span class="comment">宽度9，默认精度: 1.234568 </span></span><br><span class="line"><span class="comment">默认宽度，精度2:1.23 </span></span><br><span class="line"><span class="comment">宽度9，精度2:     1.23 </span></span><br><span class="line"><span class="comment">宽度9，精度0 :        1 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>打印整数</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个整数变量</span></span><br><span class="line">a := <span class="number">54321</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;十进制:%d\n&quot;</span>,a)</span><br><span class="line">fmt.Printf(<span class="string">&quot;二进制:%b\n&quot;</span>,a)</span><br><span class="line">fmt.Printf(<span class="string">&quot;八进制:%o\n&quot;</span>,a)</span><br><span class="line">fmt.Printf(<span class="string">&quot;十六进制:%x\n&quot;</span>,a)</span><br><span class="line">fmt.Printf(<span class="string">&quot;十六进制,字母大写:%X\n&quot;</span>,a)</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">十进制:54321</span></span><br><span class="line"><span class="comment">二进制:1101010000110001</span></span><br><span class="line"><span class="comment">八进制:152061</span></span><br><span class="line"><span class="comment">十六进制:d431</span></span><br><span class="line"><span class="comment">十六进制,字母大写:D431</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>打印指针</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str := <span class="string">&quot;hello&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;打印指针:%p\n&quot;</span>, &amp;str)</span><br><span class="line"><span class="comment">//输出: 打印指针:0xc000098d50</span></span><br></pre></td></tr></table></figure>

<p><strong>打印变量类型</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line">arr := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;arr类型: %T\n&quot;</span>, arr)</span><br><span class="line"><span class="comment">// 映射</span></span><br><span class="line">map1 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line">	<span class="string">&quot;张三&quot;</span>: <span class="number">20</span>,</span><br><span class="line">	<span class="string">&quot;李四&quot;</span>: <span class="number">23</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;map1类型: %T\n&quot;</span>, map1)</span><br><span class="line"><span class="comment">// 匿名结构体</span></span><br><span class="line">fruit := <span class="keyword">struct</span> &#123;</span><br><span class="line">	name  <span class="type">string</span></span><br><span class="line">	price <span class="type">float64</span></span><br><span class="line">&#125;&#123;<span class="string">&quot;香蕉&quot;</span>, <span class="number">4.99</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;fruit类型: %T\n&quot;</span>, fruit)</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">arr类型: []int</span></span><br><span class="line"><span class="comment">map1类型: map[string]int</span></span><br><span class="line"><span class="comment">fruit类型: struct &#123; name string; price float64 &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>打印结构体</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个匿名结构体</span></span><br><span class="line">people := <span class="keyword">struct</span> &#123;</span><br><span class="line">	name, home, school <span class="type">string</span></span><br><span class="line">&#125;&#123;<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;北京&quot;</span>, <span class="string">&quot;北京大学&quot;</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, people)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, people)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, people)</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">&#123;张三 北京 北京大学&#125;</span></span><br><span class="line"><span class="comment">&#123;name:张三 home:北京 school:北京大学&#125;</span></span><br><span class="line"><span class="comment">struct &#123; name string; home string; school string &#125;&#123;name:&quot;张三&quot;, home:&quot;北京&quot;, school:&quot;北京大学&quot;&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>打印Unicode</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;%U\n&quot;</span>, <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%c\n&quot;</span>, <span class="number">65</span>)</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">U+0041</span></span><br><span class="line"><span class="comment">A</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="Print"><a href="#Print" class="headerlink" title="Print"></a>Print</h3><p><code>Print</code>: 采用默认格式将其参数格式化并写入标准输出。如果两个相邻的参数都不是字符串，会在它们的输出之间添加空格。</p>
<p><strong>打印相邻的字符串</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Print(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;word&quot;</span>,<span class="string">&quot;!&quot;</span>)</span><br><span class="line">fmt.Print(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;word&quot;</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&quot;!&quot;</span>)</span><br><span class="line"><span class="comment">// 输出: helloword2 3!helloword!</span></span><br></pre></td></tr></table></figure>
<p>如果两个相邻的参数都不是字符串，会在它们的输出之间添加空格,注意的是,<strong>不会自动换行</strong>。</p>
<h3 id="Println"><a href="#Println" class="headerlink" title="Println"></a>Println</h3><p><code>Println</code>: 采用默认格式将其参数格式化并写入标准输出。总是会在相邻参数的输出之间添加空格并在输出结束后添加换行符。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;word&quot;</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&quot;!&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;word&quot;</span>,<span class="string">&quot;!&quot;</span>)</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">hello word 2 3 !</span></span><br><span class="line"><span class="comment">hello word !</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="输出到文件"><a href="#输出到文件" class="headerlink" title="输出到文件"></a>输出到文件</h2><table>
    <tr>
        <th>方法名</th><th>描述</th>
    </tr>
    <tr>
        <td>Fprintln</td><td>功能和Println一样,但可以输出到文件</td>
    </tr>
    <tr>
        <td>Fprintf</td><td>功能和Printf一样,但可以输出到文件</td>
    </tr>
    <tr>
        <td>Fprint</td><td>功能和Print一样,但可以输出到文件</td>
    </tr>
</table>

<p><strong>输出到控制台</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">_, _ = fmt.Fprintln(os.Stdout, <span class="string">&quot;hello&quot;</span>,<span class="string">&quot;go&quot;</span>)</span><br><span class="line">_, _ = fmt.Fprintln(os.Stdout,  <span class="string">&quot;hello&quot;</span>,<span class="string">&quot;php&quot;</span>)</span><br><span class="line"><span class="comment">/** 输出</span></span><br><span class="line"><span class="comment">hello go</span></span><br><span class="line"><span class="comment">hello php</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>输出到文件</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打开文件</span></span><br><span class="line">file, err := os.OpenFile(<span class="string">&quot;./test.log&quot;</span>, os.O_APPEND|os.O_CREATE|os.O_WRONLY, os.ModePerm)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line">_, err = fmt.Fprintln(file, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;word&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(err.Error())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生成字符串"><a href="#生成字符串" class="headerlink" title="生成字符串"></a>生成字符串</h2><table>
    <tr>
        <th>方法名</th><th>描述</th>
    </tr>
    <tr>
        <td>Sprintf</td><td>同Printf一样,但是结果不输出到控制台,而是直接返回</td>
    </tr>
    <tr>
        <td>Sprint</td><td>同Print一样,但是结果不输出到控制台,而是直接返回</td>
    </tr>
    <tr>
        <td>Sprintln</td><td>同Println一样,但是结果不输出到控制台,而是直接返回</td>
    </tr>
</table>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sprintf := fmt.Sprintf(<span class="string">&quot;水果:%s 价格:%.3f&quot;</span>, <span class="string">&quot;香蕉&quot;</span>, <span class="number">1.99</span>)</span><br><span class="line">sprint := fmt.Sprint(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;LOVE&quot;</span>, <span class="string">&quot;YOU&quot;</span>)</span><br><span class="line">sprintln := fmt.Sprintln(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;LOVE&quot;</span>, <span class="string">&quot;YOU&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Sprintf:%s\n&quot;</span>,sprintf)</span><br><span class="line">fmt.Printf(<span class="string">&quot;sprint:%s\n&quot;</span>,sprint)</span><br><span class="line">fmt.Printf(<span class="string">&quot;sprintln:%s\n&quot;</span>,sprintln)</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">Sprintf:水果:香蕉 价格:1.990</span></span><br><span class="line"><span class="comment">sprint:ILOVEYOU</span></span><br><span class="line"><span class="comment">sprintln:I LOVE YOU</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="生成错误类型"><a href="#生成错误类型" class="headerlink" title="生成错误类型"></a>生成错误类型</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回错误类型</span></span><br><span class="line">err := fmt.Errorf(<span class="string">&quot;错误信息:%s&quot;</span>, <span class="string">&quot;参数不全&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;类型:%T   内容: %v&quot;</span>,err,err)</span><br><span class="line"><span class="comment">//输出: 类型:*errors.errorString   内容: 错误信息:参数不全</span></span><br></pre></td></tr></table></figure>

<h2 id="接收控制台输入"><a href="#接收控制台输入" class="headerlink" title="接收控制台输入"></a>接收控制台输入</h2><p><code>Scan</code><br>接收终端输入，按照参数输入顺序赋值，参数间以空格(或换行)间隔，如果输入的参数少于接收的参数则会报错。类型不一致时也会报错。当参数输入数量不够时，换行时会继续等待输入。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		name   <span class="type">string</span></span><br><span class="line">		age    <span class="type">int64</span></span><br><span class="line">		isBody <span class="type">bool</span></span><br><span class="line">	)</span><br><span class="line">	_, err := fmt.Scan(&amp;name, &amp;age, &amp;isBody)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err.Error())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;name:%s age: %d isBody:%t&quot;</span>, name, age, isBody)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//启动后，依次输入：张三 22 true</span></span><br><span class="line"><span class="comment">// 输出: name:张三 age: 22 isBody:true</span></span><br></pre></td></tr></table></figure>

<p><code>Scanf</code><br>接收终端输入,按照format参数指定的格式接收参数.当参数输入数量不够时，换行时会直接输出.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		name   <span class="type">string</span></span><br><span class="line">		age    <span class="type">int</span></span><br><span class="line">		isBody <span class="type">bool</span></span><br><span class="line">	)</span><br><span class="line">	_, err := fmt.Scanf(<span class="string">&quot;a:%s b:%d c:%t&quot;</span>, &amp;name, &amp;age, &amp;isBody)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;name:%s age:%d isBody:%t&quot;</span>, name, age, isBody)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当输入-&gt; 张三 23 true 报错: input does not match format </span></span><br><span class="line"><span class="comment">当输入-&gt; a:张三 b:23 c:true 输出: name:张三 age:23 isBody:true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><code>Scanln</code><br>Scanln类似Scan，它在遇到换行时才停止扫描。最后一个数据后面必须有换行或者到达结束位置。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		name   <span class="type">string</span></span><br><span class="line">		age    <span class="type">int64</span></span><br><span class="line">		isBody <span class="type">bool</span></span><br><span class="line">	)</span><br><span class="line">	_, err := fmt.Scanln(&amp;name, &amp;age, &amp;isBody)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;name:%s age: %d isBody:%t&quot;</span>, name, age, isBody)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当输入-&gt; 张三 23  报错: unexpected newline</span></span><br><span class="line"><span class="comment">当输入-&gt; 李四 74 true 输出: name:李四 age: 74 isBody:true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>time包使用</title>
    <url>/2021/04/23/time%E5%8C%85%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="获取时间"><a href="#获取时间" class="headerlink" title="获取时间"></a>获取时间</h2><h3 id="当前时间"><a href="#当前时间" class="headerlink" title="当前时间"></a>当前时间</h3><p>语法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Now() Time </span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>使用示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">unix := time.Now().Unix()</span><br><span class="line">fmt.Printf(<span class="string">&quot;当前时间戳(单位秒): %v \n&quot;</span>,unix)</span><br><span class="line">nano := time.Now().UnixNano()</span><br><span class="line">fmt.Printf(<span class="string">&quot;当前时间戳(单位纳秒): %v\n&quot;</span>,nano)</span><br><span class="line">format := time.Now().Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;当前时间(Y-m-d H:i:s): %v\n&quot;</span>,format)</span><br><span class="line">format2 := time.Now().Format(<span class="string">&quot;20060102150405&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;当前时间(YmdHis): %v\n&quot;</span>,format2)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">当前时间戳(单位秒): 1616251448 </span></span><br><span class="line"><span class="comment">当前时间戳(单位纳秒): 1616251448041163000</span></span><br><span class="line"><span class="comment">当前时间(Y-m-d H:i:s): 2021-03-20 22:44:08</span></span><br><span class="line"><span class="comment">当前时间(YmdHis): 20210320224408</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="当前年、月、日、时、分、秒、星期几"><a href="#当前年、月、日、时、分、秒、星期几" class="headerlink" title="当前年、月、日、时、分、秒、星期几"></a>当前年、月、日、时、分、秒、星期几</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">format := time.Now().Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;当前时间(Y-m-d H:i:s): %v\n&quot;</span>,format)</span><br><span class="line">fmt.Printf(<span class="string">&quot;当前年: %v\n&quot;</span>, time.Now().Year())</span><br><span class="line">fmt.Printf(<span class="string">&quot;当前月: %v\n&quot;</span>, time.Now().Month())</span><br><span class="line">fmt.Printf(<span class="string">&quot;当前日: %v\n&quot;</span>, time.Now().Day())</span><br><span class="line">fmt.Printf(<span class="string">&quot;当前小时: %v\n&quot;</span>, time.Now().Hour())</span><br><span class="line">fmt.Printf(<span class="string">&quot;当前分钟: %v\n&quot;</span>, time.Now().Minute())</span><br><span class="line">fmt.Printf(<span class="string">&quot;当前秒: %v\n&quot;</span>, time.Now().Second())</span><br><span class="line">fmt.Printf(<span class="string">&quot;当前星期几: %v\n&quot;</span>, time.Now().Weekday())</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">当前时间(Y-m-d H:i:s): 2021-03-21 17:32:24</span></span><br><span class="line"><span class="comment">当前年: 2021</span></span><br><span class="line"><span class="comment">当前月: March</span></span><br><span class="line"><span class="comment">当前日: 21</span></span><br><span class="line"><span class="comment">当前小时: 17</span></span><br><span class="line"><span class="comment">当前分钟: 32</span></span><br><span class="line"><span class="comment">当前秒: 24</span></span><br><span class="line"><span class="comment">当前星期几: Sunday</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="获取时分秒"><a href="#获取时分秒" class="headerlink" title="获取时分秒"></a>获取时分秒</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">hour, min, sec := now.Clock()</span><br><span class="line">fmt.Printf(<span class="string">&quot;时间:%v   hour: %v min:%v sec:%v \n&quot;</span>,now,hour,min,sec)</span><br><span class="line"><span class="comment">//时间:2021-03-22 23:18:43.245006 +0800 CST m=+0.000108086   hour: 23 min:18 sec:43</span></span><br></pre></td></tr></table></figure>
<h3 id="创建指定时间"><a href="#创建指定时间" class="headerlink" title="创建指定时间"></a>创建指定时间</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">date := time.Date(<span class="number">2020</span>,<span class="number">8</span>,<span class="number">23</span>,<span class="number">13</span>,<span class="number">53</span>,<span class="number">32</span>,<span class="number">0</span>,time.Local)</span><br><span class="line">fmt.Printf(<span class="string">&quot;类型: %T , %v &quot;</span>,date,date)</span><br><span class="line"><span class="comment">// 输出:类型: time.Time , 2020-08-23 13:53:32 +0800 CST </span></span><br></pre></td></tr></table></figure>
<h3 id="获取所属第几周"><a href="#获取所属第几周" class="headerlink" title="获取所属第几周"></a>获取所属第几周</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前时间是，今年的第几周</span></span><br><span class="line">week, w := time.Now().ISOWeek()</span><br><span class="line">fmt.Printf(<span class="string">&quot;year: %v w:%v \n&quot;</span>,week,w)</span><br><span class="line"><span class="comment">// year: 2021 w:12 </span></span><br></pre></td></tr></table></figure>
<h3 id="获取x年的第几天"><a href="#获取x年的第几天" class="headerlink" title="获取x年的第几天"></a>获取x年的第几天</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">num := time.Now().YearDay()</span><br><span class="line">fmt.Printf(<span class="string">&quot;今天是今年的第 %v 天 \n&quot;</span>,num)</span><br><span class="line"><span class="comment">// 今天是今年的第 81 天 </span></span><br></pre></td></tr></table></figure>
<h2 id="字符串转时间"><a href="#字符串转时间" class="headerlink" title="字符串转时间"></a>字符串转时间</h2><h3 id="字符串转时间类型"><a href="#字符串转时间类型" class="headerlink" title="字符串转时间类型"></a>字符串转时间类型</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str := <span class="string">&quot;1616319808&quot;</span></span><br><span class="line">unix, _ := strconv.ParseInt(str,<span class="number">10</span>,<span class="number">64</span>)</span><br><span class="line">format := time.Unix(unix, <span class="number">0</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;字符串时间戳-&gt; 类型:%T 值:%v \n&quot;</span>,format,format)</span><br><span class="line"><span class="comment">// 字符串时间,</span></span><br><span class="line">strDate := <span class="string">&quot;2019-04-10 12:54:03&quot;</span></span><br><span class="line"><span class="comment">// 注意layout格式需要和字符串时间格式一致</span></span><br><span class="line">location, _ := time.Parse(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>, strDate)</span><br><span class="line">fmt.Printf(<span class="string">&quot;字符串时间-&gt; 类型:%T 值:%v \n&quot;</span>,location,location)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">字符串时间戳-&gt; 类型:time.Time 值:2021-03-21 17:43:28 +0800 CST </span></span><br><span class="line"><span class="comment">字符串时间-&gt; 类型:time.Time 值:2019-04-10 12:54:03 +0000 UTC </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="格式化时间"><a href="#格式化时间" class="headerlink" title="格式化时间"></a>格式化时间</h3><p>Format根据layout指定的格式返回t代表的时间点的格式化文本表示；Format中内置了几个固定的layout常量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	ANSIC       = <span class="string">&quot;Mon Jan _2 15:04:05 2006&quot;</span></span><br><span class="line">	UnixDate    = <span class="string">&quot;Mon Jan _2 15:04:05 MST 2006&quot;</span></span><br><span class="line">	RubyDate    = <span class="string">&quot;Mon Jan 02 15:04:05 -0700 2006&quot;</span></span><br><span class="line">	RFC822      = <span class="string">&quot;02 Jan 06 15:04 MST&quot;</span></span><br><span class="line">	RFC822Z     = <span class="string">&quot;02 Jan 06 15:04 -0700&quot;</span> <span class="comment">// RFC822 with numeric zone</span></span><br><span class="line">	RFC850      = <span class="string">&quot;Monday, 02-Jan-06 15:04:05 MST&quot;</span></span><br><span class="line">	RFC1123     = <span class="string">&quot;Mon, 02 Jan 2006 15:04:05 MST&quot;</span></span><br><span class="line">	RFC1123Z    = <span class="string">&quot;Mon, 02 Jan 2006 15:04:05 -0700&quot;</span> <span class="comment">// RFC1123 with numeric zone</span></span><br><span class="line">	RFC3339     = <span class="string">&quot;2006-01-02T15:04:05Z07:00&quot;</span></span><br><span class="line">	RFC3339Nano = <span class="string">&quot;2006-01-02T15:04:05.999999999Z07:00&quot;</span></span><br><span class="line">	Kitchen     = <span class="string">&quot;3:04PM&quot;</span></span><br><span class="line">	<span class="comment">// Handy time stamps.</span></span><br><span class="line">	Stamp      = <span class="string">&quot;Jan _2 15:04:05&quot;</span></span><br><span class="line">	StampMilli = <span class="string">&quot;Jan _2 15:04:05.000&quot;</span></span><br><span class="line">	StampMicro = <span class="string">&quot;Jan _2 15:04:05.000000&quot;</span></span><br><span class="line">	StampNano  = <span class="string">&quot;Jan _2 15:04:05.000000000&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将字符时间: 2020-09-12 14:34:10 转成 20200912143410</span></span><br><span class="line">strDate := <span class="string">&quot;2020-09-12 14:34:10&quot;</span></span><br><span class="line"><span class="comment">// 1.先转成时间类型</span></span><br><span class="line">location, _ := time.ParseInLocation(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>, strDate, time.Local)</span><br><span class="line"><span class="comment">// 2.再格式化</span></span><br><span class="line">format := location.Format(<span class="string">&quot;20060102150405&quot;</span>)</span><br><span class="line">fmt.Println(format)</span><br><span class="line"><span class="comment">// 输出:20200912143410</span></span><br></pre></td></tr></table></figure>

<h2 id="时间比较"><a href="#时间比较" class="headerlink" title="时间比较"></a>时间比较</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strDate := <span class="string">&quot;2020-09-12 12:00:00&quot;</span></span><br><span class="line">strDate2 := <span class="string">&quot;2020-09-12 12:00:00&quot;</span></span><br><span class="line"><span class="comment">// 1.先转成时间类型</span></span><br><span class="line">time1, _ := time.ParseInLocation(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>, strDate, time.Local)</span><br><span class="line">time2, _ := time.ParseInLocation(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>, strDate2, time.Local)</span><br><span class="line"><span class="comment">// 2.比较 strDate2 &gt; strDate ?</span></span><br><span class="line">before := time1.Before(time2)</span><br><span class="line">fmt.Printf(<span class="string">&quot;strDate2 &gt; strDate ? %t \n&quot;</span>,before)</span><br><span class="line"><span class="comment">// 3.比较 strDate2 = strDate ?</span></span><br><span class="line">equal := time1.Equal(time2)</span><br><span class="line">fmt.Printf(<span class="string">&quot;strDate2 = strDate ? %t \n&quot;</span>,equal)</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">strDate2 &gt; strDate ? false </span></span><br><span class="line"><span class="comment">strDate2 = strDate ? true </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="时间计算"><a href="#时间计算" class="headerlink" title="时间计算"></a>时间计算</h2><p>时间相加</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">fmt.Printf(<span class="string">&quot;现在的时间: %v \n&quot;</span>,now)</span><br><span class="line"><span class="comment">// 十分钟前</span></span><br><span class="line">duration, _ := time.ParseDuration(<span class="string">&quot;-10m&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;十分钟前: %v \n&quot;</span>, now.Add(duration))</span><br><span class="line"><span class="comment">// 一小时前</span></span><br><span class="line">duration2, _ := time.ParseDuration(<span class="string">&quot;-1h&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;一小时前: %v \n&quot;</span>, now.Add(duration2))</span><br><span class="line"><span class="comment">// 一天后</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;一天后: %v \n&quot;</span>, now.AddDate(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line">fmt.Printf(<span class="string">&quot;一月后: %v \n&quot;</span>, now.AddDate(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line">fmt.Printf(<span class="string">&quot;一年后: %v \n&quot;</span>, now.AddDate(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">现在的时间: 2021-03-22 22:54:16.008615 +0800 CST m=+0.000092572 </span></span><br><span class="line"><span class="comment">十分钟前: 2021-03-22 22:44:16.008615 +0800 CST m=-599.999907428 </span></span><br><span class="line"><span class="comment">一小时前: 2021-03-22 21:54:16.008615 +0800 CST m=-3599.999907428 </span></span><br><span class="line"><span class="comment">一天后: 2021-03-23 22:54:16.008615 +0800 CST </span></span><br><span class="line"><span class="comment">一月后: 2021-04-22 22:54:16.008615 +0800 CST </span></span><br><span class="line"><span class="comment">一年后: 2022-03-22 22:54:16.008615 +0800 CST </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>时间相减</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">day1, _ := time.ParseInLocation(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>, <span class="string">&quot;2020-11-02 12:00:00&quot;</span>, time.Local)</span><br><span class="line">day2, _ := time.ParseInLocation(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>, <span class="string">&quot;2020-11-02 15:00:00&quot;</span>, time.Local)</span><br><span class="line">fmt.Printf(<span class="string">&quot;相差几秒: %v \n&quot;</span>,day2.Sub(day1).Seconds())</span><br><span class="line">fmt.Printf(<span class="string">&quot;相差多少分钟: %v \n&quot;</span>,day2.Sub(day1).Minutes())</span><br><span class="line">fmt.Printf(<span class="string">&quot;相差多少小时: %v \n&quot;</span>,day2.Sub(day1).Hours())</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">相差几秒: 10800 </span></span><br><span class="line"><span class="comment">相差多少分钟: 180 </span></span><br><span class="line"><span class="comment">相差多少小时: 3 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p><code>NewTicker</code>返回一个新的Ticker，该Ticker包含一个通道字段，并会每隔时间段d就向该通道发送当时的时间。<br>它会调整时间间隔或者丢弃tick信息以适应反应慢的接收者。如果d&lt;=0会panic。关闭该Ticker可以释放相关资源。</p>
<p>使用示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建定时器，间隔设置每秒</span></span><br><span class="line">	ticker := time.NewTicker(time.Second)</span><br><span class="line">	<span class="comment">// 启动一个协程，打印定时器里面的时间</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ticker *time.Ticker)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">			fmt.Println(&lt;-ticker.C)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 关闭定时器</span></span><br><span class="line">		ticker.Stop()</span><br><span class="line">	&#125;(ticker)</span><br><span class="line">	<span class="comment">// 手动阻塞</span></span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">2021-03-30 11:33:23.704677 +0800 CST m=+1.003656575</span></span><br><span class="line"><span class="comment">2021-03-30 11:33:24.704695 +0800 CST m=+2.003675713</span></span><br><span class="line"><span class="comment">2021-03-30 11:33:25.704271 +0800 CST m=+3.003275554</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><code>Tick</code>是NewTicker的封装，只提供对Ticker通道的访问。如果不需要关闭Ticker，本函数就很方便。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建定时器，间隔设置每秒</span></span><br><span class="line">	chTime := time.Tick(time.Second)</span><br><span class="line">	<span class="comment">// 启动一个协程，打印定时器里面的时间</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ch &lt;- <span class="keyword">chan</span> time.Time)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">			fmt.Println(&lt;-ch)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(chTime)</span><br><span class="line">	<span class="comment">// 手动阻塞</span></span><br><span class="line">	time.Sleep(<span class="number">4</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h2><p><code>NewTimer</code>创建一个Timer，它会在指定时间后，向其自身的C字段发送当时的时间。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;开始时间: %v \n&quot;</span>,time.Now())</span><br><span class="line">	timer := time.NewTimer(time.Second * <span class="number">3</span>)</span><br><span class="line">	<span class="comment">// 此处会阻塞，直到timer.C中有数据写入</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;timer通道里的时间: %v \n&quot;</span>, &lt;- timer.C)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">开始时间: 2021-03-30 14:27:04.966887 +0800 CST m=+0.001502710 </span></span><br><span class="line"><span class="comment">timer通道里的时间: 2021-03-30 14:27:07.970134 +0800 CST m=+3.004701898 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><code>After()</code>函数相当于NewTimer(d).C,如下源码:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">After</span><span class="params">(d Duration)</span></span> &lt;-<span class="keyword">chan</span> Time &#123;</span><br><span class="line">	<span class="keyword">return</span> NewTimer(d).C</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个计时器,返回的是chan</span></span><br><span class="line">	ch := time.After(<span class="number">5</span> * time.Second)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;开始时间 %v \n&quot;</span>,time.Now())</span><br><span class="line">	<span class="comment">// 此处会阻塞5秒</span></span><br><span class="line">	out := &lt;- ch</span><br><span class="line">	fmt.Printf(<span class="string">&quot;变量out-&gt;  类型: %T 值:%v  \n&quot;</span>,out,out)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 输出</span></span><br><span class="line"><span class="comment">  开始时间 2020-12-10 11:01:07.272154 +0800 CST m=+0.000153152 </span></span><br><span class="line"><span class="comment">  变量out-&gt;  类型: time.Time 值:2020-12-10 11:01:12.273034 +0800 CST m=+5.000956630  </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>strconv包使用</title>
    <url>/2021/04/22/strconv%E5%8C%85%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="转换成数字类型（Parse类函数）"><a href="#转换成数字类型（Parse类函数）" class="headerlink" title="转换成数字类型（Parse类函数）"></a>转换成数字类型（Parse类函数）</h2><h3 id="转换成整型-Atoi"><a href="#转换成整型-Atoi" class="headerlink" title="转换成整型(Atoi)"></a>转换成整型(Atoi)</h3><p>语法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Atoi</span><span class="params">(s <span class="type">string</span>)</span></span> (<span class="type">int</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 将字符串转成整型</span></span><br><span class="line">	s := <span class="string">&quot;666&quot;</span></span><br><span class="line">	sInt, err := strconv.Atoi(s)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;将字符串:%s 转成整型:%d 类型: %T \n&quot;</span>, s, sInt, sInt)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将字符串:666 转成整型:666 类型: int</span></span><br></pre></td></tr></table></figure>

<h3 id="解析成整型-ParseInt"><a href="#解析成整型-ParseInt" class="headerlink" title="解析成整型(ParseInt)"></a>解析成整型(ParseInt)</h3><p>语法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseInt</span><span class="params">(s <span class="type">string</span>, base <span class="type">int</span>, bitSize <span class="type">int</span>)</span></span> (i <span class="type">int64</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p><code>base</code>:表示进制(2到36)。如果base=0,则根据字符串前缀判断,0x:表示十六进制、0:表示八进制、其他代表十进制。<br><code>bitSize</code>: 指定结果必须是不会溢出的整数类型，其值0、8、16、32、64 分别代表int、int8、int16、int32、int64</p>
<p>使用示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 将字符串转成int</span></span><br><span class="line">	s := <span class="string">&quot;666&quot;</span></span><br><span class="line">	i,err := strconv.ParseInt(s,<span class="number">10</span>,<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;类型转换失败&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;字符串%s转成int,%d 类型:%T \n&quot;</span>, s,i,i)</span><br><span class="line">  <span class="comment">// 这里会报错: 将字符串转成int8 int8的范围(-128~127)</span></span><br><span class="line">	ii,err := strconv.ParseInt(s,<span class="number">10</span>,<span class="number">8</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;类型转换int8失败,值溢出&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;字符串%s转成int,%d 类型:%T &quot;</span>, s,ii,ii)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">字符串666转成int,666 类型:int64 </span></span><br><span class="line"><span class="comment">panic: 类型转换int8失败,值溢出</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">goroutine 1 [running]:</span></span><br><span class="line"><span class="comment">main.main()</span></span><br><span class="line"><span class="comment">        /Users/hui/Project/Go/src/go-basic/main.go:20 +0x2dd</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><code>ParseUint</code>与<code>ParseInt</code>类似，但是只用于无符号数字</p>
<h3 id="解析成浮点型-ParseFloat"><a href="#解析成浮点型-ParseFloat" class="headerlink" title="解析成浮点型(ParseFloat)"></a>解析成浮点型(ParseFloat)</h3><p>语法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseFloat</span><span class="params">(s <span class="type">string</span>, bitSize <span class="type">int</span>)</span></span> (<span class="type">float64</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p>将一个字符串s解析成浮点数返回。如果字符串s符合语法规则，会返回一个最为接近s值的浮点数。精度由bitSize指定，其值32表示float32、64表示float32。</p>
<p>使用示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 将字符串转成int</span></span><br><span class="line">	s := <span class="string">&quot;666&quot;</span></span><br><span class="line">	i,err := strconv.ParseFloat(s,<span class="number">32</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;类型转换失败&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;字符串%s转成float,%f 类型:%T \n&quot;</span>, s,i,i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:字符串666转成float,666.000000 类型:float64 </span></span><br></pre></td></tr></table></figure>

<h3 id="解析成布尔型-ParseBool"><a href="#解析成布尔型-ParseBool" class="headerlink" title="解析成布尔型(ParseBool)"></a>解析成布尔型(ParseBool)</h3><p>语法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseBool</span><span class="params">(str <span class="type">string</span>)</span></span> (<span class="type">bool</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p>返回字符串表示的布尔值。其值如果是:1,t,T,True,TRUE,true,0,f,F,FALSE,false,F</p>
<table>
    <tr>
        <th>str值</th><th>返回结果</th>
    </tr>
    <tr>
        <td>1,t,T,True,TRUE,true</td><td>true</td>
    </tr>
    <tr>
        <td>0,f,F,FALSE,false,F</td><td>false</td>
    </tr>
    <tr>
        <td>其他值</td><td>false</td>
    </tr>
</table>

<p>使用示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	strSlice := []<span class="type">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;1&quot;</span>,<span class="string">&quot;t&quot;</span>,<span class="string">&quot;T&quot;</span>,<span class="string">&quot;True&quot;</span>,<span class="string">&quot;TRUE&quot;</span>,<span class="string">&quot;true&quot;</span>, <span class="comment">// 都为true</span></span><br><span class="line">		<span class="string">&quot;0&quot;</span>,<span class="string">&quot;f&quot;</span>,<span class="string">&quot;F&quot;</span>,<span class="string">&quot;False&quot;</span>,<span class="string">&quot;FALSE&quot;</span>,<span class="string">&quot;false&quot;</span>, <span class="comment">// 都为false</span></span><br><span class="line">		<span class="string">&quot;9&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;你&quot;</span>,<span class="string">&quot;+&quot;</span>,<span class="comment">// 其他值都是false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _,v :=  <span class="keyword">range</span> strSlice &#123;</span><br><span class="line">		b,_ := strconv.ParseBool(v)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;当x = %s,返回: %t\n&quot;</span>, v,b)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 输出</span></span><br><span class="line"><span class="comment">当x = 1,返回: true</span></span><br><span class="line"><span class="comment">当x = t,返回: true</span></span><br><span class="line"><span class="comment">当x = T,返回: true</span></span><br><span class="line"><span class="comment">当x = True,返回: true</span></span><br><span class="line"><span class="comment">当x = TRUE,返回: true</span></span><br><span class="line"><span class="comment">当x = true,返回: true</span></span><br><span class="line"><span class="comment">当x = 0,返回: false</span></span><br><span class="line"><span class="comment">当x = f,返回: false</span></span><br><span class="line"><span class="comment">当x = F,返回: false</span></span><br><span class="line"><span class="comment">当x = False,返回: false</span></span><br><span class="line"><span class="comment">当x = FALSE,返回: false</span></span><br><span class="line"><span class="comment">当x = false,返回: false</span></span><br><span class="line"><span class="comment">当x = 9,返回: false</span></span><br><span class="line"><span class="comment">当x = a,返回: false</span></span><br><span class="line"><span class="comment">当x = 你,返回: false</span></span><br><span class="line"><span class="comment">当x = +,返回: false</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="转换成字符串-Format类函数"><a href="#转换成字符串-Format类函数" class="headerlink" title="转换成字符串(Format类函数)"></a>转换成字符串(Format类函数)</h2><p>Format类函数主要的功能是将其他类型格式化成字符串。</p>
<h3 id="int转string-Itoa"><a href="#int转string-Itoa" class="headerlink" title="int转string(Itoa)"></a>int转string(Itoa)</h3><p>Itoa源码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由源码可知，Itoa是FormatInt(int64(i), 10)的缩写。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Itoa</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> FormatInt(<span class="type">int64</span>(i), <span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i :=<span class="number">100</span></span><br><span class="line">	s := strconv.Itoa(i)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;转换结果: 值: %s 类型: %T \n&quot;</span>, s,s)</span><br><span class="line">  <span class="comment">// 输出: 转换结果: 值: 100 类型: string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="int转string-ForamtInt"><a href="#int转string-ForamtInt" class="headerlink" title="int转string(ForamtInt)"></a>int转string(ForamtInt)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回指定基数，i的字符串表示。base取值范围 2 &lt;= base &lt;= 36</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatInt</span><span class="params">(i <span class="type">int64</span>, base <span class="type">int</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure>
<p>使用示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i  <span class="type">int64</span> =<span class="number">123456</span></span><br><span class="line">	s2 := strconv.FormatInt(i,<span class="number">2</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;base=2(二进制) 转换结果: 值: %s 类型: %T \n&quot;</span>, s2,s2)</span><br><span class="line">	s8 := strconv.FormatInt(i,<span class="number">8</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;base=8(八进制) 转换结果: 值: %s 类型: %T \n&quot;</span>, s8,s8)</span><br><span class="line">	s10 := strconv.FormatInt(i,<span class="number">10</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;base=10(十进制) 转换结果: 值: %s 类型: %T \n&quot;</span>, s10,s10)</span><br><span class="line">	s16 := strconv.FormatInt(i,<span class="number">16</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;base=16(十六进制) 转换结果: 值: %s 类型: %T \n&quot;</span>, s16,s16)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">  base=2(二进制) 转换结果: 值: 11110001001000000 类型: string </span></span><br><span class="line"><span class="comment">  base=8(八进制) 转换结果: 值: 361100 类型: string </span></span><br><span class="line"><span class="comment">  base=10(十进制) 转换结果: 值: 123456 类型: string </span></span><br><span class="line"><span class="comment">  base=16(十六进制) 转换结果: 值: 1e240 类型: string </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>ForamtUint和ForamtInt使用方法一样，区别是ForamtUint:无符号，ForamtInt:有符号。</p>
<h3 id="Float转string-ForamtFloat"><a href="#Float转string-ForamtFloat" class="headerlink" title="Float转string(ForamtFloat)"></a>Float转string(ForamtFloat)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatFloat</span><span class="params">(f <span class="type">float64</span>, fmt <span class="type">byte</span>, prec, bitSize <span class="type">int</span>)</span></span> <span class="type">string</span></span><br><span class="line"><span class="comment">// bitSize: 表示f的来源类型（32:float32 64:float64）,会根据此进行舍入</span></span><br><span class="line"><span class="comment">// fmt: 表示格式标记,（b、e、E、f、g、G）;</span></span><br><span class="line">  <span class="comment">// 格式标记：</span></span><br><span class="line">    <span class="comment">// &#x27;b&#x27; (-ddddp±ddd，二进制指数)</span></span><br><span class="line">    <span class="comment">// &#x27;e&#x27; (-d.dddde±dd，十进制指数)</span></span><br><span class="line">    <span class="comment">// &#x27;E&#x27; (-d.ddddE±dd，十进制指数)</span></span><br><span class="line">    <span class="comment">// &#x27;f&#x27; (-ddd.dddd，没有指数)</span></span><br><span class="line">    <span class="comment">// &#x27;g&#x27; (&#x27;e&#x27;:大指数，&#x27;f&#x27;:其它情况)</span></span><br><span class="line">    <span class="comment">// &#x27;G&#x27; (&#x27;E&#x27;:大指数，&#x27;f&#x27;:其它情况)</span></span><br><span class="line">  <span class="comment">// 如果格式标记为 &#x27;e&#x27;，&#x27;E&#x27;和&#x27;f&#x27;，则 prec 表示小数点后的数字位数</span></span><br><span class="line">  <span class="comment">// 如果格式标记为 &#x27;g&#x27;，&#x27;G&#x27;，则 prec 表示总的数字位数（整数部分+小数部分）</span></span><br><span class="line"><span class="comment">// prec：精度</span></span><br></pre></td></tr></table></figure>
<p>使用示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i := <span class="number">30.1237</span></span><br><span class="line">	<span class="comment">// 如果格式标记为 &#x27;e&#x27;，&#x27;E&#x27;和&#x27;f&#x27;，则 prec 表示小数点后的数字位数</span></span><br><span class="line">	s1 := strconv.FormatFloat(i,<span class="string">&#x27;f&#x27;</span>,<span class="number">4</span>,<span class="number">32</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;保留4位小数-&gt; 值: %s 类型: %T \n&quot;</span>, s1,s1)</span><br><span class="line">	<span class="comment">// 如果格式标记为 &#x27;g&#x27;，&#x27;G&#x27;，则 prec 表示总的数字位数（整数部分+小数部分）</span></span><br><span class="line">	s2 := strconv.FormatFloat(i,<span class="string">&#x27;g&#x27;</span>,<span class="number">4</span>,<span class="number">32</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;总长度返回4位-&gt; 值: %s 类型: %T \n&quot;</span>, s2,s2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment"> 保留4位小数-&gt; 值: 30.1237 类型: string </span></span><br><span class="line"><span class="comment"> 总长度返回4位-&gt; 值: 30.12 类型: string </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="转布尔型-FormatBool"><a href="#转布尔型-FormatBool" class="headerlink" title="转布尔型(FormatBool)"></a>转布尔型(FormatBool)</h3><p>使用示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 返回true字符串</span></span><br><span class="line">	s1 := strconv.FormatBool(<span class="literal">true</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;返回true字符串-&gt; 值: %s 类型: %T \n&quot;</span>, s1,s1)</span><br><span class="line">	<span class="comment">// 返回false字符串</span></span><br><span class="line">	s2 := strconv.FormatBool(<span class="literal">false</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;返回false字符串-&gt; 值: %s 类型: %T \n&quot;</span>, s2,s2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出</span></span><br><span class="line"><span class="comment">  返回true字符串-&gt; 值: true 类型: string </span></span><br><span class="line"><span class="comment">  返回false字符串-&gt; 值: false 类型: string </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>strings包使用</title>
    <url>/2021/04/21/strings%E5%8C%85%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h2><blockquote>
<p>strings是Go内置的标准包,主要用于字符串查找、替换、比较等。常用方法如下:</p>
</blockquote>
<span id="more"></span>
<h3 id="方法列表"><a href="#方法列表" class="headerlink" title="方法列表"></a>方法列表</h3><table>
    <tr>
        <th>方法名</th><th>描述</th>
    </tr>
    <tr>
        <td>Count(s, substr string)int</td><td>返回字符串s包含字符串substr的个数</td>
    </tr>
    <tr>
        <td>Contains(s, substr string)bool</td><td>判断字符串s是否包含substr字符串</td>
    </tr>
    <tr>
        <td>ContainsAny(s, chars string)bool</td><td>判断字符串s是否包含chars字符串中的任意一个字符</td>
    </tr>
    <tr>
        <td>ContainsRune(s string, r rune)bool</td><td>判断字符串s是否包含unicode的码值r</td>
    </tr>
    <tr>
        <td>LastIndex(s, substr string)int</td><td>返回字符串s中字符串substr最后一次出现的位置</td>
    </tr>
    <tr>
        <td>IndexByte(s string, c byte)int</td><td>返回字符串s中字符c首次出现的位置</td>
    </tr>
    <tr>
        <td>IndexRune(s string, r rune)int</td><td>返回unicode的码值r在字符串s中首次出现的位置</td>
    </tr>
    <tr>
        <td>IndexAny(s, chars string)int</td><td>返回字符串chars中的任意一个字符unicode码值,
在s中首次出现的位置</td>
    </tr>
    <tr>
        <td>LastIndexAny(s, chars string)int</td><td>返回字符串chars中的任意一个字符unicode码值,
在s中最后一次出现的位置</td>
    </tr>
    <tr>
        <td>LastIndexByte(s string, c byte)int</td><td>返回字符串s中字符c最后一次出现的位置</td>
    </tr>
    <tr>
        <td>HasPrefix(s, prefix string)bool</td><td>判断字符串s是否有前缀prefix</td>
    </tr>
    <tr>
        <td>HasSuffix(s, suffix string)bool</td><td>判断字符串s是否有后缀suffix</td>
    </tr>
    <tr>
        <td>IndexFunc(s string, f func(r rune)bool)int</td><td>返回字符串s中满足函数f(r)==true,
字符首次出现的位置</td>
    </tr>
    <tr>
        <td>LastIndexFunc(s string, f func(r rune)bool)int</td><td>返回字符串s中满足函数f(r)==true ,
字符最后一次出现的位置</td>
    </tr>
</table>

<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">	<span class="string">&quot;unicode&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 返回字符串s包含字符串substr的个数</span></span><br><span class="line">	s := <span class="string">&quot;hello word&quot;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;字符串:%s,o出现数量: %d\n&quot;</span>,s,strings.Count(s,<span class="string">&quot;o&quot;</span>))</span><br><span class="line">	<span class="comment">// 判断字符串s是否包含substr字符串</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;字符串:%s 是否包含%s ? %t \n&quot;</span>,s,<span class="string">&quot;word&quot;</span>,strings.Contains(s,<span class="string">&quot;word&quot;</span>))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;字符串:%s 是否包含%s ? %t \n&quot;</span>,s,<span class="string">&quot;go&quot;</span>,strings.Contains(s,<span class="string">&quot;go&quot;</span>))</span><br><span class="line">	<span class="comment">// 判断字符串s是否包含chars字符串中的任意一个字符</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;字符串:%s 是否包含%s中的任意一个字符 ? %t \n&quot;</span>,s,<span class="string">&quot;go&quot;</span>,strings.ContainsAny(s,<span class="string">&quot;go&quot;</span>))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;字符串:%s 是否包含%s中的任意一个字符 ? %t \n&quot;</span>,s,<span class="string">&quot;gg&quot;</span>,strings.ContainsAny(s,<span class="string">&quot;gg&quot;</span>))</span><br><span class="line">	<span class="comment">// 判断字符串s是否包含unicode的码值r</span></span><br><span class="line">	r := <span class="string">&#x27;w&#x27;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;字符串:%s 是否包含unicode的码值%c? %t \n&quot;</span>,s,r,strings.ContainsRune(s,r))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;字符串:%s 是否包含unicode的码值%d? %t \n&quot;</span>,s,<span class="number">119</span>,strings.ContainsRune(s,<span class="number">119</span>))</span><br><span class="line">	<span class="comment">// 返回字符串s中字符串substr最后一次出现的位置</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;在字符串%s中,字符串%s最后一次出现的位置? %d \n&quot;</span>,s,<span class="string">&quot;o&quot;</span>,strings.LastIndex(s,<span class="string">&quot;o&quot;</span>))</span><br><span class="line">	<span class="comment">// 返回字符串s中字符串substr首次出现的位置</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;在字符串%s中,字符串%s首次出现的位置? %d \n&quot;</span>,s,<span class="string">&quot;o&quot;</span>,strings.Index(s,<span class="string">&quot;o&quot;</span>))</span><br><span class="line">	<span class="comment">// 返回字符串s中字符c首次出现的位置</span></span><br><span class="line">	<span class="keyword">var</span> b <span class="type">byte</span> = <span class="string">&#x27;l&#x27;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;在字符串%s中,字符%c首次出现的位置? %d \n&quot;</span>,s,b,strings.IndexByte(s,b))</span><br><span class="line">	<span class="comment">// 返回字符串s中字符c最后一次出现的位置</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;在字符串%s中,字符%c最后一次出现的位置? %d \n&quot;</span>,s,b,strings.LastIndexByte(s,b))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回unicode的码值r在字符串s中首次出现的位置</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;在字符串%s中,unicode的码值%d(%c)首次出现的位置? %d \n&quot;</span>,s,<span class="number">104</span>,<span class="number">104</span>,strings.IndexRune(s,<span class="number">104</span>))</span><br><span class="line">	<span class="comment">// 返回字符串chars中的任意一个字符unicode码值,在s中首次出现的位置</span></span><br><span class="line">	s3 := <span class="string">&quot;rd&quot;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;返回字符串%s中的任意一个字符unicode码值(%s)首次出现的位置? %d \n&quot;</span>,s,s3,strings.LastIndexAny(s,s3))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断字符串s是否有前缀prefix</span></span><br><span class="line">	a := <span class="string">&quot;VIP001&quot;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;字符串:%s 是否有前缀%s ? %t \n&quot;</span>,a,<span class="string">&quot;vip&quot;</span>,strings.HasPrefix(a,<span class="string">&quot;vip&quot;</span>))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;字符串:%s 是否有前缀%s ? %t \n&quot;</span>,a,<span class="string">&quot;VIP&quot;</span>,strings.HasPrefix(a,<span class="string">&quot;VIP&quot;</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断字符串s是否有后缀suffix</span></span><br><span class="line">	sn := <span class="string">&quot;K011_Mn&quot;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;字符串:%s 是否有后缀%s ? %t \n&quot;</span>,sn,<span class="string">&quot;MN&quot;</span>,strings.HasSuffix(sn,<span class="string">&quot;MN&quot;</span>))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;字符串:%s 是否有后缀%s ? %t \n&quot;</span>,sn,<span class="string">&quot;Mn&quot;</span>,strings.HasSuffix(sn,<span class="string">&quot;Mn&quot;</span>))</span><br><span class="line">	<span class="comment">// 返回字符串s中满足函数f(r)==true,字符首次出现的位置 (判断第一个汉字的位置)</span></span><br><span class="line">	f := <span class="function"><span class="keyword">func</span><span class="params">(c <span class="type">rune</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> unicode.Is(unicode.Han,c)</span><br><span class="line">	&#125;</span><br><span class="line">	s4 := <span class="string">&quot;go!中国人&quot;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;字符串:%s 首次出现汉字的位置%d \n&quot;</span>,s4,strings.IndexFunc(s4,f))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;字符串:%s 最后一次出现汉字的位置%d \n&quot;</span>,s4,strings.LastIndexFunc(s4,f))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 输出</span></span><br><span class="line"><span class="comment">  字符串:hello word,o出现数量: 2</span></span><br><span class="line"><span class="comment">  字符串:hello word 是否包含word ? true </span></span><br><span class="line"><span class="comment">  字符串:hello word 是否包含go ? false </span></span><br><span class="line"><span class="comment">  字符串:hello word 是否包含go中的任意一个字符 ? true </span></span><br><span class="line"><span class="comment">  字符串:hello word 是否包含gg中的任意一个字符 ? false </span></span><br><span class="line"><span class="comment">  字符串:hello word 是否包含unicode的码值w? true </span></span><br><span class="line"><span class="comment">  字符串:hello word 是否包含unicode的码值119? true </span></span><br><span class="line"><span class="comment">  在字符串hello word中,字符串o最后一次出现的位置? 7 </span></span><br><span class="line"><span class="comment">  在字符串hello word中,字符串o首次出现的位置? 4 </span></span><br><span class="line"><span class="comment">  在字符串hello word中,字符l首次出现的位置? 2 </span></span><br><span class="line"><span class="comment">  在字符串hello word中,字符l最后一次出现的位置? 3 </span></span><br><span class="line"><span class="comment">  在字符串hello word中,unicode的码值104(h)首次出现的位置? 0 </span></span><br><span class="line"><span class="comment">  返回字符串hello word中的任意一个字符unicode码值(rd)首次出现的位置? 9 </span></span><br><span class="line"><span class="comment">  字符串:VIP001 是否有前缀vip ? false </span></span><br><span class="line"><span class="comment">  字符串:VIP001 是否有前缀VIP ? true </span></span><br><span class="line"><span class="comment">  字符串:K011_Mn 是否有后缀MN ? false </span></span><br><span class="line"><span class="comment">  字符串:K011_Mn 是否有后缀Mn ? true </span></span><br><span class="line"><span class="comment">  字符串:go!中国人 首次出现汉字的位置3 </span></span><br><span class="line"><span class="comment">  字符串:go!中国人 最后一次出现汉字的位置9 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串分割"><a href="#字符串分割" class="headerlink" title="字符串分割"></a>字符串分割</h2><h3 id="方法列表-1"><a href="#方法列表-1" class="headerlink" title="方法列表"></a>方法列表</h3><table>
    <tr>
        <th>方法名</th><th>描述</th>
    </tr>
    <tr>
        <td>Fields(s string)[]string</td><td>将字符串s以空白字符分割，返回切片</td>
    </tr>
    <tr>
        <td>FieldsFunc(s string, f func(r) bool)[]string</td><td>将字符串s以满足f(r)==true的字符分割，
分割后返回切片</td>
    </tr>
    <tr>
        <td>Split(s,sep string)[]string</td><td>将字符串s以sep作为分割符进行分割，
分割后字符最后去掉sep,返回切片</td>
    </tr>
    <tr>
        <td>SplitAfter(s,sep string)[]string</td><td>将字符串s以sep作为分割符进行分割，
分割后字符最后加上sep,返回切片</td>
    </tr>
    <tr>
        <td>SplitAfterN(s,sep string, n int)[]string</td><td>将字符串s以sep作为分割符进行分割，
分割后字符最后加上sep,n决定分割成切片长度</td>
    </tr>
</table>

<h3 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">	<span class="string">&quot;unicode&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="string">&quot;Go! Go! 中国人!&quot;</span></span><br><span class="line">	<span class="comment">// 将字符串s以空白字符分割，返回切片</span></span><br><span class="line">	slice := strings.Fields(s)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串:【%s】以空白字符分割，返回切片:%v \n&quot;</span>, s, slice)</span><br><span class="line">	<span class="comment">// 将字符串s以满足f(r)==true的字符分割，分割后返回切片。</span></span><br><span class="line">	<span class="comment">// 以特殊符号分割</span></span><br><span class="line">	f := <span class="function"><span class="keyword">func</span><span class="params">(r <span class="type">rune</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="comment">// 不是字母，也不是数字</span></span><br><span class="line">		<span class="keyword">return</span> !unicode.IsLetter(r) &amp;&amp; !unicode.IsNumber(r)</span><br><span class="line">	&#125;</span><br><span class="line">	ss := <span class="string">&quot;张三@19*BeiJing&amp;高中生|男(打球&quot;</span></span><br><span class="line">	slice2 := strings.FieldsFunc(ss, f)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串:【%s】 以满足f(r)==true【不是数字和字母都是分隔符】的字符分割，返回切片:%v \n&quot;</span>, ss, slice2)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将字符串s以sep作为分割符进行分割，分割后字符最后去掉sep</span></span><br><span class="line">	s2 := <span class="string">&quot;@123@张@AB@001&quot;</span></span><br><span class="line">	sep1 := <span class="string">&quot;@&quot;</span></span><br><span class="line">	slic1 := strings.Split(s2, sep1)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串:【%s】以%s进行分割，分割后最后去掉:%s 返回切片: %v 切片长度: %d \n&quot;</span>, s2, sep1, sep1, slic1, <span class="built_in">len</span>(slic1))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将字符串s以sep作为分割符进行分割，分割后字符最后加上sep,返回切片</span></span><br><span class="line">	slic2 := strings.SplitAfter(s2, sep1)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串:【%s】以%s进行分割，分割后最后加上:%s 返回切片: %v 切片长度: %d \n&quot;</span>, s2, sep1, sep1, slic2, <span class="built_in">len</span>(slic2))</span><br><span class="line">	<span class="comment">// 将字符串s以sep作为分割符进行分割，分割后字符最后加上sep,n决定分割成切片长度</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串:【%s】以%s进行分割，指定分割切片长度%d: %v 分割后加上%s \n&quot;</span>, s2, sep1, <span class="number">0</span>, strings.SplitAfterN(s2, sep1, <span class="number">0</span>), sep1)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串:【%s】以%s进行分割，指定分割切片长度%d: %v 分割后加上%s \n&quot;</span>, s2, sep1, <span class="number">1</span>, strings.SplitAfterN(s2, sep1, <span class="number">1</span>), sep1)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串:【%s】以%s进行分割，指定分割切片长度%d: %v 分割后加上%s \n&quot;</span>, s2, sep1, <span class="number">5</span>, strings.SplitAfterN(s2, sep1, <span class="number">5</span>), sep1)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串:【%s】以%s进行分割，指定分割切片长度%d: %v 分割后加上%s \n&quot;</span>, s2, sep1, <span class="number">6</span>, strings.SplitAfterN(s2, sep1, <span class="number">6</span>), sep1)</span><br><span class="line">	<span class="comment">// 将字符串s以sep作为分割符进行分割，分割后字符最后去掉sep,n决定分割成切片长度</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串:【%s】以%s进行分割，指定分割切片长度%d: %v 分割后去掉%s \n&quot;</span>, s2, sep1, <span class="number">1</span>, strings.SplitN(s2, sep1, <span class="number">1</span>), sep1)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串:【%s】以%s进行分割，指定分割切片长度%d: %v 分割后去掉%s \n&quot;</span>, s2, sep1, <span class="number">3</span>, strings.SplitN(s2, sep1, <span class="number">3</span>), sep1)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串:【%s】以%s进行分割，指定分割切片长度%d: %v 分割后去掉%s \n&quot;</span>, s2, sep1, <span class="number">5</span>, strings.SplitN(s2, sep1, <span class="number">5</span>), sep1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 输出</span></span><br><span class="line"><span class="comment">将字符串:【Go! Go! 中国人!】以空白字符分割，返回切片:[Go! Go! 中国人!]</span></span><br><span class="line"><span class="comment">将字符串:【张三@19*BeiJing&amp;高中生|男(打球】 以满足f(r)==true【不是数字和字母都是分隔符】的字符分割，返回切片:[张三 19 BeiJing 高中生 男 打球]</span></span><br><span class="line"><span class="comment">将字符串:【@123@张@AB@001】以@进行分割，分割后最后去掉:@ 返回切片: [ 123 张 AB 001] 切片长度: 5</span></span><br><span class="line"><span class="comment">将字符串:【@123@张@AB@001】以@进行分割，分割后最后加上:@ 返回切片: [@ 123@ 张@ AB@ 001] 切片长度: 5</span></span><br><span class="line"><span class="comment">将字符串:【@123@张@AB@001】以@进行分割，指定分割切片长度0: [] 分割后加上@</span></span><br><span class="line"><span class="comment">将字符串:【@123@张@AB@001】以@进行分割，指定分割切片长度1: [@123@张@AB@001] 分割后加上@</span></span><br><span class="line"><span class="comment">将字符串:【@123@张@AB@001】以@进行分割，指定分割切片长度5: [@ 123@ 张@ AB@ 001] 分割后加上@</span></span><br><span class="line"><span class="comment">将字符串:【@123@张@AB@001】以@进行分割，指定分割切片长度6: [@ 123@ 张@ AB@ 001] 分割后加上@</span></span><br><span class="line"><span class="comment">将字符串:【@123@张@AB@001】以@进行分割，指定分割切片长度1: [@123@张@AB@001] 分割后去掉@</span></span><br><span class="line"><span class="comment">将字符串:【@123@张@AB@001】以@进行分割，指定分割切片长度3: [ 123 张@AB@001] 分割后去掉@</span></span><br><span class="line"><span class="comment">将字符串:【@123@张@AB@001】以@进行分割，指定分割切片长度5: [ 123 张 AB 001] 分割后去掉@</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="大小写切换"><a href="#大小写切换" class="headerlink" title="大小写切换"></a>大小写切换</h2><h3 id="方法列表-2"><a href="#方法列表-2" class="headerlink" title="方法列表"></a>方法列表</h3><table>
    <tr>
        <th>方法名</th><th>描述</th>
    </tr>
    <tr>
        <td>Title(s string)string</td><td>将字符串s每个单词首字母大写</td>
    </tr>
    <tr>
        <td>ToLower(s string)string</td><td>将字符串s转换成小写返回</td>
    </tr>
    <tr>
        <td>ToTitle(s string)string</td><td>将字符串s转换成大写返回</td>
    </tr>
    <tr>
        <td>ToUpper(s string)string</td><td>将字符串s转换成大写返回</td>
    </tr>
</table>

<p>大部分情况下， ToUpper 与 ToTitle 返回值相同，但在处理某些unicode编码字符则不同</p>
<h3 id="使用示例-2"><a href="#使用示例-2" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	str := <span class="string">&quot;hello word&quot;</span></span><br><span class="line">	str1 := <span class="string">&quot;HELLO WORD&quot;</span></span><br><span class="line">	<span class="comment">// Title(s string) string: 每个单词首字母大写</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Title-&gt;将字符串%s 每个单词首字母大写: %s\n&quot;</span>, str, strings.Title(str))</span><br><span class="line">	<span class="comment">// ToLower(s string) string : 将字符串s转换成小写返回</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;ToLower-&gt;将字符串%s 转换成小写返回: %s\n&quot;</span>, str1, strings.ToLower(str1))</span><br><span class="line">	<span class="comment">// ToTitle(s string)string: 将字符串s转换成大写返回</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;ToTitle-&gt;将字符串%s 转换成大写返回: %s\n&quot;</span>, str, strings.ToTitle(str))</span><br><span class="line">	<span class="comment">// ToUpper(s string)string: 将字符串s转换成大写返回</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;ToUpper-&gt;将字符串%s 转换成大写返回: %s\n&quot;</span>, str, strings.ToUpper(str))</span><br><span class="line"></span><br><span class="line">	strr := <span class="string">&quot;ǳ ǵǵǳǳǳ hello world！&quot;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;ToTitle-&gt;将字符串%s 转换成大写返回: %s\n&quot;</span>, strr, strings.ToTitle(strr))</span><br><span class="line">	<span class="comment">// ToUpper(s string)string: 将字符串s转换成大写返回</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;ToUpper-&gt;将字符串%s 转换成大写返回: %s\n&quot;</span>, strr, strings.ToUpper(strr))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">Title-&gt;将字符串hello word 每个单词首字母大写: Hello Word</span></span><br><span class="line"><span class="comment">ToLower-&gt;将字符串HELLO WORD 转换成小写返回: hello word</span></span><br><span class="line"><span class="comment">ToTitle-&gt;将字符串hello word 转换成大写返回: HELLO WORD</span></span><br><span class="line"><span class="comment">ToUpper-&gt;将字符串hello word 转换成大写返回: HELLO WORD</span></span><br><span class="line"><span class="comment">ToTitle-&gt;将字符串ǳ ǵǵǳǳǳ hello world！ 转换成大写返回: ǲ ǴǴǲǲǲ HELLO WORLD！</span></span><br><span class="line"><span class="comment">ToUpper-&gt;将字符串ǳ ǵǵǳǳǳ hello world！ 转换成大写返回: Ǳ ǴǴǱǱǱ HELLO WORLD！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="字符串删除"><a href="#字符串删除" class="headerlink" title="字符串删除"></a>字符串删除</h2><h3 id="方法列表-3"><a href="#方法列表-3" class="headerlink" title="方法列表"></a>方法列表</h3><table>
    <tr>
        <th>方法名</th><th>描述</th>
    </tr>
    <tr>
        <td>Trim(s,cutset string)string</td><td>将字符串s首尾包含在cutset中的任一字符去掉</td>
    </tr>
    <tr>
        <td>TrimFunc(s string,f func(r)bool)string</td><td>将字符串s首尾满足函数f(r)==true的字符串去掉</td>
    </tr>
    <tr>
        <td>TrimLeft(s,cutset string)string</td><td>将字符串s左边包含在cutset中的任一字符去掉</td>
    </tr>
    <tr>
        <td>TrimLeftFunc(s string,f func(r)bool)string</td><td>将字符串s左边满足函数f(r)==true的字符串去掉</td>
    </tr>
    <tr>
        <td>TrimPrefix(s,prefix string)string</td><td>将字符串s中前缀字符串prefix去掉</td>
    </tr>
    <tr>
        <td>TrimRight(s,cutset string)string</td><td>将字符串s右边包含在cutset中的任一字符去掉</td>
    </tr>
    <tr>
        <td>TrimRightFunc(s string, f func(r) bool)string</td><td>将字符串s右边满足函数f(r)==true的字符串去掉</td>
    </tr>
    <tr>
        <td>TrimSpace(s string) string</td><td>将字符串首尾空白去掉</td>
    </tr>
    <tr>
        <td>TrimSuffix(s, suffix string) string</td><td>将字符串s中后缀字符串suffix去掉</td>
    </tr>
</table>


<h3 id="使用示例-3"><a href="#使用示例-3" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 将字符串首尾包含在cutset中的任一字符去掉</span></span><br><span class="line">	str := <span class="string">&quot;@*test@-@124@!*&quot;</span></span><br><span class="line">	cutset := <span class="string">&quot;*#@!&quot;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串【%s】首尾包含在【%s】中的任一字符去掉,返回:【%s】\n&quot;</span>, str, cutset, strings.Trim(str, cutset))</span><br><span class="line">	<span class="comment">// 将字符串首尾满足函数`f(r)==true`的字符串去掉</span></span><br><span class="line">	f := <span class="function"><span class="keyword">func</span><span class="params">(r <span class="type">rune</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> strings.Contains(<span class="string">&quot;*#@!&quot;</span>, <span class="type">string</span>(r)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串【%s】首尾满足函数f的字符去掉,返回:【%s】\n&quot;</span>, str, strings.TrimFunc(str, f))</span><br><span class="line">	<span class="comment">// 将字符串左边包含在cutset中的任一字符去掉</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串【%s】左边包含在【%s】中的任一字符去掉,返回:【%s】\n&quot;</span>, str, cutset, strings.TrimLeft(str, cutset))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将字符串左边满足函数`f(r)==true`的字符串去掉</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串【%s】左边满足函数f的字符去掉,返回:【%s】\n&quot;</span>, str, strings.TrimLeftFunc(str, f))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将字符串右边包含在cutset中的任一字符去掉</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串【%s】右边包含在【%s】中的任一字符去掉,返回:【%s】\n&quot;</span>, str, cutset, strings.TrimRight(str, cutset))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串【%s】右边满足函数f的字符去掉,返回:【%s】\n&quot;</span>, str, strings.TrimRightFunc(str, f))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将字符串中前缀字符串prefix去掉</span></span><br><span class="line">	str1 := <span class="string">&quot;VIP00001_U&quot;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串【%s】前缀【%s】去掉,返回:【%s】\n&quot;</span>, str1, <span class="string">&quot;VIP&quot;</span>, strings.TrimPrefix(str1, <span class="string">&quot;VIP&quot;</span>))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串【%s】前缀【%s】去掉,返回:【%s】\n&quot;</span>, str1, <span class="string">&quot;vip&quot;</span>, strings.TrimPrefix(str1, <span class="string">&quot;vip&quot;</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将字符串中后缀字符串suffix去掉</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串【%s】后缀【%s】去掉,返回:【%s】\n&quot;</span>, str1, <span class="string">&quot;U&quot;</span>, strings.TrimSuffix(str1, <span class="string">&quot;U&quot;</span>))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串【%s】后缀【%s】去掉,返回:【%s】\n&quot;</span>, str1, <span class="string">&quot;u&quot;</span>, strings.TrimSuffix(str1, <span class="string">&quot;u&quot;</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将字符串首尾空白去掉</span></span><br><span class="line">	str2 := <span class="string">&quot;  hello  word !  &quot;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串【%s】首尾空白去掉,返回:【%s】\n&quot;</span>, str2, strings.TrimSpace(str2))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">将字符串【@*test@-@124@!*】首尾包含在【*#@!】中的任一字符去掉,返回:【test@-@124】</span></span><br><span class="line"><span class="comment">将字符串【@*test@-@124@!*】首尾满足函数f的字符去掉,返回:【test@-@124】</span></span><br><span class="line"><span class="comment">将字符串【@*test@-@124@!*】左边包含在【*#@!】中的任一字符去掉,返回:【test@-@124@!*】</span></span><br><span class="line"><span class="comment">将字符串【@*test@-@124@!*】左边满足函数f的字符去掉,返回:【test@-@124@!*】</span></span><br><span class="line"><span class="comment">将字符串【@*test@-@124@!*】右边包含在【*#@!】中的任一字符去掉,返回:【@*test@-@124】</span></span><br><span class="line"><span class="comment">将字符串【@*test@-@124@!*】右边满足函数f的字符去掉,返回:【@*test@-@124】</span></span><br><span class="line"><span class="comment">将字符串【VIP00001_U】前缀【VIP】去掉,返回:【00001_U】</span></span><br><span class="line"><span class="comment">将字符串【VIP00001_U】前缀【vip】去掉,返回:【VIP00001_U】</span></span><br><span class="line"><span class="comment">将字符串【VIP00001_U】后缀【U】去掉,返回:【VIP00001_】</span></span><br><span class="line"><span class="comment">将字符串【VIP00001_U】后缀【u】去掉,返回:【VIP00001_U】</span></span><br><span class="line"><span class="comment">将字符串【  hello  word !  】首尾空白去掉,返回:【hello  word !】</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="字符串删除-1"><a href="#字符串删除-1" class="headerlink" title="字符串删除"></a>字符串删除</h2><h3 id="方法列表-4"><a href="#方法列表-4" class="headerlink" title="方法列表"></a>方法列表</h3><table>
    <tr>
        <th>方法名</th><th>描述</th>
    </tr>
    <tr>
        <td>Join(elems []string, sep string) string</td><td>将字符串切片elems，使用sep进行拼接</td>
    </tr>
    <tr>
        <td>Repeat(s string, count int) string</td><td>将字符串s,重复count次</td>
    </tr>
</table>


<h3 id="使用示例-4"><a href="#使用示例-4" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 字符串拼接</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;字符串拼接:Join-&gt; %s\n&quot;</span>, strings.Join([]<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;, <span class="string">&quot;|&quot;</span>))</span><br><span class="line">	<span class="comment">// 字符串重复</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;字符串重复:Repeat-&gt; %s\n&quot;</span>, strings.Repeat(<span class="string">&quot;Go!&quot;</span>, <span class="number">10</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">字符串拼接:Join-&gt; a|b|c</span></span><br><span class="line"><span class="comment">字符串重复:Repeat-&gt; Go!Go!Go!Go!Go!Go!Go!Go!Go!Go!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h2><h3 id="方法列表-5"><a href="#方法列表-5" class="headerlink" title="方法列表"></a>方法列表</h3><table>
    <tr>
        <th>方法名</th><th>描述</th>
    </tr>
    <tr>
        <td>Replace(s, old, new string, n int)string</td><td>将字符串s前n个不重叠old子串都替换为new的新字符串
如果n小于0会替换所有old子串。</td>
    </tr>
    <tr>
        <td>ReplaceAll(s, old, new string) string</td><td>将字符串s中的old子串全部替换为new的新字符串</td>
    </tr>
</table>

<h3 id="使用示例-5"><a href="#使用示例-5" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 字符串替换,如果n&lt;0会替换所有old子串。</span></span><br><span class="line">	s := <span class="string">&quot;a,b,c,d,e,f&quot;</span></span><br><span class="line">	old := <span class="string">&quot;,&quot;</span></span><br><span class="line">	newStr := <span class="string">&quot;.&quot;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串【%s】中的前%d个【%s】替换为【%s】结果是【%s】\n&quot;</span>, s, <span class="number">2</span>, old, newStr, strings.Replace(s, old, newStr, <span class="number">2</span>))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串【%s】中的前%d个【%s】替换为【%s】结果是【%s】\n&quot;</span>, s, <span class="number">7</span>, old, newStr, strings.Replace(s, old, newStr, <span class="number">7</span>))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串【%s】中的前%d个【%s】替换为【%s】结果是【%s】\n&quot;</span>, s, <span class="number">-1</span>, old, newStr, strings.Replace(s, old, newStr, <span class="number">-1</span>))</span><br><span class="line">	<span class="comment">// 字符串全部替换</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串【%s】中的【%s】全部替换为【%s】结果是【%s】\n&quot;</span>, s, old, newStr, strings.ReplaceAll(s, old, newStr))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">将字符串【a,b,c,d,e,f】中的前2个【,】替换为【.】结果是【a.b.c,d,e,f】</span></span><br><span class="line"><span class="comment">将字符串【a,b,c,d,e,f】中的前7个【,】替换为【.】结果是【a.b.c.d.e.f】</span></span><br><span class="line"><span class="comment">将字符串【a,b,c,d,e,f】中的前-1个【,】替换为【.】结果是【a.b.c.d.e.f】</span></span><br><span class="line"><span class="comment">将字符串【a,b,c,d,e,f】中的【,】全部替换为【.】结果是【a.b.c.d.e.f】</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2><h3 id="方法列表-6"><a href="#方法列表-6" class="headerlink" title="方法列表"></a>方法列表</h3><table>
    <tr>
        <th>方法名</th><th>描述</th>
    </tr>
    <tr>
        <td>Compare(a, b string) int</td><td>按字典顺序比较a和b字符串的大小</td>
    </tr>
    <tr>
        <td>EqualFold(s, t string) bool</td><td>判断s和t两个UTF-8字符串是否相等，忽略大小写</td>
    </tr>
</table>

<h3 id="使用示例-6"><a href="#使用示例-6" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 字符串比较大小</span></span><br><span class="line">	s := <span class="string">&quot;a&quot;</span></span><br><span class="line">	s1 := <span class="string">&quot;c&quot;</span></span><br><span class="line">	s2 := <span class="string">&quot;c&quot;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s &gt; %s 返回 : %d \n&quot;</span>, s, s1, strings.Compare(s, s1))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s &gt; %s 返回 : %d \n&quot;</span>, s1, s, strings.Compare(s1, s))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s &gt; %s 返回 : %d \n&quot;</span>, s1, s2, strings.Compare(s1, s2))</span><br><span class="line">	<span class="comment">// 字符串比较一致性</span></span><br><span class="line">	a := <span class="string">&quot;go&quot;</span></span><br><span class="line">	b := <span class="string">&quot;Go&quot;</span></span><br><span class="line">	c := <span class="string">&quot;go&quot;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s和%s是否相等(忽略大小写)？%t \n&quot;</span>, a, b, strings.EqualFold(a, b))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s和%s是否相等(忽略大小写)？%t \n&quot;</span>, a, c, strings.EqualFold(a, c))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s和%s是否相等(不忽略大小写)？%t \n&quot;</span>, a, b, a == b)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s和%s是否相等(不忽略大小写)？%t \n&quot;</span>, a, c, a == c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">a &gt; c 返回 : -1</span></span><br><span class="line"><span class="comment">c &gt; a 返回 : 1</span></span><br><span class="line"><span class="comment">c &gt; c 返回 : 0</span></span><br><span class="line"><span class="comment">go和Go是否相等(忽略大小写)？true</span></span><br><span class="line"><span class="comment">go和go是否相等(忽略大小写)？true</span></span><br><span class="line"><span class="comment">go和Go是否相等(不忽略大小写)？false</span></span><br><span class="line"><span class="comment">go和go是否相等(不忽略大小写)？true</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go rpc编程</title>
    <url>/2021/04/20/go-rpc%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>Go语言标准包(net/rpc)已经提供了对RPC的支持，而且支持三个级别的RPC：TCP、HTTP和JSONRPC。<br>Go语言的RPC规则：方法只能有两个可序列化的参数，其中第二个参数是指针类型，并且返回一个error类型，同时必须是公开的方法。</p>
</blockquote>
<span id="more"></span>

<h2 id="TCP版"><a href="#TCP版" class="headerlink" title="TCP版"></a>TCP版</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HelloService <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HelloService)</span></span> Say(request <span class="type">string</span>, response *<span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">	format := time.Now().Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>)</span><br><span class="line">	*response = request + <span class="string">&quot; -- &quot;</span> + format</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 注册服务名称</span></span><br><span class="line">	_ = rpc.RegisterName(<span class="string">&quot;HelloService&quot;</span>, <span class="built_in">new</span>(HelloService))</span><br><span class="line">	<span class="comment">// 监听端口</span></span><br><span class="line">	listen, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:1234&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 监听请求</span></span><br><span class="line">		accept, err := listen.Accept()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatalf(<span class="string">&quot;Accept Error: %s&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">go</span> rpc.ServeConn(accept)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>rpc.RegisterName()函数调用会将对象类型中所有满足RPC规则的对象方法注册为RPC函数，所有注册的方法会放在HelloService服务的空间之下。然后建立一个唯一的TCP链接，并且通过rpc.ServeConn()函数在该TCP链接上为对方提供RPC服务。</p>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 建立链接</span></span><br><span class="line">	dial, err := rpc.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:1234&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;Dial error &quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> result <span class="type">string</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="comment">// 发起请求</span></span><br><span class="line">		_ = dial.Call(<span class="string">&quot;HelloService.Say&quot;</span>, <span class="string">&quot;tcp&quot;</span>, &amp;result)</span><br><span class="line">		fmt.Println(<span class="string">&quot;result:&quot;</span>, result)</span><br><span class="line">		time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先是通过rpc.Dial拨号RPC服务，然后通过dial.Call()调用具体的RPC方法。在调用dial.Call()时，第一个参数是用点号链接的RPC服务名字和方法名字，第二个和第三个参数分别是定义RPC方法的两个参数。</p>
<p>执行结果:<br><img src="abe761a72768434e148816ed88e8b7372f5217689b194fb2179daf864f89c5da.png" alt="图 1">  </p>
<h2 id="HTTP版"><a href="#HTTP版" class="headerlink" title="HTTP版"></a>HTTP版</h2><h3 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HelloService <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HelloService)</span></span> Say(request <span class="type">string</span>, response *<span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">	format := time.Now().Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>)</span><br><span class="line">	*response = request + <span class="string">&quot; -- &quot;</span> + format</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	userService := <span class="built_in">new</span>(HelloService)</span><br><span class="line">	<span class="comment">// 注册服务</span></span><br><span class="line">	err := rpc.Register(userService)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	rpc.HandleHTTP()</span><br><span class="line">	err = http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 建立链接</span></span><br><span class="line">	client, err := rpc.DialHTTP(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;err &quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> result <span class="type">string</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="comment">// 发起请求</span></span><br><span class="line">		_ = client.Call(<span class="string">&quot;HelloService.Say&quot;</span>, <span class="string">&quot;http&quot;</span>, &amp;result)</span><br><span class="line">		fmt.Println(<span class="string">&quot;result:&quot;</span>, result)</span><br><span class="line">		time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行结果:<br><img src="89c86ce460cfb840754b438ea1728898f150d0af9144a82884ed5035d13405e7.png" alt="图 2">  </p>
<h2 id="JSON版"><a href="#JSON版" class="headerlink" title="JSON版"></a>JSON版</h2><h3 id="服务端-2"><a href="#服务端-2" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc/jsonrpc&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HelloService <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HelloService)</span></span> Say(request <span class="type">string</span>, response *<span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">	format := time.Now().Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>)</span><br><span class="line">	*response = request + <span class="string">&quot; -- &quot;</span> + format</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 注册服务</span></span><br><span class="line">	err := rpc.RegisterName(<span class="string">&quot;HelloService&quot;</span>, <span class="built_in">new</span>(HelloService))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;rpc RegisterName err &quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 监听端口</span></span><br><span class="line">	listen, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:9090&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Listen err &quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 监听</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		conn, err := listen.Accept()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;conn err &quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 使用json编码</span></span><br><span class="line">		<span class="keyword">go</span> rpc.ServeCodec(jsonrpc.NewServerCodec(conn))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="客户端-2"><a href="#客户端-2" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc/jsonrpc&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 建立链接</span></span><br><span class="line">	conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:9090&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot; rpc.Dial err &quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 使用json编码</span></span><br><span class="line">	client := rpc.NewClientWithCodec(jsonrpc.NewClientCodec(conn))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> result <span class="type">string</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="comment">// 发起请求</span></span><br><span class="line">		_ = client.Call(<span class="string">&quot;HelloService.Say&quot;</span>, <span class="string">&quot;json&quot;</span>, &amp;result)</span><br><span class="line">		fmt.Println(<span class="string">&quot;result:&quot;</span>, result)</span><br><span class="line">		time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行结果:<br><img src="15878f40708d15b8ffaffa1eea1623f012a6bd6127a5f7d3372e80af864f8290.png" alt="图 3">  </p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go grpc使用</title>
    <url>/2021/04/19/go-grpc%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="grpc"><a href="#grpc" class="headerlink" title="grpc"></a>grpc</h2><blockquote>
<p>gRPC 是一个高性能、开源、通用的RPC框架，由Google推出，基于HTTP2协议标准设计开发，默认采用Protocol Buffers数据序列化协议，支持多种开发语言。gRPC提供了一种简单的方法来精确的定义服务，并且为客户端和服务端自动生成可靠的功能库。</p>
</blockquote>
<span id="more"></span>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>最底层为TCP或Unix套接字协议，在此之上是HTTP/2协议的实现，然后在HTTP/2协议之上又构建了针对Go语言的gRPC核心库（gRPC内核+解释器）。应用程序通过gRPC插件生成的Stub代码和gRPC核心库通信，也可以直接和gRPC核心库通信。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装protoc"><a href="#安装protoc" class="headerlink" title="安装protoc"></a>安装protoc</h3><p>ubuntu环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install protobuf-compiler</span><br><span class="line"></span><br><span class="line">root@YBNJ0101:~/go/pkg/mod<span class="comment"># protoc --version</span></span><br><span class="line">libprotoc 3.21.2</span><br></pre></td></tr></table></figure>

<h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><ol>
<li><p>安装插件的目的是为了将protobuf文件，生成Go代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.26</span><br><span class="line">$ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.1</span><br></pre></td></tr></table></figure></li>
<li><p>设置插件环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$PATH</span>:<span class="subst">$(go env GOPATH)</span>/bin&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>验证插件是否成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看protoc-gen-go版本</span></span><br><span class="line">$ protoc-gen-go --version                                      </span><br><span class="line">protoc-gen-go v1.26.0</span><br></pre></td></tr></table></figure></li>
<li><p>查看protoc-gen-go-grpc版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ protoc-gen-go-grpc --version</span><br><span class="line">protoc-gen-go-grpc 1.1.0</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>编写一个使用grpc进行大小写转换的程序，其目录结构如下<br><img src="915fbb210e462a4ea17e54064d50bfa73e4145053783c0162640f559cca79973.png" alt="图 1">  </p>
<h3 id="定义protobuf文件"><a href="#定义protobuf文件" class="headerlink" title="定义protobuf文件"></a>定义protobuf文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line">package proto;</span><br><span class="line"></span><br><span class="line">// 定义go生成后的包名</span><br><span class="line">option go_package = <span class="string">&quot;proto/toupper&quot;</span>;</span><br><span class="line"></span><br><span class="line">// 定义接口</span><br><span class="line">service ToUpper&#123;</span><br><span class="line">  // Sends a greeting</span><br><span class="line">  rpc Upper (UpperRequest) returns (UpperReply) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义入参</span><br><span class="line">message UpperRequest &#123;</span><br><span class="line">  string name = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义返回</span><br><span class="line">message UpperReply &#123;</span><br><span class="line">  string message = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="执行protoc命令"><a href="#执行protoc命令" class="headerlink" title="执行protoc命令"></a>执行protoc命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">protoc --go-grpc_out=. --go_out=. proto/toupper.proto</span><br></pre></td></tr></table></figure>

<h3 id="toupper-pb-go部分代码"><a href="#toupper-pb-go部分代码" class="headerlink" title="toupper.pb.go部分代码"></a>toupper.pb.go部分代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> toupper</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	protoreflect <span class="string">&quot;google.golang.org/protobuf/reflect/protoreflect&quot;</span></span><br><span class="line">	protoimpl <span class="string">&quot;google.golang.org/protobuf/runtime/protoimpl&quot;</span></span><br><span class="line">	reflect <span class="string">&quot;reflect&quot;</span></span><br><span class="line">	sync <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// Verify that this generated code is sufficiently up-to-date.</span></span><br><span class="line">	_ = protoimpl.EnforceVersion(<span class="number">20</span> - protoimpl.MinVersion)</span><br><span class="line">	<span class="comment">// Verify that runtime/protoimpl is sufficiently up-to-date.</span></span><br><span class="line">	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - <span class="number">20</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义入参</span></span><br><span class="line"><span class="keyword">type</span> UpperRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">	state         protoimpl.MessageState</span><br><span class="line">	sizeCache     protoimpl.SizeCache</span><br><span class="line">	unknownFields protoimpl.UnknownFields</span><br><span class="line"></span><br><span class="line">	Name <span class="type">string</span> <span class="string">`protobuf:&quot;bytes,1,opt,name=name,proto3&quot; json:&quot;name,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *UpperRequest)</span></span> GetName() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> x != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> x.Name</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义返回</span></span><br><span class="line"><span class="keyword">type</span> UpperReply <span class="keyword">struct</span> &#123;</span><br><span class="line">	state         protoimpl.MessageState</span><br><span class="line">	sizeCache     protoimpl.SizeCache</span><br><span class="line">	unknownFields protoimpl.UnknownFields</span><br><span class="line"></span><br><span class="line">	Message <span class="type">string</span> <span class="string">`protobuf:&quot;bytes,1,opt,name=message,proto3&quot; json:&quot;message,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *UpperReply)</span></span> GetMessage() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> x != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> x.Message</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="toupper-grpc-pb-go部分代码"><a href="#toupper-grpc-pb-go部分代码" class="headerlink" title="toupper_grpc.pb.go部分代码"></a>toupper_grpc.pb.go部分代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> toupper</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	context <span class="string">&quot;context&quot;</span></span><br><span class="line">	grpc <span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">	codes <span class="string">&quot;google.golang.org/grpc/codes&quot;</span></span><br><span class="line">	status <span class="string">&quot;google.golang.org/grpc/status&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is a compile-time assertion to ensure that this generated file</span></span><br><span class="line"><span class="comment">// is compatible with the grpc package it is being compiled against.</span></span><br><span class="line"><span class="comment">// Requires gRPC-Go v1.32.0 or later.</span></span><br><span class="line"><span class="keyword">const</span> _ = grpc.SupportPackageIsVersion7</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------- 客户端相关代码 --------</span></span><br><span class="line"><span class="comment">// 客户端接口</span></span><br><span class="line"><span class="keyword">type</span> ToUpperClient <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Sends a greeting</span></span><br><span class="line">	Upper(ctx context.Context, in *UpperRequest, opts ...grpc.CallOption) (*UpperReply, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现客户端接口</span></span><br><span class="line"><span class="keyword">type</span> toUpperClient <span class="keyword">struct</span> &#123;</span><br><span class="line">	cc grpc.ClientConnInterface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化客户端</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewToUpperClient</span><span class="params">(cc grpc.ClientConnInterface)</span></span> ToUpperClient &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;toUpperClient&#123;cc&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端调用Upper方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *toUpperClient)</span></span> Upper(ctx context.Context, in *UpperRequest, opts ...grpc.CallOption) (*UpperReply, <span class="type">error</span>) &#123;</span><br><span class="line">	out := <span class="built_in">new</span>(UpperReply)</span><br><span class="line">	err := c.cc.Invoke(ctx, <span class="string">&quot;/proto.ToUpper/Upper&quot;</span>, in, out, opts...)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> out, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------- 服务端相关代码 ------------------</span></span><br><span class="line"><span class="comment">// 定义服务端接口</span></span><br><span class="line"><span class="keyword">type</span> ToUpperServer <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Sends a greeting</span></span><br><span class="line">	Upper(context.Context, *UpperRequest) (*UpperReply, <span class="type">error</span>)</span><br><span class="line">	mustEmbedUnimplementedToUpperServer()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现服务端接口</span></span><br><span class="line"><span class="keyword">type</span> UnimplementedToUpperServer <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现方法，业务代码重写</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(UnimplementedToUpperServer)</span></span> Upper(context.Context, *UpperRequest) (*UpperReply, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, status.Errorf(codes.Unimplemented, <span class="string">&quot;method Upper not implemented&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(UnimplementedToUpperServer)</span></span> mustEmbedUnimplementedToUpperServer() &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterToUpperServer</span><span class="params">(s grpc.ServiceRegistrar, srv ToUpperServer)</span></span> &#123;</span><br><span class="line">	s.RegisterService(&amp;ToUpper_ServiceDesc, srv)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="业务server端代码"><a href="#业务server端代码" class="headerlink" title="业务server端代码"></a>业务server端代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line"></span><br><span class="line">	pb <span class="string">&quot;toupper/proto/toupper&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;golang.org/x/net/context&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc/reflection&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	port = <span class="string">&quot;:50051&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;</span><br><span class="line">	pb.UnimplementedToUpperServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写Upper方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> Upper(ctx context.Context, in *pb.UpperRequest) (*pb.UpperReply, <span class="type">error</span>) &#123;</span><br><span class="line">	log.Printf(<span class="string">&quot;Received: %s&quot;</span>, in.Name)</span><br><span class="line">	<span class="keyword">return</span> &amp;pb.UpperReply&#123;Message: strings.ToUpper(in.Name)&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, port)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;failed to listen: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	s := grpc.NewServer()</span><br><span class="line">	pb.RegisterToUpperServer(s, &amp;server&#123;&#125;)</span><br><span class="line">	<span class="comment">// Register reflection service on gRPC server.</span></span><br><span class="line">	reflection.Register(s)</span><br><span class="line">	<span class="keyword">if</span> err := s.Serve(lis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;failed to serve: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="业务client端代码"><a href="#业务client端代码" class="headerlink" title="业务client端代码"></a>业务client端代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line">	pb <span class="string">&quot;toupper/proto/toupper&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;golang.org/x/net/context&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	address = <span class="string">&quot;localhost:50051&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Set up a connection to the server.</span></span><br><span class="line">	conn, err := grpc.Dial(address, grpc.WithInsecure())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;did not connect: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	c := pb.NewToUpperClient(conn)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Contact the server and print out its response.</span></span><br><span class="line">	name := <span class="string">&quot;hello world&quot;</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &gt; <span class="number">1</span> &#123;</span><br><span class="line">		name = os.Args[<span class="number">1</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	r, err := c.Upper(context.Background(), &amp;pb.UpperRequest&#123;Name: name&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;could not greet: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Printf(<span class="string">&quot;Response: %s&quot;</span>, r.Message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># go mod init toupper</span></span><br><span class="line"><span class="comment"># go mod tidy</span></span><br><span class="line">root@YBNJ0101:/home/rma/mr_work/go_test/toupper<span class="comment"># make </span></span><br><span class="line">protoc --go-grpc_out=. --go_out=. proto/toupper.proto</span><br><span class="line">go build main/client.go</span><br><span class="line">go build main/server.go</span><br></pre></td></tr></table></figure>

<p>运行结果如下<br><img src="fc1fef8e5b134a34d33fbf00c34ab04ea3b77b953852d889f0614fe1a26aa6c1.png" alt="图 2"><br><img src="fecbbc770af2af4ffd88b410cdc82c082773e2998103403068c489aa8f081534.png" alt="图 3">  </p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>包依赖管理</title>
    <url>/2021/04/18/%E5%8C%85%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="失宠的-Vendor-目录"><a href="#失宠的-Vendor-目录" class="headerlink" title="失宠的 Vendor 目录"></a>失宠的 Vendor 目录</h2><blockquote>
<p>Vendor目录是Golang从1.5版本开始引入的，为项目开发提供了一种离线保存第三方依赖包的方法。但是到了Golang 1.11之后，由于引入了Module功能，在运行go build时，优先引用的是Module依赖包的逻辑，所以Vendor目录就被“无视”了，进而可能发生编译错误， moudle 说还是很想他，于是 提供了 go mod vendor 命令用来生成 vendor 目录。这样能避免一些编译问题，依赖可以先从 vendor 目录进行扫描。</p>
</blockquote>
<span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go mod <span class="built_in">help</span> vendor</span><br><span class="line">usage: go mod vendor [-v]</span><br><span class="line"></span><br><span class="line">Vendor resets the main module<span class="string">&#x27;s vendor directory to include all packages needed to build and test all the main module&#x27;</span>s packages.</span><br><span class="line">It does not include <span class="built_in">test</span> code <span class="keyword">for</span> vendored packages.</span><br></pre></td></tr></table></figure>
<p>这句话的意思是： 把 go mod init 后下载的相关依 赖包(Gopath 的 pkg) 目录，拷贝到 vendor 目录。</p>
<h2 id="GOROOT-和-GOPATH"><a href="#GOROOT-和-GOPATH" class="headerlink" title="GOROOT 和 GOPATH"></a>GOROOT 和 GOPATH</h2><p><code>GOROOT</code>： go的安装路径，默认usr/local/go，go自带的包放在/usr/local/go/src底下。<br><code>GOPATH</code>： go mod 是 Golang 1.11 版本引入的依赖包管理工具，替换旧的基于 GOPATH 的依赖包管理方式。GOPATH 不再需要包含 src 子目录，使用 go.mod 方式管理的依赖包都被下载到了 $GOPATH/pkg/mod 目录</p>
<h2 id="包依赖查找顺序"><a href="#包依赖查找顺序" class="headerlink" title="包依赖查找顺序"></a>包依赖查找顺序</h2><ul>
<li>优先使用vendor目录下面的包</li>
<li>搜索$GOPATH/pkg/mod下面的包</li>
<li>搜索$GOROOT/src下面的包</li>
</ul>
<p><strong>注意</strong>：vendor和$GOPATH只能选择其一，不能混用</p>
<h2 id="go-mod"><a href="#go-mod" class="headerlink" title="go mod"></a>go mod</h2><p>有了 go mod 之后，每个项目（源代码目录）就是一个 Module，只要其中包含了 go.mod 文件。go mod 指令和 go.mod 文件用于记录和解析模块之间的依赖性。<br>go.mod 文件一旦创建后，它的内容将会被 go toolchain（工具链）完全掌控，比如：执行 go get、go build、go mod 等指令时，会自动修改和维护 go.mod 文件。<br>除了 go.mod 之外，go 指令还维护了一个 go.sum 文件，其中包含特定模块版本内容的加密哈希。go 指令使用 go.sum 文件来确保这些模块的哈希值，以确保项目所依赖的模块不会出现意外更改。<br>go.mod 和 go.sum 都应该应用于版本控制。 并且 go.sum 不需要手工维护，所以可以不用太关注。</p>
<h2 id="使用go-mod"><a href="#使用go-mod" class="headerlink" title="使用go mod"></a>使用go mod</h2><p>初始化一个 Module：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go mod init &lt;project_name&gt;</span><br></pre></td></tr></table></figure>

<p>删除错误或者不使用的 Modules：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go mod tidy</span><br></pre></td></tr></table></figure>
<p>此时当前工程目录下会生成两个文件go.mod和go.sum<br><img src="4a771fd6162103583ef57364eb268d064690bde30f1b21bfdefa45f3941ca600.png" alt="图 1">  </p>
<p><img src="4d9d0377985f1aed11bd0982191d8a001923891ea66e9d4cb21f27052638f278.png" alt="图 2">  </p>
<h2 id="防止包依赖升级不兼容"><a href="#防止包依赖升级不兼容" class="headerlink" title="防止包依赖升级不兼容"></a>防止包依赖升级不兼容</h2><p>生成 Vendor 目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go mod vendor</span><br></pre></td></tr></table></figure>
<p>此时会将$GOPATH/pkg/mod底下依赖的包拷贝当前工程vendor底下<br><img src="a7f44963848995870bc26d49e4f8bea4a1333c6e47c829a9446536f92c6ef590.png" alt="图 3">  </p>
<p>这样项目包搜索时会优先搜索vendor目录下的包</p>
<p>后续如果引入新的包依赖，则需要再次执行<code>go mod tidy</code><br>由于vendor和$GOPATH只能选择其一，不能混用，所以还需要执行<code>go mod vendor</code></p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go常用包列表</title>
    <url>/2021/04/17/go%E5%B8%B8%E7%94%A8%E5%8C%85%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<p>net yaml glog</p>
<p>go常用包(三十五):高性能的goroutine池[ants]<br>1.介绍ants是一个高性能的 goroutine 池，实现了对大规模 goroutine 的调度管理、goroutine 复用，允许使用者在开发并发程序的时候限制 goroutine 数量，复用资源…</p>
<span id="more"></span>

<p>go常用包(三十四):高性能http客户端fasthttp</p>
<ol>
<li>介绍fasthttp是由valyala编写,并宣称比Go官方标准库net/http快十倍。fasthttp采用了许多性能优化上的最佳实践，尤其是在内存对象的重用上，大量使用sync.Pool以降…</li>
</ol>
<p>go常用包(三十三):高性能json解析器</p>
<ol>
<li>介绍json-iterator是一款快且灵活的JSON解析器,不但100%兼容标准库encoding/json,而且比其更快。虽然官网说比标准包encoding/json快6倍之多，但是随着Go…</li>
</ol>
<p>go常用包(三十二):现代的go工具库go-funk</p>
<ol>
<li>介绍Go-funk 是基于反射(reflect )实现的一个现代Go工具库，封装了对slice/map/struct/string等的操作。2. 下载# 下载go get github.com/…</li>
</ol>
<p>go常用包(三十一):性能调试利器使用(下)</p>
<ol>
<li>trace说明在pprof的分析中，能够知道一段时间内的CPU占用、内存分配、协程堆栈信息。这些信息都是一段时间内数据的汇总，但是它们并没有提供整个周期内发生的事件，例如指定的Goroutine…</li>
</ol>
<p>go常用包(三十):性能调试利器使用(中)</p>
<ol>
<li>调用图说明1.1 示例图1.2 节点颜色红色代表累计值cum为正，并且很大；绿色代表累计值cum为负，并且很大；灰色代表累计值cum可以忽略不计。1.3 节点字体大小较大的字体表示较大的当前值；…</li>
</ol>
<p>go常用包(二十九):性能调试利器使用(上)</p>
<ol>
<li>介绍Go语言中的pprof指对于指标或特征的分析（Profiling），通过分析不仅可以查找到程序中的错误（内存泄漏、race冲突、协程泄漏），也能对程序进行优化（例如CPU利用率不足）。由于G…</li>
</ol>
<p>go常用包(二十八):构建现代cli应用库cobra</p>
<ol>
<li>介绍cobra是一个用来构建现代CLI工具的库。相比flag标准库，它提供更多方便的特性和功能。Cobra 由 Go 项目成员和 hugo 作者 spf13 创建，已经被许多流行的 Go 项目采…</li>
</ol>
<p>go常用包(二十七):定时任务管理库cron<br>1.介绍在Linux中，通过crontab命令使任务在约定的时间执行已经计划好的工作，而Go由于语言的特性，不适合直接使用crontab来管理计划任务，cron (目前 Star8.3k)是一个用Go…</p>
<p>go常用包(二十六):知名爬虫框架colly<br>1.介绍Colly是Golang世界中最知名的Web爬虫框架,它提供简洁的 API，拥有强劲的性能、可以自动处理 cookie&amp;session、提供灵活的扩展机制,同时支持分布式抓取和多种存储…</p>
<p>go常用包(二十五):elasticsearch客户端的实现<br>1.介绍Elasticsearch（ES）是一个基于Lucene构建的开源、分布式、RESTful接口的全文搜索引擎。Elasticsearch还是一个分布式文档数据库，其中每个字段均可被索引，而且每…</p>
<p>go常用包(二十四):单元测试(testinng)</p>
<ol>
<li>介绍testing 包为Go 语言提供自动化测试的支持。通过 go test 命令来执行单元测试文件，单元测试文件命名格式为: xxx_test.go,在单元测试文件中,根据测试类型不同可以分为…</li>
</ol>
<p>go常用包(二十三):操作redis开源库(go-redis)</p>
<ol>
<li>介绍redis官网推荐使用redigo(<a href="https://github.com/gomodule/redigo)%EF%BC%8C%E6%88%AA%E6%AD%A2%E5%88%B0%E4%BB%8A%E5%A4%A9Github">https://github.com/gomodule/redigo)，截止到今天Github</a> Start是8.2k 但go-redis(https://…</li>
</ol>
<p>go常用包(二十二):jwt在golang中的实现(jwt-go)</p>
<ol>
<li>介绍JWT全称JSON Web Token是一种跨域认证解决方案，属于一个开放的标准，它规定了一种Token实现方式，目前多用于前后端分离项目和OAuth2.0业务场景下。jwt-go 是使用G…</li>
</ol>
<p>go常用包(二十一):360开源高性能excel库(excelize)</p>
<ol>
<li>介绍1. 1 什么是ExcelizeExcelize 是 Go 语言编写的用于操作 Office Excel 文档基础库，基于 ECMA-376，ISO/IEC 29500 国际标准。可以使用它…</li>
</ol>
<p>go常用包(二十):数学计算和常数(math)</p>
<ol>
<li>介绍Go标准包math,提供了基本的数学常数和数学函数。2. 常量2.1 整数取值const ( MaxInt8 = 1&lt;&lt;7 - 1 // int8最大值 MinI…</li>
</ol>
<p>gin集成(三):集成全功能orm框架-gorm<br>齐全，对开发者友好，支持主流数据库。具体使用可参考之前的文章go常用包(十九):全功能ORM框架(gorm)1.1 集成流程1.2 涉及目录2. 配置2.1 编辑主配置./config.yamlmysql: host: 127.0.0.1 port: 33…</p>
<p>go常用包(十九):全功能orm框架[gorm]使用</p>
<ol>
<li>介绍gorm是一个使用Go语言编写的ORM框架。 它文档齐全，对开发者友好，支持主流数据库。官方中文文档 <a href="https://gorm.io/zh_CN/docs/index.html2">https://gorm.io/zh_CN/docs/index.html2</a>. 安装go…</li>
</ol>
<p>go常用包(十八):结构体匿名字段的json序列化、反序列化</p>
<ol>
<li>介绍Go的标准包 encoding/json实现了json对象的编码和解码。这篇文章主要讲的是结构体中嵌套匿名字段时的序列化和反序列化，因结构体在参与序列时会有很多细节规则，平时常用的也是结构体…</li>
</ol>
<p>go常用包(十七):crypto之rsa非对称加解密</p>
<ol>
<li>维基百科释义RSA加密算法是一种非对称加密算法，在公开密钥加密和电子商业中被广泛使用。RSA是由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（L…</li>
</ol>
<p>go常用包(十六):crypto之aes加解密<br>1.介绍高级加密标准（英语：Advanced Encryption Standard，缩写：AES），又称Rijndael加密法（荷兰语发音：[ˈrɛindaːl]，音似英文的“Rhine doll”…</p>
<p>go常用包(十五):系统基本操作包使用(os)<br>1.介绍os包中提供了操作系统函数的接口，是一个比较重要的包。它的作用主要是在服务器上进行系统的基本操作，如文件操作、目录操作、执行命令、信号与中断、进程、系统状态等等。下面分模块归纳一些常用函数。2…</p>
<p>go常用包(十二):rune字符操作包(unicode)<br>1.介绍unicode包提供了诸多处理rune字符相关功能的函数（比如区分字母和数字，或者是字母的大写和小写转换等)2.判断函数2.1 是否为空格(IsSpace)func TestJudge(t *…</p>
<p>go常用包(十一):sort排序和查询<br>1.介绍sort包实现了四种基本排序算法：插入排序、归并排序、堆排序、快速排序。 但是这四种排序方法是不公开的，它们只能在 sort 包内部使用。sort 包会根据实际数据自动选择高效的排序算法，所以…</p>
<p>go常用包(九):flag命令行参数解析<br>1.介绍在 Go中，如果要接收命令行参数，需要使用 flag包进行解析。不同的参数类型可以通过不同的方法接收。2.参数接受2.1 接受方式使用flag接收参数，可以由以下三种方式接受：方式一: fla…</p>
<p>go常用包(八):sync辅助并发安全<br>1.介绍sync包提供了互斥锁。除了Once和WaitGroup类型，其余多数适用于低水平的程序，多数情况下，高水平的同步使用channel通信性能会更优一些。2.并发等待组(WaitGroup)Wa…</p>
<p>go常用包(七):context上下文<br>1.什么是上下文?从Go 1.7开始,标准库引入context(上下文)，他主要用来在goroutine之间传递上下文信息(同步信号、超时时间、截止时间、Key-Val值对)。2. 为什么要用上下文?…</p>
<p>go常用包(六):bufio有缓存的io包使用<br>1.介绍bufio包实现了有缓冲的I/O。它包装一个io.Reader或io.Writer接口对象，使用这个包可以大幅提高文件读写的效率。1.如何提高效率?1.写入流程梳理:当写入内容小于缓冲区(bu…</p>
<p>go常用包(五):ioutil包使用<br>1.介绍在Go语言中，io包主要声明的是对I/O操作的基本接口，而io/ioutil包则实现了对应的方法，方便我们直接使用。2.方法列表方法名描述NopCloser对Reader进行封装，返回一个Re…</p>
<p>go常用包(四):fmt包使用<br>1.输出控制台1.1 PrintfPrintf根据format参数生成格式化的字符串并写入标准输出。返回写入的字节数和遇到的任何错误。1.format格式动 词功 能%v 按值的本来值输出%+v在…</p>
<p>go常用包(三):time(时间)包使用<br>1.获取时间1.1 当前时间unix := time.Now().Unix()fmt.Printf(“当前时间戳(单位秒): %v \n”,unix)nano := time.No…</p>
<p>go常用包(二):strconv(字符串转换)包使用<br>1.转换成其他类型（Parse类函数）1.1 转换成整型(Atoi)1.语法func Atoi(s string) (int, error)2.使用示例package mainimport (&amp;quo…</p>
<p>go常用包(一):strings(字符串操作)包使用<br>字符串查找strings是Go内置的标准包,主要用于字符串查找、替换、比较等。</p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go select详解</title>
    <url>/2021/04/16/go-select%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>select是一种go可以处理多个通道之间的机制，看起来和switch语句很相似，但是select其实和IO机制中的select一样，多路复用通道，随机选取一个进行执行，如果说通道(channel)实现了多个goroutine之前的同步或者通信，那么select则实现了多个通道(channel)的同步或者通信，并且select具有阻塞的特性。</p>
</blockquote>
<span id="more"></span>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span> </span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> func1 ()  &#123;</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        ch1 &lt;- <span class="number">1</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> func2 ()  &#123;</span><br><span class="line">        ch2 &lt;- <span class="number">3</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> i := &lt;-ch1:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;从ch1读取了数据%d&quot;</span>, i)</span><br><span class="line">    <span class="keyword">case</span> j := &lt;-ch2:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;从ch2读取了数据%d&quot;</span>, j)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码很简单，我们创建了两个无缓冲的channel，通过两个goroutine向ch1，ch2两个通道发送数据，通过select随机读取ch1，ch2的返回值，但是由于func1有sleep，所以这个例子我们总是从ch2读到结果，打印从ch2读取了数据3<br><img src="46ac4f2ed81a35effa77adda1402be4892bc97d8d9a877c4bc2e8c1ec3a921da.png" alt="图 1">  </p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>select这个特性到底有什么用呢，下面我们来介绍一些使用select的场景</p>
<h3 id="竞争选举"><a href="#竞争选举" class="headerlink" title="竞争选举"></a>竞争选举</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> i := &lt;-ch1:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;从ch1读取了数据%d&quot;</span>, i)</span><br><span class="line"><span class="keyword">case</span> j := &lt;-ch2:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;从ch2读取了数据%d&quot;</span>, j)</span><br><span class="line"><span class="keyword">case</span> m := &lt;-ch3</span><br><span class="line">    fmt.Printf(<span class="string">&quot;从ch3读取了数据%d&quot;</span>, m)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个是最常见的使用场景，多个通道，有一个满足条件可以读取，就可以“竞选成功”</p>
<h3 id="超时处理（保证不阻塞）"><a href="#超时处理（保证不阻塞）" class="headerlink" title="超时处理（保证不阻塞）"></a>超时处理（保证不阻塞）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag.Parse()</span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	time_wait := flag.Arg(<span class="number">0</span>)</span><br><span class="line">	<span class="type">int64</span>, err := strconv.ParseInt(time_wait, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(time.Second * time.Duration(<span class="type">int64</span>))</span><br><span class="line">		ch1 &lt;- <span class="number">1</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> str := &lt;-ch1:</span><br><span class="line">		fmt.Println(<span class="string">&quot;receive str&quot;</span>, str)</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(time.Second * <span class="number">3</span>):</span><br><span class="line">		fmt.Println(<span class="string">&quot;timeout!!&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：<br><img src="d0d3e6659b280473c457134eef984b8e1826932dfd744db2fad60427be2dcc0f.png" alt="图 2">  </p>
<p>因为select是阻塞的，我们有时候就需要搭配超时处理来处理这种情况，超过某一个时间就要进行处理，保证程序不阻塞。</p>
<p>判断buffered channel是否阻塞<br>比如我们有一个有限的资源（这里用buffer channel实现），我们每一秒向bufChan传送数据，由于生产者的生产速度大于消费者的消费速度，故会触发default语句，这个就很像我们web端来显示并发过高的提示了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span> </span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    bufChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span>  &#123;</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            &lt;-bufChan</span><br><span class="line">            time.Sleep(<span class="number">5</span>*time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;() </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> bufChan &lt;- <span class="number">1</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;add success&quot;</span>)</span><br><span class="line">            time.Sleep(time.Second)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;资源已满，请稍后再试&quot;</span>)</span><br><span class="line">            time.Sleep(time.Second)</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：<br><img src="041886cbb4cb63fa48864f3c6ef0755724d0960a572cbcfdfe0350ec4757688d.png" alt="图 3">  </p>
<h3 id="阻塞main函数"><a href="#阻塞main函数" class="headerlink" title="阻塞main函数"></a>阻塞main函数</h3><p>有时候我们会让main函数阻塞不退出，如http服务，我们会使用空的select{}来阻塞main goroutine</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    bufChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span>&#123;</span><br><span class="line">            bufChan &lt;<span class="number">-1</span></span><br><span class="line">            time.Sleep(time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span>&#123;</span><br><span class="line">            fmt.Println(&lt;-bufChan)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">select</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：<br><img src="30e1d7fd42b02ff6ff4d420bef2393f02d4fe420d23ef2c108723ecfc7109d12.png" alt="图 4">  </p>
<p>如上所示，这样主函数就永远阻塞住了，这里要注意上面一定要有一直活动的goroutine,否则会报deadlock。<br>如果这里使用for {}，那么top查看该进程cpu 100%。</p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go打印调用栈信息</title>
    <url>/2021/04/15/go%E6%89%93%E5%8D%B0%E8%B0%83%E7%94%A8%E6%A0%88%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><blockquote>
<p>在日志信息中，有时需要获取当前函数的调用信息，比如打印调用栈<br>debug.Stack() []byte</p>
</blockquote>
<span id="more"></span>

<p><code>debug.Stack()</code>函数可以获取当前 goroutine 的调用栈信息，需要import “runtime/debug”</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;--- BEGIN ---&quot;</span>)</span><br><span class="line">    fmt.Println(string(debug.Stack()))</span><br><span class="line">    fmt.Println(<span class="string">&quot;--- END ---&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">boom</span></span>() &#123;</span><br><span class="line">    foo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    boom()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以获得类似输出结果：<br><img src="0b0adaa3d5e6c9ba15bd2eb91ccefc7f6cf360ac25ac2abb4939c227b5ffd0fe.png" alt="图 1">  </p>
<p>debug.Stack()函数源码在runtime/debug/stack.go中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func Stack() []byte &#123;</span><br><span class="line">    buf := make([]byte, 1024)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        n := runtime.Stack(buf, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">if</span> n &lt; len(buf) &#123;</span><br><span class="line">            <span class="built_in">return</span> buf[:n]</span><br><span class="line">        &#125;</span><br><span class="line">        buf = make([]byte, 2*len(buf))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到它是通过调用runtime.Stack获取的调用栈信息， 其中第二个参数all表示是否获取所有 goroutine 的调用栈。可以将第二个参数改为true然后创建多个 goroutine 查看输出效果。</p>
<h2 id="更可控的调用信息"><a href="#更可控的调用信息" class="headerlink" title="更可控的调用信息"></a>更可控的调用信息</h2><p>上面两个函数虽然可以获取调用栈，但是直接将所有调用信息返回，控制参数较少。</p>
<p>下面几个函数可以实现获取单层的调用信息</p>
<p><code>runtime.Caller</code>函数可以获取调用者的信息</p>
<p>参数<code>skip</code>：表示跳过的层级，相当于往上获取第几层的调用者。0 表示当前函数，1 表示上一层函数，依次往上。</p>
<p>返回值<br><code>pc</code>：program counter（不知道该怎么翻译，程序计数器？），可以大概理解为函数编号，可以通过<code>runtime.FuncForPC</code>解析<br><code>file</code>：文件名<br><code>line</code>：行号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">    pc, file, line, ok := runtime.Caller(1)</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        fmt.Println(runtime.FuncForPC(pc).Name(), file, line)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以得到这样一条输出：<br><img src="65532387773ae03007e8d918d927388d402b6bb9d16e5c8c2d2b816180fb5312.png" alt="图 2">  </p>
<h3 id="runtime-CallersFrames-callers-uintptr-runtime-Frames"><a href="#runtime-CallersFrames-callers-uintptr-runtime-Frames" class="headerlink" title="runtime.CallersFrames(callers []uintptr) *runtime.Frames"></a>runtime.CallersFrames(callers []uintptr) *runtime.Frames</h3><p><code>runtime.CallersFrames</code>可以一次解析多个pc</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">    pc := make([]uintptr, 10)</span><br><span class="line">    n := runtime.Callers(1, pc)</span><br><span class="line">    frames := runtime.CallersFrames(pc[:n])</span><br><span class="line"></span><br><span class="line">    var frame runtime.Frame</span><br><span class="line">    more := n &gt; 0</span><br><span class="line">    <span class="keyword">for</span> more &#123;</span><br><span class="line">        frame, more = frames.Next()</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s %d %s\n&quot;</span>, frame.File, frame.Line, frame.Function)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：<br><img src="4f7ebb587aa9aadeb191b91014112e7dac4e7d89046dcdd2e0f8099af431e5eb.png" alt="图 3">  </p>
<h3 id="func-runtime-FuncForPC-pc-uintptr-runtime-Func"><a href="#func-runtime-FuncForPC-pc-uintptr-runtime-Func" class="headerlink" title="func runtime.FuncForPC(pc uintptr) *runtime.Func"></a>func runtime.FuncForPC(pc uintptr) *runtime.Func</h3><p>前面使用了runtime.FuncForPC来解析pc，获得函数信息。</p>
<p>它返回的*runtime.Func主要有三个方法：<br><code>Entry() uintptr</code>: 返回函数入口地址（函数注释Entry address of the function）<br><code>Name() string</code>: 返回函数名<br><code>FileLine(pc uintptr) (file string, line int)</code>: 返回文件名和行号</p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>lex文件分析</title>
    <url>/2021/04/14/lex%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="lex文件组成"><a href="#lex文件组成" class="headerlink" title="lex文件组成"></a>lex文件组成</h2><blockquote>
<p>lex文件由3段组成，用2个%%行把这3段隔开。<br>定义段 Definition section<br>%%<br>规则段 Rules section<br>%%<br>用户代码段 user code section</p>
</blockquote>
<span id="more"></span>

<h2 id="定义段"><a href="#定义段" class="headerlink" title="定义段"></a>定义段</h2><blockquote>
<p>可以包括：<br>1-C代码，这块可以放C语言的各种各种include，define等声明语句，但是要用%{ %}括起来。这些声明会原样拷到生成的.c文件中。<br>2-状态condition声明，如%x COMMENT。<br>3-正则式定义，如digit ([0-9])。</p>
</blockquote>
<h3 id="定义段（definitions）开始。"><a href="#定义段（definitions）开始。" class="headerlink" title="定义段（definitions）开始。"></a>定义段（definitions）开始。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_GLOB_H</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;glob.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util/config_file.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util/configparser.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ub_c_error</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *message)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEXOUT(s)  printf s <span class="comment">/* used ONLY when debugging */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEXOUT(s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** avoid warning in about fwrite return value */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECHO ub_c_error_msg(<span class="string">&quot;syntax error at text: %s&quot;</span>, yytext)</span></span><br></pre></td></tr></table></figure>

<p>定义了一个YDVAR的宏，该宏用于处理config文件里的变量定义行，例如：<br>server:<br>interface: 192.168.200.83<br>port: 20053<br>access-control: 127.0.0.0/8 allow<br>module-config: “iterator”<br>等类似这样的定义，主要功能是进入val状态（在变量数量大于0的情况下），返回一个token number(return var)。</p>
<p>两个参数，nargs：变量数，var：token值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** A parser variable, this is a statement in the config file which is</span></span><br><span class="line"><span class="comment"> * of the form variable: value1 value2 ...  nargs is the number of values. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YDVAR(nargs, var) \</span></span><br><span class="line"><span class="meta">	num_args=(nargs); \</span></span><br><span class="line"><span class="meta">	LEXOUT((<span class="string">&quot;v(%s%d) &quot;</span>, yytext, num_args)); \</span></span><br><span class="line"><span class="meta">	<span class="keyword">if</span>(num_args &gt; 0) &#123; BEGIN(val); &#125; \</span></span><br><span class="line"><span class="meta">	return (var);</span></span><br></pre></td></tr></table></figure>

<p>定义一个保存include其他文件状态的结构体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inc_state</span> &#123;</span></span><br><span class="line">	<span class="type">char</span>* filename;</span><br><span class="line">	<span class="type">int</span> line;</span><br><span class="line">	YY_BUFFER_STATE buffer;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inc_state</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">inc_state</span>* <span class="title">config_include_stack</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> inc_depth = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> inc_prev = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> num_args = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_cfg_parse</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	config_include_stack = <span class="literal">NULL</span>;</span><br><span class="line">	inc_depth = <span class="number">0</span>;</span><br><span class="line">	inc_prev = <span class="number">0</span>;</span><br><span class="line">	num_args = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为开始处理include文件做准备工作。打开文件，创建一个inc_state的结构，存储相关信息，然后放入config_include_stack堆栈中，调用yy_switch_to_buffer，切换文件输入流。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">config_start_include</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename)</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE *input;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inc_state</span>* <span class="title">s</span>;</span></span><br><span class="line">	<span class="type">char</span>* nm;</span><br><span class="line">	<span class="keyword">if</span>(inc_depth++ &gt; <span class="number">100000</span>) &#123;</span><br><span class="line">		ub_c_error_msg(<span class="string">&quot;too many include files&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(*filename == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		ub_c_error_msg(<span class="string">&quot;empty include file name&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	s = (<span class="keyword">struct</span> inc_state*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*s));</span><br><span class="line">	<span class="keyword">if</span>(!s) &#123;</span><br><span class="line">		ub_c_error_msg(<span class="string">&quot;include %s: malloc failure&quot;</span>, filename);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cfg_parser-&gt;chroot &amp;&amp; <span class="built_in">strncmp</span>(filename, cfg_parser-&gt;chroot,</span><br><span class="line">		<span class="built_in">strlen</span>(cfg_parser-&gt;chroot)) == <span class="number">0</span>) &#123;</span><br><span class="line">		filename += <span class="built_in">strlen</span>(cfg_parser-&gt;chroot);</span><br><span class="line">	&#125;</span><br><span class="line">	nm = strdup(filename);</span><br><span class="line">	<span class="keyword">if</span>(!nm) &#123;</span><br><span class="line">		ub_c_error_msg(<span class="string">&quot;include %s: strdup failure&quot;</span>, filename);</span><br><span class="line">		<span class="built_in">free</span>(s);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	input = fopen(filename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(!input) &#123;</span><br><span class="line">		ub_c_error_msg(<span class="string">&quot;cannot open include file &#x27;%s&#x27;: %s&quot;</span>,</span><br><span class="line">			filename, strerror(errno));</span><br><span class="line">		<span class="built_in">free</span>(s);</span><br><span class="line">		<span class="built_in">free</span>(nm);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LEXOUT((<span class="string">&quot;switch_to_include_file(%s)\n&quot;</span>, filename));</span><br><span class="line">	s-&gt;filename = cfg_parser-&gt;filename;</span><br><span class="line">	s-&gt;line = cfg_parser-&gt;line;</span><br><span class="line">	s-&gt;buffer = YY_CURRENT_BUFFER;</span><br><span class="line">	s-&gt;next = config_include_stack;</span><br><span class="line">	config_include_stack = s;</span><br><span class="line">	cfg_parser-&gt;filename = nm;</span><br><span class="line">	cfg_parser-&gt;line = <span class="number">1</span>;</span><br><span class="line">	yy_switch_to_buffer(yy_create_buffer(input, YY_BUF_SIZE));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">config_start_include_glob</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* check for wildcards */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_GLOB</span></span><br><span class="line">	<span class="type">glob_t</span> g;</span><br><span class="line">	<span class="type">size_t</span> i;</span><br><span class="line">	<span class="type">int</span> r, flags;</span><br><span class="line">	<span class="keyword">if</span>(!(!<span class="built_in">strchr</span>(filename, <span class="string">&#x27;*&#x27;</span>) &amp;&amp; !<span class="built_in">strchr</span>(filename, <span class="string">&#x27;?&#x27;</span>) &amp;&amp; !<span class="built_in">strchr</span>(filename, <span class="string">&#x27;[&#x27;</span>) &amp;&amp;</span><br><span class="line">		!<span class="built_in">strchr</span>(filename, <span class="string">&#x27;&#123;&#x27;</span>) &amp;&amp; !<span class="built_in">strchr</span>(filename, <span class="string">&#x27;~&#x27;</span>))) &#123;</span><br><span class="line">		flags = <span class="number">0</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> GLOB_ERR</span></span><br><span class="line">			| GLOB_ERR</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> GLOB_NOSORT</span></span><br><span class="line">			| GLOB_NOSORT</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> GLOB_BRACE</span></span><br><span class="line">			| GLOB_BRACE</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> GLOB_TILDE</span></span><br><span class="line">			| GLOB_TILDE</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		;</span><br><span class="line">		<span class="built_in">memset</span>(&amp;g, <span class="number">0</span>, <span class="keyword">sizeof</span>(g));</span><br><span class="line">		<span class="keyword">if</span>(cfg_parser-&gt;chroot &amp;&amp; <span class="built_in">strncmp</span>(filename, cfg_parser-&gt;chroot,</span><br><span class="line">			<span class="built_in">strlen</span>(cfg_parser-&gt;chroot)) == <span class="number">0</span>) &#123;</span><br><span class="line">			filename += <span class="built_in">strlen</span>(cfg_parser-&gt;chroot);</span><br><span class="line">		&#125;</span><br><span class="line">		r = glob(filename, flags, <span class="literal">NULL</span>, &amp;g);</span><br><span class="line">		<span class="keyword">if</span>(r) &#123;</span><br><span class="line">			<span class="comment">/* some error */</span></span><br><span class="line">			globfree(&amp;g);</span><br><span class="line">			<span class="keyword">if</span>(r == GLOB_NOMATCH)</span><br><span class="line">				<span class="keyword">return</span>; <span class="comment">/* no matches for pattern */</span></span><br><span class="line">			config_start_include(filename); <span class="comment">/* let original deal with it */</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* process files found, if any */</span></span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;(<span class="type">size_t</span>)g.gl_pathc; i++) &#123;</span><br><span class="line">			config_start_include(g.gl_pathv[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		globfree(&amp;g);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* HAVE_GLOB */</span></span></span><br><span class="line"></span><br><span class="line">	config_start_include(filename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Include文件处理结束，恢复文件处理堆栈，继续上一个文件的处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">config_end_include</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inc_state</span>* <span class="title">s</span> =</span> config_include_stack;</span><br><span class="line">	--inc_depth;</span><br><span class="line">	<span class="keyword">if</span>(!s) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">free</span>(cfg_parser-&gt;filename);</span><br><span class="line">	cfg_parser-&gt;filename = s-&gt;filename;</span><br><span class="line">	cfg_parser-&gt;line = s-&gt;line;</span><br><span class="line">	yy_delete_buffer(YY_CURRENT_BUFFER);</span><br><span class="line">	yy_switch_to_buffer(s-&gt;buffer);</span><br><span class="line">	config_include_stack = s-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> yy_set_bol <span class="comment">/* compat definition, for flex 2.4.6 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> yy_set_bol(at_bol) \</span></span><br><span class="line"><span class="meta">        &#123; \</span></span><br><span class="line"><span class="meta">	        <span class="keyword">if</span> ( ! yy_current_buffer ) \</span></span><br><span class="line"><span class="meta">	                yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \</span></span><br><span class="line"><span class="meta">	        yy_current_buffer-&gt;yy_ch_buf[0] = ((at_bol)?<span class="string">&#x27;\n&#x27;</span>:<span class="string">&#x27; &#x27;</span>); \</span></span><br><span class="line"><span class="meta">        &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">%&#125;</span><br></pre></td></tr></table></figure>

<p>定义lex配置，指示flex生成文件时不使用input和unput函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%option noinput</span><br><span class="line">%option nounput</span><br><span class="line"></span><br><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> YY_NO_UNPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YY_NO_UNPUT 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> YY_NO_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YY_NO_INPUT 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">%&#125;</span><br></pre></td></tr></table></figure>

<p>正则式定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SPACE   [ \t]</span><br><span class="line">LETTER  [a-zA-Z]</span><br><span class="line">UNQUOTEDLETTER [^\<span class="string">&#x27;\&quot;\n\r \t\\]|\\.</span></span><br><span class="line"><span class="string">UNQUOTEDLETTER_NOCOLON [^\:\&#x27;</span>\<span class="string">&quot;\n\r \t\\]|\\.</span></span><br><span class="line"><span class="string">NEWLINE [\r\n]</span></span><br><span class="line"><span class="string">COMMENT \#</span></span><br><span class="line"><span class="string">COLON 	\:</span></span><br><span class="line"><span class="string">DQANY     [^\&quot;\n\r\\]|\\.</span></span><br><span class="line"><span class="string">SQANY     [^\&#x27;\n\r\\]|\\.</span></span><br></pre></td></tr></table></figure>

<p>定义了几个状态（condition），分别指示：双引号后字符的处理，单引号后字符的处理，“include:“后字符的处理，，关键字（如server、num-threads等）+:后变量的处理。</p>
<p>lex的每个正则式前面可以带有”&lt;状态&gt;“，例如”\n”。每个状态要先用%x声明才能使用。 当lex开始运行时，默认状态是INITIAL，以后可在C代码里用”BEGIN 状态名;“切换到其它状态(BEGIN是lex/yacc内置的宏)。 这时，只有当lex状态切换到COMMENT后，才会去匹配以开头的正则式，而不匹配其它状态开头的。 也就是说，lex当前处在什么状态，就考虑以该状态开头的正则式，而忽略其它的正则式。 其应用例如，在一段C代码里，同样是串”abc”，如果它写在代码段里，会被识别为标识符，如果写在注释里则就不会。所以对串”abc”的识别结果，应根据不同的状态加以区分。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%x	quotedstring singlequotedstr include include_quoted val</span><br></pre></td></tr></table></figure>

<h2 id="规则段"><a href="#规则段" class="headerlink" title="规则段"></a>规则段</h2><p>新的一段（规则段 rules）开始。<br>规则区包含了一系列具有pattern-action形式的规则，并且模式 pattern 位于行首不能缩进，action 也应该起始于同一行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%%</span><br></pre></td></tr></table></figure>
<p>初始状态或者val状态忽略任意长度的空格</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;INITIAL,val&gt;&#123;SPACE&#125;*	&#123; </span><br><span class="line">	LEXOUT((<span class="string">&quot;SP &quot;</span>)); <span class="comment">/* ignore */</span> &#125;</span><br></pre></td></tr></table></figure>

<p>初始状态或者val状态遇到#号后的任意长度任意字符，都认为是注释语句，全部忽略</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;INITIAL,val&gt;&#123;SPACE&#125;*&#123;COMMENT&#125;.*	&#123; </span><br><span class="line">	<span class="comment">/* note that flex makes the longest match and &#x27;.&#x27; is any but not nl */</span></span><br><span class="line">	LEXOUT((<span class="string">&quot;comment(%s) &quot;</span>, yytext)); <span class="comment">/* ignore */</span> &#125;</span><br></pre></td></tr></table></figure>

<p>遇到“server:“，执行宏YDVAR，后面0个参数，进入val状态，返回名为VAR_SERVER的token。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">server&#123;COLON&#125;			&#123; YDVAR(<span class="number">0</span>, VAR_SERVER) &#125;</span><br></pre></td></tr></table></figure>
<p>遇到“num-threads:“，执行YDVAR，后面1个参数(线程数)，进入val状态（lex将解析1个参数），返回名为VAR_NUM_THREADS的token。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">num-threads&#123;COLON&#125;		&#123; YDVAR(<span class="number">1</span>, VAR_NUM_THREADS) &#125;</span><br></pre></td></tr></table></figure>
<p>处理变量时，遇到双引号，则进入双引号状态quotedstring，QS-Quoted Start</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Quoted strings. Strip leading and ending quotes */</span></span><br><span class="line">&lt;val&gt;\<span class="string">&quot;			&#123; BEGIN(quotedstring); LEXOUT((&quot;</span>QS <span class="string">&quot;)); &#125;</span></span><br></pre></td></tr></table></figure>

<p>处理双引号字符串时遇到文件结束，应该是非正常结束，因为还没找到下一个双引号</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;quotedstring&gt;&lt;&lt;EOF&gt;&gt;   &#123;</span><br><span class="line">        yyerror(<span class="string">&quot;EOF inside quoted string&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(--num_args == <span class="number">0</span>) &#123; BEGIN(INITIAL); &#125;</span><br><span class="line">	<span class="keyword">else</span>		    &#123; BEGIN(val); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;quotedstring&gt;&#123;DQANY&#125;*  &#123; LEXOUT((<span class="string">&quot;STR(%s) &quot;</span>, yytext)); yymore(); &#125;</span><br></pre></td></tr></table></figure>

<h2 id="用户代码段"><a href="#用户代码段" class="headerlink" title="用户代码段"></a>用户代码段</h2><p>开始新的段，用户代码段(user code)，本例无数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%%</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Lex</category>
      </categories>
      <tags>
        <tag>lex</tag>
      </tags>
  </entry>
  <entry>
    <title>Yacc文件分析</title>
    <url>/2021/04/13/Yacc%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="Yacc文件组成"><a href="#Yacc文件组成" class="headerlink" title="Yacc文件组成"></a>Yacc文件组成</h2><blockquote>
<p>Yacc文件的格式和lex文件格式基本相同，也是由3段组成，用2个%%行把这3段隔开。<br>定义段… definitions …<br>%%<br>规则段… rules …<br>%%<br>用户代码段… subroutines …</p>
</blockquote>
<span id="more"></span>

<h2 id="定义段"><a href="#定义段" class="headerlink" title="定义段"></a>定义段</h2><blockquote>
<p>定义段包含的内容：<br>％｛<br>头文件表<br>宏定义<br>数据类型定义<br>全局变量定义<br>％｝<br>语法开始符定义<br>语义值类型定义<br>终结符定义<br>运算符优先级及结合性定义</p>
</blockquote>
<p>上述四部分括在 ％{和％}之间的内容是由yacc原样照抄到编译后的源文件（y.tab.c）中去，所以必须完全符合C语言文法。</p>
<p>规则段由语法规则和包括C代码的动作组成</p>
<h3 id="定义段开始"><a href="#定义段开始" class="headerlink" title="定义段开始"></a>定义段开始</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;config.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util/configyyrename.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util/config_file.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util/net_help.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ub_c_lex</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ub_c_error</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *message)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* these need to be global, otherwise they cannot be used inside yacc */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">config_parser_state</span>* <span class="title">cfg_parser</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OUTYY(s)  printf s <span class="comment">/* used ONLY when debugging */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OUTYY(s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">%&#125;</span><br></pre></td></tr></table></figure>

<h3 id="语义值类型定义"><a href="#语义值类型定义" class="headerlink" title="语义值类型定义"></a>语义值类型定义</h3><p>定义YYSTYPE的union类型。如果不进行定义，YYSTYPE默认为int类型。即yylval是一个int型的变量。Lex与yacc之间的通信就是靠%union里定义的联合体来完成。<br>%union里定义的联合体最终会被生成一个叫yylval的全局变量，这个全局变量可以在lex和yacc之间传递变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">	<span class="type">char</span>*	str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以％token开始的行定义的是终结符，所以SPACE, STRING_ARG, VAR_SERVER都是终结符，尖括号中的名字就是这些终结符的语义值的具体类型。<br>另外还有以％type开始的行是说明非终结符语义值的类型。本例中并未涉及，因为本例中所有的非终结符均不需要获取其值。</p>
<p>终结符token定义，可分多行，一行中可以定义多个终结符，它们之间用空格分开。<br>yacc规定每个终结符都有一个唯一的编号（token number）。终结符的编号由yacc内部决定，其编号规则是从258开始依次递增，每次加1。0-255被保留作为字符值。lexer解析到定义的特定字串，会返回此token值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%token SPACE LETTER NEWLINE COMMENT COLON ANY ZONESTR</span><br></pre></td></tr></table></figure>
<p>定义一个名为STRING_ARG的token，并且告诉yacc，其语义值为str,这时yylval.str中的值是有意义的可用的值。当然，这是因为我们的lexer已经正确的进行了如下的处理：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;val&gt;&#123;UNQUOTEDLETTER&#125;*	&#123; </span><br><span class="line">			<span class="keyword">if</span>(--num_args == <span class="number">0</span>) &#123; BEGIN(INITIAL); &#125;</span><br><span class="line">			yylval.str = strdup(yytext); </span><br><span class="line"><span class="keyword">return</span> STRING_ARG; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%token &lt;str&gt; STRING_ARG</span><br></pre></td></tr></table></figure>

<p>继续定义其它的终结符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%token VAR_SERVER VAR_VERBOSITY VAR_NUM_THREADS VAR_PORT</span><br><span class="line">%token VAR_OUTGOING_RANGE VAR_INTERFACE</span><br><span class="line">%token VAR_DO_IP4 VAR_DO_IP6 VAR_DO_UDP VAR_DO_TCP </span><br><span class="line">%token VAR_TCP_MSS VAR_OUTGOING_TCP_MSS</span><br></pre></td></tr></table></figure>
<h2 id="规则段"><a href="#规则段" class="headerlink" title="规则段"></a>规则段</h2><p>在yacc中，语法开始符定义在定义段中，语句是：</p>
<blockquote>
<p>%start 非终结符</p>
</blockquote>
<p>如果定义段中没有上面的说明，yacc自动将语法规则部分中第一条语法规则左部的非终结符作为语法开始符。</p>
<p>因此我们的开始非终结符为toplevelvars,它可以为空，可以是toplevelvars toplevelvar组成，注意，它是一个递归结构。<br>规则定义部分每个都是以分号结束。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">toplevelvars: <span class="comment">/* empty */</span> | toplevelvars toplevelvar ;</span><br></pre></td></tr></table></figure>
<p>继续：<br>toplevelvar 是由serverstart contents_server 或 forwardstart contents_forward等部分或共同组成的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">toplevelvar: serverstart contents_server | stubstart contents_stub |</span><br><span class="line">	forwardstart contents_forward | pythonstart contents_py | </span><br><span class="line">	rcstart contents_rc | dtstart contents_dt</span><br><span class="line">	;</span><br></pre></td></tr></table></figure>
<p>继续：<br>serverstart是由VAR_SERVER的token构成，它是一个终结符，由lexer来解析提供。<br>即:server:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* server: declaration */</span></span><br><span class="line">serverstart: VAR_SERVER</span><br><span class="line">	&#123; </span><br><span class="line">		OUTYY((<span class="string">&quot;\nP(server:)\n&quot;</span>)); </span><br><span class="line">	&#125;</span><br><span class="line">	;</span><br></pre></td></tr></table></figure>

<p>继续：<br>contents_server(应该是server section的内容)是由contents_server和content_server来构成，也可以为空，它也是一个递归结构。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">contents_server: contents_server content_server </span><br><span class="line">	| ;</span><br></pre></td></tr></table></figure>
<p>继续：</p>
<p>content_server由server_num_threads、server_verbosity等下列部分构成。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">content_server: server_num_threads | server_verbosity | server_port |</span><br><span class="line">	server_outgoing_range | server_do_ip4 |</span><br><span class="line">	server_do_ip6 | server_do_udp | server_do_tcp | </span><br><span class="line">	server_tcp_mss | server_outgoing_tcp_mss |</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">stubstart: VAR_STUB_ZONE</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">config_stub</span>* <span class="title">s</span>;</span></span><br><span class="line">		OUTYY((<span class="string">&quot;\nP(stub_zone:)\n&quot;</span>)); </span><br><span class="line">		s = (<span class="keyword">struct</span> config_stub*)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> config_stub));</span><br><span class="line">		<span class="keyword">if</span>(s) &#123;</span><br><span class="line">			s-&gt;next = cfg_parser-&gt;cfg-&gt;stubs;</span><br><span class="line">			cfg_parser-&gt;cfg-&gt;stubs = s;</span><br><span class="line">		&#125; <span class="keyword">else</span> </span><br><span class="line">			yyerror(<span class="string">&quot;out of memory&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	;</span><br><span class="line">contents_stub: contents_stub content_stub </span><br><span class="line">	| ;</span><br><span class="line">content_stub: stub_name | stub_host | stub_addr | stub_prime | stub_first</span><br><span class="line">	;</span><br></pre></td></tr></table></figure>

<p>server_num_threads 定义，它由两个token组成，VAR_NUM_THREADS 和STRING_ARG,即配置项名 server_num_threads: 和参数：一个整数构成。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">server_num_threads: VAR_NUM_THREADS STRING_ARG </span><br><span class="line">	&#123; </span><br><span class="line">		OUTYY((<span class="string">&quot;P(server_num_threads:%s)\n&quot;</span>, $<span class="number">2</span>)); </span><br><span class="line">		<span class="keyword">if</span>(atoi($<span class="number">2</span>) == <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>($<span class="number">2</span>, <span class="string">&quot;0&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">			yyerror(<span class="string">&quot;number expected&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> cfg_parser-&gt;cfg-&gt;num_threads = atoi($<span class="number">2</span>);</span><br><span class="line">		<span class="built_in">free</span>($<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	;</span><br></pre></td></tr></table></figure>

<p>yacc 允许通过符号名引用表达式的组成部分。当解析非终结符时，进入解析器的组成部分被命名为 $1 、 $2 ，依次类推；它将向高层解析器返回的值名为 $$ 。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">server_verbosity: VAR_VERBOSITY STRING_ARG </span><br><span class="line">	&#123; </span><br><span class="line">		OUTYY((<span class="string">&quot;P(server_verbosity:%s)\n&quot;</span>, $<span class="number">2</span>)); </span><br><span class="line">		<span class="keyword">if</span>(atoi($<span class="number">2</span>) == <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>($<span class="number">2</span>, <span class="string">&quot;0&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">			yyerror(<span class="string">&quot;number expected&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> cfg_parser-&gt;cfg-&gt;verbosity = atoi($<span class="number">2</span>);</span><br><span class="line">		<span class="built_in">free</span>($<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	;</span><br></pre></td></tr></table></figure>

<p>上述语句编译得到的C语言代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">case</span> <span class="number">154</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">line</span> 241 <span class="string">&quot;util/configparser.y&quot;</span> <span class="comment">/* yacc.c:1646  */</span></span></span><br><span class="line">    &#123; </span><br><span class="line">		OUTYY((<span class="string">&quot;P(server_verbosity:%s)\n&quot;</span>, (yyvsp[<span class="number">0</span>].str))); </span><br><span class="line">		<span class="keyword">if</span>(atoi((yyvsp[<span class="number">0</span>].str)) == <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>((yyvsp[<span class="number">0</span>].str), <span class="string">&quot;0&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">			yyerror(<span class="string">&quot;number expected&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> cfg_parser-&gt;cfg-&gt;verbosity = atoi((yyvsp[<span class="number">0</span>].str));</span><br><span class="line">		<span class="built_in">free</span>((yyvsp[<span class="number">0</span>].str));</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">line</span> 2121 <span class="string">&quot;util/configparser.c&quot;</span> <span class="comment">/* yacc.c:1646  */</span></span></span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>两个参数STRING_ARG的情况</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">server_access_control: VAR_ACCESS_CONTROL STRING_ARG STRING_ARG</span><br><span class="line">	&#123;</span><br><span class="line">		OUTYY((<span class="string">&quot;P(server_access_control:%s %s)\n&quot;</span>, $<span class="number">2</span>, $<span class="number">3</span>));</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">strcmp</span>($<span class="number">3</span>, <span class="string">&quot;deny&quot;</span>)!=<span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>($<span class="number">3</span>, <span class="string">&quot;refuse&quot;</span>)!=<span class="number">0</span> &amp;&amp;</span><br><span class="line">			<span class="built_in">strcmp</span>($<span class="number">3</span>, <span class="string">&quot;deny_non_local&quot;</span>)!=<span class="number">0</span> &amp;&amp;</span><br><span class="line">			<span class="built_in">strcmp</span>($<span class="number">3</span>, <span class="string">&quot;refuse_non_local&quot;</span>)!=<span class="number">0</span> &amp;&amp;</span><br><span class="line">			<span class="built_in">strcmp</span>($<span class="number">3</span>, <span class="string">&quot;allow&quot;</span>)!=<span class="number">0</span> &amp;&amp; </span><br><span class="line">			<span class="built_in">strcmp</span>($<span class="number">3</span>, <span class="string">&quot;allow_snoop&quot;</span>)!=<span class="number">0</span>) &#123;</span><br><span class="line">			yyerror(<span class="string">&quot;expected deny, refuse, deny_non_local, &quot;</span></span><br><span class="line">				<span class="string">&quot;refuse_non_local, allow or allow_snoop &quot;</span></span><br><span class="line">				<span class="string">&quot;in access control action&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(!cfg_str2list_insert(&amp;cfg_parser-&gt;cfg-&gt;acls, $<span class="number">2</span>, $<span class="number">3</span>))</span><br><span class="line">				fatal_exit(<span class="string">&quot;out of memory adding acl&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Yacc</category>
      </categories>
      <tags>
        <tag>Yacc</tag>
      </tags>
  </entry>
  <entry>
    <title>UML类图常用关系</title>
    <url>/2021/04/12/UML%E7%B1%BB%E5%9B%BE%E5%B8%B8%E7%94%A8%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h2 id="UML类图常用关系"><a href="#UML类图常用关系" class="headerlink" title="UML类图常用关系"></a>UML类图常用关系</h2><blockquote>
<p>在UML类图中，常有以下几种关系：<br>泛化(Generalization)、实现(Realization)、关联(Association)、聚合(Aggregation)、组合(Composition)和依赖(Dependency)。<br>按照关系的强弱顺序：泛化≥实现&gt;关联&gt;聚合&gt;组合&gt;依赖。</p>
</blockquote>
<span id="more"></span>

<h2 id="类图定义"><a href="#类图定义" class="headerlink" title="类图定义"></a>类图定义</h2><p><img src="95e11d9e34c28a82fb8a84bae9cd4a3749c44769e9e7ea46976e55fda1e3a9af.png" alt="图 9">  </p>
<p><code>-</code>：private——私有<br><code>+</code>：public——公有<br><code>#</code>：protected——保护性<br>例如：<br><img src="4b6b17de98d0a199af0723462e30ca60ed23688f7ac57ea94695d2da692429b9.png" alt="图 10">  </p>
<h2 id="泛化-Generalization"><a href="#泛化-Generalization" class="headerlink" title="泛化(Generalization)"></a>泛化(Generalization)</h2><p><img src="9b3aecb0abccab07f031a5ce7b2d591502ec398270c97bd5f57d842fc54961ca.png" alt="图 1">  </p>
<h2 id="实现-Realization"><a href="#实现-Realization" class="headerlink" title="实现(Realization)"></a>实现(Realization)</h2><p><img src="fac5736514f3a60bc072e23bdc33eecb4551da8dcca7d5fc617cb5d246032f4a.png" alt="图 2">  </p>
<h2 id="关联-Association"><a href="#关联-Association" class="headerlink" title="关联(Association)"></a>关联(Association)</h2><p>单向关联、双向关联、自有关联<br><img src="d2ac8614aa4b1c9751e93a50b4eff831fbad26fa25760865d5084ddf0d5c8e92.png" alt="图 3"><br><img src="b30f66dfb2c4755deb1fbf3efa9aa948307d3bd4ec320c0409ab641e05589be0.png" alt="图 4">  </p>
<h2 id="聚合-Aggregation"><a href="#聚合-Aggregation" class="headerlink" title="聚合(Aggregation)"></a>聚合(Aggregation)</h2><p><img src="262c8c17e368511f86f7aba001239d100bc4f60238a6228c0002216d0f2f4ee9.png" alt="图 5">  </p>
<h2 id="组合-Composition"><a href="#组合-Composition" class="headerlink" title="组合(Composition)"></a>组合(Composition)</h2><p><img src="05470d078e48896c17e46ba5e4bc76ae03f8a11511d5ccf85a44402244b33bb2.png" alt="图 6">  </p>
<h2 id="依赖-Dependency"><a href="#依赖-Dependency" class="headerlink" title="依赖(Dependency)"></a>依赖(Dependency)</h2><p><img src="ef50d3977d2e56a3feb8010e8f1bf724e2f642ac161922b142cb7fd09fa7861b.png" alt="图 7">  </p>
]]></content>
      <categories>
        <category>UML</category>
      </categories>
      <tags>
        <tag>astah</tag>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>pcap</title>
    <url>/2021/04/11/pcap/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>PCAP是常用的数据报存储格式。</li>
<li>基于libpcap，是tcpdump、tshark等网络工具报文捕获的主要文件格式。</li>
<li>格式：文件头 + 帧头 + 帧数据<span id="more"></span>
<img src="78371cae51385780a52c3d1a7e3f2f77f8e460e750b4d9d65073eb89218c3ce2.png" alt="图 1">  </li>
</ul>
<p><img src="784dbc0d2a7dd9651976aecdf8e7005325fbc22d52e2f68ea7490c66930fb5c4.png" alt="图 2">  </p>
<h2 id="文件头格式"><a href="#文件头格式" class="headerlink" title="文件头格式"></a>文件头格式</h2><p>文件头：每个PCAP文件只有一个，占24字节<br><img src="a5bf1b2e94e2b4259a14a6f2f548f999fec9a4da12ea8c6deed94d01bd19e15d.png" alt="图 3"><br><code>Magic</code>：4B，魔数，识别文件和字节顺序；<br>             0xa1b2c3d4表示大端模式；<br>             0xd4c3b2a1表示小端模式；<br><code>Major/Minor</code>：4B，版本号；<br><code>ThisZone</code>：4B，时区；<br><code>SigFigs</code>：4B，时间戳精度；<br><code>SnapLen</code>：4B，最大捕获长度；<br><code>LinkType</code>：4B，链路类型: 常见ETH(1)、PPP(9)、CHDLC(104)等。</p>
<h2 id="帧头格式"><a href="#帧头格式" class="headerlink" title="帧头格式"></a>帧头格式</h2><p>帧头：每一帧报文都带有一个帧头，占16字节<br><img src="612f57ac698ab2869f8cfa0070a37e850e5af2017155fef4b40f8e76e0bcaabe.png" alt="图 4"><br><code>Timestamp(s)</code>：4B，捕获时间戳，精确到秒；<br><code>Timestamp(us)</code> ：4B，捕获时间戳，精确到微秒；<br><code>CapLen</code>：4B，当前捕获的数据帧长度；<br><code>Len</code>：4B，网络中实际数据帧长度；受限于SnapLen，可能会截断，一般等于CapLen。</p>
<h2 id="PCAP工具"><a href="#PCAP工具" class="headerlink" title="PCAP工具"></a>PCAP工具</h2><p><code>wireshark</code>：windows下网络封包分析软件；<br><code>tshark</code>：Linux版本的wireshark命令行工具；<br><code>tcpdump</code>：报文捕获工具；<br>                例如抓取eth0 53端口udp报文：<br>                tcpdump –i eth0 udp port 53 –s 0 –w save.pcap –v<br><code>tcpreplay</code>：报文重放工具；<br>                例如向eth0以10Mbps速率循环放包：<br>                tcpreplay –i eth0 –M 10 –l 0 local.pcap -v<br><code>editcap</code>：报文编辑工具；<br>                例如将报文切割为每1000帧一个PCAP文件：<br>                editcap –c 1000 src.pcap out.pcap<br><code>mergecap</code>：报文合并工具；<br>                例如合并多个原始PCAP文件：<br>                mergecap –w all.pca src1.pcap src2.pcap</p>
<h2 id="修改报文用于功能分支测试"><a href="#修改报文用于功能分支测试" class="headerlink" title="修改报文用于功能分支测试"></a>修改报文用于功能分支测试</h2><p>例如：测试DNS请求类型为DLV的场景，但无该类型报文；<br>        以十六进制显示帧内容，找到对应位置修改；<br>        需注意修改的内容要满足对应协议格式；<br>        字节增加删除需要将关联的长度也修改。<br><img src="295c62d4468bc057fe98104817d6c719e35c39180a14cb2753976a32daf069a9.png" alt="图 5">  </p>
<h2 id="开发场景，下载调试报文"><a href="#开发场景，下载调试报文" class="headerlink" title="开发场景，下载调试报文"></a>开发场景，下载调试报文</h2><p>例如：异常分支下，将对应内存保存到本地PCAP文件。<br>    gdb模式下导出内存：<br>    dump memory out.mem pStart pEnd<br>    转储hex格式：<br>    xxd –g 1 out.mem out.hex<br>    转换pcap格式：<br>    text2pcap out.hex out.pcap<br><img src="355d5c2325a46ad6e3ad72110713074132910c5ce33d81517f4304da221d811d.png" alt="图 7">  </p>
]]></content>
      <categories>
        <category>PCAP</category>
      </categories>
      <tags>
        <tag>pcap</tag>
      </tags>
  </entry>
  <entry>
    <title>signal capture + libunwind</title>
    <url>/2021/04/11/signal-capture-libunwind/</url>
    <content><![CDATA[<h2 id="常见跑飞问题定位"><a href="#常见跑飞问题定位" class="headerlink" title="常见跑飞问题定位"></a>常见跑飞问题定位</h2><h3 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h3><p>段错误触发时，GDB会直接告诉我们问题出现在哪一行代码，并且可以利用backtrace命令查看完整调用栈信息。<br>此外，还可以利用其他常规调试命令来查看参数、变量、内存等数据。</p>
<p>缺点：很多时候，问题并不是100%必现的，我们不可能一直把程序运行在GDB中，这对程序的执行性能等会有很大的影响。</p>
<span id="more"></span>

<h3 id="coredump-gdb"><a href="#coredump-gdb" class="headerlink" title="coredump + gdb"></a>coredump + gdb</h3><p>程序异常中断时，OS会把程序当前的工作状态存储成一个coredump文件。</p>
<p>其提供了程序的内存、堆栈、寄存器、函数栈等各种信息，方便问题的追踪定位。</p>
<p>缺点：当程序运行时占用大量内存，异常奔溃时生成的coredump会非常大，相应落盘过程也会非常缓慢。</p>
<p>由于某种原因，系统可能无法生存core dump文件。</p>
<p>比如出于安全考虑，core dump功能可能是被彻底禁止的，或者在一些存储空间受限的嵌入式系统中，也无法生成core dump文件。</p>
<h2 id="替代方案"><a href="#替代方案" class="headerlink" title="替代方案"></a>替代方案</h2><p>程序自己捕捉信号，获取中断时的堆栈信息</p>
<ul>
<li>signal capture + libunwind</li>
</ul>
<h2 id="libunwind简介"><a href="#libunwind简介" class="headerlink" title="libunwind简介"></a>libunwind简介</h2><p>用于获取程序的调用栈和异常处理和跳转需要，常用的unwind库根据Assembling a Complete Toolchain有：</p>
<ul>
<li>libunwind (llvm)，LLVM内置的unwind库，主要为了不依赖GNU的实现。</li>
<li>libgcc_s (GNU)，GCC内置的unwind库，不需要其他的外部unwind库。</li>
<li>libunwind，The libunwind project - News 1.1版本从2012年后有几年不更新，2017年恢复更新发布了1.2版本支持aarch64并且支持了快速stacktrace。当初导入gperftools时有简单用过这个库。</li>
<li>libunwind (PathScale)，pathscale/libunwind。</li>
<li>gabi++，早期的Android实现，包含在ndk中，在ndk/sources/cxx-stl/gabi++中找到，从NDK r9到r16均有提供，从NDK r11开始以源码方式提供，默认不编译。</li>
<li>Android 9.0开始使用新的unwind库，见<a href="https://android.googlesource.com/">https://android.googlesource.com</a>。</li>
<li>更多API的信息可以访问<a href="https://www.nongnu.org/libunwind/docs.html">libunwind documentation</a></li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>测试代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> UNW_LOCAL_ONLY</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;execinfo.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libunwind.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRACE_COUNT 16</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_backtrace</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unw_cursor_t</span> cursor;</span><br><span class="line">	<span class="type">unw_context_t</span> context;</span><br><span class="line"></span><br><span class="line">	unw_getcontext(&amp;context);</span><br><span class="line">	unw_init_local(&amp;cursor, &amp;context);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (unw_step(&amp;cursor) &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">unw_word_t</span> offset, pc;</span><br><span class="line">		unw_get_reg(&amp;cursor, UNW_REG_IP, &amp;pc);</span><br><span class="line">		<span class="keyword">if</span> (pc == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;0x%lx:&quot;</span>, pc);</span><br><span class="line"></span><br><span class="line">		<span class="type">char</span> sym[<span class="number">256</span>];</span><br><span class="line">		<span class="keyword">if</span> (unw_get_proc_name(&amp;cursor, sym, <span class="keyword">sizeof</span>(sym), &amp;offset) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot; (%s+0x%lx)\n&quot;</span>, sym, offset);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot; -- error: unable to obtain symbol name for this frame\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">signal_handle3</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *dump_arr[TRACE_COUNT];</span><br><span class="line">	<span class="type">int</span> size = backtrace(dump_arr, TRACE_COUNT);</span><br><span class="line"></span><br><span class="line">	FILE *fd = fopen(<span class="string">&quot;b.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line">	backtrace_symbols_fd(dump_arr, size, fileno(fd));</span><br><span class="line">	fclose(fd);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">signal_handle</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">	my_backtrace();</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun_core_sigfpe</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun_core_sigabrt</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun_core_sigsegv</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *q1;</span><br><span class="line">	<span class="built_in">memcpy</span>(q1, <span class="string">&quot;aaaaaaaaa&quot;</span>, <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span> (sig)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> SIGSEGV:</span><br><span class="line">		fun_core_sigsegv();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SIGABRT:</span><br><span class="line">		fun_core_sigabrt();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SIGFPE:</span><br><span class="line">		fun_core_sigfpe();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">signal_handle2</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">256</span>];</span><br><span class="line">	<span class="type">char</span> cmd[<span class="number">256</span>];</span><br><span class="line">	FILE *fh;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">&quot;/proc/%d/cmdline&quot;</span>, getpid());</span><br><span class="line">	<span class="keyword">if</span> (!(fh = fopen(buf, <span class="string">&quot;r&quot;</span>)))</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (!fgets(buf, <span class="keyword">sizeof</span>(buf), fh))</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	fclose(fh);</span><br><span class="line">	<span class="keyword">if</span> (buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	<span class="built_in">snprintf</span>(cmd, <span class="keyword">sizeof</span>(cmd), <span class="string">&quot;gdb %s %d -ex=bt &gt; ./a.txt&quot;</span>, buf, getpid());</span><br><span class="line">	system(cmd);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	signal(SIGSEGV, signal_handle);</span><br><span class="line">	signal(SIGABRT, signal_handle);</span><br><span class="line">	signal(SIGFPE, signal_handle);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// SIGFPE 算术异常</span></span><br><span class="line">	<span class="comment">// fun(SIGFPE);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// SIGABRT 异常终止</span></span><br><span class="line">	<span class="comment">// fun(SIGABRT);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// SIGSEGV 无效存储访问</span></span><br><span class="line">	fun(SIGSEGV);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果<br><img src="97e114fd24980501019a763eb1bca50b8da68dbfca1d73d8c6487103c97dab74.png" alt="图 2"><br><img src="7be43c3a08bc23324a62735446f2deb9ea2632513500c29192bf80c4eec4c945.png" alt="图 3">  </p>
<h2 id="抛栈解析脚本"><a href="#抛栈解析脚本" class="headerlink" title="抛栈解析脚本"></a>抛栈解析脚本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">DEFAULT_PROC_NAME=<span class="string">&quot;hyper_commander&quot;</span></span><br><span class="line">DEFAULT_PROC_SO=<span class="string">&quot;jmnd_admin.so&quot;</span></span><br><span class="line">DEFAULT_CORE_FILE=<span class="string">&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="title">get_default_core_file</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">pushd</span> /var/log/jmnd 2&gt;/dev/null 1&gt;/dev/null</span><br><span class="line">  DEFAULT_CORE_FILE=$(<span class="built_in">ls</span> | grep hyper_commander_core | <span class="built_in">head</span> -1)</span><br><span class="line">  <span class="built_in">popd</span> 2&gt;/dev/null 1&gt;/dev/null</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">args=<span class="string">&quot;$*&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="title">usage</span></span> ()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;args=<span class="variable">$args</span>&quot;</span></span><br><span class="line">  <span class="built_in">echo</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;sh <span class="subst">$(basename <span class="string">&quot;<span class="variable">$0</span>&quot;</span>)</span> -h -e &lt;proc_name&gt; -f &lt;core_file&gt;&quot;</span></span><br><span class="line">  <span class="built_in">echo</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Helper script, used to addr2line.&quot;</span></span><br><span class="line">  <span class="built_in">echo</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot; -h               Help Usage&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot; -e &lt;proc_name&gt; proc name&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot; -f &lt;core_file&gt; core file&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;example:&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;    sh <span class="subst">$(basename <span class="string">&quot;<span class="variable">$0</span>&quot;</span>)</span> -e <span class="variable">$DEFAULT_PROC_NAME</span>&quot;</span></span><br><span class="line">  <span class="built_in">echo</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> <span class="string">&quot;he:f:&quot;</span> opt</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="keyword">case</span> <span class="variable">$opt</span> <span class="keyword">in</span></span><br><span class="line">    h)  show_usage=1</span><br><span class="line">        ;;</span><br><span class="line">    e)  proc_name=<span class="string">&quot;<span class="variable">$OPTARG</span>&quot;</span></span><br><span class="line">        ;;</span><br><span class="line">    f)  core_file=<span class="string">&quot;<span class="variable">$OPTARG</span>&quot;</span></span><br><span class="line">        ;;</span><br><span class="line">    \?)</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;Invalid option: -<span class="variable">$OPTARG</span>&quot;</span> &gt;&amp;2</span><br><span class="line">      show_usage=1</span><br><span class="line">      ;;</span><br><span class="line">  <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$show_usage</span>&quot;</span> = <span class="string">&quot;1&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  usage</span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$proc_name</span>&quot;</span> == <span class="string">&quot;&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  proc_name=<span class="variable">$DEFAULT_PROC_NAME</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$proc_name</span>&quot;</span> == <span class="string">&quot;hyper_commander&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  so_name=<span class="string">&quot;/usr/share/jmnd/<span class="variable">$DEFAULT_PROC_SO</span>&quot;</span></span><br><span class="line">  <span class="keyword">if</span> [ ! -e <span class="variable">$so_name</span> ]</span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$so_name</span> not exist&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 2</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line">proc_name=<span class="string">&quot;/usr/share/jmnd/bin/<span class="variable">$proc_name</span>&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ ! -e <span class="variable">$proc_name</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$proc_name</span> not exist&quot;</span></span><br><span class="line">  <span class="built_in">exit</span> 2</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line">get_default_core_file</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$core_file</span>&quot;</span> == <span class="string">&quot;&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  core_file=<span class="variable">$DEFAULT_CORE_FILE</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$core_file</span>&quot;</span> == <span class="string">&quot;&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;no core_file&quot;</span></span><br><span class="line">  <span class="built_in">exit</span> 3</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">core_file=<span class="string">&quot;/var/log/jmnd/<span class="variable">$core_file</span>&quot;</span></span><br><span class="line"> </span><br><span class="line">abs_addr=$(awk -F <span class="string">&#x27;[:(+)]&#x27;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> <span class="variable">$core_file</span>)</span><br><span class="line">func_name=$(awk -F <span class="string">&#x27;[:(+)]&#x27;</span> <span class="string">&#x27;&#123;print $3&#125;&#x27;</span> <span class="variable">$core_file</span>)</span><br><span class="line">func_offset=$(awk -F <span class="string">&#x27;[:(+)]&#x27;</span> <span class="string">&#x27;&#123;print $4&#125;&#x27;</span> <span class="variable">$core_file</span>)</span><br><span class="line"> </span><br><span class="line">func_name=(<span class="variable">$&#123;func_name// /&#125;</span>)</span><br><span class="line">func_offset=(<span class="variable">$&#123;func_offset// /&#125;</span>)</span><br><span class="line">num_name=<span class="variable">$&#123;#func_name[@]&#125;</span></span><br><span class="line">num_off=<span class="variable">$&#123;#func_offset[@]&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$num_name</span>&quot;</span> != <span class="string">&quot;<span class="variable">$num_off</span>&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;num not match&quot;</span></span><br><span class="line">  <span class="built_in">exit</span> 4</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line">j=0</span><br><span class="line"><span class="keyword">for</span>((i=0;i&lt;<span class="variable">$num_name</span>;i++));</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  func_v=<span class="variable">$&#123;func_name[$i]&#125;</span></span><br><span class="line">  off_v=<span class="variable">$&#123;func_offset[$i]&#125;</span></span><br><span class="line">  nm_v=$(nm <span class="variable">$proc_name</span> | grep -w <span class="variable">$func_v</span>)</span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$nm_v</span>&quot;</span> == <span class="string">&quot;&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$so_name</span>&quot;</span> != <span class="string">&quot;&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">      nm_so_v=$(nm <span class="variable">$so_name</span> | grep -w <span class="variable">$func_v</span>)</span><br><span class="line">      <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$nm_so_v</span>&quot;</span> == <span class="string">&quot;&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">continue</span></span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$nm_v</span>&quot;</span> != <span class="string">&quot;&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    rel_addr=<span class="variable">$&#123;nm_v%% *&#125;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    rel_addr=<span class="variable">$&#123;nm_so_v%% *&#125;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$rel_addr</span>&quot;</span> == <span class="string">&quot;&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">continue</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  rel_addr=<span class="string">&quot;0x&quot;</span>`<span class="built_in">echo</span> <span class="string">&quot;obase=16; <span class="subst">$((16#$&#123;rel_addr&#125;+off_v)</span>)&quot;</span> | bc`</span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$nm_v</span>&quot;</span> != <span class="string">&quot;&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    func_line=`addr2line <span class="variable">$rel_addr</span> -e <span class="variable">$proc_name</span> -f`</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    func_line=`addr2line <span class="variable">$rel_addr</span> -e <span class="variable">$so_name</span> -f`</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  func_line=(<span class="variable">$&#123;func_line// /&#125;</span>)</span><br><span class="line">  <span class="built_in">printf</span> <span class="string">&quot;#%-3s %-10s in %s\n&quot;</span> <span class="variable">$j</span> <span class="variable">$rel_addr</span> <span class="variable">$&#123;func_line[0]&#125;</span></span><br><span class="line">  <span class="built_in">printf</span> <span class="string">&quot;     at %s\n&quot;</span> <span class="variable">$&#123;func_line[1]&#125;</span></span><br><span class="line">  ((j=j+1))</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>libunwind</category>
      </categories>
      <tags>
        <tag>libunwind</tag>
      </tags>
  </entry>
  <entry>
    <title>用Jenkins构建CI/CD流水线</title>
    <url>/2021/04/10/%E7%94%A8Jenkins%E6%9E%84%E5%BB%BACI-CD%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
    <content><![CDATA[<p>在正式学习Jenkins之前我们需要对两个名词有一定了解，其一是DevOps，另外一个就是CI/CD。</p>
<h2 id="何为DevOps？"><a href="#何为DevOps？" class="headerlink" title="何为DevOps？"></a>何为DevOps？</h2><p>来自wiki百科介绍</p>
<blockquote>
<p>DevOps是一系列软件开发实践，强调开发人员（Dev）和测试人员（QA）及运维人员（Ops）之间的沟通合作，通过自动化流程，使得软件构建、测试、发布更加快捷、频繁和可靠。</p>
</blockquote>
<span id="more"></span>

<p>简单来说通过DevOps可以将开发、测试、运维三个团队紧密联系在一起，能够使得项目快速迭代、缩短项目上线时间。<br>需要注意的是DevOps是一种理念，而不是一种技术，在实际工作中落地应用这套理念需要有相对应得技术作为支撑，而CI/CD就是作为DevOps得最佳实践技术手段。</p>
<h2 id="何为CI-CD？"><a href="#何为CI-CD？" class="headerlink" title="何为CI/CD？"></a>何为CI/CD？</h2><h3 id="持续集成-（Continuous-integration，简称CI）"><a href="#持续集成-（Continuous-integration，简称CI）" class="headerlink" title="持续集成 （Continuous integration，简称CI）"></a>持续集成 （Continuous integration，简称CI）</h3><p>持续集成是一种开发实践，它倡导团队成员需要频繁的集成他们的工作，每次集成都通过自动化构建（包括编译、构建、自动化测试）来验证，从而尽快地发现集成中的错误。让正在开发的软件始终处于可工作状态，让产品可以快速迭代，同时还能保持高质量。</p>
<h3 id="持续交付（Continuous-Delivery）"><a href="#持续交付（Continuous-Delivery）" class="headerlink" title="持续交付（Continuous Delivery）"></a>持续交付（Continuous Delivery）</h3><p>持续交付是持续集成的延伸或者看作持续集成的下一步，它将集成后的代码部署到类生产环境，确保可以以可持续的方式快速向客户发布新的更改。如果代码没有问题，可以继续部署到生产环境中。它强调的是，不管怎么更新，软件是随时随地可以交付的。</p>
<h3 id="持续部署（Continuous-Deployment）"><a href="#持续部署（Continuous-Deployment）" class="headerlink" title="持续部署（Continuous Deployment）"></a>持续部署（Continuous Deployment）</h3><p>持续部署是持续交付的下一步，在持续交付的基础上，由开发人员或运维人员定期向生产环境部署稳定的构建版本，持续部署的目标是代码在任何时刻都是可部署的，并可自动进入到生产环境。</p>
<p>而CI/CD整套流水线体系的运行我们需要Jenkins这样的平台去支撑。</p>
<h2 id="安装配置JDK环境"><a href="#安装配置JDK环境" class="headerlink" title="安装配置JDK环境"></a>安装配置JDK环境</h2><p>从官网下载jdk压缩包，拷贝到linux系统opt目录下<br><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p>
<p>解压：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xzvf jdk-8u121-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>
<p>配置环境变量，/etc/profile文件每个用户登录时都会运行的环境变量设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure>
<p>在最末尾进行配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/opt/jdk1.8.0_121</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=$:CLASSPATH:<span class="variable">$JAVA_HOME</span>/lib/</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br></pre></td></tr></table></figure>
<p>注意：JAVA_HOME需要配置为本地JDK家目录</p>
<p>使配置生效</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>
<p>验证JDK配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>
<h2 id="安装配置Jenkins"><a href="#安装配置Jenkins" class="headerlink" title="安装配置Jenkins"></a>安装配置Jenkins</h2><p>从官网下载Jenkins rpm包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://pkg.jenkins.io/redhat-stable/jenkins-2.249.3-1.1.noarch.rpm</span><br></pre></td></tr></table></figure>
<p>从官网下载可能速度较慢，可以换成清华的地址：<a href="https://mirrors.tuna.tsinghua.edu.cn/jenkins/redhat-stable/">https://mirrors.tuna.tsinghua.edu.cn/jenkins/redhat-stable/</a></p>
<p>安装Jenkins</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ivh jenkins-2.249.3-1.1.noarch.rpm</span><br></pre></td></tr></table></figure>
<p>启动Jenkins</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start jenkins</span><br></pre></td></tr></table></figure>
<p>可能遇到的报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Starting Jenkins bash: /usr/bin/java: No such file or directory</span><br></pre></td></tr></table></figure>
<p>解决方案： 添加java命令的的软链接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /opt/jdk1.8.0_121/bin/java /usr/bin/java</span><br></pre></td></tr></table></figure>
<p>修改Jenkins端口号</p>
<p>默认Jenkins会使用8080端口，此端口会被很多程序使用，比如tomcat</p>
<p>编辑JENKINS_PORT配置选项</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/sysconfig/jenkins</span><br><span class="line"></span><br><span class="line"><span class="comment">## Type:        integer(0:65535)</span></span><br><span class="line"><span class="comment">## Default:     8080</span></span><br><span class="line"><span class="comment">## ServiceRestart: jenkins</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Port Jenkins is listening on.</span></span><br><span class="line"><span class="comment"># Set to -1 to disable</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">JENKINS_PORT=<span class="string">&quot;8081&quot;</span></span><br></pre></td></tr></table></figure>
<p>重启Jenkins</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart jenkins</span><br></pre></td></tr></table></figure>
<h2 id="使用Jenkins"><a href="#使用Jenkins" class="headerlink" title="使用Jenkins"></a>使用Jenkins</h2><p>访问Jenkins通过http://你的服务器ip地址:8081即可访问</p>
<p>一、初始化配置，进入到对应目录通过cat命令查看初始化密码</p>
<p>cat /var/lib/jenkins/secrets/initialAdminPassword<br><img src="9f31164162a48629df266f6967baedba9703d6ae208f1f85adfa44dcb215c7f9.png" alt="图 6">  </p>
<p>二、自定义插件进行安装</p>
<p><img src="bdb13e0b23a5c2382bac06595bfcde137da82852268f9e579b953542a075da27.png" alt="图 5">  </p>
<p>三、勾选【无】选择安装，这里不选择插件安装是因为插件可能会下载失败，我们可以选择后续再去安装。</p>
<p><img src="8330d6ca6c73b205ec567850855f7fca0541790aa2f3b5dd99842d8d5244ef6c.png" alt="图 4">  </p>
<p>四、填写管理员用户信息</p>
<p><img src="5dbb99dbbb175edc62243e4be6fdadab01421e456828a629f257920239337ad2.png" alt="图 2">  </p>
<p>五、点击保存并完成即可<br><img src="fcba9c43ad948ce0cb267d38f6f576410c905d6a25ef2252ed3bc6eede90ba6a.png" alt="图 3">  </p>
]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>CI/CD</tag>
      </tags>
  </entry>
  <entry>
    <title>signal capture + backtrace</title>
    <url>/2021/04/10/signal-capture-backtrace/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>要获取堆栈信息，要使用库提供的三个堆栈相关的系统函数：</p>
<ul>
<li>backtrace：返回当前线程栈帧信息，形式为栈帧地址</li>
<li>backtrace_symbols：将栈帧地址转换为可读的字符串形式</li>
<li>backtrace_symbols_fd：同上，转换后写入文件句柄fd<span id="more"></span></li>
</ul>
<p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;execinfo.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>       <span class="title function_">backtrace</span><span class="params">(<span class="type">void</span> **buffer, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">char</span> **<span class="title function_">backtrace_symbols</span><span class="params">(<span class="type">void</span> *<span class="type">const</span> *buffer, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">void</span>    <span class="title function_">backtrace_symbols_fd</span><span class="params">(<span class="type">void</span> *<span class="type">const</span> *buffer, <span class="type">int</span> size, <span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure>


<h2 id="常见异常中断信号"><a href="#常见异常中断信号" class="headerlink" title="常见异常中断信号"></a>常见异常中断信号</h2><ul>
<li>SIGFPE：算术异常，例如除数为0</li>
<li>SIGABRT：异常终止，例如内存重复释放</li>
<li>SIGSEGV：无效存储访问，例如越界操作访问</li>
</ul>
<p>信号捕捉：通过signal系统函数绑定信号处理函数，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">signal(SIGSEGV, signal_handle);</span><br><span class="line">signal(SIGABRT, signal_handle);</span><br><span class="line">signal(SIGFPE, signal_handle);</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>测试代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fun_core_sigfpe</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun_core_sigabrt</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun_core_sigsegv</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *q1;</span><br><span class="line">    <span class="built_in">memcpy</span>(q1, <span class="string">&quot;aaaaaaaaa&quot;</span>, <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span>(sig)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> SIGSEGV:</span><br><span class="line">            fun_core_sigsegv();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SIGABRT:</span><br><span class="line">            fun_core_sigabrt();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SIGFPE:</span><br><span class="line">            fun_core_sigfpe();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">signal_handle3</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> * dump_arr[TRACE_COUNT];</span><br><span class="line">    <span class="type">int</span> size = backtrace(dump_arr, TRACE_COUNT);</span><br><span class="line"></span><br><span class="line">    FILE *fd = fopen(<span class="string">&quot;b.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line">    backtrace_symbols_fd(dump_arr, size, fileno(fd));</span><br><span class="line">    fclose(fd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    signal(SIGSEGV, signal_handle3);</span><br><span class="line">    signal(SIGABRT, signal_handle3);</span><br><span class="line">    signal(SIGFPE,  signal_handle3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//SIGFPE 算术异常</span></span><br><span class="line">    fun(SIGFPE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//SIGABRT 异常终止</span></span><br><span class="line">    fun(SIGABRT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//SIGSEGV 无效存储访问</span></span><br><span class="line">    fun(SIGSEGV);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果<br><img src="437db2da189fe666d5a761a7767d640a984c663ae440d219aa328bec69bdf37b.png" alt="图 1">  </p>
<p>nm+addr2line解析具体抛栈行号<br><img src="fb66fbd0611768797c4448503c40f83fd2cf7a5e1a333dec87ce5c78dd87ada6.png" alt="图 2">  </p>
<p><img src="c337bbf22f9c52b246b6afd440b0b155b98031c79cab476f4183874419a76bbd.png" alt="图 3">  </p>
]]></content>
      <categories>
        <category>backtrace</category>
      </categories>
      <tags>
        <tag>backtrace</tag>
      </tags>
  </entry>
  <entry>
    <title>mlx5 dpdk编译</title>
    <url>/2021/01/07/mlx5-dpdk%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h2 id="MLX5运行环境安装"><a href="#MLX5运行环境安装" class="headerlink" title="MLX5运行环境安装"></a>MLX5运行环境安装</h2><p>MLNX_OFED_LINUX-5.4-1.0.3.0-rhel7.4-x86_64.tgz </p>
<ol>
<li>该驱动下载官网：<br><a href="https://www.mellanox.com/products/infiniband-drivers/linux/mlnx_ofed">https://www.mellanox.com/products/infiniband-drivers/linux/mlnx_ofed</a><span id="more"></span></li>
<li>简要安装步骤:<br>将MLNX_OFED_LINUX-5.4-1.0.3.0-rhel7.4-x86_64.tgz放在/home/setup目录，解压，<br>进入解压包的顶层目录,里面有两个脚本mlnxofedinstall跟mlnx_add_kernel_support.sh， 首先执行<br><code>./mlnxofedinstall --upstream-libs --dpdk --add-kernel-support</code></li>
</ol>
<p>请严格按照所给参数进行安装，安装中间可能会出现一些依赖库的安装，请自行使用yum安装。安装完成后进行下一步<br><code>/etc/init.d/openibd restart</code></p>
<p>这里有个特殊点，如果出现以上报错 ： rmmod: ERROR: Module rdma_cm is in use by: rpcrdma ib_isert<br>把对应的模块停掉就好了。查看 <code>lsmod |grep rdma_cm </code><br><code>modprobe -r rpcrdma </code><br><code>modprobe -r ib_isert </code><br>这个完成后，然后运行第二个脚本<br><code>./mlnx_add_kernel_support.sh -m /home/setup/MLNX_OFED_LINUX-5.4-1.0.3.0-rhel7.4-x86_64 -v</code></p>
<p><strong>注意：</strong><br> /home/setup/MLNX_OFED_LINUX-5.4-1.0.3.0-rhel7.4-x86_64 这个是实际该安装包的压缩目录，最好使用绝对路径（相对路径未使用过）</p>
<h2 id="DPDK编译（20-11）"><a href="#DPDK编译（20-11）" class="headerlink" title="DPDK编译（20.11）"></a>DPDK编译（20.11）</h2><p>DPDK编译版本：20.11<br>编译依赖：MLX5运行环境的安装，因为meson build时会检查当前系统环境，存在MLX5运行环境时，meson build会自动加载MLX5相关的静态动态库<br>应用程序编译：</p>
<ol>
<li><p>检查DPDK编译是否存在MLX5相关的静态动态库，如果不存在需要重新安装MLX5运行环境<br><img src="44d0628aecf620aed3d1ec30cfc18e64f190703e83be9b80c34777eac91ec158.png" alt="图 7">  </p>
</li>
<li><p>编译配置添加rte_common_mlx5、rte_net_mlx5静态库 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DBDK_LIBS        += -lrte_common_mlx5</span><br><span class="line">DBDK_LIBS        += -lrte_net_mlx5</span><br></pre></td></tr></table></figure></li>
<li><p>链接-lmlx5 -libverbs动态库</p>
</li>
<li><p>执行程序编译，编译完之后检查应用程序是否能找到链接的动态库，如果不能的话需要检查动态库的安装位置</p>
</li>
</ol>
<h2 id="DPDK编译（18-11）"><a href="#DPDK编译（18-11）" class="headerlink" title="DPDK编译（18.11）"></a>DPDK编译（18.11）</h2><p>DPDK编译版本：18.11<br>编译依赖：MLX5运行环境的安装，依赖安装后的动态库<br>应用程序编译： </p>
<ol>
<li><p>18.11通过make&amp;&amp;make install来编译相关网卡支持的驱动库<br>修改DPDK源码目录config/common-base文件内的CONFIG_RTE_LIBRTE_MLX5_PMD选项<br>CONFIG_RTE_LIBRTE_MLX5_PMD=y<br>会将rte_pmd_mlx5静态库编译到指定目录中 </p>
</li>
<li><p>编译配置添加rte_pmd_mlx5静态库 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DBDK_LIBS        += -lrte_pmd_mlx5</span><br></pre></td></tr></table></figure></li>
<li><p>链接 -lmlx5 -libverbs -lmnl动态库</p>
</li>
<li><p>执行程序编译，编译完之后检查应用程序是否能找到链接的动态库，如果不能的话需要检查动态库的安装位置<br><img src="f559d10e5e4010af751779993a8476d896d3546c5fa7de3a248ce553c39a1454.png" alt="图 8">  </p>
</li>
</ol>
<h2 id="DPDK应用程序启动"><a href="#DPDK应用程序启动" class="headerlink" title="DPDK应用程序启动"></a>DPDK应用程序启动</h2><ol>
<li><p>判断网卡驱动是否为MLX</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./DPDK/dpdk-devbind.py -s | grep <span class="variable">$&#123;DEV_LIST[0]&#125;</span> | grep mlx</span><br></pre></td></tr></table></figure></li>
<li><p>如果是MLX驱动则加载ib_uverbs mlx5_core mlx5_ib，正常分配大页 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /sbin/modprobe -a ib_uverbs mlx5_core mlx5_ib</span><br><span class="line">/sbin/lsmod | grep -s ib_uverbs &gt; /dev/null</span><br><span class="line"><span class="keyword">if</span> [ $? -ne 0 ] ; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;## ERROR: Could not load ib_uverbs.&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">/sbin/lsmod | grep -s mlx5_core &gt; /dev/null</span><br><span class="line"><span class="keyword">if</span> [ $? -ne 0 ] ; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;## ERROR: Could not load mlx5_core.&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">/sbin/lsmod | grep -s mlx5_ib &gt; /dev/null</span><br><span class="line"><span class="keyword">if</span> [ $? -ne 0 ] ; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;## ERROR: Could not load mlx5_ib.&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>注意：</strong><br>    <strong>千万不要安装igb_uio与vfio-pci驱动，要不然mlx5无法启动</strong></p>
<ol start="3">
<li>添加pci的id号至bind_nic.log<br>程序在eal初始化时需要-a指定该文件中的参数，<strong>注意不要将管理口添加进去</strong>，否则进程会将管理口托管，导致其他应用无法使用管理口</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pci_id[0]=`./DPDK/dpdk-devbind.py -s | grep <span class="variable">$&#123;DEV_LIST[0]&#125;</span> | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;pci_id[0]&#125;</span> if=<span class="variable">$&#123;DEV_LIST[0]&#125;</span> ip=None mask=None now_drv=mlx5_core old_drv=igb_uio&quot;</span> &gt; bind_nic.log</span><br><span class="line"><span class="keyword">for</span>((i=1; i&lt;<span class="variable">$&#123;DEV_NUM&#125;</span>; i++));</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    pci_id[<span class="variable">$i</span>]=`./DPDK/dpdk-devbind.py -s | grep <span class="variable">$&#123;DEV_LIST[$i]&#125;</span> | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>`</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;pci_id[$i]&#125;</span> if=<span class="variable">$&#123;DEV_LIST[$i]&#125;</span> ip=None mask=None now_drv=mlx5_core old_drv=igb_uio&quot;</span> &gt;&gt; bind_nic.log</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>DPDK</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>DPDK</tag>
      </tags>
  </entry>
  <entry>
    <title>rebase + merge</title>
    <url>/2020/11/13/rebase-merge/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>git rebase</code> 和 <code>git merge</code> 一样都是用于从一个分支获取并且合并到当前分支，但是他们采取不同的工作方式，以下面的一个工作场景说明其区别</p>
<span id="more"></span>

<p>场景：</p>
<p>如图所示：你在一个feature分支进行新特性的开发，与此同时，master 分支的也有新的提交。<br><img src="10d112b9d1e18b14aad2682fc0245ac4f21f11727af55627ac28fa305be6b557.png" alt="图 6">  </p>
<p>为了将master 上新的提交合并到你的feature分支上，你有两种选择：<code>merge</code> or <code>rebase</code></p>
<h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><p>执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line">git merge master</span><br></pre></td></tr></table></figure>
<p>或者执行更简单的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge master feature</span><br></pre></td></tr></table></figure>
<p>那么此时在feature上git 自动会产生一个新的commit(merge commit)</p>
<p><img src="329561e5949faafb4940dc500bdea86b4203c08715fb0124f2bb35262c303c27.png" alt="图 7">  </p>
<p><strong>marge 特点</strong>：</p>
<ul>
<li>自动创建一个新的commit</li>
<li>如果合并的时候遇到冲突，仅需要修改后重新commit</li>
<li>优点：记录了真实的commit情况，包括每个分支的详情</li>
<li>缺点：因为每次merge会自动产生一个merge commit，所以在使用一些git 的GUI tools，特别是commit比较频繁时，看到分支很杂乱。</li>
</ul>
<h2 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h2><p>本质是变基 变基 变基<br>变基是什么? 找公共祖先</p>
<p>执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line">git rebase master</span><br></pre></td></tr></table></figure>
<p><img src="4afc22fd0e1bd665a6076695dab490d2b62c2199443b04ff4ebec332a6ecbe3e.png" alt="图 8">  </p>
<p><strong>rebase 特点</strong>：</p>
<ul>
<li>会合并之前的commit历史</li>
<li>优点：得到更简洁的项目历史，去掉了merge commit</li>
<li>缺点：如果合并出现代码问题不容易定位，因为re-write了history</li>
</ul>
<p>合并时如果出现冲突需要按照如下步骤解决</p>
<p><strong>修改冲突部分</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add</span><br><span class="line">git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure>
<p>（如果第三步无效可以执行 git rebase –skip）<br>不要在git add 之后习惯性的执行 git commit命令</p>
<p><strong>注意</strong>：<br>不要在公共分支上使用<br>比如说如下场景：如图所示<br><img src="2ad414bcc983f0ae1222fa405ff797c61da0ac786ea7ea65f42497edba95fe31.png" alt="图 9">  </p>
<p>如果你rebase master 到你的feature分支：</p>
<p>rebase 将所有master的commit移动到你的feature 的顶端。问题是：其他人还在original master上开发，由于你使用了rebase移动了master，git 会认为你的主分支的历史与其他人的有分歧，会产生冲突。</p>
]]></content>
      <categories>
        <category>GIT</category>
      </categories>
      <tags>
        <tag>rebase</tag>
        <tag>merge</tag>
      </tags>
  </entry>
  <entry>
    <title>remote + cherry-pick</title>
    <url>/2020/11/12/remote-cherry-pick/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>对于多分支的代码库，将代码从一个分支转移到另一个分支是常见需求。<br>这时分两种情况。一种情况是，你需要另一个分支的所有代码变动，那么就采用合并（git merge）。<br>另一种情况是，你只需要部分代码变动（某几个提交），这时可以采用 Cherry pick。</p>
</blockquote>
<span id="more"></span>

<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>git cherry-pick命令的作用，就是将指定的提交（commit）应用于其他分支。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cherry-pick &lt;commitHash&gt;</span><br></pre></td></tr></table></figure>
<p>上面命令就会将指定的提交commitHash，应用于当前分支。这会在当前分支产生一个新的提交，当然它们的哈希值会不一样。</p>
<p>举例来说，代码仓库有master和feature两个分支。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a - b - c - d   Master</span><br><span class="line">     \</span><br><span class="line">       e - f - g Feature</span><br></pre></td></tr></table></figure>
<p>现在将提交f应用到master分支。</p>
<h1 id="切换到-master-分支"><a href="#切换到-master-分支" class="headerlink" title="切换到 master 分支"></a>切换到 master 分支</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line"></span><br><span class="line"><span class="comment"># Cherry pick 操作</span></span><br><span class="line">$ git cherry-pick f</span><br></pre></td></tr></table></figure>
<p>上面的操作完成以后，代码库就变成了下面的样子。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a - b - c - d - f   Master</span><br><span class="line">     \</span><br><span class="line">       e - f - g Feature</span><br></pre></td></tr></table></figure>
<p>从上面可以看到，master分支的末尾增加了一个提交f。</p>
<p><code>git cherry-pick</code>命令的参数，不一定是提交的哈希值，分支名也是可以的，表示转移该分支的最新提交。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cherry-pick feature</span><br></pre></td></tr></table></figure>
<p>上面代码表示将feature分支的最近一次提交，转移到当前分支。</p>
<h2 id="转移多个提交"><a href="#转移多个提交" class="headerlink" title="转移多个提交"></a>转移多个提交</h2><p>Cherry pick 支持一次转移多个提交。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cherry-pick &lt;HashA&gt; &lt;HashB&gt;</span><br></pre></td></tr></table></figure>
<p>上面的命令将 A 和 B 两个提交应用到当前分支。这会在当前分支生成两个对应的新提交。</p>
<p>如果想要转移一系列的连续提交，可以使用下面的简便语法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cherry-pick A..B </span><br></pre></td></tr></table></figure>
<p>上面的命令可以转移从 A 到 B 的所有提交。它们必须按照正确的顺序放置：提交 A 必须早于提交 B，否则命令将失败，但不会报错。</p>
<p>注意，使用上面的命令，提交 A 将不会包含在 Cherry pick 中。如果要包含提交 A，可以使用下面的语法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cherry-pick A^..B </span><br></pre></td></tr></table></figure>

<h2 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h2><p><code>git cherry-pick</code>命令的常用配置项如下。</p>
<p>（1）<code>-e，--edit</code></p>
<p>打开外部编辑器，编辑提交信息。</p>
<p>（2）<code>-n，--no-commit</code></p>
<p>只更新工作区和暂存区，不产生新的提交。</p>
<p>（3）<code>-x</code></p>
<p>在提交信息的末尾追加一行(cherry picked from commit …)，方便以后查到这个提交是如何产生的。</p>
<p>（4）<code>-s，--signoff</code></p>
<p>在提交信息的末尾追加一行操作者的签名，表示是谁进行了这个操作。</p>
<p>（5）<code>-m parent-number，--mainline parent-number</code></p>
<p>如果原始提交是一个合并节点，来自于两个分支的合并，那么 Cherry pick 默认将失败，因为它不知道应该采用哪个分支的代码变动。</p>
<p><code>-m</code>配置项告诉 Git，应该采用哪个分支的变动。它的参数<code>parent-number</code>是一个从1开始的整数，代表原始提交的父分支编号。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cherry-pick -m 1 &lt;commitHash&gt;</span><br></pre></td></tr></table></figure>
<p>上面命令表示，Cherry pick 采用提交commitHash来自编号1的父分支的变动。</p>
<p>一般来说，1号父分支是接受变动的分支（the branch being merged into），2号父分支是作为变动来源的分支（the branch being merged from）。</p>
<h2 id="代码冲突"><a href="#代码冲突" class="headerlink" title="代码冲突"></a>代码冲突</h2><p>如果操作过程中发生代码冲突，Cherry pick 会停下来，让用户决定如何继续操作。</p>
<p>（1）<code>--continue</code></p>
<p>用户解决代码冲突后，第一步将修改的文件重新加入暂存区（git add .），第二步使用下面的命令，让 Cherry pick 过程继续执行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cherry-pick --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure>
<p>（2）<code>--abort</code></p>
<p>发生代码冲突后，放弃合并，回到操作前的样子。</p>
<p>（3）<code>--quit</code></p>
<p>发生代码冲突后，退出 Cherry pick，但是不回到操作前的样子。</p>
<p>（4）结合vscode<br>结合vscode的图形界面，可以高效的完成冲突的修复，会将所有的冲突文件呈现出来</p>
<h2 id="转移到另一个代码库"><a href="#转移到另一个代码库" class="headerlink" title="转移到另一个代码库"></a>转移到另一个代码库</h2><p>Cherry pick 也支持转移另一个代码库的提交，方法是先将该库加为远程仓库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote add target git://gitUrl</span><br></pre></td></tr></table></figure>

<p>上面命令添加了一个远程仓库target。</p>
<p>然后，将远程代码抓取到本地。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git fetch target</span><br></pre></td></tr></table></figure>

<p>上面命令将远程代码仓库抓取到本地。</p>
<p>接着，检查一下要从远程仓库转移的提交，获取它的哈希值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> target/master</span><br></pre></td></tr></table></figure>

<p>最后，使用git cherry-pick命令转移提交。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cherry-pick &lt;commitHash&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>GIT</category>
      </categories>
      <tags>
        <tag>cherry-pick</tag>
      </tags>
  </entry>
  <entry>
    <title>format-patch + am</title>
    <url>/2020/11/11/format-patch-am/</url>
    <content><![CDATA[<h2 id="生成所选的patch"><a href="#生成所选的patch" class="headerlink" title="生成所选的patch"></a>生成所选的patch</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git format-patch HEAD^       <span class="comment">#生成最近的1次commit的patch</span></span><br><span class="line">$ git format-patch HEAD^^      <span class="comment">#生成最近的2次commit的patch</span></span><br><span class="line">$ git format-patch HEAD^^^     <span class="comment">#生成最近的3次commit的patch</span></span><br><span class="line">$ git format-patch HEAD^^^^    <span class="comment">#生成最近的4次commit的patch</span></span><br><span class="line">$ git format-patch &lt;r1&gt;..&lt;r2&gt;  <span class="comment">#生成两个commit间的修改的patch（生成的patch不包含r1. &lt;r1&gt;和&lt;r2&gt;都是具体的commit号)</span></span><br><span class="line">$ git format-patch -1 &lt;r1&gt;     <span class="comment">#生成单个commit的patch</span></span><br><span class="line">$ git format-patch &lt;r1&gt;        <span class="comment">#生成某commit以来的修改patch（不包含该commit）</span></span><br><span class="line">$ git format-patch --root &lt;r1&gt; <span class="comment">#生成从根到r1提交的所有patch</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="使用am应用patch"><a href="#使用am应用patch" class="headerlink" title="使用am应用patch"></a>使用am应用patch</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git am 0001-limit-log-function.patch           <span class="comment"># 将名字为0001-limit-log-function.patch的patch打上</span></span><br><span class="line">$ git am --signoff 0001-limit-log-function.patch <span class="comment"># 添加-s或者--signoff，还可以把自己的名字添加为signed off by信息，作用是注明打patch的人是谁，因为有时打patch的人并不是patch的作者</span></span><br><span class="line">$ git am ~/patch-set/*.patch                     <span class="comment"># 将路径~/patch-set/*.patch 按照先后顺序打上</span></span><br><span class="line">$ git am --abort                                 <span class="comment"># 当git am失败时，用以将已经在am过程中打上的patch废弃掉(比如有三个patch，打到第三个patch时有冲突，那么这条命令会把打上的前两个patch丢弃掉，返回没有打patch的状态)</span></span><br><span class="line">$ git am --resolved                              <span class="comment"># 当git am失败，解决完冲突后，这条命令会接着打patch</span></span><br></pre></td></tr></table></figure>

<h2 id="使用apply应用patch"><a href="#使用apply应用patch" class="headerlink" title="使用apply应用patch"></a>使用apply应用patch</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git apply --<span class="built_in">stat</span>    xxx.patch 查看哪些文件需要合入</span><br><span class="line">git apply --check   xxx.patch 检查合入后是否有冲突</span><br><span class="line">git apply --reject  xxx.patch 合入改动</span><br></pre></td></tr></table></figure>

<h2 id="am和apply区别"><a href="#am和apply区别" class="headerlink" title="am和apply区别"></a>am和apply区别</h2><p>git am会直接将patch的所有信息打上去，而且不用重新git add和git commit，author也是patch的author而不是打patch的人。<br>git apply并不会将commit message等打上去，打完patch后需要重新git add和git commit。</p>
]]></content>
      <categories>
        <category>GIT</category>
      </categories>
      <tags>
        <tag>format-patch</tag>
        <tag>am</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用命令</title>
    <url>/2020/11/10/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><blockquote>
<p>远端版本库、本地版本库、工作区、暂存区<br>从远端版本库<code>clone</code>到本地版本库，<code>checkout</code>创建一个分支到工作区，<br>修改代码，<code>add</code>到暂存区，<code>commit</code>到本地版本库，<code>push</code>到远端版本库</p>
</blockquote>
<span id="more"></span>

<h2 id="新建代码库"><a href="#新建代码库" class="headerlink" title="新建代码库"></a>新建代码库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在当前目录新建一个Git代码库</span></span><br><span class="line">$ git init</span><br><span class="line"><span class="comment"># 新建一个目录，将其初始化为Git代码库</span></span><br><span class="line">$ git init [project-name]</span><br><span class="line"><span class="comment"># 下载一个项目和它的整个代码历史</span></span><br><span class="line">$ git <span class="built_in">clone</span> [url]</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下(全局配置)，也可以在项目目录下(项目配置)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示当前的Git配置</span></span><br><span class="line">$ git config --list</span><br><span class="line"><span class="comment"># 编辑Git配置文件</span></span><br><span class="line">$ git config -e [--global]</span><br><span class="line"><span class="comment"># 设置提交代码时的用户信息</span></span><br><span class="line">$ git config [--global] user.name <span class="string">&quot;[name]&quot;</span></span><br><span class="line">$ git config [--global] user.email <span class="string">&quot;[email address]&quot;</span></span><br><span class="line"><span class="comment"># 颜色设置</span></span><br><span class="line">git config --global color.ui <span class="literal">true</span>                         <span class="comment"># git status等命令自动着色</span></span><br><span class="line">git config --global color.status auto</span><br><span class="line">git config --global color.diff auto</span><br><span class="line">git config --global color.branch auto</span><br><span class="line">git config --global color.interactive auto</span><br><span class="line">git config --global --<span class="built_in">unset</span> http.proxy                    <span class="comment"># remove  proxy configuration on git</span></span><br></pre></td></tr></table></figure>

<h2 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加/删除文件"></a>增加/删除文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加指定文件到暂存区</span></span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"><span class="comment"># 添加指定目录到暂存区，包括子目录</span></span><br><span class="line">$ git add [<span class="built_in">dir</span>]</span><br><span class="line"><span class="comment"># 添加当前目录的所有文件到暂存区</span></span><br><span class="line">$ git add .</span><br><span class="line"><span class="comment"># 添加每个变化前，都会要求确认</span></span><br><span class="line"><span class="comment"># 对于同一个文件的多处变化，可以实现分次提交</span></span><br><span class="line">$ git add -p</span><br><span class="line"><span class="comment"># 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line">$ git <span class="built_in">rm</span> [file1] [file2] ...</span><br><span class="line"><span class="comment"># 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line">$ git <span class="built_in">rm</span> --cached [file]</span><br><span class="line"><span class="comment"># 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line">$ git <span class="built_in">mv</span> [file-original] [file-renamed]</span><br></pre></td></tr></table></figure>

<h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提交暂存区到仓库区</span></span><br><span class="line">$ git commit -m [message]</span><br><span class="line"><span class="comment"># 提交暂存区的指定文件到仓库区</span></span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"><span class="comment"># 提交工作区自上次commit之后的变化，直接到仓库区</span></span><br><span class="line">$ git commit -a</span><br><span class="line"><span class="comment"># 提交时显示所有diff信息</span></span><br><span class="line">$ git commit -v</span><br><span class="line"><span class="comment"># 将add和commit合为一步</span></span><br><span class="line">$ git commit -am <span class="string">&#x27;message&#x27;</span></span><br><span class="line"><span class="comment"># 使用一次新的commit，替代上一次提交</span></span><br><span class="line"><span class="comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"><span class="comment"># 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure>

<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有本地分支</span></span><br><span class="line">$ git branch</span><br><span class="line"><span class="comment"># 列出所有远程分支</span></span><br><span class="line">$ git branch -r</span><br><span class="line"><span class="comment"># 列出所有本地分支和远程分支</span></span><br><span class="line">$ git branch -a</span><br><span class="line"><span class="comment"># 新建一个分支，但依然停留在当前分支</span></span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"><span class="comment"># 新建一个分支，并切换到该分支</span></span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"><span class="comment"># 新建一个分支，指向指定commit</span></span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"><span class="comment"># 新建一个分支，与指定的远程分支建立追踪关系</span></span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br><span class="line"><span class="comment"># 切换到指定分支，并更新工作区</span></span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"><span class="comment"># 切换到上一个分支</span></span><br><span class="line">$ git checkout -</span><br><span class="line"><span class="comment"># 建立追踪关系，在现有分支与指定的远程分支之间</span></span><br><span class="line">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"><span class="comment"># 合并指定分支到当前分支</span></span><br><span class="line">$ git merge [branch]</span><br><span class="line"><span class="comment"># 选择一个commit，合并进当前分支</span></span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br><span class="line"><span class="comment"># 检出版本v2.0</span></span><br><span class="line">$ git checkout v2.0</span><br><span class="line"><span class="comment"># 从远程分支develop创建新本地分支devel并检出</span></span><br><span class="line">$ git checkout -b devel origin/develop</span><br><span class="line"><span class="comment"># 检出head版本的README文件（可用于修改错误回退）</span></span><br><span class="line">git checkout -- README </span><br></pre></td></tr></table></figure>

<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有tag</span></span><br><span class="line">$ git tag</span><br><span class="line"><span class="comment"># 新建一个tag在当前commit</span></span><br><span class="line">$ git tag [tag]</span><br><span class="line"><span class="comment"># 新建一个tag在指定commit</span></span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"><span class="comment"># 删除本地tag</span></span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"><span class="comment"># 删除远程tag</span></span><br><span class="line">$ git push origin :refs/tags/[tagName]</span><br><span class="line"><span class="comment"># 查看tag信息</span></span><br><span class="line">$ git show [tag]</span><br><span class="line"><span class="comment"># 提交指定tag</span></span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"><span class="comment"># 提交所有tag</span></span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"><span class="comment"># 新建一个分支，指向某个tag</span></span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure>

<h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示有变更的文件</span></span><br><span class="line">$ git status</span><br><span class="line"><span class="comment"># 显示当前分支的版本历史</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"><span class="comment"># 显示commit历史，以及每次commit发生变更的文件</span></span><br><span class="line">$ git <span class="built_in">log</span> --<span class="built_in">stat</span></span><br><span class="line"><span class="comment"># 搜索提交历史，根据关键词</span></span><br><span class="line">$ git <span class="built_in">log</span> -S [keyword]</span><br><span class="line"><span class="comment"># 显示某个commit之后的所有变动，每个commit占据一行</span></span><br><span class="line">$ git <span class="built_in">log</span> [tag] HEAD --pretty=format:%s</span><br><span class="line"><span class="comment"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span></span><br><span class="line">$ git <span class="built_in">log</span> [tag] HEAD --grep feature</span><br><span class="line"><span class="comment"># 显示某个文件的版本历史，包括文件改名</span></span><br><span class="line">$ git <span class="built_in">log</span> --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"><span class="comment"># 显示指定文件相关的每一次diff</span></span><br><span class="line">$ git <span class="built_in">log</span> -p [file]</span><br><span class="line"><span class="comment"># 显示过去5次提交</span></span><br><span class="line">$ git <span class="built_in">log</span> -5 --pretty --oneline</span><br><span class="line"><span class="comment"># 显示所有提交过的用户，按提交次数排序</span></span><br><span class="line">$ git shortlog -sn</span><br><span class="line"><span class="comment"># 显示指定文件是什么人在什么时间修改过</span></span><br><span class="line">$ git blame [file]</span><br><span class="line"><span class="comment"># 显示暂存区和工作区的差异</span></span><br><span class="line">$ git diff</span><br><span class="line"><span class="comment"># 显示暂存区和上一个commit的差异</span></span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"><span class="comment"># 显示工作区与当前分支最新commit之间的差异</span></span><br><span class="line">$ git diff HEAD</span><br><span class="line"><span class="comment"># 显示两次提交之间的差异</span></span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"><span class="comment"># 显示今天你写了多少行代码</span></span><br><span class="line">$ git diff --shortstat <span class="string">&quot;@&#123;0 day ago&#125;&quot;</span></span><br><span class="line"><span class="comment"># 显示某次提交的元数据和内容变化</span></span><br><span class="line">$ git show [commit]</span><br><span class="line"><span class="comment"># 显示某次提交发生变化的文件</span></span><br><span class="line">$ git show --name-only [commit]</span><br><span class="line"><span class="comment"># 显示某次提交时，某个文件的内容</span></span><br><span class="line">$ git show [commit]:[filename]</span><br><span class="line"><span class="comment"># 显示当前分支的最近几次提交</span></span><br><span class="line">$ git reflog</span><br></pre></td></tr></table></figure>

<h2 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载远程仓库的所有变动</span></span><br><span class="line">$ git fetch [remote]</span><br><span class="line"><span class="comment"># 显示所有远程仓库</span></span><br><span class="line">$ git remote -v</span><br><span class="line"><span class="comment"># 显示某个远程仓库的信息</span></span><br><span class="line">$ git remote show [remote]</span><br><span class="line"><span class="comment"># 增加一个新的远程仓库，并命名</span></span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"><span class="comment"># 取回远程仓库的变化，并与本地分支合并</span></span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"><span class="comment"># 上传本地指定分支到远程仓库</span></span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"><span class="comment"># 强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class="line">$ git push [remote] --force</span><br><span class="line"><span class="comment"># 推送所有分支到远程仓库</span></span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></table></figure>

<h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 恢复暂存区的指定文件到工作区</span></span><br><span class="line">$ git checkout [file]</span><br><span class="line"><span class="comment"># 恢复某个commit的指定文件到暂存区和工作区</span></span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"><span class="comment"># 恢复暂存区的所有文件到工作区</span></span><br><span class="line">$ git checkout .</span><br><span class="line"><span class="comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span></span><br><span class="line">$ git reset [file]</span><br><span class="line"><span class="comment"># 重置暂存区与工作区，与上一次commit保持一致</span></span><br><span class="line">$ git reset --hard</span><br><span class="line"><span class="comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></span><br><span class="line">$ git reset [commit]</span><br><span class="line"><span class="comment"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"><span class="comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"><span class="comment"># 新建一个commit，用来撤销指定commit</span></span><br><span class="line"><span class="comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span></span><br><span class="line">$ git revert [commit]</span><br><span class="line"><span class="comment"># 暂时将未提交的变化移除，稍后再移入</span></span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init                                                  <span class="comment"># 初始化本地git仓库（创建新仓库）</span></span><br><span class="line">git config --global user.name <span class="string">&quot;xxx&quot;</span>                       <span class="comment"># 配置用户名</span></span><br><span class="line">git config --global user.email <span class="string">&quot;xxx@xxx.com&quot;</span>              <span class="comment"># 配置邮件</span></span><br><span class="line">git config --global color.ui <span class="literal">true</span>                         <span class="comment"># git status等命令自动着色</span></span><br><span class="line">git config --global color.status auto</span><br><span class="line">git config --global color.diff auto</span><br><span class="line">git config --global color.branch auto</span><br><span class="line">git config --global color.interactive auto</span><br><span class="line">git config --global --<span class="built_in">unset</span> http.proxy                    <span class="comment"># remove  proxy configuration on git</span></span><br><span class="line">git <span class="built_in">clone</span> git+ssh://git@192.168.53.168/VT.git             <span class="comment"># clone远程仓库</span></span><br><span class="line">git status                                                <span class="comment"># 查看当前版本状态（是否修改）</span></span><br><span class="line">git add xyz                                               <span class="comment"># 添加xyz文件至index</span></span><br><span class="line">git add .                                                 <span class="comment"># 增加当前子目录下所有更改过的文件至index</span></span><br><span class="line">git commit -m <span class="string">&#x27;xxx&#x27;</span>                                       <span class="comment"># 提交</span></span><br><span class="line">git commit --amend -m <span class="string">&#x27;xxx&#x27;</span>                               <span class="comment"># 合并上一次提交（用于反复修改）</span></span><br><span class="line">git commit -am <span class="string">&#x27;xxx&#x27;</span>                                      <span class="comment"># 将add和commit合为一步</span></span><br><span class="line">git <span class="built_in">rm</span> xxx                                                <span class="comment"># 删除index中的文件</span></span><br><span class="line">git <span class="built_in">rm</span> -r *                                               <span class="comment"># 递归删除</span></span><br><span class="line">git <span class="built_in">log</span>                                                   <span class="comment"># 显示提交日志</span></span><br><span class="line">git <span class="built_in">log</span> -1                                                <span class="comment"># 显示1行日志 -n为n行</span></span><br><span class="line">git <span class="built_in">log</span> -5</span><br><span class="line">git <span class="built_in">log</span> --<span class="built_in">stat</span>                                            <span class="comment"># 显示提交日志及相关变动文件</span></span><br><span class="line">git <span class="built_in">log</span> -p -m</span><br><span class="line">git show dfb02e6e4f2f7b573337763e5c0013802e392818         <span class="comment"># 显示某个提交的详细内容</span></span><br><span class="line">git show dfb02                                            <span class="comment"># 可只用commitid的前几位</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>GIT</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git更改远程仓库指向</title>
    <url>/2020/11/10/git%E6%9B%B4%E6%94%B9%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93%E6%8C%87%E5%90%91/</url>
    <content><![CDATA[<h2 id="命令行更改"><a href="#命令行更改" class="headerlink" title="命令行更改"></a>命令行更改</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git remote set-url origin ssh://git@bb.jaguarmicro.com:7999/alps/jmnd-project.git</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="配置文件更改"><a href="#配置文件更改" class="headerlink" title="配置文件更改"></a>配置文件更改</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git config -e</span><br></pre></td></tr></table></figure>
<p>直接编辑其中origin的url就行了，退出时记得保存  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[core]</span><br><span class="line">        repositoryformatversion = 0</span><br><span class="line">        filemode = true</span><br><span class="line">        bare = false</span><br><span class="line">        logallrefupdates = true</span><br><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">        url = ssh://git@bb.jaguarmicro.com:7999/~rma.ma/hyper-commander-pr.git</span><br><span class="line">        fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[branch &quot;corsica_dpu_dev&quot;]</span><br><span class="line">        remote = origin</span><br><span class="line">        merge = refs/heads/corsica_dpu_dev</span><br><span class="line">[branch &quot;alps_dpu_dev&quot;]</span><br><span class="line">        remote = origin</span><br><span class="line">        merge = refs/heads/alps_dpu_dev</span><br></pre></td></tr></table></figure>
<h2 id="origin意义"><a href="#origin意义" class="headerlink" title="origin意义"></a>origin意义</h2><p>假设你们公司有一个内部gitlab或gitea搭建的服务器，地址为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://192.168.1.100/</span><br></pre></td></tr></table></figure>

<p>但是外网服务器上也有一个git服务器，地址为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://git.company.com</span><br></pre></td></tr></table></figure>

<hr>
<p>假设你们在做一个项目叫“sixsixsix”，你是项目负责人，你叫zhangsan，现在你要给你的项目一个git仓库。</p>
<p>首先，你在本地搭好框架，项目文件夹是<code>sixsixsix</code>，然后做git的初始化和提交</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd sixsixsix</span><br><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;项目起步，首次提交&quot;</span><br></pre></td></tr></table></figure>

<p>好了，现在你要推送到内部服务器，让你的组员检出，进行开发。要推送到服务器，你得先添加地址，不然git怎么知道要往哪儿推送呢？</p>
<p>所以你要先在内网git服务器上添加一个仓库，并把仓库地址添加到你本地git仓库中(neiwang是“内网”的拼音)，这样你push的时候，git才知道往哪个地址push</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add neiwang http://192.168.1.100/zhangsan/sixsixsix.git</span><br></pre></td></tr></table></figure>

<p>公网远程服务器，虽然我还没那么快推送，但是我还是先添加一下吧，先把流程跑通，免得要推送的时候出问题(gongwang是“公网”的拼音)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add gongwang https://git.company.com/zhangsan/sixsixsix.git</span><br></pre></td></tr></table></figure>

<p>好了，你现在添加了两个远程服务器地址了，是时候推送了。</p>
<p>先往内部服务器推送master分支(<code>-u neiwang</code>用于指定向内网服务器推送)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push -u neiwang master</span><br></pre></td></tr></table></figure>

<p>后期做好之后，向公网服务器推送稳定分支(<code>-u gongwang</code>用于指向向公网服务器推送)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push -u gongwang stable</span><br></pre></td></tr></table></figure>

<p>你是不是发现，貌似跟如下所示的(你在csdn查的)命令不一样？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p>其实到这里你应该已经明白，neiwang、gongwang、origin这三个就是一类东西，就是用来代表“远程仓库”的，就是名称不一样而已。</p>
<p>事实上，推送到内网和公网的命令你还可以写成这样</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push http://192.168.1.100/zhangsan/sixsixsix.git master</span><br><span class="line">git push https://git.company.com/zhangsan/sixsixsix.git stable</span><br></pre></td></tr></table></figure>

<p>到这里，你应该明白了，其实无论neiwang、gongwang、origin，它们只是远程服务器的一个别名，否则你就要写整个地址，显然写整个地址太长太麻烦。</p>
<hr>
<p><code>fetch</code>参数可能也很多人不明白它是干什么的，其实很简单，它代表从url中的哪个分支中复制到本地的哪个分支，因为如果只有一个远程仓库url，如果远程仓库有很多分支，你怎么知道要复制哪个分支呢？所以fetch参数就是做这个规定的。</p>
<p>其实fetch参数冒号两边就代表两个文件夹，在你的项目下的<code>.git</code>文件夹中，有一个文件夹叫<code>ref</code>，它的意思是“引用”，如果你只有主分支(master或main，我这里是main，如果你是master也一样，把我说的main当成你的master就好)，那么<code>.git/refs/heads/</code>文件夹下应该只有一个文件，那就是<code>main</code>，表示当前分支为<code>main</code>分支，而另一个文件夹<code>.git/refs/remote/</code>可以认为是远程文件夹在你本地的缓存，<code>git pull</code>或者<code>git fetch</code>从远程仓库获取数据的时候，其实它是往<code>.git/refs/remote/</code>文件夹里存的，所以这个fetch的意思，就是指从url中获取到数据后，把它放到<code>.git/refs/remote/origin</code>文件夹下，然后你执行<code>git merge</code>的时候，如果你本地跟远程仓库代码没有冲突，它就会把<code>.git/refs/remote/origin</code>中的数据再copy到代表你本地数据的文件夹，也就是<code>.git/refs/heads/</code>文件夹。</p>
<p>当然，事实上refs里根本没有实际数据，refs里只有引用，为什么这个文件夹叫refs？因为refs是单词“references”的缩写，这个单词就是“引用”的意思，你可以去看<code>.git/refs/heads/main</code>中的内容，它只有一个commitID在里面， <code>.git/refs/remote/origin/main</code>也是只有commitID，实际数据都是存放在<code>.git/objects</code>目录下的，所以前面说的copy其实只是把<code>.git/refs/remote/origin/main</code>中的commitID copy到<code>.git/refs/heads/main</code>里，这样本地的数据就会自动使用最新的那个引用对应的数据。</p>
<hr>
<p>如果你的项目是本地<code>git init</code>的，而不是clone下来的，那么<code>.git/config</code>中就不会有那个配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[core]</span><br><span class="line">	repositoryformatversion = 0</span><br><span class="line">	filemode = true</span><br><span class="line">	bare = false</span><br><span class="line">	logallrefupdates = true</span><br></pre></td></tr></table></figure>


<p>首次提交时，你需要先用以下命令添加一个远程仓库链接，然后再看<code>.git/config</code>，发现就有remote url了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git remote add origin https://github.com/zhangsan/test.git</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[core]</span><br><span class="line">	repositoryformatversion = 0</span><br><span class="line">	filemode = true</span><br><span class="line">	bare = false</span><br><span class="line">	logallrefupdates = true</span><br><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">	url = https://github.com/zhangsan/test.git</span><br><span class="line">	fetch = +refs/heads/*:refs/remotes/origin/*</span><br></pre></td></tr></table></figure>


<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; git push</span><br><span class="line">fatal: 当前分支 main 没有对应的上游分支。</span><br><span class="line">为推送当前分支并建立与远程上游的跟踪，使用</span><br><span class="line"></span><br><span class="line">    git push --set-upstream origin main</span><br></pre></td></tr></table></figure>

<p>我们按它的建议，就能成功推送到github了（其中<code>--set-upstream</code>就是我们前面说的<code>-u</code>，只不过一个是写全了，一个是简写，熟悉Linux的朋友应该知道，这种在Linux命令中很常见）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&gt; git push --set-upstream origin main</span><br><span class="line">枚举对象中: 3, 完成.</span><br><span class="line">对象计数中: 100% (3/3), 完成.</span><br><span class="line">写入对象中: 100% (3/3), 211 字节 | 211.00 KiB/s, 完成.</span><br><span class="line">总共 3（差异 0），复用 0（差异 0），包复用 0</span><br><span class="line">To https://github.com/zhangsan/test.git</span><br><span class="line"> * [new branch]      main -&gt; main</span><br><span class="line">分支 &#x27;main&#x27; 设置为跟踪来自 &#x27;origin&#x27; 的远程分支 &#x27;main&#x27;。</span><br></pre></td></tr></table></figure>

<p>此时再看<code>.git/config</code>中的内容，可以看到，已经多了一个branch配置，它的值是<code>main</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[core]</span><br><span class="line">	repositoryformatversion = 0</span><br><span class="line">	filemode = true</span><br><span class="line">	bare = false</span><br><span class="line">	logallrefupdates = true</span><br><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">	url = https://github.com/zhangsan/test.git</span><br><span class="line">	fetch = +refs/heads/*:refs/remotes/origin/*</span><br><span class="line">[branch &quot;main&quot;]</span><br><span class="line">	remote = origin</span><br><span class="line">	merge = refs/heads/main</span><br></pre></td></tr></table></figure>

<p>此后，你再次<code>git push</code>，就不需要指定后面的参数了，只需要<code>git push</code>即可，因为它会从<code>.git/config</code>配置文件中获取默认配置。</p>
<p>它会先获取当前branch名称是main，然后再从branch中得到remote是origin，它又会根据这个origin值去读取<code>[remote &quot;origin&quot;]</code> 中的url，最终向该url中推送。</p>
]]></content>
      <categories>
        <category>GIT</category>
      </categories>
      <tags>
        <tag>set-url</tag>
      </tags>
  </entry>
  <entry>
    <title>rebase -i整理commit</title>
    <url>/2020/11/10/rebase-i%E6%95%B4%E7%90%86commit/</url>
    <content><![CDATA[<p>利用 git rebase 的互动模式，可以让你简单的去调整 Commit 的顺序；或是拆分过大的 Commit；也可以刪除不必要的 Commit。</p>
<span id="more"></span>
<h2 id="什么是-Git-Rebase"><a href="#什么是-Git-Rebase" class="headerlink" title=" 什么是 Git Rebase"></a> 什么是 Git Rebase</h2><p>Git Rebase 是一個內建的 git 指令，可以用來將 Commit 重新提交到新的基礎。<br>下面這個範例中有一個 feature 分支是從 master 開出來，而 master 也有新的提交。</p>
<p>在这输入文本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">     E---F---G feature</span><br><span class="line">    /</span><br><span class="line">A---B---C---D master </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 我們可以執行在 feature 分支執行 <code>git rebase master</code>，就可以把在 feature 的 Commit 以 D 為基礎重新套用，結果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">             E&#x27;---F&#x27;---G&#x27; feature</span><br><span class="line">            /</span><br><span class="line">A---B---C---D master </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="进入互动模式"><a href="#进入互动模式" class="headerlink" title=" 进入互动模式"></a> 进入互动模式</h2><p> 在原本的指令中，加入 <code>-i</code> 或是 <code>--interactive</code> 就可以進入互動模式。</p>
<p>git rebase -i &lt;起始 Commit&gt; </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">執行後，預設會使用 vim 開啟互動模式的介面，調整完後執行 `:wq` 存擋關閉 vim，就會依照指定的指令執行。</span><br><span class="line"></span><br><span class="line">上半部未註解的部分會由上至下列出從指定的 Commit 到 HEAD 之間的所有 Commit，一行代表一個 Commit 及對應的操作，從頭依序 **操作指令**、**Hash** 及 **Commit 訊息**。</span><br><span class="line"></span><br><span class="line">下半部有註解的部分，是一些指令的簡介及縮寫，使用時就可以直接參考不用去特別記它的指令及用法。</span><br><span class="line"></span><br><span class="line">pick d34548f Add feature 1</span><br><span class="line">pick 98fb1b9 Add feature 2</span><br><span class="line">pick cbf941f Add feature 3</span><br><span class="line">pick 1499a17 Add feature 4</span><br><span class="line">pick 3e14876 Add feature 5</span><br><span class="line"></span><br><span class="line"># 重定基底 bda1985..1499a17 到 bda1985（6 個提交）</span><br><span class="line">#</span><br><span class="line"># 指令:</span><br><span class="line"># p, pick &lt;提交&gt; = 使用提交</span><br><span class="line"># r, reword &lt;提交&gt; = 使用提交，但修改提交說明</span><br><span class="line"># e, edit &lt;提交&gt; = 使用提交，進入 shell 以便進行提交修補</span><br><span class="line"># s, squash &lt;提交&gt; = 使用提交，但融合到前一個提交</span><br><span class="line"># f, fixup &lt;提交&gt; = 類似於 &quot;squash&quot;，但捨棄提交說明日誌</span><br><span class="line"># x, exec &lt;指令&gt; = 使用 shell 執行指令（此行剩餘部分）</span><br><span class="line"># b, break = 在此處停止（使用 &#x27;git rebase --continue&#x27; 繼續重定基底）</span><br><span class="line"># d, drop &lt;提交&gt; = 刪除提交</span><br><span class="line"># l, label &lt;label&gt; = 為目前 HEAD 打上標記</span><br><span class="line"># t, reset &lt;label&gt; = 重設 HEAD 到該標記</span><br><span class="line"># m, merge \[-C &lt;commit&gt; | -c &lt;commit&gt;\] &lt;label&gt; \[# &lt;oneline&gt;\]</span><br><span class="line"># .       建立一個合併提交，並使用原始的合併提交說明（如果沒有指定</span><br><span class="line"># .       原始提交，使用備註部分的 oneline 作為提交說明）。使用</span><br><span class="line"># .       -c &lt;提交&gt; 可以編輯提交說明。</span><br><span class="line">#</span><br><span class="line"># 可以對這些行重新排序，將從上至下執行。</span><br><span class="line">#</span><br><span class="line"># 如果您在這裡刪除一行，對應的提交將會遺失。</span><br><span class="line">#</span><br><span class="line"># 然而，如果您刪除全部內容，重定基底動作將會終止。 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上半部 Commit 的部分可以看到預設指令都是 <code>pick</code> (使用提交)，我們可以藉由更改這個指令來對任意的 Commit 進行編輯或刪除之類的操作。</p>
<p>需要注意的是開頭指令及 Hash 的部分，都要輸入正確否則它會無法辨識，而 Commit 訊息的部分就沒差了，不會影響執行。</p>
<p>常用的指令說明：</p>
<ul>
<li>  <code>pick</code>：預設都是這個指令，代表會使用這個 Commit。</li>
<li>  <code>reword</code>：使用這個 Commit，但是執行到此 Commit 時會開啟 vim 供更改 Commit 訊息。</li>
<li>  <code>edit</code>：使用這個 Commit，但是執行到此 Commit 時會暫停，直到執行 <code>git rebase --continue</code>。</li>
<li>  <code>squash</code>：將這個 Commit 與前一個 Commit 合併，訊息也會合併。</li>
<li>  <code>fixup</code>：與 <code>squash</code> 相同，但會捨棄這個 Commit 的訊息。</li>
<li>  <code>drop</code>：刪除這個 Commit，結果同直接刪除行。</li>
</ul>
<h2 id="範例"><a href="#範例" class="headerlink" title=" 範例"></a> 範例</h2><p>這裡將透過一個範例來展示幾個常用操作。</p>
<p>原始的 Commit 如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\* 655082e 2021-07-19 | Add feature 6 (HEAD)</span><br><span class="line">\* 69a3e14 2021-07-19 | Add feature 5-1</span><br><span class="line">\* b99b647 2021-07-19 | Add feature 4</span><br><span class="line">\* b2e9250 2021-07-19 | Add feature 5</span><br><span class="line">\* 8ad13c6 2021-07-19 | Add feature 3</span><br><span class="line">\* c3e8936 2021-07-19 | Fix feature 2 bug</span><br><span class="line">\* e4e3c6f 2021-07-19 | Add feature 2</span><br><span class="line">\* 9fa7ff7 2021-07-19 | Add feature 1</span><br><span class="line">\* bda1985 2021-07-19 | Init Commit </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需求：</p>
<ol>
<li> 交換 <code>Add feature 4</code> 及 <code>Add feature 5</code> 的順序。</li>
<li> 合併 <code>Add feature 2</code> 及 <code>Fix feature 2 bug</code> (不留訊息)。</li>
<li> 刪除 <code>Add feature 5-1</code></li>
</ol>
<h4 id="Step-1-執行-git-rebase"><a href="#Step-1-執行-git-rebase" class="headerlink" title="Step 1. 執行 git rebase"></a>Step 1. 執行 <code>git rebase</code></h4><p>執行以下指令開啟 git rebase 互動模式，並指定 Rebase <code>bda1985</code> 之後的 Commit：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rebase -i bda1985 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>執行後，將顯示以下資訊</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pick 9fa7ff7 Add feature 1</span><br><span class="line">pick e4e3c6f Add feature 2</span><br><span class="line">pick c3e8936 Fix feature 2 bug</span><br><span class="line">pick 8ad13c6 Add feature 3</span><br><span class="line">pick b2e9250 Add feature 5</span><br><span class="line">pick b99b647 Add feature 4</span><br><span class="line">pick 69a3e14 Add feature 5-1</span><br><span class="line">pick 655082e Add feature 6</span><br><span class="line"></span><br><span class="line"># 重定基底 bda1985..655082e 到 bda1985（8 個提交）</span><br><span class="line"># ... </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Step-2-交換-Add-feature-4-及-Add-feature-5-的順序"><a href="#Step-2-交換-Add-feature-4-及-Add-feature-5-的順序" class="headerlink" title="Step 2. 交換 Add feature 4 及 Add feature 5 的順序"></a>Step 2. 交換 <code>Add feature 4</code> 及 <code>Add feature 5</code> 的順序</h4><p>直接將 <code>Add feature 4</code> 及 <code>Add feature 5</code> 兩行交換順序。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pick 9fa7ff7 Add feature 1</span><br><span class="line">pick e4e3c6f Add feature 2</span><br><span class="line">pick c3e8936 Fix feature 2 bug</span><br><span class="line">pick 8ad13c6 Add feature 3</span><br><span class="line">pick b99b647 Add feature 4</span><br><span class="line">pick b2e9250 Add feature 5</span><br><span class="line">pick 69a3e14 Add feature 5-1</span><br><span class="line">pick 655082e Add feature 6</span><br><span class="line"></span><br><span class="line"># 重定基底 bda1985..655082e 到 bda1985（8 個提交） </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Step-3-合併-Add-feature-2-及-Fix-feature-2-bug"><a href="#Step-3-合併-Add-feature-2-及-Fix-feature-2-bug" class="headerlink" title="Step 3. 合併 Add feature 2 及 Fix feature 2 bug"></a>Step 3. 合併 <code>Add feature 2</code> 及 <code>Fix feature 2 bug</code></h4><p>為了將 <code>Fix feature 2 bug</code> 合併至 <code>Add feature 2</code>，更改 <code>Fix feature 2 bug</code> 的指令為 <code>fixup</code> (與上一個合併但不保留訊息)。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pick 9fa7ff7 Add feature 1</span><br><span class="line">pick e4e3c6f Add feature 2</span><br><span class="line">fixup c3e8936 Fix feature 2 bug</span><br><span class="line">pick 8ad13c6 Add feature 3</span><br><span class="line">pick b99b647 Add feature 4</span><br><span class="line">pick b2e9250 Add feature 5</span><br><span class="line">pick 69a3e14 Add feature 5-1</span><br><span class="line">pick 655082e Add feature 6</span><br><span class="line"></span><br><span class="line"># 重定基底 bda1985..655082e 到 bda1985（8 個提交） </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Step-4-刪除-Add-feature-5-1"><a href="#Step-4-刪除-Add-feature-5-1" class="headerlink" title="Step 4. 刪除 Add feature 5-1"></a>Step 4. 刪除 <code>Add feature 5-1</code></h4><p>因為要刪除 <code>Add feature 5-1</code> 這個 Commit，所以將這一行直接移除。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pick 9fa7ff7 Add feature 1</span><br><span class="line">pick e4e3c6f Add feature 2</span><br><span class="line">fixup c3e8936 Fix feature 2 bug</span><br><span class="line">pick 8ad13c6 Add feature 3</span><br><span class="line">pick b99b647 Add feature 4</span><br><span class="line">pick b2e9250 Add feature 5</span><br><span class="line">pick 655082e Add feature 6</span><br><span class="line"></span><br><span class="line"># 重定基底 bda1985..655082e 到 bda1985（8 個提交） </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="Step-5-套用-Rebase-指令"><a href="#Step-5-套用-Rebase-指令" class="headerlink" title="Step 5. 套用 Rebase 指令"></a>Step 5. 套用 Rebase 指令</h4><p>在 Vim 中執行 <code>:wq</code> 就可以關閉互動模式，並執行 Rebase。</p>
<p>執行結果如下，可以看到已完成上面列的需求。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">\* 31d6978 2021-07-19 | Add feature 6 (HEAD -&gt; master)</span><br><span class="line">\* 5e4f588 2021-07-19 | Add feature 5</span><br><span class="line">\* 04b8a95 2021-07-19 | Add feature 4</span><br><span class="line">\* 17fc05f 2021-07-19 | Add feature 3</span><br><span class="line">\* a30783f 2021-07-19 | Add feature 2</span><br><span class="line">\* 9fa7ff7 2021-07-19 | Add feature 1</span><br><span class="line">\* bda1985 2021-07-19 | Init Commit </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="总结"><a href="#总结" class="headerlink" title=" 总结"></a> 总结</h2><p>利用 Git Rebase 的互動模式介面，可以快速的整理 Commit，讓我們的變更紀錄更容易理解。但 rebase 的操作是會變更整個歷史，要注意一點是**<code>不要在共用的分支進行 rebase</code>**，會造成其他人的歷史紀錄亂掉。</p>
]]></content>
      <categories>
        <category>GIT</category>
      </categories>
      <tags>
        <tag>rebase</tag>
      </tags>
  </entry>
  <entry>
    <title>git log使用</title>
    <url>/2020/11/09/git-log%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h2><blockquote>
<p>任何版本控制器都是用来记录代码的变动历史。这能帮助你在项目中找到谁提交了什么代码，bug在哪次提交被引入的，并且能帮助你回滚有问题的改动。但是，只是存储这些信息而不知道怎么去引导和分类，也是没有用的。这就是git log这条命令被引入的原因。</p>
</blockquote>
<span id="more"></span>

<h2 id="输出格式化"><a href="#输出格式化" class="headerlink" title="输出格式化"></a>输出格式化</h2><p>我们先来看看如何通过传入一些参数，将<code>git log</code>的输出格式化。<br>如果你不喜欢<code>git log</code>默认的格式，可以用<code>git config</code>创建一个git log的别名，The git config Command</p>
<p><code>Oneline</code><br><code>--oneline</code>参数将每次提交记录汇总成一行，默认情况下，会展示commit的id和commit信息的第一行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline</span><br><span class="line"></span><br><span class="line">0e25143 Merge branch <span class="string">&#x27;feature&#x27;</span></span><br><span class="line">ad8621a Fix a bug <span class="keyword">in</span> the feature</span><br><span class="line">16b36c6 Add a new feature</span><br><span class="line">23ad9ad Add the initial code base</span><br></pre></td></tr></table></figure>

<p><code>Decorating</code><br>很多时候需要了解每次commit的关联的分支或者是标签。<code>--decorate</code>参数会展示每次commit对象的相关信息。<br>这个参数和可以和其他参数配合使用，比如，使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline --decorate</span><br><span class="line"><span class="comment">#这个命令会对输出进行如下格式化</span></span><br><span class="line"></span><br><span class="line">0e25143 (HEAD, master) Merge branch <span class="string">&#x27;feature&#x27;</span></span><br><span class="line">ad8621a (feature) Fix a bug <span class="keyword">in</span> the feature</span><br><span class="line">16b36c6 Add a new feature</span><br><span class="line">23ad9ad (tag: v0.9) Add the initial code base</span><br></pre></td></tr></table></figure>

<p>从上面的输出可以看出，第一个commit是master分支的最后一条提交(HEAD)。第二条commit有一个叫feature的分支也指向了它。第4条commit被打上了v0.9的标签。</p>
<p>分支，标签，HEAD，commit历史几乎就是你git版本库里的信息，这个命令能让你了解项目完整的逻辑结构。</p>
<p><code>Diffs</code><br><code>git log</code>命令提供了很多参数用于展示每个commit的更改的信息。最常用的有<code>--stat</code>和<code>-p</code></p>
<p><code>--stat</code>参数将会显示每次提交中，每个文件加入和删除的行数（修改一行等同于加入一行和删除一行）。如果想要简单了解每个commit大致的改动，这个参数是很有用的。举个例子，下面这个commit中，hello.py这个文件添加了67行，删除了38行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">commit f2a238924e89ca1d4947662928218a06d39068c3</span><br><span class="line">Author: John &lt;john@example.com&gt;</span><br><span class="line">Date: Fri Jun 25 17:30:28 2014 -0500 </span><br><span class="line">Add a new feature hello.py | 105 ++++++++++++++++++++++++----------------- </span><br><span class="line">1 file changed, 67 insertion(+), 38 deletions(-)</span><br><span class="line"><span class="comment">#“+”和“-”数量显示的是添加和删除行数的占比。</span></span><br></pre></td></tr></table></figure>

<p>如果想要知道改动的详细信息，可以使用</p>
<p><code>git log -p</code><br>这个命令会将补丁的信息完整输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">commit 16b36c697eb2d24302f89aa22d9170dfe609855b</span><br><span class="line">Author: Mary &lt;mary@example.com&gt;</span><br><span class="line">Date: Fri Jun 25 17:31:57 2014 -0500 </span><br><span class="line">Fix a bug <span class="keyword">in</span> the feature</span><br><span class="line">diff --git a/hello.py b/hello.py</span><br><span class="line">index 18ca709..c673b40 100644</span><br><span class="line">--- a/hello.py</span><br><span class="line">+++ b/hello.py</span><br><span class="line">@@ -13,14 +13,14 @@ B</span><br><span class="line">-<span class="built_in">print</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">+<span class="built_in">print</span>(<span class="string">&quot;Hello, Git!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>如果提交中包含了大量改动，输出信息可能会很长并且很复杂。通常，你会在完整的补丁信息中寻找特定的改动，这种情况下，可以使用pickaxe参数。</p>
<p><code>Shortlog</code><br><code>git shortlog</code>是<code>git log</code>的一个特别版本，用于生成发布的通告。它会将每个开发者提交的信息汇总，并且展示出来。使用这个命令可以可以很快看到各自做的事情。<br>举个例子，如果两个开发者提交了5次commit，<code>git shortlog</code>会输出这样的信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Mary (2): </span><br><span class="line">    Fix a bug <span class="keyword">in</span> the feature </span><br><span class="line">    Fix a serious security hole <span class="keyword">in</span> our framework</span><br><span class="line">John (3): </span><br><span class="line">    Add the initial code base </span><br><span class="line">    Add a new feature </span><br><span class="line">    Merge branch <span class="string">&#x27;feature&#x27;</span></span><br></pre></td></tr></table></figure>
<p><code>git shortlog</code>默认会按提交者名字排序，也可以传入<code>-n</code>参数按每个人的提交次数排序</p>
<p><code>Graphs</code><br><code>--graph</code> 参数会根据分枝提交历史绘出图像。这个命令通常和<code>--oneline</code>，<code>--decorate</code>一起使用</p>
<p><code>git log --graph --oneline --decorate</code><br>如果版本库中有两个分支，会有如下输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">* 0e25143 (HEAD, master) Merge branch <span class="string">&#x27;feature&#x27;</span></span><br><span class="line">|\ </span><br><span class="line">| * 16b36c6 Fix a bug <span class="keyword">in</span> the new feature</span><br><span class="line">| * 23ad9ad Start a new feature</span><br><span class="line">* | ad8621a Fix a critical security issue</span><br><span class="line">|/ </span><br><span class="line">* 400e4b7 Fix typos <span class="keyword">in</span> the documentation</span><br><span class="line">* 160e224 Add the initial code base</span><br></pre></td></tr></table></figure>
<p>*号的意思是commit在哪个分支上，所以上面的图像告诉我们23ad9ad和16b36c6者两个commit提交在了topic分支上，其他的commit提交在master分支上。</p>
<h2 id="自定义格式化"><a href="#自定义格式化" class="headerlink" title="自定义格式化"></a>自定义格式化</h2><p>可以使用<code>--pretty=format:&quot;&lt;string&gt;&quot;</code>来自定义输出的格式。输出格式有点像printf中的占位符。<br>举个例子，下面的命令中，%cn,%h和%cd会被提交者姓名，commit的hash缩写，提交的日期占据</p>
<p><code>git log --pretty=format:&quot;%cn committed %h on %cd&quot;</code><br>这会产生如下的输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">John committed 400e4b7 on Fri Jun 24 12:30:04 2014 -0500</span><br><span class="line">John committed 89ab2cf on Thu Jun 23 17:09:42 2014 -0500</span><br><span class="line">Mary committed 180e223 on Wed Jun 22 17:21:19 2014 -0500</span><br><span class="line">John committed f12ca28 on Wed Jun 22 13:50:31 2014 -0500</span><br></pre></td></tr></table></figure>
<p>占位符的说明可以在 <code>Pretty Formats</code>找到。</p>
<p>需要将git log信息重定向作为其他命令的输出时，这个命令尤其有用。</p>
<h2 id="过滤提交提交历史"><a href="#过滤提交提交历史" class="headerlink" title="过滤提交提交历史"></a>过滤提交提交历史</h2><p>格式化输出只是git log强大功能的一部分。git log还能够根据需求筛选commit。下面就来看看这部分的功能，上面提交的格式化功能也可以配合这部分使用。</p>
<p><strong>根据数量过滤</strong><br>最基本的过滤就是限制输出的commit个数。如果你只对最近的几次commit感兴趣，就不用讲所有commit历史输出。</p>
<p>使用<code>-&lt;n&gt;</code>参数可以做到这一点。举个例子，下面的命令只输出最近3条提交</p>
<p><code>git log -3</code></p>
<p><strong>根据日期过滤</strong><br>如果想找特定时间段的提交记录，可以使用<code>--after</code>或者是<code>--before</code>参数。这两个参数接受很多种日期格式，举个例子，下面的命令只显示2014年7月1号后的提交</p>
<p><code>git log --after=&quot;2014-7-1&quot;</code><br>也可以传入相对的时间概念，像”1 week ago”，或者是”yesterday”</p>
<p><code>git log --after=&quot;yesterday&quot;</code><br>如果想找某个时间区间的提交记录，可以同时传入<code>--before</code>和<code>--after</code>参数。<br>举个例子，可以用下面的命令找到2014年7月1号到4号之间的提交。</p>
<p><code>git log --after=&quot;2014-7-1&quot; --before=&quot;2014-7-4&quot;</code><br><code>--since</code>，<code>--until</code>和<code>--after</code>，<code>--before</code>是同义的</p>
<p><strong>按照提交者过滤</strong><br>如果想找某个开发者提交的commit，可以使用<code>--auther</code>参数，传入一个正则表达式，返回所有符合表达式的开发者提交的commit。如果知道想找的人是谁，直接传入字符也可以</p>
<p><code>git log --author=&quot;John&quot;</code><br>上面的命令会筛选出所有名字里包含”John”的作者提交的commit。</p>
<p>也可以用<code>正则</code>来满足更复杂的需求，比如筛选出名字里包含了John和Mary的开发者的提交。</p>
<p><code>git log --author=&quot;John\|Mary&quot;</code></p>
<p><strong>根据commit信息过滤</strong><br>使用<code>--grep</code>可以根据commit提交的信息过滤。这个和上面的–author差不多，只不过匹配的是commit信息，比如说可以这样</p>
<p><code>git log --grep=&quot;JRA-224:&quot;</code><br>也可以使用<code>-i</code>参数忽略大小写。</p>
<p><strong>根据文件过滤</strong><br>有很多时候，你只对某个文件的改动感兴趣。传入文件路径，就能找到所有和这个文件相关的提交记录，比如，下面的命令会筛出foo.py 和bar.py相关的提交</p>
<p><code>git log -- foo.py bar.py</code><br><code>-- </code>参数是告诉<code>git log</code>，后面传入的参数是文件路径，而不是分支的名字。如果传入的文件路径不可能是分支名的话，可以省略掉它。</p>
<p><strong>根据改动过滤</strong><br>根据代码中加入或者移除的某一行代码，也能筛选出相应的commit。这个叫做pickaxe，它接受形如<code>-S&quot;&lt;string&gt;&quot;</code>的参数。如果你想知道Hello, World!这行代码是何时加入到文件中的，可以使用下面的命令</p>
<p><code>git log -S&quot;Hello, World!&quot;</code><br>如果想查找匹配某个正则表达式的代码，可以传入这样子的参数-G”<regex>“。<br>这个功能在debug的时候是很有用的，因为它能够筛选出所有影响某一行代码的提交。它甚至能告诉你这一行代码是什么时候移到另外一个文件中的</regex></p>
<p><strong>过滤Merge信息</strong><br>git log输出包含merge信息。但是，如果开发组总是把上游分支里的更新mege到feature分支，而不是将feature分支rebase到上游分支，就会在代码库中看到非常多的merge信息。<br>可以使用<code>--no-merges</code>来过滤掉这个merge信息</p>
<p><code>git log --no-merges</code><br>另一方面，如果只想看到merge信息，可以使用<code>--merges</code></p>
<p><code>git log --merges</code></p>
<h2 id="统计git提交数脚本示例"><a href="#统计git提交数脚本示例" class="headerlink" title="统计git提交数脚本示例"></a>统计git提交数脚本示例</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#使用：git clone主仓库代码，将gitstat.sh放在代码根目录下，修改AUTHOR配置，执行sh gitstat.sh</span></span><br><span class="line"><span class="comment">#生成gitstat.log</span></span><br><span class="line"></span><br><span class="line">GITSTAT_LOG=<span class="string">&quot;gitstat.log&quot;</span></span><br><span class="line">AUTHOR=<span class="string">&quot;Rma Ma&quot;</span> </span><br><span class="line">DURATION_OPS=<span class="string">&quot;--after=&quot;</span>2021-12-31<span class="string">&quot; --before=&quot;</span>2023-1-1<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="variable">$&#123;GITSTAT_LOG&#125;</span></span><br><span class="line"></span><br><span class="line">commit_num=`git <span class="built_in">log</span> <span class="variable">$&#123;DURATION_OPS&#125;</span> --author=<span class="string">&quot;<span class="variable">$&#123;AUTHOR&#125;</span>&quot;</span> --no-merges   --oneline | <span class="built_in">wc</span> -l`</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;commit num : <span class="variable">$&#123;commit_num&#125;</span>&quot;</span> &gt;&gt; <span class="variable">$&#123;GITSTAT_LOG&#125;</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span> --author=<span class="string">&quot;<span class="variable">$&#123;AUTHOR&#125;</span>&quot;</span> --no-merges <span class="variable">$&#123;DURATION_OPS&#125;</span> \</span><br><span class="line">--pretty=tformat: --numstat  | \</span><br><span class="line">awk <span class="string">&#x27;&#123;adds += $1; subs += $2; changes += $1 + $2&#125; END \</span></span><br><span class="line"><span class="string">&#123;printf &quot;added lines: %s, removed lines: %s, changed lines: %s\n&quot;, adds, subs, changes&#125;&#x27;</span> &gt;&gt; <span class="variable">$&#123;GITSTAT_LOG&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;commit info :&quot;</span> &gt;&gt; <span class="variable">$&#123;GITSTAT_LOG&#125;</span></span><br><span class="line">git <span class="built_in">log</span> --author=<span class="string">&quot;<span class="variable">$&#123;AUTHOR&#125;</span>&quot;</span> --no-merges <span class="variable">$&#123;DURATION_OPS&#125;</span>  --oneline  &gt;&gt; <span class="variable">$&#123;GITSTAT_LOG&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>呈现如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">commit num : 58</span><br><span class="line">added lines: 6099, removed lines: 1020, changed lines: 7119</span><br><span class="line">commit info :</span><br><span class="line">49542d8 commit info 1</span><br><span class="line">62d11a9 commit info 2</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>GIT</category>
      </categories>
      <tags>
        <tag>git_log</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL2 删除文件后磁盘空间不释放</title>
    <url>/2020/11/08/WSL2-%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%90%8E%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E4%B8%8D%E9%87%8A%E6%94%BE/</url>
    <content><![CDATA[<h2 id="分析原因"><a href="#分析原因" class="headerlink" title="分析原因"></a>分析原因</h2><p>不同于 <code>WSL1</code>，<code>WSL2</code> 本质上是虚拟机，所以 <code>Windows</code> 会自动创建 <code>vhdx</code> 后缀的虚拟磁盘文件作为存储。这个 <code>vhdx</code> 后缀的虚拟磁盘文件特点是可以自动扩容，但是一般不会自动缩容。一旦有很多文件把它“撑大”，即使把这些文件删除它也不会自动“缩小”。所以删除文件后还需要我们手动进行压缩才能释放磁盘空间。</p>
<span id="more"></span>

<h2 id="如何操作"><a href="#如何操作" class="headerlink" title="如何操作"></a>如何操作</h2><h3 id="找到并确定要压缩的虚拟磁盘文件"><a href="#找到并确定要压缩的虚拟磁盘文件" class="headerlink" title="找到并确定要压缩的虚拟磁盘文件"></a>找到并确定要压缩的虚拟磁盘文件</h3><p>首先，我们搜索并找到 <code>ext4.vhdx</code> 文件。</p>
<p>我的 <code>WSL2</code> 有如下的 Linux distributions：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  wsl -l -v</span><br><span class="line">  NAME                   STATE           VERSION</span><br><span class="line">* Ubuntu-20.04           Running         2</span><br><span class="line">  docker-desktop         Running         2</span><br><span class="line">  docker-desktop-data    Running         2</span><br></pre></td></tr></table></figure>

<p>我搜索到的 <code>ext4.vhdx</code> 文件路径如下：</p>
<ul>
<li>  <code>C:\Users\richa\AppData\Local\Docker\wsl\data\ext4.vhdx</code></li>
<li>  <code>C:\Users\richa\AppData\Local\Docker\wsl\distro\ext4.vhdx</code></li>
<li>  <code>C:\Users\richa\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu20.04onWindows_79rhkp1fndgsc\LocalState\ext4.vhdx</code></li>
</ul>
<p>由于我这里 <code>C</code> 盘空间不足主要是 <code>Ubuntu-20.04</code> 删除文件后 <code>ext4.vhd</code> 没有缩容引起的，所以只压缩了它的 <code>ext4.vhdx</code>。</p>
<p>如果出现删除 <code>Docker</code> 镜像、删除 <code>Docker</code> 容器后磁盘占用没有缩小，应该也可以类比操作。</p>
<h3 id="备份虚拟磁盘文件所属的-Linux-distribution（可选）"><a href="#备份虚拟磁盘文件所属的-Linux-distribution（可选）" class="headerlink" title="备份虚拟磁盘文件所属的 Linux distribution（可选）"></a>备份虚拟磁盘文件所属的 Linux distribution（可选）</h3><p>在 <code>PowerShell</code> 中执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 关闭 WSL2 中的 linux distributions</span><br><span class="line">wsl --shutdown</span><br><span class="line"># 备份指定的 Linux distribution 到指定的位置</span><br><span class="line">wsl --export Ubuntu-20.04 D:\Ubuntu-20.04.tar</span><br></pre></td></tr></table></figure>

<p>如果后续步骤出现错误，可以从备份的文件中恢复。本人后续步骤并没有出现错误，所以并没有实践恢复的操作。</p>
<p>有需要的读者可以参考：<a href="https://link.zhihu.com/?target=https://www.virtualizationhowto.com/2021/01/wsl2-backup-and-restore-images-using-import-and-export/">wsl2-backup-and-restore-images-using-import-and-export</a></p>
<h3 id="压缩虚拟磁盘文件"><a href="#压缩虚拟磁盘文件" class="headerlink" title="压缩虚拟磁盘文件"></a>压缩虚拟磁盘文件</h3><p>在 <code>PowerShell</code> 中执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 关闭 WSL2 中的 linux distributions</span><br><span class="line">wsl --shutdown</span><br><span class="line"># 运行管理计算机的驱动器的 DiskPart 命令</span><br><span class="line">diskpart</span><br></pre></td></tr></table></figure>

<p>在新打开的 <code>DiskPart</code> 命令窗口中执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 选择虚拟磁盘文件</span><br><span class="line">select vdisk file=&quot;C:\Users\rma.ma\AppData\Local\Packages\CanonicalGroupLimited.Ubuntu18.04onWindows_79rhkp1fndgsc\LocalState\ext4.vhdx&quot;</span><br><span class="line"># 压缩文件</span><br><span class="line">compact vdisk</span><br><span class="line"># 压缩完毕后卸载磁盘</span><br><span class="line">detach vdisk</span><br></pre></td></tr></table></figure>

<p>上述操作执行完毕，<code>WSL2</code> 删除文件后空出来的磁盘空间就被释放了。</p>
<h3 id="解决WSL2中Vmmem内存占用过大问题"><a href="#解决WSL2中Vmmem内存占用过大问题" class="headerlink" title="解决WSL2中Vmmem内存占用过大问题"></a>解决WSL2中Vmmem内存占用过大问题</h3><p>按下Windows + R 键，输入 %UserProfile% 并运行进入用户文件夹</p>
<p>新建文件 .wslconfig ，然后记事本编辑</p>
<p>填入以下内容并保存, memory为系统内存上限，这里我限制最大2gb，可根据自身电脑配置设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[wsl2]</span><br><span class="line">memory=2GB</span><br><span class="line">swap=0</span><br><span class="line">localhostForwarding=true</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>WSL</category>
      </categories>
      <tags>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpdump使用介绍</title>
    <url>/2020/11/08/tcpdump%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>tcpdump 是一款强大的网络抓包工具，运行在 linux 平台上。熟悉 tcpdump 的使用能够帮助你分析、调试网络数据。</p>
<span id="more"></span>
<p>要想使用很好地掌握 tcpdump， 必须对网络报文（TCP/IP 协议）有一定的了解。不过对于简单的使用来说，只要有网络基础概念就行了。</p>
<p>tcpdump 是一个很复杂的命令，想了解它的方方面面非常不易，也不值得推荐，能够使用它解决日常工作中的问题才是关键。</p>
<h2 id="列子"><a href="#列子" class="headerlink" title="列子"></a>列子</h2><p>抓取eth0 53端口udp报文：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump –i eth0 udp port 53 –s 0 –w save.pcap –v </span><br></pre></td></tr></table></figure>

<h2 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h2><h3 id="设置不解析域名提升速度"><a href="#设置不解析域名提升速度" class="headerlink" title="设置不解析域名提升速度"></a>设置不解析域名提升速度</h3><p><code>-n</code>：不把ip转化成域名，直接显示 ip，避免执行 DNS lookups 的过程，速度会快很多<br><code>-nn</code>：不把协议和端口号转化成名字，速度也会快很多。</p>
<h3 id="结果输出到文件"><a href="#结果输出到文件" class="headerlink" title="结果输出到文件"></a>结果输出到文件</h3><p><code>-w</code>: 可用于wireshark分析</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump icmp -w icmp.pcap</span><br></pre></td></tr></table></figure>

<h3 id="从文件中读取包数据"><a href="#从文件中读取包数据" class="headerlink" title="从文件中读取包数据"></a>从文件中读取包数据</h3><p><code>-r</code>: 从文件中读取数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump icmp -r icmp.pcap</span><br></pre></td></tr></table></figure>

<h3 id="控制详细内容的输出"><a href="#控制详细内容的输出" class="headerlink" title="控制详细内容的输出"></a>控制详细内容的输出</h3><p><code>-v</code>：产生详细的输出. 比如包的TTL，id标识，数据包长度，以及IP包的一些选项。同时它还会打开一些附加的包完整性检测，比如对IP或ICMP包头部的校验和。<br><code>-vv</code>：产生比-v更详细的输出. 比如NFS回应包中的附加域将会被打印, SMB数据包也会被完全解码。<br><code>-vvv</code>：产生比-vv更详细的输出。比如 telent 时所使用的SB, SE 选项将会被打印, 如果telnet同时使用的是图形界面，其相应的图形选项将会以16进制的方式打印出来</p>
<h3 id="控制时间的显示"><a href="#控制时间的显示" class="headerlink" title="控制时间的显示"></a>控制时间的显示</h3><p><code>-t</code>：在每行的输出中不输出时间<br><code>-tt</code>：在每行的输出中会输出时间戳<br><code>-ttt</code>：输出每两行打印的时间间隔(以毫秒为单位)<br><code>-tttt</code>：在每行打印的时间戳之前添加日期的打印（此种选项，输出的时间最直观）</p>
<h3 id="显示数据包的头部"><a href="#显示数据包的头部" class="headerlink" title="显示数据包的头部"></a>显示数据包的头部</h3><p><code>-x</code>：以16进制的形式打印每个包的头部数据（但不包括数据链路层的头部）<br><code>-xx</code>：以16进制的形式打印每个包的头部数据（包括数据链路层的头部）<br><code>-X</code>：以16进制和 ASCII码形式打印出每个包的数据(但不包括连接层的头部)，这在分析一些新协议的数据包很方便。<br><code>-XX</code>：以16进制和 ASCII码形式打印出每个包的数据(包括连接层的头部)，这在分析一些新协议的数据包很方便。</p>
<h3 id="过滤指定网卡的数据包"><a href="#过滤指定网卡的数据包" class="headerlink" title="过滤指定网卡的数据包"></a>过滤指定网卡的数据包</h3><p><code>-i</code>：指定要过滤的网卡接口，如果要查看所有网卡，可以 <code>-i any</code></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><code>-q</code> : 简洁地打印输出。即打印很少的协议相关信息, 从而输出行都比较简短.<br><code>-c</code> : 捕获 count 个包 tcpdump 就退出<br><code>-s</code> : tcpdump 默认只会截取前 96 字节的内容，要想截取所有的报文内容，可以使用 -s number， number 就是你要截取的报文字节数，如果是 0 的话，表示截取报文全部内容。<br><code>-S</code> : 使用绝对序列号，而不是相对序列号</p>
<h2 id="常规过滤规则"><a href="#常规过滤规则" class="headerlink" title="常规过滤规则"></a>常规过滤规则</h2><h3 id="基于IP地址过滤：host"><a href="#基于IP地址过滤：host" class="headerlink" title="基于IP地址过滤：host"></a>基于IP地址过滤：host</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump host 192.168.10.100</span><br></pre></td></tr></table></figure>
<p>数据包的 ip 可以再细分为源ip和目标ip两种</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据源ip进行过滤</span></span><br><span class="line">$ tcpdump -i eth2 src 192.168.10.100</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据目标ip进行过滤</span></span><br><span class="line">$ tcpdump -i eth2 dst 192.168.10.200</span><br></pre></td></tr></table></figure>

<h3 id="基于网段进行过滤：net"><a href="#基于网段进行过滤：net" class="headerlink" title="基于网段进行过滤：net"></a>基于网段进行过滤：net</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump net 192.168.10.0/24</span><br></pre></td></tr></table></figure>
<p>网段同样可以再细分为源网段和目标网段</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据源网段进行过滤</span></span><br><span class="line">$ tcpdump src net 192.168</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据目标网段进行过滤</span></span><br><span class="line">$ tcpdump dst net 192.168</span><br></pre></td></tr></table></figure>
<h3 id="基于端口进行过滤：port"><a href="#基于端口进行过滤：port" class="headerlink" title="基于端口进行过滤：port"></a>基于端口进行过滤：port</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump port 8088</span><br></pre></td></tr></table></figure>
<p>端口同样可以再细分为源端口，目标端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据源端口进行过滤</span></span><br><span class="line">$ tcpdump src port 8088</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据目标端口进行过滤</span></span><br><span class="line">$ tcpdump dst port 8088</span><br></pre></td></tr></table></figure>
<p>如果你想要同时指定两个端口你可以这样写</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump port 80 or port 8088</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump port 80 or 8088</span><br></pre></td></tr></table></figure>

<h3 id="基于协议进行过滤：proto"><a href="#基于协议进行过滤：proto" class="headerlink" title="基于协议进行过滤：proto"></a>基于协议进行过滤：proto</h3><p>常见的网络协议有：tcp, udp, icmp, http, ip,ipv6 等</p>
<h2 id="如何抓取到更精准的包？"><a href="#如何抓取到更精准的包？" class="headerlink" title="如何抓取到更精准的包？"></a>如何抓取到更精准的包？</h2><p>例如：只想抓取HTTP 的 POST 请求，则命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump -s 0 -A -vv <span class="string">&#x27;tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4]&#x27;</span></span><br></pre></td></tr></table></figure>
<p>具体用法如下：<br><code>tcp[n]</code>：表示 tcp 报文里 第 n 个字节<br><code>tcp[n:c]</code>：表示 tcp 报文里从第n个字节开始取 c 个字节<br>例如：<br><code>tcp[12:1]</code> 表示从报文的第12个字节（因为有第0个字节，所以这里的12其实表示的是13）开始算起取一个字节，也就是 8 个bit。查看 <a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol#TCP_segment_structure">tcp 的报文首部结构</a>，可以得知这 8 个bit 其实就是下图中的红框圈起来的位置，而在这里我们只要前面 4个bit，也就是实际数据在整个报文首部中的偏移量。<br><img src="2c2c84fde3a9e30df481d71c00ae384b454fc22c0d73a10af2a823680cd052a9.png" alt="图 1"><br><code>&amp;</code>：是位运算里的 and 操作符，比如 0011 &amp; 0010 = 0010<br><code>&gt;&gt;</code>：是位运算里的右移操作，比如 0111 &gt;&gt; 2 = 0001<br><code>0xf0</code>：是 10 进制的 240 的 16 进制表示，但对于位操作来说，10进制和16进制都将毫无意义，我们需要的是二进制，将其转换成二进制后是：11110000，这个数有什么特点呢？前面个 4bit 全部是 1，后面4个bit全部是0</p>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>tcpdump</tag>
      </tags>
  </entry>
  <entry>
    <title>wsl常用命令</title>
    <url>/2020/11/07/wsl%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h1><h2 id="列出可用的-Linux-发行版"><a href="#列出可用的-Linux-发行版" class="headerlink" title="列出可用的 Linux 发行版"></a>列出可用的 Linux 发行版</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --list --online</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p><img src="7ec56d6171fba0cf87c50f6de7c7b91acf1ae3f2f158f41d224f2292ff1875de.png" alt="图 10">  </p>
<h2 id="列出已安装的-Linux-发行版"><a href="#列出已安装的-Linux-发行版" class="headerlink" title="列出已安装的 Linux 发行版"></a>列出已安装的 Linux 发行版</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --list --verbose</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl -l -v</span><br></pre></td></tr></table></figure>
<p><img src="8910516bd8ed4d4e895e9d4783f8a8ed25359315f576169c8b6570b7a1febe42.png" alt="图 11">  </p>
<h2 id="安装特定的-Linux-发行版"><a href="#安装特定的-Linux-发行版" class="headerlink" title="安装特定的 Linux 发行版"></a>安装特定的 Linux 发行版</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --install --distribution &lt;Distribution Name&gt;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --install -d &lt;Distribution Name&gt;</span><br></pre></td></tr></table></figure>

<h2 id="删除特定的版本"><a href="#删除特定的版本" class="headerlink" title="删除特定的版本"></a>删除特定的版本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --unregister &lt;Distribution Name&gt;</span><br></pre></td></tr></table></figure>

<h2 id="启动并进入特定的版本"><a href="#启动并进入特定的版本" class="headerlink" title="启动并进入特定的版本"></a>启动并进入特定的版本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl -d &lt;Distribution Name&gt;</span><br></pre></td></tr></table></figure>

<h2 id="将-WSL-版本设置为-1-或-2"><a href="#将-WSL-版本设置为-1-或-2" class="headerlink" title="将 WSL 版本设置为 1 或 2"></a>将 WSL 版本设置为 1 或 2</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --set-version &lt;distribution name&gt; &lt;versionNumber&gt;</span><br></pre></td></tr></table></figure>

<h2 id="设置默认-WSL-版本"><a href="#设置默认-WSL-版本" class="headerlink" title="设置默认 WSL 版本"></a>设置默认 WSL 版本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --set-default-version &lt;Version&gt;</span><br></pre></td></tr></table></figure>

<h2 id="设置默认-Linux-发行版"><a href="#设置默认-Linux-发行版" class="headerlink" title="设置默认 Linux 发行版"></a>设置默认 Linux 发行版</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --set-default &lt;Distribution Name&gt;</span><br></pre></td></tr></table></figure>

<h2 id="更新-WSL"><a href="#更新-WSL" class="headerlink" title="更新 WSL"></a>更新 WSL</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --update</span><br></pre></td></tr></table></figure>

<h2 id="检查-WSL-状态"><a href="#检查-WSL-状态" class="headerlink" title="检查 WSL 状态"></a>检查 WSL 状态</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --status</span><br></pre></td></tr></table></figure>

<h2 id="Help-命令"><a href="#Help-命令" class="headerlink" title="Help 命令"></a>Help 命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --<span class="built_in">export</span> Ubuntu-20.04 d:\ubuntu20.04.tar</span><br><span class="line">wsl --<span class="built_in">export</span> Ubuntu-18.04 h:\ubuntu18.04.tar</span><br></pre></td></tr></table></figure>

<h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --import &lt;DistributionName&gt;  &lt;安装位置&gt;  &lt;tar文件名&gt;</span><br></pre></td></tr></table></figure>
<p>例如：<br>在d盘ubuntu目录下导入ubuntu20.04.tar，指定wsl2版本，则命令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --import Ubuntu-20.04 d:\Ubuntu-20.04 d:\ubuntu20.04.tar --version 2</span><br><span class="line">wsl --import Ubuntu-18.04 d:\Ubuntu-18.04 d:\ubuntu18.04.tar</span><br></pre></td></tr></table></figure>
<p><strong>导入时改变DistributionName(如Ubuntu-20.04改成Ubuntu)，会导致WSL不可用。</strong></p>
<h2 id="Ubuntu修改默认登陆用户"><a href="#Ubuntu修改默认登陆用户" class="headerlink" title="Ubuntu修改默认登陆用户"></a>Ubuntu修改默认登陆用户</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ubuntu2004.exe config --default-user root</span><br></pre></td></tr></table></figure>

<h2 id="注销发行版"><a href="#注销发行版" class="headerlink" title="注销发行版"></a>注销发行版</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --unregister Ubuntu-20.04</span><br></pre></td></tr></table></figure>

<h2 id="LxRunOffline"><a href="#LxRunOffline" class="headerlink" title="LxRunOffline"></a>LxRunOffline</h2><p>可以安装任何linux发行版，例如centos</p>
]]></content>
      <categories>
        <category>WSL</category>
      </categories>
      <tags>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title>wsl设置开机启动ssh服务</title>
    <url>/2020/11/07/wsl%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8ssh%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="安装ssh服务"><a href="#安装ssh服务" class="headerlink" title="安装ssh服务"></a>安装ssh服务</h2><p>说明:虽然已经安装了ssh服务，但是好像默认自带的不能用。所以需要先卸载再安装。</p>
<p>执行以下命令进行卸载和安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sudo apt remove openssh-server</span><br><span class="line">sudo apt install openssh-server</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>编辑ssh配置文件，/etc/ssh/sshd_config，修改的配置项如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Port 1220</span><br><span class="line">ListenAddress 0.0.0.0</span><br><span class="line"></span><br><span class="line">PermitRootLogin <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line">PasswordAuthentication <span class="built_in">yes</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>service ssh restart</code></p>
<h2 id="添加开机自启动ssh服务"><a href="#添加开机自启动ssh服务" class="headerlink" title="添加开机自启动ssh服务"></a>添加开机自启动ssh服务</h2><ol>
<li>在 Windows10 上，使用 windows + r 键，调出运行，输入 shell:startup 进入开机启动项文件夹</li>
<li>新建wsl.bat</li>
<li>添加如下内容：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\Users\rma.ma\AppData\Local\Microsoft\WindowsApps\ubuntu1804.exe run <span class="string">&quot;sudo service ssh start&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>WSL</category>
      </categories>
      <tags>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title>wsl安装Ubuntu</title>
    <url>/2020/11/07/wsl%E5%AE%89%E8%A3%85Ubuntu/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>wsl常用命令<br>wsl设置开机启动ssh服务</p>
<h2 id="查看已经安装和可安装的版本"><a href="#查看已经安装和可安装的版本" class="headerlink" title="查看已经安装和可安装的版本"></a>查看已经安装和可安装的版本</h2><p>通过<code>wsl -l -v</code>和<code>wsl -l -o</code>查看已经安装和可安装的版本，本次已Ubuntu-20.04为例做安装</p>
<span id="more"></span>
<p><img src="89215c6f60f9caf5a5f38ee811a945b01e4da2330e72059db9818db0a9f1b4ff.png" alt="图 1">  </p>
<h2 id="安装Ubuntu-20-04发行版"><a href="#安装Ubuntu-20-04发行版" class="headerlink" title="安装Ubuntu-20.04发行版"></a>安装Ubuntu-20.04发行版</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --install -d Ubuntu-20.04</span><br></pre></td></tr></table></figure>
<p><img src="81a43f49f8cb1b173ca879badc27f2759dbbf6a494d06eec9c85248927b1b9a2.png" alt="图 2">  </p>
<h2 id="设置默认登录用户为root"><a href="#设置默认登录用户为root" class="headerlink" title="设置默认登录用户为root"></a>设置默认登录用户为root</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ubuntu2004.exe config --default-user root</span><br></pre></td></tr></table></figure>
<p>设置root密码<br><img src="541acf7bef46d4c729ce79102a7f79530634818c2c5a011be37a4b245d0b7a5b.png" alt="图 3">  </p>
<h2 id="ssh登录"><a href="#ssh登录" class="headerlink" title="ssh登录"></a>ssh登录</h2><ol>
<li><p>启动并进入Ubuntu-20.04</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl -d Ubuntu-20.04</span><br></pre></td></tr></table></figure></li>
<li><p><a href="https://www.cnblogs.com/zqifa/p/12910989.html">更换apt源</a><br>sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup<br>vim /etc/apt/sources.list<br>内容如下</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#阿里云源</span></span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"><span class="comment">#清华源</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预发布软件源，不建议启用</span></span><br><span class="line"><span class="comment"># deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse</span></span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#中科大源</span></span><br><span class="line"></span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"><span class="comment">#网易163源</span></span><br><span class="line"></span><br><span class="line">deb http://mirrors.163.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>sudo apt-get update<br>sudo apt-get upgrade</p>
<ol start="3">
<li>wsl设置开机启动ssh服务</li>
</ol>
<h2 id="wsl连不上外网修复"><a href="#wsl连不上外网修复" class="headerlink" title="wsl连不上外网修复"></a>wsl连不上外网修复</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --shutdown</span><br><span class="line">netsh winsock reset</span><br><span class="line">netsh int ip reset all</span><br><span class="line">netsh winhttp reset proxy</span><br><span class="line">ipconfig /flushdns</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>重启电脑</p>
]]></content>
      <categories>
        <category>WSL</category>
      </categories>
      <tags>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title>mlx5环境安装</title>
    <url>/2020/11/06/mlx5%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>环境信息：centos7 x86_64 LINUX-5</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install python-devel lsof</span><br><span class="line">yum install -y createrepo</span><br><span class="line">yum install tk</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="安装包准备"><a href="#安装包准备" class="headerlink" title="安装包准备"></a>安装包准备</h2><p>MLNX_OFED_LINUX-5.4-1.0.3.0-rhel7.4-x86_64.tgz<br>该驱动下载官网：<a href="https://www.mellanox.com/products/infiniband-drivers/linux/mlnx_ofed">https://www.mellanox.com/products/infiniband-drivers/linux/mlnx_ofed</a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>cd /home/setup/MLNX_OFED_LINUX-5.4-3.0.3.0-rhel7.4-x86_64<br>./mlnxofedinstall –upstream-libs –dpdk –add-kernel-support<br><img src="4e802edfe5cc5c05e95ffa36e3e6dfff420d76854025737d8fb3443e86735814.png" alt="图 1">  </p>
<p>/etc/init.d/openibd restart<br><img src="29957518d473b6b6cdaa1e4480719011baf03d8227fd6f6ede00c2d4d5ec2f49.png" alt="图 2"><br><img src="1d4b811ccacdda6cc4e574bdaf079b2dc3b8f90df193afac667c9fe17038ee82.png" alt="图 3">  </p>
<p>./mlnx_add_kernel_support.sh -m /home/setup/MLNX_OFED_LINUX-5.4-3.0.3.0-rhel7.4-x86_64<br><img src="341a0189edff3f9b0067fc99d88cb0013ec896541ec2512522dc34cbb067711d.png" alt="图 4"><br><img src="e4b42ff5bc2aa8054c16240c88013b6115ebb3a25474d2243f2245d7df1d9b36.png" alt="图 5">  </p>
<p>环境安装好后会有以下文件生成<br><img src="98bea2c8977a696b56a4a749b18c5fd7090eab8c98184d163332961836a417bf.png" alt="图 6">  </p>
]]></content>
      <categories>
        <category>DPDK</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>DPDK</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux之大页内存</title>
    <url>/2020/11/06/Linux%E4%B9%8B%E5%A4%A7%E9%A1%B5%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h2 id="Linux之大页内存"><a href="#Linux之大页内存" class="headerlink" title="Linux之大页内存"></a>Linux之大页内存</h2><p>Linux通过使用大页内存来取代传统的4kb内存页面，使得管理虚拟地址数变少，加快了从虚拟地址到物理地址的映射以及通过摒弃内存页面的换入换出以提高内存的整体性能。</p>
<ul>
<li>优点1：不存在页面由于内存空间不足引起的换入换出。</li>
<li>优点2：相同的内存大小情况下，管理的虚拟地址减少，降低CPU管理内存地址压力。</li>
<li>优点3：普通内存结构，每一个页面（4K）就需要64字节进行管理。使用大页内存可以降低管理查找页面负载。</li>
<li>优点4：提高内存的整体性能。<span id="more"></span>
<h2 id="Linux之透明大页"><a href="#Linux之透明大页" class="headerlink" title="Linux之透明大页"></a>Linux之透明大页</h2></li>
</ul>
<p>由于 Huge pages 很难手动管理，而且通常需要对代码进行重大的更改才能有效的使用，因此 RHEL 6 开始引入了 Transparent Huge Pages （ THP ）， THP 是一个抽象层，能够自动创建、管理和使用传统大页。<br>大页面不是某个进程独占的，它是一个系统资源，<strong>如果透明大页面功能被打开，那么大页面会为所有进程服务</strong>。<br>Linux操作系统，<strong>默认打开了透明大页面功能</strong>（Transparent Hugepages），这个功能会使操作系统看到有大页面存在的时候，会在应用进程或者内核进程申请大块内存的时候，优先为它们分配大页面，大页面无法分配时，才会分配传统的4KB页面。</p>
<h2 id="DPDK与大页内存"><a href="#DPDK与大页内存" class="headerlink" title="DPDK与大页内存"></a>DPDK与大页内存</h2><p>DPDK程序启动，rte_eal_init初始化环境抽象层（ EAL ）时候，映射Hugepages 。<br>当系统运行一段时间后，DPDK重启时rte_eal_init初始化可能失败，报错类似如下信息：<br>EAL: No free hugepages reported in hugepages-2048kB<br>EAL: Can only reserve 927 pages from 4096 requested<br>这个问题是说，在EAL在初始化的时候，无法从操作系统的Hugepages中找到所需要的连续的大页面。<br><strong>根本原因在于当前系统开启了透明大页，大页内存被系统分配给其他程序使用了</strong>。</p>
<h2 id="查看与关闭透明大页"><a href="#查看与关闭透明大页" class="headerlink" title="查看与关闭透明大页"></a>查看与关闭透明大页</h2><p>相关命令：cat  /sys/kernel/mm/transparent_hugepage/enabled<br>echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled<br>echo never &gt; /sys/kernel/mm/transparent_hugepage/defrag</p>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>DPDK</tag>
        <tag>大页内存</tag>
        <tag>透明大页</tag>
      </tags>
  </entry>
  <entry>
    <title>内存检测之valgrind</title>
    <url>/2020/11/05/%E5%86%85%E5%AD%98%E6%A3%80%E6%B5%8B%E4%B9%8Bvalgrind/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>valgrind包含几个标准的工具，它们是：</p>
<span id="more"></span>
<p>1、memcheck</p>
<p>memcheck探测程序中内存管理存在的问题。它检查所有对内存的读/写操作，并截取所有的malloc/new/free/delete调用。因此memcheck工具能够探测到以下问题：</p>
<p>1）使用未初始化的内存</p>
<p>2）读/写已经被释放的内存</p>
<p>3）读/写内存越界</p>
<p>4）读/写不恰当的内存栈空间</p>
<p>5）内存泄漏</p>
<p>6）使用malloc/new/new[]和free/delete/delete[]不匹配。</p>
<p>2、cachegrind</p>
<p>cachegrind是一个cache剖析器。它模拟执行CPU中的L1, D1和L2 cache，因此它能很精确的指出代码中的cache未命中。如果你需要，它可以打印出cache未命中的次数，内存引用和发生cache未命中的每一行代码，每一个函数，每一个模块和整个程序的摘要。如果你要求更细致的信息，它可以打印出每一行机器码的未命中次数。在x86和amd64上，cachegrind通过CPUID自动探测机器的cache配置，所以在多数情况下它不再需要更多的配置信息了。</p>
<p>3、helgrind</p>
<p>helgrind查找多线程程序中的竞争数据。helgrind查找内存地址，那些被多于一条线程访问的内存地址，但是没有使用一致的锁就会被查出。这表示这些地址在多线程间访问的时候没有进行同步，很可能会引起很难查找的时序问题。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">valgrind --tool=memcheck --leak-check=full --show-reachable=<span class="built_in">yes</span> --trace-children=<span class="built_in">yes</span> --log-file=reportleak ./xxx</span><br></pre></td></tr></table></figure>

<p>其中./xxx代表可执行程序，执行完之后将生产日志文件reportleak，<br>注意：如果是不停止程序，那么可以通过ctrl+c停止运行；如果是后台运行程序，那么可以top查看memcheck进程的pid，通过kill -2 该pid，发送ctrl+c信号停止。<br>一定要停止才能生存完整的reportleak</p>
<h3 id="使用样例"><a href="#使用样例" class="headerlink" title="使用样例"></a>使用样例</h3><ol>
<li><p>样例代码: 代码中Leak和AvoidLeak存在内存泄漏<br><img src="4f4d3f0f999e05d2751a403ca94b51e93d2cfe2ca198e493add36f27c1be5e12.png" alt="图 20">  </p>
</li>
<li><p>编译运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">valgrind --tool=memcheck --leak-check=full --show-reachable=<span class="built_in">yes</span> --trace-children=<span class="built_in">yes</span> --log-file=reportleak ./test</span><br></pre></td></tr></table></figure>
<p>查看reportleak中definitely的日志<br><img src="b217a8cfe633d131b63f5a5fe4656e37f93e91c0151b2b86e52e274289e3a51b.png" alt="图 21">  </p>
</li>
</ol>
<h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><p>valgrind 的好处是不用编译应用程序即可进行内存泄漏的检测，而且内存泄漏无处遁形，上述相同的测试程序使用tcmalloc无法报出Leak的内存泄漏</p>
<p>然而valgrind 太过于庞大，对机器硬件性能要求较高，在目前8核的机器上使用valgrind 会导致CPU飙高</p>
]]></content>
      <categories>
        <category>内存检测</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>内存检测</tag>
        <tag>valgrind</tag>
      </tags>
  </entry>
  <entry>
    <title>内存检测之asan</title>
    <url>/2020/11/04/%E5%86%85%E5%AD%98%E6%A3%80%E6%B5%8B%E4%B9%8Basan/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>addressSanitizer主要包括两部分：插桩(Instrumentation)和动态运行库(Run-time library)。    </p>
<span id="more"></span>
<p>插桩主要是针对在llvm编译器级别对访问内存的操作(store，load，alloca等)，将它们进行处理。<br>动态运行库主要提供一些运行时的复杂的功能(比如poison/unpoison shadow memory)以及将malloc,free等系统调用函数hook住。<br>该算法的思路是：如果想防住Buffer Overflow漏洞，只需要在每块内存区域右端（或两端，能防overflow和underflow）加一块区域（RedZone），使RedZone的区域的影子内存（Shadow Memory)设置为不可写即可。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ul>
<li>GCC版本4.8以及以上</li>
<li>安装asan动态库(libasan)</li>
<li>编译参数加上 -fsanitize=address -fno-omit-frame-pointer –g</li>
<li>运行程序，查看结果</li>
</ul>
<h2 id="使用样例"><a href="#使用样例" class="headerlink" title="使用样例"></a>使用样例</h2><ul>
<li><p>样例代码: 代码存在内存泄漏<br><img src="74b8a5a4910de02d7b8c993258ad787fcb32996313ef3cee0e2fd49e2f893f89.png" alt="图 10"></p>
</li>
<li><p>编译运行<br><img src="17b5883dc069c8c32892d589d2c9273eaf8124babca0590e2e5933689c15ada7.png" alt="图 11"></p>
</li>
<li><p>样例代码: 代码存在内存越界<br><img src="b92b03582a8c04de6737c16ec405f89fac0f399f3d068a802f478846ddc29634.png" alt="图 12"></p>
</li>
<li><p>编译运行<br><img src="5a57213a417566f56b5a0e91af3a8add8f4f77a95671a5830a807a5e4a97bc53.png" alt="图 13"></p>
</li>
</ul>
<h1 id="AddressSanitizer能检测的错误"><a href="#AddressSanitizer能检测的错误" class="headerlink" title="AddressSanitizer能检测的错误"></a>AddressSanitizer能检测的错误</h1><p><img src="40fd715d333285db18a8d99dd4fa300f9f8105a6b0b3d80ceb78aeb4397aaa77.png" alt="图 14"></p>
<h1 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h1><p>Asan目前能定位绝大都部分的内存越界；但是对于一些特殊情况下的越界访问好像是无法定位的；例如下面的场景</p>
<p><img src="9871fbda3864c971db9013d26118f10f0cefc0081f03aa6b6eb0f8aae87427f0.png" alt="图 15"></p>
<p>编译运行后，asan工具无法很好的抛出异常<br><img src="b8f42ac1161a0a1ab95e8f6bee047502485ba41942a947391067d3413c3a15d3.png" alt="图 16"><br>即，asan无法定位分配的有效内存内的越界，例如内存池或者结构体等，在连续有效的内存内哪怕一个成员覆盖了相邻成员的内存。</p>
]]></content>
      <categories>
        <category>内存检测</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>内存检测</tag>
        <tag>asan</tag>
      </tags>
  </entry>
  <entry>
    <title>内存检测之TCMalloc</title>
    <url>/2020/11/03/%E5%86%85%E5%AD%98%E6%A3%80%E6%B5%8B%E4%B9%8Btcmalloc/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>TCMalloc就是一个内存分配器，管理堆内存，主要影响malloc和free，用于降低频繁分配、释放内存造成的性能损耗，并且有效地控制内存碎片。</p>
<span id="more"></span>
<p>glibc中的内存分配器是ptmalloc2，tcmalloc号称要比它快。<br>一次malloc和free操作，ptmalloc需要300ns，而tcmalloc只要50ns。<br>同时tcmalloc也优化了小对象的存储，需要更少的空间。<br>tcmalloc特别对多线程做了优化，对于小对象的分配基本上是不存在锁竞争，而大对象使用了细粒度、高效的自旋锁（spinlock）。<br>分配给线程的本地缓存，在长时间空闲的情况下会被回收，供其他线程使用，这样提高了在多线程情况下的内存利用率，不会浪费内存，而这一点ptmalloc2是做不到的。<br> <br>TCMalloc除了解决内存碎片，提升申请释放效率，还包含了一个堆检查器以及一个堆测量器，用于检测程序内存泄漏。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol>
<li><p>tcmalloc库安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install libgoogle-perftools-dev</span><br></pre></td></tr></table></figure></li>
<li><p>安装pprof工具</p>
<ul>
<li>安装autotools工具包<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install autotools-dev m4 autoconf2.13 autoconf-archive gnu-standards autoconf-doc libtool autoconf</span><br></pre></td></tr></table></figure></li>
<li>源码下载 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:gperftools/gperftools.git</span><br></pre></td></tr></table></figure></li>
<li>进入gperftools目录执行./autogen.sh</li>
<li>./configure &amp;&amp; make &amp;&amp; make install</li>
<li>查看pprof是否安装成功<br><img src="b8ad9413113be96825243c343f1785e1b45ffe3934604b0e23d948aa0cc9e59c.png" alt="图 7">  </li>
</ul>
</li>
<li><p>测试程序验证</p>
<ul>
<li>编译链接时添加-ltcmalloc</li>
<li>env HEAPCHECK=normal PPROF_PATH=/usr/local/bin/pprof ./test<br><img src="5d929d3cf8389aada4f8273a654e4d0a7dbe5a913cc4701d06d2b54a00324921.png" alt="图 8">  </li>
<li>参数说明:<br><img src="368850a3ea956629e4abd887c9282def0d08c00238af402bb51e5fd473e7ad23.png" alt="图 9">  </li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>内存检测</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>内存检测</tag>
        <tag>TCMalloc</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode如何优雅的显示大纲</title>
    <url>/2020/10/27/vscode%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E6%98%BE%E7%A4%BA%E5%A4%A7%E7%BA%B2/</url>
    <content><![CDATA[<h2 id="内置大纲"><a href="#内置大纲" class="headerlink" title="内置大纲"></a>内置大纲</h2><p>vscode 内置的大纲可以帮助我们理清代码层级。在设置<strong>跟随光标</strong>后还可以自动展开节点，清楚地看到代码上下文的结构。<br>但它有个缺点， 节点不会自己折叠，造成大纲只会越来越长。</p>
<span id="more"></span>
<p><img src="2bb6e7220bffcb46bf2ed064fcce7b3b7fd6fa398d9cdf5df93189515d4f77ea.png" alt="图 1">  </p>
<p>实际上，在同级作用域中显示变量和函数并不能帮助我们理解我们关注的代码的组织。<br>vscode 内置的缩略地图 minimap 提供了源代码的高层级概述，这对快速导航和理解代码很有用。<br>但是，小屏幕的用户可能只能将缩略图作为大号的彩色滚动条。</p>
<p>为什么不把二者的优点结合起来呢？</p>
<h2 id="Outline-Map"><a href="#Outline-Map" class="headerlink" title="Outline Map"></a>Outline Map</h2><p>可视，可互动的大纲地图，提供大纲的清晰条理与缩略地图的直观概览</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p><strong>跟随光标</strong><br>高亮光标所在位置。</p>
<p>高亮编辑器可见区域。</p>
<p>自动展开编辑器视图中可见的作用域， 折叠不可见的作用域，保持清晰的层级。<br><img src="4605c9451918be66cb14a2aa9c41ac7c52ffcc121792c0d99b9822b72c72a76a.png" alt="图 2">  </p>
<p><strong>快速导航</strong><br>点击节点即可跳转，正如大纲中的那样。<br><img src="879658d6c56b3fdafbe447346f1d34414c92b52ca3033faf9990a09354b205de.png" alt="图 3">  </p>
<p><strong>标记诊断信息</strong><br><img src="78103a712162b947bff0c1ce429acbcc161c60ef211fb8abc65a03f987691f7a.png" alt="图 4">  </p>
<p><strong>自定义颜色主题</strong></p>
<p>设置<code>outline-map.color</code></p>
<p><img src="3d47664c20bcfdb371ab5646cc8a31c3ddc3f12f19332412a8248517e9fac68c.png" alt="图 5">  </p>
<p><strong>自动减少缩进</strong></p>
<p>设置 <code>outline-map.enableAutomaticIndentReduction: true</code><br><img src="b81d20034bc31d39c24ceb1e9429edef9ad9976dcf5eb0e1097b1a1c8e69aa94.png" alt="图 6">  </p>
<p><strong>固定📌大纲</strong></p>
<p><img src="97fe644af1925c45ba6204c4562e64ded7c9ae187b0d66f0385addd2c9fa0fe2.png" alt="图 7">  </p>
<p><strong>手动展开</strong></p>
<p><img src="568487cd751b293ce009556601d6b5a3d60be8e709c47ef30804ec7ff5bbdaf9.png" alt="图 8">  </p>
<p><strong>增加/减少最大深度</strong><br><img src="bda8b52eb31f7023c49404badfb681758404dceac9fe6d10ef72e107ad8bcd0c.png" alt="图 9">  </p>
]]></content>
      <categories>
        <category>VSCODE</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>settings-sync同步vscode配置</title>
    <url>/2020/10/27/settings-sync%E5%90%8C%E6%AD%A5vscode%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="配置同步：将自己本地的配置云同步到-GitHub"><a href="#配置同步：将自己本地的配置云同步到-GitHub" class="headerlink" title="配置同步：将自己本地的配置云同步到 GitHub"></a>配置同步：将自己本地的配置云同步到 GitHub</h2><ol>
<li><p>安装插件 settings-sync</p>
</li>
<li><p>安装完插件后，在插件里使用 GitHub 账号登录</p>
</li>
<li><p>登录后在 vscode 的界面中，可以选择一个别人的 gist；也可以忽略掉，然后创建一个属于自己的 gist</p>
</li>
<li><p>使用快捷键 「Command + Shift + P」，在弹出的命令框中输入 sync，并选择「更新/上传配置」，这样就可以把最新的配置上传到 GitHub</p>
<span id="more"></span>
<h2 id="管理同步：（换另外一个电脑时，从云端同步配置到本地）"><a href="#管理同步：（换另外一个电脑时，从云端同步配置到本地）" class="headerlink" title="管理同步：（换另外一个电脑时，从云端同步配置到本地）"></a>管理同步：（换另外一个电脑时，从云端同步配置到本地）</h2></li>
<li><p>当我们换另外一台电脑时，可以先在 VS Code 中安装 settings-sync 插件</p>
</li>
<li><p>安装完插件后，在插件里使用 GitHub 账号登录</p>
</li>
<li><p>登录之后，插件的界面上，会自动出现之前的同步记录：<br><img src="3c26e5a5e56f386ea70dafd7f60d5a822d9599946e1750b6b165739b797d969d.png" alt="图 5">  </p>
</li>
<li><p>上图中，我们点击最新的那条记录，就可将云端的最新配置同步到本地：<br><img src="a0101f018a94c658d2ecba2b99de840513e76f78fbfb401e4fde4f6cf4ffc564.png" alt="图 6">  </p>
</li>
<li><p>如果你远程的配置没有成功同步到本地，那可能是网络的问题，此时，可以使用快捷键 「Command + Shift + P」，在弹出的命令框中输入 sync，并选择「下载配置」，多试几次</p>
</li>
</ol>
<h2 id="使用其他人的配置"><a href="#使用其他人的配置" class="headerlink" title="使用其他人的配置"></a>使用其他人的配置</h2><p>如果我们想使用别人的配置，首先需要对方提供给你 gist。具体步骤如下：</p>
<ol>
<li>安装插件 settings-sync。</li>
<li>使用快捷键 「Command + Shift + P」，在弹出的命令框中输入 sync，并选择「下载配置」</li>
<li>在弹出的界面中，选择「Download Public Gist」，然后输入别人分享给你的 gist。注意，这一步不需要登录 GitHub 账号。</li>
</ol>
]]></content>
      <categories>
        <category>VSCODE</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode 中TODO的使用</title>
    <url>/2020/10/26/vscode-%E4%B8%ADTODO%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>关于在vscode中想标识一些未完成的事件。推荐大家一款非常方便的插件。<br>我们先打开vscode软件，先在扩展中搜索todo插件</p>
<span id="more"></span>
<h2 id="安装TODO-Highlight"><a href="#安装TODO-Highlight" class="headerlink" title="安装TODO Highlight"></a>安装TODO Highlight</h2><p><img src="b5946132aba47eef30b53a79429b8e2d90539f4f4b298baf3f09ca916a185297.png" alt="图 1">  </p>
<h2 id="安装Todo-Tree"><a href="#安装Todo-Tree" class="headerlink" title="安装Todo Tree"></a>安装Todo Tree</h2><p><img src="e405f7816e0ead47ca536f929fd270b28a66b3dd6761c07c93f4207d0716bb5b.png" alt="图 2">  </p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>点击侧边栏Todo Tree，如下图标<br><img src="909b7dbe5d928a5e8b6968c925a0f26b6ff34d8a9570391b56ac55a25b6f2b34.png" alt="图 3"><br>如下图，显示代办事项<br><img src="efe3b59a96b586c4615b98240218df831488f7b1121d4e660a706b782736fbb9.png" alt="图 4">  </p>
]]></content>
      <categories>
        <category>VSCODE</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux小工具</title>
    <url>/2020/10/25/Linux%E5%B0%8F%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="w"><a href="#w" class="headerlink" title="w"></a>w</h2><p>可以查看当前登陆系统的用户有哪些</p>
<span id="more"></span>
<h2 id="nmon"><a href="#nmon" class="headerlink" title="nmon"></a>nmon</h2><p>nmon 是一个可以监控当前系统性能的小工具， 可以查看网络、CPU、内存和磁盘的使用情况<br><a href="https://blog.csdn.net/qq_35304570/article/details/81351065">下载及安装地址</a><br><img src="7412cebccfaa9dcfcfb8949d91a8bc1c328a30575b5cb9a654df8f6128293eca.png" alt="图 1">  </p>
<ul>
<li>按键“c”可以查看CPU相 关信息;</li>
<li>“m”对应内存、“n”对应网络;</li>
<li>按键“d”可以查看磁盘信息;</li>
<li>按键“t”可以查看系统的进程信息，h是帮助等等；<br><img src="0f372c8376114a6a7d5b8f69a311381262922683addbd7b178d99cf8348df8ee.png" alt="图 2">  </li>
</ul>
<h2 id="ncdu"><a href="#ncdu" class="headerlink" title="ncdu"></a>ncdu</h2><p>ncdu 命令可以用来查看和分析 Linux 中各目录对磁盘空间占用情况的工具<br>执行 命令  ncdu /home/alipms</p>
<ul>
<li>分析完成后，会生成类似如下截图的输出。</li>
<li><a href="http://blog.51cto.com/daxionglaiba/1828379">下载及安装地址</a></li>
</ul>
<p> <img src="b0e3db3c71edf8969fc99b30c4d601ac3a5dfee64a7780247710c3ca70305811.png" alt="图 3">  </p>
<h2 id="findmnt"><a href="#findmnt" class="headerlink" title="findmnt"></a>findmnt</h2><p>是一个 Linux 内置的命令行工具，它主要用于查找挂载的文件系统状态。Findmnt 可以查看到当前系统中已挂载的设备，在必要时还可进行 mount 或 umount 操作<br><img src="89dcb4566e506c15bb4a169ae465f7bfe31ee003ac1df04c821b706fa362a42f.png" alt="图 4">  </p>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux系统启动过程</title>
    <url>/2020/10/24/linux%E7%B3%BB%E7%BB%9F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="1-上电加载BIOS"><a href="#1-上电加载BIOS" class="headerlink" title="1. 上电加载BIOS"></a><strong>1. 上电加载BIOS</strong></h2><span id="more"></span>

<p>首先肯定是上电，当按下计算机的电源，计算机就会首先加载<strong>BIOS</strong>系统，<strong>BIOS</strong>(<strong>Basic Input Output System</strong>)是基本输入输出系统，主要就是进行硬件检测，检测硬件能否满足运行的基本条件，叫做“硬件自检(<strong>Power-OnSelf-Test</strong>)”，简称<strong>POST</strong>，所以，计算机要顺利启动，就需要首先加载BIOS信息，在计算机还没加载操作系统的时候控制计算机。</p>
<p><strong>BIOS</strong>程序一般被存放在主板ROM(只读存储芯片)中，即使关机或掉电，该程序也不会丢失。</p>
<h2 id="2-加载MBR到内存"><a href="#2-加载MBR到内存" class="headerlink" title="2. 加载MBR到内存"></a><strong>2. 加载MBR到内存</strong></h2><p>在<strong>BIOS</strong>程序的最后，将会指向计算机硬盘的<strong>MBR</strong>(<strong>Master Boot Record</strong>)主引导扇区，就是启动盘的第一个扇区，硬盘上的<strong>MBR</strong>包含基本的Boot Loader(446字节)和一个小的分区表(64字节)及分隔标识(2字节)，它是一个512字节大小的扇区。</p>
<p>系统读取到<strong>BIOS</strong>所指向的硬盘的<strong>MBR</strong>后，就会将其load到内存(RAM)中，然后<strong>BIOS</strong>就会将控制权转交给<strong>MBR</strong>。</p>
<h2 id="3-GRUB引导"><a href="#3-GRUB引导" class="headerlink" title="3. GRUB引导"></a><strong>3. GRUB引导</strong></h2><p>在Linux资料中，被俗称<strong>GRUB</strong>的就是Boot Loader，<strong>GRUB</strong>是GRand Unified Bootloader的缩写，<strong>MBR</strong>的前446字节存放的就是<strong>GRUB</strong>程序的一部分，它是一个多重操作系统启动管理器，用来引导不同系统，<strong>GRUB</strong>是目前Linux环境中最流行的启动管理器。</p>
<p>如果你的计算机上配置了双操作系统，使用者就是在<strong>GRUB</strong>中进行选择究竟启动哪个操作系统。</p>
<p>这一步将加载grub配置，以及指定需要加载的内核版本</p>
<p>修改/etc/default/grub中GRUB_DEFAULT用于指定默认内核版本</p>
<h2 id="4-加载内核-Kernel"><a href="#4-加载内核-Kernel" class="headerlink" title="4. 加载内核(Kernel)"></a><strong>4. 加载内核(Kernel)</strong></h2><p>系统启动到这一步，首先会加载系统的<strong>Kernel</strong>，<strong>Kernel</strong>是现代操作系统的核心，直接负责管理硬件。</p>
<p>这一步将初始化pcie设备</p>
<h2 id="5-设定Inittab运行等级"><a href="#5-设定Inittab运行等级" class="headerlink" title="5. 设定Inittab运行等级"></a><strong>5. 设定Inittab运行等级</strong></h2><p>在内核加载完毕后，会启动Linux操作系统第一个守护进程init，这个进程的PID是1，所有的进程都是它的子进程。</p>
<p>通过这个进程读取/etc/inittab文件，/etc/inittab文件的作用是设定Linux的运行等级，文件内容大致如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Default runlevel. The runlevels used by RHS are:  </span><br><span class="line">#   0 - halt (Do NOT set initdefault to this)  </span><br><span class="line">#   1 - Single user mode  </span><br><span class="line">#   2 - Multiuser, without NFS (The same as 3, if you do not have networking)  </span><br><span class="line">#   3 - Full multiuser mode  </span><br><span class="line">#   4 - unused  </span><br><span class="line">#   5 - X11  </span><br><span class="line">#   6 - reboot (Do NOT set initdefault to this)  </span><br><span class="line">#   </span><br><span class="line">id:3:initdefault:  </span><br><span class="line">   </span><br><span class="line">...</span><br></pre></td></tr></table></figure>


<p>从文件内容知道Linux系统运行等级一共有7种：</p>
<blockquote>
<p>0：关机模式，运行等级为0，系统会立即关机，在系统启动后可以利用这种等级对系统进行关机操作，但是不允许将系统下次启动时的等级设定为0，否则系统将无法正常启动（启动后立即关机）。</p>
<p>1：单用户模式，类似于windows系统下的安全模式，具有ROOT权限。</p>
<p>2：无网络支持的多用户模式，顾名思义就是支持多用户登录</p>
<p>3：字符界面多用户模式，文本命令行界面，一般服务器都是此模式</p>
<p>4：保留，未使用模式</p>
<p>5：图形界面多用户模式，系统启动之后会进入到图形化桌面系统中</p>
<p>6：重新引导系统，重启模式，千万不要设置为6，和0相似。</p>
</blockquote>
<p>/etc/inittab文件内容中的设定的行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id:3:initdefault:</span><br></pre></td></tr></table></figure>

<p>表示启动的层级为3，即图形界面多用户模式。一般3和5比较常用，如果需要其它等级，可以手动修改这个值。</p>
<p>每一个运行级别都在/etc目录下有一个对应的子目录，可以指定每一个运行级别需要加载哪些程序，rcN.d的字母d是directory的意思，表示这是一个目录。</p>
<h2 id="6-加载rc-sysinit"><a href="#6-加载rc-sysinit" class="headerlink" title="6. 加载rc.sysinit"></a><strong>6. 加载rc.sysinit</strong></h2><p>读取完运行等级后，Linux系统就会运行第一个用户层进程：/etc/rc.d/rc.sysinit，该进程的功能是设定PATH变量、设定网络配置、启动/swap分区、设定/proc、系统函数和Selinux等等。</p>
<h2 id="7-启动运行级别程序"><a href="#7-启动运行级别程序" class="headerlink" title="7. 启动运行级别程序"></a><strong>7. 启动运行级别程序</strong></h2><p>根据前面设定的运行等级，系统会执行/etc/rc0.d/到/etc/rc6.d/中相应的脚本程序，来完成相应的初始化工作和启动相应的服务，都是一些服务程序。其中以<strong>S</strong>开头表示系统即将启动的程序，如果以<strong>K</strong>开头，则代表停止该服务。<strong>S</strong>和<strong>K</strong>后紧跟的数字为启动顺序编号。</p>
<p>前面提到，每一个运行级别都在/etc目录下有一个对应的子目录，但是如果每一个运行级别都要执行同一个程序，那就要每一个子目录里面都要拷贝一个这个程序进去，那这样就会有一个问题：如果要修改一个程序，修改完岂不是每一个子目录里面都要修改一遍或者都要重新拷贝一遍？  </p>
<p>所以Linux的解决办法就是每一个/etc/rcN.d目录下的文件都设为链接文件，下图中看到箭头指向/etc/init.d目录下的文件，所以实际执行的是/etc/init.d目录下的文件，只需要修改一次/etc/init.d目录下的程序就搞定了。</p>
<h2 id="8-读取rc-local文件"><a href="#8-读取rc-local文件" class="headerlink" title="8. 读取rc.local文件"></a><strong>8. 读取rc.local文件</strong></h2><p>启动完服务程序后，会读取执行/etc/rc.d/rc.local文件，我们可以对该文件设定一些关键核心业务开机自启，也就是Linux留给用户进行个性化的地方，你可以把你想要设置和启动的东西放到这里。</p>
<h2 id="9-执行-bin-login"><a href="#9-执行-bin-login" class="headerlink" title="9. 执行/bin/login"></a><strong>9. 执行/bin/login</strong></h2><p>到这里，Linux系统启动结束，最后执行/bin/login程序，启动到系统登录界面，等待用户输入用户名和密码，然后就可登录到<strong>Shell</strong>终端。</p>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode使用md</title>
    <url>/2020/10/24/vscode%E4%BD%BF%E7%94%A8md/</url>
    <content><![CDATA[<h2 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h2><ul>
<li>MarkDown All in One</li>
<li>Markdown Preview Enhanced</li>
<li>markdown image</li>
</ul>
<h2 id="markdown语法"><a href="#markdown语法" class="headerlink" title="markdown语法"></a>markdown语法</h2><p><a href="https://www.appinn.com/markdown">参考</a></p>
<span id="more"></span>

<h2 id="生成目录"><a href="#生成目录" class="headerlink" title="生成目录"></a>生成目录</h2><p>F1 搜索 content</p>
<p><img src="53cdbbd9b4026329bccfa6d18d80f44c3bf78b30cc77235dfe944309fd7e1816.png" alt="图 1"></p>
<h2 id="插入表格"><a href="#插入表格" class="headerlink" title="插入表格"></a>插入表格</h2><p>创建表格：</p>
<p>使用html</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;<span class="built_in">tr</span>&gt;</span><br><span class="line">        &lt;th&gt;班级&lt;/th&gt;&lt;th&gt;课程&lt;/th&gt;&lt;th&gt;平均分&lt;/th&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;<span class="built_in">tr</span>&gt;</span><br><span class="line">        &lt;td rowspan=<span class="string">&quot;3&quot;</span> align=<span class="string">&quot;center&quot;</span>&gt;1班&lt;/td&gt;&lt;td&gt;语文&lt;/td&gt;&lt;td&gt;95&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;<span class="built_in">tr</span>&gt;</span><br><span class="line">        &lt;td&gt;数学&lt;/td&gt;&lt;td&gt;96&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;<span class="built_in">tr</span>&gt;</span><br><span class="line">        &lt;td&gt;英语&lt;/td&gt;&lt;td&gt;92&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;<span class="built_in">tr</span>&gt;</span><br><span class="line">        &lt;td colspan=<span class="string">&quot;3&quot;</span> align=<span class="string">&quot;center&quot;</span>&gt;1班&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>

<table>
    <tr>
        <th>班级</th><th>课程</th><th>平均分</th>
    </tr>
    <tr>
        <td rowspan="3" align="center">1班</td><td>语文</td><td>95</td>
    </tr>
    <tr>
        <td>数学</td><td>96</td>
    </tr>
    <tr>
        <td>英语</td><td>92</td>
    </tr>
    <tr>
        <td colspan="3" align="center">1班</td>
    </tr>
</table>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;table align=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">	&lt;tbody&gt;</span><br><span class="line">		&lt;<span class="built_in">tr</span>&gt;</span><br><span class="line">			&lt;th&gt;Cell 1x1&lt;/th&gt;</span><br><span class="line">			&lt;th&gt;Cell 2x1&lt;/th&gt;</span><br><span class="line">			&lt;th&gt;Cell 3x1&lt;/th&gt;</span><br><span class="line">		&lt;/tr&gt;</span><br><span class="line">		&lt;<span class="built_in">tr</span>&gt;</span><br><span class="line">			&lt;td&gt;Cell 1x2&lt;/td&gt;</span><br><span class="line">			&lt;td&gt;Cell 2x2&lt;/td&gt;</span><br><span class="line">			&lt;td&gt;Cell 3x2&lt;/td&gt;</span><br><span class="line">		&lt;/tr&gt;</span><br><span class="line">	&lt;/tbody&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>
<table align="center">
    <tbody>
        <tr>
            <th>Cell 1x1</th>
            <th>Cell 2x1</th>
            <th>Cell 3x1</th>
        </tr>
        <tr>
            <td>Cell 1x2</td>
            <td>Cell 2x2</td>
            <td>Cell 3x2</td>
        </tr>
    </tbody>
</table>

<h2 id="水平线"><a href="#水平线" class="headerlink" title="水平线"></a>水平线</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">___</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">**This is bold text**</span><br><span class="line"></span><br><span class="line">__This is bold text__</span><br><span class="line"></span><br><span class="line">*This is italic text*</span><br><span class="line"></span><br><span class="line">_This is italic text_</span><br><span class="line"></span><br><span class="line">~~Strikethrough~~</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><strong>This is bold text</strong></p>
<p><strong>This is bold text</strong></p>
<p><em>This is italic text</em></p>
<p><em>This is italic text</em></p>
<p><del>Strikethrough</del></p>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>开头使用```bash/python/c/c++/go</p>
<p>结尾使用```</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$i</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := <span class="number">0</span></span><br><span class="line">b := <span class="keyword">map</span>()</span><br></pre></td></tr></table></figure>

<h2 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h2><p>正文中的代码 <code>uname -a</code></p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>输入数字，加一个句点，然后空格即可</p>
<ol>
<li>列表1</li>
<li>列表2</li>
<li>列表3</li>
</ol>
<h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>输入 - ,然后空格</p>
<ul>
<li>列表1</li>
<li>列表2</li>
<li>列表3</li>
</ul>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p><a href="https://www.helloworld.net/html2md">https://www.helloworld.net/html2md</a></p>
]]></content>
      <categories>
        <category>VSCODE</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode常用插件和设置</title>
    <url>/2020/10/24/vscode%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%92%8C%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p><strong>说明</strong>：插件并非全局生效，有的插件需要在wsl/ssh中另装</p>
<span id="more"></span>
<h3 id="语言插件"><a href="#语言插件" class="headerlink" title="语言插件"></a>语言插件</h3><ol>
<li><p>c/c++<br>C/C++ Extension Pack</p>
</li>
<li><p>shell<br>补全： shellman<br>右键运行：Code Runner<br>格式化： shell-format、手动下载shfmt_v3.3.1_linux_amd64</p>
</li>
<li><p>go<br>go<br>安装go Install/Update Tools<br><img src="a96b3fea0c6428186f35e1214660ae10b9e2e7ecdef2d20a291c957da4e0b040.png" alt="图 10">  </p>
</li>
<li><p>python<br>Python</p>
</li>
<li><p>rust<br>rust-analyzer<br>TabNine</p>
</li>
</ol>
<h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>Git History<br>compareit<br>Git Graph<br>GitLens</p>
<h3 id="远程"><a href="#远程" class="headerlink" title="远程"></a>远程</h3><p>Remote - SSH<br>WSL</p>
<h3 id="md"><a href="#md" class="headerlink" title="md"></a>md</h3><p>MarkDown All in One<br>Markdown Preview Enhanced<br>markdown image</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>高亮：highlight-words<br>大纲：Outline Map<br>待办：Todo Tree<br>统计：VS Code Counter<br>AI: ChatGPT – EasyCode</p>
<h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><p><strong>说明</strong>：全局生效</p>
<h3 id="搜索内容不全"><a href="#搜索内容不全" class="headerlink" title="搜索内容不全"></a>搜索内容不全</h3><p>设置，搜索Use Ignore Files，取消勾选，重载vscode</p>
<h3 id="光标离开后保存文件"><a href="#光标离开后保存文件" class="headerlink" title="光标离开后保存文件"></a>光标离开后保存文件</h3><p>设置搜索auto save，选择onFocusChange<br><img src="e8ef5767321296703101e079e053c385ae44d2b408447dd6b8fc0a260dd8a216.png" alt="图 5">  </p>
<h3 id="大小写转换快捷键"><a href="#大小写转换快捷键" class="headerlink" title="大小写转换快捷键"></a>大小写转换快捷键</h3><p>键盘快捷方式，搜索 转换为大写 upper， 设置快捷键ctrl+shift+u<br>搜索 转换为小写 lower， 设置快捷键ctrl+shift+l，需要先清除前面两个绑定的快捷键</p>
<h3 id="前进-后退快捷键"><a href="#前进-后退快捷键" class="headerlink" title="前进/后退快捷键"></a>前进/后退快捷键</h3><p>键盘快捷方式中搜索navigateBack navigateForward<br>设置喜欢的快捷键，我的是alt+,  alt+.</p>
<h3 id="选中即复制、右键粘贴"><a href="#选中即复制、右键粘贴" class="headerlink" title="选中即复制、右键粘贴"></a>选中即复制、右键粘贴</h3><p>设置中搜索copy on，勾选<br><img src="28523ce1b944f8a23f668683b9dc8a66069bd75b34cc3bda158e476d47524e79.png" alt="图 2"><br>设置中搜索right click，下拉选择 paste<br><img src="8d1fc2b3862c7e21a286a7e96eaa8c79ac2d0b2295c662a5d2d43453140e8b55.png" alt="图 3">  </p>
<h3 id="markdown背景设置"><a href="#markdown背景设置" class="headerlink" title="markdown背景设置"></a>markdown背景设置</h3><p>点击vscode左下角的设置图标，打开vscode设置，在搜索框输入：markdown preview enhanced: Preview theme。结果如下图：<br><img src="5ec0e46c9b911ce4ea30f5d9bb1806c0b42ce509ce6b161540642d0b0c6b8d0f.png" alt="图 1">  </p>
<h3 id="高亮设置"><a href="#高亮设置" class="headerlink" title="高亮设置"></a>高亮设置</h3><p>键盘快捷方式中搜索Highlight Toggle Current<br>设置，我的是f8，不过事先要将之前f8绑定的快捷键删除</p>
<h3 id="显示tab"><a href="#显示tab" class="headerlink" title="显示tab"></a>显示tab</h3><p>设置，搜索renderWhitespace，下拉选择 all<br><img src="50e58a623395a9a3ae4f278c46176634779d61888c03b805ec7562218aea8557.png" alt="图 4">  </p>
<h3 id="设置tab大小为8"><a href="#设置tab大小为8" class="headerlink" title="设置tab大小为8"></a>设置tab大小为8</h3><p>设置，搜索tabSize，填写8</p>
<h3 id="设置删除一行的快捷"><a href="#设置删除一行的快捷" class="headerlink" title="设置删除一行的快捷"></a>设置删除一行的快捷</h3><p>键盘快捷方式中搜索ctrl+shift+K，<br>设置为ctrl+d</p>
<h3 id="键盘快捷取消ctrl-e"><a href="#键盘快捷取消ctrl-e" class="headerlink" title="键盘快捷取消ctrl+e"></a>键盘快捷取消ctrl+e</h3><p>键盘快捷方式中搜索ctrl+e，取消绑定</p>
<h3 id="复制代码取消背景色"><a href="#复制代码取消背景色" class="headerlink" title="复制代码取消背景色"></a>复制代码取消背景色</h3><p>设置，搜索Copy With Syntax，勾选去掉<br><img src="24e867e238923100c37ebae65f55ef5301fcafda24675ce4016f040c4bf93c0c.png" alt="图 10">  </p>
<h3 id="统计代码行"><a href="#统计代码行" class="headerlink" title="统计代码行"></a>统计代码行</h3><p>F1 在命令输入：Count lines in workspace<br><strong>注意</strong>：建议在Windows端统计，wsl统计偶现失效<br>基于语言统计：<br><img src="ab7b6207d4ee44ebcf7271f0da0a23daec2924a62269b2e576a68ee640d69832.png" alt="图 9">  </p>
<p>基于文件夹统计：<br><img src="b5af3d8e63a050ae2c42f4371bcafca762df22d8167e8a2284b05a32f4026d78.png" alt="图 8">  </p>
<h3 id="选中一列"><a href="#选中一列" class="headerlink" title="选中一列"></a>选中一列</h3><p>alt+shift+鼠标拖动</p>
<h3 id="设置proxy"><a href="#设置proxy" class="headerlink" title="设置proxy"></a>设置proxy</h3><p>设置中搜索proxy</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wsl的proxy</span><br><span class="line">http://172.28.32.1:7890</span><br></pre></td></tr></table></figure>

<p><img src="e5421b821ee700d93e0ff53f4e3573a3267914fdebd5c9bb37f672c074bb1c91.png" alt="picture 11">  </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh的proxy</span><br><span class="line">http://10.20.19.157:7890</span><br></pre></td></tr></table></figure>

<p><img src="acaab142b8745d0ac1ec99b7336b7f1d0c4f80a3cbcc14a923377933be0fed3a.png" alt="picture 10">  </p>
]]></content>
      <categories>
        <category>VSCODE</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode配置ssh</title>
    <url>/2020/10/24/vscode%E9%85%8D%E7%BD%AEssh/</url>
    <content><![CDATA[<h2 id="本机安装ssh"><a href="#本机安装ssh" class="headerlink" title="本机安装ssh"></a>本机安装ssh</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>可以使用 Windows Server 2019 和 Windows 10 设备上的 Windows 设置安装这两个 OpenSSH 组件。<br>若要安装 OpenSSH 组件：</p>
<ol>
<li>打开“设置”，选择“应用”&gt;“应用和功能”，然后选择“可选功能” 。</li>
<li>扫描列表，查看是否已安装 OpenSSH。 如果未安装，请在页面顶部选择“添加功能”，然后：</li>
</ol>
<span id="more"></span>
<ul>
<li>查找“OpenSSH 客户端”，再单击“安装”</li>
<li>查找“OpenSSH 服务器”，再单击“安装”</li>
</ul>
<p>设置完成后，回到“应用”&gt;“应用和功能”和“可选功能”，你应会看到已列出 OpenSSH<br><a href="https://learn.microsoft.com/zh-cn/windows-server/administration/openssh/openssh_install_firstuse">参考</a></p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh 或者 ssh-V</span><br></pre></td></tr></table></figure>
<h2 id="vscode安装Remote-SSH插件"><a href="#vscode安装Remote-SSH插件" class="headerlink" title="vscode安装Remote - SSH插件"></a>vscode安装Remote - SSH插件</h2><h3 id="免密登录配置"><a href="#免密登录配置" class="headerlink" title="免密登录配置"></a>免密登录配置</h3><ol>
<li><p>生成密钥对</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> C:\Users\&lt;user&gt;\.ssh</span><br><span class="line">ssh-keygen -t rsa -b 4096 -f id_rsa-remote-ssh</span><br></pre></td></tr></table></figure>
<p><img src="a67dc3712e025e8a68a003a9ab10c3a6aa362c72517926f5995162f80330d08b.png" alt="图 1">  </p>
</li>
<li><p>公钥拷贝<br>将本机的id_rsa-remote-ssh.pub拷贝到目标服务器上/root/.ssh/authorized_keys中</p>
</li>
<li><p>vscode上配置私钥<br><img src="bfeb91acdcb2cabf3a2e0c4d688410253087d5995cfe032cc96b59a56627bc0e.png" alt="图 2"><br><img src="cf206f6a63f0e331b2f3d9294e2536055e4a9cf16912421f481ccfd3f7ce1a70.png" alt="图 3"></p>
</li>
</ol>
<p><strong>注意</strong>：<br>配置后，需要reload vscode，才会出现目标服务器的选项</p>
]]></content>
      <categories>
        <category>VSCODE</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo Next主题中文Toc无法展开</title>
    <url>/2020/10/03/Hexo%20Next%E4%B8%BB%E9%A2%98%E4%B8%AD%E6%96%87Toc%E6%97%A0%E6%B3%95%E5%B1%95%E5%BC%80/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>如下图，当编辑多级标题时，在主页的侧边栏无法显示完全</p>
<span id="more"></span>
<p><img src="edd95282baee44c9f19d0e60498dca2126541ae7233bcfd8a70177864391a72d.png" alt="图 19">  </p>
<h2 id="问题修复"><a href="#问题修复" class="headerlink" title="问题修复"></a>问题修复</h2><p>在themes\next\source\css_custom\custom.styl文件中添加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">.post-toc .nav .nav-child &#123;</span><br><span class="line">   display: block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>HEXO</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>hexo故障修复</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo Next主题中文Toc无法跳转</title>
    <url>/2020/10/03/Hexo%20Next%E4%B8%BB%E9%A2%98%E4%B8%AD%E6%96%87Toc%E6%97%A0%E6%B3%95%E8%B7%B3%E8%BD%AC/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>安装 Next 主题后, 侧边栏目录中中文目录锚点点击后无法正常跳转</p>
<span id="more"></span>
<h2 id="故障描述"><a href="#故障描述" class="headerlink" title="故障描述"></a>故障描述</h2><p>如图，点击左边侧边栏无法正常跳转<br><img src="74e496c94572c1caef9b9e5f6fc755161b3fbb628194a8299880617fc7f643ee.png" alt="图 18">  </p>
<h2 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h2><p>知道是 ‘post-details.js’ 文件报错后就简单了. 阅读源码后我们发现是 targetSelector 解析 UTF8 有问题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// TOC item animation navigate &amp; prevent <span class="comment">#item selector in adress bar.</span></span><br><span class="line">$(<span class="string">&#x27;.post-toc a&#x27;</span>).on(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (e) &#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  &lt;!-- targetSelector 解析UTF8的问题 -&gt;</span><br><span class="line">  var targetSelector = NexT.utils.escapeSelector(this.getAttribute(<span class="string">&#x27;href&#x27;</span>));</span><br><span class="line">  var offset = $(targetSelector).offset().top;</span><br><span class="line"></span><br><span class="line">  hasVelocity ?</span><br><span class="line">    html.velocity(<span class="string">&#x27;stop&#x27;</span>).velocity(<span class="string">&#x27;scroll&#x27;</span>, &#123;</span><br><span class="line">      offset: offset  + <span class="string">&#x27;px&#x27;</span>,</span><br><span class="line">      mobileHA: <span class="literal">false</span></span><br><span class="line">    &#125;) :</span><br><span class="line">    $(<span class="string">&#x27;html, body&#x27;</span>).stop().animate(&#123;</span><br><span class="line">      scrollTop: offset</span><br><span class="line">    &#125;, 500);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="问题修复"><a href="#问题修复" class="headerlink" title="问题修复"></a>问题修复</h2><p>将 targetSelector 再解析一次就好了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var targetSelector = NexT.utils.escapeSelector(this.getAttribute(<span class="string">&#x27;href&#x27;</span>));</span><br><span class="line">&lt;!-- 添加下面这行代码, 重新解析 URL -&gt;</span><br><span class="line">targetSelector = decodeURI(this.getAttribute(<span class="string">&#x27;href&#x27;</span>))</span><br><span class="line">var offset = $(targetSelector).offset().top;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>HEXO</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>hexo故障修复</tag>
      </tags>
  </entry>
  <entry>
    <title>readelf</title>
    <url>/2020/09/26/readelf/</url>
    <content><![CDATA[<h2 id="readelf-elf文件格式分析"><a href="#readelf-elf文件格式分析" class="headerlink" title="readelf elf文件格式分析"></a>readelf elf文件格式分析</h2><p>这个工具和objdump命令提供的功能类似，但是它显示的信息更为具体，并且它不依赖BFD库(BFD库是一个GNU项目，它的目标就是希望通过一种统一的接口来处理不同的目标文件）</p>
<span id="more"></span>

<h2 id="ELF文件类型"><a href="#ELF文件类型" class="headerlink" title="ELF文件类型"></a>ELF文件类型</h2><p>ELF(Executable and Linking Format)是一种对象文件的格式，用于定义不同类型的对象文件(Object files)中都放了什么东西、以及都以什么样的格式去放这些东西。它自最早在 System V 系统上出现后，被 xNIX 世界所广泛接受，作为缺省的二进制文件格式来使用。可以说，ELF是构成众多xNIX系统的基础之一。<br>ELF文件有三种类型：</p>
<ol>
<li>可重定位的对象文件(Relocatable file)<br>由汇编器汇编生成的 .o 文件</li>
<li>可执行的对象文件(Executable file)<br>可执行应用程序</li>
<li>可被共享的对象文件(Shared object file)<br>动态库文件，也即 .so 文件</li>
</ol>
<ul>
<li>.text section 里装载了可执行代码；</li>
<li>.data section 里面装载了被初始化的数据；</li>
<li>.bss section 里面装载了未被初始化的数据；</li>
<li>以 .rec 打头的 sections 里面装载了重定位条目；</li>
<li>.symtab 或者 .dynsym section 里面装载了符号信息；</li>
<li>.strtab 或者 .dynstr section 里面装载了字符串信息；</li>
</ul>
<h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><p><code>-a –all</code> 全部 Equivalent to: -h -l -S -s -r -d -V -A -I<br><code>-h –file-header</code> 文件头 Display the ELF file header<br><code>-l –program-headers</code> 程序 Display the program headers<br><code>–segments</code> An alias for –program-headers<br><code>-S –section-headers</code> 段头 Display the sections’ header<br><code>--sections    </code> An alias for –section-headers<br><code>-e –headers</code> 全部头 Equivalent to: -h -l -S<br><code>-s –syms</code> 符号表 Display the symbol table<br><code>--symbols</code>    An alias for –syms<br><code>-n –notes</code> 内核注释 Display the core notes (if present)<br><code>-r –relocs</code> 重定位 Display the relocations (if present)<br><code>-u –unwind</code> Display the unwind info (if present)<br><code>-d –dynamic</code> 动态段 Display the dynamic segment (if present)<br><code>-V –version-info</code> 版本 Display the version sections (if present)<br><code>-A –arch-specific</code> CPU构架 Display architecture specific information (if any).<br><code>-D –use-dynamic</code> 动态段 Use the dynamic section info when displaying symbols<br><code>-x –hex-dump=&lt;number&gt;</code> 显示 段内内容Dump the contents of section <number><br><code>-w[liaprmfFso] or -I</code> –histogram Display histogram of bucket list lengths<br><code>-W –wide</code> 宽行输出 Allow output width to exceed 80 characters<br><code>-H –help</code> Display this information<br><code>-v –version</code> Display the version number of readelf</number></p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>想知道一个应用程序的可运行的架构平台:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$readelf</span> -h main| grep Machine</span><br></pre></td></tr></table></figure>
<p><code>-h</code>选项将显示文件头的概要信息，从里面可以看到，有很多有用的信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$readelf</span> -h main</span><br><span class="line">ELF Header:</span><br><span class="line">Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">Class:                             ELF64</span><br><span class="line">Data:                              2 s complement, little endian</span><br><span class="line">Version:                           1 (current)</span><br><span class="line">OS/ABI:                            UNIX - System V</span><br><span class="line">ABI Version:                       0</span><br><span class="line">Type:                              EXEC (Executable file)</span><br><span class="line">Machine:                           Advanced Micro Devices X86-64</span><br><span class="line">Version:                           0x1</span><br><span class="line">Entry point address:               0x400790</span><br><span class="line">Start of program headers:          64 (bytes into file)</span><br><span class="line">Start of section headers:          5224 (bytes into file)</span><br><span class="line">Flags:                             0x0</span><br><span class="line">Size of this header:               64 (bytes)</span><br><span class="line">Size of program headers:           56 (bytes)</span><br><span class="line">Number of program headers:         8</span><br><span class="line">Size of section headers:           64 (bytes)</span><br><span class="line">Number of section headers:         29</span><br><span class="line">Section header string table index: 26</span><br></pre></td></tr></table></figure>
<p>一个编译好的应用程序，想知道其编译时是否使用了-g选项（加入调试信息）:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$readelf</span> -S main| grep debug</span><br></pre></td></tr></table></figure>
<p>用-S选项是显示所有段信息；如果编译时使用了-g选项，则会有debug段;<br>未加-g时无显示<br><img src="e35e573e40be9d30fecfdc25520c6e2fb432d3c323ed63b48ad6e9754c5195b1.png" alt="图 1">  </p>
<p>添加-g时显示debug段信息<br><img src="a872fe53b83a036ba82fdb125de153f252467a30db81143bf18c496e386ff910.png" alt="图 2">  </p>
<p>查看.o文件是否编入了调试信息（编译的时候是否加了-g):</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$readelf</span> -S Shpos.o | grep debug</span><br></pre></td></tr></table></figure>

<h2 id="完整输出"><a href="#完整输出" class="headerlink" title="完整输出"></a>完整输出</h2><p>readelf输出的完整内容:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$readelf</span> -all a.out</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">  Class:                             ELF32</span><br><span class="line">  Data:                              2<span class="string">&#x27;s complement, little endian</span></span><br><span class="line"><span class="string">  Version:                           1 (current)</span></span><br><span class="line"><span class="string">  OS/ABI:                            UNIX - System V</span></span><br><span class="line"><span class="string">  ABI Version:                       0</span></span><br><span class="line"><span class="string">  Type:                              EXEC (Executable file)</span></span><br><span class="line"><span class="string">  Machine:                           Intel 80386</span></span><br><span class="line"><span class="string">  Version:                           0x1</span></span><br><span class="line"><span class="string">  Entry point address:               0x8048330</span></span><br><span class="line"><span class="string">  Start of program headers:          52 (bytes into file)</span></span><br><span class="line"><span class="string">  Start of section headers:          4412 (bytes into file)</span></span><br><span class="line"><span class="string">  Flags:                             0x0</span></span><br><span class="line"><span class="string">  Size of this header:               52 (bytes)</span></span><br><span class="line"><span class="string">  Size of program headers:           32 (bytes)</span></span><br><span class="line"><span class="string">  Number of program headers:         9</span></span><br><span class="line"><span class="string">  Size of section headers:           40 (bytes)</span></span><br><span class="line"><span class="string">  Number of section headers:         30</span></span><br><span class="line"><span class="string">  Section header string table index: 27</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Section Headers:</span></span><br><span class="line"><span class="string">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span></span><br><span class="line"><span class="string">  [ 0]                   NULL            00000000 000000 000000 00      0   0  0</span></span><br><span class="line"><span class="string">  [ 1] .interp           PROGBITS        08048154 000154 000013 00   A  0   0  1</span></span><br><span class="line"><span class="string">  [ 2] .note.ABI-tag     NOTE            08048168 000168 000020 00   A  0   0  4</span></span><br><span class="line"><span class="string">  [ 3] .note.gnu.build-i NOTE            08048188 000188 000024 00   A  0   0  4</span></span><br><span class="line"><span class="string">  [ 4] .gnu.hash         GNU_HASH        080481ac 0001ac 000020 04   A  5   0  4</span></span><br><span class="line"><span class="string">  [ 5] .dynsym           DYNSYM          080481cc 0001cc 000050 10   A  6   1  4</span></span><br><span class="line"><span class="string">  [ 6] .dynstr           STRTAB          0804821c 00021c 00004c 00   A  0   0  1</span></span><br><span class="line"><span class="string">  [ 7] .gnu.version      VERSYM          08048268 000268 00000a 02   A  5   0  2</span></span><br><span class="line"><span class="string">  [ 8] .gnu.version_r    VERNEED         08048274 000274 000020 00   A  6   1  4</span></span><br><span class="line"><span class="string">  [ 9] .rel.dyn          REL             08048294 000294 000008 08   A  5   0  4</span></span><br><span class="line"><span class="string">  [10] .rel.plt          REL             0804829c 00029c 000018 08   A  5  12  4</span></span><br><span class="line"><span class="string">  [11] .init             PROGBITS        080482b4 0002b4 00002e 00  AX  0   0  4</span></span><br><span class="line"><span class="string">  [12] .plt              PROGBITS        080482f0 0002f0 000040 04  AX  0   0 16</span></span><br><span class="line"><span class="string">  [13] .text             PROGBITS        08048330 000330 00018c 00  AX  0   0 16</span></span><br><span class="line"><span class="string">  [14] .fini             PROGBITS        080484bc 0004bc 00001a 00  AX  0   0  4</span></span><br><span class="line"><span class="string">  [15] .rodata           PROGBITS        080484d8 0004d8 000011 00   A  0   0  4</span></span><br><span class="line"><span class="string">  [16] .eh_frame_hdr     PROGBITS        080484ec 0004ec 000034 00   A  0   0  4</span></span><br><span class="line"><span class="string">  [17] .eh_frame         PROGBITS        08048520 000520 0000c4 00   A  0   0  4</span></span><br><span class="line"><span class="string">  [18] .ctors            PROGBITS        08049f14 000f14 000008 00  WA  0   0  4</span></span><br><span class="line"><span class="string">  [19] .dtors            PROGBITS        08049f1c 000f1c 000008 00  WA  0   0  4</span></span><br><span class="line"><span class="string">  [20] .jcr              PROGBITS        08049f24 000f24 000004 00  WA  0   0  4</span></span><br><span class="line"><span class="string">  [21] .dynamic          DYNAMIC         08049f28 000f28 0000c8 08  WA  6   0  4</span></span><br><span class="line"><span class="string">  [22] .got              PROGBITS        08049ff0 000ff0 000004 04  WA  0   0  4</span></span><br><span class="line"><span class="string">  [23] .got.plt          PROGBITS        08049ff4 000ff4 000018 04  WA  0   0  4</span></span><br><span class="line"><span class="string">  [24] .data             PROGBITS        0804a00c 00100c 000008 00  WA  0   0  4</span></span><br><span class="line"><span class="string">  [25] .bss              NOBITS          0804a014 001014 000008 00  WA  0   0  4</span></span><br><span class="line"><span class="string">  [26] .comment          PROGBITS        00000000 001014 00002a 01  MS  0   0  1</span></span><br><span class="line"><span class="string">  [27] .shstrtab         STRTAB          00000000 00103e 0000fc 00      0   0  1</span></span><br><span class="line"><span class="string">  [28] .symtab           SYMTAB          00000000 0015ec 000410 10     29  45  4</span></span><br><span class="line"><span class="string">  [29] .strtab           STRTAB          00000000 0019fc 0001f9 00      0   0  1</span></span><br><span class="line"><span class="string">Key to Flags:</span></span><br><span class="line"><span class="string">  W (write), A (alloc), X (execute), M (merge), S (strings)</span></span><br><span class="line"><span class="string">  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)</span></span><br><span class="line"><span class="string">  O (extra OS processing required) o (OS specific), p (processor specific)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">There are no section groups in this file.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Program Headers:</span></span><br><span class="line"><span class="string">  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align</span></span><br><span class="line"><span class="string">  PHDR           0x000034 0x08048034 0x08048034 0x00120 0x00120 R E 0x4</span></span><br><span class="line"><span class="string">  INTERP         0x000154 0x08048154 0x08048154 0x00013 0x00013 R   0x1</span></span><br><span class="line"><span class="string">      [Requesting program interpreter: /lib/ld-linux.so.2]</span></span><br><span class="line"><span class="string">  LOAD           0x000000 0x08048000 0x08048000 0x005e4 0x005e4 R E 0x1000</span></span><br><span class="line"><span class="string">  LOAD           0x000f14 0x08049f14 0x08049f14 0x00100 0x00108 RW  0x1000</span></span><br><span class="line"><span class="string">  DYNAMIC        0x000f28 0x08049f28 0x08049f28 0x000c8 0x000c8 RW  0x4</span></span><br><span class="line"><span class="string">  NOTE           0x000168 0x08048168 0x08048168 0x00044 0x00044 R   0x4</span></span><br><span class="line"><span class="string">  GNU_EH_FRAME   0x0004ec 0x080484ec 0x080484ec 0x00034 0x00034 R   0x4</span></span><br><span class="line"><span class="string">  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x4</span></span><br><span class="line"><span class="string">  GNU_RELRO      0x000f14 0x08049f14 0x08049f14 0x000ec 0x000ec R   0x1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> Section to Segment mapping:</span></span><br><span class="line"><span class="string">  Segment Sections...</span></span><br><span class="line"><span class="string">   00</span></span><br><span class="line"><span class="string">   01     .interp</span></span><br><span class="line"><span class="string">   02     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .text .fini .rodata .eh_frame_hdr .eh_frame</span></span><br><span class="line"><span class="string">   03     .ctors .dtors .jcr .dynamic .got .got.plt .data .bss</span></span><br><span class="line"><span class="string">   04     .dynamic</span></span><br><span class="line"><span class="string">   05     .note.ABI-tag .note.gnu.build-id</span></span><br><span class="line"><span class="string">   06     .eh_frame_hdr</span></span><br><span class="line"><span class="string">   07</span></span><br><span class="line"><span class="string">   08     .ctors .dtors .jcr .dynamic .got</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Dynamic section at offset 0xf28 contains 20 entries:</span></span><br><span class="line"><span class="string">  Tag        Type                         Name/Value</span></span><br><span class="line"><span class="string"> 0x00000001 (NEEDED)                     Shared library: [libc.so.6]</span></span><br><span class="line"><span class="string"> 0x0000000c (INIT)                       0x80482b4</span></span><br><span class="line"><span class="string"> 0x0000000d (FINI)                       0x80484bc</span></span><br><span class="line"><span class="string"> 0x6ffffef5 (GNU_HASH)                   0x80481ac</span></span><br><span class="line"><span class="string"> 0x00000005 (STRTAB)                     0x804821c</span></span><br><span class="line"><span class="string"> 0x00000006 (SYMTAB)                     0x80481cc</span></span><br><span class="line"><span class="string"> 0x0000000a (STRSZ)                      76 (bytes)</span></span><br><span class="line"><span class="string"> 0x0000000b (SYMENT)                     16 (bytes)</span></span><br><span class="line"><span class="string"> 0x00000015 (DEBUG)                      0x0</span></span><br><span class="line"><span class="string"> 0x00000003 (PLTGOT)                     0x8049ff4</span></span><br><span class="line"><span class="string"> 0x00000002 (PLTRELSZ)                   24 (bytes)</span></span><br><span class="line"><span class="string"> 0x00000014 (PLTREL)                     REL</span></span><br><span class="line"><span class="string"> 0x00000017 (JMPREL)                     0x804829c</span></span><br><span class="line"><span class="string"> 0x00000011 (REL)                        0x8048294</span></span><br><span class="line"><span class="string"> 0x00000012 (RELSZ)                      8 (bytes)</span></span><br><span class="line"><span class="string"> 0x00000013 (RELENT)                     8 (bytes)</span></span><br><span class="line"><span class="string"> 0x6ffffffe (VERNEED)                    0x8048274</span></span><br><span class="line"><span class="string"> 0x6fffffff (VERNEEDNUM)                 1</span></span><br><span class="line"><span class="string"> 0x6ffffff0 (VERSYM)                     0x8048268</span></span><br><span class="line"><span class="string"> 0x00000000 (NULL)                       0x0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Relocation section &#x27;</span>.rel.dyn<span class="string">&#x27; at offset 0x294 contains 1 entries:</span></span><br><span class="line"><span class="string"> Offset     Info    Type            Sym.Value  Sym. Name</span></span><br><span class="line"><span class="string">08049ff0  00000206 R_386_GLOB_DAT    00000000   __gmon_start__</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Relocation section &#x27;</span>.rel.plt<span class="string">&#x27; at offset 0x29c contains 3 entries:</span></span><br><span class="line"><span class="string"> Offset     Info    Type            Sym.Value  Sym. Name</span></span><br><span class="line"><span class="string">0804a000  00000107 R_386_JUMP_SLOT   00000000   printf</span></span><br><span class="line"><span class="string">0804a004  00000207 R_386_JUMP_SLOT   00000000   __gmon_start__</span></span><br><span class="line"><span class="string">0804a008  00000307 R_386_JUMP_SLOT   00000000   __libc_start_main</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">There are no unwind sections in this file.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Symbol table &#x27;</span>.dynsym<span class="string">&#x27; contains 5 entries:</span></span><br><span class="line"><span class="string">   Num:    Value  Size Type    Bind   Vis      Ndx Name</span></span><br><span class="line"><span class="string">     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND</span></span><br><span class="line"><span class="string">     1: 00000000     0 FUNC    GLOBAL DEFAULT  UND printf@GLIBC_2.0 (2)</span></span><br><span class="line"><span class="string">     2: 00000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__</span></span><br><span class="line"><span class="string">     3: 00000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2.0 (2)</span></span><br><span class="line"><span class="string">     4: 080484dc     4 OBJECT  GLOBAL DEFAULT   15 _IO_stdin_used</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Symbol table &#x27;</span>.symtab<span class="string">&#x27; contains 65 entries:</span></span><br><span class="line"><span class="string">   Num:    Value  Size Type    Bind   Vis      Ndx Name</span></span><br><span class="line"><span class="string">     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND</span></span><br><span class="line"><span class="string">     1: 08048154     0 SECTION LOCAL  DEFAULT    1</span></span><br><span class="line"><span class="string">     2: 08048168     0 SECTION LOCAL  DEFAULT    2</span></span><br><span class="line"><span class="string">     3: 08048188     0 SECTION LOCAL  DEFAULT    3</span></span><br><span class="line"><span class="string">     4: 080481ac     0 SECTION LOCAL  DEFAULT    4</span></span><br><span class="line"><span class="string">     5: 080481cc     0 SECTION LOCAL  DEFAULT    5</span></span><br><span class="line"><span class="string">     6: 0804821c     0 SECTION LOCAL  DEFAULT    6</span></span><br><span class="line"><span class="string">     7: 08048268     0 SECTION LOCAL  DEFAULT    7</span></span><br><span class="line"><span class="string">     8: 08048274     0 SECTION LOCAL  DEFAULT    8</span></span><br><span class="line"><span class="string">     9: 08048294     0 SECTION LOCAL  DEFAULT    9</span></span><br><span class="line"><span class="string">    10: 0804829c     0 SECTION LOCAL  DEFAULT   10</span></span><br><span class="line"><span class="string">    11: 080482b4     0 SECTION LOCAL  DEFAULT   11</span></span><br><span class="line"><span class="string">    12: 080482f0     0 SECTION LOCAL  DEFAULT   12</span></span><br><span class="line"><span class="string">    13: 08048330     0 SECTION LOCAL  DEFAULT   13</span></span><br><span class="line"><span class="string">    14: 080484bc     0 SECTION LOCAL  DEFAULT   14</span></span><br><span class="line"><span class="string">    15: 080484d8     0 SECTION LOCAL  DEFAULT   15</span></span><br><span class="line"><span class="string">    16: 080484ec     0 SECTION LOCAL  DEFAULT   16</span></span><br><span class="line"><span class="string">    17: 08048520     0 SECTION LOCAL  DEFAULT   17</span></span><br><span class="line"><span class="string">    18: 08049f14     0 SECTION LOCAL  DEFAULT   18</span></span><br><span class="line"><span class="string">    19: 08049f1c     0 SECTION LOCAL  DEFAULT   19</span></span><br><span class="line"><span class="string">    20: 08049f24     0 SECTION LOCAL  DEFAULT   20</span></span><br><span class="line"><span class="string">    21: 08049f28     0 SECTION LOCAL  DEFAULT   21</span></span><br><span class="line"><span class="string">    22: 08049ff0     0 SECTION LOCAL  DEFAULT   22</span></span><br><span class="line"><span class="string">    23: 08049ff4     0 SECTION LOCAL  DEFAULT   23</span></span><br><span class="line"><span class="string">    24: 0804a00c     0 SECTION LOCAL  DEFAULT   24</span></span><br><span class="line"><span class="string">    25: 0804a014     0 SECTION LOCAL  DEFAULT   25</span></span><br><span class="line"><span class="string">    26: 00000000     0 SECTION LOCAL  DEFAULT   26</span></span><br><span class="line"><span class="string">    27: 00000000     0 FILE    LOCAL  DEFAULT  ABS crtstuff.c</span></span><br><span class="line"><span class="string">    28: 08049f14     0 OBJECT  LOCAL  DEFAULT   18 __CTOR_LIST__</span></span><br><span class="line"><span class="string">    29: 08049f1c     0 OBJECT  LOCAL  DEFAULT   19 __DTOR_LIST__</span></span><br><span class="line"><span class="string">    30: 08049f24     0 OBJECT  LOCAL  DEFAULT   20 __JCR_LIST__</span></span><br><span class="line"><span class="string">    31: 08048360     0 FUNC    LOCAL  DEFAULT   13 __do_global_dtors_aux</span></span><br><span class="line"><span class="string">    32: 0804a014     1 OBJECT  LOCAL  DEFAULT   25 completed.6086</span></span><br><span class="line"><span class="string">    33: 0804a018     4 OBJECT  LOCAL  DEFAULT   25 dtor_idx.6088</span></span><br><span class="line"><span class="string">    34: 080483c0     0 FUNC    LOCAL  DEFAULT   13 frame_dummy</span></span><br><span class="line"><span class="string">    35: 00000000     0 FILE    LOCAL  DEFAULT  ABS crtstuff.c</span></span><br><span class="line"><span class="string">    36: 08049f18     0 OBJECT  LOCAL  DEFAULT   18 __CTOR_END__</span></span><br><span class="line"><span class="string">    37: 080485e0     0 OBJECT  LOCAL  DEFAULT   17 __FRAME_END__</span></span><br><span class="line"><span class="string">    38: 08049f24     0 OBJECT  LOCAL  DEFAULT   20 __JCR_END__</span></span><br><span class="line"><span class="string">    39: 08048490     0 FUNC    LOCAL  DEFAULT   13 __do_global_ctors_aux</span></span><br><span class="line"><span class="string">    40: 00000000     0 FILE    LOCAL  DEFAULT  ABS a.c</span></span><br><span class="line"><span class="string">    41: 08049f14     0 NOTYPE  LOCAL  DEFAULT   18 __init_array_end</span></span><br><span class="line"><span class="string">    42: 08049f28     0 OBJECT  LOCAL  DEFAULT   21 _DYNAMIC</span></span><br><span class="line"><span class="string">    43: 08049f14     0 NOTYPE  LOCAL  DEFAULT   18 __init_array_start</span></span><br><span class="line"><span class="string">    44: 08049ff4     0 OBJECT  LOCAL  DEFAULT   23 _GLOBAL_OFFSET_TABLE_</span></span><br><span class="line"><span class="string">    45: 08048480     2 FUNC    GLOBAL DEFAULT   13 __libc_csu_fini</span></span><br><span class="line"><span class="string">    46: 08048482     0 FUNC    GLOBAL HIDDEN    13 __i686.get_pc_thunk.bx</span></span><br><span class="line"><span class="string">    47: 0804a00c     0 NOTYPE  WEAK   DEFAULT   24 data_start</span></span><br><span class="line"><span class="string">    48: 00000000     0 FUNC    GLOBAL DEFAULT  UND printf@@GLIBC_2.0</span></span><br><span class="line"><span class="string">    49: 0804a014     0 NOTYPE  GLOBAL DEFAULT  ABS _edata</span></span><br><span class="line"><span class="string">    50: 080484bc     0 FUNC    GLOBAL DEFAULT   14 _fini</span></span><br><span class="line"><span class="string">    51: 08049f20     0 OBJECT  GLOBAL HIDDEN    19 __DTOR_END__</span></span><br><span class="line"><span class="string">    52: 0804a00c     0 NOTYPE  GLOBAL DEFAULT   24 __data_start</span></span><br><span class="line"><span class="string">    53: 00000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__</span></span><br><span class="line"><span class="string">    54: 0804a010     0 OBJECT  GLOBAL HIDDEN    24 __dso_handle</span></span><br><span class="line"><span class="string">    55: 080484dc     4 OBJECT  GLOBAL DEFAULT   15 _IO_stdin_used</span></span><br><span class="line"><span class="string">    56: 00000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@@GLIBC_</span></span><br><span class="line"><span class="string">    57: 08048410    97 FUNC    GLOBAL DEFAULT   13 __libc_csu_init</span></span><br><span class="line"><span class="string">    58: 0804a01c     0 NOTYPE  GLOBAL DEFAULT  ABS _end</span></span><br><span class="line"><span class="string">    59: 08048330     0 FUNC    GLOBAL DEFAULT   13 _start</span></span><br><span class="line"><span class="string">    60: 080484d8     4 OBJECT  GLOBAL DEFAULT   15 _fp_hw</span></span><br><span class="line"><span class="string">    61: 0804a014     0 NOTYPE  GLOBAL DEFAULT  ABS __bss_start</span></span><br><span class="line"><span class="string">    62: 080483e4    40 FUNC    GLOBAL DEFAULT   13 main</span></span><br><span class="line"><span class="string">    63: 00000000     0 NOTYPE  WEAK   DEFAULT  UND _Jv_RegisterClasses</span></span><br><span class="line"><span class="string">    64: 080482b4     0 FUNC    GLOBAL DEFAULT   11 _init</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Histogram for `.gnu.hash&#x27;</span> bucket list length (total of 2 buckets):</span><br><span class="line"> Length  Number     % of total  Coverage</span><br><span class="line">      0  1          ( 50.0%)</span><br><span class="line">      1  1          ( 50.0%)    100.0%</span><br><span class="line"></span><br><span class="line">Version symbols section <span class="string">&#x27;.gnu.version&#x27;</span> contains 5 entries:</span><br><span class="line"> Addr: 0000000008048268  Offset: 0x000268  Link: 5 (.dynsym)</span><br><span class="line">  000:   0 (*<span class="built_in">local</span>*)       2 (GLIBC_2.0)     0 (*<span class="built_in">local</span>*)       2 (GLIBC_2.0)</span><br><span class="line">  004:   1 (*global*)</span><br><span class="line"></span><br><span class="line">Version needs section <span class="string">&#x27;.gnu.version_r&#x27;</span> contains 1 entries:</span><br><span class="line"> Addr: 0x0000000008048274  Offset: 0x000274  Link: 6 (.dynstr)</span><br><span class="line">  000000: Version: 1  File: libc.so.6  Cnt: 1</span><br><span class="line">  0x0010:   Name: GLIBC_2.0  Flags: none  Version: 2</span><br><span class="line"></span><br><span class="line">Notes at offset 0x00000168 with length 0x00000020:</span><br><span class="line">  Owner                 Data size   Description</span><br><span class="line">  GNU                  0x00000010   NT_GNU_ABI_TAG (ABI version tag)</span><br><span class="line">    OS: Linux, ABI: 2.6.15</span><br><span class="line"></span><br><span class="line">Notes at offset 0x00000188 with length 0x00000024:</span><br><span class="line">  Owner                 Data size   Description</span><br><span class="line">  GNU                  0x00000014   NT_GNU_BUILD_ID (unique build ID bitstring)</span><br><span class="line">    Build ID: 17fb9651029b6a8543bfafec9eea23bd16454e65</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>readelf</tag>
      </tags>
  </entry>
  <entry>
    <title>objdump二进制文件分析</title>
    <url>/2020/09/25/objdump%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在Linux环境下，我们可以使用objdump命令对目标文件(obj)或可执行文件进行反汇编，它以一种可阅读的格式让你更多的了解二进制文件可能带有的附加信息。</p>
<span id="more"></span>

<h2 id="常用参数说明"><a href="#常用参数说明" class="headerlink" title="常用参数说明"></a>常用参数说明</h2><p><code>-f</code> 显示文件头信息<br><code>-D</code> 反汇编所有section (-d反汇编特定section)<br><code>-h</code> 显示目标文件各个section的头部摘要信息<br><code>-x</code> 显示所有可用的头信息，包括符号表、重定位入口。-x 等价于 -a -f -h -r -t 同时指定。<br><code>-i</code> 显示对于 -b 或者 -m 选项可用的架构和目标格式列表。<br><code>-r</code> 显示文件的重定位入口。如果和-d或者-D一起使用，重定位部分以反汇编后的格式显示出来。<br><code>-R</code> 显示文件的动态重定位入口，仅仅对于动态目标文件有意义，比如某些共享库。<br><code>-S</code> 尽可能反汇编出源代码，尤其当编译的时候指定了-g这种调试参数时，效果比较明显。隐含了-d参数。<br><code>-t</code> 显示文件的符号表入口。类似于nm -s提供的信息</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="测试示例代码"><a href="#测试示例代码" class="headerlink" title="测试示例代码"></a>测试示例代码</h3><h4 id="头文件add-h"><a href="#头文件add-h" class="headerlink" title="头文件add.h"></a>头文件add.h</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ADD_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ADD_H_</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __cplusplus */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> module_id;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> *module_name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __cplusplus */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h4 id="源文件add-c"><a href="#源文件add-c" class="headerlink" title="源文件add.c"></a>源文件add.c</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;add.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> module_id = <span class="number">1001</span>;</span><br><span class="line"><span class="type">char</span> *module_name = <span class="string">&quot;calc&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="测试文件main-c"><a href="#测试文件main-c" class="headerlink" title="测试文件main.c"></a>测试文件main.c</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;add.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> out_sum;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> id = module_id;</span><br><span class="line">        <span class="type">char</span> *name = module_name;</span><br><span class="line">        <span class="type">int</span> sum;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;module：%d %s\n&quot;</span>, id, name);</span><br><span class="line"></span><br><span class="line">        sum = add(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sum: %d\n&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        out_sum = sum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="编译代码"><a href="#编译代码" class="headerlink" title="编译代码"></a>编译代码</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># gcc -g -c add.c -o add.o</span></span><br><span class="line"><span class="comment"># gcc -g -c main.c -o main.o</span></span><br><span class="line"><span class="comment"># gcc -o main main.o add.o</span></span><br><span class="line"><span class="comment"># ls</span></span><br><span class="line">add.c  add.h  add.o  main  main.c  main.o</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="查看对象文件的所有sections的头部摘要信息"><a href="#查看对象文件的所有sections的头部摘要信息" class="headerlink" title="查看对象文件的所有sections的头部摘要信息"></a>查看对象文件的所有sections的头部摘要信息</h3><ul>
<li><p>add.o目标文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># objdump -h ./add.o</span></span><br><span class="line"></span><br><span class="line">./add.o:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA       LMA       File off  Algn</span><br><span class="line">  0 .text         0000000d  00000000  00000000  00000034  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  1 .data         00000008  00000000  00000000  00000044  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, DATA</span><br><span class="line">  2 .bss          00000000  00000000  00000000  0000004c  2**0</span><br><span class="line">                  ALLOC</span><br><span class="line">  3 .rodata       00000005  00000000  00000000  0000004c  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  4 .debug_info   0000008e  00000000  00000000  00000051  2**0</span><br><span class="line">                  CONTENTS, RELOC, READONLY, DEBUGGING</span><br><span class="line">  5 .debug_abbrev 0000006f  00000000  00000000  000000df  2**0</span><br><span class="line">                  CONTENTS, READONLY, DEBUGGING</span><br><span class="line">  6 .debug_aranges 00000020  00000000  00000000  0000014e  2**0</span><br><span class="line">                  CONTENTS, RELOC, READONLY, DEBUGGING</span><br><span class="line">  7 .debug_line   00000035  00000000  00000000  0000016e  2**0</span><br><span class="line">                  CONTENTS, RELOC, READONLY, DEBUGGING</span><br><span class="line">  8 .debug_str    0000007f  00000000  00000000  000001a3  2**0</span><br><span class="line">                  CONTENTS, READONLY, DEBUGGING</span><br><span class="line">  9 .comment      00000036  00000000  00000000  00000222  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line"> 10 .note.GNU-stack 00000000  00000000  00000000  00000258  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line"> 11 .eh_frame     00000038  00000000  00000000  00000258  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br></pre></td></tr></table></figure></li>
<li><p>main.o目标文件</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># objdump -h main.o</span></span><br><span class="line"></span><br><span class="line">main.o:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA       LMA       File off  Algn</span><br><span class="line">  0 .text         00000071  00000000  00000000  00000034  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span><br><span class="line">  1 .data         00000000  00000000  00000000  000000a5  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  2 .bss          00000000  00000000  00000000  000000a5  2**0</span><br><span class="line">                  ALLOC</span><br><span class="line">  3 .rodata       00000019  00000000  00000000  000000a5  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  4 .debug_info   0000010c  00000000  00000000  000000be  2**0</span><br><span class="line">                  CONTENTS, RELOC, READONLY, DEBUGGING</span><br><span class="line">  5 .debug_abbrev 0000009e  00000000  00000000  000001ca  2**0</span><br><span class="line">                  CONTENTS, READONLY, DEBUGGING</span><br><span class="line">  6 .debug_aranges 00000020  00000000  00000000  00000268  2**0</span><br><span class="line">                  CONTENTS, RELOC, READONLY, DEBUGGING</span><br><span class="line">  7 .debug_line   0000004b  00000000  00000000  00000288  2**0</span><br><span class="line">                  CONTENTS, RELOC, READONLY, DEBUGGING</span><br><span class="line">  8 .debug_str    00000129  00000000  00000000  000002d3  2**0</span><br><span class="line">                  CONTENTS, READONLY, DEBUGGING</span><br><span class="line">  9 .comment      00000036  00000000  00000000  000003fc  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line"> 10 .note.GNU-stack 00000000  00000000  00000000  00000432  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line"> 11 .eh_frame     00000044  00000000  00000000  00000434  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>main可执行程序<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># objdump -h main</span></span><br><span class="line"></span><br><span class="line">main:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA       LMA       File off  Algn</span><br><span class="line">  0 .interp       00000013  08048154  08048154  00000154  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  1 .note.ABI-tag 00000020  08048168  08048168  00000168  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  2 .note.gnu.build-id 00000024  08048188  08048188  00000188  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  3 .gnu.hash     00000020  080481ac  080481ac  000001ac  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  4 .dynsym       00000050  080481cc  080481cc  000001cc  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  5 .dynstr       0000004c  0804821c  0804821c  0000021c  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  6 .gnu.version  0000000a  08048268  08048268  00000268  2**1</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  7 .gnu.version_r 00000020  08048274  08048274  00000274  2**2</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="显示目标文件的整体头部摘要信息"><a href="#显示目标文件的整体头部摘要信息" class="headerlink" title="显示目标文件的整体头部摘要信息"></a>显示目标文件的整体头部摘要信息</h3><ul>
<li><p>add.o目标文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># objdump -f ./add.o</span></span><br><span class="line"></span><br><span class="line">./add.o:     file format elf32-i386</span><br><span class="line">architecture: i386, flags 0x00000011:</span><br><span class="line">HAS_RELOC, HAS_SYMS</span><br><span class="line">start address 0x00000000</span><br></pre></td></tr></table></figure></li>
<li><p>main.o目标文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># objdump -f ./main.o</span></span><br><span class="line"></span><br><span class="line">./main.o:     file format elf32-i386</span><br><span class="line">architecture: i386, flags 0x00000011:</span><br><span class="line">HAS_RELOC, HAS_SYMS</span><br><span class="line">start address 0x00000000</span><br></pre></td></tr></table></figure></li>
<li><p>main目标文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># objdump -f ./main</span></span><br><span class="line"></span><br><span class="line">./main:     file format elf32-i386</span><br><span class="line">architecture: i386, flags 0x00000112:</span><br><span class="line">EXEC_P, HAS_SYMS, D_PAGED</span><br><span class="line">start address 0x08048310</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="查看目标文件符号表"><a href="#查看目标文件符号表" class="headerlink" title="查看目标文件符号表"></a>查看目标文件符号表</h3><ul>
<li>add.o符号表<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># objdump -t ./add.o</span></span><br><span class="line"></span><br><span class="line">./add.o:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">SYMBOL TABLE:</span><br><span class="line">00000000 l    <span class="built_in">df</span> *ABS*  00000000 add.c</span><br><span class="line">00000000 l    d  .text  00000000 .text</span><br><span class="line">00000000 l    d  .data  00000000 .data</span><br><span class="line">00000000 l    d  .bss   00000000 .bss</span><br><span class="line">00000000 l    d  .rodata        00000000 .rodata</span><br><span class="line">00000000 l    d  .debug_info    00000000 .debug_info</span><br><span class="line">00000000 l    d  .debug_abbrev  00000000 .debug_abbrev</span><br><span class="line">00000000 l    d  .debug_aranges 00000000 .debug_aranges</span><br><span class="line">00000000 l    d  .debug_line    00000000 .debug_line</span><br><span class="line">00000000 l    d  .debug_str     00000000 .debug_str</span><br><span class="line">00000000 l    d  .note.GNU-stack        00000000 .note.GNU-stack</span><br><span class="line">00000000 l    d  .eh_frame      00000000 .eh_frame</span><br><span class="line">00000000 l    d  .comment       00000000 .comment</span><br><span class="line">00000000 g     O .data  00000004 module_id</span><br><span class="line">00000004 g     O .data  00000004 module_name</span><br><span class="line">00000000 g     F .text  0000000d add</span><br></pre></td></tr></table></figure></li>
<li>main.o符号表<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># objdump -t ./main.o</span></span><br><span class="line"></span><br><span class="line">./main.o:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">SYMBOL TABLE:</span><br><span class="line">00000000 l    <span class="built_in">df</span> *ABS*  00000000 main.c</span><br><span class="line">00000000 l    d  .text  00000000 .text</span><br><span class="line">00000000 l    d  .data  00000000 .data</span><br><span class="line">00000000 l    d  .bss   00000000 .bss</span><br><span class="line">00000000 l    d  .rodata        00000000 .rodata</span><br><span class="line">00000000 l    d  .debug_info    00000000 .debug_info</span><br><span class="line">00000000 l    d  .debug_abbrev  00000000 .debug_abbrev</span><br><span class="line">00000000 l    d  .debug_aranges 00000000 .debug_aranges</span><br><span class="line">00000000 l    d  .debug_line    00000000 .debug_line</span><br><span class="line">00000000 l    d  .debug_str     00000000 .debug_str</span><br><span class="line">00000000 l    d  .note.GNU-stack        00000000 .note.GNU-stack</span><br><span class="line">00000000 l    d  .eh_frame      00000000 .eh_frame</span><br><span class="line">00000000 l    d  .comment       00000000 .comment</span><br><span class="line">00000004       O *COM*  00000004 out_sum</span><br><span class="line">00000000 g     F .text  00000071 main</span><br><span class="line">00000000         *UND*  00000000 module_id</span><br><span class="line">00000000         *UND*  00000000 module_name</span><br><span class="line">00000000         *UND*  00000000 <span class="built_in">printf</span></span><br><span class="line">00000000         *UND*  00000000 add</span><br></pre></td></tr></table></figure></li>
<li>main符号表<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># objdump -t ./main</span></span><br><span class="line"></span><br><span class="line">./main:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">SYMBOL TABLE:</span><br><span class="line">08048154 l    d  .interp        00000000              .interp</span><br><span class="line">08048168 l    d  .note.ABI-tag  00000000              .note.ABI-tag</span><br><span class="line">08048188 l    d  .note.gnu.build-id     00000000              .note.gnu.build-id</span><br><span class="line">080481ac l    d  .gnu.hash      00000000              .gnu.hash</span><br><span class="line">080481cc l    d  .dynsym        00000000              .dynsym</span><br><span class="line">0804821c l    d  .dynstr        00000000              .dynstr</span><br><span class="line">08048268 l    d  .gnu.version   00000000              .gnu.version</span><br><span class="line">08048274 l    d  .gnu.version_r 00000000              .gnu.version_r</span><br><span class="line">08048294 l    d  .rel.dyn       00000000              .rel.dyn</span><br><span class="line">0804829c l    d  .rel.plt       00000000              .rel.plt</span><br><span class="line">080482ac l    d  .init  00000000              .init</span><br><span class="line">080482d0 l    d  .plt   00000000              .plt</span><br><span class="line">08048300 l    d  .plt.got       00000000              .plt.got</span><br><span class="line">08048310 l    d  .text  00000000              .text</span><br><span class="line">080484f4 l    d  .fini  00000000              .fini</span><br><span class="line">08048508 l    d  .rodata        00000000              .rodata</span><br><span class="line">08048530 l    d  .eh_frame_hdr  00000000              .eh_frame_hdr</span><br><span class="line">08048564 l    d  .eh_frame      00000000              .eh_frame</span><br><span class="line">08049f08 l    d  .init_array    00000000              .init_array</span><br><span class="line">08049f0c l    d  .fini_array    00000000              .fini_array</span><br><span class="line">08049f10 l    d  .jcr   00000000              .jcr</span><br><span class="line">08049f14 l    d  .dynamic       00000000              .dynamic</span><br><span class="line">08049ffc l    d  .got   00000000              .got</span><br><span class="line">0804a000 l    d  .got.plt       00000000              .got.plt</span><br><span class="line">0804a014 l    d  .data  00000000              .data</span><br><span class="line">0804a024 l    d  .bss   00000000              .bss</span><br><span class="line">00000000 l    d  .comment       00000000              .comment</span><br><span class="line">00000000 l    d  .debug_aranges 00000000              .debug_aranges</span><br><span class="line">00000000 l    d  .debug_info    00000000              .debug_info</span><br><span class="line">00000000 l    d  .debug_abbrev  00000000              .debug_abbrev</span><br><span class="line">00000000 l    d  .debug_line    00000000              .debug_line</span><br><span class="line">00000000 l    d  .debug_str     00000000              .debug_str</span><br><span class="line">00000000 l    <span class="built_in">df</span> *ABS*  00000000              crtstuff.c</span><br><span class="line">08049f10 l     O .jcr   00000000              __JCR_LIST__</span><br><span class="line">08048350 l     F .text  00000000              deregister_tm_clones</span><br><span class="line">08048380 l     F .text  00000000              register_tm_clones</span><br><span class="line">080483c0 l     F .text  00000000              __do_global_dtors_aux</span><br><span class="line">0804a024 l     O .bss   00000001              completed.7209</span><br><span class="line">08049f0c l     O .fini_array    00000000              __do_global_dtors_aux_fini_array_entry</span><br><span class="line">080483e0 l     F .text  00000000              frame_dummy</span><br><span class="line">08049f08 l     O .init_array    00000000              __frame_dummy_init_array_entry</span><br><span class="line">00000000 l    <span class="built_in">df</span> *ABS*  00000000              main.c</span><br><span class="line">00000000 l    <span class="built_in">df</span> *ABS*  00000000              add.c</span><br><span class="line">00000000 l    <span class="built_in">df</span> *ABS*  00000000              crtstuff.c</span><br><span class="line">0804864c l     O .eh_frame      00000000              __FRAME_END__</span><br><span class="line">08049f10 l     O .jcr   00000000              __JCR_END__</span><br><span class="line">00000000 l    <span class="built_in">df</span> *ABS*  00000000              </span><br><span class="line">08049f0c l       .init_array    00000000              __init_array_end</span><br><span class="line">08049f14 l     O .dynamic       00000000              _DYNAMIC</span><br><span class="line">08049f08 l       .init_array    00000000              __init_array_start</span><br><span class="line">08048530 l       .eh_frame_hdr  00000000              __GNU_EH_FRAME_HDR</span><br><span class="line">0804a000 l     O .got.plt       00000000              _GLOBAL_OFFSET_TABLE_</span><br><span class="line">080484f0 g     F .text  00000002              __libc_csu_fini</span><br><span class="line">00000000  w      *UND*  00000000              _ITM_deregisterTMCloneTable</span><br><span class="line">08048340 g     F .text  00000004              .hidden __x86.get_pc_thunk.bx</span><br><span class="line">0804a014  w      .data  00000000              data_start</span><br><span class="line">0804847c g     F .text  0000000d              add</span><br><span class="line">00000000       F *UND*  00000000              <span class="built_in">printf</span>@@GLIBC_2.0</span><br><span class="line">0804a01c g     O .data  00000004              module_id</span><br><span class="line">0804a024 g       .data  00000000              _edata</span><br><span class="line">0804a020 g     O .data  00000004              module_name</span><br><span class="line">080484f4 g     F .fini  00000000              _fini</span><br><span class="line">0804a014 g       .data  00000000              __data_start</span><br><span class="line">00000000  w      *UND*  00000000              __gmon_start__</span><br><span class="line">0804a018 g     O .data  00000000              .hidden __dso_handle</span><br><span class="line">0804850c g     O .rodata        00000004              _IO_stdin_used</span><br><span class="line">00000000       F *UND*  00000000              __libc_start_main@@GLIBC_2.0</span><br><span class="line">08048490 g     F .text  0000005d              __libc_csu_init</span><br><span class="line">0804a02c g       .bss   00000000              _end</span><br><span class="line">08048310 g     F .text  00000000              _start</span><br><span class="line">08048508 g     O .rodata        00000004              _fp_hw</span><br><span class="line">0804a024 g       .bss   00000000              __bss_start</span><br><span class="line">0804a028 g     O .bss   00000004              out_sum</span><br><span class="line">0804840b g     F .text  00000071              main</span><br><span class="line">00000000  w      *UND*  00000000              _Jv_RegisterClasses</span><br><span class="line">0804a024 g     O .data  00000000              .hidden __TMC_END__</span><br><span class="line">00000000  w      *UND*  00000000              _ITM_registerTMCloneTable</span><br><span class="line">080482ac g     F .init  00000000              _init</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="对目标文件进行反汇编"><a href="#对目标文件进行反汇编" class="headerlink" title="对目标文件进行反汇编"></a>对目标文件进行反汇编</h3><ul>
<li>add.o进行反汇编<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># objdump -d ./add.o</span></span><br><span class="line"></span><br><span class="line">./add.o:     file format elf32-i386</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">00000000 &lt;add&gt;:</span><br><span class="line">   0:   55                      push   %ebp</span><br><span class="line">   1:   89 e5                   mov    %esp,%ebp</span><br><span class="line">   3:   8b 55 08                mov    0x8(%ebp),%edx</span><br><span class="line">   6:   8b 45 0c                mov    0xc(%ebp),%eax</span><br><span class="line">   9:   01 d0                   add    %edx,%eax</span><br><span class="line">   b:   5d                      pop    %ebp</span><br><span class="line">   c:   c3                      ret </span><br></pre></td></tr></table></figure></li>
<li>main.o进行反汇编<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># objdump -d -S ./main.o</span></span><br><span class="line"></span><br><span class="line">./main.o:     file format elf32-i386</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">00000000 &lt;main&gt;:</span><br><span class="line"></span><br><span class="line">int out_sum;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">   0:   8d 4c 24 04             lea    0x4(%esp),%ecx</span><br><span class="line">   4:   83 e4 f0                and    <span class="variable">$0xfffffff0</span>,%esp</span><br><span class="line">   7:   ff 71 <span class="built_in">fc</span>                pushl  -0x4(%ecx)</span><br><span class="line">   a:   55                      push   %ebp</span><br><span class="line">   b:   89 e5                   mov    %esp,%ebp</span><br><span class="line">   d:   51                      push   %ecx</span><br><span class="line">   e:   83 ec 14                sub    <span class="variable">$0x14</span>,%esp</span><br><span class="line">        int <span class="built_in">id</span> = module_id;</span><br><span class="line">  11:   a1 00 00 00 00          mov    0x0,%eax</span><br><span class="line">  16:   89 45 ec                mov    %eax,-0x14(%ebp)</span><br><span class="line">        char *name = module_name;</span><br><span class="line">  19:   a1 00 00 00 00          mov    0x0,%eax</span><br><span class="line">  1e:   89 45 f0                mov    %eax,-0x10(%ebp)</span><br><span class="line">        int <span class="built_in">sum</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;module：%d %s\n&quot;</span>, <span class="built_in">id</span>, name);</span><br><span class="line">  21:   83 ec 04                sub    <span class="variable">$0x4</span>,%esp</span><br><span class="line">  24:   ff 75 f0                pushl  -0x10(%ebp)</span><br><span class="line">  27:   ff 75 ec                pushl  -0x14(%ebp)</span><br><span class="line">  2a:   68 00 00 00 00          push   <span class="variable">$0x0</span></span><br><span class="line">  2f:   e8 <span class="built_in">fc</span> ff ff ff          call   30 &lt;main+0x30&gt;</span><br><span class="line">  34:   83 c4 10                add    <span class="variable">$0x10</span>,%esp</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sum</span> = add(2,3);</span><br><span class="line">  37:   83 ec 08                sub    <span class="variable">$0x8</span>,%esp</span><br><span class="line">  3a:   6a 03                   push   <span class="variable">$0x3</span></span><br><span class="line">  3c:   6a 02                   push   <span class="variable">$0x2</span></span><br><span class="line">  3e:   e8 <span class="built_in">fc</span> ff ff ff          call   3f &lt;main+0x3f&gt;</span><br><span class="line">  43:   83 c4 10                add    <span class="variable">$0x10</span>,%esp</span><br><span class="line">  46:   89 45 f4                mov    %eax,-0xc(%ebp)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sum: %d\n&quot;</span>, <span class="built_in">sum</span>);</span><br><span class="line">  49:   83 ec 08                sub    <span class="variable">$0x8</span>,%esp</span><br><span class="line">  4c:   ff 75 f4                pushl  -0xc(%ebp)</span><br><span class="line">  4f:   68 10 00 00 00          push   <span class="variable">$0x10</span></span><br><span class="line">  54:   e8 <span class="built_in">fc</span> ff ff ff          call   55 &lt;main+0x55&gt;</span><br><span class="line">  59:   83 c4 10                add    <span class="variable">$0x10</span>,%esp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        out_sum = <span class="built_in">sum</span>;</span><br><span class="line">  5c:   8b 45 f4                mov    -0xc(%ebp),%eax</span><br><span class="line">  5f:   a3 00 00 00 00          mov    %eax,0x0</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> 0x0;</span><br><span class="line">  64:   b8 00 00 00 00          mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">&#125;</span><br><span class="line">  69:   8b 4d <span class="built_in">fc</span>                mov    -0x4(%ebp),%ecx</span><br><span class="line">  6c:   c9                      leave  </span><br><span class="line">  6d:   8d 61 <span class="built_in">fc</span>                lea    -0x4(%ecx),%esp</span><br><span class="line">  70:   c3                      ret    </span><br></pre></td></tr></table></figure></li>
<li>main进行反汇编<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># objdump -d -S ./main</span></span><br><span class="line"></span><br><span class="line">./main:     file format elf32-i386</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .init:</span><br><span class="line"></span><br><span class="line">080482ac &lt;_init&gt;:</span><br><span class="line"> 80482ac:       53                      push   %ebx</span><br><span class="line"> 80482ad:       83 ec 08                sub    <span class="variable">$0x8</span>,%esp</span><br><span class="line"> 80482b0:       e8 8b 00 00 00          call   8048340 &lt;__x86.get_pc_thunk.bx&gt;</span><br><span class="line"> 80482b5:       81 c3 4b 1d 00 00       add    <span class="variable">$0x1d4b</span>,%ebx</span><br><span class="line"> 80482bb:       8b 83 <span class="built_in">fc</span> ff ff ff       mov    -0x4(%ebx),%eax</span><br><span class="line"> 80482c1:       85 c0                   <span class="built_in">test</span>   %eax,%eax</span><br><span class="line"> 80482c3:       74 05                   je     80482ca &lt;_init+0x1e&gt;</span><br><span class="line"> 80482c5:       e8 36 00 00 00          call   8048300 &lt;__libc_start_main@plt+0x10&gt;</span><br><span class="line"> 80482ca:       83 c4 08                add    <span class="variable">$0x8</span>,%esp</span><br><span class="line"> 80482cd:       5b                      pop    %ebx</span><br><span class="line"> 80482ce:       c3                      ret    </span><br><span class="line"></span><br><span class="line">Disassembly of section .plt:</span><br><span class="line"></span><br><span class="line">080482d0 &lt;<span class="built_in">printf</span>@plt-0x10&gt;:</span><br><span class="line"> 80482d0:       ff 35 04 a0 04 08       pushl  0x804a004</span><br><span class="line"> 80482d6:       ff 25 08 a0 04 08       jmp    *0x804a008</span><br><span class="line"> 80482dc:       00 00                   add    %al,(%eax)</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">080482e0 &lt;<span class="built_in">printf</span>@plt&gt;:</span><br><span class="line"> 80482e0:       ff 25 0c a0 04 08       jmp    *0x804a00c</span><br><span class="line"> 80482e6:       68 00 00 00 00          push   <span class="variable">$0x0</span></span><br><span class="line"> 80482eb:       e9 e0 ff ff ff          jmp    80482d0 &lt;_init+0x24&gt;</span><br><span class="line"></span><br><span class="line">080482f0 &lt;__libc_start_main@plt&gt;:</span><br><span class="line"> 80482f0:       ff 25 10 a0 04 08       jmp    *0x804a010</span><br><span class="line"> 80482f6:       68 08 00 00 00          push   <span class="variable">$0x8</span></span><br><span class="line"> 80482fb:       e9 d0 ff ff ff          jmp    80482d0 &lt;_init+0x24&gt;</span><br><span class="line"></span><br><span class="line">Disassembly of section .plt.got:</span><br><span class="line"></span><br><span class="line">08048300 &lt;.plt.got&gt;:</span><br><span class="line"> 8048300:       ff 25 <span class="built_in">fc</span> 9f 04 08       jmp    *0x8049ffc</span><br><span class="line"> 8048306:       66 90                   xchg   %ax,%ax</span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">08048310 &lt;_start&gt;:</span><br><span class="line"> 8048310:       31 ed                   xor    %ebp,%ebp</span><br><span class="line"> 8048312:       5e                      pop    %esi</span><br><span class="line"> 8048313:       89 e1                   mov    %esp,%ecx</span><br><span class="line"> 8048315:       83 e4 f0                and    <span class="variable">$0xfffffff0</span>,%esp</span><br><span class="line"> 8048318:       50                      push   %eax</span><br><span class="line"> 8048319:       54                      push   %esp</span><br><span class="line"> 804831a:       52                      push   %edx</span><br><span class="line"> 804831b:       68 f0 84 04 08          push   <span class="variable">$0x80484f0</span></span><br><span class="line"> 8048320:       68 90 84 04 08          push   <span class="variable">$0x8048490</span></span><br><span class="line"> 8048325:       51                      push   %ecx</span><br><span class="line"> 8048326:       56                      push   %esi</span><br><span class="line"> 8048327:       68 0b 84 04 08          push   <span class="variable">$0x804840b</span></span><br><span class="line"> 804832c:       e8 bf ff ff ff          call   80482f0 &lt;__libc_start_main@plt&gt;</span><br><span class="line"> 8048331:       f4                      hlt    </span><br><span class="line"> 8048332:       66 90                   xchg   %ax,%ax</span><br><span class="line"> 8048334:       66 90                   xchg   %ax,%ax</span><br><span class="line"> 8048336:       66 90                   xchg   %ax,%ax</span><br><span class="line"> 8048338:       66 90                   xchg   %ax,%ax</span><br><span class="line"> 804833a:       66 90                   xchg   %ax,%ax</span><br><span class="line"> 804833c:       66 90                   xchg   %ax,%ax</span><br><span class="line"> 804833e:       66 90                   xchg   %ax,%ax</span><br><span class="line"></span><br><span class="line">08048340 &lt;__x86.get_pc_thunk.bx&gt;:</span><br><span class="line"> 8048340:       8b 1c 24                mov    (%esp),%ebx</span><br><span class="line"> 8048343:       c3                      ret    </span><br><span class="line"> 8048344:       66 90                   xchg   %ax,%ax</span><br><span class="line"> 8048346:       66 90                   xchg   %ax,%ax</span><br><span class="line"> 8048348:       66 90                   xchg   %ax,%ax</span><br><span class="line"> 804834a:       66 90                   xchg   %ax,%ax</span><br><span class="line"> 804834c:       66 90                   xchg   %ax,%ax</span><br><span class="line"> 804834e:       66 90                   xchg   %ax,%ax</span><br><span class="line"></span><br><span class="line">08048350 &lt;deregister_tm_clones&gt;:</span><br><span class="line"> 8048350:       b8 27 a0 04 08          mov    <span class="variable">$0x804a027</span>,%eax</span><br><span class="line"> 8048355:       2d 24 a0 04 08          sub    <span class="variable">$0x804a024</span>,%eax</span><br><span class="line"> 804835a:       83 f8 06                cmp    <span class="variable">$0x6</span>,%eax</span><br><span class="line"> 804835d:       76 1a                   jbe    8048379 &lt;deregister_tm_clones+0x29&gt;</span><br><span class="line"> 804835f:       b8 00 00 00 00          mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line"> 8048364:       85 c0                   <span class="built_in">test</span>   %eax,%eax</span><br><span class="line"> 8048366:       74 11                   je     8048379 &lt;deregister_tm_clones+0x29&gt;</span><br><span class="line"> 8048368:       55                      push   %ebp</span><br><span class="line"> 8048369:       89 e5                   mov    %esp,%ebp</span><br><span class="line"> 804836b:       83 ec 14                sub    <span class="variable">$0x14</span>,%esp</span><br><span class="line"> 804836e:       68 24 a0 04 08          push   <span class="variable">$0x804a024</span></span><br><span class="line"> 8048373:       ff d0                   call   *%eax</span><br><span class="line"> 8048375:       83 c4 10                add    <span class="variable">$0x10</span>,%esp</span><br><span class="line"> 8048378:       c9                      leave  </span><br><span class="line"> 8048379:       f3 c3                   repz ret </span><br><span class="line"> 804837b:       90                      nop</span><br><span class="line"> 804837c:       8d 74 26 00             lea    0x0(%esi,%eiz,1),%esi</span><br><span class="line"></span><br><span class="line">08048380 &lt;register_tm_clones&gt;:</span><br><span class="line"> 8048380:       b8 24 a0 04 08          mov    <span class="variable">$0x804a024</span>,%eax</span><br><span class="line"> 8048385:       2d 24 a0 04 08          sub    <span class="variable">$0x804a024</span>,%eax</span><br><span class="line"> 804838a:       c1 f8 02                sar    <span class="variable">$0x2</span>,%eax</span><br><span class="line"> 804838d:       89 c2                   mov    %eax,%edx</span><br><span class="line"> 804838f:       c1 ea 1f                shr    <span class="variable">$0x1f</span>,%edx</span><br><span class="line"> 8048392:       01 d0                   add    %edx,%eax</span><br><span class="line"> 8048394:       d1 f8                   sar    %eax</span><br><span class="line"> 8048396:       74 1b                   je     80483b3 &lt;register_tm_clones+0x33&gt;</span><br><span class="line"> 8048398:       ba 00 00 00 00          mov    <span class="variable">$0x0</span>,%edx</span><br><span class="line"> 804839d:       85 d2                   <span class="built_in">test</span>   %edx,%edx</span><br><span class="line"> 804839f:       74 12                   je     80483b3 &lt;register_tm_clones+0x33&gt;</span><br><span class="line"> 80483a1:       55                      push   %ebp</span><br><span class="line"> 80483a2:       89 e5                   mov    %esp,%ebp</span><br><span class="line"> 80483a4:       83 ec 10                sub    <span class="variable">$0x10</span>,%esp</span><br><span class="line"> 80483a7:       50                      push   %eax</span><br><span class="line"> 80483a8:       68 24 a0 04 08          push   <span class="variable">$0x804a024</span></span><br><span class="line"> 80483ad:       ff d2                   call   *%edx</span><br><span class="line"> 80483af:       83 c4 10                add    <span class="variable">$0x10</span>,%esp</span><br><span class="line"> 80483b2:       c9                      leave  </span><br><span class="line"> 80483b3:       f3 c3                   repz ret </span><br><span class="line"> 80483b5:       8d 74 26 00             lea    0x0(%esi,%eiz,1),%esi</span><br><span class="line"> 80483b9:       8d bc 27 00 00 00 00    lea    0x0(%edi,%eiz,1),%edi</span><br><span class="line"></span><br><span class="line">080483c0 &lt;__do_global_dtors_aux&gt;:</span><br><span class="line"> 80483c0:       80 3d 24 a0 04 08 00    cmpb   <span class="variable">$0x0</span>,0x804a024</span><br><span class="line"> 80483c7:       75 13                   jne    80483dc &lt;__do_global_dtors_aux+0x1c&gt;</span><br><span class="line"> 80483c9:       55                      push   %ebp</span><br><span class="line"> 80483ca:       89 e5                   mov    %esp,%ebp</span><br><span class="line"> 80483cc:       83 ec 08                sub    <span class="variable">$0x8</span>,%esp</span><br><span class="line"> 80483cf:       e8 7c ff ff ff          call   8048350 &lt;deregister_tm_clones&gt;</span><br><span class="line"> 80483d4:       c6 05 24 a0 04 08 01    movb   <span class="variable">$0x1</span>,0x804a024</span><br><span class="line"> 80483db:       c9                      leave  </span><br><span class="line"> 80483dc:       f3 c3                   repz ret </span><br><span class="line"> 80483de:       66 90                   xchg   %ax,%ax</span><br><span class="line"></span><br><span class="line">080483e0 &lt;frame_dummy&gt;:</span><br><span class="line"> 80483e0:       b8 10 9f 04 08          mov    <span class="variable">$0x8049f10</span>,%eax</span><br><span class="line"> 80483e5:       8b 10                   mov    (%eax),%edx</span><br><span class="line"> 80483e7:       85 d2                   <span class="built_in">test</span>   %edx,%edx</span><br><span class="line"> 80483e9:       75 05                   jne    80483f0 &lt;frame_dummy+0x10&gt;</span><br><span class="line"> 80483eb:       eb 93                   jmp    8048380 &lt;register_tm_clones&gt;</span><br><span class="line"> 80483ed:       8d 76 00                lea    0x0(%esi),%esi</span><br><span class="line"> 80483f0:       ba 00 00 00 00          mov    <span class="variable">$0x0</span>,%edx</span><br><span class="line"> 80483f5:       85 d2                   <span class="built_in">test</span>   %edx,%edx</span><br><span class="line"> 80483f7:       74 f2                   je     80483eb &lt;frame_dummy+0xb&gt;</span><br><span class="line"> 80483f9:       55                      push   %ebp</span><br><span class="line"> 80483fa:       89 e5                   mov    %esp,%ebp</span><br><span class="line"> 80483fc:       83 ec 14                sub    <span class="variable">$0x14</span>,%esp</span><br><span class="line"> 80483ff:       50                      push   %eax</span><br><span class="line"> 8048400:       ff d2                   call   *%edx</span><br><span class="line"> 8048402:       83 c4 10                add    <span class="variable">$0x10</span>,%esp</span><br><span class="line"> 8048405:       c9                      leave  </span><br><span class="line"> 8048406:       e9 75 ff ff ff          jmp    8048380 &lt;register_tm_clones&gt;</span><br><span class="line"></span><br><span class="line">0804840b &lt;main&gt;:</span><br><span class="line"></span><br><span class="line">int out_sum;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line"> 804840b:       8d 4c 24 04             lea    0x4(%esp),%ecx</span><br><span class="line"> 804840f:       83 e4 f0                and    <span class="variable">$0xfffffff0</span>,%esp</span><br><span class="line"> 8048412:       ff 71 <span class="built_in">fc</span>                pushl  -0x4(%ecx)</span><br><span class="line"> 8048415:       55                      push   %ebp</span><br><span class="line"> 8048416:       89 e5                   mov    %esp,%ebp</span><br><span class="line"> 8048418:       51                      push   %ecx</span><br><span class="line"> 8048419:       83 ec 14                sub    <span class="variable">$0x14</span>,%esp</span><br><span class="line">        int <span class="built_in">id</span> = module_id;</span><br><span class="line"> 804841c:       a1 1c a0 04 08          mov    0x804a01c,%eax</span><br><span class="line"> 8048421:       89 45 ec                mov    %eax,-0x14(%ebp)</span><br><span class="line">        char *name = module_name;</span><br><span class="line"> 8048424:       a1 20 a0 04 08          mov    0x804a020,%eax</span><br><span class="line"> 8048429:       89 45 f0                mov    %eax,-0x10(%ebp)</span><br><span class="line">        int <span class="built_in">sum</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;module：%d %s\n&quot;</span>, <span class="built_in">id</span>, name);</span><br><span class="line"> 804842c:       83 ec 04                sub    <span class="variable">$0x4</span>,%esp</span><br><span class="line"> 804842f:       ff 75 f0                pushl  -0x10(%ebp)</span><br><span class="line"> 8048432:       ff 75 ec                pushl  -0x14(%ebp)</span><br><span class="line"> 8048435:       68 10 85 04 08          push   <span class="variable">$0x8048510</span></span><br><span class="line"> 804843a:       e8 a1 fe ff ff          call   80482e0 &lt;<span class="built_in">printf</span>@plt&gt;</span><br><span class="line"> 804843f:       83 c4 10                add    <span class="variable">$0x10</span>,%esp</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sum</span> = add(2,3);</span><br><span class="line"> 8048442:       83 ec 08                sub    <span class="variable">$0x8</span>,%esp</span><br><span class="line"> 8048445:       6a 03                   push   <span class="variable">$0x3</span></span><br><span class="line"> 8048447:       6a 02                   push   <span class="variable">$0x2</span></span><br><span class="line"> 8048449:       e8 2e 00 00 00          call   804847c &lt;add&gt;</span><br><span class="line"> 804844e:       83 c4 10                add    <span class="variable">$0x10</span>,%esp</span><br><span class="line"> 8048451:       89 45 f4                mov    %eax,-0xc(%ebp)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sum: %d\n&quot;</span>, <span class="built_in">sum</span>);</span><br><span class="line"> 8048454:       83 ec 08                sub    <span class="variable">$0x8</span>,%esp</span><br><span class="line"> 8048457:       ff 75 f4                pushl  -0xc(%ebp)</span><br><span class="line"> 804845a:       68 20 85 04 08          push   <span class="variable">$0x8048520</span></span><br><span class="line"> 804845f:       e8 7c fe ff ff          call   80482e0 &lt;<span class="built_in">printf</span>@plt&gt;</span><br><span class="line"> 8048464:       83 c4 10                add    <span class="variable">$0x10</span>,%esp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        out_sum = <span class="built_in">sum</span>;</span><br><span class="line"> 8048467:       8b 45 f4                mov    -0xc(%ebp),%eax</span><br><span class="line"> 804846a:       a3 28 a0 04 08          mov    %eax,0x804a028</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> 0x0;</span><br><span class="line"> 804846f:       b8 00 00 00 00          mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">&#125;</span><br><span class="line"> 8048474:       8b 4d <span class="built_in">fc</span>                mov    -0x4(%ebp),%ecx</span><br><span class="line"> 8048477:       c9                      leave  </span><br><span class="line"> 8048478:       8d 61 <span class="built_in">fc</span>                lea    -0x4(%ecx),%esp</span><br><span class="line"> 804847b:       c3                      ret    </span><br><span class="line"></span><br><span class="line">0804847c &lt;add&gt;:</span><br><span class="line"></span><br><span class="line">int module_id = 1001;</span><br><span class="line">char *module_name = <span class="string">&quot;calc&quot;</span>;</span><br><span class="line"></span><br><span class="line">int add(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line"> 804847c:       55                      push   %ebp</span><br><span class="line"> 804847d:       89 e5                   mov    %esp,%ebp</span><br><span class="line">        <span class="built_in">return</span> a+b;</span><br><span class="line"> 804847f:       8b 55 08                mov    0x8(%ebp),%edx</span><br><span class="line"> 8048482:       8b 45 0c                mov    0xc(%ebp),%eax</span><br><span class="line"> 8048485:       01 d0                   add    %edx,%eax</span><br><span class="line">&#125;</span><br><span class="line"> 8048487:       5d                      pop    %ebp</span><br><span class="line"> 8048488:       c3                      ret    </span><br><span class="line"> 8048489:       66 90                   xchg   %ax,%ax</span><br><span class="line"> 804848b:       66 90                   xchg   %ax,%ax</span><br><span class="line"> 804848d:       66 90                   xchg   %ax,%ax</span><br><span class="line"> 804848f:       90                      nop</span><br><span class="line"></span><br><span class="line">08048490 &lt;__libc_csu_init&gt;:</span><br><span class="line"> 8048490:       55                      push   %ebp</span><br><span class="line"> 8048491:       57                      push   %edi</span><br><span class="line"> 8048492:       56                      push   %esi</span><br><span class="line"> 8048493:       53                      push   %ebx</span><br><span class="line"> 8048494:       e8 a7 fe ff ff          call   8048340 &lt;__x86.get_pc_thunk.bx&gt;</span><br><span class="line"> 8048499:       81 c3 67 1b 00 00       add    <span class="variable">$0x1b67</span>,%ebx</span><br><span class="line"> 804849f:       83 ec 0c                sub    <span class="variable">$0xc</span>,%esp</span><br><span class="line"> 80484a2:       8b 6c 24 20             mov    0x20(%esp),%ebp</span><br><span class="line"> 80484a6:       8d b3 0c ff ff ff       lea    -0xf4(%ebx),%esi</span><br><span class="line"> 80484ac:       e8 fb fd ff ff          call   80482ac &lt;_init&gt;</span><br><span class="line"> 80484b1:       8d 83 08 ff ff ff       lea    -0xf8(%ebx),%eax</span><br><span class="line"> 80484b7:       29 c6                   sub    %eax,%esi</span><br><span class="line"> 80484b9:       c1 fe 02                sar    <span class="variable">$0x2</span>,%esi</span><br><span class="line"> 80484bc:       85 f6                   <span class="built_in">test</span>   %esi,%esi</span><br><span class="line"> 80484be:       74 25                   je     80484e5 &lt;__libc_csu_init+0x55&gt;</span><br><span class="line"> 80484c0:       31 ff                   xor    %edi,%edi</span><br><span class="line"> 80484c2:       8d b6 00 00 00 00       lea    0x0(%esi),%esi</span><br><span class="line"> 80484c8:       83 ec 04                sub    <span class="variable">$0x4</span>,%esp</span><br><span class="line"> 80484cb:       ff 74 24 2c             pushl  0x2c(%esp)</span><br><span class="line"> 80484cf:       ff 74 24 2c             pushl  0x2c(%esp)</span><br><span class="line"> 80484d3:       55                      push   %ebp</span><br><span class="line"> 80484d4:       ff 94 bb 08 ff ff ff    call   *-0xf8(%ebx,%edi,4)</span><br><span class="line"> 80484db:       83 c7 01                add    <span class="variable">$0x1</span>,%edi</span><br><span class="line"> 80484de:       83 c4 10                add    <span class="variable">$0x10</span>,%esp</span><br><span class="line"> 80484e1:       39 f7                   cmp    %esi,%edi</span><br><span class="line"> 80484e3:       75 e3                   jne    80484c8 &lt;__libc_csu_init+0x38&gt;</span><br><span class="line"> 80484e5:       83 c4 0c                add    <span class="variable">$0xc</span>,%esp</span><br><span class="line"> 80484e8:       5b                      pop    %ebx</span><br><span class="line"> 80484e9:       5e                      pop    %esi</span><br><span class="line"> 80484ea:       5f                      pop    %edi</span><br><span class="line"> 80484eb:       5d                      pop    %ebp</span><br><span class="line"> 80484ec:       c3                      ret    </span><br><span class="line"> 80484ed:       8d 76 00                lea    0x0(%esi),%esi</span><br><span class="line"></span><br><span class="line">080484f0 &lt;__libc_csu_fini&gt;:</span><br><span class="line"> 80484f0:       f3 c3                   repz ret </span><br><span class="line"></span><br><span class="line">Disassembly of section .fini:</span><br><span class="line"></span><br><span class="line">080484f4 &lt;_fini&gt;:</span><br><span class="line"> 80484f4:       53                      push   %ebx</span><br><span class="line"> 80484f5:       83 ec 08                sub    <span class="variable">$0x8</span>,%esp</span><br><span class="line"> 80484f8:       e8 43 fe ff ff          call   8048340 &lt;__x86.get_pc_thunk.bx&gt;</span><br><span class="line"> 80484fd:       81 c3 03 1b 00 00       add    <span class="variable">$0x1b03</span>,%ebx</span><br><span class="line"> 8048503:       83 c4 08                add    <span class="variable">$0x8</span>,%esp</span><br><span class="line"> 8048506:       5b                      pop    %ebx</span><br><span class="line"> 8048507:       c3                      ret    </span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>objdump</tag>
      </tags>
  </entry>
  <entry>
    <title>nm目标文件格式分析</title>
    <url>/2020/09/24/nm%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>nm 命令显示关于指定 File 中符号的信息，文件可以是对象文件、可执行文件或对象文件库。</li>
<li>如果文件没有包含符号信息，nm 命令报告该情况，但不把它解释为出错条件。 </li>
<li>nm 命令缺省情况下报告十六进制符号表示法下的数字值。<span id="more"></span></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$nm</span> myProgrammer</span><br><span class="line">08049f28 d _DYNAMIC</span><br><span class="line">08049ff4 d _GLOBAL_OFFSET_TABLE_</span><br><span class="line">080484dc R _IO_stdin_used</span><br><span class="line">         w _Jv_RegisterClasses</span><br><span class="line">08049f18 d __CTOR_END__</span><br><span class="line">08049f14 d __CTOR_LIST__</span><br><span class="line">08049f20 D __DTOR_END__</span><br><span class="line">08049f1c d __DTOR_LIST__</span><br><span class="line">080485e0 r __FRAME_END__</span><br><span class="line">08049f24 d __JCR_END__</span><br><span class="line">08049f24 d __JCR_LIST__</span><br><span class="line">0804a014 A __bss_start</span><br><span class="line">0804a00c D __data_start</span><br><span class="line">08048490 t __do_global_ctors_aux</span><br><span class="line">08048360 t __do_global_dtors_aux</span><br><span class="line">0804a010 D __dso_handle</span><br><span class="line">         w __gmon_start__</span><br><span class="line">08048482 T __i686.get_pc_thunk.bx</span><br><span class="line">08049f14 d __init_array_end</span><br><span class="line">08049f14 d __init_array_start</span><br><span class="line">08048480 T __libc_csu_fini</span><br><span class="line">08048410 T __libc_csu_init</span><br><span class="line">         U __libc_start_main@@GLIBC_2.0</span><br><span class="line">0804a014 A _edata</span><br><span class="line">0804a01c A _end</span><br><span class="line">080484bc T _fini</span><br><span class="line">080484d8 R _fp_hw</span><br><span class="line">080482b4 T _init</span><br><span class="line">08048330 T _start</span><br><span class="line">0804a014 b completed.6086</span><br><span class="line">0804a00c W data_start</span><br><span class="line">0804a018 b dtor_idx.6088</span><br><span class="line">080483c0 t frame_dummy</span><br><span class="line">080483e4 T main</span><br><span class="line">         U <span class="built_in">printf</span>@@GLIBC_2.0</span><br></pre></td></tr></table></figure>
<p>这些包含可执行代码的段称为代码段。<br>同样地，数据段包含了不可执行的信息或数据。<br>另一种类型的段，称为 BSS 段，它包含以符号数据开头的块。<br>对于 nm 命令列出的每个符号，它们的值使用十六进制来表示（缺省行为），并且在该符号前面加上了一个表示符号类型的编码字符。</p>
<p>可以将目标文件中所包含的不同的部分划分为段。段可以包含可执行代码、符号名称、初始数据值和许多其他类型的数据。有关这些类型的数据的详细信息，可以阅读 UNIX 中 nm 的 man 页面，其中按照该命令输出中的字符编码分别对每种类型进行了描述。</p>
<h2 id="选项说明"><a href="#选项说明" class="headerlink" title="选项说明"></a>选项说明</h2><p><code>-a或–debug-syms</code>：显示所有的符号，包括debugger-only symbols。<br><code>-B</code>：等同于–format=bsd，用来兼容MIPS的nm。<br><code>-C或–demangle</code>：将低级符号名解析(demangle)成用户级名字。这样可以使得C++函数名具有可读性。<br><code>–no-demangle</code>：默认的选项，不需要将低级符号名解析成用户级名。<br><code>-D或–dynamic</code>：显示动态符号。该任选项仅对于动态目标(例如特定类型的共享库)有意义。<br><code>-f format</code>：使用format格式输出。format可以选取bsd、sysv或posix，该选项在GNU的nm中有用。默认为bsd。<br><code>-g或–extern-only</code>：仅显示外部符号。<br><code>-n、-v或–numeric-sort</code>：按符号对应地址的顺序排序，而非按符号名的字符顺序。<br><code>-p或–no-sort</code>：按目标文件中遇到的符号顺序显示，不排序。<br><code>-P或–portability</code>：使用POSIX.2标准输出格式代替默认的输出格式。等同于使用任选项-f posix。<br><code>-s或–print-armap</code>：当列出库中成员的符号时，包含索引。索引的内容包含：哪些模块包含哪些名字的映射。<br><code>-r或–reverse-sort</code>：反转排序的顺序(例如，升序变为降序)。<br><code>–size-sort</code>：按大小排列符号顺序。该大小是按照一个符号的值与它下一个符号的值进行计算的。<br><code>–target=bfdname</code>：指定一个目标代码的格式，而非使用系统的默认格式。<br><code>-u或–undefined-only</code>：仅显示没有定义的符号(那些外部符号)。<br><code>–defined-only</code>:仅显示定义的符号。<br><code>-l或–line-numbers</code>：对每个符号，使用调试信息来试图找到文件名和行号。<br><code>-V或–version</code>：显示nm的版本号。<br><code>–help</code>：显示nm的选项。</p>
<h2 id="符号说明"><a href="#符号说明" class="headerlink" title="符号说明"></a>符号说明</h2><p>对于每一个符号来说，其类型如果是<strong>小写</strong>的，则表明该符号是<strong>local</strong>的；<br><strong>大写</strong>则表明该符号是<strong>global</strong>的。</p>
<p><code>A</code> 该符号的值是绝对的，在以后的链接过程中，不允许进行改变。<br>这样的符号值，常常出现在<strong>中断向量表</strong>中，例如用符号来表示各个中断向量函数在中断向量表中的位置。<br><code>B</code> 该符号的值出现在<strong>非初始化static数据段bss</strong>中。例如，在一个文件中定义全局static int test。<br>则该符号test的类型为b，位于bss section中。其值表示该符号在bss段中的偏移。一般而言，bss段分配于RAM中。<br><code>C</code> 该符号为common。common symbol是<strong>非初始化数据段</strong>。该符号没有包含于一个普通section中。只有在链接过程中才进行分配。符号的值表示该符号需要的字节数。<br>例如在一个c文件中，定义int test，并且该符号在别的地方会被引用，则该符号类型即为C。否则其类型为B。<br><code>D</code> 该符号位于<strong>初始化数据段</strong>中。一般来说，分配到data section中。<br>例如：定义全局int baud_table[5] = {9600, 19200, 38400, 57600, 115200}，会分配到初始化数据段中。<br><code>G</code> 该符号也位于初始化数据段中。主要用于small object提高访问small data object的一种方式。<br><code>I</code> 该符号是对另一个符号的间接引用。<br><code>N</code> 该符号是一个debugging符号。<br><code>R</code> 该符号位于只读数据区。<br>例如定义全局const int test[] = {123, 123};则test就是一个只读数据区的符号。<br>值得注意的是，如果在一个函数中定义const char *test = “abc”, const char test_int = 3。使用nm都不会得到符号信息，但是字符串”abc”分配于只读存储器中，test在rodata section中，大小为4。<br><code>S</code> 符号位于非初始化数据区，用于small object。<br><code>T</code> 该符号位于代码区text section。<br><code>U</code> 该符号在当前文件中是未定义的，即该符号的定义在别的文件中。<br>例如，当前文件调用另一个文件中定义的函数，在这个被调用的函数在当前就是未定义的；但是在定义它的文件中类型是T。但是对于全局变量来说，在定义它的文件中，其符号类型为C，在使用它的文件中，其类型为U。<br><code>V</code> 该符号是一个weak object。<br><code>W</code> The symbol is a weak symbol that has not been specifically tagged as a weak object symbol.<br><code>?</code> 该符号类型没有定义<br>库或对象名 如果您指定了 -A 选项，则 nm 命令只报告与该文件有关的或者库或者对象名。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>寻找特殊标识<br>有时会碰到一个编译了但没有链接的代码，那是因为它缺失了标识符；这种情况，可以用nm和objdump、readelf命令来查看程序的符号表；所有这些命令做的工作基本一样；</p>
<p>比如连接器报错有未定义的标识符；大多数情况下，会发生在库的缺失或企图链接一个错误版本的库的时候；浏览目标代码来寻找一个特殊标识符的引用:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nm -uCA *.o | grep foo</span><br></pre></td></tr></table></figure>
<p><code>-u</code>选项限制了每个目标文件中未定义标识符的输出。<br><code>-A</code>选项用于显示每个标识符的文件名信息；对于C++代码，常用的还有<code>-C</code>选项，它也为解码这些标识符；</p>
<p>注解<br>objdump、readld命令可以完成同样的任务。等效命令为： <code>$objdump -t $readelf -s</code></p>
<p>列出 a.out 对象文件的静态和外部符:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$nm</span> -e a.out</span><br></pre></td></tr></table></figure>

<p>以十六进制显示符号大小和值并且按值排序符号:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$nm</span> -xv a.out</span><br></pre></td></tr></table></figure>

<p>显示 libc.a 中所有 64 位对象符号，忽略所有 32 位对象:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$nm</span> -X64 /usr/lib/libc.a</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>nm</tag>
      </tags>
  </entry>
  <entry>
    <title>strace</title>
    <url>/2020/09/23/strace/</url>
    <content><![CDATA[<h2 id="跟踪进程中的系统调用"><a href="#跟踪进程中的系统调用" class="headerlink" title="跟踪进程中的系统调用"></a>跟踪进程中的系统调用</h2><ul>
<li>strace常用来跟踪进程执行时的系统调用和所接收的信号。 </li>
<li>在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。</li>
<li>strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。<br>追踪test进程关于信号的系统调用：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">strace -tt -e trace=signal -p `pidof <span class="built_in">test</span>`</span><br></pre></td></tr></table></figure>
<span id="more"></span></li>
</ul>
<h2 id="输出参数含义"><a href="#输出参数含义" class="headerlink" title="输出参数含义"></a>输出参数含义</h2><p>每一行都是一条系统调用，等号左边是系统调用的函数名及其参数，右边是该调用的返回值。 strace 显示这些调用的参数并返回符号形式的值。strace 从内核接收信息，而且不需要以任何特殊的方式来构建内核。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$strace</span> <span class="built_in">cat</span> /dev/null</span><br><span class="line">execve(<span class="string">&quot;/bin/cat&quot;</span>, [<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;/dev/null&quot;</span>], [/* 22 vars */]) = 0</span><br><span class="line">brk(0)                                  = 0xab1000</span><br><span class="line">access(<span class="string">&quot;/etc/ld.so.nohwcap&quot;</span>, F_OK)      = -1 ENOENT (No such file or directory)</span><br><span class="line">mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f29379a7000</span><br><span class="line">access(<span class="string">&quot;/etc/ld.so.preload&quot;</span>, R_OK)      = -1 ENOENT (No such file or directory)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p><code>-c</code> 统计每一系统调用的所执行的时间,次数和出错的次数等.<br><code>-d</code> 输出strace关于标准错误的调试信息.<br><code>-f</code> 跟踪由fork调用所产生的子进程.<br><code>-ff</code> 如果提供-o filename,则所有进程的跟踪结果输出到相应的filename.pid中,pid是各进程的进程号.<br><code>-F</code> 尝试跟踪vfork调用.在-f时,vfork不被跟踪.<br><code>-h</code> 输出简要的帮助信息.<br><code>-i</code> 输出系统调用的入口指针.<br><code>-q</code> 禁止输出关于脱离的消息.<br><code>-r</code> 打印出相对时间关于,,每一个系统调用.<br><code>-t</code> 在输出中的每一行前加上时间信息.<br><code>-tt</code> 在输出中的每一行前加上时间信息,微秒级.<br><code>-ttt</code> 微秒级输出,以秒了表示时间.<br><code>-T</code> 显示每一调用所耗的时间.<br><code>-v</code> 输出所有的系统调用.一些调用关于环境变量,状态,输入输出等调用由于使用频繁,默认不输出.<br><code>-V</code> 输出strace的版本信息.<br><code>-x</code> 以十六进制形式输出非标准字符串<br><code>-xx</code> 所有字符串以十六进制形式输出.<br><code>-a</code> column<br>设置返回值的输出位置.默认 为40.<br><code>-e expr</code><br>指定一个表达式,用来控制如何跟踪.格式如下:<br>[qualifier=][!]value1[,value2]…<br>qualifier只能是 trace,abbrev,verbose,raw,signal,read,write其中之一.value是用来限定的符号或数字.默认的 qualifier是 trace.感叹号是否定符号.例如:<br>-eopen等价于 -e trace=open,表示只跟踪open调用.而-e trace!=open表示跟踪除了open以外的其他调用.有两个特殊的符号 all 和 none.<br>注意有些shell使用!来执行历史记录里的命令,所以要使用\.<br><code>-e trace=set</code><br>只跟踪指定的系统 调用.例如:-e trace=open,close,rean,write表示只跟踪这四个系统调用.默认的为set=all.<br><code>-e trace=file</code><br>只跟踪有关文件操作的系统调用.<br><code>-e trace=process</code><br>只跟踪有关进程控制的系统调用.<br><code>-e trace=network</code><br>跟踪与网络有关的所有系统调用.<br><code>-e trace=signal</code><br>跟踪所有与系统信号有关的 系统调用<br><code>-e trace=ipc</code><br>跟踪所有与进程通讯有关的系统调用<br><code>-e abbrev=set</code><br>设定 strace输出的系统调用的结果集.-v 等与 abbrev=none.默认为abbrev=all.<br><code>-e raw=set</code><br>将指 定的系统调用的参数以十六进制显示.<br><code>-e signal=set</code><br>指定跟踪的系统信号.默认为all.如 signal=!SIGIO(或者signal=!io),表示不跟踪SIGIO信号.<br><code>-e read=set</code><br>输出从指定文件中读出 的数据.例如:<br><code>-e read=3,5</code><br><code>-e write=set</code><br>输出写入到指定文件中的数据.<br><code>-o filename</code><br>将strace的输出写入文件filename<br><code>-p pid</code><br>跟踪指定的进程pid.<br><code>-s strsize</code><br>指定输出的字符串的最大长度.默认为32.文件名一直全部输出.<br><code>-u username</code><br>以username 的UID和GID执行被跟踪的命令</p>
<h2 id="命令实例"><a href="#命令实例" class="headerlink" title="命令实例"></a>命令实例</h2><p>跟踪可执行程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">strace -f -F -o ~/straceout.txt myserver</span><br></pre></td></tr></table></figure>
<p><code>-f -F</code>选项告诉strace同时跟踪fork和vfork出来的进程<br><code>-o</code>选项把所有strace输出写到~/straceout.txt里 面，myserver是要启动和调试的程序。</p>
<p>跟踪服务程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">strace -o output.txt -T -tt -e trace=all -p 28979</span><br></pre></td></tr></table></figure>
<p>跟踪28979进程的所有系统调用（-e trace=all），并统计系统调用的花费时间，以及开始时间（并以可视化的时分秒格式显示），最后将记录结果存在output.txt文件里面。</p>
]]></content>
      <categories>
        <category>进程调试</category>
      </categories>
      <tags>
        <tag>strace</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb</title>
    <url>/2020/09/22/gdb/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>GDB是一个由GNU开源组织发布的、UNIX/LINUX操作系统下的、基于命令行的、功能强大的程序调试工具。 对于一名Linux下工作的c/c++程序员，gdb是必不可少的工具。</p>
<span id="more"></span>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>对C/C++程序的调试，需要在编译前就加上-g选项:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$g</span>++ -g hello.cpp -o hello</span><br></pre></td></tr></table></figure>
<p>调试可执行文件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$gdb</span> &lt;program&gt;</span><br></pre></td></tr></table></figure>
<p>program也就是你的执行文件，一般在当前目录下。</p>
<p>调试core文件(core是程序非法执行后core dump后产生的文件):</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$gdb</span> &lt;program&gt; &lt;core dump file&gt;</span><br><span class="line"><span class="variable">$gdb</span> program core.11127</span><br></pre></td></tr></table></figure>

<p>调试服务程序:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$gdb</span> &lt;program&gt; &lt;PID&gt;</span><br><span class="line"><span class="variable">$gdb</span> hello 11127</span><br></pre></td></tr></table></figure>
<p>如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他。program应该在PATH环境变量中搜索得到。</p>
<h2 id="gdb交互命令"><a href="#gdb交互命令" class="headerlink" title="gdb交互命令"></a>gdb交互命令</h2><p>启动gdb后，进入到交互模式，通过以下命令完成对程序的调试；注意高频使用的命令一般都会有缩写，熟练使用这些缩写命令能提高调试的效率；</p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p><code>run</code>：简记为<code>r</code> ，其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。<br><code>continue</code> （简写<code>c</code> ）：继续执行，到下一个断点处（或运行结束）<br><code>next</code>：（简写 <code>n</code>），单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内。<br><code>step</code> （简写<code>s</code>）：单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的<br><code>until</code>：当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。<br><code>until+行号</code>或者<code>adv+行号</code>： 运行至某行，不仅仅用来跳出循环<br><code>finish</code>： 运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。<br><code>call 函数(参数)</code>：调用程序中可见的函数，并传递“参数”，如：<code>call gdb_test(55)</code><br><code>quit</code>：简记为 <code>q</code> ，退出gdb</p>
<h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><p><code>break n</code> （简写<code>b n</code>）:在第n行处设置断点<br>（可以带上代码路径和代码名称： <code>b OAGUPDATE.cpp:578</code>）<br><code>b fn1 if a＞b</code>：条件断点设置<br><code>break func（break缩写为b）</code>：在函数func()的入口处设置断点，如：<code>break cb_button</code><br><code>delete 断点号n</code>：删除第n个断点<br><code>disable 断点号n</code>：暂停第n个断点<br><code>enable 断点号n</code>：开启第n个断点<br><code>clear 行号n</code>：清除第n行的断点<br><code>info b （info breakpoints）</code> ：显示当前程序的断点设置情况<br><code>delete breakpoints</code>：清除所有断点</p>
<h3 id="查看源代码"><a href="#查看源代码" class="headerlink" title="查看源代码"></a>查看源代码</h3><p><code>list</code> ：简记为 <code>l</code> ，其作用就是列出程序的源代码，默认每次显示10行。<br><code>list 行号</code>：将显示当前文件以“行号”为中心的前后10行代码，如：list 12<br><code>list 函数名</code>：将显示“函数名”所在函数的源代码，如：<code>list main</code><br><code>list</code> ：不带参数，将接着上一次 list 命令的，输出下边的内容。</p>
<h3 id="打印表达式"><a href="#打印表达式" class="headerlink" title="打印表达式"></a>打印表达式</h3><p><code>print 表达式</code>：简记为 <code>p</code> ，其中“表达式”可以是任何当前正在被测试程序的有效表达式，比如当前正在调试C语言的程序，那么“表达式”可以是任何C语言的有效表达式，包括数字，变量甚至是函数调用。<br><code>print a</code>：将显示整数 a 的值<br><code>print ++a</code>：将把 a 中的值加1,并显示出来<br><code>print name</code>：将显示字符串 name 的值<br><code>print gdb_test(22)</code>：将以整数22作为参数调用 gdb_test() 函数<br><code>print gdb_test(a)</code>：将以变量 a 作为参数调用 gdb_test() 函数<br><code>display 表达式</code>：在单步运行时将非常有用，使用display命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值。如： <code>display a</code><br><code>watch 表达式</code>：设置一个监视点，一旦被监视的“表达式”的值改变，gdb将强行终止正在被调试的程序。如： <code>watch a</code><br><code>whatis</code> ：查询变量或函数<br><code>info function</code>： 查询函数<br>扩展<code>info locals</code>： 显示当前堆栈页的所有变量</p>
<h3 id="查询运行信息"><a href="#查询运行信息" class="headerlink" title="查询运行信息"></a>查询运行信息</h3><p><code>where/bt</code> ：当前运行的堆栈列表；<br><code>bt</code> backtrace 显示当前调用堆栈<br><code>up/down</code> 改变堆栈显示的深度<br><code>set args</code> 参数:指定运行时的参数<br><code>show args</code>：查看设置好的参数<br><code>info program</code>： 来查看程序的是否在运行，进程号，被暂停的原因。<br><code>info variables</code>：查看全局和静态变量<br><code>info locals</code>：查看当前stack frame局部变量<br><code>info args</code>：查看当前stack frame参数</p>
<h3 id="分割窗口"><a href="#分割窗口" class="headerlink" title="分割窗口"></a>分割窗口</h3><p><code>layout</code>：用于分割窗口，可以一边查看代码，一边测试：<br><code>layout src</code>：显示源代码窗口<br><code>layout asm</code>：显示反汇编窗口<br><code>layout regs</code>：显示源代码/反汇编和CPU寄存器窗口<br><code>layout split</code>：显示源代码和反汇编窗口<br><code>Ctrl + L</code>：刷新窗口</p>
<h3 id="多线程调试"><a href="#多线程调试" class="headerlink" title="多线程调试"></a>多线程调试</h3><p><code>info threads</code>: 查看执行线程号<br><code>threads 线程号n</code>：进入到第n个线程<br><code>set scheduler-locking on</code> ： 多线程下禁止线程切换<br>编译选项<code>-g3</code>可以调试宏</p>
<h3 id="终端显示代码"><a href="#终端显示代码" class="headerlink" title="终端显示代码"></a>终端显示代码</h3><p><code>export TERM=xterm</code>：设置终端格式<br><code>ctrl + x + a</code>: 在gdb终端显示代码，此时代码目录需要被指定<br><code>dir</code>: 用来指定源文件目录<br>批量指定目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># find /opt/apigw/gwhw/src/hw/gw_parser -type d &gt; srcdir.cmd</span></span><br><span class="line"><span class="comment"># sed -i &#x27;s/^/dir /g&#x27; srcdir.cmd </span></span><br><span class="line">(gdb) <span class="built_in">source</span> srcdir1.cmd </span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure>
<p>指定具体某个目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) <span class="built_in">dir</span> /home/alipms/mr_work/prj_proc/commonLib/src/rtec</span><br><span class="line">Source directories searched: /home/alipms/mr_work/prj_proc/commonLib/src/rtec:<span class="variable">$cdir</span>:<span class="variable">$cwd</span></span><br><span class="line"></span><br><span class="line">(gdb) <span class="built_in">dir</span> /home/alipms/mr_work/ddi_cache/src/policy</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>进程调试</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>pstack</title>
    <url>/2020/09/21/pstack/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>pstack是一个脚本工具，可显示每个进程的栈跟踪。pstack 命令必须由相应进程的属主或 root 运行。其核心实现就是使用了gdb以及thread apply all bt命令;</p>
<p>语法:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$pstrack</span> &lt;program-pid&gt;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="脚本实现"><a href="#脚本实现" class="headerlink" title="脚本实现"></a>脚本实现</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> <span class="variable">$#</span> -ne 1; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Usage: `basename <span class="variable">$0</span> .sh` &lt;process-id&gt;&quot;</span> 1&gt;&amp;2</span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> ! -r /proc/<span class="variable">$1</span>; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Process <span class="variable">$1</span> not found.&quot;</span> 1&gt;&amp;2</span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># GDB doesn&#x27;t allow &quot;thread apply all bt&quot; when the process isn&#x27;t</span></span><br><span class="line"><span class="comment"># threaded; need to peek at the process to determine if that or the</span></span><br><span class="line"><span class="comment"># simpler &quot;bt&quot; should be used.</span></span><br><span class="line"></span><br><span class="line">backtrace=<span class="string">&quot;bt&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> -d /proc/<span class="variable">$1</span>/task ; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># Newer kernel; has a task/ directory.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">test</span> `/bin/ls /proc/<span class="variable">$1</span>/task | /usr/bin/wc -l` -gt 1 2&gt;/dev/null ; <span class="keyword">then</span></span><br><span class="line">	backtrace=<span class="string">&quot;thread apply all bt&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">test</span> -f /proc/<span class="variable">$1</span>/maps ; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># Older kernel; go by it loading libpthread.</span></span><br><span class="line">    <span class="keyword">if</span> /bin/grep -e libpthread /proc/<span class="variable">$1</span>/maps &gt; /dev/null 2&gt;&amp;1 ; <span class="keyword">then</span></span><br><span class="line">	backtrace=<span class="string">&quot;thread apply all bt&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">GDB=<span class="variable">$&#123;GDB:-gdb&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Run GDB, strip out unwanted noise.</span></span><br><span class="line"><span class="comment"># --readnever is no longer used since .gdb_index is now in use.</span></span><br><span class="line"><span class="variable">$GDB</span> --quiet -nx <span class="variable">$GDBARGS</span> /proc/<span class="variable">$1</span>/exe <span class="variable">$1</span> &lt;&lt;<span class="string">EOF 2&gt;&amp;1 | </span></span><br><span class="line"><span class="string">set width 0</span></span><br><span class="line"><span class="string">set height 0</span></span><br><span class="line"><span class="string">set pagination no</span></span><br><span class="line"><span class="string">$backtrace</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">/bin/sed -n \</span><br><span class="line">    -e <span class="string">&#x27;s/^\((gdb) \)*//&#x27;</span> \</span><br><span class="line">    -e <span class="string">&#x27;/^#/p&#x27;</span> \</span><br><span class="line">    -e <span class="string">&#x27;/^Thread/p&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pstack 4551</span><br><span class="line">Thread 7 (Thread 1084229984 (LWP 4552)):</span><br><span class="line"><span class="comment">#0  0x000000302afc63dc in epoll_wait () from /lib64/tls/libc.so.6</span></span><br><span class="line"><span class="comment">#1  0x00000000006f0730 in ub::EPollEx::poll ()</span></span><br><span class="line"><span class="comment">#2  0x00000000006f172a in ub::NetReactor::callback ()</span></span><br><span class="line"><span class="comment">#3  0x00000000006fbbbb in ub::UBTask::CALLBACK ()</span></span><br><span class="line"><span class="comment">#4  0x000000302b80610a in start_thread () from /lib64/tls/libpthread.so.0</span></span><br><span class="line"><span class="comment">#5  0x000000302afc6003 in clone () from /lib64/tls/libc.so.6</span></span><br><span class="line"><span class="comment">#6  0x0000000000000000 in ?? ()</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>进程调试</category>
      </categories>
      <tags>
        <tag>pstack</tag>
      </tags>
  </entry>
  <entry>
    <title>awk数据流处理工具</title>
    <url>/2020/09/20/awk%E6%95%B0%E6%8D%AE%E6%B5%81%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="awk脚本结构"><a href="#awk脚本结构" class="headerlink" title="awk脚本结构"></a>awk脚本结构</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27; BEGIN&#123; statements &#125; statements2 END&#123; statements &#125; &#x27;</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h2><ol>
<li>执行begin中语句块；</li>
<li>从文件或stdin中读入一行，然后执行statements2，重复这个过程，直到文件全部被读取完毕；</li>
<li>执行end语句块；</li>
</ol>
<h2 id="print-打印当前行"><a href="#print-打印当前行" class="headerlink" title="print 打印当前行"></a>print 打印当前行</h2><p>使用不带参数的print时，会打印当前行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;line1\nline2&quot;</span> | awk <span class="string">&#x27;BEGIN&#123;print &quot;start&quot;&#125; &#123;print &#125; END&#123; print &quot;End&quot; &#125;&#x27;</span></span><br><span class="line">start</span><br><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">End</span><br></pre></td></tr></table></figure>

<p>print 以逗号分割时，参数以空格定界;</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> | awk <span class="string">&#x27; &#123;var1 = &quot;v1&quot; ; var2 = &quot;V2&quot;; var3=&quot;v3&quot;; print var1, var2 , var3; &#125;&#x27;</span></span><br><span class="line">v1 V2 v3</span><br></pre></td></tr></table></figure>
<p>使用-拼接符的方式（””作为拼接符）;</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> | awk <span class="string">&#x27; &#123;var1 = &quot;v1&quot; ; var2 = &quot;V2&quot;; var3=&quot;v3&quot;; print var1&quot;-&quot;var2&quot;-&quot;var3; &#125;&#x27;</span></span><br><span class="line">v1-V2-v3</span><br></pre></td></tr></table></figure>

<h2 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h2><p><code>NR</code>:表示记录数量，在执行过程中对应当前行号；<br><code>NF</code>:表示字段数量，在执行过程总对应当前行的字段数；<br><code>$0</code>:这个变量包含执行过程中当前行的文本内容；<br><code>$1</code>:第一个字段的文本内容；<br><code>$2</code>:第二个字段的文本内容；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;line1 f2 f3\n line2 \n line 3&quot;</span> | awk <span class="string">&#x27;&#123;print NR&quot;:&quot;$1&quot;-&quot;$2&#125;&#x27;</span></span><br><span class="line">1:line1-f2</span><br><span class="line">2:line2-</span><br><span class="line">3:line-3</span><br></pre></td></tr></table></figure>

<p>打印每一行的第二和第三个字段</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;print $2, $3&#125;&#x27;</span> file</span><br></pre></td></tr></table></figure>
<p>统计文件的行数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27; END &#123;print NR&#125;&#x27;</span> file</span><br></pre></td></tr></table></figure>
<h2 id="累加每一行的第一个字段"><a href="#累加每一行的第一个字段" class="headerlink" title="累加每一行的第一个字段"></a>累加每一行的第一个字段</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;1\n 2\n 3\n 4\n&quot;</span> | awk <span class="string">&#x27;BEGIN&#123;num = 0&#125; &#123;sum += $1;&#125; END &#123;print sum &#125;&#x27;</span></span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<h2 id="传递外部变量"><a href="#传递外部变量" class="headerlink" title="传递外部变量"></a>传递外部变量</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var=1000</span><br><span class="line"><span class="built_in">echo</span> | awk <span class="string">&#x27;&#123;print vara&#125;&#x27;</span> vara=<span class="variable">$var</span> <span class="comment">#  输入来自stdin</span></span><br><span class="line">awk <span class="string">&#x27;&#123;print vara&#125;&#x27;</span> vara=<span class="variable">$var</span> file <span class="comment"># 输入来自文件</span></span><br></pre></td></tr></table></figure>
<h2 id="用样式对awk处理的行进行过滤"><a href="#用样式对awk处理的行进行过滤" class="headerlink" title="用样式对awk处理的行进行过滤"></a>用样式对awk处理的行进行过滤</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;NR &lt; 5&#x27;</span> <span class="comment">#行号小于5</span></span><br><span class="line">awk <span class="string">&#x27;NR==1,NR==4 &#123;print&#125;&#x27;</span> file <span class="comment">#行号等于1和4的打印出来</span></span><br><span class="line">awk <span class="string">&#x27;/linux/&#x27;</span> <span class="comment">#包含linux文本的行（可以用正则表达式来指定，超级强大）</span></span><br><span class="line">awk <span class="string">&#x27;!/linux/&#x27;</span> <span class="comment">#不包含linux文本的行</span></span><br></pre></td></tr></table></figure>
<h2 id="设置定界符"><a href="#设置定界符" class="headerlink" title="设置定界符"></a>设置定界符</h2><p>使用-F来设置定界符（默认为空格）:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk -F: <span class="string">&#x27;&#123;print $NF&#125;&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure>
<h2 id="读取命令输出"><a href="#读取命令输出" class="headerlink" title="读取命令输出"></a>读取命令输出</h2><p>使用getline，将外部shell命令的输出读入到变量cmdout中:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> | awk <span class="string">&#x27;&#123;&quot;grep root /etc/passwd&quot; | getline cmdout; print cmdout &#125;&#x27;</span></span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br></pre></td></tr></table></figure>

<h2 id="在awk中使用循环"><a href="#在awk中使用循环" class="headerlink" title="在awk中使用循环"></a>在awk中使用循环</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=0;i&lt;10;i++)&#123;<span class="built_in">print</span> <span class="variable">$i</span>;&#125;</span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> array)&#123;<span class="built_in">print</span> array[i];&#125;</span><br></pre></td></tr></table></figure>

<p>以逆序的形式打印行：(tac命令的实现）:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">seq</span> 9| \</span><br><span class="line">awk <span class="string">&#x27;&#123;lifo[NR] = $0; lno=NR&#125; \</span></span><br><span class="line"><span class="string">END&#123; for(;lno&gt;-1;lno--)&#123;print lifo[lno];&#125;</span></span><br><span class="line"><span class="string">&#125; &#x27;</span>\</span><br></pre></td></tr></table></figure>
<p>等同于<code>seq 9|tac</code></p>
<p>awk结合grep找到指定的服务，然后将其kill掉</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef| grep msv8 | grep -v MFORWARD | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> | xargs <span class="built_in">kill</span> -9;</span><br></pre></td></tr></table></figure>

<h2 id="打印指定列"><a href="#打印指定列" class="headerlink" title="打印指定列"></a>打印指定列</h2><p>awk方式实现</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -lrt | awk <span class="string">&#x27;&#123;print $6&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>cut方式实现</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -lrt | <span class="built_in">cut</span> -f6</span><br></pre></td></tr></table></figure>

<h2 id="打印指定文本区域"><a href="#打印指定文本区域" class="headerlink" title="打印指定文本区域"></a>打印指定文本区域</h2><p>确定行号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">seq</span> 100| awk <span class="string">&#x27;NR==4,NR==6&#123;print&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>确定文本<br>打印处于start_pattern 和end_pattern之间的文本:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;/start_pattern/, /end_pattern/&#x27;</span> filename</span><br></pre></td></tr></table></figure>

<p>示例:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">seq</span> 100 | awk <span class="string">&#x27;/13/,/15/&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="awk常用内建函数"><a href="#awk常用内建函数" class="headerlink" title="awk常用内建函数"></a>awk常用内建函数</h2><p><code>index(string,search_string)</code>:返回search_string在string中出现的位置<br><code>sub(regex,replacement_str,string)</code>:将正则匹配到的第一处内容替换为replacement_str;<br><code>match(regex,string)</code>:检查正则表达式是否能够匹配字符串；<br><code>length(string)</code>：返回字符串长度</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> | awk <span class="string">&#x27;&#123;&quot;grep root /etc/passwd&quot; | getline cmdout; print length(cmdout) &#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>printf 类似c语言中的printf，对输出进行格式化:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">seq</span> 10 | awk <span class="string">&#x27;&#123;printf &quot;-&gt;%4s\n&quot;, $1&#125;&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SHELL</category>
      </categories>
      <tags>
        <tag>awk</tag>
      </tags>
  </entry>
  <entry>
    <title>sed文本替换利器</title>
    <url>/2020/09/19/sed%E6%96%87%E6%9C%AC%E6%9B%BF%E6%8D%A2%E5%88%A9%E5%99%A8/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>sed 是一种流编辑器，它是文本处理中非常重要的工具，能够完美的配合正则表达式使用，功能不同凡响。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。</p>
<span id="more"></span>

<h2 id="sed的选项、命令、替换标记"><a href="#sed的选项、命令、替换标记" class="headerlink" title="sed的选项、命令、替换标记"></a>sed的选项、命令、替换标记</h2><h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed [options] <span class="string">&#x27;command&#x27;</span> file(s)</span><br><span class="line">sed [options] -f scriptfile file(s)</span><br></pre></td></tr></table></figure>

<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p><code>-e&lt;script&gt;或--expression=&lt;script&gt;</code>：以选项中的指定的script来处理输入的文本文件；<br><code>-f&lt;script文件&gt;或--file=&lt;script文件&gt;</code>：以选项中指定的script文件来处理输入的文本文件；<br><code>-h或--help</code>：显示帮助；<br><code>-n或--quiet或——silent</code>：仅显示script处理后的结果；<br><code>-V或--version</code>：显示版本信息。</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>文件：指定待处理的文本文件列表。</p>
<h3 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a>sed命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a\ <span class="comment"># 在当前行下面插入文本。</span></span><br><span class="line">i\ <span class="comment"># 在当前行上面插入文本。</span></span><br><span class="line">c\ <span class="comment"># 把选定的行改为新的文本。</span></span><br><span class="line">d <span class="comment"># 删除，删除选择的行。</span></span><br><span class="line">D <span class="comment"># 删除模板块的第一行。</span></span><br><span class="line">s <span class="comment"># 替换指定字符</span></span><br><span class="line">h <span class="comment"># 拷贝模板块的内容到内存中的缓冲区。</span></span><br><span class="line">H <span class="comment"># 追加模板块的内容到内存中的缓冲区。</span></span><br><span class="line">g <span class="comment"># 获得内存缓冲区的内容，并替代当前模板块中的文本。</span></span><br><span class="line">G <span class="comment"># 获得内存缓冲区的内容，并追加到当前模板块文本的后面。</span></span><br><span class="line">l <span class="comment"># 列表不能打印字符的清单。</span></span><br><span class="line">n <span class="comment"># 读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。</span></span><br><span class="line">N <span class="comment"># 追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码。</span></span><br><span class="line">p <span class="comment"># 打印模板块的行。</span></span><br><span class="line">P <span class="comment"># (大写) 打印模板块的第一行。</span></span><br><span class="line">q <span class="comment"># 退出Sed。</span></span><br><span class="line">b lable <span class="comment"># 分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾。</span></span><br><span class="line">r file <span class="comment"># 从file中读行。</span></span><br><span class="line">t label <span class="comment"># if分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。</span></span><br><span class="line">T label <span class="comment"># 错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。</span></span><br><span class="line">w file <span class="comment"># 写并追加模板块到file末尾。  </span></span><br><span class="line">W file <span class="comment"># 写并追加模板块的第一行到file末尾。  </span></span><br><span class="line">! <span class="comment"># 表示后面的命令对所有没有被选定的行发生作用。  </span></span><br><span class="line">= <span class="comment"># 打印当前行号码。  </span></span><br><span class="line"><span class="comment"># # 把注释扩展到下一个换行符以前。 </span></span><br></pre></td></tr></table></figure>

<h3 id="sed替换标记"><a href="#sed替换标记" class="headerlink" title="sed替换标记"></a>sed替换标记</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g <span class="comment"># 表示行内全面替换。  </span></span><br><span class="line">p <span class="comment"># 表示打印行。  </span></span><br><span class="line">w <span class="comment"># 表示把行写入一个文件。  </span></span><br><span class="line">x <span class="comment"># 表示互换模板块中的文本和缓冲区中的文本。  </span></span><br><span class="line">y <span class="comment"># 表示把一个字符翻译为另外的字符（但是不用于正则表达式）</span></span><br><span class="line">\1 <span class="comment"># 子串匹配标记</span></span><br><span class="line">&amp; <span class="comment"># 已匹配字符串标记</span></span><br></pre></td></tr></table></figure>

<h3 id="sed元字符集"><a href="#sed元字符集" class="headerlink" title="sed元字符集"></a>sed元字符集</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">^ <span class="comment"># 匹配行开始，如：/^sed/匹配所有以sed开头的行。</span></span><br><span class="line">$ <span class="comment"># 匹配行结束，如：/sed$/匹配所有以sed结尾的行。</span></span><br><span class="line">. <span class="comment"># 匹配一个非换行符的任意字符，如：/s.d/匹配s后接一个任意字符，最后是d。</span></span><br><span class="line">* <span class="comment"># 匹配0个或多个字符，如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。</span></span><br><span class="line">[] <span class="comment"># 匹配一个指定范围内的字符，如/[sS]ed/匹配sed和Sed。  </span></span><br><span class="line">[^] <span class="comment"># 匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。</span></span><br><span class="line">\(..\) <span class="comment"># 匹配子串，保存匹配的字符，如s/\(love\)able/\1rs，loveable被替换成lovers。</span></span><br><span class="line">&amp; <span class="comment"># 保存搜索字符用来替换其他字符，如s/love/ **&amp;** /，love这成 **love** 。</span></span><br><span class="line">\&lt; <span class="comment"># 匹配单词的开始，如:/\&lt;love/匹配包含以love开头的单词的行。</span></span><br><span class="line">\&gt; <span class="comment"># 匹配单词的结束，如/love\&gt;/匹配包含以love结尾的单词的行。</span></span><br><span class="line">x\&#123;m\&#125; <span class="comment"># 重复字符x，m次，如：/0\&#123;5\&#125;/匹配包含5个0的行。</span></span><br><span class="line">x\&#123;m,\&#125; <span class="comment"># 重复字符x，至少m次，如：/0\&#123;5,\&#125;/匹配至少有5个0的行。</span></span><br><span class="line">x\&#123;m,n\&#125; <span class="comment"># 重复字符x，至少m次，不多于n次，如：/0\&#123;5,10\&#125;/匹配5~10个0的行。  </span></span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="替换操作：s命令"><a href="#替换操作：s命令" class="headerlink" title="替换操作：s命令"></a>替换操作：s命令</h3><p>替换文本中的字符串：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/book/books/&#x27;</span> file</span><br></pre></td></tr></table></figure>
<p>-n选项 和 p命令 一起使用表示只打印那些发生替换的行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -n <span class="string">&#x27;s/test/TEST/p&#x27;</span> file</span><br></pre></td></tr></table></figure>
<p>直接编辑文件 选项-i ，会匹配file文件中每一行的所有book替换为books：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s/book/books/g&#x27;</span> file</span><br></pre></td></tr></table></figure>
<p>全面替换标记g<br>使用后缀 /g 标记会替换每一行中的所有匹配：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/book/books/g&#x27;</span> file</span><br></pre></td></tr></table></figure>
<p>当需要从第N处匹配开始替换时，可以使用 /Ng：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> sksksksksksk | sed <span class="string">&#x27;s/sk/SK/2g&#x27;</span></span><br><span class="line">skSKSKSKSKSK</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> sksksksksksk | sed <span class="string">&#x27;s/sk/SK/3g&#x27;</span></span><br><span class="line">skskSKSKSKSK</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> sksksksksksk | sed <span class="string">&#x27;s/sk/SK/4g&#x27;</span></span><br><span class="line">skskskSKSKSK</span><br></pre></td></tr></table></figure>

<h3 id="定界符"><a href="#定界符" class="headerlink" title="定界符"></a>定界符</h3><p>以上命令中字符 / 在sed中作为定界符使用，也可以使用任意的定界符：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;s:test:TEXT:g&#x27;</span></span><br><span class="line">sed <span class="string">&#x27;s|test|TEXT|g&#x27;</span></span><br></pre></td></tr></table></figure>
<p>定界符出现在样式内部时，需要进行转义：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/\/bin/\/usr\/local\/bin/g&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="删除操作：d命令"><a href="#删除操作：d命令" class="headerlink" title="删除操作：d命令"></a>删除操作：d命令</h3><p>删除空白行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;/^$/d&#x27;</span> file</span><br></pre></td></tr></table></figure>
<p>删除文件的第2行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;2d&#x27;</span> file</span><br></pre></td></tr></table></figure>
<p>删除文件的第2行到末尾所有行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;2,$d&#x27;</span> file</span><br></pre></td></tr></table></figure>
<p>删除文件最后一行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;$d&#x27;</span> file</span><br></pre></td></tr></table></figure>
<p>删除文件中所有开头是test的行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;/^test/&#x27;</span>d file</span><br></pre></td></tr></table></figure>

<h3 id="已匹配字符串标记-amp"><a href="#已匹配字符串标记-amp" class="headerlink" title="已匹配字符串标记&amp;"></a>已匹配字符串标记&amp;</h3><p>正则表达式 \w+ 匹配每一个单词，使用 [&amp;] 替换它，&amp; 对应于之前所匹配到的单词：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> this is a <span class="built_in">test</span> line | sed <span class="string">&#x27;s/\w\+/[&amp;]/g&#x27;</span></span><br><span class="line">[this] [is] [a] [<span class="built_in">test</span>] [line]</span><br></pre></td></tr></table></figure>
<p>所有以192.168.0.1开头的行都会被替换成它自已加localhost：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/^192.168.0.1/&amp;localhost/&#x27;</span> file</span><br><span class="line">192.168.0.1localhost</span><br></pre></td></tr></table></figure>

<h3 id="子串匹配标记-1"><a href="#子串匹配标记-1" class="headerlink" title="子串匹配标记\1"></a>子串匹配标记\1</h3><p>匹配给定样式的其中一部分：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> this is digit 7 <span class="keyword">in</span> a number | sed <span class="string">&#x27;s/digit \([0-9]\)/\1/&#x27;</span></span><br><span class="line">this is 7 <span class="keyword">in</span> a number</span><br></pre></td></tr></table></figure>

<p>对于匹配到的第一个子串就标记为 \1 ，依此类推匹配到的第二个结果就是 \2 ，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> aaa BBB | sed <span class="string">&#x27;s/\([a-z]\+\) \([A-Z]\+\)/\2 \1/&#x27;</span></span><br><span class="line">BBB aaa</span><br></pre></td></tr></table></figure>

<p>通过替换获取ip：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig ens32 | sed -n <span class="string">&#x27;/inet /p&#x27;</span> | sed <span class="string">&#x27;s/inet \([0-9.]\+\).*/\1/&#x27;</span></span><br><span class="line">192.168.75.126</span><br></pre></td></tr></table></figure>

<h3 id="大小写转换U-L"><a href="#大小写转换U-L" class="headerlink" title="大小写转换U/L"></a>大小写转换U/L</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\u：	首字母转换为大写</span><br><span class="line">\U：  全部转换为大写</span><br><span class="line">\l：	 首字母转换为小写</span><br><span class="line">\L：	 全部转换为小写</span><br></pre></td></tr></table></figure>

<p>首字母转换为大写：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node6 ~]<span class="comment"># sed &#x27;s/^[a-z]\+/\u&amp;/&#x27; passwd </span></span><br><span class="line">Root:x:0:0:root:/root:/bin/bash</span><br><span class="line">Bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">Daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">Adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="line">Lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br><span class="line">Sync:x:5:0:<span class="built_in">sync</span>:/sbin:/bin/sync</span><br></pre></td></tr></table></figure>

<p>匹配到的字符全部转换为大写：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node6 ~]<span class="comment"># sed &#x27;s/^[a-z]\+/\U&amp;/&#x27; passwd </span></span><br><span class="line">ROOT:x:0:0:root:/root:/bin/bash</span><br><span class="line">BIN:x:1:1:bin:/bin:/sbin/nologin</span><br></pre></td></tr></table></figure>

<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>sed表达式可以使用单引号来引用，但是如果表达式内部包含变量字符串，就需要使用双引号。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">test</span>=hello</span><br><span class="line"><span class="built_in">echo</span> hello WORLD | sed <span class="string">&quot;s/<span class="variable">$test</span>/HELLO&quot;</span></span><br><span class="line">HELLO WORLD</span><br></pre></td></tr></table></figure>

<h3 id="选定行的范围：-（逗号）"><a href="#选定行的范围：-（逗号）" class="headerlink" title="选定行的范围：,（逗号）"></a>选定行的范围：,（逗号）</h3><p>所有在模板test和check所确定的范围内的行都被打印：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -n <span class="string">&#x27;/test/,/check/p&#x27;</span> file</span><br></pre></td></tr></table></figure>
<p>打印从第5行开始到第一个包含以test开始的行之间的所有行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -n <span class="string">&#x27;5,/^test/p&#x27;</span> file</span><br></pre></td></tr></table></figure>
<p>对于模板test和west之间的行，每行的末尾用字符串aaa bbb替换：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;/test/,/west/s/$/aaa bbb/&#x27;</span> file</span><br></pre></td></tr></table></figure>

<h3 id="多点编辑：e命令"><a href="#多点编辑：e命令" class="headerlink" title="多点编辑：e命令"></a>多点编辑：e命令</h3><p>-e选项允许在同一行里执行多条命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -e <span class="string">&#x27;1,5d&#x27;</span> -e <span class="string">&#x27;s/test/check/&#x27;</span> file</span><br></pre></td></tr></table></figure>
<p>上面sed表达式的第一条命令删除1至5行，第二条命令用check替换test。命令的执行顺序对结果有影响。如果两个命令都是替换命令，那么第一个替换命令将影响第二个替换命令的结果。</p>
<h3 id="追加（行下）：a-命令"><a href="#追加（行下）：a-命令" class="headerlink" title="追加（行下）：a\命令"></a>追加（行下）：a\命令</h3><p>将 this is a test line 追加到 以test 开头的行后面：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;/^test/a\this is a test line&#x27;</span> file</span><br></pre></td></tr></table></figure>

<p>在 test.conf 文件第2行之后插入 this is a test line：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;2a\this is a test line&#x27;</span> test.conf</span><br></pre></td></tr></table></figure>

<h3 id="插入（行上）：i-命令"><a href="#插入（行上）：i-命令" class="headerlink" title="插入（行上）：i\命令"></a>插入（行上）：i\命令</h3><p>将 this is a test line 追加到以test开头的行前面：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;/^test/i\this is a test line&#x27;</span> file</span><br></pre></td></tr></table></figure>
<p>在test.conf文件第5行之前插入this is a test line：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;5i\this is a test line&#x27;</span> test.conf</span><br></pre></td></tr></table></figure>
<p>替换指定行：c\命令<br>把root开头的行替换新内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node6 ~]<span class="comment"># sed &#x27;/^root/c this is new line!&#x27; passwd </span></span><br><span class="line">this is new line!</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br></pre></td></tr></table></figure>
<p>如果是指定范围替换，需要注意，sed不是每行进行替换，而是把整个范围作为整体替换：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node6 ~]<span class="comment"># nl passwd | sed &#x27;1,5c\   this is dangerous!&#x27;</span></span><br><span class="line">     this is dangerous!</span><br><span class="line">     6	<span class="built_in">sync</span>:x:5:0:<span class="built_in">sync</span>:/sbin:/bin/sync</span><br><span class="line">     7	shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown</span><br></pre></td></tr></table></figure>
<p>如果想实现对第一行到第五行统一替换为相同内容，可以用下面的命令实现：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node5 ~]<span class="comment"># sed &#x27;1&#123;:a;s/.*/lutxixia/;n;6!ba&#125;&#x27; passwd </span></span><br><span class="line">lutxixia</span><br><span class="line">lutxixia</span><br><span class="line">lutxixia</span><br><span class="line">lutxixia</span><br><span class="line">lutxixia</span><br><span class="line"><span class="built_in">sync</span>:x:5:0:<span class="built_in">sync</span>:/sbin:/bin/sync</span><br><span class="line"></span><br><span class="line">其中：</span><br><span class="line">:a  	是设置一个循环标签</span><br><span class="line">s/.*/lutixia/	是用lutixia字符替换匹配到的每行内容</span><br><span class="line">n	是读取下一行</span><br><span class="line">6!	是读到第六行退出循环，终止操作,如果没有，则继续循环。</span><br><span class="line">ba	是如果没有到第六行就跳转到a继续循环</span><br></pre></td></tr></table></figure>

<h3 id="变形：y命令"><a href="#变形：y命令" class="headerlink" title="变形：y命令"></a>变形：y命令</h3><p>把1~10行内所有abcde转变为大写，注意，正则表达式元字符不能使用这个命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;1,10y/abcde/ABCDE/&#x27;</span> file</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SHELL</category>
      </categories>
      <tags>
        <tag>sed</tag>
      </tags>
  </entry>
  <entry>
    <title>paste and wc</title>
    <url>/2020/09/19/paste-and-wc/</url>
    <content><![CDATA[<h2 id="paste"><a href="#paste" class="headerlink" title="paste"></a>paste</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>将两个文本按列拼接到一起</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> file1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> file2</span><br><span class="line">colin</span><br><span class="line">book</span><br><span class="line"></span><br><span class="line"><span class="built_in">paste</span> file1 file2</span><br><span class="line">1 colin</span><br><span class="line">2 book</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>默认的定界符是制表符，可以用-d指明定界符:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">paste</span> file1 file2 -d <span class="string">&quot;,&quot;</span></span><br><span class="line">1,colin</span><br><span class="line">2,book</span><br></pre></td></tr></table></figure>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">paste</span> [-s][-d &lt;间隔字符&gt;][--<span class="built_in">help</span>][--version][文件...]</span><br></pre></td></tr></table></figure>

<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p><code>-d</code>&lt;间隔字符&gt;或–delimiters=&lt;间隔字符&gt; 　用指定的间隔字符取代跳格字符。<br><code>-s或--serial</code> 　串列进行而非平行处理。<br><code>--help</code> 　在线帮助。<br><code>--version</code> 　显示帮助信息。<br><code>[文件…]</code> 指定操作的文件路径</p>
<h2 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h2><h3 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h3><p>Linux wc命令用于计算字数。<br>利用wc指令我们可以计算文件的Byte数、字数、或是列数，若不指定文件名称、或是所给予的文件名为”-“，则wc指令会从标准输入设备读取数据。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$wc</span> -l file // 统计行数</span><br><span class="line"><span class="variable">$wc</span> -w file // 统计单词数</span><br><span class="line"><span class="variable">$wc</span> -c file // 统计字符数</span><br></pre></td></tr></table></figure>

<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">wc</span> [-clw][--<span class="built_in">help</span>][--version][文件...]</span><br></pre></td></tr></table></figure>

<h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><p><code>-c</code>或–bytes或–chars 只显示Bytes数。<br><code>-l</code>或–lines 显示行数。<br><code>-w</code>或–words 只显示字数。<br><code>--help</code> 在线帮助。<br><code>--version</code> 显示版本信息。</p>
]]></content>
      <categories>
        <category>SHELL</category>
      </categories>
      <tags>
        <tag>paste</tag>
        <tag>wc</tag>
      </tags>
  </entry>
  <entry>
    <title>cut按列切分文本</title>
    <url>/2020/09/18/cut%E6%8C%89%E5%88%97%E5%88%87%E5%88%86%E6%96%87%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>cut命令主要有3个定位方法：</p>
<ul>
<li>对字节的定位，用 -b 选项</li>
<li>对字符的定位，用 -c 选项</li>
<li>域，用选型 -f      （-d 区分域）<span id="more"></span></li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># echo $&#123;PATH&#125;</span></span><br><span class="line">/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># echo $&#123;PATH&#125; | cut -d : -f1,2</span></span><br><span class="line">/usr/local/sbin:/usr/local/bin</span><br><span class="line"><span class="comment"># echo $&#123;PATH&#125; | cut -d : -f2</span></span><br><span class="line">/usr/local/bin</span><br></pre></td></tr></table></figure>

<p>类似于awk</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># echo $&#123;PATH&#125; | awk -F : &#x27;&#123;print $1,$2&#125;&#x27;</span></span><br><span class="line">/usr/local/sbin /usr/local/bin</span><br><span class="line"><span class="comment"># echo $&#123;PATH&#125; | awk -F : &#x27;&#123;print $2&#125;&#x27;</span></span><br><span class="line">/usr/local/bin</span><br></pre></td></tr></table></figure>


<h2 id="缺陷和不足"><a href="#缺陷和不足" class="headerlink" title="缺陷和不足"></a>缺陷和不足</h2><p>在处理多空格时，如果文件里面的某些域是由若干个空格来间隔的，那么用cut就有点麻烦了，因为cut只擅长处理“以一个字符间隔”的文本内容</p>
]]></content>
      <categories>
        <category>SHELL</category>
      </categories>
      <tags>
        <tag>cut</tag>
      </tags>
  </entry>
  <entry>
    <title>用tr进行转换</title>
    <url>/2020/09/18/%E7%94%A8tr%E8%BF%9B%E8%A1%8C%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Shell 用 tr 进行转换，tr是Unix命令行专家工具箱中的一件万能工具。它可用于编写优雅的单行命令。tr可以对来自标准输入的内容进行字符替换、字符删除以及重复字符压缩。tr是translate（转换）的简写，因为它可以将一组字符转换成另一组字符。在本章中，我们会看到如何使用tr进行基本的集合转换。</p>
<span id="more"></span>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>tr只能通过stdin（标准输入）接收输入（无法通过命令行参数接收）。其调用格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tr</span> [options] set1 set2</span><br></pre></td></tr></table></figure>

<p>来自stdin的输入字符会按照位置从set1映射到set2（set1中的第一个字符映射到set2中的第一个字符，以此类推），然后将输出写入stdout（标准输出）。set1和set2是字符类或字符组。如果两个字符组的长度不相等，那么set2会不断复制其最后一个字符，直到长度与set1相同。如果set2的长度大于set1，那么在set2中超出set1长度的那部分字符则全部被忽略。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>要将输入中的字符由大写转换成小写，可以使用下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;HELLO WHO IS THIS&quot;</span> | <span class="built_in">tr</span> <span class="string">&#x27;A-Z&#x27;</span> <span class="string">&#x27;a-z&#x27;</span></span><br><span class="line">hello <span class="built_in">who</span> is this</span><br></pre></td></tr></table></figure>

<p>数字转换：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> 12345 | <span class="built_in">tr</span> <span class="string">&#x27;0-9&#x27;</span> <span class="string">&#x27;9876543210&#x27;</span></span><br><span class="line">87654    <span class="comment"># 已加密</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> 87654 | <span class="built_in">tr</span> <span class="string">&#x27;9876543210&#x27;</span> <span class="string">&#x27;0-9&#x27;</span></span><br><span class="line">12345    <span class="comment"># 已解密</span></span><br></pre></td></tr></table></figure>

<h2 id="用tr删除字符"><a href="#用tr删除字符" class="headerlink" title="用tr删除字符"></a>用tr删除字符</h2><p><code>-d</code> 可以通过指定需要被删除的字符集合，将出现在stdin中的特定字符清除掉</p>
<p>例如：将stdin中的数字删除并打印删除后的结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;Hello 123 world 456&quot;</span> | <span class="built_in">tr</span> -d <span class="string">&#x27;0-9&#x27;</span></span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure>

<h2 id="字符组补集"><a href="#字符组补集" class="headerlink" title="字符组补集"></a>字符组补集</h2><p>我们可以利用选项-c来使用set1的补集：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tr</span> -c [set1] [set2]</span><br></pre></td></tr></table></figure>
<p>如果使用了-c选项，set1和set2必须都给出。<br>如果-c与-d选项同时出现，你只能使用set1，其他所有的字符都会被删除。</p>
<p>下面的例子会从输入文本中删除不在补集中的所有字符：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> hello 1 char 2 next 4 | <span class="built_in">tr</span> -d -c <span class="string">&#x27;0-9\n&#x27;</span></span><br><span class="line">124</span><br></pre></td></tr></table></figure>
<p>接下来的例子会将不在set1中的字符替换成空格：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> hello 1 char 2 next 4 | <span class="built_in">tr</span> -c <span class="string">&#x27;0-9\n&#x27;</span> <span class="string">&#x27; &#x27;</span></span><br><span class="line">      1      2      4</span><br></pre></td></tr></table></figure>

<h2 id="用tr压缩字符"><a href="#用tr压缩字符" class="headerlink" title="用tr压缩字符"></a>用tr压缩字符</h2><p>tr命令能够完成很多文本处理任务。例如，它可以删除字符串中重复出现的字符。基本实现形式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tr</span> -s <span class="string">&#x27;[需要被压缩的一组字符]&#x27;</span></span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;GNU is       not     UNIX. Recursive   right ?&quot;</span> | <span class="built_in">tr</span> -s <span class="string">&#x27; &#x27;</span></span><br><span class="line">GNU is not UNIX. Recursive right ?</span><br></pre></td></tr></table></figure>

<p>tr命令还可以用来删除多余的换行符：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> multi_blanks.txt</span><br><span class="line">line 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">line 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">line 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">line 4</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> multi_blanks.txt | <span class="built_in">tr</span> -s <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">line 1</span><br><span class="line">line 2</span><br><span class="line">line 3</span><br><span class="line">line 4</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SHELL</category>
      </categories>
      <tags>
        <tag>tr</tag>
      </tags>
  </entry>
  <entry>
    <title>sort and uniq</title>
    <url>/2020/09/17/sort-and-uniq/</url>
    <content><![CDATA[<h2 id="sort字段说明"><a href="#sort字段说明" class="headerlink" title="sort字段说明"></a>sort字段说明</h2><p><code>-n</code> 按数字进行排序<br><code>-d</code> 按字典序进行排序<br><code>-r</code> 逆序排序<br><code>-t</code>&lt;分隔字符&gt; 指定排序时所用的栏位分隔字符。<br><code>-k</code> N 指定按第N列排序</p>
<span id="more"></span>

<h2 id="sort示例"><a href="#sort示例" class="headerlink" title="sort示例"></a>sort示例</h2><p>按照文件大小显示，从小到大</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ll | <span class="built_in">sort</span> -n -t <span class="string">&#x27; &#x27;</span> -k6</span><br></pre></td></tr></table></figure>

<h2 id="uniq-消除重复行"><a href="#uniq-消除重复行" class="headerlink" title="uniq 消除重复行"></a>uniq 消除重复行</h2><p>消除重复行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span> unsort.txt | <span class="built_in">uniq</span></span><br></pre></td></tr></table></figure>

<p>统计各行在文件中出现的次数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span> unsort.txt | <span class="built_in">uniq</span> -c</span><br></pre></td></tr></table></figure>

<p>找出重复行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span> unsort.txt | <span class="built_in">uniq</span> -d</span><br></pre></td></tr></table></figure>

<h2 id="sort-u"><a href="#sort-u" class="headerlink" title="sort -u"></a>sort -u</h2><p>作用是uniq的缩写选项，消除重复行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> seq.txt</span><br><span class="line">banana</span><br><span class="line">apple</span><br><span class="line">pear</span><br><span class="line">orange</span><br><span class="line">pear</span><br><span class="line">$ <span class="built_in">sort</span> seq.txt</span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">orange</span><br><span class="line">pear</span><br><span class="line">pear</span><br><span class="line">$ <span class="built_in">sort</span> -u seq.txt</span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">orange</span><br><span class="line">pear</span><br><span class="line"><span class="comment">#等同于</span></span><br><span class="line">$ <span class="built_in">sort</span> seq.txt | <span class="built_in">uniq</span> </span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">orange</span><br><span class="line">pear</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SHELL</category>
      </categories>
      <tags>
        <tag>sort</tag>
        <tag>uniq</tag>
      </tags>
  </entry>
  <entry>
    <title>xargs命令行参数转换</title>
    <url>/2020/09/17/xargs%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>xargs 能够将输入数据转化为特定命令的命令行参数；</li>
<li>这样，可以配合很多命令来组合使用。比如grep，比如find；</li>
<li>将多行输出转化为单行输出:<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> file.txt| xargs</span><br></pre></td></tr></table></figure>
<span id="more"></span></li>
</ul>
<p><code>-n</code> 是多行文本间的定界符</p>
<p>将单行转化为多行输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> single.txt | xargs -n 3</span><br><span class="line">-n：指定每行显示的字段数</span><br></pre></td></tr></table></figure>

<h2 id="xargs参数说明"><a href="#xargs参数说明" class="headerlink" title="xargs参数说明"></a>xargs参数说明</h2><p><code>-d</code> 定义定界符 （默认为空格 多行的定界符为 n）<br><code>-n</code> 指定输出为多行<br><code>-I</code> {} 指定替换字符串，这个字符串在xargs扩展时会被替换掉,用于待执行的命令需要多个参数时<br><code>-0</code> 指定0为输入定界符</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>-d 选项可以自定义一个定界符</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># echo &quot;nameXnameXnameXname&quot; | xargs -dX</span></span><br><span class="line"></span><br><span class="line">name name name name</span><br></pre></td></tr></table></figure>



<p>结合 -n 选项使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># echo &quot;nameXnameXnameXname&quot; | xargs -dX -n2</span></span><br><span class="line"></span><br><span class="line">name name</span><br><span class="line">name name</span><br></pre></td></tr></table></figure>


<p>统计程序行数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find source_dir/ -<span class="built_in">type</span> f -name <span class="string">&quot;*.cpp&quot;</span> -print0 | xargs -0 | <span class="built_in">wc</span> -l</span><br></pre></td></tr></table></figure>


<p>复制所有图片文件到 /data/images 目录下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> *.jpg | xargs -n1 -I &#123;&#125; <span class="built_in">cp</span> &#123;&#125; /data/images</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SHELL</category>
      </categories>
      <tags>
        <tag>xargs</tag>
      </tags>
  </entry>
  <entry>
    <title>grep</title>
    <url>/2020/09/17/grep/</url>
    <content><![CDATA[<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep match_patten file // 默认访问匹配行</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><p><code>-o</code> 只输出匹配的文本行<br><code>-v</code> 只输出没有匹配的文本行<br><code>-c</code> 统计文件中包含文本的次数 <code>grep -c “text” filename</code><br><code>-n</code> 打印匹配的行号<br><code>-i</code> 搜索时忽略大小写<br><code>-l</code> 只打印文件名<br><code>-w</code> 全词匹配</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>在多级目录中对文本递归搜索(程序员搜代码的最爱）:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep <span class="string">&quot;class&quot;</span> . -R -n</span><br></pre></td></tr></table></figure>

<p>匹配多个模式:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -e <span class="string">&quot;class&quot;</span> -e <span class="string">&quot;vitural&quot;</span> file</span><br></pre></td></tr></table></figure>

<p>grep输出以0作为结尾符的文件名（-z）:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep <span class="string">&quot;test&quot;</span> file* -lZ| xargs -0 <span class="built_in">rm</span></span><br></pre></td></tr></table></figure>

<p>将日志中的所有带where条件的sql查找查找出来:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> LOG.* | <span class="built_in">tr</span> a-z A-Z | grep <span class="string">&quot;FROM &quot;</span> | grep <span class="string">&quot;WHERE&quot;</span> &gt; b</span><br></pre></td></tr></table></figure>

<p>全词匹配：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># free -h | grep -i me</span></span><br><span class="line">Mem:            30G         15G        3.2G        909M         12G         13G</span><br><span class="line"><span class="comment"># free -h | grep -i -w me</span></span><br><span class="line"><span class="comment"># </span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SHELL</category>
      </categories>
      <tags>
        <tag>grep</tag>
      </tags>
  </entry>
  <entry>
    <title>find</title>
    <url>/2020/09/16/find/</url>
    <content><![CDATA[<h2 id="查找txt和pdf文件"><a href="#查找txt和pdf文件" class="headerlink" title="查找txt和pdf文件"></a>查找txt和pdf文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . \( -name <span class="string">&quot;*.txt&quot;</span> -o -name <span class="string">&quot;*.pdf&quot;</span> \) -<span class="built_in">print</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="过滤掉某个路径"><a href="#过滤掉某个路径" class="headerlink" title="过滤掉某个路径"></a>过滤掉某个路径</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -path /mnt -prune -o  -name <span class="string">&quot;libunwind*&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="正则方式查找-txt和pdf"><a href="#正则方式查找-txt和pdf" class="headerlink" title="正则方式查找.txt和pdf:"></a>正则方式查找.txt和pdf:</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -regex  <span class="string">&quot;.*\(\.txt|\.pdf\)$&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>-iregex</code>： 忽略大小写的正则</p>
<h2 id="否定参数-查找所有非txt文本"><a href="#否定参数-查找所有非txt文本" class="headerlink" title="否定参数 ,查找所有非txt文本:"></a>否定参数 ,查找所有非txt文本:</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . ! -name <span class="string">&quot;*.txt&quot;</span> -<span class="built_in">print</span></span><br></pre></td></tr></table></figure>

<h2 id="指定搜索深度-打印出当前目录的文件（深度为1）"><a href="#指定搜索深度-打印出当前目录的文件（深度为1）" class="headerlink" title="指定搜索深度,打印出当前目录的文件（深度为1）:"></a>指定搜索深度,打印出当前目录的文件（深度为1）:</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -maxdepth 1 -<span class="built_in">type</span> f</span><br></pre></td></tr></table></figure>

<h2 id="定制搜索"><a href="#定制搜索" class="headerlink" title="定制搜索"></a>定制搜索</h2><h3 id="按类型搜索"><a href="#按类型搜索" class="headerlink" title="按类型搜索"></a>按类型搜索</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> d -<span class="built_in">print</span>  //只列出所有目录</span><br></pre></td></tr></table></figure>
<p><code>-type</code> f 文件 / l 符号链接 / d 目录</p>
<p>find支持的文件检索类型可以区分普通文件和符号链接、目录等，但是二进制文件和文本文件无法直接通过find的类型区分出来；</p>
<p>file命令可以检查文件具体类型（二进制或文本）:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$file</span> redis-cli  <span class="comment"># 二进制文件</span></span><br><span class="line">redis-cli: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), <span class="keyword">for</span> GNU/Linux 2.6.9, not stripped</span><br><span class="line"><span class="variable">$file</span> redis.pid  <span class="comment"># 文本文件</span></span><br><span class="line">redis.pid: ASCII text</span><br></pre></td></tr></table></figure>
<p>所以,可以用以下命令组合来实现查找本地目录下的所有二进制文件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -lrt | awk <span class="string">&#x27;&#123;print $9&#125;&#x27;</span>|xargs file|grep  ELF| awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>|<span class="built_in">tr</span> -d <span class="string">&#x27;:&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="按时间搜索"><a href="#按时间搜索" class="headerlink" title="按时间搜索"></a>按时间搜索</h3><p><code>-atime</code> 访问时间 (单位是天，分钟单位则是-amin，以下类似）<br><code>-mtime</code> 修改时间 （内容被修改）<br><code>-ctime</code> 变化时间 （元数据或权限变化）<br>最近第7天被访问过的所有文件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -atime 7 -<span class="built_in">type</span> f -<span class="built_in">print</span></span><br></pre></td></tr></table></figure>
<p>最近7天内被访问过的所有文件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -atime -7 -<span class="built_in">type</span> f -<span class="built_in">print</span></span><br></pre></td></tr></table></figure>
<p>查询7天前被访问过的所有文件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -atime +7 <span class="built_in">type</span> f -<span class="built_in">print</span></span><br></pre></td></tr></table></figure>
<h3 id="按大小搜索"><a href="#按大小搜索" class="headerlink" title="按大小搜索"></a>按大小搜索</h3><p>w字 k M G 寻找大于2k的文件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -size +2k</span><br></pre></td></tr></table></figure>
<h3 id="按权限查找"><a href="#按权限查找" class="headerlink" title="按权限查找"></a>按权限查找</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -perm 644 -<span class="built_in">print</span> //找具有可执行权限的所有文件</span><br></pre></td></tr></table></figure>
<h3 id="按用户查找"><a href="#按用户查找" class="headerlink" title="按用户查找"></a>按用户查找</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -user weber -<span class="built_in">print</span>// 找用户weber所拥有的文件</span><br></pre></td></tr></table></figure>
<h2 id="找到后的后续动作"><a href="#找到后的后续动作" class="headerlink" title="找到后的后续动作"></a>找到后的后续动作</h2><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除当前目录下所有的swp文件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.swp&quot;</span> -delete</span><br></pre></td></tr></table></figure>
<p>另一种语法:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . <span class="built_in">type</span> f -name <span class="string">&quot;*.swp&quot;</span> | xargs <span class="built_in">rm</span></span><br></pre></td></tr></table></figure>
<h3 id="执行动作（强大的exec）"><a href="#执行动作（强大的exec）" class="headerlink" title="执行动作（强大的exec）"></a>执行动作（强大的exec）</h3><p>将当前目录下的所有权变更为weber:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -user root -<span class="built_in">exec</span> <span class="built_in">chown</span> weber &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<p><strong>注</strong>：{}是一个特殊的字符串，对于每一个匹配的文件，{}会被替换成相应的文件名；</p>
<p>将找到的文件全都copy到另一个目录:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -mtime +10 -name <span class="string">&quot;*.txt&quot;</span> -<span class="built_in">exec</span> <span class="built_in">cp</span> &#123;&#125; OLD \;</span><br></pre></td></tr></table></figure>
<h3 id="结合多个命令"><a href="#结合多个命令" class="headerlink" title="结合多个命令"></a>结合多个命令</h3><p>如果需要后续执行多个命令，可以将多个命令写成一个脚本。然后 -exec 调用时执行脚本即可:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-<span class="built_in">exec</span> ./commands.sh &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<h2 id="print的定界符"><a href="#print的定界符" class="headerlink" title="-print的定界符"></a>-print的定界符</h2><p>默认使用’\n’作为文件的定界符；</p>
<p><code>-print0</code> 使用’\0’作为文件的定界符，这样就可以搜索包含空格的文件；</p>
]]></content>
      <categories>
        <category>SHELL</category>
      </categories>
      <tags>
        <tag>find</tag>
      </tags>
  </entry>
  <entry>
    <title>lsof一切皆文件</title>
    <url>/2020/09/15/lsof%E4%B8%80%E5%88%87%E7%9A%86%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>lsof（list open files）是一个查看当前系统文件的工具。</li>
<li>在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。<span id="more"></span></li>
<li>如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等；</li>
<li>系统在后台都为该应用程序分配了一个文件描述符，该文件描述符提供了大量关于这个应用程序本身的信息。</li>
</ul>
<p>lsof打开的文件可以是：</p>
<ul>
<li>普通文件</li>
<li>目录</li>
<li>网络文件系统的文件</li>
<li>字符或设备文件</li>
<li>(函数)共享库</li>
<li>管道，命名管道</li>
<li>符号链接</li>
<li>网络文件（例如：NFS file、网络socket，unix域名socket）</li>
<li>还有其它类型的文件，等等</li>
</ul>
<h2 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h2><p><code>-a</code> 列出打开文件存在的进程<br><code>-c</code>&lt;进程名&gt; 列出指定进程所打开的文件<br><code>-g</code> 列出GID号进程详情<br><code>-d</code>&lt;文件号&gt; 列出占用该文件号的进程<br><code>+d</code>&lt;目录&gt; 列出目录下被打开的文件<br><code>+D</code>&lt;目录&gt; 递归列出目录下被打开的文件<br><code>-n</code>&lt;目录&gt; 列出使用NFS的文件<br><code>-i</code>&lt;条件&gt; 列出符合条件的进程。（4、6、协议、:端口、 @ip ）<br><code>-p</code>&lt;进程号&gt; 列出指定进程号所打开的文件<br><code>-u</code> 列出UID号进程详情<br><code>-h</code> 显示帮助信息<br><code>-v</code> 显示版本信息</p>
<h2 id="使用无任何参数"><a href="#使用无任何参数" class="headerlink" title="使用无任何参数"></a>使用无任何参数</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$lsof</span>| more</span><br><span class="line">COMMAND     PID      USER   FD      TYPE             DEVICE SIZE/OFF       NODE NAME</span><br><span class="line">init          1      root  cwd       DIR              253,0     4096          2 /</span><br><span class="line">init          1      root  rtd       DIR              253,0     4096          2 /</span><br><span class="line">init          1      root  txt       REG              253,0   150352    1310795 /sbin/init</span><br><span class="line">init          1      root  mem       REG              253,0    65928    5505054 /lib64/libnss_files-2.12.so</span><br><span class="line">init          1      root  mem       REG              253,0  1918016    5521405 /lib64/libc-2.12.so</span><br><span class="line">init          1      root  mem       REG              253,0    93224    5521440 /lib64/libgcc_s-4.4.6-20120305.so.1</span><br><span class="line">init          1      root  mem       REG              253,0    47064    5521407 /lib64/librt-2.12.so</span><br><span class="line">init          1      root  mem       REG              253,0   145720    5521406 /lib64/libpthread-2.12.so</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<p>lsof输出各列信息的意义如下：<br><code>COMMAND</code>：进程的名称<br><code>PID</code>：进程标识符<br><code>PPID</code>：父进程标识符（需要指定-R参数）<br><code>USER</code>：进程所有者<br><code>PGID</code>：进程所属组<br><code>FD</code>：文件描述符，应用程序通过文件描述符识别该文件。如cwd、txt等:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">（1）cwd：表示current work dirctory，即：应用程序的当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改</span><br><span class="line">（2）txt ：该类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 /sbin/init 程序</span><br><span class="line">（3）lnn：library references (AIX);</span><br><span class="line">（4）er：FD information error (see NAME column);</span><br><span class="line">（5）jld：jail directory (FreeBSD);</span><br><span class="line">（6）ltx：shared library text (code and data);</span><br><span class="line">（7）mxx ：hex memory-mapped <span class="built_in">type</span> number xx.</span><br><span class="line">（8）m86：DOS Merge mapped file;</span><br><span class="line">（9）mem：memory-mapped file;</span><br><span class="line">（10）mmap：memory-mapped device;</span><br><span class="line">（11）pd：parent directory;</span><br><span class="line">（12）rtd：root directory;</span><br><span class="line">（13）<span class="built_in">tr</span>：kernel trace file (OpenBSD);</span><br><span class="line">（14）v86  VP/ix mapped file;</span><br><span class="line">（15）0：表示标准输入</span><br><span class="line">（16）1：表示标准输出</span><br><span class="line">（17）2：表示标准错误</span><br><span class="line">一般在标准输出、标准错误、标准输入后还跟着文件状态模式：r、w、u等</span><br><span class="line">（1）u：表示该文件被打开并处于读取/写入模式</span><br><span class="line">（2）r：表示该文件被打开并处于只读模式</span><br><span class="line">（3）w：表示该文件被打开并处于</span><br><span class="line">（4）空格：表示该文件的状态模式为unknow，且没有锁定</span><br><span class="line">（5）-：表示该文件的状态模式为unknow，且被锁定</span><br><span class="line">同时在文件状态模式后面，还跟着相关的锁</span><br><span class="line">（1）N：<span class="keyword">for</span> a Solaris NFS lock of unknown <span class="built_in">type</span>;</span><br><span class="line">（2）r：<span class="keyword">for</span> <span class="built_in">read</span> lock on part of the file;</span><br><span class="line">（3）R：<span class="keyword">for</span> a <span class="built_in">read</span> lock on the entire file;</span><br><span class="line">（4）w：<span class="keyword">for</span> a write lock on part of the file;（文件的部分写锁）</span><br><span class="line">（5）W：<span class="keyword">for</span> a write lock on the entire file;（整个文件的写锁）</span><br><span class="line">（6）u：<span class="keyword">for</span> a <span class="built_in">read</span> and write lock of any length;</span><br><span class="line">（7）U：<span class="keyword">for</span> a lock of unknown <span class="built_in">type</span>;</span><br><span class="line">（8）x：<span class="keyword">for</span> an SCO OpenServer Xenix lock on part      of the file;</span><br><span class="line">（9）X：<span class="keyword">for</span> an SCO OpenServer Xenix lock on the      entire file;</span><br><span class="line">（10）space：<span class="keyword">if</span> there is no lock.</span><br></pre></td></tr></table></figure>

<p><code>TYPE</code>：文件类型，如DIR、REG等，常见的文件类型:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">（1）DIR：表示目录</span><br><span class="line">（2）CHR：表示字符类型</span><br><span class="line">（3）BLK：块设备类型</span><br><span class="line">（4）UNIX： UNIX 域套接字</span><br><span class="line">（5）FIFO：先进先出 (FIFO) 队列</span><br><span class="line">（6）IPv4：网际协议 (IP) 套接字</span><br></pre></td></tr></table></figure>

<p><code>DEVICE</code>：指定磁盘的名称<br><code>SIZE</code>：文件的大小<br><code>NODE</code>：索引节点（文件在磁盘上的标识）<br><code>NAME</code>：打开文件的确切名称</p>
<h2 id="查找某个文件相关的进程"><a href="#查找某个文件相关的进程" class="headerlink" title="查找某个文件相关的进程"></a>查找某个文件相关的进程</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$lsof</span> /bin/bash</span><br><span class="line">COMMAND     PID USER  FD   TYPE DEVICE SIZE/OFF    NODE NAME</span><br><span class="line">mysqld_sa  2169 root txt    REG  253,0   938736 4587562 /bin/bash</span><br><span class="line">ksmtuned   2334 root txt    REG  253,0   938736 4587562 /bin/bash</span><br><span class="line">bash      20121 root txt    REG  253,0   938736 4587562 /bin/bash</span><br></pre></td></tr></table></figure>

<h2 id="列出某个用户打开的文件信息"><a href="#列出某个用户打开的文件信息" class="headerlink" title="列出某个用户打开的文件信息"></a>列出某个用户打开的文件信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">   <span class="variable">$lsof</span> -u username</span><br><span class="line">-u 选项，u是user的缩写</span><br></pre></td></tr></table></figure>

<h2 id="列出某个程序进程所打开的文件信息"><a href="#列出某个程序进程所打开的文件信息" class="headerlink" title="列出某个程序进程所打开的文件信息"></a>列出某个程序进程所打开的文件信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$lsof</span> -c mysql</span><br><span class="line">-c 选项将会列出所有以mysql这个进程开头的程序的文件，</span><br><span class="line">可以写成 lsof | grep mysql, 但是第一种方法明显比第二种方法要少打几个字符；</span><br></pre></td></tr></table></figure>

<h2 id="列出某个用户以及某个进程所打开的文件信息"><a href="#列出某个用户以及某个进程所打开的文件信息" class="headerlink" title="列出某个用户以及某个进程所打开的文件信息"></a>列出某个用户以及某个进程所打开的文件信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$lsof</span>  -u <span class="built_in">test</span> -c mysql</span><br></pre></td></tr></table></figure>

<h2 id="通过某个进程号显示该进程打开的文件"><a href="#通过某个进程号显示该进程打开的文件" class="headerlink" title="通过某个进程号显示该进程打开的文件"></a>通过某个进程号显示该进程打开的文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$lsof</span> -p 11968</span><br></pre></td></tr></table></figure>

<h2 id="列出所有的网络连接"><a href="#列出所有的网络连接" class="headerlink" title="列出所有的网络连接"></a>列出所有的网络连接</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$lsof</span> -i</span><br></pre></td></tr></table></figure>

<h2 id="列出所有tcp网络连接信息"><a href="#列出所有tcp网络连接信息" class="headerlink" title="列出所有tcp网络连接信息"></a>列出所有tcp网络连接信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$lsof</span> -i tcp</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$lsof</span> -n -i tcp</span><br><span class="line">COMMAND     PID  USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME</span><br><span class="line">svnserve  11552 weber    3u  IPv4 3799399      0t0  TCP *:svn (LISTEN)</span><br><span class="line">redis-ser 25501 weber    4u  IPv4  113150      0t0  TCP 127.0.0.1:6379 (LISTEN)</span><br></pre></td></tr></table></figure>

<h2 id="列出谁在使用某个端口"><a href="#列出谁在使用某个端口" class="headerlink" title="列出谁在使用某个端口"></a>列出谁在使用某个端口</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$lsof</span> -i :3306</span><br></pre></td></tr></table></figure>

<h2 id="列出某个用户的所有活跃的网络端口"><a href="#列出某个用户的所有活跃的网络端口" class="headerlink" title="列出某个用户的所有活跃的网络端口"></a>列出某个用户的所有活跃的网络端口</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$lsof</span> -a -u <span class="built_in">test</span> -i</span><br></pre></td></tr></table></figure>

<h2 id="根据文件描述列出对应的文件信息"><a href="#根据文件描述列出对应的文件信息" class="headerlink" title="根据文件描述列出对应的文件信息"></a>根据文件描述列出对应的文件信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$lsof</span> -d description(like 2)</span><br></pre></td></tr></table></figure>
<p>示例:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$lsof</span> -d 3 | grep PARSER1</span><br><span class="line"><span class="built_in">tail</span>      6499 tde    3r   REG    253,3   4514722     417798 /opt/applog/open/log/HOSTPARSER1_ERROR_141217.log.001</span><br></pre></td></tr></table></figure>
<p>说明： 0表示标准输入，1表示标准输出，2表示标准错误，从而可知：所以大多数应用程序所打开的文件的 FD 都是从 3 开始</p>
<h2 id="列出被进程号为1234的进程所打开的所有IPV4-network-files"><a href="#列出被进程号为1234的进程所打开的所有IPV4-network-files" class="headerlink" title="列出被进程号为1234的进程所打开的所有IPV4 network files"></a>列出被进程号为1234的进程所打开的所有IPV4 network files</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$lsof</span> -i 4 -a -p 1234</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>lsof</tag>
      </tags>
  </entry>
  <entry>
    <title>top命令</title>
    <url>/2020/09/14/top-linux%E4%B8%8B%E7%9A%84%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器；<span id="more"></span></li>
<li>top是一个动态显示过程,即可以通过用户按键来不断刷新当前状态，如果在前台执行该命令,它将独占前台,直到用户终止该程序为止；</li>
<li>比较准确的说,top命令提供了实时的对系统处理器的状态监视；</li>
<li>它将显示系统中CPU最“敏感”的任务列表，该命令可以按CPU使用，内存使用和执行时间对任务进行排序；</li>
<li>而且该命令的很多特性都可以通过交互式命令或者在个人定制文件中进行设定。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$top</span></span><br><span class="line">    top - 09:14:56 up 264 days, 20:56,  1 user,  load average: 0.02, 0.04, 0.00</span><br><span class="line">    Tasks:  87 total,   1 running,  86 sleeping,   0 stopped,   0 zombie</span><br><span class="line">    Cpu(s):  0.0%us,  0.2%sy,  0.0%ni, 99.7%<span class="built_in">id</span>,  0.0%wa,  0.0%hi,  0.0%si,  0.2%st</span><br><span class="line">    Mem:    377672k total,   322332k used,    55340k free,    32592k buffers</span><br><span class="line">    Swap:   397308k total,    67192k used,   330116k free,    71900k cached</span><br><span class="line">    PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND</span><br><span class="line">    1 root      20   0  2856  656  388 S  0.0  0.2   0:49.40 init</span><br><span class="line">    2 root      20   0     0    0    0 S  0.0  0.0   0:00.00 kthreadd</span><br><span class="line">    3 root      20   0     0    0    0 S  0.0  0.0   7:15.20 ksoftirqd/0</span><br><span class="line">    4 root      RT   0     0    0    0 S  0.0  0.0   0:00.00 migration/0</span><br></pre></td></tr></table></figure>

<h2 id="top命令名词解释"><a href="#top命令名词解释" class="headerlink" title="top命令名词解释"></a>top命令名词解释</h2><p>第一行<br><code>09:14:56</code> ： 系统当前时间<br><code>264 days, 20:56</code> ： 系统开机到现在经过了多少时间<br><code>1 users</code> ： 当前2用户在线<br><code>load average: 0.02, 0.04, 0.00</code>： 系统1分钟、5分钟、15分钟的CPU负载信息<br>第二行<br><code>Tasks</code>：任务;<br><code>87 total</code>：很好理解，就是当前有87个任务，也就是87个进程。<br><code>1 running</code>：1个进程正在运行<br><code>86 sleeping</code>：86个进程睡眠<br><code>0 stopped</code>：停止的进程数<br><code>0 zombie</code>：僵死的进程数<br>第三行<br><code>Cpu(s)</code>：表示这一行显示CPU总体信息<br><code>0.0%us</code>：用户态进程占用CPU时间百分比，不包含renice值为负的任务占用的CPU的时间。<br><code>0.7%sy</code>：内核占用CPU时间百分比<br><code>0.0%ni</code>：改变过优先级的进程占用CPU的百分比<br><code>99.3%id</code>：空闲CPU时间百分比<br><code>0.0%wa</code>：等待I/O的CPU时间百分比<br><code>0.0%hi</code>：CPU硬中断时间百分比<br><code>0.0%si</code>：CPU软中断时间百分比<br><strong>注</strong>：这里显示数据是所有cpu的平均值，如果想看每一个cpu的处理情况，按1即可；折叠，再次按1；<br>第四行<br><code>Mem</code>：内存的意思<br><code>8175320kk total</code>：物理内存总量<br><code>8058868k used</code>：使用的物理内存量<br><code>116452k free</code>：空闲的物理内存量<br><code>283084k buffers</code>：用作内核缓存的物理内存量<br>第五行<br><code>Swap</code>：交换空间<br><code>6881272k total</code>：交换区总量<br><code>4010444k used</code>：使用的交换区量<br><code>2870828k free</code>：空闲的交换区量<br><code>4336992k cached</code>：缓冲交换区总量<br>进程信息<br>再下面就是进程信息：<br><code>PID</code>：进程的ID<br><code>USER</code>：进程所有者<br><code>PR</code>：进程的优先级别，越小越优先被执行<br><code>NI</code>nice：值<br><code>VIRT</code>：进程占用的虚拟内存<br><code>RES</code>：进程占用的物理内存<br><code>SHR</code>：进程使用的共享内存<br><code>S</code>：进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负数<br><code>%CPU</code>：进程占用CPU的使用率<br><code>%MEM</code>：进程使用的物理内存和总内存的百分比<br><code>TIME+</code>：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值。<br><code>COMMAND</code>：进程启动命令名称</p>
<h2 id="top命令交互操作指令"><a href="#top命令交互操作指令" class="headerlink" title="top命令交互操作指令"></a>top命令交互操作指令</h2><p>下面列出一些常用的 top命令操作指令</p>
<p><code>q</code>：退出top命令<br><code>&lt;Space&gt;</code>：立即刷新<br><code>s</code>：设置刷新时间间隔<br><code>c</code>：显示命令完全模式<br><code>t</code>：显示或隐藏进程和CPU状态信息<br><code>m</code>：显示或隐藏内存状态信息<br><code>l</code>：显示或隐藏uptime信息<br><code>f</code>：增加或减少进程显示标志<br><code>S</code>：累计模式，会把已完成或退出的子进程占用的CPU时间累计到父进程的MITE+<br><code>P</code>：按%CPU使用率排行<br><code>T</code>：按MITE+排行<br><code>M</code>：按%MEM排行<br><code>u</code>：指定显示用户进程<br><code>r</code>：修改进程renice值<br><code>k</code>kill：进程<br><code>i</code>：只显示正在运行的进程<br><code>W</code>：保存对top的设置到文件^/.toprc，下次启动将自动调用toprc文件的设置。<br><code>h</code>：帮助命令。<br><code>q</code>：退出<br><strong>注</strong>：强调一下，使用频率最高的是P、T、M，因为通常使用top，我们就想看看是哪些进程最耗cpu资源、占用的内存最多； 注：通过”shift + &gt;”或”shift + &lt;”可以向右或左改变排序列 如果只需要查看内存：可用free命令。只查看uptime信息（第一行），可用uptime命令；</p>
<h2 id="查看线程绑定在哪个核"><a href="#查看线程绑定在哪个核" class="headerlink" title="查看线程绑定在哪个核"></a>查看线程绑定在哪个核</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top -Hp `pidof 进程名`</span><br></pre></td></tr></table></figure>
<p>按f，选中SMP，按下空格键，再按下esc返回<br><img src="1851a559fa0049439666269588b5696a633d8d789de2be4e226c0e562a3ad282.png" alt="图 1">  </p>
<p>如下图，P列表示线程对应的CPU核号<br><img src="9aaf6394f686b8f5c84e6ad022ba9233bd36c8ee09365dcf332b91c6033d9e17.png" alt="图 2">  </p>
<h2 id="多核CPU监控"><a href="#多核CPU监控" class="headerlink" title="多核CPU监控"></a>多核CPU监控</h2><p>在top基本视图中，按键盘数字“1”，可监控每个逻辑CPU的状况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[rdtfr@bl685cb4-t ^]$ top</span><br><span class="line">top - 09:10:44 up 20 days, 16:51,  4 <span class="built_in">users</span>,  load average: 3.82, 4.40, 4.40</span><br><span class="line">Tasks: 1201 total,  10 running, 1189 sleeping,   0 stopped,   2 zombie</span><br><span class="line">Cpu0  :  1.3%us,  2.3%sy,  0.0%ni, 96.4%<span class="built_in">id</span>,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st</span><br><span class="line">Cpu1  :  1.3%us,  2.6%sy,  0.0%ni, 96.1%<span class="built_in">id</span>,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st</span><br><span class="line">Cpu2  :  1.0%us,  2.0%sy,  0.0%ni, 92.5%<span class="built_in">id</span>,  0.0%wa,  0.0%hi,  4.6%si,  0.0%st</span><br><span class="line">Cpu3  :  3.9%us,  7.8%sy,  0.0%ni, 83.2%<span class="built_in">id</span>,  0.0%wa,  0.0%hi,  5.2%si,  0.0%st</span><br><span class="line">Cpu4  :  4.2%us, 10.4%sy,  0.0%ni, 63.8%<span class="built_in">id</span>,  0.0%wa,  0.0%hi, 21.5%si,  0.0%st</span><br><span class="line">Cpu5  :  6.8%us, 12.7%sy,  0.0%ni, 80.5%<span class="built_in">id</span>,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st</span><br><span class="line">Cpu6  :  2.9%us,  7.2%sy,  0.0%ni, 85.3%<span class="built_in">id</span>,  0.0%wa,  0.0%hi,  4.6%si,  0.0%st</span><br><span class="line">Cpu7  :  6.2%us, 13.0%sy,  0.0%ni, 75.3%<span class="built_in">id</span>,  0.0%wa,  0.0%hi,  5.5%si,  0.0%st</span><br><span class="line">Mem:  32943888k total, 32834216k used,   109672k free,   642704k buffers</span><br><span class="line">Swap: 35651576k total,  5761928k used, 29889648k free, 16611500k cached</span><br></pre></td></tr></table></figure>

<h2 id="高亮显示当前运行进程"><a href="#高亮显示当前运行进程" class="headerlink" title="高亮显示当前运行进程"></a>高亮显示当前运行进程</h2><p>在top基本视图中,按键盘“b”（打开/关闭加亮效果）</p>
<h2 id="显示完整的程序命令"><a href="#显示完整的程序命令" class="headerlink" title="显示完整的程序命令"></a>显示完整的程序命令</h2><p><code>top -c</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[rdtfr@bl685cb4-t ^]$ top -c</span><br><span class="line">top - 09:14:35 up 20 days, 16:55,  4 <span class="built_in">users</span>,  load average: 5.77, 5.01, 4.64</span><br><span class="line">Tasks: 1200 total,   5 running, 1192 sleeping,   0 stopped,   3 zombie</span><br><span class="line">Cpu(s):  4.4%us,  6.0%sy,  0.0%ni, 83.8%<span class="built_in">id</span>,  0.2%wa,  0.0%hi,  5.5%si,  0.0%st</span><br><span class="line">Mem:  32943888k total, 32842896k used,   100992k free,   591484k buffers</span><br><span class="line">Swap: 35651576k total,  5761808k used, 29889768k free, 16918824k cached</span><br><span class="line">PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND</span><br><span class="line">2013 apache    18   0  403m  88m 5304 S 25.0  0.3   6:37.44 /usr/sbin/httpd</span><br><span class="line">18335 pubtest   22   0 65576  996  728 R  7.8  0.0   0:00.24 netstat -naltp</span><br><span class="line">16499 rdtfare   15   0 13672 2080  824 R  2.6  0.0   0:00.38 top -c</span><br><span class="line">29684 rdtfare   15   0 1164m 837m  14m S  2.3  2.6 148:47.54 ./autodata data1.txt</span><br><span class="line">12976 pubtest   18   0  238m 9000 1932 S  1.6  0.0 439:28.44 tscagent -s TOEV_P</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>top</tag>
      </tags>
  </entry>
  <entry>
    <title>Anycast</title>
    <url>/2020/09/12/anycast/</url>
    <content><![CDATA[<h2 id="什么是-Anycast？"><a href="#什么是-Anycast？" class="headerlink" title="什么是 Anycast？"></a>什么是 Anycast？</h2><ul>
<li>Anycast实质上是一种网络技术，它借助于网络中动态路由协议实现服务的负载均衡和冗余。<span id="more"></span></li>
<li>当存在多条到同一目的ip地址的等价路由时，路由器/三层交换机根据特定算法把流量负载均衡到这多条等价路由上。</li>
<li>DNS的局域网anycast技术就是使用路由器/三层交换机的这一功能，在下挂的多台后台服务器上配置相同loopback地址，</li>
<li>互联接口地址采用不同ip地址，配置指向该loopback的多条等价路由，从而使用路由器/三层交换机的等价路由负载均衡机制，以到达负载均衡的目的。</li>
</ul>
<h2 id="Anycast优势"><a href="#Anycast优势" class="headerlink" title="Anycast优势"></a>Anycast优势</h2><ol>
<li><p>不同客户端将访问不同目的主机，此过程对客户端透明，从而实现了目的主机的负载均衡;</p>
</li>
<li><p>当任意目的主机接入的网络出现故障，导致该目的主机不可达时，客户端请求可以在无人为干预的情况下自动被路由到目前可达的最近目的主机，在一定程度上为目标主机提供了冗余性;</p>
</li>
<li><p>当目的主机受到DoS攻击而无法到达时，由于网络不可到达，客户端请求也将路由到其他目的主机上，而在DDoS攻击时，由于Anycast的负载均衡效应，避免了单台目的主机承受所有攻击流量，因此在一定程度上为目的主机提高了安全性;</p>
</li>
<li><p>因为Anycast利用路由度量到“最近”的目的主机，提高了客户端响应速度。</p>
</li>
</ol>
<h2 id="Anycast技术原理"><a href="#Anycast技术原理" class="headerlink" title="Anycast技术原理"></a>Anycast技术原理</h2><p><img src="a305e0a3b3f79d7c6abf7a52d3af9190caffd34944f236b0f86242a6d0cb6ba9.png" alt="图 2"><br>路由器下挂三台SERVER，配置相同的loopback0地址：10.0.0.1/32，互联接口地址分别为192.168.1.2/30、192.168.2.2/30、192.168.3.2/30。</p>
<p><img src="de2b88ec508a2a1c68dd14e2d27bd32b0a440d16112e6b44d3df4df17db1a47d.png" alt="图 3"><br>在路由器上有三条等价的到10.0.0.1/32的路由，下一跳分别为三个互联接口地址，这三条路由通过IGP（静态或动态路由协议）产生，通过BGP发布给骨干网。路由器根据这三条等价路由进行负载均衡。</p>
<p><img src="813ffdf7349f4dbb2f1dd704dd7c796e94820319d5aabe440392d667f42f53ed.png" alt="图 4"><br>根据路由表，路由器并不能识别出地址欺骗的存在，而是认为10.0.0.1/32同时下挂在RouterA、RouterB、RouterC下，可以通过这三台路由器到达该Server，从而在三个接口上实现负载均衡。</p>
<h2 id="Anycast问题"><a href="#Anycast问题" class="headerlink" title="Anycast问题"></a>Anycast问题</h2><ol>
<li>缺少健康检查机制<br>由于anycast是基于网络等价路径实现负载均衡的，网络设备本身不能提供检查检查。导致当某台服务器中的服务出现异常时，用户请求流量仍然送到该服务器，从而用户解析请求失败。</li>
<li>后台服务器台数限制<br>由于路由器/三层交换机支持的等价路由有个数限定（视不同品牌的产品和不同的路由协议而定），所以在每台DNS路由器下挂后台服务器不能超过个数限制，这就限制了未来的扩容需求。</li>
</ol>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>Anycast</tag>
      </tags>
  </entry>
  <entry>
    <title>licenses</title>
    <url>/2020/09/11/licenses/</url>
    <content><![CDATA[<h3 id="BSD许可协议"><a href="#BSD许可协议" class="headerlink" title="BSD许可协议"></a>BSD许可协议</h3><p><strong>1、概念：</strong></p>
<p>BSD 许可协议，即 Berkeley Software Distribution license 的简称，是由加州大学伯克利分校发布并维护的开源软件许可证。BSD许可证是自由软件中使用最广泛的许可协议之一。</p>
<span id="more"></span>
<p><strong>2、两个概念：</strong></p>
<p>BSD：人们常说的BSD，指的是 Berkeley Software Distribution，即伯克利软件套件，是加州大学伯克利分校在AT&amp;T贝尔实验室的Unix操作系统基础上，开发打包的操作系统及相关软件套件。</p>
<p>BSD许可协议：BSD套件遵循某种开源许可证的方式发布，这种许许可证因此而得名，被叫做 BSD许可证。</p>
<p><strong>3、BSD协议特点：</strong></p>
<p>BSD开源协议是一个给予使用者很大自由的协议，可以自由的使用、修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。</p>
<p><strong>4、版本演进历史：</strong></p>
<p>旧版BSD：1998发布初版。<br>新版BSD：1999年发布修订版。</p>
<p>BSD协议的初稿内含有一项额外的条款，要求所有从以BSD许可证授权的软件派生著作，都必须要包含一段文字以交代源代码的来源。该条文列于原BSD许可证的第三条。</p>
<p>GNU项目将这个称为“令人感到不舒服的BSD交代条款”，GNU工程认为存在两个问题：</p>
<p>第一，修改源码的人都希望将其大名加到鸣谢中，如果一个项目参加的人非常多，或者软件包中包含许多个单独项目，鸣谢阵容将会变得非常庞大。<br>第二，这跟GNU通用公共许可协议相抵触，GPL不允许增加额外的限制，所以软件只能在GNU跟BSD之间选择。由于这两个许可证在自由软件中使用很普遍，如果作者想将GPL和BSD有所结合，就会出现冲突。</p>
<p>应自由软件基金会和GNU计划的发起者斯托曼的请求，1999年7月22日，伯克利技术许可办公室的主管 William Hoskins 删除了BSD许可证的第三条。从此以后，自由软件作者就可以方便地采用BSD许可证下的软件，从而跟GPL下的作品融合。</p>
<p>原来的许可证有时被称为“BSD-old”（老BSD）或“4-clause BSD”（四句版BSD），当前的BSD许可证有的被称为“BSD-new”（新BSD）、“revised BSD”（修订的BSD）或“3-clause BSD”（三句版BSD）。</p>
<p><strong>5、协议分析：</strong></p>
<p>当发布使用了BSD协议的代码或以BSD协议代码为基础做二次开发自己的产品时，需满足以下三个条件：</p>
<ul>
<li>如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。</li>
<li>如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。</li>
<li>不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。</li>
</ul>
<p>BSD协议鼓励项目代码共享，但需要尊重作者的著作权。BSD协议由于允许使用者修改和重新发布代码，也允许在BSD代码上开发商业软件发布和销售，因此是对商业集成很友好的协议。</p>
<p>很多公司在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。遵守BSD 协议的软件，允许用作商业用途，甚至可按照专属许可证进行再发布。</p>
<h3 id="GNU-GPL-LGPL"><a href="#GNU-GPL-LGPL" class="headerlink" title="GNU(GPL, LGPL)"></a>GNU(GPL, LGPL)</h3><h4 id="GPL"><a href="#GPL" class="headerlink" title="GPL"></a>GPL</h4><p><strong>1、概念：</strong></p>
<p>GPL，即GNU通用公共许可协议，是 GNU General Public License 的简写。它是由自由软件基金会(FSF)公布的自由软件许可证。</p>
<p><strong>2、版本演进历史：</strong></p>
<p>GPLv1：1989年2月25日发布。<br>GPLv2：1991年6月发布。<br>GPLv3：2007年6月29日发布。</p>
<p><strong>3、协议特点：</strong></p>
<p>GPL协议最大的一个特征是具有传染性，即GPL对于许可证有强制继承的要求，这也是GPL与其他许可证在哲学思想上最大的差异。</p>
<p><strong>4、权利和义务：</strong></p>
<p>GPL 规定了使用遵循了GPL协议软件时，使用者的权力和义务如下：</p>
<p><strong>权力：</strong></p>
<ul>
<li>获取源码的权力；</li>
<li>修改源码的权利；</li>
<li>自由处理衍生作品的权利。</li>
</ul>
<p><strong>义务：</strong></p>
<ul>
<li>使用了遵循GPL协议发布的软件，自身也必须遵守GPL协议。这也是GPL被人称为有传染性的原因。</li>
<li>必须开放源代码；允许使用者自由获取(复制)、修改、发布的产品，即拥有获取源码、修改源码、分发软件的自由。</li>
</ul>
<p><strong>5、GPL 自由权利的描述：</strong></p>
<p>GPL的条款和条件必须提供给任何接受GPL应用的作品的副本（“被许可人”）的人员。<br>任何遵守条款和条件的被授证人员都有权修改作品，以及复制和重新分发作品或任何派生版本。<br>GPL下的软件可以用于所有目的，包括商业目的，甚至作为创建专有软件的工具，例如使用GPL许可的编译器时，分发GPL许可作品（如软件）的用户或公司可能会收取副本费用或无偿提供费用。</p>
<p><strong>6、分析说明：</strong></p>
<p>这里被授权人，可以理解为，是使用了遵循GPL协议软件的作品的作者或者组织。<br>第三点将GPL与禁止商业再分发的软件许可区分开来，也与共享软件许可证区分开来。FSF认为自由软件不应该限制商业使用和发布（包括再发布）。GPL明确规定，GPL作品可能以任何价格出售。<br>许可只依赖于使用的库和软件组件，而不是依赖于底层平台。例如，作为GPL许可操作系统（如Linux）下的应用程序运行的软件不需要根据GPL进行许可或者以源代码可用性分发。</p>
<p><strong>7、官方网址：</strong></p>
<p>gnu.org/licenses/gpl-3.0.html</p>
<h4 id="LGPL"><a href="#LGPL" class="headerlink" title="LGPL"></a>LGPL</h4><p><strong>1、概念：</strong></p>
<p>LGPL，即GNU宽通用公共许可证，是 GNU Lesser General Public License 的简称。它是由自由软件基金会(FSF)公布的自由软件许可证。</p>
<p><strong>2、版本演进历史：</strong></p>
<p>第一版(2.0)：1991年发布，第一个字母 L 定义为 Library，为与 GPLv2 保持一致而采用 2.0 版的编号。</p>
<p>第二版(2.1)：1999年发布，第一个字母 L 定义为 Lesser，以显示 FSF 认为并不是所有程序库都应当采用该许可证的态度。</p>
<p>第三版(3.0)：2007年发布，它以在 GPL 第3版之上附加应用一系列许可的方式表现。</p>
<p><strong>3、协议特点：</strong></p>
<p>LGPL和GPL不同，GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同，LGPL允许商业软件通过引用(link)的方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并发布和销售。</p>
<p><strong>4、LGPL的发展和分析：</strong></p>
<p>从第一版的 L 表示 Library 的含义以及其版本号直接和GPL保持一致(第一版就是2.0)可知，该协议是GPL的补充协议，是一个主要为开源类库使用设计的开源协议，因为FSF逐渐意识到，GPL协议的强制传染性在某些场景下太过苛刻，会阻碍开源产品被更广泛的传播和使用，实际上很多软件开发过程中使用开源软件的场景，仅仅是把某个开源软件当做底层的库来引用，针对此种场景，FSF在1991年发布GPL第二版时，发布了LGPL第一版。</p>
<p>LGPL的含义可以理解为：它允许企业与软件开发者将LGPL授权的软件以依赖库链接的形式集成至他们自己的软件内（即使该软件是私有软件也被允许），同时不会受到类似于GPL传染特性的许可证强制对软件开源的限制。但如果修改LGPL协议的代码而产生的衍生代码，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。</p>
<p>采用LGPL的项目本身虽然仍有“Copyleft”的限制条件，但这些限制不会感染到仅仅只链接到本项目的软件。因此LGPL协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。LGPL为了在GPL与其他许可式许可证之间获取折衷，常被用于一些GNU程序库，亦可使用于独立存在的应用程序中，比较有名的例子为 Mozilla 跟 <a href="http://openoffice.org./">http://OpenOffice.Org。</a></p>
<h3 id="MIT"><a href="#MIT" class="headerlink" title="MIT"></a>MIT</h3><p><strong>1、概念：</strong></p>
<p>MIT 许可协议：即 The MIT License，该许可协议之名源自麻省理工学院（Massachusetts Institute of Technology, MIT），又称“X许可协议”（X License）或“X11许可协议”（X11 License）。</p>
<p><strong>2、版本演进历史：</strong></p>
<p>1988，由自麻省理工学院(MIT)发布。</p>
<p><strong>3、协议特点：</strong></p>
<p>MIT许可协议是许多软件许可条款中被广泛使用的其中一种。与其他常见的软件许可协议（如GPL、LGPL、BSD）相比，MIT是相对宽松的软件许可协议，赋予软件被许可人更大的权利与更少的限制。</p>
<p><strong>4、协议分析：</strong></p>
<p>被许可人权利：被许可人有权利使用、复制、修改、合并、出版发行、散布、再许可和/或贩售软件及软件的副本，及授予被供应人同等权利，惟服从以下义务。<br>被许可人义务：在软件和软件的所有副本中都必须包含以上著作权声明和本许可声明。</p>
<p><strong>5、其他重要特性：</strong></p>
<p>此许可协议并非属copyleft的自由软件许可协议条款，允许在自由及开放源代码软件或非自由软件（proprietary software）所使用。<br>MIT的内容可依照软件代码著作权者的需求更改内容，这也是MIT与BSD本质上的不同处。<br>MIT许可协议可与其他许可协议并存。MIT条款也是自由软件基金会（FSF）所认可的自由软件许可协议条款，与GPL兼容。</p>
<p>有许多团体均采用MIT许可证，例如著名的SSH连线软件PuTTY与X窗口系统、Expat、Mono开发平台库、Ruby on Rails、Lua等等也都采用MIT许可协议。</p>
<h3 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h3><p><strong>1、概念：</strong></p>
<p>Apache许可证，即 Apache License，是一个由Apache软件基金会(ASF)发布的自由软件许可证。</p>
<p>Apache许可证最初为 Apache Web 服务器而撰写，Apache许可证在Apache社区内外被广泛使用；Apache基金会下属所有项目都使用Apache许可证；许多非Apache基金会项目也使用了Apache许可证。</p>
<p>官网：<a href="http://www.apache.org/licenses/">http://www.apache.org/licenses/</a></p>
<p><strong>2、版本演进历史：</strong></p>
<p>Apache License 1.0，1995年发布。</p>
<p><a href="http://www.apache.org/licenses/LICENSE-1.0">http://www.apache.org/licenses/LICENSE-1.0</a></p>
<p>Apache License 1.1，2000年发布。<br><a href="http://www.apache.org/licenses/LICENSE-1.1">http://www.apache.org/licenses/LICENSE-1.1</a></p>
<p>Apache License 2.0，2004年发布。<br><a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p><strong>3、协议要求：</strong></p>
<p>Apache许可证，具体要求如下：</p>
<p>对所有未修改的部分应用相同的许可证，并且在每个许可文件中，必须保留再分发代码中的任何原始著作权、专利、商标和归属通知(不需要包括任何部分的派生作品)；</p>
<p>在每个更改的许可文件中，都必须添加一条通知，说明对该文件进行了更改。</p>
<p>不强制要求派生和修改产物使用相同的许可证进行发布。</p>
<p><strong>4、协议分析说明：</strong></p>
<p>如果声明文本文件是作为原始作品发布的一部分，则派生作品必须包含该通知文本文件的可读副本，可以是文档或显示在软件中。</p>
<p>声明文件的内容不会修改许可证，因为它们仅用于提供信息，并且可以在许可证文本中添加更多属性声明，前提是这些声明不能被理解为修改许可证。修改可能有适当的著作权声明，并可能为修改提供不同的许可条款。</p>
<h3 id="Mozilla-MPL"><a href="#Mozilla-MPL" class="headerlink" title="Mozilla (MPL)"></a>Mozilla (MPL)</h3><p><strong>1、概念：</strong></p>
<p>MPL，即 Mozilla公共许可证，是 Mozilla Public License 的简称，由Mozilla基金会开发并维护。</p>
<p><strong>2、版本演进历史：</strong></p>
<p>第一版，1.0版本，1998年发布。</p>
<p>第二版，1.1版本，其主要变更是理清了关于专利部分的条款，以及允许多个许可证之间共存。</p>
<p>第三版，2.0版本，2012年1月3日发布。该版本使许可协议更加清晰，更加方便应用，同时也兼容于GPL及Apache许可证。</p>
<p>从1.1版本开始，允许遵循MPL许可证的项目里多个许可证的共存，这一特性旨在鼓励与偏好使用GPL许可的开发者合作。1.1版本的结构，法律切合度，以及其对专利权的明确态度都深深的影响了后来流行的许可协议，有点像是第三版的GPL。很多项目都以此派生出他们自己的许可协议，如Sun Microsystems的通用开发与散布许可证。</p>
<p><strong>3、协议特点：</strong></p>
<p>MPL允许在其授权下的源代码与其他授权的文件进行混合，包括私有许可证，但在MPL授权下的代码文件必须保持MPL授权，并且保持开源。</p>
<p>可以理解为：遵循MPL的项目允许使用者对于MPL作品进行二次开发和发布，但MPL的部分、以及修改的部分，需要遵循MPL协议，并对修改部分作出说明，但允许衍生项目中有私有模块的存在。</p>
<p>这样的条款让MPL既不像MIT和BSD那样允许派生作品完全转化为私有，也不像GPL那样要求所有的派生作品包括新的组件在内的作品全部必须保持GPL。</p>
<p>一句话，MPL协议通过允许在派生项目中存在私有模块，同时保证核心文件的开源，同时激励了商业及开源社区来参与帮助开发核心软件。</p>
<p><strong>4、发展与应用：</strong></p>
<p>MPL既是得到自由软件基金会(FSF)承认的自由软件许可证，也是得到开放源代码促进会(OSF)承认的开源软件许可证。</p>
<p>该协议融合了BSD许可证和GNU通用公共许可协议的特性，追求平衡专有软件和开源软件开发者之间的顾虑。</p>
<p>MPL用于 Mozilla Firefox、Mozilla Thunderbird 及其他 Mozilla软件的许可，也被其他产品所用，如Adobe以此为Flex产品线许可，还有LibreOffice 4.0（同时使用LGPLv3）。</p>
<p><strong>对比</strong><br><img src="8ea9ebf985a55a4924d29135f341d7db96481dcb0daf7fc4d6e8a1ca764898a3.png" alt="图 3"><br><img src="ac478febdf707959be88d11b80c3cb90ca6b80ebdc20bd35d9f588b8827ff7e3.png" alt="图 4">  </p>
<h3 id="开源工程中licenses"><a href="#开源工程中licenses" class="headerlink" title="开源工程中licenses"></a>开源工程中licenses</h3><p><img src="21a6eb647e8f2233756b138d55cfdbb919119940a3b58153a8a2b1f459deed47.png" alt="图 2">  </p>
<p><strong>样例</strong></p>
<p>GPLv2  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * jmnd interface</span><br><span class="line"> *</span><br><span class="line"> * Copyright Jaguarmicro. 2022-2028 </span><br><span class="line"> *</span><br><span class="line"> * This work is licensed under the terms of the GNU GPL, version 2. </span><br><span class="line"> *</span><br><span class="line"> * Contributions after 2012-01-13 are licensed under the terms of the</span><br><span class="line"> * GNU GPL, version 2 or (at your option) any later version.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>


<p> BSD</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*-</span><br><span class="line"> *   BSD LICENSE</span><br><span class="line"> *</span><br><span class="line"> *   Copyright (c) Jaguarmicro Corporation.</span><br><span class="line"> *   All rights reserved.</span><br><span class="line"> *</span><br><span class="line"> *   Redistribution and use <span class="keyword">in</span> <span class="built_in">source</span> and binary forms, with or without</span><br><span class="line"> *   modification, are permitted provided that the following conditions</span><br><span class="line"> *   are met:</span><br><span class="line"> *</span><br><span class="line"> *     * Redistributions of <span class="built_in">source</span> code must retain the above copyright</span><br><span class="line"> *       notice, this list of conditions and the following disclaimer.</span><br><span class="line"> *     * Redistributions <span class="keyword">in</span> binary form must reproduce the above copyright</span><br><span class="line"> *       notice, this list of conditions and the following disclaimer <span class="keyword">in</span></span><br><span class="line"> *       the documentation and/or other materials provided with the</span><br><span class="line"> *       distribution.</span><br><span class="line"> *     * Neither the name of Intel Corporation nor the names of its</span><br><span class="line"> *       contributors may be used to endorse or promote products derived</span><br><span class="line"> *       from this software without specific prior written permission.</span><br><span class="line"> *</span><br><span class="line"> *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span><br><span class="line"> *   <span class="string">&quot;AS IS&quot;</span> AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span><br><span class="line"> *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span><br><span class="line"> *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span><br><span class="line"> *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span><br><span class="line"> *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span><br><span class="line"> *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span><br><span class="line"> *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span><br><span class="line"> *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span><br><span class="line"> *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span><br><span class="line"> *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<p>私有licence</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/* xxx.c - XXXXXXXXX */</span><br><span class="line"></span><br><span class="line">/* Copyright 2022-2028 Jaguarmicro Corporation. */</span><br></pre></td></tr></table></figure>

<p>参考vxworks</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/* privateCode.c - uses VM contexts to make data private to a code segment */</span><br><span class="line"></span><br><span class="line">/* Copyright 1984-1997 Wind River Systems, Inc. */</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>licenses</category>
      </categories>
      <tags>
        <tag>licenses</tag>
      </tags>
  </entry>
  <entry>
    <title>Quagga使用</title>
    <url>/2020/09/10/Quagga%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Quagga是一个开源路由软件套件，可以将Linux变成支持如RIP、OSPF、BGP和IS-IS等主要路由协议的路由器。它具有对IPv4和IPv6的完整支持，并支持路由/前缀过滤。<span id="more"></span></li>
</ul>
<h2 id="网络拓扑"><a href="#网络拓扑" class="headerlink" title="网络拓扑"></a>网络拓扑</h2><p>如下，CentOS位于所述专用链路的两端。两台主机名分别设置为“site-A-RTR”和“site-B-RTR’。下面是IP地址的详细信息。<br><img src="f2c55d4d98ca0648e8e62227eb283e42a15612b325b166af2e15d05d6f6b46df.png" alt="图 16">  </p>
<ul>
<li>Site-A: 192.168.1.0/24</li>
<li>Site-B: 172.16.1.0/24</li>
<li>两个 Linux 路由器之间的对等网络: 10.10.10.0/30</li>
</ul>
<h2 id="Quagga核心"><a href="#Quagga核心" class="headerlink" title="Quagga核心"></a>Quagga核心</h2><ul>
<li>Zebra: 核心守护进程，负责内核接口和静态路由。</li>
<li>Ospfd: IPv4 OSPF 守护进程。</li>
</ul>
<h2 id="在CentOS上安装Quagga"><a href="#在CentOS上安装Quagga" class="headerlink" title="在CentOS上安装Quagga"></a>在CentOS上安装Quagga</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yum install quagga </span></span><br></pre></td></tr></table></figure>

<p>如果是centos7，则关闭SELinux </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># setenforce 0</span></span><br></pre></td></tr></table></figure>
<p>或者 启用“zebra_write_config”</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># setsebool -P zebra_write_config 1 </span></span><br></pre></td></tr></table></figure>
<p>如果没有做这个修改，则尝试在Quagga命令行中保存配置的时候看到如下错误。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Can<span class="string">&#x27;t open configuration file /etc/quagga/zebra.conf.OS1Uu5.</span></span><br></pre></td></tr></table></figure>
<p>安装完Quagga后，需要配置必要的对等IP地址，并更新OSPF设置。Quagga自带了一个命令行称为vtysh。vtysh里面用到的Quagga命令与主要的路由器厂商如思科和Juniper是相似的。</p>
<h3 id="配置-Zebra"><a href="#配置-Zebra" class="headerlink" title="配置 Zebra"></a>配置 Zebra</h3><p>创建Zebra配置文件，并启用Zebra守护进程。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cp /usr/share/doc/quagga-XXXXX/zebra.conf.sample /etc/quagga/zebra.conf</span></span><br><span class="line"><span class="comment"># service zebra start</span></span><br><span class="line"><span class="comment"># chkconfig zebra on </span></span><br></pre></td></tr></table></figure>
<p>启动vtysh命令行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vtysh </span></span><br></pre></td></tr></table></figure>
<p>配置日志</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">site-A-RTR<span class="comment"># configure terminal</span></span><br><span class="line">site-A-RTR(config)<span class="comment"># log file /var/log/quagga/quagga.log</span></span><br><span class="line">site-A-RTR(config)<span class="comment"># exit</span></span><br><span class="line">site-A-RTR<span class="comment"># write</span></span><br></pre></td></tr></table></figure>
<p>配置IP</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">site-A-RTR<span class="comment"># show interface </span></span><br><span class="line">Interface eth0 is up, line protocol detection is disabled</span><br><span class="line">. . . . .</span><br><span class="line">Interface eth1 is up, line protocol detection is disabled</span><br><span class="line">. . . . .</span><br></pre></td></tr></table></figure>
<p>配置eth0参数:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">site-A-RTR<span class="comment"># configure terminal</span></span><br><span class="line">site-A-RTR(config)<span class="comment"># interface eth0</span></span><br><span class="line">site-A-RTR(config-if)<span class="comment"># ip address 10.10.10.1/30</span></span><br><span class="line">site-A-RTR(config-if)<span class="comment"># description to-site-B</span></span><br><span class="line">site-A-RTR(config-if)<span class="comment"># no shutdown </span></span><br></pre></td></tr></table></figure>
<p>配置eth1参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">site-A-RTR(config)<span class="comment"># interface eth1</span></span><br><span class="line">site-A-RTR(config-if)<span class="comment"># ip address 192.168.1.1/24</span></span><br><span class="line">site-A-RTR(config-if)<span class="comment"># description to-site-A-LAN</span></span><br><span class="line">site-A-RTR(config-if)<span class="comment"># no shutdown </span></span><br></pre></td></tr></table></figure>

<p>验证配置:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">site-A-RTR(config-if)<span class="comment"># do show interface </span></span><br><span class="line">Interface eth0 is up, line protocol detection is disabled</span><br><span class="line">. . . . .</span><br><span class="line">  inet 10.10.10.1/30 broadcast 10.10.10.3</span><br><span class="line">. . . . .</span><br><span class="line">Interface eth1 is up, line protocol detection is disabled</span><br><span class="line">. . . . .</span><br><span class="line">  inet 192.168.1.1/24 broadcast 192.168.1.255</span><br><span class="line">. . . . .</span><br><span class="line"></span><br><span class="line">site-A-RTR(config-if)<span class="comment"># do show interface description </span></span><br><span class="line">Interface      Status  Protocol  Description</span><br><span class="line">eth0           up      unknown   to-site-B</span><br><span class="line">eth1           up      unknown   to-site-A-LAN</span><br></pre></td></tr></table></figure>

<p>永久保存配置:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">site-A-RTR(config-if)<span class="comment"># do write </span></span><br></pre></td></tr></table></figure>

<p>在site-B上重复上面配置IP地址的步骤。<br>如果一切顺利，可以在site-A的服务器上ping通site-B上的对等IP地址10.10.10.2了。<br>注意：一旦Zebra的守护进程启动了，在vtysh命令行中的任何改变都会立即生效。因此没有必要在更改配置后重启Zebra守护进程。</p>
<h3 id="配置OSPF"><a href="#配置OSPF" class="headerlink" title="配置OSPF"></a>配置OSPF</h3><p>创建OSPF配置文件，并启动OSPF守护进程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cp /usr/share/doc/quagga-XXXXX/ospfd.conf.sample /etc/quagga/ospfd.conf</span></span><br><span class="line"><span class="comment"># service ospfd start</span></span><br><span class="line"><span class="comment"># chkconfig ospfd on </span></span><br></pre></td></tr></table></figure>

<p>现在启动vtysh命令行来继续OSPF配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vtysh</span></span><br></pre></td></tr></table></figure>

<p>输入路由配置模式:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">site-A-RTR<span class="comment"># configure terminal</span></span><br><span class="line">site-A-RTR(config)<span class="comment"># router ospf</span></span><br></pre></td></tr></table></figure>

<p>可选配置路由id:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">site-A-RTR(config-router)<span class="comment"># router-id 10.10.10.1</span></span><br></pre></td></tr></table></figure>

<p>添加在OSPF中的网络:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">site-A-RTR(config-router)<span class="comment"># network 10.10.10.0/30 area 0</span></span><br><span class="line">site-A-RTR(config-router)<span class="comment"># network 192.168.1.0/24 area 0</span></span><br></pre></td></tr></table></figure>

<p>保存：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">site-A-RTR(config-router)<span class="comment"># do write</span></span><br></pre></td></tr></table></figure>

<p>在site-B上重复和上面相似的OSPF配置:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">site-B-RTR(config-router)<span class="comment"># network 10.10.10.0/30 area 0</span></span><br><span class="line">site-B-RTR(config-router)<span class="comment"># network 172.16.1.0/24 area 0</span></span><br><span class="line">site-B-RTR(config-router)<span class="comment"># do write </span></span><br></pre></td></tr></table></figure>

<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><h3 id="通过ping测试"><a href="#通过ping测试" class="headerlink" title="通过ping测试"></a>通过ping测试</h3><p>可以从site-A ping通site-B的LAN子网。确保防火墙没有阻止ping的流量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@site-A-RTR ~]<span class="comment"># ping 172.16.1.1 -c 2 </span></span><br></pre></td></tr></table></figure>
<h3 id="检查路由表"><a href="#检查路由表" class="headerlink" title="检查路由表"></a>检查路由表</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@site-A-RTR ~]<span class="comment"># ip route </span></span><br><span class="line">10.10.10.0/30 dev eth0  proto kernel  scope <span class="built_in">link</span>  src 10.10.10.1</span><br><span class="line">172.16.1.0/30 via 10.10.10.2 dev eth0  proto zebra  metric 20</span><br><span class="line">192.168.1.0/24 dev eth1  proto kernel  scope <span class="built_in">link</span>  src 192.168.1.1</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@site-A-RTR ~]<span class="comment"># vtysh</span></span><br><span class="line">site-A-RTR<span class="comment"># show ip route </span></span><br><span class="line"></span><br><span class="line">Codes: K - kernel route, C - connected, S - static, R - RIP, O - OSPF,</span><br><span class="line">       I - ISIS, B - BGP, &gt; - selected route, * - FIB route</span><br><span class="line"> </span><br><span class="line">O   10.10.10.0/30 [110/10] is directly connected, eth0, 00:14:29</span><br><span class="line">C&gt;* 10.10.10.0/30 is directly connected, eth0</span><br><span class="line">C&gt;* 127.0.0.0/8 is directly connected, lo</span><br><span class="line">O&gt;* 172.16.1.0/30 [110/20] via 10.10.10.2, eth0, 00:14:14</span><br><span class="line">C&gt;* 192.168.1.0/24 is directly connected, eth1</span><br></pre></td></tr></table></figure>

<h3 id="验证OSPF邻居和路由"><a href="#验证OSPF邻居和路由" class="headerlink" title="验证OSPF邻居和路由"></a>验证OSPF邻居和路由</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@site-A-RTR ~]<span class="comment"># vtysh</span></span><br><span class="line">site-A-RTR<span class="comment"># show ip ospf neighbor </span></span><br></pre></td></tr></table></figure>
<p><img src="19578b06dd67d51e47097962c3632bbd1ff2158ec7803711502c36c53bbb8b31.png" alt="图 17">  </p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>Quagga</tag>
      </tags>
  </entry>
  <entry>
    <title>CPU超线程</title>
    <url>/2020/09/09/CPU%E8%B6%85%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="什么是超线程？"><a href="#什么是超线程？" class="headerlink" title="什么是超线程？"></a>什么是超线程？</h2><ul>
<li>“超线程”（Hyperthreading Technology）技术可以把一个物理内核模拟成两个逻辑内核。在相应的软硬件的支持下大幅度的提高运行效能，从而使单处理器上模拟双处理器的效能。</li>
<li>其实，从实质上说，超线程是一种可以将CPU内部暂时闲置处理资源充分“调动”起来的技术。<span id="more"></span>
<img src="8db9d383c368be72efbd3809ee64bbb29313050a0d8c4942c6691b4b453dc0ac.png" alt="图 10">  </li>
</ul>
<h2 id="CPU超线程原理"><a href="#CPU超线程原理" class="headerlink" title="CPU超线程原理"></a>CPU超线程原理</h2><p>CPU中两个相关的模块：</p>
<ol>
<li>Processing Unit（运算处理单元），简称PU</li>
<li>Architectual State（架构状态单元），简称AS<br>PU一般就是执行运算，比如算数运算加减乘除。<br>AS执行一些逻辑和调度方面的操作，比如控制内存访问等。</li>
</ol>
<p><strong>双核心系统</strong>:<br><img src="4ae42920bf8b3b071dd663d667e015960632be71b009e78288b4e0c203774145.png" alt="双核心系统">  </p>
<p><strong>单核心超线程系统</strong>:<br><img src="7532259dd76bacac58f31a2c87411cc0d03852fe4cf4c803057539df8a4c4708.png" alt="单核心超线程系统">  </p>
<h2 id="Linux下CPU超线程配置查看"><a href="#Linux下CPU超线程配置查看" class="headerlink" title="Linux下CPU超线程配置查看"></a>Linux下CPU超线程配置查看</h2><p>通过 /proc/cpuinfo  查看cpu信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">processor　   ：体系中逻辑核的编号，顺序加1</span><br><span class="line">…..</span><br><span class="line">physical <span class="built_in">id</span>   ：单个物理CPU的标号</span><br><span class="line">siblings      ：此物理CPU种逻辑核总数</span><br><span class="line">core <span class="built_in">id</span>       ：此物理CPU中某物理核的编号</span><br><span class="line">cpu cores     ：此物理CPU的物理核总数</span><br></pre></td></tr></table></figure>

<p>查询是否存在超线程？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/cpuinfo | grep -e <span class="string">&quot;cpu cores&quot;</span>  -e <span class="string">&quot;siblings&quot;</span> | <span class="built_in">sort</span> | <span class="built_in">uniq</span></span><br></pre></td></tr></table></figure>
<p><img src="a2df011701a4d4b337db30c09568b19322141f00ff760e67d6f3f1b06f8ac2dc.png" alt="图 13">  </p>
<p>如果启用超线程， “siblings”是“cpu cores”的2倍。<br><img src="749fc356489c78d2ad189c6abe82436dd6011e5a70429e6f51853ac9ffdd136a.png" alt="图 14"><br>如果未启用超线程， “siblings”等于“cpu cores” 。</p>
<h2 id="哪2个核是超线程兄弟？"><a href="#哪2个核是超线程兄弟？" class="headerlink" title="哪2个核是超线程兄弟？"></a>哪2个核是超线程兄弟？</h2><p>查看 /proc/cpuinfo ， 如果两个逻辑核（processor）的“physical id”和“core id”相同，那么他们就是属于同一物理核的2个超线程逻辑核。<br><img src="51c9d082b993e414d937d40856d2e25c59ce57dd3416a3be997e77a7297cd2e9.png" alt="图 15">  </p>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux调优</title>
    <url>/2020/09/08/linux%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<p>下图诠释了linux内核各个模块对应的调优诊断工具</p>
<span id="more"></span>
<p><img src="89be2ee91d755c1a58c33374e212ad341d9c339261a8b444c1aab29cfdd02d38.png" alt="图 28">       </p>
<h4 id="网络类"><a href="#网络类" class="headerlink" title="网络类"></a>网络类</h4><p>iptables<br>tcpdump<br>tcpreplay<br>net-tools<br>iperf</p>
<h4 id="文件系统类"><a href="#文件系统类" class="headerlink" title="文件系统类"></a>文件系统类</h4><p>df<br>fdisk<br>dd<br>fio</p>
<h4 id="调试类"><a href="#调试类" class="headerlink" title="调试类"></a>调试类</h4><p>gdb<br>kdump-tools<br>kexec-tools<br>trace-cmd<br>strace<br>vmlinux<br>System.map<br>perf<br>crash<br>bpftrace<br>bcc</p>
<h4 id="内存类"><a href="#内存类" class="headerlink" title="内存类"></a>内存类</h4><p>memtester<br>devmem2</p>
<h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>taskset<br>acpi<br>acpidump<br>iasl</p>
<h4 id="misc"><a href="#misc" class="headerlink" title="misc"></a>misc</h4><p>python2<br>python2<br>vim<br>ipmitool<br>dmidecode<br>efibootmgr</p>
<h4 id="设备相关"><a href="#设备相关" class="headerlink" title="设备相关"></a>设备相关</h4><p>lspci<br>setpci<br>lsusb<br>smartctl<br>shell</p>
<h4 id="性能工具"><a href="#性能工具" class="headerlink" title="性能工具"></a>性能工具</h4><p>apt install hdparm<br>apt install stress</p>
<p>stream<br><a href="http://www.cs.virginia.edu/stream/FTP/Code/">http://www.cs.virginia.edu/stream/FTP/Code/</a><br>gcc -O3 -fopenmp -DN=2000000 -DNTIMES=10 stream.c -o stream</p>
<p>unixbench-5.1.2-29.tar.gz<br>apt install perf<br>apt install libgl<br>make</p>
<p>apt install ipmitool</p>
<p>/root/tools/lkp-tests</p>
<p>npb: /root/tools/NPB3.4.2/</p>
<p>lmbench</p>
<h4 id="调优手段"><a href="#调优手段" class="headerlink" title="调优手段"></a>调优手段</h4><p><strong>查看某个核上跑哪些进程，线程</strong><br>7是核号，实际使用时换成需要的核</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -eLo pid,tid,psr,stat,pcpu,comm | awk &#x27;&#123;if($3==1) print $0&#125;&#x27;</span><br></pre></td></tr></table></figure>

<p><strong>查看进程跑在哪些核上</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps c -L -o ppid,lwp,comm,%cpu,psr,time -p 3598</span><br></pre></td></tr></table></figure>

<p><strong>绑核</strong></p>
<p>taskset -cp 6-12 4232<br>taskset -cp 13-19 4849</p>
<p><strong>固定cpu主频</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cpufreq-set -g performance</span><br></pre></td></tr></table></figure>

<p><strong>核隔离</strong><br>cmdline修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">isolcpus=4-15</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>调优</tag>
      </tags>
  </entry>
  <entry>
    <title>ethtool调优</title>
    <url>/2020/09/07/ethtool%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<h2 id="网卡多队列"><a href="#网卡多队列" class="headerlink" title="网卡多队列"></a>网卡多队列</h2><p>如果网卡及其驱动支持 RSS/多队列，那你可以会调整 RX queue（也叫 RX channel）的数量。这可以用 ethtool 完成。<br>查看 RX queue 数量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo ethtool -l eth0</span><br><span class="line">Channel parameters <span class="keyword">for</span> eth0:</span><br><span class="line">Pre-<span class="built_in">set</span> maximums:</span><br><span class="line">RX:   0</span><br><span class="line">TX:   0</span><br><span class="line">Other:    0</span><br><span class="line">Combined: 8</span><br><span class="line">Current hardware settings:</span><br><span class="line">RX:   0</span><br><span class="line">TX:   0</span><br><span class="line">Other:    0</span><br><span class="line">Combined: 4</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>这里可以看到允许的最大值（网卡及驱动限制），以及当前设置的值。</p>
<h2 id="调整RX-queues"><a href="#调整RX-queues" class="headerlink" title="调整RX queues"></a>调整RX queues</h2><p>设置 combined 类型网卡的收发队列为 8 个：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo ethtool -L eth0 combined 8</span><br></pre></td></tr></table></figure>
<p>如果你的网卡支持独立的 RX 和 TX 队列数量，那你可以只修改 RX queue 数量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo ethtool -L eth0 rx 8</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：对于大部分驱动，修改以上配置会使网卡先 down 再 up，因此会造成丢包。请酌情使用。</p>
<p>kvm中设置网卡多队列：<br>编辑虚拟机yaml文件，添加 <driver name="vhost" queues="4"><br>一般队列数和虚拟机的vcpu保持一致</driver></p>
<h2 id="网卡队列长度"><a href="#网卡队列长度" class="headerlink" title="网卡队列长度"></a>网卡队列长度</h2><p>增加RX queue 的大小可以在流量很大的时候缓解丢包问题，但是，只调整这个还不够，软件层面仍然可能会丢包，因此还需要其他的一些调优才能彻底的缓解或解决丢包问题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo ethtool -g eth0</span><br><span class="line">Ring parameters <span class="keyword">for</span> eth0:</span><br><span class="line">Pre-<span class="built_in">set</span> maximums:</span><br><span class="line">RX:   4096</span><br><span class="line">RX Mini:  0</span><br><span class="line">RX Jumbo: 0</span><br><span class="line">TX:   4096</span><br><span class="line">Current hardware settings:</span><br><span class="line">RX:   512</span><br><span class="line">RX Mini:  0</span><br><span class="line">RX Jumbo: 0</span><br><span class="line">TX:   512</span><br></pre></td></tr></table></figure>

<p>以上显式网卡支持最多 4096 个接收和发送 descriptor（描述符，简单理解，存放的是指向包的指针），但是现在只用到了 512 个。</p>
<p>用 ethtool -G 修改 queue 大小：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo ethtool -G eth0 rx 4096</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：对于大部分驱动，修改以上配置会使网卡先 down 再 up，因此会造成丢包。请酌情使用。</p>
<h2 id="网卡RSS"><a href="#网卡RSS" class="headerlink" title="网卡RSS"></a>网卡RSS</h2><p>可以用 ethtool 调整 RSS 计算哈希时所使用的字段。<br>查看 UDP RX flow 哈希所使用的字段：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo ethtool -n eth0 rx-flow-hash udp4</span><br><span class="line">UDP over IPV4 flows use these fields <span class="keyword">for</span> computing Hash flow key:</span><br><span class="line">IP SA</span><br><span class="line">IP DA</span><br></pre></td></tr></table></figure>
<p>可以看到只用到了源 IP（SA：Source Address）和目的 IP。</p>
<p>我们接下来修改一下，加入源端口和目的端口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo ethtool -N eth0 rx-flow-hash udp4 sdfn</span><br></pre></td></tr></table></figure>

<p>其中：<br>对于udp协议来说<code>f</code>、<code>n</code>为源端口、目的端口，<code>s</code>、<code>d</code>为源ip、目的ip<br>使用这种方法，可以改变RSS通道的分配方法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//查看</span><br><span class="line"><span class="comment"># ethtool -n eth0 rx-flow-hash udp4    </span></span><br><span class="line">UDP over IPV4 flows use these fields <span class="keyword">for</span> computing Hash flow key:</span><br><span class="line">IP SA</span><br><span class="line">IP DA</span><br><span class="line">//修改</span><br><span class="line"><span class="comment"># ethtool -N eth0 rx-flow-hash udp4 sdfn</span></span><br><span class="line">//再次查看</span><br><span class="line"><span class="comment"># ethtool -n eth0 rx-flow-hash udp4     </span></span><br><span class="line">UDP over IPV4 flows use these fields <span class="keyword">for</span> computing Hash flow key:</span><br><span class="line">IP SA</span><br><span class="line">IP DA</span><br><span class="line">L4 bytes 0 &amp; 1 [TCP/UDP src port]</span><br><span class="line">L4 bytes 2 &amp; 3 [TCP/UDP dst port]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ETHTOOL</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ethtool</tag>
      </tags>
  </entry>
  <entry>
    <title>inet_ntoa函数</title>
    <url>/2020/09/06/inet-ntoa%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="inet-ntoa简介"><a href="#inet-ntoa简介" class="headerlink" title="inet_ntoa简介"></a>inet_ntoa简介</h2><ul>
<li>char *inet_ntoa(struct in_addr in);</li>
<li>功能：将一个十进制网络字节序转换为点分十进制IP格式的字符串<span id="more"></span></li>
<li>参数：<br>  一个网络上的IP地址</li>
<li>返回值：<br>  如果正确，返回一个字符指针，指向一块存储着点分格式IP地址的静态缓冲区（同一线程内共享此内存）；<br>  错误，返回NULL。</li>
</ul>
<h2 id="使用问题"><a href="#使用问题" class="headerlink" title="使用问题"></a>使用问题</h2><p>inet_ntoa函数连续调用两次产生的返回值相同。<br><img src="315ac77f2681b218a2701ea836cb2a74d07052becaf5f2a71605bea15345c483.png" alt="图 21"><br><img src="3a48ee6e4345a6810adaf407431ccb74efa9b8ec44ce3b8d8568661f6b327d5e.png" alt="图 22">  </p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p><img src="9530d8ccccab525d7451505cf66fadef6cb1b5ad4674e9f6aefc69343cc76463.png" alt="图 23">  </p>
<ul>
<li>根据官网定义，我们看到inet_ntoa函数返回一个字符指针，它指向一个定义在函数inet_ntoa中的static 类型字符串。</li>
<li>也就是说，每次调用inet_ntoa函数，都会改变最后一次调用inet_ntoa函数时得到的结果。</li>
</ul>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>如果需要把结果保存下来，那么可以在每次调用inet_ntoa函数后调用strcpy函数或memcpy函数将结果存到自定义的字符串中。<br><img src="cf7e364079c402d99b28829a660ca87519e1536edb4f4c7e5218821fe82c64e7.png" alt="图 24"><br><img src="88cf94fcfcb14a4fcc299a576c6852f0d8d6b71acef5e1b30756bfc08d0c24e0.png" alt="图 25">  </p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>inet_ntoa</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS Flag Day</title>
    <url>/2020/09/05/DNS-Flag-Day/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>2019 年 02 月 01 日由 Google、Cloudflare、Cisco、PowerDNS、ISC(BIND) 等知名 DNS 服务提供商将不再主动采用”EDNS error workaround”获取域名 NS 服务器的解析记录。</li>
<li>当前 DNS 响应速度没必要地慢，并且无法部署新功能。为了解决这些问题，DNS 软件供应商以及大型公共 DNS 提供商将在 2019 年 2 月 1 日删除某些解决方法”EDNS error workaround”。<span id="more"></span></li>
<li>Google 公共DNS服务：8.8.8.8 </li>
<li>Cloudflare公共DNS服务：1.1.1.1</li>
<li>PowerDNS、ISC：DNS软件提供商，开源软件</li>
</ul>
<h2 id="DNS-Flag-Day-缘由"><a href="#DNS-Flag-Day-缘由" class="headerlink" title="DNS Flag Day 缘由"></a>DNS Flag Day 缘由</h2><ul>
<li>DNS 扩展机制于 1999 年制定，2013 年稍作更新，建立了用 EDNS 选项或标志回复查询的 “道路规则”。尽管如此，一些实现仍然违反规则。DNS 软件开发人员试图通过各种非标准行为的变通方法来解决 DNS 协议的互操作性问题，特别是其 EDNS 扩展（RFC 6891 标准）。这与具有通行权的驾驶员在继续之前在交叉路口犹豫的方式没有什么不同，如果交叉路口中有另一个驾驶员表现不正常。这些变通办法使 DNS 软件过于复杂，现在也对 DNS 产生负面影响。</li>
<li>主要变化是来自上述供应商的 DNS 软件过去会将 DNS 查询超时解释为网络或服务器问题的标志。从 2019 年 2 月 1 日开始，将不会尝试禁用 EDNS 作为对 DNS 查询超时的反应。</li>
<li>这实际上意味着所有对 EDNS 查询完全没有响应的 DNS 服务器将被视为死机。</li>
</ul>
<h2 id="DNS-Flag-Day-检查"><a href="#DNS-Flag-Day-检查" class="headerlink" title="DNS Flag Day 检查"></a>DNS Flag Day 检查</h2><ul>
<li>为了检查 EDNS 的合规性，建议您使用项目主页的工具，为整个域生成简化的检查结果。</li>
<li>可以使用 <a href="https://ednscomp.isc.org/ednscomp">ednscomp</a> 工具测试 NS 服务器的实现，以确保正确处理 EDNS。</li>
<li>值得注意的是，EDNS 仍然不是强制性的。如果决定不支持 EDNS，只要您的 NS 服务器根据 EDNS 标准第 7 节回复即可。</li>
</ul>
<h2 id="部分知名网站的检查结果"><a href="#部分知名网站的检查结果" class="headerlink" title="部分知名网站的检查结果"></a>部分知名网站的检查结果</h2><p><img src="6cf818cb24706eff78b66f893388f1bbd4dd48dc81b0309bb5ce444d130f40ea.png" alt="图 15"><br><img src="da968feec46613df7e09a9861f61cb67dee7afc1c96bb546f7ede59d8b353c15.png" alt="图 16"><br><img src="1983f2152e994ad09be2385e35412d7204e2720ed695cac77b8d9bdd444963c6.png" alt="图 17">  </p>
<h2 id="江苏移动授权服务器的检查结果"><a href="#江苏移动授权服务器的检查结果" class="headerlink" title="江苏移动授权服务器的检查结果"></a>江苏移动授权服务器的检查结果</h2><p><img src="81fd00778366859f9a322ec868fd58db0a25dbc4d98e036d89a4e5c3fa5b8277.png" alt="图 18">  </p>
<h2 id="江苏移动授权服务器的问题"><a href="#江苏移动授权服务器的问题" class="headerlink" title="江苏移动授权服务器的问题"></a>江苏移动授权服务器的问题</h2><p><img src="71136f54bf04d34711bbeef9d486eddad8f2318d71c6b519e73f84391de2ac50.png" alt="图 19">  </p>
<h2 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h2><p><img src="61adfa43a14debd5b0331e7d2326afe16f14d4a5bb83935dcffd48d6ab55d8a6.png" alt="图 20">  </p>
<h2 id="问题影响分析"><a href="#问题影响分析" class="headerlink" title="问题影响分析"></a>问题影响分析</h2><ul>
<li>DNS Flag Day 本质上是DNS软件开发商对目前仍在运行的不能遵守EDNS规范各类授权服务器的新的应对处理措施。</li>
<li>以前的处理措施比较宽容，会采取EDNS错误应对措施（EDNS error workaround）。<br>比如：如果递归服务器请求包携带EDNS数据，而授权服务器无应答，超时后，递归服务器会认为授权服务器可能不支持EDNS，再发一次不携带EDNS的请求包到授权服务器。这样以来，会使得递归服务器程序逻辑复杂，运行缓慢。</li>
<li>现在，这样的错误应对措施将从2019年2月1号开始从发布或部署的代码里去除。</li>
<li>但这样的影响仅限于发布的代码，不影响现行部署的程序。也可能会影响Google和Cloudflare的公共DNS。如果一个用户的DNS设置为Google的DNS，在2月1日后访问网络可能会受到影响。但如果用户使用的是缺省的运营商DNS，则完全不受影响。</li>
</ul>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>经过测试发现：<br>江苏移动的授权服务器对正常的EDNS数据能够正确应答，返回正确的数据。但缺少对EDNS版本号的校验，而一般情况下，正常的请求是不会使用非法的EDNS版本来请求数据的。因此基本上不会有什么影响。<br>另外，授权服务器不支持EDNS的TCP请求。</p>
<p>以上与EDNS规范不兼容的问题可以通过后续版本升级来解决。</p>
]]></content>
      <categories>
        <category>DNS</category>
      </categories>
      <tags>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS安全防护</title>
    <url>/2020/09/04/DNS%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4/</url>
    <content><![CDATA[<h2 id="DDOS攻击"><a href="#DDOS攻击" class="headerlink" title="DDOS攻击"></a>DDOS攻击</h2><p>DDoS （Distributed Denial ofservice）攻击通过僵尸网络利用各种服务请求耗尽被攻击网络的系统资源，造成被攻击网络无法处理合法用户的请求。而针对DNS的DDoS攻击又可按攻击发起者和攻击特征进行分类。主要表现特征如下：</p>
<span id="more"></span>
<ul>
<li>按照攻击发起者分类<br>僵尸网络：控制僵尸网络，利用真实DNS协议栈发起大量域名查询请求。<br>模拟工具：利用工具软件伪造源IP发送海量DNS查询。</li>
<li>按照攻击特征分类<br>Flood攻击：发送海量DNS查询报文导致网络带宽耗尽而无法传送正常DNS查询请求。<br>资源消耗攻击：发送大量非法域名查询报文引起DNS服务器持续进行迭代查询，从而达到较少的攻击流量消耗大量服务器资源的目的。<br><img src="89fc7f078285dd51ea13a165feb02772818d1a411478cb078d4d03432d397e7c.png" alt="图 9">  </li>
</ul>
<h2 id="DNS欺骗"><a href="#DNS欺骗" class="headerlink" title="DNS欺骗"></a>DNS欺骗</h2><p>（1）缓存污染：攻击者采用特殊的DNS请求，将虚假信息放入DNS的缓存中。<br><img src="af4d51c4482f05a0efdc6fa06dbbcc7550ff0385d1b022d433ed037bfdd2ed32.png" alt="图 10">  </p>
<p>（2）DNS信息劫持 ：攻击者监听DNS会话，猜测DNS服务器响应ID，抢先将虚假的响应提交给客户端。<br>（3）DNS重定向 ：将DNS名称查询重定向到恶意DNS服务器。<br><img src="0d8f88647eea3363d83cca8abc754b547dcdfa6c3982a4e91493d73b08adfab4.png" alt="图 11">  </p>
<h2 id="DNS安全防护措施"><a href="#DNS安全防护措施" class="headerlink" title="DNS安全防护措施"></a>DNS安全防护措施</h2><p>（1）提供至少2个以上的DNS服务地址。<br>用户的DNS解析服务可以进行轮循处理，只要保证一个DNS服务器运转正常，即可确认网站的访问将不受故障影响，尽量减少宕机的比率。<br>（2）智能DNS解析支持多路线多区域。<br>通过链路负载均衡功能将流量分配到不同的服务器上，可减少各种灾害带来的影响。<br>（3）DNS解析对外具有高防功能。<br>在抵御外来网络攻击方面DNS解析服务器需要做充分的准备，此外，宕机检测也是DNS解析里一大重要功能。系统将对域名进行24小时不间断检测，当其中有服务器出现故障问题时，宕机检测将对用户的解析自动切换到预先设置的备用服务器IP，应急响应到场时间不超过设定时间，保证业务访问的可持续性。<br>（4）建议采用TSIG和DNSSEC技术。</p>
<h2 id="DNSSEC技术"><a href="#DNSSEC技术" class="headerlink" title="DNSSEC技术"></a>DNSSEC技术</h2><p>域名系统安全扩展：Domain Name System Security Extensions</p>
<ul>
<li>DNSSEC通过公私钥验证的方式，服务端用私钥为每一条资源记录添加数字签名响应给客户端，客户端用公钥对签名进行验证，从而保证安全。</li>
<li>DNSSEC 就是一个对现有 DNS 协议进行安全完善的拓展。他在现有的 DNS 协议的基础上，增加了几个新的资源记录来达到这个目的。</li>
<li>新增四种资源记录类型：RRSIG (Resource Record Signature)、DNSKEY (DNS Public Key)、DS (Delegation Signer)、NSEC（用于验证不存在的资源记录）</li>
</ul>
<h2 id="RRSIG-（Resource-Record-Signature）"><a href="#RRSIG-（Resource-Record-Signature）" class="headerlink" title="RRSIG （Resource Record Signature）"></a>RRSIG （Resource Record Signature）</h2><p>该记录用于存放我们当前域名每一条记录的 DNSSEC 签名。</p>
<ul>
<li>算法类型 (参考附录「算法类型列表」)</li>
<li>标签 (泛解析中原先 RRSIG 记录的名称)</li>
<li>原 TTL 大小</li>
<li>签名失效时间</li>
<li>签名签署时间</li>
<li>Key 标签 (一个简短的数值，用来迅速判断应该用那个 DNSKEY 记录来验证)</li>
<li>签名名称 (用于验证该签名的 DNSKEY 名称)</li>
<li>加密签名<br><img src="6ffda5232e8de5dc23bb20be0133916679e12b301bf14917d252f22a2b3199ff.png" alt="图 12">  </li>
</ul>
<h2 id="DNSKEY-DNS-Public-Key"><a href="#DNSKEY-DNS-Public-Key" class="headerlink" title="DNSKEY(DNS Public Key)"></a>DNSKEY(DNS Public Key)</h2><p>该记录用于存放我们用于检查 DNSSEC 签名的公钥</p>
<ul>
<li>标识符 (Zone Key (DNSSEC密钥集) 以及 Secure Entry Point (KSK和简单密钥集))</li>
<li>协议 (固定值3 向下兼容)</li>
<li>算法类型 (参考附录「算法类型列表」)</li>
<li>公钥内容<br><img src="81ba5fc3cacbf8cf441dc74465fd3a2925bde7bd523d69cb844bfb76bcd8062b.png" alt="图 13">  </li>
</ul>
<h2 id="DS（Delegation-Signer"><a href="#DS（Delegation-Signer" class="headerlink" title="DS（Delegation Signer)"></a>DS（Delegation Signer)</h2><p>为什么挟持者不把 RRSIG 以及 DNSKEY 记录也给污染了呢？</p>
<ul>
<li>DS用于存放 DNSSEC 公钥的散列值</li>
<li>Key 标签 (一个简短的数值，用来迅速判断应该用那个 DNSKEY 记录来验证)</li>
<li>算法类型 (参考附录「算法类型列表」)</li>
<li>摘要类型 (创建摘要值的加密散列算法)(参考附录「摘要类型列表」)</li>
<li>Digest: A cryptographic hash value of the referenced DNSKEY-record.<br><img src="d798c60c403b0e651ba7406ee84c5aa13d5f9df50ab5593245140703e8032196.png" alt="图 14">  </li>
</ul>
<h2 id="DNSSEC现状及问题"><a href="#DNSSEC现状及问题" class="headerlink" title="DNSSEC现状及问题"></a>DNSSEC现状及问题</h2><ul>
<li>无法保证私密性<br>DNSSEC 并没有改变 DNS 基于 UDP 的通讯方式，数据流也都是明文传输，他所做的只是加上了一个数字签名，而中间人依然可以看到你请求了什么、结果是什么</li>
<li>挟持发生时不能告诉用户真正的记录<br>当用户的 DNS 被挟持的时候，用户通过检查 DNSSEC 签名，可以知道自己得到的并不是真正的解析结果，而是得到了一个被伪造的地址。但是，用户并不知道真正的解析结果是什么。</li>
<li>支持 DNSSEC 的递归服务器并不多</li>
</ul>
]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>DNS</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>DPDK 18.11 KNI部分的变化</title>
    <url>/2020/09/03/DPDK-18-11-KNI%E9%83%A8%E5%88%86%E7%9A%84%E5%8F%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="DPDK-18-11-KNI部分的变化"><a href="#DPDK-18-11-KNI部分的变化" class="headerlink" title="DPDK 18.11 KNI部分的变化"></a>DPDK 18.11 KNI部分的变化</h2><p>更新了KNI内核模块，新增了一个内核模块参数<code>carrier=[on|off]</code>，可允许用户控制KNI接口网卡缺省的链路载波状态（carrier state），缺省的状态为off。<br>因此以缺省状态创建的KNI网卡是在载波状态设置为on之前<strong>是不能使用的</strong>。</p>
<span id="more"></span>

<h2 id="设置KNI"><a href="#设置KNI" class="headerlink" title="设置KNI"></a>设置KNI</h2><p>为此KNI部分新增了一个API接口函数rte_kni_update_link可以设置网卡的状态。<br><img src="4453ea4a8dc614df09c271ddcba13841fac81d9a66bd902af812ac61050e7067.png" alt="图 1">  </p>
<p>也可以采用下面的shell命令来控制KNI网卡的状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /sys/class/net/veth0/carrier</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="built_in">echo</span> 0 &gt; /sys/class/net/veth0/carrier</span><br></pre></td></tr></table></figure>

<p>还可以在加载kni内核模块时设置carrier参数来设置缺省的载波状态。<br>如设置缺省的载波状态为on：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># insmod kmod/rte_kni.ko carrier=on</span></span><br></pre></td></tr></table></figure>
<p>或设置缺省的载波状态为off：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># insmod kmod/rte_kni.ko carrier=off</span></span><br></pre></td></tr></table></figure>
<p>如果加载kni内核模块时不指定carrier参数，则KNI接口的<strong>缺省载波状态被设置为off</strong>.</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Monitor the link status of all ports and update the</span></span><br><span class="line"><span class="comment"> * corresponding KNI interface(s)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"><span class="title function_">monitor_all_ports_link_status</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">uint16_t</span> portid;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rte_eth_link</span> <span class="title">link</span>;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kni_port_params</span> **<span class="title">p</span> =</span> kni_port_params_array;</span><br><span class="line">  <span class="type">int</span> prev;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">while</span> (monitor_links) &#123;</span><br><span class="line">    rte_delay_ms(<span class="number">500</span>);</span><br><span class="line">    RTE_ETH_FOREACH_DEV(portid) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((ports_mask &amp; (<span class="number">1</span> &lt;&lt; portid)) == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      <span class="built_in">memset</span>(&amp;link, <span class="number">0</span>, <span class="keyword">sizeof</span>(link));</span><br><span class="line">      rte_eth_link_get_nowait(portid, &amp;link);</span><br><span class="line">      <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; p[portid]-&gt;nb_kni; i++) &#123;</span><br><span class="line">        prev = rte_kni_update_link(p[portid]-&gt;kni[i], link.link_status);</span><br><span class="line">        log_link_state(p[portid]-&gt;kni[i], prev, &amp;link);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>DPDK</category>
      </categories>
      <tags>
        <tag>DPDK</tag>
      </tags>
  </entry>
  <entry>
    <title>shmget和shm_open</title>
    <url>/2020/09/03/shmget%E5%92%8Cshm-open/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>现代Linux有两种共享内存机制：</p>
<ul>
<li>POSIX共享内存(shm_open()、shm_unlink())</li>
<li>System V共享内存(shmget()、shmat()、shmdt())<span id="more"></span></li>
</ul>
<h2 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h2><ol>
<li>接口的区别，如上</li>
<li>shm_open通过mmap映射到文件/dev/shm/中</li>
<li>shmget通过ipcs查询</li>
</ol>
<p><strong>注意</strong><br>虽然shm_open映射到文件，但是系统重启后，仍然会丢失/dev/shm/文件，其持久性与shmget相当</p>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><h3 id="shm-open"><a href="#shm-open" class="headerlink" title="shm_open"></a>shm_open</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> test_shm_mmap_svr 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> test_shm_mmap_svr</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHMSZ     27</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHM_NAME     <span class="string">&quot;mmap_test&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> shmid;</span><br><span class="line">    <span class="type">char</span> *shm, *s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Create the segment.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((shmid = shm_open(SHM_NAME, O_CREAT | O_RDWR, <span class="number">0644</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shm_open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ftruncate(shmid, SHMSZ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;ftruncate&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Now we attach the segment to our data space.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	shm = mmap(<span class="number">0</span>, SHMSZ, PROT_READ | PROT_WRITE,</span><br><span class="line">			MAP_SHARED | MAP_POPULATE, shmid, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (shm == (<span class="type">char</span> *) <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Now put some things into the memory for the</span></span><br><span class="line"><span class="comment">     * other process to read.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    s = shm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (c = <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; c++)</span><br><span class="line">        *s++ = c;</span><br><span class="line">    *s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Finally, we wait until the other process </span></span><br><span class="line"><span class="comment">     * changes the first character of our memory</span></span><br><span class="line"><span class="comment">     * to &#x27;*&#x27;, indicating that it has read what </span></span><br><span class="line"><span class="comment">     * we put there.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> (*shm != <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> test_shm_mmap_cli 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> test_shm_mmap_cli</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHMSZ     27</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHM_NAME     <span class="string">&quot;mmap_test&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> shmid;</span><br><span class="line">    <span class="type">char</span> *shm, *s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Locate the segment.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((shmid = shm_open(SHM_NAME, O_CREAT | O_RDWR, <span class="number">0644</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shm_open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ftruncate(shmid, SHMSZ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;ftruncate&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Now we attach the segment to our data space.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	shm = mmap(<span class="number">0</span>, SHMSZ, PROT_READ | PROT_WRITE,</span><br><span class="line">			MAP_SHARED | MAP_POPULATE, shmid, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (shm == (<span class="type">char</span> *) <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Now read what the server put in the memory.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (s = shm; *s != <span class="number">0</span>; s++)</span><br><span class="line">        <span class="built_in">putchar</span>(*s);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Finally, change the first character of the </span></span><br><span class="line"><span class="comment">     * segment to &#x27;*&#x27;, indicating we have read </span></span><br><span class="line"><span class="comment">     * the segment.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    *shm = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>运行结果：<br><img src="cb535ff7ff0bf31aeb696788e261ecfd4d85723a4ce4c2129a3d2862ebcddfb7.png" alt="图 1"><br><img src="b4b8b776f8ccb3861330fbb1f8cfa9ed0f82d8ffdfc23b29cfe99044c8d8219b.png" alt="图 2">  </p>
<h3 id="shmget"><a href="#shmget" class="headerlink" title="shmget"></a>shmget</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> test_shm_sysv_svr 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> test_shm_sysv_svr</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHMSZ     27</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> shmid;</span><br><span class="line">    <span class="type">key_t</span> key;</span><br><span class="line">    <span class="type">char</span> *shm, *s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We&#x27;ll name our shared memory segment</span></span><br><span class="line"><span class="comment">     * &quot;5678&quot;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    key = <span class="number">5678</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Create the segment.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((shmid = shmget(key, SHMSZ, IPC_CREAT | <span class="number">0666</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Now we attach the segment to our data space.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((shm = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>)) == (<span class="type">char</span> *) <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmat&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Now put some things into the memory for the</span></span><br><span class="line"><span class="comment">     * other process to read.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    s = shm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (c = <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; c++)</span><br><span class="line">        *s++ = c;</span><br><span class="line">    *s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Finally, we wait until the other process </span></span><br><span class="line"><span class="comment">     * changes the first character of our memory</span></span><br><span class="line"><span class="comment">     * to &#x27;*&#x27;, indicating that it has read what </span></span><br><span class="line"><span class="comment">     * we put there.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> (*shm != <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> test_shm_sysv_cli 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> test_shm_sysv_cli</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHMSZ     27</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> shmid;</span><br><span class="line">    <span class="type">key_t</span> key;</span><br><span class="line">    <span class="type">char</span> *shm, *s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We need to get the segment named</span></span><br><span class="line"><span class="comment">     * &quot;5678&quot;, created by the server.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    key = <span class="number">5678</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Locate the segment.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((shmid = shmget(key, SHMSZ, <span class="number">0666</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Now we attach the segment to our data space.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((shm = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>)) == (<span class="type">char</span> *) <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmat&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Now read what the server put in the memory.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (s = shm; *s != <span class="number">0</span>; s++)</span><br><span class="line">        <span class="built_in">putchar</span>(*s);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Finally, change the first character of the </span></span><br><span class="line"><span class="comment">     * segment to &#x27;*&#x27;, indicating we have read </span></span><br><span class="line"><span class="comment">     * the segment.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    *shm = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> test_shm_mmap_svr 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> test_shm_mmap_svr</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHMSZ     27</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHM_NAME     <span class="string">&quot;mmap_test&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> shmid;</span><br><span class="line">    <span class="type">char</span> *shm, *s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We&#x27;ll name our shared memory segment</span></span><br><span class="line"><span class="comment">     * &quot;5678&quot;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Create the segment.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((shmid = shm_open(SHM_NAME, O_CREAT | O_RDWR, <span class="number">0644</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shm_open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ftruncate(shmid, SHMSZ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;ftruncate&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Now we attach the segment to our data space.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	shm = mmap(<span class="number">0</span>, SHMSZ, PROT_READ | PROT_WRITE,</span><br><span class="line">			MAP_SHARED | MAP_POPULATE, shmid, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (shm == (<span class="type">char</span> *) <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Now put some things into the memory for the</span></span><br><span class="line"><span class="comment">     * other process to read.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    s = shm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (c = <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; c++)</span><br><span class="line">        *s++ = c;</span><br><span class="line">    *s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Finally, we wait until the other process </span></span><br><span class="line"><span class="comment">     * changes the first character of our memory</span></span><br><span class="line"><span class="comment">     * to &#x27;*&#x27;, indicating that it has read what </span></span><br><span class="line"><span class="comment">     * we put there.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> (*shm != <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：<br><img src="32003a2bceafdc4d4a9f92696a4e83a8512fbc5777b5c5c046092335a23c9a0b.png" alt="图 3"><br><img src="10ae700eeae7568b2cc0fb17020428c33edd19504ad8e458a1eceff292a4ecb3.png" alt="图 4">  </p>
]]></content>
      <categories>
        <category>IPC</category>
      </categories>
      <tags>
        <tag>IPC</tag>
        <tag>共享内存</tag>
      </tags>
  </entry>
  <entry>
    <title>授权域配置</title>
    <url>/2020/09/03/%E6%8E%88%E6%9D%83%E5%9F%9F%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="DNS的资源记录"><a href="#DNS的资源记录" class="headerlink" title="DNS的资源记录"></a>DNS的资源记录</h2><p>A：IPV4地址。<br>AAAA：IPV6地址。<br>NS：名称服务器，说明该域有哪些DNS服务器提供解析服务。</p>
<span id="more"></span>
<p>SOA：起始授权机构(SOA) 资源记录。指示区域的源名称，并包含作为区域主要信息源的服务器的名称。它还表示该区域的其他基本属性。SOA 资源记录在任何标准区域中始终是首位记录。它表示最初创建它的DNS服务器或现在是该区域的主服务器的DNS服务器。它还用于存储会影响区域更新或过期的其他属性，如版本信息和计时。这些属性会影响在该区域的权威服务器之间进行区域传输的频繁程度语法：owner  TTL  CLASS SOA  name_server  responsible_person(serial_number  refresh_interval  retry_interval  expiration  minimum_time_to_live)<br><img src="0b96b12c242b619ad5738f79042759f28698baa21803959d0b684b4dcdf5f285.png" alt="图 5"><br>CNAME：别名记录。<br>PTR：反解。从IP到域名的映射。<br>MX：邮件交换器(MX) 资源记录如mail_exchanger_host中指定的那样，为邮件交换器主机提供邮件路由，以便将邮件发送给owner字段中指定的域名。preference表示在指定了多个交换器主机情况下的首选顺序。每个交换机主机都必须在有效区域中有一个相应的主机(A) 地址资源记录（RFC 1035）。<br>语法：owner  TTL  CLASS  MX  preference mail_exchanger_host<br>例如：mail.com. IN MX 10 baidu.mail.com.</p>
<h2 id="授权域的配置"><a href="#授权域的配置" class="headerlink" title="授权域的配置"></a>授权域的配置</h2><p><img src="6f5d9a7d33ade6609beea1aea74a660b08e94fd7e2be598ab1461964be4bd1d4.png" alt="图 6"><br><img src="49e60c99b98d6ba7484a7faa02127d8373d7745f7bc2f631773e37552970d22a.png" alt="图 7"><br><img src="b00556a6a996bca54a8b00d9819839d940164e71b9b40126811ae46b7429899f.png" alt="图 8">  </p>
]]></content>
      <categories>
        <category>DNS</category>
      </categories>
      <tags>
        <tag>DNS</tag>
        <tag>授权域</tag>
      </tags>
  </entry>
  <entry>
    <title>DPDK文档的错误</title>
    <url>/2020/09/02/DPDK%E6%96%87%E6%A1%A3%E7%9A%84%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<h2 id="DPDK文档里的一个坑"><a href="#DPDK文档里的一个坑" class="headerlink" title="DPDK文档里的一个坑"></a>DPDK文档里的一个坑</h2><p>rte_mempool_get_bulk的返回值注释有误</p>
<span id="more"></span>
<p><img src="9eb3bb869095b85e13fd4ce5b831fa4593525b74955a6df910a44110daa0b61a.png" alt="图 11">  </p>
<p><img src="2419fa7680d4eefae69cbace4cf3f2f39576cc6b09f75b7ba46392daa414246e.png" alt="图 12">  </p>
<h2 id="错误码意义"><a href="#错误码意义" class="headerlink" title="错误码意义"></a>错误码意义</h2><p><strong>#define ENOENT 2 /* No such file or directory */</strong><br><strong>#define ENOBUFS 105 /* No buffer space available */</strong></p>
<h2 id="代码错误判断"><a href="#代码错误判断" class="headerlink" title="代码错误判断"></a>代码错误判断</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">dns_decode_proc</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (!force_quit) &#123;</span><br><span class="line">		<span class="keyword">while</span> (!force_quit) &#123;</span><br><span class="line">			<span class="keyword">if</span> (rte_ring_sc_dequeue_bulk(</span><br><span class="line">				  process_ring, (<span class="type">void</span>**)pkts_burst, MAX_PKT_BURST, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			usleep(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (!force_quit) &#123;</span><br><span class="line">			<span class="keyword">if</span> (rte_mempool_get_bulk(</span><br><span class="line">				  logstr_pool, (<span class="type">void</span>**)logs, MAX_PKT_BURST) == -ENOENT) &#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_PKT_BURST; i++) &#123;</span><br><span class="line">			logs[i]-&gt;len = <span class="number">0</span>;</span><br><span class="line">			m = pkts_burst[i];</span><br><span class="line">			<span class="type">uint8_t</span>* data = rte_pktmbuf_mtod(m, <span class="type">uint8_t</span>*);</span><br><span class="line">			<span class="type">int</span> data_len = m-&gt;data_len;</span><br><span class="line">			dns_packet_decode(dctx, logs[i], data, data_len, &amp;ts);</span><br><span class="line">			rte_pktmbuf_free(m);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ret = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (ret == <span class="number">0</span> &amp;&amp; !force_quit) &#123;</span><br><span class="line">			ret = rte_ring_sp_enqueue_bulk(</span><br><span class="line">			  logstr_ring, (<span class="type">void</span>**)logs, MAX_PKT_BURST, <span class="literal">NULL</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>DPDK</category>
      </categories>
      <tags>
        <tag>DPDK</tag>
      </tags>
  </entry>
  <entry>
    <title>redhat root密码丢失找回</title>
    <url>/2020/09/02/redhat-root%E5%AF%86%E7%A0%81%E4%B8%A2%E5%A4%B1%E6%89%BE%E5%9B%9E/</url>
    <content><![CDATA[<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>使用redhat忘记root密码</p>
<span id="more"></span>
<h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><ol>
<li>启动redhat linux出现倒计时界面如下图<br><img src="83b1c96ee941ee6bf0e6b9783178de78d7fff6824b5f5ef249c5e0700b7b1bb5.png" alt="图 1">  </li>
<li>此时按任意键出现下图<br><img src="ed05bfb130f05f6ff9f9282e0fcb3fa26a4b4c3e97d049b1272c672d8831b995.png" alt="图 2">  </li>
<li>此时按e键出现下图<br><img src="128b2fa624ce97e4ddadd1d6d9b73ace478dfceca6d8512201dd1281ddf6f045.png" alt="图 3">  </li>
<li>按下箭头，走到第二个选项，按e键出现下图<br><img src="4fc064a4d48d511ac16c3dc1560273a2ad356a8f559c08c712e6598b6dc9f440.png" alt="图 4">  </li>
<li>输入：空格1，或者空格single，回车出现下图<br><img src="9fe4dbaaf140dd1b0ee551faac3b46a9910c0d5769f5f417d61dcea7d706e622.png" alt="图 5">  </li>
<li>此时按b键出现下图<br><img src="9eb3370c94d2fa2162f2649d263e2ace42c1d2b46e7cd1cc9f5de8af373a3434.png" alt="图 6">  </li>
<li>等待若干秒后出现下图界面，此时我们已经成功进入了单用户<br><img src="91126e6cbd1e2bc0829e947288103349cf1c4490673fb1126abd5b9c2c1c873b.png" alt="图 7">  </li>
<li>此时只需要输入passwd回车就可以修改root用户的密码<br><img src="db7b0cdde44f6b1d757b5d139844da3aed78c7b2be46d303b041a1906b6a9288.png" alt="图 8">  </li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>密码需要确认一次才能修改成功，此时输入reboot重启，就可以用刚才设置的密码登陆系统</li>
<li>需要说明的是进入单用户模式的前提是grub没有加密。</li>
</ul>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>redhat</tag>
      </tags>
  </entry>
  <entry>
    <title>简化dpdk-devbind.py</title>
    <url>/2020/09/01/%E7%AE%80%E5%8C%96dpdk-devbind-py/</url>
    <content><![CDATA[<h2 id="dpdk-devbind-py作用"><a href="#dpdk-devbind-py作用" class="headerlink" title="dpdk-devbind.py作用"></a>dpdk-devbind.py作用</h2><p>用于绑定dpdk驱动、去绑定、显示当前绑定状态</p>
<span id="more"></span>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">usage: dpdk_bind [-h] [-s]</span><br><span class="line">                 [--status-dev &#123;baseband,compress,crypto,dma,event,mempool,misc,net,regex&#125;]</span><br><span class="line">                 [-b DRIVER | -u] [--force]</span><br><span class="line">                 [DEVICE [DEVICE ...]]</span><br><span class="line">[root@jmnd-246 rma]<span class="comment"># dpdk_bind -h</span></span><br><span class="line">usage: dpdk_bind [-h] [-s]</span><br><span class="line">                 [--status-dev &#123;baseband,compress,crypto,dma,event,mempool,misc,net,regex&#125;]</span><br><span class="line">                 [-b DRIVER | -u] [--force]</span><br><span class="line">                 [DEVICE [DEVICE ...]]</span><br><span class="line"></span><br><span class="line">Utility to <span class="built_in">bind</span> and unbind devices from Linux kernel</span><br><span class="line"></span><br><span class="line">positional arguments:</span><br><span class="line">  DEVICE                Device specified as PCI <span class="string">&quot;domain:bus:slot.func&quot;</span> syntax</span><br><span class="line">                        or <span class="string">&quot;bus:slot.func&quot;</span> syntax. For devices bound to Linux</span><br><span class="line">                        kernel drivers, they may be referred to by interface</span><br><span class="line">                        name.</span><br><span class="line"></span><br><span class="line">optional arguments:</span><br><span class="line">  -h, --<span class="built_in">help</span>            show this <span class="built_in">help</span> message and <span class="built_in">exit</span></span><br><span class="line">  -s, --status          Print the current status of all known devices.</span><br><span class="line">  --status-dev &#123;baseband,compress,crypto,dma,event,mempool,misc,net,regex&#125;</span><br><span class="line">                        Print the status of given device group.</span><br><span class="line">  -b DRIVER, --<span class="built_in">bind</span> DRIVER</span><br><span class="line">                        Select the driver to use or <span class="string">&quot;none&quot;</span> to unbind the</span><br><span class="line">                        device</span><br><span class="line">  -u, --unbind          Unbind a device (equivalent to <span class="string">&quot;-b none&quot;</span>)</span><br><span class="line">  --force               Override restriction on binding devices <span class="keyword">in</span> use by</span><br><span class="line">                        Linux<span class="string">&quot; WARNING: This can lead to loss of network</span></span><br><span class="line"><span class="string">                        connection and should be used with caution.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Examples:</span></span><br><span class="line"><span class="string">---------</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">To display current device status:</span></span><br><span class="line"><span class="string">        dpdk_bind --status</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">To display current network device status:</span></span><br><span class="line"><span class="string">        dpdk_bind --status-dev net</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">To bind eth1 from the current driver and move to use vfio-pci</span></span><br><span class="line"><span class="string">        dpdk_bind --bind=vfio-pci eth1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">To unbind 0000:01:00.0 from using any driver</span></span><br><span class="line"><span class="string">        dpdk_bind -u 0000:01:00.0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">To bind 0000:02:00.0 and 0000:02:00.1 to the ixgbe kernel driver</span></span><br><span class="line"><span class="string">        dpdk_bind -b ixgbe 02:00.0 02:00.1</span></span><br></pre></td></tr></table></figure>

<h2 id="查看status"><a href="#查看status" class="headerlink" title="查看status"></a>查看status</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dpdk_bind -s</span></span><br><span class="line"></span><br><span class="line">Network devices using DPDK-compatible driver</span><br><span class="line">============================================</span><br><span class="line">0000:cc:00.1 <span class="string">&#x27;Device 1000&#x27;</span> drv=vfio-pci unused=</span><br><span class="line"></span><br><span class="line">Network devices using kernel driver</span><br><span class="line">===================================</span><br><span class="line">0000:24:00.0 <span class="string">&#x27;I350 Gigabit Network Connection 1521&#x27;</span> <span class="keyword">if</span>=ens33f0 drv=igb unused=vfio-pci *Active*</span><br><span class="line">0000:24:00.1 <span class="string">&#x27;I350 Gigabit Network Connection 1521&#x27;</span> <span class="keyword">if</span>=ens33f1 drv=igb unused=vfio-pci </span><br><span class="line">0000:ca:00.0 <span class="string">&#x27;Virtio network device 1000&#x27;</span> <span class="keyword">if</span>=ens25 drv=virtio-pci unused=vfio-pci *Active*</span><br><span class="line">0000:cb:00.0 <span class="string">&#x27;Virtio network device 1000&#x27;</span> <span class="keyword">if</span>=ens26 drv=virtio-pci unused=vfio-pci </span><br><span class="line">0000:cc:00.0 <span class="string">&#x27;Device 1000&#x27;</span> <span class="keyword">if</span>= drv=jmnd_sriov unused=vfio-pci </span><br><span class="line">0000:cc:00.2 <span class="string">&#x27;Device 1000&#x27;</span> <span class="keyword">if</span>= drv=jmnd_sriov unused=vfio-pci </span><br><span class="line">0000:cc:00.3 <span class="string">&#x27;Device 1000&#x27;</span> <span class="keyword">if</span>= drv=jmnd_sriov unused=vfio-pci </span><br><span class="line">0000:cc:00.4 <span class="string">&#x27;Device 1000&#x27;</span> <span class="keyword">if</span>= drv=jmnd_sriov unused=vfio-pci </span><br><span class="line">0000:cc:00.5 <span class="string">&#x27;Device 1000&#x27;</span> <span class="keyword">if</span>= drv=jmnd_sriov unused=vfio-pci </span><br><span class="line">0000:cc:00.6 <span class="string">&#x27;Device 1000&#x27;</span> <span class="keyword">if</span>= drv=jmnd_sriov unused=vfio-pci </span><br></pre></td></tr></table></figure>

<h2 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h2><p>1、将现有驱动设置到driver_override<br>2、unbind原有驱动<br>3、重新probe</p>
<h2 id="简化脚本"><a href="#简化脚本" class="headerlink" title="简化脚本"></a>简化脚本</h2><p>绑定到dpdk驱动，$1表示设备的bdf，例如0000:b3:00.1</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> vfio-pci &gt; /sys/bus/pci/devices/<span class="variable">$1</span>/driver_override</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$1</span> &gt; /sys/bus/pci/devices/<span class="variable">$1</span>/driver/unbind</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$1</span> &gt; /sys/bus/pci/drivers_probe</span><br></pre></td></tr></table></figure>

<p>绑定到内核驱动，$1表示设备的bdf，例如0000:b3:00.1</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> sriov &gt; /sys/bus/pci/devices/<span class="variable">$1</span>/driver_override</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$1</span> &gt; /sys/bus/pci/devices/<span class="variable">$1</span>/driver/unbind</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$1</span> &gt; /sys/bus/pci/drivers_probe</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>DPDK</category>
      </categories>
      <tags>
        <tag>DPDK</tag>
      </tags>
  </entry>
  <entry>
    <title>SecureCRT 端口转发及防火墙</title>
    <url>/2020/09/01/SecureCRT-%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%8F%8A%E9%98%B2%E7%81%AB%E5%A2%99/</url>
    <content><![CDATA[<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>通过跳板机访问内网机器或设置了登录限制的机器</p>
<span id="more"></span>
<p><img src="b09b5e0c860df6462fbd3663225a13177b7ba379387ba751cf590afd3b1ed237.png" alt="图 3">  </p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>方式1、手工登录，先登录跳板机，再手动输入ssh指令登录</p>
<p>方式2、使用SecureCRT的自动登录功能</p>
<p><img src="6303a363076324522ad2b70f0d27ae8e9288f7d92b1c71597853f2ccb0e45d94.png" alt="图 4">  </p>
<p>方式3、利用SecureCRT的端口转发及防火墙功能<br><img src="c371515100a33de3d6233f3abf0e70716a197b9fbb2e9a1c670db4c8bd956085.png" alt="图 5">  </p>
<h3 id="创建跳板机登录Session的端口转发"><a href="#创建跳板机登录Session的端口转发" class="headerlink" title="创建跳板机登录Session的端口转发"></a>创建跳板机登录Session的端口转发</h3><p><img src="d693ebe2f6b6835c143d5d93b1e163229ea77cd4c3f398cd2801b883803f6e4d.png" alt="图 6">  </p>
<h3 id="端口转发配置"><a href="#端口转发配置" class="headerlink" title="端口转发配置"></a>端口转发配置</h3><p><img src="81ac269008341454ef306312603784b05424625cb56891bd3ab70e85b30c38e7.png" alt="图 7">  </p>
<h3 id="添加防火墙"><a href="#添加防火墙" class="headerlink" title="添加防火墙"></a>添加防火墙</h3><p>菜单 Options -&gt; Global Options 新增防火墙<br><img src="34e14c21a6eef41ba673bed426c563e5381f3110c612ac043ff5a5ee7fd5fdff.png" alt="图 8">  </p>
<h3 id="配置防火墙属性"><a href="#配置防火墙属性" class="headerlink" title="配置防火墙属性"></a>配置防火墙属性</h3><p><img src="534dc68f268cd1c88ba9b2bf81cfd0f3e0e5221c3ad1cabc035629ed7819c3b3.png" alt="图 9">  </p>
<h3 id="连接内网机器时使用防火墙"><a href="#连接内网机器时使用防火墙" class="headerlink" title="连接内网机器时使用防火墙"></a>连接内网机器时使用防火墙</h3><p><img src="3e8855a4e5e243ed42f71734a2b3d3a352ad2d69bde00ac771e643edc36c1c6c.png" alt="图 10">  </p>
]]></content>
      <categories>
        <category>SecureCRT</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>SecureCRT</tag>
      </tags>
  </entry>
</search>
