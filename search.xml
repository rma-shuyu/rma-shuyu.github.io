<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>gitstats使用介绍</title>
    <url>/2022/12/05/gitstats%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>进一步来讲，Gitstats它是一个git仓库分析软件，它可以检查仓库并生成历史数据的统计信息。可以帮助你查看git仓库的提交状态，根据不同维度分析计算，并自动生成数据图表。<br>官网介绍：<a href="http://gitstats.sourceforge.net/">http://gitstats.sourceforge.net/</a></p>
<span id="more"></span>
<p>当前GitStats所生成统计信息常用分为如下几类：<br><strong>常规的统计</strong>：文件总数，行数，提交量，作者数。<br><strong>活跃性</strong>：每天中每小时的、每周中每天的、每周中每小时的、每年中每月的、每年的提交量。<br><strong>作者数</strong>：列举所有的作者（提交数，第一次提交日期，最近一次的提交日期），并按月和年来划分。<br><strong>文件数</strong>：按日期划分，按扩展名名划分。<br><strong>行数</strong>：按日期划分。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//mac osx</span><br><span class="line">brew install gnuplot</span><br><span class="line">//centos linux</span><br><span class="line">yum install gnuplot</span><br><span class="line">//ubuntu linux</span><br><span class="line">apt install gnuplot</span><br></pre></td></tr></table></figure>

<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://github.com/hoxu/gitstats.git</span><br><span class="line"><span class="built_in">cd</span> gitstats</span><br><span class="line">./gitstats 你的项目的位置 生成统计的文件夹位置</span><br></pre></td></tr></table></figure>

<h2 id="展示"><a href="#展示" class="headerlink" title="展示"></a>展示</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> 生成统计的文件夹位置</span><br><span class="line">python3 -m http.server 8090</span><br></pre></td></tr></table></figure>

<h2 id="qemu示例"><a href="#qemu示例" class="headerlink" title="qemu示例"></a>qemu示例</h2><p>如下图所示。首先，在gitstats上提供了全局的统计数据报告，包括：</p>
<p><strong>报告产生时间及产生所花费的时间</strong>：如花费了710秒<br><strong>报告所覆盖的时间</strong>：如2003-02-19 to 2022-12-05<br><strong>年龄</strong>：该repo的年纪，如“7230天，其中5918天是活跃天.”<br><strong>文件数及代码</strong>：如：9256个文件，3130k行代码。<br><strong>总提交数</strong>：如：99776，平均每天13.8个<br><strong>作者数</strong>：如2160，每个作者平均提交次数46.2次。<br><img src="efbe731981191bf53d5ddccfb0d2ceddc68787753068302bb6b07ae3325161c7.png" alt="图 6">  </p>
<p>除此之外，还包括了：</p>
<ol>
<li>时间维度的效率分析：每天中每小时的、每周中每天的、每周中每小时的、每年中每月的、每年的提交量。<br><img src="e3f27ccfddf1d938e78059ed84dbee1e10029e531785d1c35dbd64ec9fd176e4.png" alt="图 7"><br><img src="c2af9654b130fbe357f60fc7d9b0d9f688909b0fd41cc173ed06bc9609bb03db.png" alt="图 8"><br><img src="fe0f04ea5472dac1bb45ef27504cf61e91c71154babe868b1d90ae164ffa901c.png" alt="图 9"><br><img src="d8a4aee3fe667a3fe39257feb14b177fc098d0952bfb78cf7a3139ac838adb95.png" alt="图 10"><br><img src="b04a8580c65f01373f091389a9c3a7d3138acb8aaf002e9a21a5ae8b8587acf5.png" alt="图 11"><br><img src="226d67aed51a110fa818c54b82b4e74434e727c354565bcf779b19f6ba31dd55.png" alt="图 12">  </li>
</ol>
<ol start="2">
<li>提交者维度的活跃度统计：列举所有的作者（提交数，第一次提交日期，最近一次的提交日期），并按月和年来划分。<br><img src="1245268c1062710ee022fb12149e82705b29e4591c0e3aacb7fd844462b8bdaf.png" alt="图 13">  </li>
</ol>
<ol start="3">
<li><p>按照文件数：按日期划分，按扩展名名划分。<br><img src="1bacc00060ca63e9f239802a91e68849e4337457d9909e0754eee5fc1664a4ee.png" alt="图 14">  </p>
</li>
<li><p>根据提交行数或提交的tag来统计。<br><img src="29853f0496e7b26c4d69af48e2d863367a2c96ee70534f89698a31e3f49b03a4.png" alt="图 15">  </p>
</li>
</ol>
]]></content>
      <categories>
        <category>GIT</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>centos8安装pprof</title>
    <url>/2022/11/22/centos8%E5%AE%89%E8%A3%85pprof/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这是谷歌的一个linux下性能测试的小工具。可以简单快速的发现程序的性能瓶颈。</p>
<span id="more"></span>
<h2 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cat /etc/*release</span></span><br><span class="line">CentOS Linux release 8.4.2105</span><br><span class="line">NAME=<span class="string">&quot;CentOS Linux&quot;</span></span><br><span class="line">VERSION=<span class="string">&quot;8&quot;</span></span><br><span class="line">ID=<span class="string">&quot;centos&quot;</span></span><br><span class="line">ID_LIKE=<span class="string">&quot;rhel fedora&quot;</span></span><br><span class="line">VERSION_ID=<span class="string">&quot;8&quot;</span></span><br><span class="line">PLATFORM_ID=<span class="string">&quot;platform:el8&quot;</span></span><br><span class="line">PRETTY_NAME=<span class="string">&quot;CentOS Linux 8&quot;</span></span><br><span class="line">ANSI_COLOR=<span class="string">&quot;0;31&quot;</span></span><br><span class="line">CPE_NAME=<span class="string">&quot;cpe:/o:centos:centos:8&quot;</span></span><br><span class="line">HOME_URL=<span class="string">&quot;https://centos.org/&quot;</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">&quot;https://bugs.centos.org/&quot;</span></span><br><span class="line">CENTOS_MANTISBT_PROJECT=<span class="string">&quot;CentOS-8&quot;</span></span><br><span class="line">CENTOS_MANTISBT_PROJECT_VERSION=<span class="string">&quot;8&quot;</span></span><br><span class="line">CentOS Linux release 8.4.2105</span><br><span class="line">CentOS Linux release 8.4.2105</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="安装编译工具"><a href="#安装编译工具" class="headerlink" title="安装编译工具"></a>安装编译工具</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install gcc</span><br><span class="line">yum -y install gcc-c++</span><br><span class="line">yum -y install make</span><br><span class="line">yum install -y autoconf automake libtool</span><br><span class="line">yum install -y wget</span><br></pre></td></tr></table></figure>

<p><strong>提示</strong>：<br>安装过程中出现以下错误</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yum -y install gcc</span></span><br><span class="line">Last metadata expiration check: 0:15:41 ago on Wed 23 Nov 2022 03:56:44 PM CST.</span><br><span class="line">Error: </span><br><span class="line"> Problem: package gcc-8.5.0-4.el8_5.x86_64 requires glibc-devel &gt;= 2.2.90-12, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libpthread.so.0, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libdl.so.2, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libm.so.6, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libresolv.so.2, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires librt.so.1, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libutil.so.1, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libBrokenLocale.so.1, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libanl.so.1, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libthread_db.so.1, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.x86_64 requires glibc = 2.28-164.el8, but none of the providers can be installed</span><br><span class="line">  - glibc-2.28-164.el8.i686 has inferior architecture</span><br><span class="line">  - cannot install both glibc-2.28-164.el8.x86_64 and glibc-2.28-203.el8.x86_64</span><br><span class="line">  - package glibc-gconv-extra-2.28-203.el8.x86_64 requires glibc(x86-64) = 2.28-203.el8, but none of the providers can be installed</span><br><span class="line">  - cannot install the best candidate <span class="keyword">for</span> the job</span><br><span class="line">  - problem with installed package glibc-gconv-extra-2.28-203.el8.x86_64</span><br><span class="line">(try to add <span class="string">&#x27;--allowerasing&#x27;</span> to <span class="built_in">command</span> line to replace conflicting packages or <span class="string">&#x27;--skip-broken&#x27;</span> to skip uninstallable packages or <span class="string">&#x27;--nobest&#x27;</span> to use not only best candidate packages)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>则执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install gcc --allowerasing</span><br></pre></td></tr></table></figure>

<p>可执行文件对应的安装包查找：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum whatprovides autoreconf</span><br></pre></td></tr></table></figure>
<p><img src="c5dd6168b78ccf54aa38d65134cb70a21c2adb250934fcf9c448d9d29d12851c.png" alt="图 26"><br>则安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y autoconf</span><br></pre></td></tr></table></figure>

<h2 id="安装libunwind"><a href="#安装libunwind" class="headerlink" title="安装libunwind"></a>安装libunwind</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/libunwind/libunwind/archive/v0.99.tar.gz</span><br><span class="line">tar -xvf v0.99.tar.gz</span><br><span class="line"><span class="built_in">cd</span> libunwind-0.99</span><br><span class="line">autoreconf --force -v --install</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h2 id="安装perftools"><a href="#安装perftools" class="headerlink" title="安装perftools"></a>安装perftools</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/gperftools/gperftools/releases/download/gperftools-2.6.1/gperftools-2.6.1.tar.gz</span><br><span class="line">tar -xvf gperftools-2.6.1.tar.gz </span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<h2 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h2><p><img src="e25c28feccf7bac3e0f524dec94e4a1f7f2d5db678b0fd3366351056d111b03a.png" alt="图 27">  </p>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>pprof</tag>
      </tags>
  </entry>
  <entry>
    <title>base64编解码</title>
    <url>/2022/11/16/base64%E7%BC%96%E8%A7%A3%E7%A0%81/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，是一种基于<strong>64个可打印字符</strong>来表示二进制数据的方法</p>
<span id="more"></span>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ol>
<li>Base64一般用于在 HTTP协议下传输二进制数据，由于 HTTP协议是文本协议，所以在HTTP协议下传输二进制数据需要将二进制数据转换为字符数据。然而直接转换是不行的。因为网络传输只能传输可打印字符，需要用Base64将不可显字符转换为可显字符</li>
<li>可用于将明文通过AES加密后，通过Base64将不可显的加密字符转换为可显字符</li>
</ol>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>base64编码表<br><img src="c617678b70d6a249a3556d4a16a4d49fbd9dc22f4be59bda0d0e52450c20be76.png" alt="图 2"> </p>
<p>由于base64编码是将编码前的3*8位数据，分解成4个6位的数据，所以经过base64编码后的字符串长度是4的倍数。<br>但往往我们进行编码的数据长度并不是3的倍数，这就造成了“编码”后的位数不为4的倍数，</p>
<p>比如Brisk共5×8=40位，以6位为一组可以分为7组，这样“编码”后就有7个字符，<br>但base64编码后的字符长度应该是4的倍数，显然这里就出问题了，那么怎么办呢？<br>前面的不可以抛弃掉，所以就只有“追加”了，所以Brisk经过base64编码后的长度应该是8个字符，而第8个编码后的字符是’=’，</p>
<p>再比如对单个字符a进行base64编码，由于它的长度不是3的倍数，以3个字节为一组它只能分一组，再以6位为一位它只能分两组，所以经过“编码”后它的长度是2，但base64编码后的个数应该是4的倍数，所以它的长度应该是4，所以在后面补上两个‘=’,</p>
<p>由于一个数求余3后有三个不同的结果，0、1、2，所以在对一个数据进行base64进行编码后它的长度为： </p>
<ol>
<li><p>当进行编码的数据长度是3的倍数时，len=strlen(str_in)/3*4;</p>
</li>
<li><p>当进行编码的数据长度不是3的倍数时，len=(strlen(str_in)/3+1)*4;</p>
</li>
</ol>
<p>我们以Brisk这个例子来说明一下base64编码的过程。首先我们以3个字符为一组将Brisk进行分组，Brisk被氛围两组：Bri 和 sk；然后我们取出这两个分组中每个字节的ASCII码，B:66 r:114 i:105 s:115 k:107。它们对应的二进制数为  B:01000010 r:01110010 i:01101001 s:01110011 k:01101011；</p>
<p>第一组，我们以6位为一组对每一个3字节分组进行再分组就变成了010000 100111 001001 101001。所对应的十进制数是16 39 9 41，对应base64表中的结果是 Q n J p；</p>
<p>第二组，011100 110110 101100(不够补0)，所以对应的十进制数是 28 54 44，对应base64表中的结果是 c 2 s，最终结果为QnJpc2s=（因为第二组“编码”后只有三个字节）。</p>
<p>解码的过程是一个逆过程，我们将经过编码后的字符按4个字符为一组，然后对照base64表得到相应的十进制数，再将其通过拆分和组合，组成3个8位数据，这个数据就是解码后的数据，下面给一个c语言实现编码和解码的代码。</p>
<h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">encode_string</span><span class="params">(</span></span><br><span class="line"><span class="params">				<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> * src, <span class="type">int</span> len,</span></span><br><span class="line"><span class="params">				<span class="type">unsigned</span> <span class="type">char</span> * dest, <span class="type">unsigned</span> <span class="type">char</span> * base64, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> one;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> two;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> thr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> fou;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ( len &gt;= <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        one = src[<span class="number">0</span>] &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        two = ( ( src[<span class="number">0</span>] &amp; <span class="number">0x03</span> ) &lt;&lt; <span class="number">4</span> ) | ( src[<span class="number">1</span>] &gt;&gt; <span class="number">4</span> );</span><br><span class="line">        thr = ( ( src[<span class="number">1</span>] &amp; <span class="number">0x0F</span> ) &lt;&lt; <span class="number">2</span> ) | ( src[<span class="number">2</span>] &gt;&gt; <span class="number">6</span> );</span><br><span class="line">        fou = src[<span class="number">2</span>] &amp; <span class="number">0x3F</span>;</span><br><span class="line"> </span><br><span class="line">        *( dest + index++ ) = base64[one];</span><br><span class="line">        *( dest + index++ ) = base64[two];</span><br><span class="line">        *( dest + index++ ) = base64[thr];</span><br><span class="line">        *( dest + index   ) = base64[fou];</span><br><span class="line">		<span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> ( len == <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        one = src[<span class="number">0</span>] &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        two = ( ( src[<span class="number">0</span>] &amp; <span class="number">0x03</span>) &lt;&lt; <span class="number">4</span> ) | ( src[<span class="number">1</span>] &gt;&gt; <span class="number">4</span> );</span><br><span class="line">        thr = ( src[<span class="number">1</span>] &amp; <span class="number">0x0F</span> ) &lt;&lt; <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">        *( dest + index++ ) = base64[one];</span><br><span class="line">        *( dest + index++ ) = base64[two];</span><br><span class="line">        *( dest + index++ ) = base64[thr];</span><br><span class="line">        *( dest + index   ) = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( len == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        one = src[<span class="number">0</span>] &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        two = ( src[<span class="number">0</span>] &amp; <span class="number">0x03</span> ) &lt;&lt; <span class="number">4</span>;</span><br><span class="line"> </span><br><span class="line">        *( dest + index++ ) = base64[one];</span><br><span class="line">        *( dest + index++ ) = base64[two];</span><br><span class="line">        *( dest + index++ ) = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">        *( dest + index   ) = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;Unknow length\n&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">base64_encode</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> * src, <span class="type">int</span> src_len, <span class="type">char</span> * dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> base64[] = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">while</span>( src_len &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> step = encode_string( src, src_len, (<span class="type">unsigned</span> <span class="type">char</span> *)dest, base64, index );</span><br><span class="line"> </span><br><span class="line">        index += <span class="number">4</span>;</span><br><span class="line">        src += step;</span><br><span class="line">		src_len -= step;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    *( dest + index ) = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">create_array</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> * <span class="built_in">array</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( index  = <span class="number">0</span>; index &lt; <span class="number">123</span>; index += <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( index == <span class="number">0x2B</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            *( <span class="built_in">array</span> + index ) = <span class="number">0x3E</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( index == <span class="number">0x2F</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            *( <span class="built_in">array</span> + index ) = <span class="number">0x3F</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( index &gt;= <span class="number">0x30</span> &amp;&amp; index &lt;= <span class="number">0x39</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            *( <span class="built_in">array</span> + index ) = <span class="number">0x34</span> + index - <span class="number">0x30</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( index == <span class="number">0x3D</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            *( <span class="built_in">array</span> + index ) = <span class="number">0x00</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( index &gt;= <span class="number">0x41</span> &amp;&amp; index &lt;= <span class="number">0x5A</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            *( <span class="built_in">array</span> + index ) = index - <span class="number">0x41</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( index &gt;= <span class="number">0x61</span> &amp;&amp; index &lt;= <span class="number">0x7A</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            *( <span class="built_in">array</span> + index ) = <span class="number">0x1A</span> + index - <span class="number">0x61</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            *( <span class="built_in">array</span> + index ) = <span class="number">0x00</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    *( <span class="built_in">array</span> + <span class="number">123</span> ) = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">decode_string</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * src, <span class="type">unsigned</span> <span class="type">char</span> * dest, <span class="type">unsigned</span> <span class="type">char</span> * <span class="built_in">array</span>, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> step;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> one;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> two;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> thr;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> ( src[<span class="number">3</span>] == <span class="string">&#x27;=&#x27;</span> &amp;&amp; src[<span class="number">2</span>] == <span class="string">&#x27;=&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        one = ( <span class="built_in">array</span>[src[<span class="number">0</span>]] &lt;&lt; <span class="number">2</span> ) | ( <span class="built_in">array</span>[src[<span class="number">1</span>]] &gt;&gt; <span class="number">4</span> );</span><br><span class="line">        *( dest + index ) = one;</span><br><span class="line"> </span><br><span class="line">        step = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( src[<span class="number">3</span>] == <span class="string">&#x27;=&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        one = ( <span class="built_in">array</span>[src[<span class="number">0</span>]] &lt;&lt; <span class="number">2</span> ) | ( <span class="built_in">array</span>[src[<span class="number">1</span>]] &gt;&gt; <span class="number">4</span> );</span><br><span class="line">        two = ( ( <span class="built_in">array</span>[src[<span class="number">1</span>]] &amp; <span class="number">0x0F</span> ) &lt;&lt; <span class="number">4</span> ) | ( <span class="built_in">array</span>[src[<span class="number">2</span>]] &gt;&gt; <span class="number">2</span> );</span><br><span class="line"> </span><br><span class="line">        *( dest + index++ ) = one;</span><br><span class="line">        *( dest + index   ) = two;</span><br><span class="line"> </span><br><span class="line">        step = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        one = ( <span class="built_in">array</span>[src[<span class="number">0</span>]] &lt;&lt; <span class="number">2</span> ) | ( <span class="built_in">array</span>[src[<span class="number">1</span>]] &gt;&gt; <span class="number">4</span> );</span><br><span class="line">        two = ( ( <span class="built_in">array</span>[src[<span class="number">1</span>]] &amp; <span class="number">0x0F</span> ) &lt;&lt; <span class="number">4</span> ) | ( <span class="built_in">array</span>[src[<span class="number">2</span>]] &gt;&gt; <span class="number">2</span> );</span><br><span class="line">        thr = ( <span class="built_in">array</span>[src[<span class="number">2</span>]] &lt;&lt; <span class="number">6</span> ) | <span class="built_in">array</span>[src[<span class="number">3</span>]];</span><br><span class="line"> </span><br><span class="line">        *( dest + index++ ) = one;</span><br><span class="line">        *( dest + index++ ) = two;</span><br><span class="line">        *( dest + index   ) = thr;</span><br><span class="line"> </span><br><span class="line">        step = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">base64_decode</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * src, <span class="type">unsigned</span> <span class="type">char</span> * dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> <span class="built_in">array</span>[<span class="number">124</span>];</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">memset</span>( <span class="built_in">array</span>, <span class="number">0x00</span>, <span class="number">124</span> );</span><br><span class="line">    create_array( <span class="built_in">array</span> );</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> ( *src )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> step = decode_string( src, dest, <span class="built_in">array</span>, index );</span><br><span class="line"> </span><br><span class="line">        index += step;</span><br><span class="line">        src   += <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    *( dest + index ) = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>测试代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *src_str = <span class="string">&quot;abcsjdhs123134&quot;</span>;</span><br><span class="line">	<span class="type">int</span> src_str_len = <span class="built_in">strlen</span>(src_str);</span><br><span class="line">	<span class="type">char</span> *out_buf = (<span class="type">char</span> *)<span class="built_in">malloc</span>(src_str_len * <span class="number">2</span>);</span><br><span class="line">	<span class="type">char</span> *out_decode_buf = (<span class="type">char</span> *)<span class="built_in">malloc</span>(src_str_len * <span class="number">2</span>);</span><br><span class="line">	base64_encode(src_str, src_str_len, out_buf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;src_str:       %s\n&quot;</span>, src_str);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;base64_encode: %s\n&quot;</span>, out_buf);</span><br><span class="line"></span><br><span class="line">	base64_decode(out_buf, out_decode_buf);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;base64_decode: %s\n&quot;</span>, out_decode_buf);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果展示<br><img src="8106a76ff5b18e8cda5e478736125efeec53fcaf86e1744cf4fe4accaaf6a38b.png" alt="图 3">  </p>
]]></content>
      <categories>
        <category>BASE64</category>
      </categories>
      <tags>
        <tag>BASE64</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenSSL之AES用法</title>
    <url>/2022/11/16/OpenSSL%E4%B9%8BAES%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>AES是<strong>对称</strong>加密的算法，使用128、192 和 256 位密钥，将被加密数据划分为128位（16字节）一块，然后使用某种加密模式进行加密</p>
<p>关键词：<br><strong>块大小</strong>：16字节<br><strong>密钥长度</strong>：AES算法下，key的长度有三种：128、192和256 bits。</p>
<span id="more"></span>
<p><strong>加密模式</strong>：AES属于块加密（Block Cipher），块加密中有CBC、ECB、CTR、OFB、CFB等几种工作模式。<br><strong>填充模式</strong>：</p>
<ul>
<li>NoPadding，数据长度不对齐时使用”\0”填充，否则不填充</li>
<li>PKCS7Padding，假设数据长度需要填充n(n&gt;0)个字节才对齐，那么填充n个字节，每个字节都是n;如果数据本身就已经对齐了，则填充一块长度为块大小的数据，每个字节都是块大小</li>
<li>PKCS5Padding，PKCS7Padding的子集，块大小固定为8字节。</li>
</ul>
<p>AES加密，如果输入是16<em>n字节，NoPadding填充的情况下，输出和输入相同；有填充的情况下，输出是16</em>（n+1）。<br>如果输入不是16字节整数倍，而是大于16<em>n小于16</em>（n+1），NoPadding填充情况下（只能是CFB和OFB模式），输出和输入长度相同；其他情况下，输出长度是16*（n+1）</p>
<h2 id="设置加解密接口"><a href="#设置加解密接口" class="headerlink" title="设置加解密接口"></a>设置加解密接口</h2><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><ul>
<li><p>函数原型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">AES_set_encrypt_key</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *userKey, <span class="type">const</span> <span class="type">int</span> bits,</span></span><br><span class="line"><span class="params">                        AES_KEY *key)</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>函数作用<br>设定加密用的Key</p>
</li>
<li><p>参数说明<br><code>userKey</code>： 密钥数值；<br><code>bits</code>：密钥长度，以bit为单位，如果密钥数字是16个字节，则此参数值应为128；<br><code>key</code>： AES_KEY对象指针；<br><code>返回值</code>：<br>0: 成功<br>1: userkey，key为空<br>2: 密钥长度不是128，192，256</p>
</li>
</ul>
<h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><ul>
<li><p>函数原型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">AES_set_decrypt_key</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *userKey, <span class="type">const</span> <span class="type">int</span> bits,</span></span><br><span class="line"><span class="params">                        AES_KEY *key)</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>函数作用<br>设定解密用的Key</p>
</li>
<li><p>参数说明<br><code>userKey</code>： 密钥数值；<br><code>bits</code>：密钥长度，以bit为单位，如果密钥数字是16个字节，则此参数值应为128；<br><code>key</code>： AES_KEY对象指针；<br><code>返回值</code>：<br>0: 成功<br>1: userkey，key为空<br>2: 密钥长度不是128，192，256</p>
</li>
</ul>
<h2 id="常用加密模式"><a href="#常用加密模式" class="headerlink" title="常用加密模式"></a>常用加密模式</h2><h3 id="CBC"><a href="#CBC" class="headerlink" title="CBC"></a>CBC</h3><ul>
<li><p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AES_cbc_encrypt</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *in, <span class="type">unsigned</span> <span class="type">char</span> *out,</span></span><br><span class="line"><span class="params">                     <span class="type">size_t</span> length, <span class="type">const</span> AES_KEY *key,</span></span><br><span class="line"><span class="params">                     <span class="type">unsigned</span> <span class="type">char</span> *ivec, <span class="type">const</span> <span class="type">int</span> enc)</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>函数作用：<br>AES加密/解密单个数据块（16个字节），CBC模式</p>
</li>
<li><p>参数说明：<br><code>in</code>： 需要加密/解密的数据；<br><code>out</code>： 计算后输出的数据；<br><code>length</code>： 数据长度（这里不包含初始向量数据长度）<br><code>key</code>：密钥<br><code>ivec</code>： 初始向量（一般为16字节全0）<br><code>enc</code>：<br>AES_ENCRYPT：代表加密<br>AES_DECRYPT：代表解密</p>
</li>
</ul>
<h3 id="ECB"><a href="#ECB" class="headerlink" title="ECB"></a>ECB</h3><ul>
<li><p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AES_ecb_encrypt</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *in, <span class="type">unsigned</span> <span class="type">char</span> *out,</span></span><br><span class="line"><span class="params">                     <span class="type">const</span> AES_KEY *key, <span class="type">const</span> <span class="type">int</span> enc)</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>函数作用：<br>AES加密/解密单个数据块（16个字节），ECB模式</p>
</li>
<li><p>参数说明：<br><code>in</code>: 需要加密/解密的数据；<br><code>out</code>: 计算后输出的数据；<br><code>key</code>: 密钥<br><code>enc</code>:<br>AES_ENCRYPT：代表加密<br>AES_DECRYPT：代表解密</p>
</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>测试代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TEST_ORG_DATA <span class="string">&quot;this is test aes data!&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">remove_padding</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buff, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">	ch = buff[size - <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; ch; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (buff[size - i] != buff[size - (i + <span class="number">1</span>)])</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	buff[size - i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">str2hex</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *ret = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> str_len = <span class="built_in">strlen</span>(str);</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> sret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	ret = (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="built_in">malloc</span>(str_len / <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; str_len; i += <span class="number">2</span>)</span><br><span class="line">		sret = <span class="built_in">sscanf</span>(str + i, <span class="string">&quot;%2hhX&quot;</span>, &amp;ret[i/<span class="number">2</span>]);</span><br><span class="line">	<span class="keyword">if</span> (sret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">free</span>(ret);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">decode_aes128_ecb</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *encrypt_buff, <span class="type">int</span> buf_len, <span class="type">unsigned</span> <span class="type">char</span> **out)</span></span><br><span class="line">&#123;</span><br><span class="line">	AES_KEY aes;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *decrypt_buff = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *key = str2hex(<span class="string">&quot;B1CFC3D787DC4511&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(&amp;aes, <span class="number">0</span>, <span class="keyword">sizeof</span>(aes));</span><br><span class="line">	decrypt_buff = (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="built_in">malloc</span>((<span class="type">size_t</span>)buf_len);</span><br><span class="line"></span><br><span class="line">	AES_set_decrypt_key(key, <span class="number">128</span>, &amp;aes);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; buf_len; i += AES_BLOCK_SIZE) &#123;</span><br><span class="line">		AES_ecb_encrypt</span><br><span class="line">			(encrypt_buff + i, decrypt_buff + i, &amp;aes, AES_DECRYPT);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	remove_padding(decrypt_buff, buf_len);</span><br><span class="line"></span><br><span class="line">	*out = decrypt_buff;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">encode_aes128_ecb</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> **out, <span class="type">int</span> *out_len)</span></span><br><span class="line">&#123;</span><br><span class="line">	AES_KEY aes;</span><br><span class="line">	<span class="type">int</span> data_len = <span class="built_in">strlen</span>(TEST_ORG_DATA);</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="type">json_error_t</span> error;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *encrypt_buff = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *decrypt_buff = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *key = str2hex(<span class="string">&quot;B1CFC3D787DC4511&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> pad_len = AES_BLOCK_SIZE - (data_len % AES_BLOCK_SIZE);</span><br><span class="line">	encrypt_buff = (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="built_in">malloc</span>(data_len + pad_len);</span><br><span class="line">	decrypt_buff = (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="built_in">malloc</span>(data_len + pad_len);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memcpy</span>(decrypt_buff, TEST_ORG_DATA, data_len);</span><br><span class="line">	<span class="built_in">memset</span>(decrypt_buff+data_len, pad_len, pad_len);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(&amp;aes, <span class="number">0</span>, <span class="keyword">sizeof</span>(aes));</span><br><span class="line">	AES_set_encrypt_key(key, <span class="number">128</span>, &amp;aes);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; data_len+pad_len; i += AES_BLOCK_SIZE) &#123;</span><br><span class="line">		AES_ecb_encrypt</span><br><span class="line">			(decrypt_buff + i, encrypt_buff + i, &amp;aes, AES_ENCRYPT);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*out = encrypt_buff;</span><br><span class="line">	*out_len = data_len+pad_len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;data before aes :\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, TEST_ORG_DATA);</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *en_code = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="type">int</span> en_code_len;</span><br><span class="line">	encode_aes128_ecb(&amp;en_code, &amp;en_code_len);</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> *de_code = <span class="literal">NULL</span>;</span><br><span class="line">	decode_aes128_ecb(en_code, en_code_len, &amp;de_code);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;data after aes encode and decode :\n&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, de_code);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试结果：<br><img src="4f8473f4df84e1e65d147bd49af24b1cf87b702462969287d002e093c7cfd2e1.png" alt="图 2">  </p>
]]></content>
      <categories>
        <category>OPENSSL</category>
      </categories>
      <tags>
        <tag>AES</tag>
        <tag>OPENSSL</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode C/C++插件失效</title>
    <url>/2022/03/08/vscode-C-C-%E6%89%A9%E5%B1%95%E5%A4%B1%E6%95%88/</url>
    <content><![CDATA[<h2 id="故障描述"><a href="#故障描述" class="headerlink" title="故障描述"></a>故障描述</h2><ul>
<li><p>打开项目工程后，过一段时间发现c/c++跳转失效</p>
</li>
<li><p>智能感知系统无法补全</p>
<span id="more"></span>
<p><img src="519c09334a7130005ac97e63cdabaf9c19ba78d30a0f27ca94b9996163e6c766.png" alt="图 2">  </p>
</li>
<li><p>并且，大纲无法加载符号<br><img src="da3040ce2169ddc0a1346799e3e1facd423444da76f7dbea51e27ca9dfbbe7bf.png" alt="图 3">  </p>
</li>
</ul>
<h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><ol>
<li>网上搜索常见的C/C++插件失效的解决办法，发现都与设置的无关</li>
<li>终端发现cpptools的cpu利用率飙高，此时可初步判定为项目工程导致符号搜索循环引用了<br><img src="ff1e27ff7a065a725a164291088616be25e5896c385e74c612d9752da83b90a7.png" alt="图 4">  </li>
<li>排查发现项目中的一个文件目录比较大，将其删除后，发现C/C++插件可以继续运作，并且cpptools不会再cpu冲高<br><img src="6ed60181060f1615ed24a7ae6effdcb19a2e4f33cb2d7a9bf19dd88d309d17b6.png" alt="图 9">  </li>
</ol>
<h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><ul>
<li>由于编译依赖该文件目录，删除后会影响编译效率；</li>
<li>通过设置exclude将C/C++插件不再搜索该文件目录，修改如下：</li>
<li>文件-》首选项-》设置，搜索exclude，找到C_Cpp.files.exclude<br><img src="7d723ba1046f38ce1447de4b059ac2e65085ee66c1b440dd4d0984b9c1a4109c.png" alt="图 6">  </li>
<li>添加文件目录名至exclude配置中<br><img src="fb11eed86c18bcb5fe46c797e0e15411e3ee5c6adbb4a6e9cd41565a26218c7d.png" alt="图 8">  </li>
<li>重新加载vscode后，该C/C++插件失效问题得以解决</li>
</ul>
]]></content>
      <categories>
        <category>VSCODE</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>omitempty关键字</title>
    <url>/2021/05/10/omitempty%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>结构体有标签名时, 标签名会作为key进行<code>json.Marshal</code>，<br>当结构体某个字段没有赋值时，<code>json.Marshal</code>无需序列化该字段，此时就要用到<code>omitempty</code>关键字</p>
</blockquote>
<span id="more"></span>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> address <span class="keyword">struct</span> &#123;</span><br><span class="line">	Street  <span class="type">string</span> <span class="string">`json:&quot;street&quot;`</span>  <span class="comment">// 街道</span></span><br><span class="line">	Ste     <span class="type">string</span> <span class="string">`json:&quot;suite&quot;`</span>   <span class="comment">// 单元（可以不存在）</span></span><br><span class="line">	City    <span class="type">string</span> <span class="string">`json:&quot;city&quot;`</span>    <span class="comment">// 城市</span></span><br><span class="line">	State   <span class="type">string</span> <span class="string">`json:&quot;state&quot;`</span>   <span class="comment">// 州/省</span></span><br><span class="line">	Zipcode <span class="type">string</span> <span class="string">`json:&quot;zipcode&quot;`</span> <span class="comment">// 邮编</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	data := <span class="string">`&#123;</span></span><br><span class="line"><span class="string">		  &quot;street&quot;: &quot;200 Larkin St&quot;,</span></span><br><span class="line"><span class="string">		  &quot;city&quot;: &quot;San Francisco&quot;,</span></span><br><span class="line"><span class="string">		  &quot;state&quot;: &quot;CA&quot;,</span></span><br><span class="line"><span class="string">		  &quot;zipcode&quot;: &quot;94102&quot;</span></span><br><span class="line"><span class="string">	  &#125;`</span></span><br><span class="line">	addr := <span class="built_in">new</span>(address)</span><br><span class="line">	json.Unmarshal([]<span class="type">byte</span>(data), &amp;addr)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理了一番 addr 变量...</span></span><br><span class="line"></span><br><span class="line">	addressBytes, _ := json.MarshalIndent(addr, <span class="string">&quot;&quot;</span>, <span class="string">&quot;    &quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, <span class="type">string</span>(addressBytes))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到运行结果如下：<br><img src="4cd9ff01cf4568afd7712d2d5d2023d88c4746fa0ebcb6d3dd41a6be20744048.png" alt="图 1">  </p>
<p>多了一行 “suite”: “”, ，而这则信息在原本的 json 数据中是没有的，此时再序列化有点浪费字节空间了</p>
<p>可以将结构体定义为:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> address <span class="keyword">struct</span> &#123;</span><br><span class="line">	Street  <span class="type">string</span> <span class="string">`json:&quot;street&quot;`</span></span><br><span class="line">	Ste     <span class="type">string</span> <span class="string">`json:&quot;suite,omitempty&quot;`</span></span><br><span class="line">	City    <span class="type">string</span> <span class="string">`json:&quot;city&quot;`</span></span><br><span class="line">	State   <span class="type">string</span> <span class="string">`json:&quot;state&quot;`</span></span><br><span class="line">	Zipcode <span class="type">string</span> <span class="string">`json:&quot;zipcode&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到预期结果：<br><img src="ef7e859c46b3844078ad6c9800293e6b95a28ffabaa6f20fd9dfa09694841688.png" alt="图 2">  </p>
<h2 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h2><p>带来方便的同时，使用 omitempty 也有些小陷阱，一个是该关键字无法忽略掉嵌套结构体。还是拿地址类型说事，这回我们想要往地址结构体中加一个新 field 来表示经纬度，如果缺乏相关的数据，暂时可以忽略。新的结构体定义如下所示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> address <span class="keyword">struct</span> &#123;</span><br><span class="line">	Street     <span class="type">string</span>     <span class="string">`json:&quot;street&quot;`</span></span><br><span class="line">	Ste        <span class="type">string</span>     <span class="string">`json:&quot;suite,omitempty&quot;`</span></span><br><span class="line">	City       <span class="type">string</span>     <span class="string">`json:&quot;city&quot;`</span></span><br><span class="line">	State      <span class="type">string</span>     <span class="string">`json:&quot;state&quot;`</span></span><br><span class="line">	Zipcode    <span class="type">string</span>     <span class="string">`json:&quot;zipcode&quot;`</span></span><br><span class="line">	Coordinate coordinate <span class="string">`json:&quot;coordinate,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"> 你们BNBH美好关于jbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb</span><br><span class="line"><span class="keyword">type</span> coordinate <span class="keyword">struct</span> &#123;</span><br><span class="line">	Lat <span class="type">float64</span> <span class="string">`json:&quot;latitude&quot;`</span></span><br><span class="line">	Lng <span class="type">float64</span> <span class="string">`json:&quot;longitude&quot;`</span></span><br><span class="line">&#125;bhnmjvjhgmbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb</span><br></pre></td></tr></table></figure>
<p>读入原来的地址数据，处理后序列化输出，我们就会发现即使加上了 omitempty 关键字，输出的 json 还是带上了一个空的坐标信息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;street&quot;</span>: <span class="string">&quot;200 Larkin St&quot;</span>,</span><br><span class="line">    <span class="string">&quot;city&quot;</span>: <span class="string">&quot;San Francisco&quot;</span>,</span><br><span class="line">    <span class="string">&quot;state&quot;</span>: <span class="string">&quot;CA&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zipcode&quot;</span>: <span class="string">&quot;94102&quot;</span>,</span><br><span class="line">    <span class="string">&quot;coordinate&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;latitude&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&quot;longitude&quot;</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了达到我们想要的效果，可以把坐标定义为指针类型，这样 Golang 就能知道一个指针的“空值”是多少了，否则面对一个我们自定义的结构， Golang 是猜不出我们想要的空值的。于是有了如下的结构体定义</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> address <span class="keyword">struct</span> &#123;</span><br><span class="line">	Street     <span class="type">string</span>      <span class="string">`json:&quot;street&quot;`</span></span><br><span class="line">	Ste        <span class="type">string</span>      <span class="string">`json:&quot;suite,omitempty&quot;`</span></span><br><span class="line">	City       <span class="type">string</span>      <span class="string">`json:&quot;city&quot;`</span></span><br><span class="line">	State      <span class="type">string</span>      <span class="string">`json:&quot;state&quot;`</span></span><br><span class="line">	Zipcode    <span class="type">string</span>      <span class="string">`json:&quot;zipcode&quot;`</span></span><br><span class="line">	Coordinate *coordinate <span class="string">`json:&quot;coordinate,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> coordinate <span class="keyword">struct</span> &#123;</span><br><span class="line">	Lat <span class="type">float64</span> <span class="string">`json:&quot;latitude&quot;`</span></span><br><span class="line">	Lng <span class="type">float64</span> <span class="string">`json:&quot;longitude&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相应的输出为</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;street&quot;</span>: <span class="string">&quot;200 Larkin St&quot;</span>,</span><br><span class="line">    <span class="string">&quot;city&quot;</span>: <span class="string">&quot;San Francisco&quot;</span>,</span><br><span class="line">    <span class="string">&quot;state&quot;</span>: <span class="string">&quot;CA&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zipcode&quot;</span>: <span class="string">&quot;94102&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个“陷阱”是，对于用 omitempty 定义的 field ，如果给它赋的值恰好等于默认空值的话，在转为 json 之后也不会输出这个 field 。比如说上面定义的经纬度坐标结构体，如果我们将经纬度两个 field 都加上 omitempty</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> coordinate <span class="keyword">struct</span> &#123;</span><br><span class="line">	Lat <span class="type">float64</span> <span class="string">`json:&quot;latitude,omitempty&quot;`</span></span><br><span class="line">	Lng <span class="type">float64</span> <span class="string">`json:&quot;longitude,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们对非洲几内亚湾的“原点坐标”非常感兴趣，于是编写了如下代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cData := <span class="string">`&#123;</span></span><br><span class="line"><span class="string">		&quot;latitude&quot;: 0.0,</span></span><br><span class="line"><span class="string">		&quot;longitude&quot;: 0.0</span></span><br><span class="line"><span class="string">	&#125;`</span></span><br><span class="line">	c := <span class="built_in">new</span>(coordinate)</span><br><span class="line">	json.Unmarshal([]<span class="type">byte</span>(cData), &amp;c)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 具体处理逻辑...</span></span><br><span class="line"></span><br><span class="line">	coordinateBytes, _ := json.MarshalIndent(c, <span class="string">&quot;&quot;</span>, <span class="string">&quot;    &quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, <span class="type">string</span>(coordinateBytes))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终我们得到了一个<br><code>&#123;&#125;</code></p>
<p>这个坐标消失不见了！但我们的设想是，如果一个地点没有经纬度信息，则悬空，这没有问题，但对于“原点坐标”，我们在确切知道它的经纬度的情况下，（0.0, 0.0）仍然被忽略了。正确的写法也是将结构体内的定义改为指针</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> coordinate <span class="keyword">struct</span> &#123;</span><br><span class="line">	Lat *<span class="type">float64</span> <span class="string">`json:&quot;latitude,omitempty&quot;`</span></span><br><span class="line">	Lng *<span class="type">float64</span> <span class="string">`json:&quot;longitude,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样空值就从 float64 的 0.0 变为了指针类型的 nil ，我们就能看到正确的经纬度输出。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;latitude&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&quot;longitude&quot;</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>json包使用</title>
    <url>/2021/05/09/json%E5%8C%85%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>使用 <code>json.Unmarshal</code> 和 <code>json.Marshal</code> 函数，可以将 JSON 格式的二进制数据反序列化到指定的 Go 结构体中，以及将 Go 结构体序列化为二进制流。</p>
</blockquote>
<span id="more"></span>

<h2 id="Map转JSON"><a href="#Map转JSON" class="headerlink" title="Map转JSON"></a>Map转JSON</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="comment">// map里面</span></span><br><span class="line">	map1 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span> &#123;</span><br><span class="line">		<span class="string">&quot;name&quot;</span>:<span class="string">&quot;张三&quot;</span>,</span><br><span class="line">		<span class="string">&quot;age&quot;</span>:<span class="string">&quot;18&quot;</span>,</span><br><span class="line">		<span class="string">&quot;home&quot;</span>:<span class="string">&quot;北京&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 将map解析成json</span></span><br><span class="line">	json1, err := json.Marshal(map1)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;json1: %s  类型: %T \n&quot;</span>,json1,json1)</span><br><span class="line">  </span><br><span class="line">	map2 := <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span> &#123;</span><br><span class="line">		<span class="string">&quot;fruit&quot;</span>: &#123;<span class="string">&quot;香蕉&quot;</span>,<span class="string">&quot;葡萄&quot;</span>&#125;,</span><br><span class="line">		<span class="string">&quot;coder&quot;</span>:&#123;<span class="string">&quot;PHP&quot;</span>,<span class="string">&quot;Go&quot;</span>,<span class="string">&quot;Java&quot;</span>&#125;,</span><br><span class="line">		<span class="string">&quot;likes&quot;</span>:&#123;<span class="string">&quot;打游戏&quot;</span>,<span class="string">&quot;看动漫&quot;</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	json2, err := json.Marshal(map2)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;json2: %s  类型: %T \n&quot;</span>,json2,json2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">json1: &#123;&quot;age&quot;:&quot;18&quot;,&quot;home&quot;:&quot;北京&quot;,&quot;name&quot;:&quot;张三&quot;&#125;  类型: []uint8 </span></span><br><span class="line"><span class="comment">json2: &#123;&quot;coder&quot;:[&quot;PHP&quot;,&quot;Go&quot;,&quot;Java&quot;],&quot;fruit&quot;:[&quot;香蕉&quot;,&quot;葡萄&quot;],&quot;likes&quot;:[&quot;打游戏&quot;,&quot;看动漫&quot;]&#125;  类型: []uint8 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="Json转Map"><a href="#Json转Map" class="headerlink" title="Json转Map"></a>Json转Map</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	json1 := <span class="string">`&#123;&quot;age&quot;:&quot;18&quot;,&quot;home&quot;:&quot;北京&quot;,&quot;name&quot;:&quot;张三&quot;&#125;`</span></span><br><span class="line">	map1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">	err := json.Unmarshal([]<span class="type">byte</span>(json1), &amp;map1)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;map1: %v T: %T\n&quot;</span>,map1,map1)</span><br><span class="line"></span><br><span class="line">	json2 := <span class="string">`&#123;&quot;coder&quot;:[&quot;PHP&quot;,&quot;Go&quot;,&quot;Java&quot;],&quot;fruit&quot;:[&quot;香蕉&quot;,&quot;葡萄&quot;],&quot;likes&quot;:[&quot;打游戏&quot;,&quot;看动漫&quot;]&#125;`</span></span><br><span class="line">	map2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>)</span><br><span class="line">	err = json.Unmarshal([]<span class="type">byte</span>(json2), &amp;map2)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;map2: %v T: %T\n&quot;</span>,map2,map2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">map1: map[age:18 home:北京 name:张三] T: map[string]string</span></span><br><span class="line"><span class="comment">map2: map[coder:[PHP Go Java] fruit:[香蕉 葡萄] likes:[打游戏 看动漫]] T: map[string][]string</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="结构体转JSON"><a href="#结构体转JSON" class="headerlink" title="结构体转JSON"></a>结构体转JSON</h2><p><strong>无字段标签</strong><br>结构体转换成JSON在开发中经常会用到。encoding/json包是通过反射机制来实现编解码的，因此结构体必须导出所转换的字段，没有导出的字段不会被encoding/json包解析。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name <span class="type">string</span></span><br><span class="line">	Age <span class="type">int</span></span><br><span class="line">	Class <span class="type">string</span></span><br><span class="line">	phone <span class="type">string</span> <span class="comment">//小写字段，则不是会导出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	s := Student&#123;</span><br><span class="line">		Name:  <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">		Age:   <span class="number">17</span>,</span><br><span class="line">		Class: <span class="string">&quot;三年级&quot;</span>,</span><br><span class="line">		phone: <span class="string">&quot;17600112222&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	json1, err := json.Marshal(s)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;json: %s \n&quot;</span>,json1)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 json: &#123;&quot;Name&quot;:&quot;张三&quot;,&quot;Age&quot;:17,&quot;Class&quot;:&quot;三年级&quot;&#125; </span></span><br></pre></td></tr></table></figure>

<p><strong>有字段标签</strong><br>json包在解析结构体时，如果遇到key为JSON的字段标签，则会按照一定规则解析该标签。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 定义一个学生结构体</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name  <span class="type">string</span> <span class="string">`json:&quot;_name&quot;`</span> <span class="comment">// 字段标签的语法</span></span><br><span class="line">	Age   <span class="type">int</span>    <span class="string">`json:&quot;_age&quot;`</span></span><br><span class="line">	Class <span class="type">string</span> <span class="string">`json:&quot;-&quot;`</span> <span class="comment">// 不解析</span></span><br><span class="line">	Phone <span class="type">string</span> <span class="string">`json:&quot;phone&quot;`</span></span><br><span class="line">	Score <span class="type">float32</span> <span class="comment">// 没有标签时，则用字段名</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	s := Student&#123;</span><br><span class="line">		Name:  <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">		Age:   <span class="number">17</span>,</span><br><span class="line">		Class: <span class="string">&quot;三年级&quot;</span>,</span><br><span class="line">		Phone: <span class="string">&quot;17600112222&quot;</span>,</span><br><span class="line">		Score: <span class="number">88.5</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	json1, err := json.Marshal(s)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;json: %s \n&quot;</span>,json1)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出-&gt; json: &#123;&quot;_name&quot;:&quot;张三&quot;,&quot;_age&quot;:17,&quot;phone&quot;:&quot;17600112222&quot;,&quot;Score&quot;:88.5&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>规则总结</strong></p>
<ul>
<li>有标签名时,标签名会作为key</li>
<li>没有标签时,则会使用字段名。</li>
<li>有标签名时，但是标签名的值为-，则不会导出</li>
</ul>
<p><strong>匿名字段</strong><br>json包在解析匿名字段时，会将匿名字段的字段当成该结构体的字段处理。<br>而不会嵌套</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name  <span class="type">string</span> <span class="string">`json:&quot;_name&quot;`</span></span><br><span class="line">	Age   <span class="type">int</span>    <span class="string">`json:&quot;_age&quot;`</span></span><br><span class="line">    Top <span class="comment">// 匿名字段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Top <span class="keyword">struct</span> &#123;</span><br><span class="line">	Sort <span class="type">int</span> <span class="string">`json:&quot;sort&quot;`</span></span><br><span class="line">	Score <span class="type">float64</span></span><br><span class="line">	Class <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	s := Student&#123;</span><br><span class="line">		Name: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">		Age:  <span class="number">18</span>,</span><br><span class="line">		Top:  Top&#123;<span class="number">1</span>,<span class="number">99.5</span>,<span class="string">&quot;一年级&quot;</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	json1, err := json.Marshal(s)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;json: %s \n&quot;</span>,json1)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出-&gt; json: &#123;&quot;_name&quot;:&quot;张三&quot;,&quot;_age&quot;:18,&quot;sort&quot;:1,&quot;Score&quot;:99.5,&quot;Class&quot;:&quot;一年级&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="JSON转结构体"><a href="#JSON转结构体" class="headerlink" title="JSON转结构体"></a>JSON转结构体</h2><p>JSON可以转换成结构体。同编码一样，json包是通过反射机制来实现解码的，因此结构体必须导出所转换的字段，不导出的字段不会被json包解析。另外解析时不区分大小写。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">	Name  <span class="type">string</span> <span class="string">`json:&quot;_name&quot;`</span></span><br><span class="line">	Age   <span class="type">int</span>    <span class="string">`json:&quot;_age&quot;`</span></span><br><span class="line">    Top <span class="comment">// 匿名字段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Top <span class="keyword">struct</span> &#123;</span><br><span class="line">	Sort <span class="type">int</span> <span class="string">`json:&quot;sort&quot;`</span></span><br><span class="line">	Score <span class="type">float64</span></span><br><span class="line">	Class <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	student := Student&#123;&#125;</span><br><span class="line">	js := <span class="string">`&#123;&quot;_name&quot;:&quot;张三&quot;,&quot;_age&quot;:18,&quot;sort&quot;:1,&quot;Score&quot;:99.5,&quot;Class&quot;:&quot;一年级&quot;&#125;`</span></span><br><span class="line">	err := json.Unmarshal([]<span class="type">byte</span>(js), &amp;student)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;v: %+v  t: %T \n&quot;</span>,student,student)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出: v: &#123;Name:张三 Age:18 Top:&#123;Sort:1 Score:99.5 Class:一年级&#125;&#125;  t: main.Student</span></span><br></pre></td></tr></table></figure>

<h2 id="切片转JSON"><a href="#切片转JSON" class="headerlink" title="切片转JSON"></a>切片转JSON</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	student := []<span class="type">string</span> &#123;</span><br><span class="line">		<span class="string">&quot;张三&quot;</span>,</span><br><span class="line">		<span class="string">&quot;李四&quot;</span>,</span><br><span class="line">		<span class="string">&quot;小米&quot;</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	marshal, err := json.Marshal(student)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;v :%s T:%T&quot;</span>,marshal,marshal)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 v :[&quot;张三&quot;,&quot;李四&quot;,&quot;小米&quot;] T:[]uint8</span></span><br></pre></td></tr></table></figure>

<h2 id="JSON转切片"><a href="#JSON转切片" class="headerlink" title="JSON转切片"></a>JSON转切片</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	json1 := <span class="string">`[&quot;张三&quot;,&quot;李四&quot;,&quot;小米&quot;]`</span></span><br><span class="line">	<span class="keyword">var</span> sc []<span class="type">string</span></span><br><span class="line">	err := json.Unmarshal([]<span class="type">byte</span>(json1), &amp;sc)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;v :%v T:%T&quot;</span>,sc,sc)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出: v :[张三 李四 小米] T:[]string</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go文件操作</title>
    <url>/2021/05/08/go%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote>
<p>在Go语言中，文件操作的大多数函数都在os包里面，文件的信息包括文件名、文件大小、修改权限、修改时间等。</p>
</blockquote>
<span id="more"></span>

<h3 id="文件接口属性-FileInfo"><a href="#文件接口属性-FileInfo" class="headerlink" title="文件接口属性(FileInfo)"></a>文件接口属性(FileInfo)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> FileInfo <span class="keyword">interface</span> &#123;</span><br><span class="line"> Name() <span class="type">string</span>       <span class="comment">// 文件名</span></span><br><span class="line"> Size() <span class="type">int64</span>        <span class="comment">// 文件大小</span></span><br><span class="line"> Mode() FileMode     <span class="comment">// 修改权限</span></span><br><span class="line"> ModTime() time.Time <span class="comment">// 最后修改时间</span></span><br><span class="line"> IsDir() <span class="type">bool</span>        <span class="comment">// 判断是否是目录</span></span><br><span class="line"> Sys() <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// 文件的详细信息，获取的值是*syscall.Stat_t类型 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文件信息结构体-fileStat"><a href="#文件信息结构体-fileStat" class="headerlink" title="文件信息结构体(fileStat)"></a>文件信息结构体(fileStat)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> fileStat <span class="keyword">struct</span> &#123;</span><br><span class="line"> name    <span class="type">string</span></span><br><span class="line"> size    <span class="type">int64</span></span><br><span class="line"> mode    FileMode</span><br><span class="line"> modTime time.Time</span><br><span class="line"> sys     syscall.Stat_t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="fileStat结构体的常用方法汇总"><a href="#fileStat结构体的常用方法汇总" class="headerlink" title="fileStat结构体的常用方法汇总"></a>fileStat结构体的常用方法汇总</h3><table>
    <tr>
        <th>方法名</th><th>描述</th>
    </tr>
    <tr>
        <td>Name() string</td><td>返回文件名</td>
    </tr>
    <tr>
        <td>IsDir() bool</td><td>判断是否是目录</td>
    </tr>
    <tr>
        <td>Size() int64</td><td>返回文件大小</td>
    </tr>
    <tr>
        <td>Mode() FileMode</td><td>返回文件权限</td>
    </tr>
    <tr>
        <td>ModTime() time.Time</td><td>文件的最后修改时间</td>
    </tr>
    <tr>
        <td>Sys() interface{}</td><td>文件的详细信息，获取的值是*syscall.Stat_t类型</td>
    </tr>
</table>

<p><strong>使用示例</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fp := <span class="string">&quot;./test.txt&quot;</span></span><br><span class="line">	fileInfo, err := os.Stat(fp)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err.Error())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;类型: %T\n&quot;</span>, fileInfo)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;文件名: %v\n&quot;</span>, fileInfo.Name())</span><br><span class="line">	fmt.Printf(<span class="string">&quot;文件大小: %v\n&quot;</span>, fileInfo.Size())</span><br><span class="line">	fmt.Printf(<span class="string">&quot;是否为目录: %v\n&quot;</span>, fileInfo.IsDir())</span><br><span class="line">	fmt.Printf(<span class="string">&quot;文件权限: %v\n&quot;</span>, fileInfo.Mode())</span><br><span class="line">	fmt.Printf(<span class="string">&quot;文件最后修改的时间: %v\n&quot;</span>, fileInfo.ModTime())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><img src="f7ba8d9a73981205670855cc27c8b705258faf5008f71308c710d1f3a28cbfe8.png" alt="图 1">  </p>
<h2 id="求路径方法"><a href="#求路径方法" class="headerlink" title="求路径方法"></a>求路径方法</h2><p><strong>方法列表</strong><br>方法的所属包: <code>path/filepath</code></p>
<table>
    <tr>
        <th>方法名</th><th>描述</th>
    </tr>
    <tr>
        <td>IsAbs(path string) bool</td><td>判断是否是绝对路径</td>
    </tr>
    <tr>
        <td>Rel(basepath, targpath string) (string, error)</td><td>返回一个相对于basepath的路径</td>
    </tr>
    <tr>
        <td>Abs(path string) (string, error)</td><td>返回绝对路径</td>
    </tr>
    <tr>
        <td>Join(elem ...string) string</td><td>拼接路径</td>
    </tr>
</table>

<p><strong>使用示例</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	basePath, _ := filepath.Abs(filepath.Dir(os.Args[<span class="number">0</span>]))</span><br><span class="line">	fp1 := <span class="string">&quot;./test.txt&quot;</span></span><br><span class="line">	fp2 := <span class="string">&quot;/home/rma/mr_work/go_test/pkg/test.log&quot;</span></span><br><span class="line"></span><br><span class="line">	fmt.Printf(<span class="string">&quot;当前程序的绝对路径:  %v\n&quot;</span>, basePath)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;是绝对路径？: %t\n&quot;</span>, filepath.IsAbs(fp1))</span><br><span class="line">	<span class="comment">// 相对路径</span></span><br><span class="line">	rel, err := filepath.Rel(basePath, fp2)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;fp2的相对路径:  %v\n&quot;</span>, rel)</span><br><span class="line">	<span class="comment">// 绝对路径</span></span><br><span class="line">	abs, err := filepath.Abs(fp1)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;fp1的绝对路径:  %s\n&quot;</span>, abs)</span><br><span class="line">	<span class="comment">// 拼接路径</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;拼接路径1: %s \n&quot;</span>, path.Join(<span class="string">&quot;/home/Item&quot;</span>, <span class="string">&quot;go&quot;</span>, <span class="string">&quot;study&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><img src="2af4c1123ebb00e55e56c87056a39c3ee9b37ce0175259158bbf541cc6a72d37.png" alt="图 2">  </p>
<h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><p><strong>方法列表</strong></p>
<table>
    <tr>
        <th>方法名</th><th>描述</th>
    </tr>
    <tr>
        <td>os.Mkdir(name string, perm FileMode) error</td><td>创建名称为name的目录，权限设置是perm</td>
    </tr>
    <tr>
        <td>os.MkdirAll(path string, perm FileMode) error</td><td>根据path创建多级子目录</td>
    </tr>
</table>

<p><strong>使用示例</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	dirName := <span class="string">&quot;./img&quot;</span></span><br><span class="line">	<span class="comment">// 创建目录,并分配权限</span></span><br><span class="line">	err := os.Mkdir(dirName, os.ModePerm)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(dirName + <span class="string">&quot;  创建成功!&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建多级目录</span></span><br><span class="line">	dirName2 := <span class="string">&quot;./public/static/css&quot;</span></span><br><span class="line">	err = os.MkdirAll(dirName2, os.ModePerm)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(dirName2 + <span class="string">&quot;  创建成功!&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><img src="f326d3b1e256fdf20ecc79c9d5e8daef8a114651ae0cc1e934258482bff3db7b.png" alt="图 3">  </p>
<h3 id="删除目录-文件"><a href="#删除目录-文件" class="headerlink" title="删除目录/文件"></a>删除目录/文件</h3><p><strong>方法列表</strong></p>
<table>
    <tr>
        <th>方法名</th><th>描述</th>
    </tr>
    <tr>
        <td>os.Remove(name string) error</td><td>删除名称为name的目录/文件，当目录下有文件或者其他目录会出错</td>
    </tr>
    <tr>
        <td>os.RemoveAll(path string) error error</td><td>根据path删除多级子目录</td>
    </tr>
</table>

<p><strong>使用示例</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	err := os.Remove(<span class="string">&quot;./img&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Remove-&gt; 删除失败: &quot;</span> + err.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Remove-&gt; 删除成功!&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err1 := os.Remove(<span class="string">&quot;./test.log&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Remove-&gt; 删除失败: &quot;</span> + err1.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Remove-&gt; 删除成功!&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	err1 = os.Remove(<span class="string">&quot;./public&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Remove-&gt; 删除失败: &quot;</span> + err1.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Remove-&gt; 删除成功!&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除多级子目录</span></span><br><span class="line">	err2 := os.RemoveAll(<span class="string">&quot;./public&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err2 != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;RemoveAll-&gt; 删除失败: &quot;</span> + err2.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;RemoveAll-&gt; 删除成功!&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="162909921ab7efbe9f64ac26c5fd54ca0849730f534838dbf0bfe71ebeb69a34.png" alt="图 4">  </p>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><p><code>os.Create()</code>创建文件，如果文件存在，会将其覆盖。<code>os.Create()</code>本质上调用的是<code>OpenFile</code>, 源码如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">(name <span class="type">string</span>)</span></span> (*File, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, <span class="number">0666</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用示例</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fileName := <span class="string">&quot;./file/a.txt&quot;</span></span><br><span class="line">	<span class="comment">//如果文件存在,则会覆盖</span></span><br><span class="line">	create, err := os.Create(fileName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;创建失败: &quot;</span> + err.Error())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;创建成功! %v\n&quot;</span>, create)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建成功! &amp;&#123;0xc00006e180&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="打开和关闭文件"><a href="#打开和关闭文件" class="headerlink" title="打开和关闭文件"></a>打开和关闭文件</h3><p><strong>方法列表</strong></p>
<table>
    <tr>
        <th>方法名</th><th>描述</th>
    </tr>
    <tr>
        <td>Open(name string) (*File, error)</td><td>只读模式打开文件，本质上调用的是OpenFile</td>
    </tr>
    <tr>
        <td>OpenFile(name string, flag int, perm FileMode) (*File, error)</td><td>打开文件，可以传入模式和权限</td>
    </tr>
</table>

<p><strong>OpenFile入参介绍</strong></p>
<table>
    <tr>
        <th>flag值</th><th>代表的模式</th>
    </tr>
    <tr>
        <td>O_RDONLY</td><td>只读模式</td>
    </tr>
    <tr>
        <td>O_WRONLY</td><td>只写模式</td>
    </tr>
    <tr>
        <td>O_RDWR</td><td>读写模式</td>
    </tr>
    <tr>
        <td>O_APPEND</td><td>追加模式</td>
    </tr>
    <tr>
        <td>O_CREATE</td><td>文件不存在，则创建</td>
    </tr>
    <tr>
        <td>O_EXCL</td><td>和O_CREATE配合使用，文件必须不存在</td>
    </tr>
    <tr>
        <td>O_SYNC</td><td>打开文件用于同步I/O</td>
    </tr>
    <tr>
        <td>O_TRUNC</td><td>如果可能，打开时清空文件</td>
    </tr>
</table>

<p><strong>使用示例</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 该文件不存在</span></span><br><span class="line">	fileName := <span class="string">&quot;./public/test.txt&quot;</span></span><br><span class="line">	file1, err := os.Open(fileName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;os.Open 打开文件失败，err:%s \n&quot;</span>, err.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;os.Open 打开文件成功，open:%v \n&quot;</span>, file1)</span><br><span class="line">		<span class="comment">// 关闭文件</span></span><br><span class="line">		<span class="keyword">defer</span> file1.Close()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 文件不存在，则会创建文件</span></span><br><span class="line">	file2, err1 := os.OpenFile(fileName, os.O_CREATE, os.ModePerm)</span><br><span class="line">	<span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;os.OpenFile 打开文件失败，err:%s \n&quot;</span>, err1.Error())</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;os.OpenFile 打开文件成功，open:%v \n&quot;</span>, file2)</span><br><span class="line">		<span class="comment">// 关闭文件</span></span><br><span class="line">		<span class="keyword">defer</span> file2.Close()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">os.Open 打开文件失败，err:open ./public/test.txt: no such file or directory </span></span><br><span class="line"><span class="comment">os.OpenFile 打开文件成功，open:&amp;&#123;0xc0000b0120&#125; </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p>读取文件步骤: 打开文件(<code>Open</code>) 、读取文件(<code>Read</code>)、关闭文件(<code>Close</code>)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fileName := <span class="string">&quot;./public/test.txt&quot;</span></span><br><span class="line">	file1, err := os.Open(fileName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;os.Open 打开文件失败，err:%s \n&quot;</span>, err.Error())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 定义一个变量存储读取的内容</span></span><br><span class="line">	b := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line">	<span class="comment">// 读取文件</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		read, _ := file1.Read(b)</span><br><span class="line">		<span class="keyword">if</span> read == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;读取内容: %s \n&quot;</span>, b)</span><br><span class="line">	<span class="comment">// 关闭文件</span></span><br><span class="line">	_ = file1.Close()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">读取内容: hello world</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><p>写入文件步骤: 打开文件(<code>OpenFile</code>) 、写入文件(<code>Write</code>)、关闭文件(<code>Close</code>)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fileName := <span class="string">&quot;./public/hello.txt&quot;</span></span><br><span class="line">	<span class="comment">// 读写|创建|追加的模式 模式打开文件</span></span><br><span class="line">	file1, err := os.OpenFile(fileName, os.O_RDWR|os.O_CREATE|os.O_APPEND, os.ModePerm)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;os.OpenFile 打开文件失败，err:%s \n&quot;</span>, err.Error())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 写入文件</span></span><br><span class="line">	write, err := file1.Write([]<span class="type">byte</span>(<span class="string">&quot;Go! Go! Let&#x27;s Go!! 汉字 \n&quot;</span>))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;写入失败: %s \n&quot;</span>, err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;写入字节数: %d \n&quot;</span>, write)</span><br><span class="line">	<span class="comment">// 关闭文件</span></span><br><span class="line">	_ = file1.Close()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">写入字节数: 27</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h3><p>Go语言提供了<code>io.copy()</code>方法，用来复制文件。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 把fileA文件复制给fileB</span></span><br><span class="line">	fileA := <span class="string">&quot;./public/hello.txt&quot;</span></span><br><span class="line">	fileB := <span class="string">&quot;./public/new.txt&quot;</span></span><br><span class="line">	<span class="comment">// 打开源文件</span></span><br><span class="line">	sourceA, err := os.Open(fileA)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;os.Open 打开文件失败，err:%s \n&quot;</span>, err.Error())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 关闭文件A</span></span><br><span class="line">	<span class="keyword">defer</span> sourceA.Close()</span><br><span class="line">	<span class="comment">// 打开新文件</span></span><br><span class="line">	targetB, err := os.Create(fileB)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;os.Create 创建新文件失败，err:%s \n&quot;</span>, err.Error())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 关闭文件B</span></span><br><span class="line">	<span class="keyword">defer</span> targetB.Close()</span><br><span class="line">	<span class="comment">// 把fileA文件复制给fileB</span></span><br><span class="line">	written, err := io.Copy(targetB, sourceA)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;文件复制失败，err:%s \n&quot;</span>, err.Error())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;文件复制成功: %d \n&quot;</span>, written)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">文件复制成功: 54</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>os系统基本操作包使用</title>
    <url>/2021/05/07/os%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%8C%85%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote>
<p>os包中提供了操作系统函数的接口，是一个比较重要的包。它的作用主要是在服务器上进行系统的基本操作，如文件操作、目录操作、执行命令、信号与中断、进程、系统状态等等。下面分模块归纳一些常用函数。</p>
</blockquote>
<span id="more"></span>

<h2 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h2><p><strong>函数列表</strong></p>
<table>
    <tr>
        <th>函数</th><th>功能</th>
    </tr>
    <tr>
        <td>Hostname()</td><td>获取当前主机名</td>
    </tr>
    <tr>
        <td>Getpid()</td><td>返回调用者所在进程的进程ID</td>
    </tr>
    <tr>
        <td>Getppid()</td><td>返回调用者所在进程的父进程的进程ID</td>
    </tr>
    <tr>
        <td>Exit()</td><td>让程序以状态码code退出。状态码0表示成功，非0表示出错。code取值范围： [0,125]</td>
    </tr>
</table>

<p><strong>代码示例</strong><br><strong>系统相关</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	hostname, _ := os.Hostname()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;主机名:%v \n&quot;</span>, hostname)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;调用者所在进程的进程ID: %v \n&quot;</span>, os.Getpid())</span><br><span class="line">	fmt.Printf(<span class="string">&quot;调用者所在进程的进程的父进程ID: %v \n&quot;</span>, os.Getppid())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><img src="25716b6374e3cdaa9cca7b44ac92f5a570725bfb9f503c6d170ce72cdeb12ea7.png" alt="图 1">  </p>
<p><strong>Exit</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;调用前打印...&quot;</span>)</span><br><span class="line">	<span class="comment">// 调用退出程序：code范围应在 0 &lt;= x &lt;= 125</span></span><br><span class="line">	os.Exit(<span class="number">0</span>)</span><br><span class="line">	<span class="comment">// 后面代码不会执行</span></span><br><span class="line">	fmt.Println(<span class="string">&quot;调用后，这里不会输出&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><img src="be49c0cb5940e2f06b09cd48e0b638be6d7027904b67f257b44349c917b2ef31.png" alt="图 2">  </p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p><strong>函数列表</strong></p>
<table>
    <tr>
        <th>函数</th><th>功能</th>
    </tr>
    <tr>
        <td>Environ()</td><td>获取所有环境变量</td>
    </tr>
    <tr>
        <td>Setenv(key, value string)</td><td>设置环境变量</td>
    </tr>
    <tr>
        <td>Getenv(key string)</td><td>获取环境变量</td>
    </tr>
    <tr>
        <td>Clearenv()</td><td>清空所有环境变量</td>
    </tr>
</table>

<p><strong>代码示例</strong><br><strong>环境变量相关</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 所有环境变量</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;所有环境变量:%+v \n&quot;</span>, os.Environ())</span><br><span class="line">	<span class="comment">// 设置环境变量</span></span><br><span class="line">	_ = os.Setenv(<span class="string">&quot;my-name&quot;</span>, <span class="string">&quot;张三&quot;</span>)</span><br><span class="line">	<span class="comment">// 获取环境变量</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;获取环境变量: %v \n&quot;</span>, os.Getenv(<span class="string">&quot;my-name&quot;</span>))</span><br><span class="line">	<span class="comment">// 清空所有环境变量</span></span><br><span class="line">	os.Clearenv()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;清空环境变量后:%+v \n&quot;</span>, os.Environ())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><img src="9dd404b3c1d594ab4b191d9b9ecec66551749e6d89620b8e744b0ca87540b88c.png" alt="图 3">  </p>
<h2 id="文件相关"><a href="#文件相关" class="headerlink" title="文件相关"></a>文件相关</h2><p>关于文件相关的函数，参见之前的文章 go文件操作</p>
<h2 id="进程相关"><a href="#进程相关" class="headerlink" title="进程相关"></a>进程相关</h2><p><strong>方法列表</strong></p>
<table>
    <tr>
        <th>函数名</th><th>功能</th>
    </tr>
    <tr>
        <td>os.StartProcess(..) (*Process, error)</td><td>根据提供的参数创建一个新进程</td>
    </tr>
    <tr>
        <td>p.Signal(sig Signal)</td><td>向进程发送一个信号</td>
    </tr>
    <tr>
        <td>p.Wait()</td><td>阻塞到进程退出,返回类型*os.ProcessState</td>
    </tr>
    <tr>
        <td>ps.Pid()</td><td>返回一个已退出进程的id</td>
    </tr>
    <tr>
        <td>ps.Exited()</td><td>报告进程是否已退出</td>
    </tr>
    <tr>
        <td>ps.Success()</td><td>报告进程是否成功退出，在Unix中状态码0代表退出。</td>
    </tr>
    <tr>
        <td>ps.SystemTime()</td><td>退出进程及子进程耗费的系统CPU时间</td>
    </tr>
    <tr>
        <td>ps.UserTime()</td><td>退出进程及子进程耗费的用户CPU时间</td>
    </tr>
    <tr>
        <td>ps.String()</td><td>退出进程的状态信息</td>
    </tr>
</table>

<p>上表中<code>p</code>代表: <code>*os.Process</code>,  <code>ps</code>代表: <code>*os.ProcessState</code></p>
<p><strong>代码示例</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个新进程执行； ls /</span></span><br><span class="line">	args := []<span class="type">string</span>&#123;<span class="string">&quot;/&quot;</span>&#125;</span><br><span class="line">	process, err := os.StartProcess(<span class="string">&quot;/bin/ls&quot;</span>, args, &amp;os.ProcAttr&#123;&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;创建新进程失败: &quot;</span> + err.Error())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;当前新线程信息: %+v \n&quot;</span>, process)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2秒后向进程发送信号</span></span><br><span class="line">	time.AfterFunc(<span class="number">2</span>*time.Second, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;发送进程退出信号...&quot;</span>)</span><br><span class="line">		_ = process.Signal(os.Kill)</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="comment">// 手动阻塞看是否执行：发送信号</span></span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 等待进程退出,返回ProcessState类型</span></span><br><span class="line">	processState, _ := process.Wait()</span><br><span class="line">	<span class="comment">// 返回一个已退出进程的id</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;当前进程Id: %v \n&quot;</span>, processState.Pid())</span><br><span class="line">	<span class="comment">// 报告进程是否已退出</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;进程是否已退出: %v \n&quot;</span>, processState.Exited())</span><br><span class="line">	<span class="comment">// 报告进程是否成功退出，如在Unix里以状态码0退出。</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;进程是否成功退出: %v \n&quot;</span>, processState.Success())</span><br><span class="line">	<span class="comment">// 返回已退出进程及其子进程耗费的系统CPU时间。</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;进程及子进程耗费系统CPU时间: %v \n&quot;</span>, processState.SystemTime())</span><br><span class="line">	<span class="comment">// 返回已退出进程及其子进程耗费的用户CPU时间。</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;进程及子进程耗费用户CPU时间: %v \n&quot;</span>, processState.UserTime())</span><br><span class="line">	fmt.Printf(<span class="string">&quot;进程状态: %s \n&quot;</span>, processState.String())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:<br><img src="e92f9e91fc71640b2a8c1309f422cebddff4e062b3925d0bf7b90fd1df2275b6.png" alt="图 4">  </p>
<h2 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h2><p><code>os/exec</code>包执行外部命令。它包装了<code>os.StartProcess</code>函数以便更容易的修正输入和输出，使用管道连接I/O，以及其它的一些优化。</p>
<p><strong>方法列表</strong></p>
<table>
    <tr>
        <th>函数名</th><th>功能</th>
    </tr>
    <tr>
        <td>LookPath(file string) (string, error)</td><td>在环境变量PATH中搜索可执行文件</td>
    </tr>
    <tr>
        <td>(c *Cmd) Run() error</td><td>执行c包含的命令，并阻塞直到完成</td>
    </tr>
    <tr>
        <td>(c *Cmd) Start() error</td><td>执行c包含的命令即刻返回，但不会等待该命令完成。</td>
    </tr>
    <tr>
        <td>(c *Cmd) Wait() error</td><td>会阻塞直到该命令执行完成,和Start()结合使用</td>
    </tr>
    <tr>
        <td>(c *Cmd) Output() ([]byte, error)</td><td>执行命令并返回标准输出的切片</td>
    </tr>
    <tr>
        <td>(c *Cmd) CombinedOutput() ([]byte, error)</td><td>执行命令并返回标准输出和错误输出合并的切片。</td>
    </tr>
</table>


<p><strong>使用示例</strong><br><code>LookPath</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在环境变量PATH中搜索可执行文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	path, err := exec.LookPath(<span class="string">&quot;go&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><img src="ea3f85148064bee0fdd191e68ce25d2976499e77d1570616931eec0bf19aafed.png" alt="图 5">  </p>
<p><code>Run</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用Run()执行命令</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cmd := exec.Command(<span class="string">&quot;sleep&quot;</span>, <span class="string">&quot;3s&quot;</span>)</span><br><span class="line">	<span class="comment">// 具体执行</span></span><br><span class="line">	err := cmd.Run()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;执行失败:%v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;cmd.Path: %v \n&quot;</span>, cmd.Path)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;cmd.Args: %v \n&quot;</span>, cmd.Args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><img src="897245d982566520021da8587f21c86f1813a8a9a1ac1c17bacd8a9c2fcf9d9b.png" alt="图 6">  </p>
<p><code>Start</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用Start执行命令</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cmd := exec.Command(<span class="string">&quot;sleep&quot;</span>, <span class="string">&quot;3s&quot;</span>)</span><br><span class="line">	<span class="comment">// Start开始执行c包含的命令，但并不会等待该命令完成即返回</span></span><br><span class="line">	err := cmd.Start()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;执行失败:%v\n&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//Wait会阻塞直到该命令执行完成</span></span><br><span class="line">	err = cmd.Wait()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;执行完成: %v \n&quot;</span>, err)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;cmd.Path: %v \n&quot;</span>, cmd.Path)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;cmd.Args: %v \n&quot;</span>, cmd.Args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出：<br><img src="25db6b3665963391aa957243a001cac77e91cf956ddcf773d26c122a0e3fb24c.png" alt="图 7">  </p>
<p><code>Output</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行命令并获取输出结果</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	output, _ := exec.Command(<span class="string">&quot;go&quot;</span>, <span class="string">&quot;version&quot;</span>).Output()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;结果: %s&quot;</span>, output)</span><br><span class="line">	<span class="comment">// 执行: du -sh .</span></span><br><span class="line">	output2, _ := exec.Command(<span class="string">&quot;du&quot;</span>, <span class="string">&quot;-sh&quot;</span>, <span class="string">&quot;.&quot;</span>).Output()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;结果: %s&quot;</span>, output2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><img src="78341914658e18326703cb8e438ce6ed7a4fe687ce368984b81ebe5a3b3e7a5d.png" alt="图 8">  </p>
<p><code>CombinedOutput</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 执行命令并返回标准输出和错误输出合并的切片</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 执行: go version-1 故意写错</span></span><br><span class="line">	output, _ := exec.Command(<span class="string">&quot;go&quot;</span>, <span class="string">&quot;version-1&quot;</span>).Output()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;结果1: %s \n&quot;</span>, output)</span><br><span class="line"></span><br><span class="line">	output, _ = exec.Command(<span class="string">&quot;go&quot;</span>, <span class="string">&quot;version-1&quot;</span>).CombinedOutput()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;结果2: %s \n&quot;</span>, output)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：<br><img src="c83901869a7a52f6d0eec8e4269aece5cabee87d8918ff1a347a74f75841cb5f.png" alt="图 9">  </p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>rune字符操作包(unicode)</title>
    <url>/2021/05/06/rune%E5%AD%97%E7%AC%A6%E6%93%8D%E4%BD%9C%E5%8C%85-unicode/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote>
<p>unicode包提供了诸多处理rune字符相关功能的函数（比如区分字母和数字，或者是字母的大写和小写转换等)</p>
</blockquote>
<span id="more"></span>

<p><strong>说明</strong>：<br>golang中的字符有两种，<code>uint8（byte）</code>代表<code>ASCII</code>的一个字符，<code>rune</code>代表一个<code>utf-8</code>字符。<br>当需要处理中文、日文或者其他复合字符时，则需要用到<code>rune</code>类型，rune实际是一个<code>int32</code></p>
<h2 id="判断函数"><a href="#判断函数" class="headerlink" title="判断函数"></a>判断函数</h2><h3 id="是否为空格-IsSpace"><a href="#是否为空格-IsSpace" class="headerlink" title="是否为空格(IsSpace)"></a>是否为空格(IsSpace)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	rune1 := <span class="string">&#x27; &#x27;</span></span><br><span class="line">	rune2 := <span class="string">&#x27;h&#x27;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%c] 是空格? %t\n&quot;</span>, rune1, unicode.IsSpace(rune1))</span><br><span class="line">	<span class="comment">// 输出 [ ] 是空格? true</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%c] 是空格? %t\n&quot;</span>, rune2, unicode.IsSpace(rune2))</span><br><span class="line">	<span class="comment">// 输出 [h] 是空格? false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="是否为十进制数-IsDigit"><a href="#是否为十进制数-IsDigit" class="headerlink" title="是否为十进制数(IsDigit)"></a>是否为十进制数(IsDigit)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	d1 := <span class="string">&#x27;1&#x27;</span></span><br><span class="line">	d2 := <span class="string">&#x27;w&#x27;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%c] 是十进制数? %t\n&quot;</span>, d1, unicode.IsDigit(d1))</span><br><span class="line">	<span class="comment">// 输出: [1] 是十进制数? true</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%c] 是十进制数? %t\n&quot;</span>, d2, unicode.IsDigit(d2))</span><br><span class="line">	<span class="comment">// 输出: [w] 是十进制数? false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="是否为数字-IsNumber"><a href="#是否为数字-IsNumber" class="headerlink" title="是否为数字(IsNumber)"></a>是否为数字(IsNumber)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	d1 := <span class="string">&#x27;1&#x27;</span></span><br><span class="line">	d2 := <span class="string">&#x27;w&#x27;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%c] 是数字? %t\n&quot;</span>, d1, unicode.IsNumber(d1))</span><br><span class="line">	<span class="comment">// 输出: [1] 是数字? true</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%c] 是数字? %t\n&quot;</span>, d2, unicode.IsNumber(d2))</span><br><span class="line">	<span class="comment">// 输出: [w] 是数字? false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="是否为字母字符-IsLetter"><a href="#是否为字母字符-IsLetter" class="headerlink" title="是否为字母字符(IsLetter)"></a>是否为字母字符(IsLetter)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str1 := <span class="string">&#x27;刘&#x27;</span></span><br><span class="line">	str2 := <span class="string">&#x27;l&#x27;</span></span><br><span class="line">	str3 := <span class="string">&#x27;W&#x27;</span></span><br><span class="line">	str4 := <span class="string">&#x27;!&#x27;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%c] 是字母? %t\n&quot;</span>, str1, unicode.IsLetter(str1))</span><br><span class="line">	<span class="comment">// [刘] 是字母? true</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%c] 是字母? %t\n&quot;</span>, str2, unicode.IsLetter(str2))</span><br><span class="line">	<span class="comment">// [l] 是字母? true</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%c] 是字母? %t\n&quot;</span>, str3, unicode.IsLetter(str3))</span><br><span class="line">	<span class="comment">// [W] 是字母? true</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%c] 是字母? %t\n&quot;</span>, str4, unicode.IsLetter(str4))</span><br><span class="line">	<span class="comment">// [!] 是字母? false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>: 汉字也是一个字母字符</p>
<h3 id="是否为标点符号-IsPunct"><a href="#是否为标点符号-IsPunct" class="headerlink" title="是否为标点符号(IsPunct)"></a>是否为标点符号(IsPunct)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str1 := <span class="string">&#x27;刘&#x27;</span></span><br><span class="line">	str2 := <span class="string">&#x27;l&#x27;</span></span><br><span class="line">	str3 := <span class="string">&#x27;!&#x27;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%c] 是标点符号? %t\n&quot;</span>, str1, unicode.IsPunct(str1))</span><br><span class="line">	<span class="comment">// [刘] 是标点符号? false</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%c] 是标点符号? %t\n&quot;</span>, str2, unicode.IsPunct(str2))</span><br><span class="line">	<span class="comment">// [l] 是标点符号? false</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%c] 是标点符号? %t\n&quot;</span>, str3, unicode.IsPunct(str3))</span><br><span class="line">	<span class="comment">// [!] 是标点符号? true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="是否为小写字母-IsLower"><a href="#是否为小写字母-IsLower" class="headerlink" title="是否为小写字母(IsLower)"></a>是否为小写字母(IsLower)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str1 := <span class="string">&#x27;刘&#x27;</span></span><br><span class="line">str2 := <span class="string">&#x27;l&#x27;</span></span><br><span class="line">str3 := <span class="string">&#x27;W&#x27;</span></span><br><span class="line">str4 := <span class="string">&#x27;!&#x27;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%c] 是小写字母? %t\n&quot;</span>, str1, unicode.IsLower(str1))</span><br><span class="line"><span class="comment">// [刘] 是小写字母? false</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%c] 是小写字母? %t\n&quot;</span>, str2, unicode.IsLower(str2))</span><br><span class="line"><span class="comment">// [l] 是小写字母? true</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%c] 是小写字母? %t\n&quot;</span>, str3, unicode.IsLower(str3))</span><br><span class="line"><span class="comment">// [W] 是小写字母? false</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%c] 是小写字母? %t\n&quot;</span>, str4, unicode.IsLower(str4))</span><br><span class="line"><span class="comment">// [!] 是小写字母? false</span></span><br></pre></td></tr></table></figure>

<h3 id="是否为大写字母-IsUpper"><a href="#是否为大写字母-IsUpper" class="headerlink" title="是否为大写字母(IsUpper)"></a>是否为大写字母(IsUpper)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str1 := <span class="string">&#x27;刘&#x27;</span></span><br><span class="line">	str2 := <span class="string">&#x27;l&#x27;</span></span><br><span class="line">	str3 := <span class="string">&#x27;W&#x27;</span></span><br><span class="line">	str4 := <span class="string">&#x27;!&#x27;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%c] 是大写字母? %t\n&quot;</span>, str1, unicode.IsUpper(str1))</span><br><span class="line">	<span class="comment">// [刘] 是大写字母? false</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%c] 是大写字母? %t\n&quot;</span>, str2, unicode.IsUpper(str2))</span><br><span class="line">	<span class="comment">// [l] 是大写字母? false</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%c] 是大写字母? %t\n&quot;</span>, str3, unicode.IsUpper(str3))</span><br><span class="line">	<span class="comment">// [W] 是大写字母? true</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%c] 是大写字母? %t\n&quot;</span>, str4, unicode.IsUpper(str4))</span><br><span class="line">	<span class="comment">// [!] 是大写字母? false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="是否为汉字"><a href="#是否为汉字" class="headerlink" title="是否为汉字"></a>是否为汉字</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	str1 := <span class="string">&#x27;刘&#x27;</span></span><br><span class="line">	str2 := <span class="string">&#x27;l&#x27;</span></span><br><span class="line">	str3 := <span class="string">&#x27;!&#x27;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%c] 是汉字? %t\n&quot;</span>, str1, unicode.Is(unicode.Scripts[<span class="string">&quot;Han&quot;</span>], str1))</span><br><span class="line">	<span class="comment">// [刘] 是汉字? true</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%c] 是汉字? %t\n&quot;</span>, str2, unicode.Is(unicode.Scripts[<span class="string">&quot;Han&quot;</span>], str2))</span><br><span class="line">	<span class="comment">// [l] 是汉字? false</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;[%c] 是汉字? %t\n&quot;</span>, str3, unicode.Is(unicode.Scripts[<span class="string">&quot;Han&quot;</span>], str3))</span><br><span class="line">	<span class="comment">// [!] 是汉字? false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h2><h3 id="转成小写-ToLower"><a href="#转成小写-ToLower" class="headerlink" title="转成小写(ToLower)"></a>转成小写(ToLower)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str1 := <span class="string">&#x27;W&#x27;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%c] 转成小写: %c \n&quot;</span>, str1, unicode.ToLower(str1))</span><br><span class="line"><span class="comment">// [W] 转成小写: w </span></span><br></pre></td></tr></table></figure>

<h3 id="转成大写-ToUpper"><a href="#转成大写-ToUpper" class="headerlink" title="转成大写(ToUpper)"></a>转成大写(ToUpper)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str2 := <span class="string">&#x27;a&#x27;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%c] 转成大写: %c \n&quot;</span>, str2, unicode.ToUpper(str2))</span><br><span class="line"><span class="comment">// [a] 转成大写: A</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>sort排序和查询</title>
    <url>/2021/04/30/sort%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote>
<p>sort包实现了四种基本排序算法：插入排序、归并排序、堆排序、快速排序。 但是这四种排序方法是不公开的，它们只能在 sort 包内部使用。sort 包会根据实际数据自动选择高效的排序算法，所以在对数据集合排序时不必考虑应当选择哪一种排序方法，只要实现了 sort.Interface 定义的三个方法,就可以顺利对数据集合进行排序</p>
</blockquote>
<span id="more"></span>

<p><code>Len() int</code>: 获取数据集合长度。<br><code>Less() bool</code>: 比较两个元素大小。<br><code>Swap()</code>: 交换两个元素位置。</p>
<h3 id="支持功能"><a href="#支持功能" class="headerlink" title="支持功能"></a>支持功能</h3><p>sort 包对[]int 、[]float64 、[]string 切片提供了完整的支持，主要功能有：</p>
<p>对基本数据类型切片的排序。<br>基本数据元素查找。<br>判断基本数据类型切片是否已经排序。<br>对排好序的数据集合逆序。</p>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 定义整数序列</span></span><br><span class="line">	nums := sort.IntSlice&#123;<span class="number">10</span>, <span class="number">40</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">23</span>, <span class="number">72</span>, <span class="number">89</span>&#125;</span><br><span class="line">	<span class="comment">// 排序</span></span><br><span class="line">	nums.Sort()</span><br><span class="line">	<span class="comment">// 判断是否已排序</span></span><br><span class="line">	<span class="keyword">if</span> sorted := sort.IsSorted(nums); sorted &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;排序结果:%+v\n&quot;</span>, nums)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;排序失败！&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 输出:</span></span><br><span class="line"><span class="comment">排序结果:[6 9 10 23 40 72 89]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="sort-Ints"><a href="#sort-Ints" class="headerlink" title="sort.Ints"></a>sort.Ints</h3><p>将 []int 进行升序排序。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	a := []<span class="type">int</span>&#123;<span class="number">23</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">89</span>&#125;</span><br><span class="line">	<span class="comment">// 调用排序</span></span><br><span class="line">	sort.Ints(a)</span><br><span class="line">	<span class="comment">// 检测是否已经排序</span></span><br><span class="line">	<span class="keyword">if</span> sorted := sort.IntsAreSorted(a); sorted &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;排序成功: %v\n&quot;</span>, a)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;排序失败: %v\n&quot;</span>, a)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 查找元素</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;查找元素(存在): %v 索引:%v \n&quot;</span>, <span class="number">12</span>, sort.SearchInts(a, <span class="number">12</span>))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;查找元素(不存在): %v 索引:%v \n&quot;</span>, <span class="number">22</span>, sort.SearchInts(a, <span class="number">22</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 输出</span></span><br><span class="line"><span class="comment">排序成功: [2 3 9 12 12 23 89]</span></span><br><span class="line"><span class="comment">查找元素(存在): 12 索引:3 </span></span><br><span class="line"><span class="comment">查找元素(不存在): 22 索引:5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>同样的方法还有：<br><code>sort.Float64s</code>、<code>sort.Strings</code></p>
<h3 id="降序"><a href="#降序" class="headerlink" title="降序"></a>降序</h3><p>降序原理<br>前面介绍的都是排序规则都是升序(sort包默认都是升序),如果想要降序，可以使用sort.Reverse来调换Less()参数，从而实现降序的目的。</p>
<p><code>sort.Reverse</code> 源码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接收一个Interface类型参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(data Interface)</span></span> Interface &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;reverse&#123;data&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以看到这里是把参数 i,j 互换成 j,i</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r reverse)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> r.Interface.Less(j, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 使用sort包中的数据类型</span></span><br><span class="line">	intSlice := sort.IntSlice&#123;<span class="number">23</span>, <span class="number">15</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">89</span>&#125;</span><br><span class="line">	<span class="comment">// 互换j,i</span></span><br><span class="line">	reverse := sort.Reverse(intSlice)</span><br><span class="line">	<span class="comment">// 排序</span></span><br><span class="line">	sort.Sort(reverse)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;排序结果: %v\n&quot;</span>, intSlice)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 输出</span></span><br><span class="line"><span class="comment">排序结果: [89 23 15 12 9 3 2]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p><strong>查找步骤</strong></p>
<ul>
<li>步骤一：定义类型变量</li>
<li>步骤二：先排序后查找(查找是基于排序后的结果)</li>
<li>步骤三：查询可能存在的索引</li>
<li>步骤四：判断是否相等</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search_var</span><span class="params">(searchVal <span class="type">int</span>, intSlice sort.IntSlice)</span></span> &#123;</span><br><span class="line">	searchIndex := intSlice.Search(searchVal)</span><br><span class="line">	<span class="comment">// 判断是否相等</span></span><br><span class="line">	<span class="keyword">if</span> searchIndex &gt;= <span class="built_in">len</span>(intSlice) &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;未找到：%v\n&quot;</span>, searchVal)</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> searchVal == intSlice[searchIndex] &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;找到: %v 索引为: %v \n&quot;</span>, searchVal, searchIndex)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;未找到：%v\n&quot;</span>, searchVal)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 1.定义类型</span></span><br><span class="line">	intSlice := sort.IntSlice&#123;<span class="number">10</span>, <span class="number">40</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">23</span>, <span class="number">72</span>, <span class="number">89</span>&#125;</span><br><span class="line">	<span class="comment">// 2.排序后查找</span></span><br><span class="line">	intSlice.Sort()</span><br><span class="line">	<span class="comment">// 3.查询可能存在的索引</span></span><br><span class="line">	search_var(<span class="number">6</span>, intSlice)</span><br><span class="line">	<span class="comment">// 4.查找不存在情况</span></span><br><span class="line">	search_var(<span class="number">90</span>, intSlice)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">找到: 6 索引为: 0 </span></span><br><span class="line"><span class="comment">未找到：90</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>根据查询出的索引,取出对应的值，看是否与查找的值相等。如果相等则认为找到，不相等则认为没有找到。</p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>flag包使用</title>
    <url>/2021/04/29/flag%E5%8C%85%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote>
<p>在 Go中，如果要接收命令行参数，需要使用 flag包进行解析。不同的参数类型可以通过不同的方法接收。</p>
</blockquote>
<span id="more"></span>

<h2 id="参数接受"><a href="#参数接受" class="headerlink" title="参数接受"></a>参数接受</h2><h3 id="接受方式"><a href="#接受方式" class="headerlink" title="接受方式"></a>接受方式</h3><p>使用<code>flag</code>接收参数，可以由以下三种方式接受：</p>
<ul>
<li>方式一: flag.Type(name,defaultVal,desc)</li>
<li>方式二: flag.TypeVar(&amp;flagVar,name,defaultVal,desc)</li>
<li>方式三: flag.Var(&amp;flagVar,name,desc)</li>
<li>方式四: flag.Args()</li>
<li>方式五: flag.Arg(i)</li>
</ul>
<table>
    <tr>
        <th>字段</th><th>说明</th>
    </tr>
    <tr>
        <td>flag.Type</td><td>这里的Type是个抽象的概念,不是具体函数名</td>
    </tr>
    <tr>
        <td>defaultVal</td><td>默认值</td>
    </tr>
    <tr>
        <td>desc</td><td>描述信息</td>
    </tr>
</table>
    
    
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>上面接收方式一、二、三，都是最后调用<code>flag.Parse()</code>,而方式四和方式五是提前调用<code>flag.Parse()</code>。<br>方式一、二、三传参时，注意布尔类型，尽量设置成-flag=val，否则会影响后面的参数解析。<br>方式四、五不能使用-flag=val这种格式传参。</p>
<h2 id="flag-Type"><a href="#flag-Type" class="headerlink" title="flag.Type"></a>flag.Type</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	<span class="comment">// 接收字符串</span></span><br><span class="line">	str =  flag.String(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;默认名&quot;</span>,<span class="string">&quot;用户姓名&quot;</span>)</span><br><span class="line">	<span class="comment">// 接收整型</span></span><br><span class="line">	age = flag.Int(<span class="string">&quot;age&quot;</span>,<span class="number">18</span>,<span class="string">&quot;用户年龄&quot;</span>)</span><br><span class="line">	<span class="comment">// 接收布尔型</span></span><br><span class="line">	smoking = flag.Bool(<span class="string">&quot;smoking&quot;</span>,<span class="literal">false</span>,<span class="string">&quot;是否吸烟&quot;</span>)</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="comment">// 解析</span></span><br><span class="line">	flag.Parse()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;str: %v\n&quot;</span>,*str)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;age: %v\n&quot;</span>,*age)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;smoking: %v\n&quot;</span>,*smoking)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">str: 默认名</span></span><br><span class="line"><span class="comment">age: 18</span></span><br><span class="line"><span class="comment">smoking: false</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>运行(传参数时)</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># go run main.go -name 张三 -age 100 -smoking=true</span></span><br><span class="line">str: 张三</span><br><span class="line">age: 100</span><br><span class="line">smoking: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h2 id="flag-TypeVar"><a href="#flag-TypeVar" class="headerlink" title="flag.TypeVar"></a>flag.TypeVar</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 先定义变量</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">	age <span class="type">int</span></span><br><span class="line">	smoking <span class="type">bool</span></span><br><span class="line">	weight <span class="type">float64</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="comment">// 接收字符串</span></span><br><span class="line">	flag.StringVar(&amp;name,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;默认名字&quot;</span>,<span class="string">&quot;用户名&quot;</span>)</span><br><span class="line">	<span class="comment">// 接收整型</span></span><br><span class="line">	flag.IntVar(&amp;age,<span class="string">&quot;age&quot;</span>,<span class="number">18</span>,<span class="string">&quot;用户年龄&quot;</span>)</span><br><span class="line">	<span class="comment">// 接收布尔类型</span></span><br><span class="line">	flag.BoolVar(&amp;smoking,<span class="string">&quot;smoking&quot;</span>,<span class="literal">false</span>,<span class="string">&quot;是否吸烟？&quot;</span>)</span><br><span class="line">	<span class="comment">// 接收浮点型</span></span><br><span class="line">	flag.Float64Var(&amp;weight,<span class="string">&quot;w&quot;</span>,<span class="number">60.0</span>,<span class="string">&quot;体重&quot;</span>)</span><br><span class="line">	<span class="comment">// 解析</span></span><br><span class="line">	flag.Parse()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;姓名: %v\n&quot;</span>,name)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;年龄: %v\n&quot;</span>,age)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;是否吸烟？: %v\n&quot;</span>,smoking)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;体重: %v\n&quot;</span>,weight)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">姓名: 默认名字</span></span><br><span class="line"><span class="comment">年龄: 18</span></span><br><span class="line"><span class="comment">是否吸烟？: false</span></span><br><span class="line"><span class="comment">体重: 60</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>运行(传参数时)</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># go run main.go -name 张三 -age 22 -smoking=true  -w=88.9</span></span><br><span class="line">姓名: 张三</span><br><span class="line">年龄: 22</span><br><span class="line">是否吸烟？: <span class="literal">true</span></span><br><span class="line">体重: 88.9</span><br></pre></td></tr></table></figure>
<p><strong>细节</strong><br>在传参数过程中，发现布尔型传参如果不设置=，会影响后面的参数接收,具体如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 布尔型不设置 = (发现名字没有被接收)</span></span><br><span class="line"><span class="comment"># go run main.go -smoking true -name 哈哈 </span></span><br><span class="line">姓名: 默认名字</span><br><span class="line">年龄: 18</span><br><span class="line">是否吸烟？: <span class="literal">true</span></span><br><span class="line">体重: 60</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 布尔型设置 = </span></span><br><span class="line"><span class="comment"># go run main.go -smoking=true -name 哈哈 </span></span><br><span class="line">姓名: 哈哈</span><br><span class="line">年龄: 18</span><br><span class="line">是否吸烟？: <span class="literal">true</span></span><br><span class="line">体重: 60</span><br></pre></td></tr></table></figure>

<h2 id="flag-Var"><a href="#flag-Var" class="headerlink" title="flag.Var"></a>flag.Var</h2><p>通过 <code>flag.Var()</code> 绑定自定义类型，自定义类型需要实现 Value 接口(Receives必须为指针)</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义变量，并实现flag.Value接口</span></span><br><span class="line"><span class="keyword">type</span> Likes []<span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Likes)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%v&quot;</span>, *l)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Likes)</span></span> Set(s <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">	<span class="comment">// 分割字符串</span></span><br><span class="line">	split := strings.Split(s, <span class="string">&quot;,&quot;</span>)</span><br><span class="line">	*l = split</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> likeList Likes</span><br><span class="line">	<span class="comment">// 接收自定义类型</span></span><br><span class="line">	flag.Var(&amp;likeList, <span class="string">&quot;likes&quot;</span>, <span class="string">&quot;接收自定义类型&quot;</span>)</span><br><span class="line">	<span class="comment">// 解析</span></span><br><span class="line">	flag.Parse()</span><br><span class="line">	fmt.Println(likeList)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># go run main.go -likes=篮球,足球,游戏</span></span><br><span class="line">[篮球 足球 游戏]</span><br></pre></td></tr></table></figure>

<h2 id="flag-Args"><a href="#flag-Args" class="headerlink" title="flag.Args"></a>flag.Args</h2><p>一次打印出全部的入参，注意入参格式不能是<code>-flag=val</code>格式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 注意Parse是在Args之前调用</span></span><br><span class="line">	flag.Parse()</span><br><span class="line">	<span class="comment">// 一次接收所有的参数</span></span><br><span class="line">	args := flag.Args()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> _, v := <span class="keyword">range</span> args &#123;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># go run main.go 篮球 足球 游戏</span></span><br><span class="line">篮球</span><br><span class="line">足球</span><br><span class="line">游戏</span><br><span class="line">[篮球 足球 游戏]</span><br></pre></td></tr></table></figure>

<h2 id="flag-Arg-i"><a href="#flag-Arg-i" class="headerlink" title="flag.Arg(i)"></a>flag.Arg(i)</h2><p>获取指定索引位置的参数，默认索引位置是0;注意入参格式不能是<code>-flag=val</code>格式。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 注意Parse是在Arg之前调用</span></span><br><span class="line">	flag.Parse()</span><br><span class="line">	<span class="comment">// 获取指定索引位置参数</span></span><br><span class="line">	p0 := flag.Arg(<span class="number">0</span>)</span><br><span class="line">	p1 := flag.Arg(<span class="number">1</span>)</span><br><span class="line">	p2 := flag.Arg(<span class="number">2</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;索引=0，v=%v\n&quot;</span>,p0)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;索引=1，v=%v\n&quot;</span>,p1)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;索引=2，v=%v\n&quot;</span>,p2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># go run main.go 篮球 足球 游戏</span></span><br><span class="line">索引=0，v=篮球</span><br><span class="line">索引=1，v=足球</span><br><span class="line">索引=2，v=游戏</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>sync包使用</title>
    <url>/2021/04/28/sync%E5%8C%85%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote>
<p>sync包提供了互斥锁。除了Once和WaitGroup类型，其余多数适用于低水平的程序，多数情况下，高水平的同步使用channel通信性能会更优一些。</p>
</blockquote>
<span id="more"></span>

<h2 id="并发等待组-WaitGroup"><a href="#并发等待组-WaitGroup" class="headerlink" title="并发等待组(WaitGroup)"></a>并发等待组(WaitGroup)</h2><p><code>WaitGroup</code>，即等待一组Goroutine结束。父Goroutine调用Add()方法来设置应等待Goroutine的数量。每个被等待的Goroutine在结束时应该调用Done()方法。与此同时，主Goroutine可调用Wait()方法阻塞至所有Goroutine结束。</p>
<p><strong>WaitGroup结构</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A WaitGroup must not be copied after first use.</span></span><br><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">	noCopy noCopy</span><br><span class="line">	state1 [<span class="number">3</span>]<span class="type">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法列表</strong></p>
<table>
    <tr>
        <th>方法名</th><th>功能</th>
    </tr>
    <tr>
        <td>(wg *WaitGroup) Add(delta int)</td><td>等待组的计数器 +1</td>
    </tr>
    <tr>
        <td>(wg *WaitGroup) Done()</td><td>等待组的计数器 -1</td>
    </tr>
    <tr>
        <td>(wg *WaitGroup) Wait()</td><td>当等待组计数器不等于0时,阻塞直到0</td>
    </tr>
</table>


<p><strong>Add参数取值范围</strong><br>等待组内部拥有一个计数器，计数器的值可以通过Add(delta int)方法调用实现计数器的增加和减少。该方法应该在创建新的Goroutine之前调用。</p>
<p>参数值x取值</p>
<table>
    <tr>
        <th>取值</th><th>描述</th>
    </tr>
    <tr>
        <td>delta < 0</td><td>x小于0时,但会报错: panic: sync: negative WaitGroup counter</td>
    </tr>
    <tr>
        <td>delta = 0</td><td>x等于0时,会释放Wait()方法阻塞等待的所有Goroutine</td>
    </tr>
    <tr>
        <td>delta > 0</td><td>x大于0时,Wait()方法会阻塞Goroutine直到WaitGroup计数减为0</td>
    </tr>
</table>

<p><strong>不使用WaitGroup示例</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建通道</span></span><br><span class="line">	intChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算1-50的和</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(intChan <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		sum := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++ &#123;</span><br><span class="line">			sum += i</span><br><span class="line">		&#125;</span><br><span class="line">		intChan &lt;- sum</span><br><span class="line">	&#125;(intChan)</span><br><span class="line">	<span class="comment">// 计算51-100的和</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(intChan <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		sum := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">51</span>; i &lt;= <span class="number">100</span>; i++ &#123;</span><br><span class="line">			sum += i</span><br><span class="line">		&#125;</span><br><span class="line">		intChan &lt;- sum</span><br><span class="line">	&#125;(intChan)</span><br><span class="line">	<span class="comment">// 另外创建个channle聚合结果</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(intChan <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		sum1 := &lt;-intChan</span><br><span class="line">		sum2 := &lt;-intChan</span><br><span class="line">		fmt.Printf(<span class="string">&quot;sum1 = %d sum2 = %d  \nsum1 + sum2 = %d \n&quot;</span>, sum1, sum2, sum1+sum2)</span><br><span class="line">	&#125;(intChan)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 注意,需求手动sleep</span></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;运行结束&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 输出:</span></span><br><span class="line"><span class="comment">  sum1 = 1275 sum2 = 3775  </span></span><br><span class="line"><span class="comment">  sum1 + sum2 = 5050 </span></span><br><span class="line"><span class="comment">  运行结束</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>使用WaitGroup示例</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 声明等待组</span></span><br><span class="line">	<span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">	<span class="comment">// 设置，需要等待3个协程执行完成</span></span><br><span class="line">	wg.Add(<span class="number">3</span>)</span><br><span class="line">	<span class="comment">// 创建通道</span></span><br><span class="line">	intChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">	<span class="comment">// 计算1-50的和</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(intChan <span class="keyword">chan</span> <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">		sum := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++ &#123;</span><br><span class="line">			sum += i</span><br><span class="line">		&#125;</span><br><span class="line">		intChan &lt;- sum</span><br><span class="line">		<span class="comment">// 计数器减一</span></span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;(intChan, &amp;wg)</span><br><span class="line">	<span class="comment">// 计算51-100的和</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(intChan <span class="keyword">chan</span> <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">		sum := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">51</span>; i &lt;= <span class="number">100</span>; i++ &#123;</span><br><span class="line">			sum += i</span><br><span class="line">		&#125;</span><br><span class="line">		intChan &lt;- sum</span><br><span class="line">		<span class="comment">// 计数器减一</span></span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;(intChan, &amp;wg)</span><br><span class="line">	<span class="comment">// 另外创建个channle聚合结果</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(intChan <span class="keyword">chan</span> <span class="type">int</span>,wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">		sum1 := &lt;-intChan</span><br><span class="line">		sum2 := &lt;-intChan</span><br><span class="line">		fmt.Printf(<span class="string">&quot;sum1 = %d sum2 = %d  \nsum1 + sum2 = %d \n&quot;</span>, sum1, sum2, sum1+sum2)</span><br><span class="line">		<span class="comment">// 计数器减一</span></span><br><span class="line">		wg.Done()</span><br><span class="line">	&#125;(intChan,&amp;wg)</span><br><span class="line">	<span class="comment">// 阻塞，直到等待组的计数器等于0</span></span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;运行结束&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">  sum1 = 1275 sum2 = 3775 </span></span><br><span class="line"><span class="comment">  sum1 + sum2 = 5050 </span></span><br><span class="line"><span class="comment">  运行结束</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="互斥锁-Mutex"><a href="#互斥锁-Mutex" class="headerlink" title="互斥锁(Mutex)"></a>互斥锁(Mutex)</h2><p><code>Mutex</code>是一个互斥锁，保证同时只有一个Goroutine可以访问共享资源。Mutex类型的锁和Goroutine无关，可以由不同的Goroutine加锁和解锁。也可以为其他结构体的字段，零值为解锁状态。</p>
<p><strong>结构介绍</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">	state <span class="type">int32</span> <span class="comment">// state 表示当前互斥锁的状态</span></span><br><span class="line">	sema  <span class="type">uint32</span> <span class="comment">// sema 是用于控制锁状态的信号量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法列表</strong></p>
<table>
    <tr>
        <th>方法名</th><th>功能</th>
    </tr>
    <tr>
        <td>(m *Mutex) Lock()</td><td>方法锁住m，如果 m 已经加锁，则阻塞直到 m 解锁</td>
    </tr>
    <tr>
        <td>(m *Mutex) Unlock()</td><td>解锁 m，如果 m 未加锁会导致运行时错误</td>
    </tr>
</table>

<p><strong>模拟多个窗口售票</strong><br>不作为结构体属性使用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 声明全局等待组</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="comment">// 声明全局锁</span></span><br><span class="line"><span class="keyword">var</span> mutex sync.Mutex</span><br><span class="line"><span class="comment">// 声明全局余票</span></span><br><span class="line"><span class="keyword">var</span> ticket <span class="type">int</span> = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 设置等待组计数器</span></span><br><span class="line">	wg.Add(<span class="number">3</span>)</span><br><span class="line">	<span class="comment">// 窗口卖票</span></span><br><span class="line">	<span class="keyword">go</span> saleTicket(<span class="string">&quot;窗口A&quot;</span>,&amp;wg)</span><br><span class="line">	<span class="keyword">go</span> saleTicket(<span class="string">&quot;窗口B&quot;</span>,&amp;wg)</span><br><span class="line">	<span class="keyword">go</span> saleTicket(<span class="string">&quot;窗口C&quot;</span>,&amp;wg)</span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;运行结束!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 卖票流程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">saleTicket</span><span class="params">(windowName <span class="type">string</span>, wg *sync.WaitGroup)</span></span>  &#123;</span><br><span class="line">	<span class="comment">// 卖票流程结束后关闭</span></span><br><span class="line">	<span class="keyword">defer</span> wg.Done()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 加锁</span></span><br><span class="line">		mutex.Lock()</span><br><span class="line">		<span class="keyword">if</span>  ticket &gt; <span class="number">0</span>&#123;</span><br><span class="line">			time.Sleep(<span class="number">10</span> * time.Millisecond)</span><br><span class="line">			ticket--</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%s 卖出一张票，余票: %d \n&quot;</span>,windowName,ticket)</span><br><span class="line">		&#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%s 票已卖完! \n&quot;</span>,windowName)</span><br><span class="line">			<span class="comment">// 解锁</span></span><br><span class="line">			mutex.Unlock()</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 解锁</span></span><br><span class="line">		mutex.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">  窗口C 卖出一张票，余票: 9 </span></span><br><span class="line"><span class="comment">  窗口C 卖出一张票，余票: 8 </span></span><br><span class="line"><span class="comment">  窗口B 卖出一张票，余票: 7 </span></span><br><span class="line"><span class="comment">  窗口A 卖出一张票，余票: 6 </span></span><br><span class="line"><span class="comment">  窗口C 卖出一张票，余票: 5 </span></span><br><span class="line"><span class="comment">  窗口B 卖出一张票，余票: 4 </span></span><br><span class="line"><span class="comment">  窗口A 卖出一张票，余票: 3 </span></span><br><span class="line"><span class="comment">  窗口C 卖出一张票，余票: 2 </span></span><br><span class="line"><span class="comment">  窗口B 卖出一张票，余票: 1 </span></span><br><span class="line"><span class="comment">  窗口A 卖出一张票，余票: 0 </span></span><br><span class="line"><span class="comment">  窗口C 票已卖完! </span></span><br><span class="line"><span class="comment">  窗口B 票已卖完! </span></span><br><span class="line"><span class="comment">  窗口A 票已卖完! </span></span><br><span class="line"><span class="comment">  运行结束!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>作为结构体属性使用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 声明一个票池</span></span><br><span class="line"><span class="keyword">type</span> ticketPool <span class="keyword">struct</span> &#123;</span><br><span class="line">	over <span class="type">int</span></span><br><span class="line">	lock sync.Mutex</span><br><span class="line">	wg   sync.WaitGroup</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义售票方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *ticketPool)</span></span> sellTicket(windowName <span class="type">string</span>) &#123;</span><br><span class="line">	<span class="comment">// 等待组减一</span></span><br><span class="line">	<span class="keyword">defer</span> t.wg.Done()</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 加锁</span></span><br><span class="line">		t.lock.Lock()</span><br><span class="line">		<span class="keyword">if</span> t.over &gt; <span class="number">0</span> &#123;</span><br><span class="line">			time.Sleep(<span class="number">10</span> * time.Millisecond)</span><br><span class="line">			t.over--</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%s 卖出一张票，余票: %d \n&quot;</span>, windowName, t.over)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 无票，跳无限循环并解锁</span></span><br><span class="line">			t.lock.Unlock()</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%s 票已卖完! \n&quot;</span>, windowName)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 正常售票流程解锁</span></span><br><span class="line">		t.lock.Unlock()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个票池</span></span><br><span class="line">	ticketP := ticketPool&#123;over: <span class="number">10</span>&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;T:%T v: %v \n&quot;</span>, ticketP, ticketP)</span><br><span class="line">	<span class="comment">// 设置窗口数量</span></span><br><span class="line">	windowNum := <span class="number">3</span></span><br><span class="line">	<span class="comment">// 设置等待组计数器</span></span><br><span class="line">	ticketP.wg.Add(windowNum)</span><br><span class="line">	<span class="comment">// 定义3个窗口售票</span></span><br><span class="line">	<span class="keyword">for</span> i:= <span class="number">1</span> ; i &lt;= windowNum; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> ticketP.sellTicket(<span class="string">&quot;窗口&quot;</span> + strconv.Itoa(i))</span><br><span class="line">	&#125;</span><br><span class="line">	ticketP.wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;运行结束!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">  窗口3 卖出一张票，余票: 9 </span></span><br><span class="line"><span class="comment">  窗口3 卖出一张票，余票: 8 </span></span><br><span class="line"><span class="comment">  窗口1 卖出一张票，余票: 7 </span></span><br><span class="line"><span class="comment">  窗口2 卖出一张票，余票: 6 </span></span><br><span class="line"><span class="comment">  窗口3 卖出一张票，余票: 5 </span></span><br><span class="line"><span class="comment">  窗口1 卖出一张票，余票: 4 </span></span><br><span class="line"><span class="comment">  窗口2 卖出一张票，余票: 3 </span></span><br><span class="line"><span class="comment">  窗口3 卖出一张票，余票: 2 </span></span><br><span class="line"><span class="comment">  窗口1 卖出一张票，余票: 1 </span></span><br><span class="line"><span class="comment">  窗口2 卖出一张票，余票: 0 </span></span><br><span class="line"><span class="comment">  窗口1 票已卖完! </span></span><br><span class="line"><span class="comment">  窗口2 票已卖完! </span></span><br><span class="line"><span class="comment">  窗口3 票已卖完! </span></span><br><span class="line"><span class="comment">  运行结束!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="读写锁-RWMutex"><a href="#读写锁-RWMutex" class="headerlink" title="读写锁(RWMutex)"></a>读写锁(RWMutex)</h2><p><strong>结构介绍</strong><br><code>RWMutex</code>是读写互斥锁，简称读写锁。该锁可以同时被多个读取者持有或被唯一个写入者持有。RWMutex类型锁跟Goroutine无关，可以由不同的Goroutine加锁、解锁。RWMutex也可以创建为其他结构体的字段；零值为解锁状态。</p>
<p><strong>RWMutex锁结构</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    w  Mutex <span class="comment">//用于控制多个写锁，获得写锁首先要获取该锁，如果有一个写锁在进行，那么再到来的写锁将会阻塞于此</span></span><br><span class="line">    writerSem  <span class="type">uint32</span> <span class="comment">//写阻塞等待的信号量，最后一个读者释放锁时会释放信号量</span></span><br><span class="line">    readerSem  <span class="type">uint32</span> <span class="comment">//读阻塞的协程等待的信号量，持有写锁的协程释放锁后会释放信号量</span></span><br><span class="line">    readerCount <span class="type">int32</span>  <span class="comment">//记录读者个数</span></span><br><span class="line">    readerWait  <span class="type">int32</span>  <span class="comment">//记录写阻塞时读者个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>读写锁堵塞场景</strong></p>
<table>
    <tr>
        <th>场景</th><th>描述</th>
    </tr>
    <tr>
        <td>写锁需要阻塞写锁</td><td>一个协程拥有写锁时，其他协程写锁需要阻塞</td>
    </tr>
    <tr>
        <td>写锁需要阻塞读锁</td><td>一个协程拥有写锁时，其他协程读锁需要阻塞</td>
    </tr>
    <tr>
        <td>读锁需要阻塞写锁</td><td>一个协程拥有读锁时，其他协程写锁需要阻塞</td>
    </tr>
    <tr>
        <td>读锁不能阻塞读锁</td><td>一个协程拥有读锁时，其他协程也可以拥有读锁</td>
    </tr>
</table>

<p><strong>方法列表</strong></p>
<table>
    <tr>
        <th>方法名</th><th>描述</th>
    </tr>
    <tr>
        <td>(rw *RWMutex) RLock()</td><td>获取读锁,当一个协程拥有读锁时，其他协程写锁需要阻塞</td>
    </tr>
    <tr>
        <td>(rw *RWMutex) RUnlock()</td><td>释放读锁</td>
    </tr>
    <tr>
        <td>(rw *RWMutex) Lock()</td><td>获取写锁，与Mutex完全一致</td>
    </tr>
    <tr>
        <td>(rw *RWMutex) Unlock()</td><td>释放写锁</td>
    </tr>
</table>

<p><strong>读写文件</strong><br>不作为结构体属性使用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 声明全局变量，文件内容</span></span><br><span class="line"><span class="keyword">var</span> fileContext <span class="type">string</span></span><br><span class="line"><span class="comment">// 声明全局读写互斥锁</span></span><br><span class="line"><span class="keyword">var</span> rxMutex sync.RWMutex</span><br><span class="line"><span class="comment">// 声明全局等待组</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 设置计数器</span></span><br><span class="line">	wg.Add(<span class="number">5</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">		name := <span class="string">&quot;同学-&quot;</span> + strconv.Itoa(i)</span><br><span class="line">		<span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">go</span> readFile(name)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">go</span> writeFile(name, strconv.Itoa(i))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 等待所有计数器执行完成</span></span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;运行结束!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">(name <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 释放读锁</span></span><br><span class="line">	<span class="keyword">defer</span> rxMutex.RUnlock()</span><br><span class="line">	<span class="comment">// 获取读锁</span></span><br><span class="line">	rxMutex.RLock()</span><br><span class="line">	<span class="comment">// 打印读取内容</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s 获取读锁，读取内容为: %s \n&quot;</span>, name, fileContext)</span><br><span class="line">	<span class="comment">// 计数器减一</span></span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeFile</span><span class="params">(name, s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 释放写锁</span></span><br><span class="line">	<span class="keyword">defer</span> rxMutex.Unlock()</span><br><span class="line">	<span class="comment">// 获取写锁</span></span><br><span class="line">	rxMutex.Lock()</span><br><span class="line">	<span class="comment">// 写入内容</span></span><br><span class="line">	fileContext = fileContext + <span class="string">&quot; &quot;</span> + s</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s 获取写锁，写入内容: %s。 文件内容变成: %s \n&quot;</span>, name, s, fileContext)</span><br><span class="line">	<span class="comment">// 计数器减一</span></span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">  同学-1 获取写锁，写入内容: 1。 文件内容变成:  1 </span></span><br><span class="line"><span class="comment">  同学-4 获取读锁，读取内容为:  1 </span></span><br><span class="line"><span class="comment">  同学-2 获取读锁，读取内容为:  1 </span></span><br><span class="line"><span class="comment">  同学-5 获取写锁，写入内容: 5。 文件内容变成:  1 5 </span></span><br><span class="line"><span class="comment">  同学-3 获取写锁，写入内容: 3。 文件内容变成:  1 5 3 </span></span><br><span class="line"><span class="comment">  运行结束!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>作为结构体属性使用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 定义一个文件结构体</span></span><br><span class="line"><span class="keyword">type</span> fileResource <span class="keyword">struct</span> &#123;</span><br><span class="line">	content <span class="type">string</span></span><br><span class="line">	wg sync.WaitGroup</span><br><span class="line">	rwLock sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *fileResource)</span></span>readFile(name <span class="type">string</span>) &#123;</span><br><span class="line">	<span class="comment">// 释放读锁</span></span><br><span class="line">	<span class="keyword">defer</span> f.rwLock.RUnlock()</span><br><span class="line">	<span class="comment">// 获取读锁</span></span><br><span class="line">	f.rwLock.RLock()</span><br><span class="line">	<span class="comment">// 打印读取内容</span></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s 获取读锁，读取内容为: %s \n&quot;</span>, name, f.content)</span><br><span class="line">	<span class="comment">// 计数器减一</span></span><br><span class="line">	f.wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *fileResource)</span></span>writeFile(name, s <span class="type">string</span>) &#123;</span><br><span class="line">	<span class="comment">// 释放写锁</span></span><br><span class="line">	<span class="keyword">defer</span> f.rwLock.Unlock()</span><br><span class="line">	<span class="comment">// 获取写锁</span></span><br><span class="line">	f.rwLock.Lock()</span><br><span class="line">	<span class="comment">// 写入内容</span></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	f.content = f.content + <span class="string">&quot; &quot;</span> + s</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s 获取写锁，写入内容: %s。 文件内容变成: %s \n&quot;</span>, name, s, f.content)</span><br><span class="line">	<span class="comment">// 计数器减一</span></span><br><span class="line">	f.wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 声明结构体</span></span><br><span class="line">	<span class="keyword">var</span> file fileResource</span><br><span class="line">	<span class="comment">// 设置计数器</span></span><br><span class="line">	file.wg.Add(<span class="number">5</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">		name := <span class="string">&quot;同学-&quot;</span> + strconv.Itoa(i)</span><br><span class="line">		<span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">go</span> file.readFile(name)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">go</span> file.writeFile(name, strconv.Itoa(i))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 等待所有计数器执行完成</span></span><br><span class="line">	file.wg.Wait()</span><br><span class="line">	fmt.Println(<span class="string">&quot;运行结束!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">  同学-5 获取写锁，写入内容: 5。 文件内容变成:  5 </span></span><br><span class="line"><span class="comment">  同学-1 获取写锁，写入内容: 1。 文件内容变成:  5 1 </span></span><br><span class="line"><span class="comment">  同学-2 获取读锁，读取内容为:  5 1 </span></span><br><span class="line"><span class="comment">  同学-3 获取写锁，写入内容: 3。 文件内容变成:  5 1 3 </span></span><br><span class="line"><span class="comment">  同学-4 获取读锁，读取内容为:  5 1 3 </span></span><br><span class="line"><span class="comment">  运行结束!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="条件变量-Cond"><a href="#条件变量-Cond" class="headerlink" title="条件变量(Cond)"></a>条件变量(Cond)</h2><p><strong>介绍</strong><br>与互斥锁不同，条件变量的作用并不是保证在同一时刻仅有一个线程访问某一个共享数据，而是在对应的共享数据的状态发生变化时，通知其他因此而被阻塞的线程。条件变量总是与互斥锁组合使用，互斥锁为共享数据的访问提供互斥支持，而条件变量可以就共享数据的状态的变化向相关线程发出通知。</p>
<p>使用场景:  我需要完成一项任务，但是这项任务需要满足一定条件才可以执行，否则我就等着。</p>
<p><strong>方法列表</strong></p>
<table>
    <tr>
        <th>方法名</th><th>描述</th>
    </tr>
    <tr>
        <td>NewCond(l Locker) *Cond</td><td>生成一个cond,需要传入实现Locker接口的变量，一般是*Mutex或*RWMutex类型的值</td>
    </tr>
    <tr>
        <td>(c *Cond) Wait()</td><td>等待通知</td>
    </tr>
    <tr>
        <td>(c *Cond) Signal()</td><td>发送单个通知</td>
    </tr>
    <tr>
        <td>(c *Cond) Broadcast()</td><td>广播(多个通知)</td>
    </tr>
</table>

<p><strong>使用示例</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 声明互斥锁</span></span><br><span class="line">	<span class="keyword">var</span> mutex sync.Mutex</span><br><span class="line">	<span class="comment">// 声明条件变量</span></span><br><span class="line">	cond := sync.NewCond(&amp;mutex)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="comment">// 获取锁</span></span><br><span class="line">			cond.L.Lock()</span><br><span class="line">			<span class="comment">// 释放锁</span></span><br><span class="line">			<span class="keyword">defer</span> cond.L.Unlock()</span><br><span class="line">			<span class="comment">// 等待通知,阻塞当前协程</span></span><br><span class="line">			cond.Wait()</span><br><span class="line">			<span class="comment">// 等待通知后打印输出</span></span><br><span class="line">			fmt.Printf(<span class="string">&quot;输出:%d ! \n&quot;</span>, i)</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 单个通知</span></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;单个通知A！&quot;</span>)</span><br><span class="line">	cond.Signal()</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;单个通知B！&quot;</span>)</span><br><span class="line">	cond.Signal()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 广播通知</span></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;广播通知！并睡眠1秒，等待其他协程输出!&quot;</span>)</span><br><span class="line">	cond.Broadcast()</span><br><span class="line">	<span class="comment">// 等待其他协程处理完</span></span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;运行结束！&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">  单个通知A！</span></span><br><span class="line"><span class="comment">  输出:1 ! </span></span><br><span class="line"><span class="comment">  单个通知B！</span></span><br><span class="line"><span class="comment">  输出:4 ! </span></span><br><span class="line"><span class="comment">  广播通知！并睡眠1秒，等待其他协程输出!</span></span><br><span class="line"><span class="comment">  输出:10 ! </span></span><br><span class="line"><span class="comment">  输出:2 ! </span></span><br><span class="line"><span class="comment">  输出:3 ! </span></span><br><span class="line"><span class="comment">  输出:8 ! </span></span><br><span class="line"><span class="comment">  输出:9 ! </span></span><br><span class="line"><span class="comment">  输出:6 ! </span></span><br><span class="line"><span class="comment">  输出:5 ! </span></span><br><span class="line"><span class="comment">  输出:7 ! </span></span><br><span class="line"><span class="comment">  运行结束！</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="一次-Once"><a href="#一次-Once" class="headerlink" title="一次(Once)"></a>一次(Once)</h2><p><code>sync.Once</code> 是使Go方法只执行一次的对象实现，作用与 init 函数类似,但也有所不同。区别如下:</p>
<p><code>init</code> 函数是在文件包首次被加载的时候执行，且只执行一次<br><code>sync.Onc</code> 是在代码运行中需要的时候执行，且只执行一次</p>
<p><strong>方法介绍</strong></p>
<table>
    <tr>
        <th>方法名</th><th>描述</th>
    </tr>
    <tr>
        <td>(o *Once) Do(f func())</td><td>函数只会执行一次，并保证在返回时，传入Do的函数已经执行完成。</td>
    </tr>
</table>
多个 goroutine 同时执行 once.Do 的时候，可以保证抢占到 once.Do 执行权的 goroutine 执行完 once.Do 后，其他goroutine才能得到返回 。

<p><strong>重复调用只执行一次</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	echo := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		t := time.Now().Unix()</span><br><span class="line">		fmt.Printf(<span class="string">&quot;输出时间 %v &quot;</span>,strconv.FormatInt(t,<span class="number">10</span>))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> one sync.Once</span><br><span class="line">  <span class="comment">// 虽然遍历调用，但是只会执行一次</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i&lt; <span class="number">10</span> ; i++  &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(a,b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			one.Do(echo)</span><br><span class="line">		&#125;(i,i+<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;运行结束！&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">  输出时间 1608083525 </span></span><br><span class="line"><span class="comment">  运行结束！</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="对象池-Pool"><a href="#对象池-Pool" class="headerlink" title="对象池(Pool)"></a>对象池(Pool)</h2><p><strong>为什么使用?</strong><br>Go语言是支持垃圾自动回收的。对于一些暂时用不到但是后续会用到的对象，为了提升性能，可以先暂存起来，这虽然会占用一些内存，但是比起销毁了再新建，要节省运行时间。Go语言专门提供了暂存对象的工具，就是sync.Pool。</p>
<p><code>sync.Pool</code>是一个对象池，它是并发安全的，而且大小是可伸缩的，仅受限于内存。当需要使用对象的时候可以从对象池中直接取出使用。</p>
<p><strong>数据结构</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">	noCopy noCopy <span class="comment">//禁止复制</span></span><br><span class="line">	local     unsafe.Pointer <span class="comment">//本地缓冲池指针,每个处理器分配一个;其类型是[P]poolLocal数组</span></span><br><span class="line">	localSize <span class="type">uintptr</span> <span class="comment">//数组大小</span></span><br><span class="line"></span><br><span class="line">	victim     unsafe.Pointer <span class="comment">// local from previous cycle</span></span><br><span class="line">	victimSize <span class="type">uintptr</span>        <span class="comment">// size of victims array</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 缓存池没有对象时,调用此方法创建</span></span><br><span class="line">	New <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法列表</strong><br>sync.Pool提供以下两个公共方法，用来操作对象池。</p>
<table>
    <tr>
        <th>方法名</th><th>描述</th>
    </tr>
    <tr>
        <td>(p *Pool) Put(x interface{})</td><td>向池中添加对象</td>
    </tr>
    <tr>
        <td>(p *Pool) Get() interface{}</td><td>从池中获取对象</td>
    </tr>
</table>

<p>Get方法是从池中获取对象，如果没有对象则调用New方法创建生成，如果未设置New则返回nil。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建对象池</span></span><br><span class="line">	pool := sync.Pool&#123;</span><br><span class="line">		New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">make</span>([]<span class="type">string</span>,<span class="number">5</span>)</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 首次获取</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;不设置直接获取: %v\n&quot;</span>,pool.Get())</span><br><span class="line">	<span class="comment">// 设置后获取</span></span><br><span class="line">	pool.Put([]<span class="type">string</span>&#123;<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;Word&quot;</span>&#125;)</span><br><span class="line">	<span class="comment">// 设置后获取</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;设置后,第一次获取: %v\n&quot;</span>,pool.Get())</span><br><span class="line">	fmt.Printf(<span class="string">&quot;设置后,第二次获取: %v\n&quot;</span>,pool.Get())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意事项</strong><br>存入sync.Pool的对象可能会在不通知的情况下被释放，这一点一定要注意。比如一些socket长连接就不适合存入sync.Pool内。</p>
<h2 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h2><p>如果要缓存的数据量不大，可以考虑使用sync.Map(Go 1.9+版本支持)。在1.6版本以前，Go语言自带标准的map类型是并发读安全的，但是并发写不安全。</p>
<h3 id="查询和新增"><a href="#查询和新增" class="headerlink" title="查询和新增"></a>查询和新增</h3><p><strong>查找方法</strong><br><code>Load</code>: 通过参数key查询对应的value，如果不存在则返回nil；ok表示是否找到对应的值。</p>
<p><strong>新增方法</strong><br><code>Store</code>: 对sync.Map的更新或新增，参数是键值对<br><code>LoadOrStore</code>: 参数为key和value。根据参数key查找对应的value，如果找到,则不修改原来的值并通过actual返回，并且loaded为true；如果未找到，则存储key-value并且将存储的value通过actual返回，loaded为false。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 定义map 类型</span></span><br><span class="line">	<span class="keyword">var</span> syncMap sync.Map</span><br><span class="line">	<span class="comment">// 新增</span></span><br><span class="line">	syncMap.Store(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;张三&quot;</span>)</span><br><span class="line">	load, _ := syncMap.Load(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Store新增-&gt;name:%v\n&quot;</span>,load)</span><br><span class="line">	<span class="comment">// 找到则不更新，返回旧值</span></span><br><span class="line">	store, loaded := syncMap.LoadOrStore(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;李四&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;找到则返回旧值-&gt; name:%v loaded:%v \n&quot;</span>,store,loaded)</span><br><span class="line">	<span class="comment">// 找不到则新增</span></span><br><span class="line">	age, loaded := syncMap.LoadOrStore(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;找不到则新增-&gt; age:%v loaded:%v \n&quot;</span>,age,loaded)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出:</span></span><br><span class="line"><span class="comment">Store新增-&gt;name:张三</span></span><br><span class="line"><span class="comment">找到则返回旧值-&gt; name:张三 loaded:true </span></span><br><span class="line"><span class="comment">找不到则新增-&gt; age:20 loaded:false </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><code>LoadAndDelete</code>: 根据参数key删除对应的value，如果找到则删除，并通过value返回删除的值，并设置loaded为true；如果未找到，则value返回nil，loaded为false。<br><code>Delete</code>：根据参数key删除对应的value。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 定义map 类型</span></span><br><span class="line">	<span class="keyword">var</span> syncMap sync.Map</span><br><span class="line">	<span class="comment">// 新增</span></span><br><span class="line">	syncMap.Store(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;张三&quot;</span>)</span><br><span class="line">	syncMap.Store(<span class="string">&quot;age&quot;</span>,<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 找到情况</span></span><br><span class="line">	andDelete, loaded := syncMap.LoadAndDelete(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;找到-&gt; val:%v loaded:%v \n&quot;</span>,andDelete,loaded)</span><br><span class="line">	search, ok := syncMap.Load(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;删除name后查找-&gt; search:%v ok:%v \n&quot;</span>,search,ok)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 找不到情况</span></span><br><span class="line">	andDelete2, loaded := syncMap.LoadAndDelete(<span class="string">&quot;name2&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;找不到-&gt; val:%v loaded:%v \n&quot;</span>,andDelete2,loaded)</span><br><span class="line"></span><br><span class="line">	syncMap.Delete(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">	searchAge, ok := syncMap.Load(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;删除age后查找-&gt; searchAge:%v ok:%v \n&quot;</span>,searchAge,ok)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 输出</span></span><br><span class="line"><span class="comment">找到-&gt; val:张三 loaded:true </span></span><br><span class="line"><span class="comment">删除name后查找-&gt; search:&lt;nil&gt; ok:false </span></span><br><span class="line"><span class="comment">找不到-&gt; val:&lt;nil&gt; loaded:false </span></span><br><span class="line"><span class="comment">删除age后查找-&gt; searchAge:&lt;nil&gt; ok:false </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>sync.Map不能通过for…range遍历，只能通过包提供的方法Range进行遍历。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 定义map 类型</span></span><br><span class="line">	<span class="keyword">var</span> syncMap sync.Map</span><br><span class="line">	<span class="comment">// 新增</span></span><br><span class="line">	syncMap.Store(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>)</span><br><span class="line">	syncMap.Store(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>)</span><br><span class="line">	syncMap.Store(<span class="string">&quot;home&quot;</span>, <span class="string">&quot;天津永和大区&quot;</span>)</span><br><span class="line">	syncMap.Range(<span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;key: %v value: %v \n&quot;</span>, key, value)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">key: name value: 张三 </span></span><br><span class="line"><span class="comment">key: age value: 20 </span></span><br><span class="line"><span class="comment">key: home value: 天津永和大区 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>context包使用</title>
    <url>/2021/04/27/context%E5%8C%85%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="什么是上下文"><a href="#什么是上下文" class="headerlink" title="什么是上下文?"></a>什么是上下文?</h2><blockquote>
<p>从Go 1.7开始, 标准库引入context(上下文)，他主要用来在goroutine之间传递上下文信息(同步信号、超时时间、截止时间、Key-Val值对)。</p>
</blockquote>
<span id="more"></span>

<h2 id="为什么要用上下文"><a href="#为什么要用上下文" class="headerlink" title="为什么要用上下文?"></a>为什么要用上下文?</h2><p><strong>场景说明</strong><br>在实际开发过程中，我们往往会在main.goroutine(主协程)中开启N 个goroutine(子协程)来处理其他逻辑，那么主协程和 子协程之间信号怎么同步呢？列举以下几个需要信号同步的场景。</p>
<p>当主协程报错或者因为其他原因需要取消时，需要通知子协程取消任务。<br>创建子协程时,希望指定超时时间或截止时间后，自动取消任务。</p>
<p><strong>怎么解决？</strong><br>context 包提供了一些函数，协助用户从现有的 Context 对象创建新的 Context 对象。<br>这些 Context 对象形成一棵树：当一个 Context 对象被取消时，继承自它的所有 Context 都会被取消。</p>
<p>Background 是所有 Context 对象树的根，它不能被取消。</p>
<h2 id="上下文接口"><a href="#上下文接口" class="headerlink" title="上下文接口"></a>上下文接口</h2><p>context包中定义了一个接口context.Context,具体定义代码如下:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="comment">// deadline: 返回取消的时间点(到点Context会自动取消请求)</span></span><br><span class="line">  <span class="comment">// ok：false代表没有设置截止时间</span></span><br><span class="line">	Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 返回一个只读的Chan</span></span><br><span class="line">  <span class="comment">// 这个Channel 会在当前工作完成或者上下文被取消后关闭,</span></span><br><span class="line">  <span class="comment">// 多次调用 Done 方法会返回同一个 Channel；</span></span><br><span class="line">	Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//返回 context.Context 结束的原因，</span></span><br><span class="line">  <span class="comment">// 它只会在 Done 方法对应的 Channel 关闭时返回非空的值；</span></span><br><span class="line">	Err() <span class="type">error</span></span><br><span class="line">	<span class="comment">// 从 context.Context 中获取键对应的值</span></span><br><span class="line">  <span class="comment">// 对于同一个上下文来说，多次调用 Value 并传入相同的 Key 会返回相同的结果</span></span><br><span class="line">	Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建父上下文"><a href="#创建父上下文" class="headerlink" title="创建父上下文"></a>创建父上下文</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span></span> Context &#123;</span><br><span class="line">	<span class="keyword">return</span> background</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TODO</span><span class="params">()</span></span> Context &#123;</span><br><span class="line">	<span class="keyword">return</span> todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>context</code> 包中最常用的方法是 <code>context.Background</code>、<code>context.TODO</code>，这两个方法都会返回预先初始化好的私有变量 <code>background</code> 和 <code>todo</code>,使用区别如下:<br><code>Background</code>: 主要用于main函数、初始化以及测试代码中，作为最顶层的Context，也就是根Context。<br><code>TODO</code>: 当我们不知道该使用什么类型的Context的时候，可以使用这个。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 基于context.Background()为根，创建新的超时上下文</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Begin:%s\n&quot;</span>, time.Now())</span><br><span class="line">	timeoutCtx, cancelFunc := context.WithTimeout(context.Background(), <span class="number">3</span>*time.Second)</span><br><span class="line">	<span class="comment">// 3秒后自动取消</span></span><br><span class="line">	<span class="keyword">defer</span> cancelFunc()</span><br><span class="line">	<span class="comment">// 子协程执行取消</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;子协程输出...&quot;</span>)</span><br><span class="line">	&#125;(timeoutCtx)</span><br><span class="line">	<span class="comment">// 等待上下文处于完成状态</span></span><br><span class="line">	&lt;-timeoutCtx.Done()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;等待超时结束：%s \n&quot;</span>, time.Now())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出()</span></span><br><span class="line"><span class="comment">Begin:2021-04-19 17:10:26.625493 +0800 CST m=+0.000780950</span></span><br><span class="line"><span class="comment">子协程输出...</span></span><br><span class="line"><span class="comment">等待超时结束：2021-04-19 17:10:29.627471 +0800 CST m=+3.002727432 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="创建子上下文"><a href="#创建子上下文" class="headerlink" title="创建子上下文"></a>创建子上下文</h2><h3 id="可取消的-WithCancel"><a href="#可取消的-WithCancel" class="headerlink" title="可取消的(WithCancel)"></a>可取消的(WithCancel)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// parent 父上下文</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc)</span><br></pre></td></tr></table></figure>

<p><code>context.WithCancel</code> 函数能够从 <code>context.Context</code> 中衍生出一个新的子上下文并返回用于取消该上下文的函数。一旦我们执行返回的取消函数，当前上下文以及它的子上下文都会被取消，所有的 Goroutine 都会同步收到这一取消信号。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Begin:%s\n&quot;</span>, time.Now())</span><br><span class="line">	<span class="comment">// 基于context.Background()为根，创建一个可取消的子Context</span></span><br><span class="line">	cancelCtx, cancelFunc := context.WithCancel(context.Background())</span><br><span class="line">	<span class="comment">// 子协程执行取消</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">				fmt.Println(<span class="string">&quot;子协程终止,上下文已被取消&quot;</span>)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">				fmt.Printf(<span class="string">&quot;%s: 子协程输出\n&quot;</span>, time.Now())</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(cancelCtx)</span><br><span class="line">	<span class="comment">// 3秒后执行取消操作</span></span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">	<span class="comment">// 取消上下文，子协程也会停止输出</span></span><br><span class="line">	cancelFunc()</span><br><span class="line">	<span class="comment">// 看看子协程是否停止</span></span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;End：%s \n&quot;</span>, time.Now())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出</span></span><br><span class="line"><span class="comment">Begin:2021-04-20 11:08:29.77314 +0800 CST m=+0.000635148</span></span><br><span class="line"><span class="comment">2021-04-20 11:08:30.776474 +0800 CST m=+1.003963915: 子协程输出</span></span><br><span class="line"><span class="comment">2021-04-20 11:08:31.780469 +0800 CST m=+2.007953399: 子协程输出</span></span><br><span class="line"><span class="comment">2021-04-20 11:08:32.781569 +0800 CST m=+3.009048079: 子协程输出</span></span><br><span class="line"><span class="comment">子协程终止,上下文已被取消</span></span><br><span class="line"><span class="comment">End：2021-04-20 11:08:33.778543 +0800 CST m=+4.006016052 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="指定超时时间-WithTimeout"><a href="#指定超时时间-WithTimeout" class="headerlink" title="指定超时时间(WithTimeout)"></a>指定超时时间(WithTimeout)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc)</span><br></pre></td></tr></table></figure>
<p><code>context.WithTimeout</code> 函数接收父上下文(parent)和一个超时时间，能够从 <code>context.Context </code>中衍生出一个新的子上下文并返回用于取消该上下文的函数。执行取消函数时功能和WithCancel一样。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;context&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 等待超时，自动取消</span></span><br><span class="line">	waitTimeOut()</span><br><span class="line">	<span class="comment">// 子协程主动发送取消信号</span></span><br><span class="line">	subSendCancel()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待超时，自动取消</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">waitTimeOut</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;等待超时——&gt; Begin:%s\n&quot;</span>, time.Now())</span><br><span class="line">	<span class="comment">// 基于context.Background()为根，创建一个3秒后自动取消的子Context</span></span><br><span class="line">	ctx, cancelFunc := context.WithTimeout(context.Background(), <span class="number">3</span>*time.Second)</span><br><span class="line">	<span class="comment">// 延迟关闭</span></span><br><span class="line">	<span class="keyword">defer</span> cancelFunc()</span><br><span class="line">	<span class="comment">// 创建子协程</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">				fmt.Println(<span class="string">&quot;子协程收到取消信号，终止&quot;</span>)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">				fmt.Printf(<span class="string">&quot;子协程输出:%s\n&quot;</span>, time.Now())</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(ctx)</span><br><span class="line">	<span class="comment">// 等待超时，自动取消</span></span><br><span class="line">	&lt;-ctx.Done()</span><br><span class="line">	<span class="comment">// 超时后，查看子协程输出</span></span><br><span class="line">	time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;End：%s \n&quot;</span>, time.Now())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子协程主动发送取消信号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subSendCancel</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;子协程主动发送取消信号——&gt; Begin:%s\n&quot;</span>, time.Now())</span><br><span class="line">	<span class="comment">// 基于context.Background()为根，创建一个可取消的子Context</span></span><br><span class="line">	cancelCtx, cancelFunc := context.WithTimeout(context.Background(), <span class="number">5</span>*time.Second)</span><br><span class="line">	<span class="comment">// 创建子协程</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(cancelFunc context.CancelFunc)</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;子协程发送-&gt;取消信号&quot;</span>)</span><br><span class="line">		cancelFunc()</span><br><span class="line">	&#125;(cancelFunc)</span><br><span class="line">	<span class="comment">// 同步阻塞</span></span><br><span class="line">	&lt;-cancelCtx.Done()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;End：%s \n&quot;</span>, time.Now())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">等待超时——&gt; Begin:2021-04-20 11:43:59.232983 +0800 CST m=+0.000634095</span></span><br><span class="line"><span class="comment">子协程输出:2021-04-20 11:44:00.237187 +0800 CST m=+1.004832384</span></span><br><span class="line"><span class="comment">子协程输出:2021-04-20 11:44:01.240217 +0800 CST m=+2.007856775</span></span><br><span class="line"><span class="comment">子协程输出:2021-04-20 11:44:02.24042 +0800 CST m=+3.008054083</span></span><br><span class="line"><span class="comment">子协程收到取消信号，终止</span></span><br><span class="line"><span class="comment">End：2021-04-20 11:44:04.239543 +0800 CST m=+5.007166176 </span></span><br><span class="line"><span class="comment">子协程主动发送取消信号——&gt; Begin:2021-04-20 11:44:04.239701 +0800 CST m=+5.007323972</span></span><br><span class="line"><span class="comment">子协程发送-&gt;取消信号</span></span><br><span class="line"><span class="comment">End：2021-04-20 11:44:04.239809 +0800 CST m=+5.007432189 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="指定截止时间-WithDeadline"><a href="#指定截止时间-WithDeadline" class="headerlink" title="指定截止时间(WithDeadline)"></a>指定截止时间(WithDeadline)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span></span> (Context, CancelFunc) </span><br></pre></td></tr></table></figure>
<p><code>context.WithDeadline</code> 函数接收父上下文(parent)和一个截止时间，能够从 <code>context.Context</code> 中衍生出一个新的子上下文并返回用于取消该上下文的函数。执行取消函数时功能和WithCancel一样。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Begin:%s\n&quot;</span>, time.Now())</span><br><span class="line">	<span class="comment">// 基于context.Background()为根，创建一个5秒后自动取消的子Context</span></span><br><span class="line">	deadlineCtx, cancelFunc := context.WithDeadline(context.Background(), time.Now().Add(<span class="number">3</span>*time.Second))</span><br><span class="line">	<span class="keyword">defer</span> cancelFunc()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span>  &#123;</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">				fmt.Println(<span class="string">&quot;子协程终止,上下文已被取消&quot;</span>)</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">				fmt.Printf(<span class="string">&quot;子协程输出: %s\n&quot;</span>,time.Now())</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(deadlineCtx)</span><br><span class="line">	<span class="comment">// 同步阻塞，直到上下文被完成或取消</span></span><br><span class="line">	&lt;-deadlineCtx.Done()</span><br><span class="line">	<span class="comment">// 查看子协程是否收到取消信号</span></span><br><span class="line">	time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;End：%s \n&quot;</span>, time.Now())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">Begin:2021-04-20 13:54:56.224477 +0800 CST m=+0.000826415</span></span><br><span class="line"><span class="comment">子协程输出: 2021-04-20 13:54:57.227495 +0800 CST m=+1.003830376</span></span><br><span class="line"><span class="comment">子协程输出: 2021-04-20 13:54:58.229607 +0800 CST m=+2.005927050</span></span><br><span class="line"><span class="comment">子协程输出: 2021-04-20 13:54:59.230173 +0800 CST m=+3.006503681</span></span><br><span class="line"><span class="comment">子协程输出: 2021-04-20 13:55:00.233766 +0800 CST m=+4.010057104</span></span><br><span class="line"><span class="comment">子协程终止,上下文已被取消</span></span><br><span class="line"><span class="comment">End：2021-04-20 13:55:00.233781 +0800 CST m=+4.010072336 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="上下文中传值"><a href="#上下文中传值" class="headerlink" title="上下文中传值"></a>上下文中传值</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// parent:父上下文</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span></span> Context </span><br></pre></td></tr></table></figure>
<p><code>context.WithValue</code> 能从父 Context中创建一个子子 Context,并传体一个键值对信息给子 Context，在子 Context中，通过context.Value获取对应的值信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Begin:%s\n&quot;</span>, time.Now())</span><br><span class="line">	<span class="comment">// 基于context.Background()为根，创建一个5秒后自动取消的子Context</span></span><br><span class="line">	parentCtx, cancelFunc := context.WithCancel(context.Background())</span><br><span class="line">	<span class="comment">// 传体信息</span></span><br><span class="line">	valueCtx := context.WithValue(parentCtx, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>)</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, cancelFunc2 context.CancelFunc)</span></span> &#123;</span><br><span class="line">		<span class="comment">// 取出上下文中key=name的值</span></span><br><span class="line">		fmt.Printf(<span class="string">&quot;取出上下文中的name: %v\n&quot;</span>, ctx.Value(<span class="string">&quot;name&quot;</span>))</span><br><span class="line">		<span class="comment">// 子协程发送取消信号</span></span><br><span class="line">		cancelFunc()</span><br><span class="line">	&#125;(valueCtx, cancelFunc)</span><br><span class="line">	<span class="comment">// 等待工作完成或者上下文被取消</span></span><br><span class="line">	&lt;-parentCtx.Done()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;End：%s \n&quot;</span>, time.Now())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">Begin:2021-04-20 14:15:57.243469 +0800 CST m=+0.000674192</span></span><br><span class="line"><span class="comment">取出上下文中的name: 张三</span></span><br><span class="line"><span class="comment">End：2021-04-20 14:15:57.243699 +0800 CST m=+0.000904753 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>bufio包使用</title>
    <url>/2021/04/26/bufio%E5%8C%85%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote>
<p>bufio包实现了有缓冲的I/O。它包装一个io.Reader或io.Writer接口对象，使用这个包可以大幅提高文件读写的效率。</p>
</blockquote>
<span id="more"></span>

<h2 id="如何提高效率"><a href="#如何提高效率" class="headerlink" title="如何提高效率?"></a>如何提高效率?</h2><p><img src="9c1c4f918059c695ae7814b606b654bdd3800fe60c5fa57c4c590c42f8035381.png" alt="图 1">  </p>
<p><strong>写入流程梳理</strong>:<br>当写入内容小于缓冲区(buf)的可用大小时,内容写入缓存区(buf)；<br>当缓冲区(buf)空间不够时，一次性将缓冲区(buf)内容写入文件,并清空缓存区(buf)；<br>当写入内容大于缓冲区(buf)空间时，将内容直接写入文件；</p>
<p><strong>读取流程梳理</strong>:<br>当缓冲区(buf)内容为空时，一次性从文件中读取大小等于缓冲区(buf)的内容；<br>当读取内容小于缓冲区(buf)空间时,从缓存区(buf)读取；<br>当读取内容大于缓冲区(buf)空间时，将内容从文件直接读取；</p>
<p><strong>总结</strong>:  避免频繁操作文件、减少访问本地磁盘次数，从而提高效率。</p>
<h2 id="读取-Read"><a href="#读取-Read" class="headerlink" title="读取(Read*)"></a>读取(Read*)</h2><h3 id="创建读取器"><a href="#创建读取器" class="headerlink" title="创建读取器"></a>创建读取器</h3><p><strong>创建默认缓冲大小 (NewReader)</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(rd io.Reader)</span></span> *Reader</span><br></pre></td></tr></table></figure>
<p>根据rd创建一个具有默认大小缓冲的*Reader。默认大小:4096字节</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">reader := bufio.NewReader(strings.NewReader(<span class="string">&quot;hello Word&quot;</span>))</span><br><span class="line">fmt.Printf(<span class="string">&quot;默认大小:%v&quot;</span>,reader.Size())</span><br><span class="line"><span class="comment">// 输出: 默认大小:4096</span></span><br></pre></td></tr></table></figure>

<p><strong>创建指定缓冲大小( NewReaderSize)</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReaderSize</span><span class="params">(rd io.Reader, size <span class="type">int</span>)</span></span> *Reader</span><br></pre></td></tr></table></figure>
<p>根据rd创建指定size大小缓冲的*Reader。最小大小为16字节</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">reader := bufio.NewReaderSize(strings.NewReader(<span class="string">&quot;hello Word&quot;</span>),<span class="number">40</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;大于16字节:%v\n&quot;</span>,reader.Size())</span><br><span class="line">reader2 := bufio.NewReaderSize(strings.NewReader(<span class="string">&quot;hello Word&quot;</span>),<span class="number">4</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;小于16字节:%v\n&quot;</span>,reader2.Size())</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">大于16字节:40</span></span><br><span class="line"><span class="comment">小于16字节:16</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="读取指定字节-Read"><a href="#读取指定字节-Read" class="headerlink" title="读取指定字节(Read)"></a>读取指定字节(Read)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span></span> Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p>将读取数据写入p。返回写入p的字节数和错误信息。当读取到达结尾时，返回值n将为0而err将为io.EOF。</p>
<p>现有文件a.txt,内容如下:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">张三 23 北京 男</span><br><span class="line">李四 22 南京 男</span><br><span class="line">郭明 32 上海 男</span><br><span class="line">王英 18 武汉 女</span><br></pre></td></tr></table></figure>

<p>读取程序如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">//打开一个文件</span></span><br><span class="line">	file, err := os.Open(<span class="string">&quot;./a.txt&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 关闭文件</span></span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	<span class="comment">// 创建读取器</span></span><br><span class="line">	reader := bufio.NewReader(file)</span><br><span class="line">	<span class="keyword">for</span>  &#123;</span><br><span class="line">		<span class="comment">// 一次读取21个字节</span></span><br><span class="line">		context := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">21</span>)</span><br><span class="line">		_, err = reader.Read(context)</span><br><span class="line">		<span class="comment">// 读取完毕，则跳出</span></span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;读取内容:%s&quot;</span>, context)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出</span></span><br><span class="line"><span class="comment">读取内容:张三 23 北京 男</span></span><br><span class="line"><span class="comment">读取内容:李四 22 南京 男</span></span><br><span class="line"><span class="comment">读取内容:郭明 32 上海 男</span></span><br><span class="line"><span class="comment">读取内容:王英 18 武汉 女</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="读取一个字节-ReadByte"><a href="#读取一个字节-ReadByte" class="headerlink" title="读取一个字节(ReadByte)"></a>读取一个字节(ReadByte)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span></span> ReadByte() (<span class="type">byte</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p>每次读取一个字节返回。当读取到达结尾时，返回值n将为0而err将为io.EOF。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 基于字符串创建读取器</span></span><br><span class="line">	reader := bufio.NewReader(strings.NewReader(<span class="string">&quot;Go,Word!&quot;</span>))</span><br><span class="line">	<span class="keyword">for</span>  &#123;</span><br><span class="line">		<span class="comment">// 一次读取1个字节</span></span><br><span class="line">		readByte, err := reader.ReadByte()</span><br><span class="line">		<span class="comment">// 读取完毕，则跳出</span></span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;读取内容:%s\n&quot;</span>, <span class="type">string</span>(readByte))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">读取内容:G</span></span><br><span class="line"><span class="comment">读取内容:o</span></span><br><span class="line"><span class="comment">读取内容:,</span></span><br><span class="line"><span class="comment">读取内容:W</span></span><br><span class="line"><span class="comment">读取内容:o</span></span><br><span class="line"><span class="comment">读取内容:r</span></span><br><span class="line"><span class="comment">读取内容:d</span></span><br><span class="line"><span class="comment">读取内容:!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="读取一行-ReadLine"><a href="#读取一行-ReadLine" class="headerlink" title="读取一行(ReadLine)"></a>读取一行(ReadLine)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span></span> ReadLine() (line []<span class="type">byte</span>, isPrefix <span class="type">bool</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p><code>ReadLine</code>尝试读取返回一行数据，不包括行尾标志的字节,但是有以下几个场景需要注意:</p>
<p>如果行太长超过了缓冲，返回值isPrefix=true,Line为行的前一部分。<br>该行剩下部分将在下一次读取中返回并且此时的isPrefix=false,<strong>即isPrefix会在行的最后一个片段时才设为false</strong>。<br>如果行内小于等于缓冲,isPrefix=false,Line为一整行的内容。<br>官方文档中推荐使用 <code>ReadBytes</code>(‘\n’)或<code>ReadString</code>(‘\n’)来代替ReadLine。</p>
<p><strong>当行超过了缓冲缓存时</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建字符串，每行超过16个字节</span></span><br><span class="line">	str := strings.Repeat(<span class="string">&quot;Hello,Hello,Hello,Hello!\n&quot;</span>, <span class="number">3</span>)</span><br><span class="line">	<span class="comment">// 基于字符串创建一个缓冲区=16字节的读取器</span></span><br><span class="line">	reader := bufio.NewReaderSize(strings.NewReader(str), <span class="number">16</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 每次读取一行</span></span><br><span class="line">		line, prefix, err := reader.ReadLine()</span><br><span class="line">		<span class="comment">// 读取完毕，则跳出</span></span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;line:%s isPrefix:%t \n&quot;</span>, line, prefix)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:<br><img src="100d5bb2c02b34eac47eea2aa1738aadf03ba71c8a708bc855081f988cd06d93.png" alt="图 4">  </p>
<p><strong>当行小于缓冲缓存时</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 每行不超过16个字节</span></span><br><span class="line">	str := strings.Repeat(<span class="string">&quot;Hello Word!\n&quot;</span>, <span class="number">3</span>)</span><br><span class="line">	<span class="comment">// 基于字符串创建读取器</span></span><br><span class="line">	reader := bufio.NewReaderSize(strings.NewReader(str), <span class="number">16</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 每次读取一行</span></span><br><span class="line">		line, prefix, err := reader.ReadLine()</span><br><span class="line">		<span class="comment">// 读取完毕，则跳出</span></span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;line:%s isPrefix:%t \n&quot;</span>, line, prefix)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:<br><img src="5d468f8e153fe27014650ee38ec32342ea7eae6a63fd65b0d802ec42a5924cbf.png" alt="图 3">  </p>
<h3 id="读取到指定的字符"><a href="#读取到指定的字符" class="headerlink" title="读取到指定的字符"></a>读取到指定的字符</h3><p><strong>同类方法列表</strong></p>
<table>
    <tr>
        <th>方法</th><th>无delim是否报错</th>
    </tr>
    <tr>
        <td>ReadSlice(delim byte) (line []byte, err error)</td><td>报错(bufio: buffer full)</td>
    </tr>
    <tr>
        <td>ReadBytes(delim byte) ([]byte, error)/td></td><td>不会</td>
    </tr>
    <tr>
        <td>ReadString(delim byte) (string, error)</td><td>不会</td>
    </tr>
</table>

<p><strong>每次读取到字符delim(包含)</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 基于字符串创建读取器</span></span><br><span class="line">	reader := bufio.NewReaderSize(strings.NewReader(<span class="string">&quot;Go,PHP,Java,Python,C&quot;</span>), <span class="number">16</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 读取</span></span><br><span class="line">		s, err := reader.ReadString(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">		<span class="comment">// 读取完毕，则跳出</span></span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;err:%s&quot;</span>, err.Error())</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, s)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">Go,</span></span><br><span class="line"><span class="comment">PHP,</span></span><br><span class="line"><span class="comment">Java,</span></span><br><span class="line"><span class="comment">Python,</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>上述例子中C后面没有<code>,</code>,所以不会读出</p>
<p><strong>模拟每次读取一行</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 设置每行超过缓冲区大小</span></span><br><span class="line">	repeat := strings.Repeat(<span class="string">&quot;Hello,Hello,Hello,Hello\n&quot;</span>, <span class="number">3</span>)</span><br><span class="line">	<span class="comment">// 基于字符串创建读取器</span></span><br><span class="line">	reader := bufio.NewReaderSize(strings.NewReader(repeat), <span class="number">16</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 读取</span></span><br><span class="line">		s, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		<span class="comment">// 读取完毕，则跳出</span></span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;err:%s&quot;</span>, err.Error())</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%s&quot;</span>, s)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 输出</span></span><br><span class="line"><span class="comment">Hello,Hello,Hello,Hello</span></span><br><span class="line"><span class="comment">Hello,Hello,Hello,Hello</span></span><br><span class="line"><span class="comment">Hello,Hello,Hello,Hello</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>虽然每行超过缓冲区大小，但是依然可以整行读出</p>
<h3 id="每次读取前几个字节-Peek"><a href="#每次读取前几个字节-Peek" class="headerlink" title="每次读取前几个字节(Peek)"></a>每次读取前几个字节(Peek)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span></span> Peek(n <span class="type">int</span>) ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p>每次读取输入流的前n个字节，<strong>且不会移动读取位置</strong>,所以当输入流不变时，每次读取都是一样的。<br>当内容小于n时，error会返回io.EOF<br>当n大于缓冲区大小时，error会返回ErrBufferFull</p>
<p><strong>内容小于n时</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 基于字符串创建读取器</span></span><br><span class="line">	reader := bufio.NewReaderSize(strings.NewReader(<span class="string">&quot;hello&quot;</span>), <span class="number">16</span>)</span><br><span class="line">	<span class="comment">// 读取</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">		s, err := reader.Peek(<span class="number">16</span>)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;结果: %s &quot;</span>, s)</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, <span class="string">&quot;已读完&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;err:%s\n&quot;</span>, err.Error())</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出-&gt; 结果: hello 已读完</span></span><br></pre></td></tr></table></figure>

<p><strong>当n大于缓冲区大小时</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 基于字符串创建读取器</span></span><br><span class="line">	reader := bufio.NewReaderSize(strings.NewReader(<span class="string">&quot;hello&quot;</span>), <span class="number">16</span>)</span><br><span class="line">	<span class="comment">// 读取</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">		<span class="comment">// 大于缓冲区大小</span></span><br><span class="line">		s, err := reader.Peek(<span class="number">17</span>)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;结果: %s &quot;</span>, s)</span><br><span class="line">		<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, <span class="string">&quot;已读完&quot;</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Printf(<span class="string">&quot;err:%s\n&quot;</span>, err.Error())</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出-&gt; 结果: hello err:bufio: buffer full</span></span><br></pre></td></tr></table></figure>

<h2 id="写入-Write"><a href="#写入-Write" class="headerlink" title="写入(Write*)"></a>写入(Write*)</h2><h3 id="创建写入器"><a href="#创建写入器" class="headerlink" title="创建写入器"></a>创建写入器</h3><p><strong>创建默认缓冲大小(NewWriter)</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriter</span><span class="params">(w io.Writer)</span></span> *Writer</span><br></pre></td></tr></table></figure>
<p>根据w创建一个具有默认大小缓冲的*Writer。默认大小:4096字节</p>
<p><strong>创建指定缓冲大小(NewWriterSize)</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriterSize</span><span class="params">(w io.Writer, size <span class="type">int</span>)</span></span> *Writer</span><br></pre></td></tr></table></figure>

<h3 id="Write"><a href="#Write" class="headerlink" title="Write*"></a>Write*</h3><p><strong>方法列表</strong></p>
<table>
    <tr>
        <th>方法名</th><th>描述</th>
    </tr>
    <tr>
        <td>Write(p []byte) (nn int, err error)</td><td>Write将p的内容写入缓冲。返回写入的字节数。如果返回值nn < len(p)，还会返回一个错误说明原因。</td>
    </tr>
    <tr>
        <td>WriteString(s string) (int, error)</td><td>同上,只是入参变成字符串。</td>
    </tr>
</table>

<p><strong>当写入内容大于缓冲区时</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	file, _ := os.OpenFile(<span class="string">&quot;./test.txt&quot;</span>, os.O_APPEND|os.O_WRONLY, os.ModePerm)</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	reader := bufio.NewWriterSize(file, <span class="number">20</span>)</span><br><span class="line">	<span class="comment">// 当写入的内容字节大于缓冲区大小时,会直接写入文件</span></span><br><span class="line">	write, err := reader.Write([]<span class="type">byte</span>(<span class="string">&quot;hello,hello,hello 你好！\n&quot;</span>))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;直接写入文件: %d\n&quot;</span>, write)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出——&gt; 直接写入文件: 28</span></span><br></pre></td></tr></table></figure>

<p><strong>当写入内容小于缓冲区时</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	file, _ := os.OpenFile(<span class="string">&quot;./test.txt&quot;</span>, os.O_APPEND|os.O_WRONLY, os.ModePerm)</span><br><span class="line">	<span class="keyword">defer</span> file.Close()</span><br><span class="line">	reader := bufio.NewWriterSize(file, <span class="number">20</span>)</span><br><span class="line">	<span class="comment">// 当写入的内容字节小于缓冲区大小时,不会直接写入文件</span></span><br><span class="line">	write, err := reader.Write([]<span class="type">byte</span>(<span class="string">&quot;\nhello,Go!&quot;</span>))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 该函数会使缓冲区的内容，直接写入文件</span></span><br><span class="line">	reader.Flush()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;Flush写入文件: %d\n&quot;</span>, write)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出-&gt; Flush写入文件: 10</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>ioutil包使用</title>
    <url>/2021/04/25/ioutil%E5%8C%85%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote>
<p>在Go语言中，io包主要声明的是对I/O操作的基本接口，而io/ioutil包则实现了对应的方法，方便我们直接使用。</p>
</blockquote>
<span id="more"></span>

<p><strong>方法列表</strong></p>
<table>
    <tr>
        <th>方法名</th><th>描述</th>
    </tr>
    <tr>
        <td>NopCloser</td><td>对Reader进行封装，返回一个ReadCloser</td>
    </tr>
    <tr>
        <td>ReadAll</td><td>对Reader进行读取，直到发生错误或者遇到EOF为止，然后返回被读取的数据</td>
    </tr>
    <tr>
        <td>ReadFile</td><td>读取指定文件的内容，并返回</td>
    </tr>
    <tr>
        <td>ReadDir</td><td>读取指定的目录， 并返回排序后的目录列表(根据名称排序)</td>
    </tr>
    <tr>
        <td>TempDir</td><td>在指定目录新创建一个临时文件，以可读写的方式打开它，并返回 *os.File 指针</td>
    </tr>
    <tr>
        <td>WriteFile</td><td>将给定的数据写入到指定文件里面</td>
    </tr>
</table>

<p><strong>注意</strong><br><code>WriteFile</code>：如果文件不存在，则去创建它；<br>如果文件已经存在，则再写入之前会先清空文件中已有的内容。</p>
<h2 id="ReadAll"><a href="#ReadAll" class="headerlink" title="ReadAll"></a>ReadAll</h2><p><strong>方法签名</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadAll</span><span class="params">(r io.Reader)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p><code>ReadAll</code>从r读取数据直到EOF或error，返回读取内容([]byte)和错误(error)。读取成功时err返回nil。<br>因为本函数定义为读取r直到EOF，它不会将读取返回的EOF视为应报告的错误。</p>
<p><strong>使用</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// NewReader创建一个从s读取数据的Reader。本函数类似bytes.NewBufferString</span></span><br><span class="line">	reader := strings.NewReader(<span class="string">&quot;Hello word !&quot;</span>)</span><br><span class="line">	all, err := ioutil.ReadAll(reader)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s&quot;</span>,all)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出: Hello word !</span></span><br></pre></td></tr></table></figure>

<h2 id="ReadFile"><a href="#ReadFile" class="headerlink" title="ReadFile"></a>ReadFile</h2><p><strong>方法签名</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(filename <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p><code>ReadFile</code>从filename指定的文件中读取内容并返回。读取成功时err返回nil。<br>因为本函数定义为读取r直到EOF，它不会将读取返回的EOF视为应报告的错误。</p>
<p><strong>使用</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 文件路径</span></span><br><span class="line">   fileName := <span class="string">&quot;./test.log&quot;</span></span><br><span class="line">   data, err := ioutil.ReadFile(fileName)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;%s&quot;</span>,data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ReadDir"><a href="#ReadDir" class="headerlink" title="ReadDir"></a>ReadDir</h2><p><strong>方法签名</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadDir</span><span class="params">(dirname <span class="type">string</span>)</span></span> ([]os.FileInfo, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p>返回dirname指定的目录的目录信息的有序列表。</p>
<p><strong>使用</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	dirName := <span class="string">&quot;./log&quot;</span></span><br><span class="line">	dirList, err := ioutil.ReadDir(dirName)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, info := <span class="keyword">range</span> dirList &#123;</span><br><span class="line">		fmt.Println(info.Name())</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TempDir"><a href="#TempDir" class="headerlink" title="TempDir"></a>TempDir</h2><p><strong>方法签名</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TempDir</span><span class="params">(dir, pattern <span class="type">string</span>)</span></span> (name <span class="type">string</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p>在dir目录里创建一个新的、使用pattern作为前缀的临时文件夹，并返回文件夹的路径。</p>
<p>如果dir是空字符串，TempDir使用默认用于临时文件的目录。<br>不同程序同时调用该函数会创建不同的临时目录，<br>创建的临时文件夹时在不使用时，需要删除。</p>
<p><strong>使用</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> pathList []<span class="type">string</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">var</span> path <span class="type">string</span></span><br><span class="line">		<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">		<span class="keyword">switch</span> i &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">			<span class="comment">// 指定目录和前缀</span></span><br><span class="line">			path, err = ioutil.TempDir(<span class="string">&quot;./log&quot;</span>,<span class="string">&quot;tmp_&quot;</span>)</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			<span class="comment">// 只指定目录</span></span><br><span class="line">			path, err = ioutil.TempDir(<span class="string">&quot;./log&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			<span class="comment">// 目录为空、前缀不为空</span></span><br><span class="line">			path, err = ioutil.TempDir(<span class="string">&quot;&quot;</span>,<span class="string">&quot;tmp_&quot;</span>)</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			<span class="comment">// 目录和前缀都是空</span></span><br><span class="line">			path, err = ioutil.TempDir(<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		pathList = <span class="built_in">append</span>(pathList, path)</span><br><span class="line">    <span class="comment">// 删除临时目录,测试时注释</span></span><br><span class="line">		<span class="comment">// _ = os.RemoveAll(path)</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(pathList)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">[./log/tmp_1985114812 ./log/3136642706 /tmp/tmp_3038884210 /tmp/80588905]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="TempFile"><a href="#TempFile" class="headerlink" title="TempFile"></a>TempFile</h2><p><strong>方法签名</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TempFile</span><span class="params">(dir, pattern <span class="type">string</span>)</span></span> (f *os.File, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p>在dir目录下创建一个新的、使用pattern为前缀的临时文件，以读写模式打开该文件并返回os.File指针。</p>
<p>如果dir是空字符串，TempFile使用默认用于临时文件的目录。<br>不同程序同时调用该函数会创建不同的临时文件。<br>创建的临时文件夹时在不使用时，需要删除。</p>
<p><strong>使用</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> fileList []<span class="type">string</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">var</span> file *os.File</span><br><span class="line">		<span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">		<span class="keyword">switch</span> i &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">			<span class="comment">// 指定目录和前缀</span></span><br><span class="line">			file, err = ioutil.TempFile(<span class="string">&quot;./log&quot;</span>, <span class="string">&quot;tmp_&quot;</span>)</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			<span class="comment">// 只指定目录</span></span><br><span class="line">			file, err = ioutil.TempFile(<span class="string">&quot;./log&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">		<span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">			<span class="comment">// 目录为空、前缀不为空</span></span><br><span class="line">			file, err = ioutil.TempFile(<span class="string">&quot;&quot;</span>, <span class="string">&quot;tmp_&quot;</span>)</span><br><span class="line">		<span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">			<span class="comment">// 目录和前缀都是空</span></span><br><span class="line">			file, err = ioutil.TempFile(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		fileList = <span class="built_in">append</span>(fileList, file.Name())</span><br><span class="line">		<span class="comment">//删除</span></span><br><span class="line">		<span class="comment">//_ = os.Remove(file.Name())</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(fileList)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">[./log/tmp_810405943 ./log/3229488309 /tmp/tmp_691615726 /tmp/1459961838]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>


<h2 id="WriteFile"><a href="#WriteFile" class="headerlink" title="WriteFile"></a>WriteFile</h2><p><strong>方法签名</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteFile</span><span class="params">(filename <span class="type">string</span>, data []<span class="type">byte</span>, perm os.FileMode)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure>
<p>函数向filename指定的文件中写入数据。</p>
<p>如果文件不存在,将按给出的权限创建文件，<br>如果文件存在,在写入数据之前清空文件。</p>
<p><strong>使用</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fileName := <span class="string">&quot;./test.txt&quot;</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">		_ = ioutil.WriteFile(fileName, []<span class="type">byte</span>(<span class="string">&quot;Hello Word!&quot;</span>), os.ModePerm)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>fmt包使用</title>
    <url>/2021/04/24/fmt%E5%8C%85%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="输出到控制台"><a href="#输出到控制台" class="headerlink" title="输出到控制台"></a>输出到控制台</h2><h3 id="Printf"><a href="#Printf" class="headerlink" title="Printf"></a>Printf</h3><blockquote>
<p>Printf根据format参数生成格式化的字符串并写入标准输出。返回写入的字节数和遇到的任何错误。</p>
</blockquote>
<span id="more"></span>

<p><strong>format格式</strong></p>
<table>
    <tr>
        <th>动 词</th><th>功 能</th>
    </tr>
    <tr>
        <td>%v</td><td>按值的本来值输出</td>
    </tr>
    <tr>
        <td>%+v</td><td>在 %v 基础上，对结构体字段名和值进行展开</td>
    </tr>
    <tr>
        <td>%#v</td><td>输出 Go 语言语法格式的值</td>
    </tr>
    <tr>
        <td>%T</td><td>输出 Go 语言语法格式的类型和值</td>
    </tr>
    <tr>
        <td>%%</td><td>输出 % 本体</td>
    </tr>
    <tr>
        <td>%b</td><td>整型以二进制方式显示</td>
    </tr>
    <tr>
        <td>%o</td><td>整型以八进制方式显示</td>
    </tr>
    <tr>
        <td>%d</td><td>整型以十进制方式显示</td>
    </tr>
    <tr>
        <td>%x</td><td>整型以十六进制方式显示</td>
    </tr>
    <tr>
        <td>%X</td><td>整型以十六进制、字母大写方式显示</td>
    </tr>
    <tr>
        <td>%U</td><td>Unicode 字符</td>
    </tr>
    <tr>
        <td>%f</td><td>浮点数</td>
    </tr>
    <tr>
        <td>%p</td><td>指针，十六进制方式显示</td>
    </tr>
    <tr>
        <td>%c</td><td>数值对应的 Unicode 编码字符</td>
    </tr>
    <tr>
        <td>%s</td><td>直接输出字符串或者[]byte</td>
    </tr>
    <tr>
        <td>%t</td><td>输出值的 true 或 false</td>
    </tr>
</table>

<p><strong>打印字符串</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str := <span class="string">&quot;hello word&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%%s-&gt; %s \n&quot;</span>,str)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%%v-&gt; %v \n&quot;</span>,str)</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">%s-&gt; hello word </span></span><br><span class="line"><span class="comment">%v-&gt; hello word </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>打印布尔类型</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;%%t-&gt; %t \n&quot;</span>, b)</span><br></pre></td></tr></table></figure>

<p><strong>打印浮点型</strong></p>
<table>
    <tr>
        <th>格式</th><th>描述</th>
    </tr>
    <tr>
        <td>%f</td><td>默认宽度，默认精度</td>
    </tr>
    <tr>
        <td>%9f</td><td>宽度9，默认精度</td>
    </tr>
    <tr>
        <td>%.2f</td><td>默认宽度，精度2</td>
    </tr>
    <tr>
        <td>%9.2f</td><td>宽度9，精度2</td>
    </tr>
    <tr>
        <td>%9.f</td><td>宽度9，精度0</td>
    </tr>
</table>


<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f := <span class="number">1.234567890</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;默认宽度，默认精度:%f \n&quot;</span>, f)</span><br><span class="line">fmt.Printf(<span class="string">&quot;宽度9，默认精度:%9f \n&quot;</span>, f)</span><br><span class="line">fmt.Printf(<span class="string">&quot;默认宽度，精度2:%.2f \n&quot;</span>, f)</span><br><span class="line">fmt.Printf(<span class="string">&quot;宽度9，精度2:%9.2f \n&quot;</span>, f)</span><br><span class="line">fmt.Printf(<span class="string">&quot;宽度9，精度0 :%9.f \n&quot;</span>, f)</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">默认宽度，默认精度:1.234568 </span></span><br><span class="line"><span class="comment">宽度9，默认精度: 1.234568 </span></span><br><span class="line"><span class="comment">默认宽度，精度2:1.23 </span></span><br><span class="line"><span class="comment">宽度9，精度2:     1.23 </span></span><br><span class="line"><span class="comment">宽度9，精度0 :        1 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>打印整数</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个整数变量</span></span><br><span class="line">a := <span class="number">54321</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;十进制:%d\n&quot;</span>,a)</span><br><span class="line">fmt.Printf(<span class="string">&quot;二进制:%b\n&quot;</span>,a)</span><br><span class="line">fmt.Printf(<span class="string">&quot;八进制:%o\n&quot;</span>,a)</span><br><span class="line">fmt.Printf(<span class="string">&quot;十六进制:%x\n&quot;</span>,a)</span><br><span class="line">fmt.Printf(<span class="string">&quot;十六进制,字母大写:%X\n&quot;</span>,a)</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">十进制:54321</span></span><br><span class="line"><span class="comment">二进制:1101010000110001</span></span><br><span class="line"><span class="comment">八进制:152061</span></span><br><span class="line"><span class="comment">十六进制:d431</span></span><br><span class="line"><span class="comment">十六进制,字母大写:D431</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>打印指针</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str := <span class="string">&quot;hello&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;打印指针:%p\n&quot;</span>, &amp;str)</span><br><span class="line"><span class="comment">//输出: 打印指针:0xc000098d50</span></span><br></pre></td></tr></table></figure>

<p><strong>打印变量类型</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line">arr := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;arr类型: %T\n&quot;</span>, arr)</span><br><span class="line"><span class="comment">// 映射</span></span><br><span class="line">map1 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line">	<span class="string">&quot;张三&quot;</span>: <span class="number">20</span>,</span><br><span class="line">	<span class="string">&quot;李四&quot;</span>: <span class="number">23</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;map1类型: %T\n&quot;</span>, map1)</span><br><span class="line"><span class="comment">// 匿名结构体</span></span><br><span class="line">fruit := <span class="keyword">struct</span> &#123;</span><br><span class="line">	name  <span class="type">string</span></span><br><span class="line">	price <span class="type">float64</span></span><br><span class="line">&#125;&#123;<span class="string">&quot;香蕉&quot;</span>, <span class="number">4.99</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;fruit类型: %T\n&quot;</span>, fruit)</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">arr类型: []int</span></span><br><span class="line"><span class="comment">map1类型: map[string]int</span></span><br><span class="line"><span class="comment">fruit类型: struct &#123; name string; price float64 &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>打印结构体</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个匿名结构体</span></span><br><span class="line">people := <span class="keyword">struct</span> &#123;</span><br><span class="line">	name, home, school <span class="type">string</span></span><br><span class="line">&#125;&#123;<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;北京&quot;</span>, <span class="string">&quot;北京大学&quot;</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, people)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, people)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, people)</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">&#123;张三 北京 北京大学&#125;</span></span><br><span class="line"><span class="comment">&#123;name:张三 home:北京 school:北京大学&#125;</span></span><br><span class="line"><span class="comment">struct &#123; name string; home string; school string &#125;&#123;name:&quot;张三&quot;, home:&quot;北京&quot;, school:&quot;北京大学&quot;&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>打印Unicode</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;%U\n&quot;</span>, <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%c\n&quot;</span>, <span class="number">65</span>)</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">U+0041</span></span><br><span class="line"><span class="comment">A</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="Print"><a href="#Print" class="headerlink" title="Print"></a>Print</h3><p><code>Print</code>: 采用默认格式将其参数格式化并写入标准输出。如果两个相邻的参数都不是字符串，会在它们的输出之间添加空格。</p>
<p><strong>打印相邻的字符串</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Print(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;word&quot;</span>,<span class="string">&quot;!&quot;</span>)</span><br><span class="line">fmt.Print(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;word&quot;</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&quot;!&quot;</span>)</span><br><span class="line"><span class="comment">// 输出: helloword2 3!helloword!</span></span><br></pre></td></tr></table></figure>
<p>如果两个相邻的参数都不是字符串，会在它们的输出之间添加空格,注意的是,<strong>不会自动换行</strong>。</p>
<h3 id="Println"><a href="#Println" class="headerlink" title="Println"></a>Println</h3><p><code>Println</code>: 采用默认格式将其参数格式化并写入标准输出。总是会在相邻参数的输出之间添加空格并在输出结束后添加换行符。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;word&quot;</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&quot;!&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;word&quot;</span>,<span class="string">&quot;!&quot;</span>)</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">hello word 2 3 !</span></span><br><span class="line"><span class="comment">hello word !</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="输出到文件"><a href="#输出到文件" class="headerlink" title="输出到文件"></a>输出到文件</h2><table>
    <tr>
        <th>方法名</th><th>描述</th>
    </tr>
    <tr>
        <td>Fprintln</td><td>功能和Println一样,但可以输出到文件</td>
    </tr>
    <tr>
        <td>Fprintf</td><td>功能和Printf一样,但可以输出到文件</td>
    </tr>
    <tr>
        <td>Fprint</td><td>功能和Print一样,但可以输出到文件</td>
    </tr>
</table>

<p><strong>输出到控制台</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">_, _ = fmt.Fprintln(os.Stdout, <span class="string">&quot;hello&quot;</span>,<span class="string">&quot;go&quot;</span>)</span><br><span class="line">_, _ = fmt.Fprintln(os.Stdout,  <span class="string">&quot;hello&quot;</span>,<span class="string">&quot;php&quot;</span>)</span><br><span class="line"><span class="comment">/** 输出</span></span><br><span class="line"><span class="comment">hello go</span></span><br><span class="line"><span class="comment">hello php</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>输出到文件</strong></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打开文件</span></span><br><span class="line">file, err := os.OpenFile(<span class="string">&quot;./test.log&quot;</span>, os.O_APPEND|os.O_CREATE|os.O_WRONLY, os.ModePerm)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line">_, err = fmt.Fprintln(file, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;word&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(err.Error())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="生成字符串"><a href="#生成字符串" class="headerlink" title="生成字符串"></a>生成字符串</h2><table>
    <tr>
        <th>方法名</th><th>描述</th>
    </tr>
    <tr>
        <td>Sprintf</td><td>同Printf一样,但是结果不输出到控制台,而是直接返回</td>
    </tr>
    <tr>
        <td>Sprint</td><td>同Print一样,但是结果不输出到控制台,而是直接返回</td>
    </tr>
    <tr>
        <td>Sprintln</td><td>同Println一样,但是结果不输出到控制台,而是直接返回</td>
    </tr>
</table>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sprintf := fmt.Sprintf(<span class="string">&quot;水果:%s 价格:%.3f&quot;</span>, <span class="string">&quot;香蕉&quot;</span>, <span class="number">1.99</span>)</span><br><span class="line">sprint := fmt.Sprint(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;LOVE&quot;</span>, <span class="string">&quot;YOU&quot;</span>)</span><br><span class="line">sprintln := fmt.Sprintln(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;LOVE&quot;</span>, <span class="string">&quot;YOU&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Sprintf:%s\n&quot;</span>,sprintf)</span><br><span class="line">fmt.Printf(<span class="string">&quot;sprint:%s\n&quot;</span>,sprint)</span><br><span class="line">fmt.Printf(<span class="string">&quot;sprintln:%s\n&quot;</span>,sprintln)</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">Sprintf:水果:香蕉 价格:1.990</span></span><br><span class="line"><span class="comment">sprint:ILOVEYOU</span></span><br><span class="line"><span class="comment">sprintln:I LOVE YOU</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="生成错误类型"><a href="#生成错误类型" class="headerlink" title="生成错误类型"></a>生成错误类型</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回错误类型</span></span><br><span class="line">err := fmt.Errorf(<span class="string">&quot;错误信息:%s&quot;</span>, <span class="string">&quot;参数不全&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;类型:%T   内容: %v&quot;</span>,err,err)</span><br><span class="line"><span class="comment">//输出: 类型:*errors.errorString   内容: 错误信息:参数不全</span></span><br></pre></td></tr></table></figure>

<h2 id="接收控制台输入"><a href="#接收控制台输入" class="headerlink" title="接收控制台输入"></a>接收控制台输入</h2><p><code>Scan</code><br>接收终端输入，按照参数输入顺序赋值，参数间以空格(或换行)间隔，如果输入的参数少于接收的参数则会报错。类型不一致时也会报错。当参数输入数量不够时，换行时会继续等待输入。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		name   <span class="type">string</span></span><br><span class="line">		age    <span class="type">int64</span></span><br><span class="line">		isBody <span class="type">bool</span></span><br><span class="line">	)</span><br><span class="line">	_, err := fmt.Scan(&amp;name, &amp;age, &amp;isBody)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err.Error())</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;name:%s age: %d isBody:%t&quot;</span>, name, age, isBody)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//启动后，依次输入：张三 22 true</span></span><br><span class="line"><span class="comment">// 输出: name:张三 age: 22 isBody:true</span></span><br></pre></td></tr></table></figure>

<p><code>Scanf</code><br>接收终端输入,按照format参数指定的格式接收参数.当参数输入数量不够时，换行时会直接输出.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		name   <span class="type">string</span></span><br><span class="line">		age    <span class="type">int</span></span><br><span class="line">		isBody <span class="type">bool</span></span><br><span class="line">	)</span><br><span class="line">	_, err := fmt.Scanf(<span class="string">&quot;a:%s b:%d c:%t&quot;</span>, &amp;name, &amp;age, &amp;isBody)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;name:%s age:%d isBody:%t&quot;</span>, name, age, isBody)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当输入-&gt; 张三 23 true 报错: input does not match format </span></span><br><span class="line"><span class="comment">当输入-&gt; a:张三 b:23 c:true 输出: name:张三 age:23 isBody:true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><code>Scanln</code><br>Scanln类似Scan，它在遇到换行时才停止扫描。最后一个数据后面必须有换行或者到达结束位置。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		name   <span class="type">string</span></span><br><span class="line">		age    <span class="type">int64</span></span><br><span class="line">		isBody <span class="type">bool</span></span><br><span class="line">	)</span><br><span class="line">	_, err := fmt.Scanln(&amp;name, &amp;age, &amp;isBody)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;name:%s age: %d isBody:%t&quot;</span>, name, age, isBody)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当输入-&gt; 张三 23  报错: unexpected newline</span></span><br><span class="line"><span class="comment">当输入-&gt; 李四 74 true 输出: name:李四 age: 74 isBody:true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>time包使用</title>
    <url>/2021/04/23/time%E5%8C%85%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="获取时间"><a href="#获取时间" class="headerlink" title="获取时间"></a>获取时间</h2><h3 id="当前时间"><a href="#当前时间" class="headerlink" title="当前时间"></a>当前时间</h3><p>语法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">Now() Time </span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>使用示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">unix := time.Now().Unix()</span><br><span class="line">fmt.Printf(<span class="string">&quot;当前时间戳(单位秒): %v \n&quot;</span>,unix)</span><br><span class="line">nano := time.Now().UnixNano()</span><br><span class="line">fmt.Printf(<span class="string">&quot;当前时间戳(单位纳秒): %v\n&quot;</span>,nano)</span><br><span class="line">format := time.Now().Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;当前时间(Y-m-d H:i:s): %v\n&quot;</span>,format)</span><br><span class="line">format2 := time.Now().Format(<span class="string">&quot;20060102150405&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;当前时间(YmdHis): %v\n&quot;</span>,format2)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">当前时间戳(单位秒): 1616251448 </span></span><br><span class="line"><span class="comment">当前时间戳(单位纳秒): 1616251448041163000</span></span><br><span class="line"><span class="comment">当前时间(Y-m-d H:i:s): 2021-03-20 22:44:08</span></span><br><span class="line"><span class="comment">当前时间(YmdHis): 20210320224408</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="当前年、月、日、时、分、秒、星期几"><a href="#当前年、月、日、时、分、秒、星期几" class="headerlink" title="当前年、月、日、时、分、秒、星期几"></a>当前年、月、日、时、分、秒、星期几</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">format := time.Now().Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;当前时间(Y-m-d H:i:s): %v\n&quot;</span>,format)</span><br><span class="line">fmt.Printf(<span class="string">&quot;当前年: %v\n&quot;</span>, time.Now().Year())</span><br><span class="line">fmt.Printf(<span class="string">&quot;当前月: %v\n&quot;</span>, time.Now().Month())</span><br><span class="line">fmt.Printf(<span class="string">&quot;当前日: %v\n&quot;</span>, time.Now().Day())</span><br><span class="line">fmt.Printf(<span class="string">&quot;当前小时: %v\n&quot;</span>, time.Now().Hour())</span><br><span class="line">fmt.Printf(<span class="string">&quot;当前分钟: %v\n&quot;</span>, time.Now().Minute())</span><br><span class="line">fmt.Printf(<span class="string">&quot;当前秒: %v\n&quot;</span>, time.Now().Second())</span><br><span class="line">fmt.Printf(<span class="string">&quot;当前星期几: %v\n&quot;</span>, time.Now().Weekday())</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">当前时间(Y-m-d H:i:s): 2021-03-21 17:32:24</span></span><br><span class="line"><span class="comment">当前年: 2021</span></span><br><span class="line"><span class="comment">当前月: March</span></span><br><span class="line"><span class="comment">当前日: 21</span></span><br><span class="line"><span class="comment">当前小时: 17</span></span><br><span class="line"><span class="comment">当前分钟: 32</span></span><br><span class="line"><span class="comment">当前秒: 24</span></span><br><span class="line"><span class="comment">当前星期几: Sunday</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h3 id="获取时分秒"><a href="#获取时分秒" class="headerlink" title="获取时分秒"></a>获取时分秒</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">hour, min, sec := now.Clock()</span><br><span class="line">fmt.Printf(<span class="string">&quot;时间:%v   hour: %v min:%v sec:%v \n&quot;</span>,now,hour,min,sec)</span><br><span class="line"><span class="comment">//时间:2021-03-22 23:18:43.245006 +0800 CST m=+0.000108086   hour: 23 min:18 sec:43</span></span><br></pre></td></tr></table></figure>
<h3 id="创建指定时间"><a href="#创建指定时间" class="headerlink" title="创建指定时间"></a>创建指定时间</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">date := time.Date(<span class="number">2020</span>,<span class="number">8</span>,<span class="number">23</span>,<span class="number">13</span>,<span class="number">53</span>,<span class="number">32</span>,<span class="number">0</span>,time.Local)</span><br><span class="line">fmt.Printf(<span class="string">&quot;类型: %T , %v &quot;</span>,date,date)</span><br><span class="line"><span class="comment">// 输出:类型: time.Time , 2020-08-23 13:53:32 +0800 CST </span></span><br></pre></td></tr></table></figure>
<h3 id="获取所属第几周"><a href="#获取所属第几周" class="headerlink" title="获取所属第几周"></a>获取所属第几周</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前时间是，今年的第几周</span></span><br><span class="line">week, w := time.Now().ISOWeek()</span><br><span class="line">fmt.Printf(<span class="string">&quot;year: %v w:%v \n&quot;</span>,week,w)</span><br><span class="line"><span class="comment">// year: 2021 w:12 </span></span><br></pre></td></tr></table></figure>
<h3 id="获取x年的第几天"><a href="#获取x年的第几天" class="headerlink" title="获取x年的第几天"></a>获取x年的第几天</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">num := time.Now().YearDay()</span><br><span class="line">fmt.Printf(<span class="string">&quot;今天是今年的第 %v 天 \n&quot;</span>,num)</span><br><span class="line"><span class="comment">// 今天是今年的第 81 天 </span></span><br></pre></td></tr></table></figure>
<h2 id="字符串转时间"><a href="#字符串转时间" class="headerlink" title="字符串转时间"></a>字符串转时间</h2><h3 id="字符串转时间类型"><a href="#字符串转时间类型" class="headerlink" title="字符串转时间类型"></a>字符串转时间类型</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">str := <span class="string">&quot;1616319808&quot;</span></span><br><span class="line">unix, _ := strconv.ParseInt(str,<span class="number">10</span>,<span class="number">64</span>)</span><br><span class="line">format := time.Unix(unix, <span class="number">0</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;字符串时间戳-&gt; 类型:%T 值:%v \n&quot;</span>,format,format)</span><br><span class="line"><span class="comment">// 字符串时间,</span></span><br><span class="line">strDate := <span class="string">&quot;2019-04-10 12:54:03&quot;</span></span><br><span class="line"><span class="comment">// 注意layout格式需要和字符串时间格式一致</span></span><br><span class="line">location, _ := time.Parse(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>, strDate)</span><br><span class="line">fmt.Printf(<span class="string">&quot;字符串时间-&gt; 类型:%T 值:%v \n&quot;</span>,location,location)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">字符串时间戳-&gt; 类型:time.Time 值:2021-03-21 17:43:28 +0800 CST </span></span><br><span class="line"><span class="comment">字符串时间-&gt; 类型:time.Time 值:2019-04-10 12:54:03 +0000 UTC </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="格式化时间"><a href="#格式化时间" class="headerlink" title="格式化时间"></a>格式化时间</h3><p>Format根据layout指定的格式返回t代表的时间点的格式化文本表示；Format中内置了几个固定的layout常量。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	ANSIC       = <span class="string">&quot;Mon Jan _2 15:04:05 2006&quot;</span></span><br><span class="line">	UnixDate    = <span class="string">&quot;Mon Jan _2 15:04:05 MST 2006&quot;</span></span><br><span class="line">	RubyDate    = <span class="string">&quot;Mon Jan 02 15:04:05 -0700 2006&quot;</span></span><br><span class="line">	RFC822      = <span class="string">&quot;02 Jan 06 15:04 MST&quot;</span></span><br><span class="line">	RFC822Z     = <span class="string">&quot;02 Jan 06 15:04 -0700&quot;</span> <span class="comment">// RFC822 with numeric zone</span></span><br><span class="line">	RFC850      = <span class="string">&quot;Monday, 02-Jan-06 15:04:05 MST&quot;</span></span><br><span class="line">	RFC1123     = <span class="string">&quot;Mon, 02 Jan 2006 15:04:05 MST&quot;</span></span><br><span class="line">	RFC1123Z    = <span class="string">&quot;Mon, 02 Jan 2006 15:04:05 -0700&quot;</span> <span class="comment">// RFC1123 with numeric zone</span></span><br><span class="line">	RFC3339     = <span class="string">&quot;2006-01-02T15:04:05Z07:00&quot;</span></span><br><span class="line">	RFC3339Nano = <span class="string">&quot;2006-01-02T15:04:05.999999999Z07:00&quot;</span></span><br><span class="line">	Kitchen     = <span class="string">&quot;3:04PM&quot;</span></span><br><span class="line">	<span class="comment">// Handy time stamps.</span></span><br><span class="line">	Stamp      = <span class="string">&quot;Jan _2 15:04:05&quot;</span></span><br><span class="line">	StampMilli = <span class="string">&quot;Jan _2 15:04:05.000&quot;</span></span><br><span class="line">	StampMicro = <span class="string">&quot;Jan _2 15:04:05.000000&quot;</span></span><br><span class="line">	StampNano  = <span class="string">&quot;Jan _2 15:04:05.000000000&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将字符时间: 2020-09-12 14:34:10 转成 20200912143410</span></span><br><span class="line">strDate := <span class="string">&quot;2020-09-12 14:34:10&quot;</span></span><br><span class="line"><span class="comment">// 1.先转成时间类型</span></span><br><span class="line">location, _ := time.ParseInLocation(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>, strDate, time.Local)</span><br><span class="line"><span class="comment">// 2.再格式化</span></span><br><span class="line">format := location.Format(<span class="string">&quot;20060102150405&quot;</span>)</span><br><span class="line">fmt.Println(format)</span><br><span class="line"><span class="comment">// 输出:20200912143410</span></span><br></pre></td></tr></table></figure>

<h2 id="时间比较"><a href="#时间比较" class="headerlink" title="时间比较"></a>时间比较</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strDate := <span class="string">&quot;2020-09-12 12:00:00&quot;</span></span><br><span class="line">strDate2 := <span class="string">&quot;2020-09-12 12:00:00&quot;</span></span><br><span class="line"><span class="comment">// 1.先转成时间类型</span></span><br><span class="line">time1, _ := time.ParseInLocation(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>, strDate, time.Local)</span><br><span class="line">time2, _ := time.ParseInLocation(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>, strDate2, time.Local)</span><br><span class="line"><span class="comment">// 2.比较 strDate2 &gt; strDate ?</span></span><br><span class="line">before := time1.Before(time2)</span><br><span class="line">fmt.Printf(<span class="string">&quot;strDate2 &gt; strDate ? %t \n&quot;</span>,before)</span><br><span class="line"><span class="comment">// 3.比较 strDate2 = strDate ?</span></span><br><span class="line">equal := time1.Equal(time2)</span><br><span class="line">fmt.Printf(<span class="string">&quot;strDate2 = strDate ? %t \n&quot;</span>,equal)</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">strDate2 &gt; strDate ? false </span></span><br><span class="line"><span class="comment">strDate2 = strDate ? true </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="时间计算"><a href="#时间计算" class="headerlink" title="时间计算"></a>时间计算</h2><p>时间相加</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">fmt.Printf(<span class="string">&quot;现在的时间: %v \n&quot;</span>,now)</span><br><span class="line"><span class="comment">// 十分钟前</span></span><br><span class="line">duration, _ := time.ParseDuration(<span class="string">&quot;-10m&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;十分钟前: %v \n&quot;</span>, now.Add(duration))</span><br><span class="line"><span class="comment">// 一小时前</span></span><br><span class="line">duration2, _ := time.ParseDuration(<span class="string">&quot;-1h&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;一小时前: %v \n&quot;</span>, now.Add(duration2))</span><br><span class="line"><span class="comment">// 一天后</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;一天后: %v \n&quot;</span>, now.AddDate(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line">fmt.Printf(<span class="string">&quot;一月后: %v \n&quot;</span>, now.AddDate(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line">fmt.Printf(<span class="string">&quot;一年后: %v \n&quot;</span>, now.AddDate(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">现在的时间: 2021-03-22 22:54:16.008615 +0800 CST m=+0.000092572 </span></span><br><span class="line"><span class="comment">十分钟前: 2021-03-22 22:44:16.008615 +0800 CST m=-599.999907428 </span></span><br><span class="line"><span class="comment">一小时前: 2021-03-22 21:54:16.008615 +0800 CST m=-3599.999907428 </span></span><br><span class="line"><span class="comment">一天后: 2021-03-23 22:54:16.008615 +0800 CST </span></span><br><span class="line"><span class="comment">一月后: 2021-04-22 22:54:16.008615 +0800 CST </span></span><br><span class="line"><span class="comment">一年后: 2022-03-22 22:54:16.008615 +0800 CST </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>时间相减</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">day1, _ := time.ParseInLocation(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>, <span class="string">&quot;2020-11-02 12:00:00&quot;</span>, time.Local)</span><br><span class="line">day2, _ := time.ParseInLocation(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>, <span class="string">&quot;2020-11-02 15:00:00&quot;</span>, time.Local)</span><br><span class="line">fmt.Printf(<span class="string">&quot;相差几秒: %v \n&quot;</span>,day2.Sub(day1).Seconds())</span><br><span class="line">fmt.Printf(<span class="string">&quot;相差多少分钟: %v \n&quot;</span>,day2.Sub(day1).Minutes())</span><br><span class="line">fmt.Printf(<span class="string">&quot;相差多少小时: %v \n&quot;</span>,day2.Sub(day1).Hours())</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">相差几秒: 10800 </span></span><br><span class="line"><span class="comment">相差多少分钟: 180 </span></span><br><span class="line"><span class="comment">相差多少小时: 3 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p><code>NewTicker</code>返回一个新的Ticker，该Ticker包含一个通道字段，并会每隔时间段d就向该通道发送当时的时间。<br>它会调整时间间隔或者丢弃tick信息以适应反应慢的接收者。如果d&lt;=0会panic。关闭该Ticker可以释放相关资源。</p>
<p>使用示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建定时器，间隔设置每秒</span></span><br><span class="line">	ticker := time.NewTicker(time.Second)</span><br><span class="line">	<span class="comment">// 启动一个协程，打印定时器里面的时间</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ticker *time.Ticker)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">			fmt.Println(&lt;-ticker.C)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 关闭定时器</span></span><br><span class="line">		ticker.Stop()</span><br><span class="line">	&#125;(ticker)</span><br><span class="line">	<span class="comment">// 手动阻塞</span></span><br><span class="line">	time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">2021-03-30 11:33:23.704677 +0800 CST m=+1.003656575</span></span><br><span class="line"><span class="comment">2021-03-30 11:33:24.704695 +0800 CST m=+2.003675713</span></span><br><span class="line"><span class="comment">2021-03-30 11:33:25.704271 +0800 CST m=+3.003275554</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><code>Tick</code>是NewTicker的封装，只提供对Ticker通道的访问。如果不需要关闭Ticker，本函数就很方便。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建定时器，间隔设置每秒</span></span><br><span class="line">	chTime := time.Tick(time.Second)</span><br><span class="line">	<span class="comment">// 启动一个协程，打印定时器里面的时间</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ch &lt;- <span class="keyword">chan</span> time.Time)</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">			fmt.Println(&lt;-ch)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;(chTime)</span><br><span class="line">	<span class="comment">// 手动阻塞</span></span><br><span class="line">	time.Sleep(<span class="number">4</span> * time.Second)</span><br><span class="line">	fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h2><p><code>NewTimer</code>创建一个Timer，它会在指定时间后，向其自身的C字段发送当时的时间。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;开始时间: %v \n&quot;</span>,time.Now())</span><br><span class="line">	timer := time.NewTimer(time.Second * <span class="number">3</span>)</span><br><span class="line">	<span class="comment">// 此处会阻塞，直到timer.C中有数据写入</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;timer通道里的时间: %v \n&quot;</span>, &lt;- timer.C)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">开始时间: 2021-03-30 14:27:04.966887 +0800 CST m=+0.001502710 </span></span><br><span class="line"><span class="comment">timer通道里的时间: 2021-03-30 14:27:07.970134 +0800 CST m=+3.004701898 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><code>After()</code>函数相当于NewTimer(d).C,如下源码:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">After</span><span class="params">(d Duration)</span></span> &lt;-<span class="keyword">chan</span> Time &#123;</span><br><span class="line">	<span class="keyword">return</span> NewTimer(d).C</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 创建一个计时器,返回的是chan</span></span><br><span class="line">	ch := time.After(<span class="number">5</span> * time.Second)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;开始时间 %v \n&quot;</span>,time.Now())</span><br><span class="line">	<span class="comment">// 此处会阻塞5秒</span></span><br><span class="line">	out := &lt;- ch</span><br><span class="line">	fmt.Printf(<span class="string">&quot;变量out-&gt;  类型: %T 值:%v  \n&quot;</span>,out,out)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 输出</span></span><br><span class="line"><span class="comment">  开始时间 2020-12-10 11:01:07.272154 +0800 CST m=+0.000153152 </span></span><br><span class="line"><span class="comment">  变量out-&gt;  类型: time.Time 值:2020-12-10 11:01:12.273034 +0800 CST m=+5.000956630  </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>strconv包使用</title>
    <url>/2021/04/22/strconv%E5%8C%85%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="转换成数字类型（Parse类函数）"><a href="#转换成数字类型（Parse类函数）" class="headerlink" title="转换成数字类型（Parse类函数）"></a>转换成数字类型（Parse类函数）</h2><h3 id="转换成整型-Atoi"><a href="#转换成整型-Atoi" class="headerlink" title="转换成整型(Atoi)"></a>转换成整型(Atoi)</h3><p>语法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Atoi</span><span class="params">(s <span class="type">string</span>)</span></span> (<span class="type">int</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 将字符串转成整型</span></span><br><span class="line">	s := <span class="string">&quot;666&quot;</span></span><br><span class="line">	sInt, err := strconv.Atoi(s)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;将字符串:%s 转成整型:%d 类型: %T \n&quot;</span>, s, sInt, sInt)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将字符串:666 转成整型:666 类型: int</span></span><br></pre></td></tr></table></figure>

<h3 id="解析成整型-ParseInt"><a href="#解析成整型-ParseInt" class="headerlink" title="解析成整型(ParseInt)"></a>解析成整型(ParseInt)</h3><p>语法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseInt</span><span class="params">(s <span class="type">string</span>, base <span class="type">int</span>, bitSize <span class="type">int</span>)</span></span> (i <span class="type">int64</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p><code>base</code>:表示进制(2到36)。如果base=0,则根据字符串前缀判断,0x:表示十六进制、0:表示八进制、其他代表十进制。<br><code>bitSize</code>: 指定结果必须是不会溢出的整数类型，其值0、8、16、32、64 分别代表int、int8、int16、int32、int64</p>
<p>使用示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 将字符串转成int</span></span><br><span class="line">	s := <span class="string">&quot;666&quot;</span></span><br><span class="line">	i,err := strconv.ParseInt(s,<span class="number">10</span>,<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;类型转换失败&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;字符串%s转成int,%d 类型:%T \n&quot;</span>, s,i,i)</span><br><span class="line">  <span class="comment">// 这里会报错: 将字符串转成int8 int8的范围(-128~127)</span></span><br><span class="line">	ii,err := strconv.ParseInt(s,<span class="number">10</span>,<span class="number">8</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;类型转换int8失败,值溢出&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;字符串%s转成int,%d 类型:%T &quot;</span>, s,ii,ii)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">字符串666转成int,666 类型:int64 </span></span><br><span class="line"><span class="comment">panic: 类型转换int8失败,值溢出</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">goroutine 1 [running]:</span></span><br><span class="line"><span class="comment">main.main()</span></span><br><span class="line"><span class="comment">        /Users/hui/Project/Go/src/go-basic/main.go:20 +0x2dd</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><code>ParseUint</code>与<code>ParseInt</code>类似，但是只用于无符号数字</p>
<h3 id="解析成浮点型-ParseFloat"><a href="#解析成浮点型-ParseFloat" class="headerlink" title="解析成浮点型(ParseFloat)"></a>解析成浮点型(ParseFloat)</h3><p>语法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseFloat</span><span class="params">(s <span class="type">string</span>, bitSize <span class="type">int</span>)</span></span> (<span class="type">float64</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p>将一个字符串s解析成浮点数返回。如果字符串s符合语法规则，会返回一个最为接近s值的浮点数。精度由bitSize指定，其值32表示float32、64表示float32。</p>
<p>使用示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 将字符串转成int</span></span><br><span class="line">	s := <span class="string">&quot;666&quot;</span></span><br><span class="line">	i,err := strconv.ParseFloat(s,<span class="number">32</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;类型转换失败&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;字符串%s转成float,%f 类型:%T \n&quot;</span>, s,i,i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:字符串666转成float,666.000000 类型:float64 </span></span><br></pre></td></tr></table></figure>

<h3 id="解析成布尔型-ParseBool"><a href="#解析成布尔型-ParseBool" class="headerlink" title="解析成布尔型(ParseBool)"></a>解析成布尔型(ParseBool)</h3><p>语法</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseBool</span><span class="params">(str <span class="type">string</span>)</span></span> (<span class="type">bool</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure>
<p>返回字符串表示的布尔值。其值如果是:1,t,T,True,TRUE,true,0,f,F,FALSE,false,F</p>
<table>
    <tr>
        <th>str值</th><th>返回结果</th>
    </tr>
    <tr>
        <td>1,t,T,True,TRUE,true</td><td>true</td>
    </tr>
    <tr>
        <td>0,f,F,FALSE,false,F</td><td>false</td>
    </tr>
    <tr>
        <td>其他值</td><td>false</td>
    </tr>
</table>

<p>使用示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	strSlice := []<span class="type">string</span>&#123;</span><br><span class="line">		<span class="string">&quot;1&quot;</span>,<span class="string">&quot;t&quot;</span>,<span class="string">&quot;T&quot;</span>,<span class="string">&quot;True&quot;</span>,<span class="string">&quot;TRUE&quot;</span>,<span class="string">&quot;true&quot;</span>, <span class="comment">// 都为true</span></span><br><span class="line">		<span class="string">&quot;0&quot;</span>,<span class="string">&quot;f&quot;</span>,<span class="string">&quot;F&quot;</span>,<span class="string">&quot;False&quot;</span>,<span class="string">&quot;FALSE&quot;</span>,<span class="string">&quot;false&quot;</span>, <span class="comment">// 都为false</span></span><br><span class="line">		<span class="string">&quot;9&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;你&quot;</span>,<span class="string">&quot;+&quot;</span>,<span class="comment">// 其他值都是false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _,v :=  <span class="keyword">range</span> strSlice &#123;</span><br><span class="line">		b,_ := strconv.ParseBool(v)</span><br><span class="line">		fmt.Printf(<span class="string">&quot;当x = %s,返回: %t\n&quot;</span>, v,b)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 输出</span></span><br><span class="line"><span class="comment">当x = 1,返回: true</span></span><br><span class="line"><span class="comment">当x = t,返回: true</span></span><br><span class="line"><span class="comment">当x = T,返回: true</span></span><br><span class="line"><span class="comment">当x = True,返回: true</span></span><br><span class="line"><span class="comment">当x = TRUE,返回: true</span></span><br><span class="line"><span class="comment">当x = true,返回: true</span></span><br><span class="line"><span class="comment">当x = 0,返回: false</span></span><br><span class="line"><span class="comment">当x = f,返回: false</span></span><br><span class="line"><span class="comment">当x = F,返回: false</span></span><br><span class="line"><span class="comment">当x = False,返回: false</span></span><br><span class="line"><span class="comment">当x = FALSE,返回: false</span></span><br><span class="line"><span class="comment">当x = false,返回: false</span></span><br><span class="line"><span class="comment">当x = 9,返回: false</span></span><br><span class="line"><span class="comment">当x = a,返回: false</span></span><br><span class="line"><span class="comment">当x = 你,返回: false</span></span><br><span class="line"><span class="comment">当x = +,返回: false</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="转换成字符串-Format类函数"><a href="#转换成字符串-Format类函数" class="headerlink" title="转换成字符串(Format类函数)"></a>转换成字符串(Format类函数)</h2><p>Format类函数主要的功能是将其他类型格式化成字符串。</p>
<h3 id="int转string-Itoa"><a href="#int转string-Itoa" class="headerlink" title="int转string(Itoa)"></a>int转string(Itoa)</h3><p>Itoa源码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由源码可知，Itoa是FormatInt(int64(i), 10)的缩写。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Itoa</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> FormatInt(<span class="type">int64</span>(i), <span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i :=<span class="number">100</span></span><br><span class="line">	s := strconv.Itoa(i)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;转换结果: 值: %s 类型: %T \n&quot;</span>, s,s)</span><br><span class="line">  <span class="comment">// 输出: 转换结果: 值: 100 类型: string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="int转string-ForamtInt"><a href="#int转string-ForamtInt" class="headerlink" title="int转string(ForamtInt)"></a>int转string(ForamtInt)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回指定基数，i的字符串表示。base取值范围 2 &lt;= base &lt;= 36</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatInt</span><span class="params">(i <span class="type">int64</span>, base <span class="type">int</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure>
<p>使用示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> i  <span class="type">int64</span> =<span class="number">123456</span></span><br><span class="line">	s2 := strconv.FormatInt(i,<span class="number">2</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;base=2(二进制) 转换结果: 值: %s 类型: %T \n&quot;</span>, s2,s2)</span><br><span class="line">	s8 := strconv.FormatInt(i,<span class="number">8</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;base=8(八进制) 转换结果: 值: %s 类型: %T \n&quot;</span>, s8,s8)</span><br><span class="line">	s10 := strconv.FormatInt(i,<span class="number">10</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;base=10(十进制) 转换结果: 值: %s 类型: %T \n&quot;</span>, s10,s10)</span><br><span class="line">	s16 := strconv.FormatInt(i,<span class="number">16</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;base=16(十六进制) 转换结果: 值: %s 类型: %T \n&quot;</span>, s16,s16)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">  base=2(二进制) 转换结果: 值: 11110001001000000 类型: string </span></span><br><span class="line"><span class="comment">  base=8(八进制) 转换结果: 值: 361100 类型: string </span></span><br><span class="line"><span class="comment">  base=10(十进制) 转换结果: 值: 123456 类型: string </span></span><br><span class="line"><span class="comment">  base=16(十六进制) 转换结果: 值: 1e240 类型: string </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>ForamtUint和ForamtInt使用方法一样，区别是ForamtUint:无符号，ForamtInt:有符号。</p>
<h3 id="Float转string-ForamtFloat"><a href="#Float转string-ForamtFloat" class="headerlink" title="Float转string(ForamtFloat)"></a>Float转string(ForamtFloat)</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatFloat</span><span class="params">(f <span class="type">float64</span>, fmt <span class="type">byte</span>, prec, bitSize <span class="type">int</span>)</span></span> <span class="type">string</span></span><br><span class="line"><span class="comment">// bitSize: 表示f的来源类型（32:float32 64:float64）,会根据此进行舍入</span></span><br><span class="line"><span class="comment">// fmt: 表示格式标记,（b、e、E、f、g、G）;</span></span><br><span class="line">  <span class="comment">// 格式标记：</span></span><br><span class="line">    <span class="comment">// &#x27;b&#x27; (-ddddp±ddd，二进制指数)</span></span><br><span class="line">    <span class="comment">// &#x27;e&#x27; (-d.dddde±dd，十进制指数)</span></span><br><span class="line">    <span class="comment">// &#x27;E&#x27; (-d.ddddE±dd，十进制指数)</span></span><br><span class="line">    <span class="comment">// &#x27;f&#x27; (-ddd.dddd，没有指数)</span></span><br><span class="line">    <span class="comment">// &#x27;g&#x27; (&#x27;e&#x27;:大指数，&#x27;f&#x27;:其它情况)</span></span><br><span class="line">    <span class="comment">// &#x27;G&#x27; (&#x27;E&#x27;:大指数，&#x27;f&#x27;:其它情况)</span></span><br><span class="line">  <span class="comment">// 如果格式标记为 &#x27;e&#x27;，&#x27;E&#x27;和&#x27;f&#x27;，则 prec 表示小数点后的数字位数</span></span><br><span class="line">  <span class="comment">// 如果格式标记为 &#x27;g&#x27;，&#x27;G&#x27;，则 prec 表示总的数字位数（整数部分+小数部分）</span></span><br><span class="line"><span class="comment">// prec：精度</span></span><br></pre></td></tr></table></figure>
<p>使用示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	i := <span class="number">30.1237</span></span><br><span class="line">	<span class="comment">// 如果格式标记为 &#x27;e&#x27;，&#x27;E&#x27;和&#x27;f&#x27;，则 prec 表示小数点后的数字位数</span></span><br><span class="line">	s1 := strconv.FormatFloat(i,<span class="string">&#x27;f&#x27;</span>,<span class="number">4</span>,<span class="number">32</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;保留4位小数-&gt; 值: %s 类型: %T \n&quot;</span>, s1,s1)</span><br><span class="line">	<span class="comment">// 如果格式标记为 &#x27;g&#x27;，&#x27;G&#x27;，则 prec 表示总的数字位数（整数部分+小数部分）</span></span><br><span class="line">	s2 := strconv.FormatFloat(i,<span class="string">&#x27;g&#x27;</span>,<span class="number">4</span>,<span class="number">32</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;总长度返回4位-&gt; 值: %s 类型: %T \n&quot;</span>, s2,s2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment"> 保留4位小数-&gt; 值: 30.1237 类型: string </span></span><br><span class="line"><span class="comment"> 总长度返回4位-&gt; 值: 30.12 类型: string </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="转布尔型-FormatBool"><a href="#转布尔型-FormatBool" class="headerlink" title="转布尔型(FormatBool)"></a>转布尔型(FormatBool)</h3><p>使用示例</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 返回true字符串</span></span><br><span class="line">	s1 := strconv.FormatBool(<span class="literal">true</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;返回true字符串-&gt; 值: %s 类型: %T \n&quot;</span>, s1,s1)</span><br><span class="line">	<span class="comment">// 返回false字符串</span></span><br><span class="line">	s2 := strconv.FormatBool(<span class="literal">false</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;返回false字符串-&gt; 值: %s 类型: %T \n&quot;</span>, s2,s2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出</span></span><br><span class="line"><span class="comment">  返回true字符串-&gt; 值: true 类型: string </span></span><br><span class="line"><span class="comment">  返回false字符串-&gt; 值: false 类型: string </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>strings包使用</title>
    <url>/2021/04/21/strings%E5%8C%85%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h2><blockquote>
<p>strings是Go内置的标准包,主要用于字符串查找、替换、比较等。常用方法如下:</p>
</blockquote>
<span id="more"></span>
<h3 id="方法列表"><a href="#方法列表" class="headerlink" title="方法列表"></a>方法列表</h3><table>
    <tr>
        <th>方法名</th><th>描述</th>
    </tr>
    <tr>
        <td>Count(s, substr string)int</td><td>返回字符串s包含字符串substr的个数</td>
    </tr>
    <tr>
        <td>Contains(s, substr string)bool</td><td>判断字符串s是否包含substr字符串</td>
    </tr>
    <tr>
        <td>ContainsAny(s, chars string)bool</td><td>判断字符串s是否包含chars字符串中的任意一个字符</td>
    </tr>
    <tr>
        <td>ContainsRune(s string, r rune)bool</td><td>判断字符串s是否包含unicode的码值r</td>
    </tr>
    <tr>
        <td>LastIndex(s, substr string)int</td><td>返回字符串s中字符串substr最后一次出现的位置</td>
    </tr>
    <tr>
        <td>IndexByte(s string, c byte)int</td><td>返回字符串s中字符c首次出现的位置</td>
    </tr>
    <tr>
        <td>IndexRune(s string, r rune)int</td><td>返回unicode的码值r在字符串s中首次出现的位置</td>
    </tr>
    <tr>
        <td>IndexAny(s, chars string)int</td><td>返回字符串chars中的任意一个字符unicode码值,
在s中首次出现的位置</td>
    </tr>
    <tr>
        <td>LastIndexAny(s, chars string)int</td><td>返回字符串chars中的任意一个字符unicode码值,
在s中最后一次出现的位置</td>
    </tr>
    <tr>
        <td>LastIndexByte(s string, c byte)int</td><td>返回字符串s中字符c最后一次出现的位置</td>
    </tr>
    <tr>
        <td>HasPrefix(s, prefix string)bool</td><td>判断字符串s是否有前缀prefix</td>
    </tr>
    <tr>
        <td>HasSuffix(s, suffix string)bool</td><td>判断字符串s是否有后缀suffix</td>
    </tr>
    <tr>
        <td>IndexFunc(s string, f func(r rune)bool)int</td><td>返回字符串s中满足函数f(r)==true,
字符首次出现的位置</td>
    </tr>
    <tr>
        <td>LastIndexFunc(s string, f func(r rune)bool)int</td><td>返回字符串s中满足函数f(r)==true ,
字符最后一次出现的位置</td>
    </tr>
</table>

<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">	<span class="string">&quot;unicode&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 返回字符串s包含字符串substr的个数</span></span><br><span class="line">	s := <span class="string">&quot;hello word&quot;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;字符串:%s,o出现数量: %d\n&quot;</span>,s,strings.Count(s,<span class="string">&quot;o&quot;</span>))</span><br><span class="line">	<span class="comment">// 判断字符串s是否包含substr字符串</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;字符串:%s 是否包含%s ? %t \n&quot;</span>,s,<span class="string">&quot;word&quot;</span>,strings.Contains(s,<span class="string">&quot;word&quot;</span>))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;字符串:%s 是否包含%s ? %t \n&quot;</span>,s,<span class="string">&quot;go&quot;</span>,strings.Contains(s,<span class="string">&quot;go&quot;</span>))</span><br><span class="line">	<span class="comment">// 判断字符串s是否包含chars字符串中的任意一个字符</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;字符串:%s 是否包含%s中的任意一个字符 ? %t \n&quot;</span>,s,<span class="string">&quot;go&quot;</span>,strings.ContainsAny(s,<span class="string">&quot;go&quot;</span>))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;字符串:%s 是否包含%s中的任意一个字符 ? %t \n&quot;</span>,s,<span class="string">&quot;gg&quot;</span>,strings.ContainsAny(s,<span class="string">&quot;gg&quot;</span>))</span><br><span class="line">	<span class="comment">// 判断字符串s是否包含unicode的码值r</span></span><br><span class="line">	r := <span class="string">&#x27;w&#x27;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;字符串:%s 是否包含unicode的码值%c? %t \n&quot;</span>,s,r,strings.ContainsRune(s,r))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;字符串:%s 是否包含unicode的码值%d? %t \n&quot;</span>,s,<span class="number">119</span>,strings.ContainsRune(s,<span class="number">119</span>))</span><br><span class="line">	<span class="comment">// 返回字符串s中字符串substr最后一次出现的位置</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;在字符串%s中,字符串%s最后一次出现的位置? %d \n&quot;</span>,s,<span class="string">&quot;o&quot;</span>,strings.LastIndex(s,<span class="string">&quot;o&quot;</span>))</span><br><span class="line">	<span class="comment">// 返回字符串s中字符串substr首次出现的位置</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;在字符串%s中,字符串%s首次出现的位置? %d \n&quot;</span>,s,<span class="string">&quot;o&quot;</span>,strings.Index(s,<span class="string">&quot;o&quot;</span>))</span><br><span class="line">	<span class="comment">// 返回字符串s中字符c首次出现的位置</span></span><br><span class="line">	<span class="keyword">var</span> b <span class="type">byte</span> = <span class="string">&#x27;l&#x27;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;在字符串%s中,字符%c首次出现的位置? %d \n&quot;</span>,s,b,strings.IndexByte(s,b))</span><br><span class="line">	<span class="comment">// 返回字符串s中字符c最后一次出现的位置</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;在字符串%s中,字符%c最后一次出现的位置? %d \n&quot;</span>,s,b,strings.LastIndexByte(s,b))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 返回unicode的码值r在字符串s中首次出现的位置</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;在字符串%s中,unicode的码值%d(%c)首次出现的位置? %d \n&quot;</span>,s,<span class="number">104</span>,<span class="number">104</span>,strings.IndexRune(s,<span class="number">104</span>))</span><br><span class="line">	<span class="comment">// 返回字符串chars中的任意一个字符unicode码值,在s中首次出现的位置</span></span><br><span class="line">	s3 := <span class="string">&quot;rd&quot;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;返回字符串%s中的任意一个字符unicode码值(%s)首次出现的位置? %d \n&quot;</span>,s,s3,strings.LastIndexAny(s,s3))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断字符串s是否有前缀prefix</span></span><br><span class="line">	a := <span class="string">&quot;VIP001&quot;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;字符串:%s 是否有前缀%s ? %t \n&quot;</span>,a,<span class="string">&quot;vip&quot;</span>,strings.HasPrefix(a,<span class="string">&quot;vip&quot;</span>))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;字符串:%s 是否有前缀%s ? %t \n&quot;</span>,a,<span class="string">&quot;VIP&quot;</span>,strings.HasPrefix(a,<span class="string">&quot;VIP&quot;</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 判断字符串s是否有后缀suffix</span></span><br><span class="line">	sn := <span class="string">&quot;K011_Mn&quot;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;字符串:%s 是否有后缀%s ? %t \n&quot;</span>,sn,<span class="string">&quot;MN&quot;</span>,strings.HasSuffix(sn,<span class="string">&quot;MN&quot;</span>))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;字符串:%s 是否有后缀%s ? %t \n&quot;</span>,sn,<span class="string">&quot;Mn&quot;</span>,strings.HasSuffix(sn,<span class="string">&quot;Mn&quot;</span>))</span><br><span class="line">	<span class="comment">// 返回字符串s中满足函数f(r)==true,字符首次出现的位置 (判断第一个汉字的位置)</span></span><br><span class="line">	f := <span class="function"><span class="keyword">func</span><span class="params">(c <span class="type">rune</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> unicode.Is(unicode.Han,c)</span><br><span class="line">	&#125;</span><br><span class="line">	s4 := <span class="string">&quot;go!中国人&quot;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;字符串:%s 首次出现汉字的位置%d \n&quot;</span>,s4,strings.IndexFunc(s4,f))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;字符串:%s 最后一次出现汉字的位置%d \n&quot;</span>,s4,strings.LastIndexFunc(s4,f))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 输出</span></span><br><span class="line"><span class="comment">  字符串:hello word,o出现数量: 2</span></span><br><span class="line"><span class="comment">  字符串:hello word 是否包含word ? true </span></span><br><span class="line"><span class="comment">  字符串:hello word 是否包含go ? false </span></span><br><span class="line"><span class="comment">  字符串:hello word 是否包含go中的任意一个字符 ? true </span></span><br><span class="line"><span class="comment">  字符串:hello word 是否包含gg中的任意一个字符 ? false </span></span><br><span class="line"><span class="comment">  字符串:hello word 是否包含unicode的码值w? true </span></span><br><span class="line"><span class="comment">  字符串:hello word 是否包含unicode的码值119? true </span></span><br><span class="line"><span class="comment">  在字符串hello word中,字符串o最后一次出现的位置? 7 </span></span><br><span class="line"><span class="comment">  在字符串hello word中,字符串o首次出现的位置? 4 </span></span><br><span class="line"><span class="comment">  在字符串hello word中,字符l首次出现的位置? 2 </span></span><br><span class="line"><span class="comment">  在字符串hello word中,字符l最后一次出现的位置? 3 </span></span><br><span class="line"><span class="comment">  在字符串hello word中,unicode的码值104(h)首次出现的位置? 0 </span></span><br><span class="line"><span class="comment">  返回字符串hello word中的任意一个字符unicode码值(rd)首次出现的位置? 9 </span></span><br><span class="line"><span class="comment">  字符串:VIP001 是否有前缀vip ? false </span></span><br><span class="line"><span class="comment">  字符串:VIP001 是否有前缀VIP ? true </span></span><br><span class="line"><span class="comment">  字符串:K011_Mn 是否有后缀MN ? false </span></span><br><span class="line"><span class="comment">  字符串:K011_Mn 是否有后缀Mn ? true </span></span><br><span class="line"><span class="comment">  字符串:go!中国人 首次出现汉字的位置3 </span></span><br><span class="line"><span class="comment">  字符串:go!中国人 最后一次出现汉字的位置9 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串分割"><a href="#字符串分割" class="headerlink" title="字符串分割"></a>字符串分割</h2><h3 id="方法列表-1"><a href="#方法列表-1" class="headerlink" title="方法列表"></a>方法列表</h3><table>
    <tr>
        <th>方法名</th><th>描述</th>
    </tr>
    <tr>
        <td>Fields(s string)[]string</td><td>将字符串s以空白字符分割，返回切片</td>
    </tr>
    <tr>
        <td>FieldsFunc(s string, f func(r) bool)[]string</td><td>将字符串s以满足f(r)==true的字符分割，
分割后返回切片</td>
    </tr>
    <tr>
        <td>Split(s,sep string)[]string</td><td>将字符串s以sep作为分割符进行分割，
分割后字符最后去掉sep,返回切片</td>
    </tr>
    <tr>
        <td>SplitAfter(s,sep string)[]string</td><td>将字符串s以sep作为分割符进行分割，
分割后字符最后加上sep,返回切片</td>
    </tr>
    <tr>
        <td>SplitAfterN(s,sep string, n int)[]string</td><td>将字符串s以sep作为分割符进行分割，
分割后字符最后加上sep,n决定分割成切片长度</td>
    </tr>
</table>

<h3 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">	<span class="string">&quot;unicode&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	s := <span class="string">&quot;Go! Go! 中国人!&quot;</span></span><br><span class="line">	<span class="comment">// 将字符串s以空白字符分割，返回切片</span></span><br><span class="line">	slice := strings.Fields(s)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串:【%s】以空白字符分割，返回切片:%v \n&quot;</span>, s, slice)</span><br><span class="line">	<span class="comment">// 将字符串s以满足f(r)==true的字符分割，分割后返回切片。</span></span><br><span class="line">	<span class="comment">// 以特殊符号分割</span></span><br><span class="line">	f := <span class="function"><span class="keyword">func</span><span class="params">(r <span class="type">rune</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="comment">// 不是字母，也不是数字</span></span><br><span class="line">		<span class="keyword">return</span> !unicode.IsLetter(r) &amp;&amp; !unicode.IsNumber(r)</span><br><span class="line">	&#125;</span><br><span class="line">	ss := <span class="string">&quot;张三@19*BeiJing&amp;高中生|男(打球&quot;</span></span><br><span class="line">	slice2 := strings.FieldsFunc(ss, f)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串:【%s】 以满足f(r)==true【不是数字和字母都是分隔符】的字符分割，返回切片:%v \n&quot;</span>, ss, slice2)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将字符串s以sep作为分割符进行分割，分割后字符最后去掉sep</span></span><br><span class="line">	s2 := <span class="string">&quot;@123@张@AB@001&quot;</span></span><br><span class="line">	sep1 := <span class="string">&quot;@&quot;</span></span><br><span class="line">	slic1 := strings.Split(s2, sep1)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串:【%s】以%s进行分割，分割后最后去掉:%s 返回切片: %v 切片长度: %d \n&quot;</span>, s2, sep1, sep1, slic1, <span class="built_in">len</span>(slic1))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将字符串s以sep作为分割符进行分割，分割后字符最后加上sep,返回切片</span></span><br><span class="line">	slic2 := strings.SplitAfter(s2, sep1)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串:【%s】以%s进行分割，分割后最后加上:%s 返回切片: %v 切片长度: %d \n&quot;</span>, s2, sep1, sep1, slic2, <span class="built_in">len</span>(slic2))</span><br><span class="line">	<span class="comment">// 将字符串s以sep作为分割符进行分割，分割后字符最后加上sep,n决定分割成切片长度</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串:【%s】以%s进行分割，指定分割切片长度%d: %v 分割后加上%s \n&quot;</span>, s2, sep1, <span class="number">0</span>, strings.SplitAfterN(s2, sep1, <span class="number">0</span>), sep1)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串:【%s】以%s进行分割，指定分割切片长度%d: %v 分割后加上%s \n&quot;</span>, s2, sep1, <span class="number">1</span>, strings.SplitAfterN(s2, sep1, <span class="number">1</span>), sep1)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串:【%s】以%s进行分割，指定分割切片长度%d: %v 分割后加上%s \n&quot;</span>, s2, sep1, <span class="number">5</span>, strings.SplitAfterN(s2, sep1, <span class="number">5</span>), sep1)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串:【%s】以%s进行分割，指定分割切片长度%d: %v 分割后加上%s \n&quot;</span>, s2, sep1, <span class="number">6</span>, strings.SplitAfterN(s2, sep1, <span class="number">6</span>), sep1)</span><br><span class="line">	<span class="comment">// 将字符串s以sep作为分割符进行分割，分割后字符最后去掉sep,n决定分割成切片长度</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串:【%s】以%s进行分割，指定分割切片长度%d: %v 分割后去掉%s \n&quot;</span>, s2, sep1, <span class="number">1</span>, strings.SplitN(s2, sep1, <span class="number">1</span>), sep1)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串:【%s】以%s进行分割，指定分割切片长度%d: %v 分割后去掉%s \n&quot;</span>, s2, sep1, <span class="number">3</span>, strings.SplitN(s2, sep1, <span class="number">3</span>), sep1)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串:【%s】以%s进行分割，指定分割切片长度%d: %v 分割后去掉%s \n&quot;</span>, s2, sep1, <span class="number">5</span>, strings.SplitN(s2, sep1, <span class="number">5</span>), sep1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 输出</span></span><br><span class="line"><span class="comment">将字符串:【Go! Go! 中国人!】以空白字符分割，返回切片:[Go! Go! 中国人!]</span></span><br><span class="line"><span class="comment">将字符串:【张三@19*BeiJing&amp;高中生|男(打球】 以满足f(r)==true【不是数字和字母都是分隔符】的字符分割，返回切片:[张三 19 BeiJing 高中生 男 打球]</span></span><br><span class="line"><span class="comment">将字符串:【@123@张@AB@001】以@进行分割，分割后最后去掉:@ 返回切片: [ 123 张 AB 001] 切片长度: 5</span></span><br><span class="line"><span class="comment">将字符串:【@123@张@AB@001】以@进行分割，分割后最后加上:@ 返回切片: [@ 123@ 张@ AB@ 001] 切片长度: 5</span></span><br><span class="line"><span class="comment">将字符串:【@123@张@AB@001】以@进行分割，指定分割切片长度0: [] 分割后加上@</span></span><br><span class="line"><span class="comment">将字符串:【@123@张@AB@001】以@进行分割，指定分割切片长度1: [@123@张@AB@001] 分割后加上@</span></span><br><span class="line"><span class="comment">将字符串:【@123@张@AB@001】以@进行分割，指定分割切片长度5: [@ 123@ 张@ AB@ 001] 分割后加上@</span></span><br><span class="line"><span class="comment">将字符串:【@123@张@AB@001】以@进行分割，指定分割切片长度6: [@ 123@ 张@ AB@ 001] 分割后加上@</span></span><br><span class="line"><span class="comment">将字符串:【@123@张@AB@001】以@进行分割，指定分割切片长度1: [@123@张@AB@001] 分割后去掉@</span></span><br><span class="line"><span class="comment">将字符串:【@123@张@AB@001】以@进行分割，指定分割切片长度3: [ 123 张@AB@001] 分割后去掉@</span></span><br><span class="line"><span class="comment">将字符串:【@123@张@AB@001】以@进行分割，指定分割切片长度5: [ 123 张 AB 001] 分割后去掉@</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="大小写切换"><a href="#大小写切换" class="headerlink" title="大小写切换"></a>大小写切换</h2><h3 id="方法列表-2"><a href="#方法列表-2" class="headerlink" title="方法列表"></a>方法列表</h3><table>
    <tr>
        <th>方法名</th><th>描述</th>
    </tr>
    <tr>
        <td>Title(s string)string</td><td>将字符串s每个单词首字母大写</td>
    </tr>
    <tr>
        <td>ToLower(s string)string</td><td>将字符串s转换成小写返回</td>
    </tr>
    <tr>
        <td>ToTitle(s string)string</td><td>将字符串s转换成大写返回</td>
    </tr>
    <tr>
        <td>ToUpper(s string)string</td><td>将字符串s转换成大写返回</td>
    </tr>
</table>

<p>大部分情况下， ToUpper 与 ToTitle 返回值相同，但在处理某些unicode编码字符则不同</p>
<h3 id="使用示例-2"><a href="#使用示例-2" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	str := <span class="string">&quot;hello word&quot;</span></span><br><span class="line">	str1 := <span class="string">&quot;HELLO WORD&quot;</span></span><br><span class="line">	<span class="comment">// Title(s string) string: 每个单词首字母大写</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;Title-&gt;将字符串%s 每个单词首字母大写: %s\n&quot;</span>, str, strings.Title(str))</span><br><span class="line">	<span class="comment">// ToLower(s string) string : 将字符串s转换成小写返回</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;ToLower-&gt;将字符串%s 转换成小写返回: %s\n&quot;</span>, str1, strings.ToLower(str1))</span><br><span class="line">	<span class="comment">// ToTitle(s string)string: 将字符串s转换成大写返回</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;ToTitle-&gt;将字符串%s 转换成大写返回: %s\n&quot;</span>, str, strings.ToTitle(str))</span><br><span class="line">	<span class="comment">// ToUpper(s string)string: 将字符串s转换成大写返回</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;ToUpper-&gt;将字符串%s 转换成大写返回: %s\n&quot;</span>, str, strings.ToUpper(str))</span><br><span class="line"></span><br><span class="line">	strr := <span class="string">&quot;ǳ ǵǵǳǳǳ hello world！&quot;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;ToTitle-&gt;将字符串%s 转换成大写返回: %s\n&quot;</span>, strr, strings.ToTitle(strr))</span><br><span class="line">	<span class="comment">// ToUpper(s string)string: 将字符串s转换成大写返回</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;ToUpper-&gt;将字符串%s 转换成大写返回: %s\n&quot;</span>, strr, strings.ToUpper(strr))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">Title-&gt;将字符串hello word 每个单词首字母大写: Hello Word</span></span><br><span class="line"><span class="comment">ToLower-&gt;将字符串HELLO WORD 转换成小写返回: hello word</span></span><br><span class="line"><span class="comment">ToTitle-&gt;将字符串hello word 转换成大写返回: HELLO WORD</span></span><br><span class="line"><span class="comment">ToUpper-&gt;将字符串hello word 转换成大写返回: HELLO WORD</span></span><br><span class="line"><span class="comment">ToTitle-&gt;将字符串ǳ ǵǵǳǳǳ hello world！ 转换成大写返回: ǲ ǴǴǲǲǲ HELLO WORLD！</span></span><br><span class="line"><span class="comment">ToUpper-&gt;将字符串ǳ ǵǵǳǳǳ hello world！ 转换成大写返回: Ǳ ǴǴǱǱǱ HELLO WORLD！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="字符串删除"><a href="#字符串删除" class="headerlink" title="字符串删除"></a>字符串删除</h2><h3 id="方法列表-3"><a href="#方法列表-3" class="headerlink" title="方法列表"></a>方法列表</h3><table>
    <tr>
        <th>方法名</th><th>描述</th>
    </tr>
    <tr>
        <td>Trim(s,cutset string)string</td><td>将字符串s首尾包含在cutset中的任一字符去掉</td>
    </tr>
    <tr>
        <td>TrimFunc(s string,f func(r)bool)string</td><td>将字符串s首尾满足函数f(r)==true的字符串去掉</td>
    </tr>
    <tr>
        <td>TrimLeft(s,cutset string)string</td><td>将字符串s左边包含在cutset中的任一字符去掉</td>
    </tr>
    <tr>
        <td>TrimLeftFunc(s string,f func(r)bool)string</td><td>将字符串s左边满足函数f(r)==true的字符串去掉</td>
    </tr>
    <tr>
        <td>TrimPrefix(s,prefix string)string</td><td>将字符串s中前缀字符串prefix去掉</td>
    </tr>
    <tr>
        <td>TrimRight(s,cutset string)string</td><td>将字符串s右边包含在cutset中的任一字符去掉</td>
    </tr>
    <tr>
        <td>TrimRightFunc(s string, f func(r) bool)string</td><td>将字符串s右边满足函数f(r)==true的字符串去掉</td>
    </tr>
    <tr>
        <td>TrimSpace(s string) string</td><td>将字符串首尾空白去掉</td>
    </tr>
    <tr>
        <td>TrimSuffix(s, suffix string) string</td><td>将字符串s中后缀字符串suffix去掉</td>
    </tr>
</table>


<h3 id="使用示例-3"><a href="#使用示例-3" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 将字符串首尾包含在cutset中的任一字符去掉</span></span><br><span class="line">	str := <span class="string">&quot;@*test@-@124@!*&quot;</span></span><br><span class="line">	cutset := <span class="string">&quot;*#@!&quot;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串【%s】首尾包含在【%s】中的任一字符去掉,返回:【%s】\n&quot;</span>, str, cutset, strings.Trim(str, cutset))</span><br><span class="line">	<span class="comment">// 将字符串首尾满足函数`f(r)==true`的字符串去掉</span></span><br><span class="line">	f := <span class="function"><span class="keyword">func</span><span class="params">(r <span class="type">rune</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> strings.Contains(<span class="string">&quot;*#@!&quot;</span>, <span class="type">string</span>(r)) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串【%s】首尾满足函数f的字符去掉,返回:【%s】\n&quot;</span>, str, strings.TrimFunc(str, f))</span><br><span class="line">	<span class="comment">// 将字符串左边包含在cutset中的任一字符去掉</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串【%s】左边包含在【%s】中的任一字符去掉,返回:【%s】\n&quot;</span>, str, cutset, strings.TrimLeft(str, cutset))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将字符串左边满足函数`f(r)==true`的字符串去掉</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串【%s】左边满足函数f的字符去掉,返回:【%s】\n&quot;</span>, str, strings.TrimLeftFunc(str, f))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将字符串右边包含在cutset中的任一字符去掉</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串【%s】右边包含在【%s】中的任一字符去掉,返回:【%s】\n&quot;</span>, str, cutset, strings.TrimRight(str, cutset))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串【%s】右边满足函数f的字符去掉,返回:【%s】\n&quot;</span>, str, strings.TrimRightFunc(str, f))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将字符串中前缀字符串prefix去掉</span></span><br><span class="line">	str1 := <span class="string">&quot;VIP00001_U&quot;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串【%s】前缀【%s】去掉,返回:【%s】\n&quot;</span>, str1, <span class="string">&quot;VIP&quot;</span>, strings.TrimPrefix(str1, <span class="string">&quot;VIP&quot;</span>))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串【%s】前缀【%s】去掉,返回:【%s】\n&quot;</span>, str1, <span class="string">&quot;vip&quot;</span>, strings.TrimPrefix(str1, <span class="string">&quot;vip&quot;</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将字符串中后缀字符串suffix去掉</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串【%s】后缀【%s】去掉,返回:【%s】\n&quot;</span>, str1, <span class="string">&quot;U&quot;</span>, strings.TrimSuffix(str1, <span class="string">&quot;U&quot;</span>))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串【%s】后缀【%s】去掉,返回:【%s】\n&quot;</span>, str1, <span class="string">&quot;u&quot;</span>, strings.TrimSuffix(str1, <span class="string">&quot;u&quot;</span>))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将字符串首尾空白去掉</span></span><br><span class="line">	str2 := <span class="string">&quot;  hello  word !  &quot;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串【%s】首尾空白去掉,返回:【%s】\n&quot;</span>, str2, strings.TrimSpace(str2))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">将字符串【@*test@-@124@!*】首尾包含在【*#@!】中的任一字符去掉,返回:【test@-@124】</span></span><br><span class="line"><span class="comment">将字符串【@*test@-@124@!*】首尾满足函数f的字符去掉,返回:【test@-@124】</span></span><br><span class="line"><span class="comment">将字符串【@*test@-@124@!*】左边包含在【*#@!】中的任一字符去掉,返回:【test@-@124@!*】</span></span><br><span class="line"><span class="comment">将字符串【@*test@-@124@!*】左边满足函数f的字符去掉,返回:【test@-@124@!*】</span></span><br><span class="line"><span class="comment">将字符串【@*test@-@124@!*】右边包含在【*#@!】中的任一字符去掉,返回:【@*test@-@124】</span></span><br><span class="line"><span class="comment">将字符串【@*test@-@124@!*】右边满足函数f的字符去掉,返回:【@*test@-@124】</span></span><br><span class="line"><span class="comment">将字符串【VIP00001_U】前缀【VIP】去掉,返回:【00001_U】</span></span><br><span class="line"><span class="comment">将字符串【VIP00001_U】前缀【vip】去掉,返回:【VIP00001_U】</span></span><br><span class="line"><span class="comment">将字符串【VIP00001_U】后缀【U】去掉,返回:【VIP00001_】</span></span><br><span class="line"><span class="comment">将字符串【VIP00001_U】后缀【u】去掉,返回:【VIP00001_U】</span></span><br><span class="line"><span class="comment">将字符串【  hello  word !  】首尾空白去掉,返回:【hello  word !】</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="字符串删除-1"><a href="#字符串删除-1" class="headerlink" title="字符串删除"></a>字符串删除</h2><h3 id="方法列表-4"><a href="#方法列表-4" class="headerlink" title="方法列表"></a>方法列表</h3><table>
    <tr>
        <th>方法名</th><th>描述</th>
    </tr>
    <tr>
        <td>Join(elems []string, sep string) string</td><td>将字符串切片elems，使用sep进行拼接</td>
    </tr>
    <tr>
        <td>Repeat(s string, count int) string</td><td>将字符串s,重复count次</td>
    </tr>
</table>


<h3 id="使用示例-4"><a href="#使用示例-4" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 字符串拼接</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;字符串拼接:Join-&gt; %s\n&quot;</span>, strings.Join([]<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;, <span class="string">&quot;|&quot;</span>))</span><br><span class="line">	<span class="comment">// 字符串重复</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;字符串重复:Repeat-&gt; %s\n&quot;</span>, strings.Repeat(<span class="string">&quot;Go!&quot;</span>, <span class="number">10</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">字符串拼接:Join-&gt; a|b|c</span></span><br><span class="line"><span class="comment">字符串重复:Repeat-&gt; Go!Go!Go!Go!Go!Go!Go!Go!Go!Go!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h2><h3 id="方法列表-5"><a href="#方法列表-5" class="headerlink" title="方法列表"></a>方法列表</h3><table>
    <tr>
        <th>方法名</th><th>描述</th>
    </tr>
    <tr>
        <td>Replace(s, old, new string, n int)string</td><td>将字符串s前n个不重叠old子串都替换为new的新字符串
如果n小于0会替换所有old子串。</td>
    </tr>
    <tr>
        <td>ReplaceAll(s, old, new string) string</td><td>将字符串s中的old子串全部替换为new的新字符串</td>
    </tr>
</table>

<h3 id="使用示例-5"><a href="#使用示例-5" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 字符串替换,如果n&lt;0会替换所有old子串。</span></span><br><span class="line">	s := <span class="string">&quot;a,b,c,d,e,f&quot;</span></span><br><span class="line">	old := <span class="string">&quot;,&quot;</span></span><br><span class="line">	newStr := <span class="string">&quot;.&quot;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串【%s】中的前%d个【%s】替换为【%s】结果是【%s】\n&quot;</span>, s, <span class="number">2</span>, old, newStr, strings.Replace(s, old, newStr, <span class="number">2</span>))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串【%s】中的前%d个【%s】替换为【%s】结果是【%s】\n&quot;</span>, s, <span class="number">7</span>, old, newStr, strings.Replace(s, old, newStr, <span class="number">7</span>))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串【%s】中的前%d个【%s】替换为【%s】结果是【%s】\n&quot;</span>, s, <span class="number">-1</span>, old, newStr, strings.Replace(s, old, newStr, <span class="number">-1</span>))</span><br><span class="line">	<span class="comment">// 字符串全部替换</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;将字符串【%s】中的【%s】全部替换为【%s】结果是【%s】\n&quot;</span>, s, old, newStr, strings.ReplaceAll(s, old, newStr))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">将字符串【a,b,c,d,e,f】中的前2个【,】替换为【.】结果是【a.b.c,d,e,f】</span></span><br><span class="line"><span class="comment">将字符串【a,b,c,d,e,f】中的前7个【,】替换为【.】结果是【a.b.c.d.e.f】</span></span><br><span class="line"><span class="comment">将字符串【a,b,c,d,e,f】中的前-1个【,】替换为【.】结果是【a.b.c.d.e.f】</span></span><br><span class="line"><span class="comment">将字符串【a,b,c,d,e,f】中的【,】全部替换为【.】结果是【a.b.c.d.e.f】</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2><h3 id="方法列表-6"><a href="#方法列表-6" class="headerlink" title="方法列表"></a>方法列表</h3><table>
    <tr>
        <th>方法名</th><th>描述</th>
    </tr>
    <tr>
        <td>Compare(a, b string) int</td><td>按字典顺序比较a和b字符串的大小</td>
    </tr>
    <tr>
        <td>EqualFold(s, t string) bool</td><td>判断s和t两个UTF-8字符串是否相等，忽略大小写</td>
    </tr>
</table>

<h3 id="使用示例-6"><a href="#使用示例-6" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 字符串比较大小</span></span><br><span class="line">	s := <span class="string">&quot;a&quot;</span></span><br><span class="line">	s1 := <span class="string">&quot;c&quot;</span></span><br><span class="line">	s2 := <span class="string">&quot;c&quot;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s &gt; %s 返回 : %d \n&quot;</span>, s, s1, strings.Compare(s, s1))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s &gt; %s 返回 : %d \n&quot;</span>, s1, s, strings.Compare(s1, s))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s &gt; %s 返回 : %d \n&quot;</span>, s1, s2, strings.Compare(s1, s2))</span><br><span class="line">	<span class="comment">// 字符串比较一致性</span></span><br><span class="line">	a := <span class="string">&quot;go&quot;</span></span><br><span class="line">	b := <span class="string">&quot;Go&quot;</span></span><br><span class="line">	c := <span class="string">&quot;go&quot;</span></span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s和%s是否相等(忽略大小写)？%t \n&quot;</span>, a, b, strings.EqualFold(a, b))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s和%s是否相等(忽略大小写)？%t \n&quot;</span>, a, c, strings.EqualFold(a, c))</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s和%s是否相等(不忽略大小写)？%t \n&quot;</span>, a, b, a == b)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s和%s是否相等(不忽略大小写)？%t \n&quot;</span>, a, c, a == c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">a &gt; c 返回 : -1</span></span><br><span class="line"><span class="comment">c &gt; a 返回 : 1</span></span><br><span class="line"><span class="comment">c &gt; c 返回 : 0</span></span><br><span class="line"><span class="comment">go和Go是否相等(忽略大小写)？true</span></span><br><span class="line"><span class="comment">go和go是否相等(忽略大小写)？true</span></span><br><span class="line"><span class="comment">go和Go是否相等(不忽略大小写)？false</span></span><br><span class="line"><span class="comment">go和go是否相等(不忽略大小写)？true</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go rpc编程</title>
    <url>/2021/04/20/go-rpc%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>Go语言标准包(net/rpc)已经提供了对RPC的支持，而且支持三个级别的RPC：TCP、HTTP和JSONRPC。<br>Go语言的RPC规则：方法只能有两个可序列化的参数，其中第二个参数是指针类型，并且返回一个error类型，同时必须是公开的方法。</p>
</blockquote>
<span id="more"></span>

<h2 id="TCP版"><a href="#TCP版" class="headerlink" title="TCP版"></a>TCP版</h2><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HelloService <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HelloService)</span></span> Say(request <span class="type">string</span>, response *<span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">	format := time.Now().Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>)</span><br><span class="line">	*response = request + <span class="string">&quot; -- &quot;</span> + format</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 注册服务名称</span></span><br><span class="line">	_ = rpc.RegisterName(<span class="string">&quot;HelloService&quot;</span>, <span class="built_in">new</span>(HelloService))</span><br><span class="line">	<span class="comment">// 监听端口</span></span><br><span class="line">	listen, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:1234&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="comment">// 监听请求</span></span><br><span class="line">		accept, err := listen.Accept()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			log.Fatalf(<span class="string">&quot;Accept Error: %s&quot;</span>, err)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">go</span> rpc.ServeConn(accept)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>rpc.RegisterName()函数调用会将对象类型中所有满足RPC规则的对象方法注册为RPC函数，所有注册的方法会放在HelloService服务的空间之下。然后建立一个唯一的TCP链接，并且通过rpc.ServeConn()函数在该TCP链接上为对方提供RPC服务。</p>
<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 建立链接</span></span><br><span class="line">	dial, err := rpc.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;127.0.0.1:1234&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(<span class="string">&quot;Dial error &quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> result <span class="type">string</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="comment">// 发起请求</span></span><br><span class="line">		_ = dial.Call(<span class="string">&quot;HelloService.Say&quot;</span>, <span class="string">&quot;tcp&quot;</span>, &amp;result)</span><br><span class="line">		fmt.Println(<span class="string">&quot;result:&quot;</span>, result)</span><br><span class="line">		time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先是通过rpc.Dial拨号RPC服务，然后通过dial.Call()调用具体的RPC方法。在调用dial.Call()时，第一个参数是用点号链接的RPC服务名字和方法名字，第二个和第三个参数分别是定义RPC方法的两个参数。</p>
<p>执行结果:<br><img src="abe761a72768434e148816ed88e8b7372f5217689b194fb2179daf864f89c5da.png" alt="图 1">  </p>
<h2 id="HTTP版"><a href="#HTTP版" class="headerlink" title="HTTP版"></a>HTTP版</h2><h3 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/http&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HelloService <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HelloService)</span></span> Say(request <span class="type">string</span>, response *<span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">	format := time.Now().Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>)</span><br><span class="line">	*response = request + <span class="string">&quot; -- &quot;</span> + format</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	userService := <span class="built_in">new</span>(HelloService)</span><br><span class="line">	<span class="comment">// 注册服务</span></span><br><span class="line">	err := rpc.Register(userService)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	rpc.HandleHTTP()</span><br><span class="line">	err = http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 建立链接</span></span><br><span class="line">	client, err := rpc.DialHTTP(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8080&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;err &quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> result <span class="type">string</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="comment">// 发起请求</span></span><br><span class="line">		_ = client.Call(<span class="string">&quot;HelloService.Say&quot;</span>, <span class="string">&quot;http&quot;</span>, &amp;result)</span><br><span class="line">		fmt.Println(<span class="string">&quot;result:&quot;</span>, result)</span><br><span class="line">		time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行结果:<br><img src="89c86ce460cfb840754b438ea1728898f150d0af9144a82884ed5035d13405e7.png" alt="图 2">  </p>
<h2 id="JSON版"><a href="#JSON版" class="headerlink" title="JSON版"></a>JSON版</h2><h3 id="服务端-2"><a href="#服务端-2" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc/jsonrpc&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> HelloService <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *HelloService)</span></span> Say(request <span class="type">string</span>, response *<span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line">	format := time.Now().Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>)</span><br><span class="line">	*response = request + <span class="string">&quot; -- &quot;</span> + format</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 注册服务</span></span><br><span class="line">	err := rpc.RegisterName(<span class="string">&quot;HelloService&quot;</span>, <span class="built_in">new</span>(HelloService))</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;rpc RegisterName err &quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 监听端口</span></span><br><span class="line">	listen, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:9090&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;Listen err &quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 监听</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		conn, err := listen.Accept()</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;conn err &quot;</span>, err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 使用json编码</span></span><br><span class="line">		<span class="keyword">go</span> rpc.ServeCodec(jsonrpc.NewServerCodec(conn))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="客户端-2"><a href="#客户端-2" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc&quot;</span></span><br><span class="line">	<span class="string">&quot;net/rpc/jsonrpc&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// 建立链接</span></span><br><span class="line">	conn, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:9090&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot; rpc.Dial err &quot;</span>, err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 使用json编码</span></span><br><span class="line">	client := rpc.NewClientWithCodec(jsonrpc.NewClientCodec(conn))</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> result <span class="type">string</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="comment">// 发起请求</span></span><br><span class="line">		_ = client.Call(<span class="string">&quot;HelloService.Say&quot;</span>, <span class="string">&quot;json&quot;</span>, &amp;result)</span><br><span class="line">		fmt.Println(<span class="string">&quot;result:&quot;</span>, result)</span><br><span class="line">		time.Sleep(time.Second * <span class="number">2</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行结果:<br><img src="15878f40708d15b8ffaffa1eea1623f012a6bd6127a5f7d3372e80af864f8290.png" alt="图 3">  </p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go grpc使用</title>
    <url>/2021/04/19/go-grpc%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="grpc"><a href="#grpc" class="headerlink" title="grpc"></a>grpc</h2><blockquote>
<p>gRPC 是一个高性能、开源、通用的RPC框架，由Google推出，基于HTTP2协议标准设计开发，默认采用Protocol Buffers数据序列化协议，支持多种开发语言。gRPC提供了一种简单的方法来精确的定义服务，并且为客户端和服务端自动生成可靠的功能库。</p>
</blockquote>
<span id="more"></span>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>最底层为TCP或Unix套接字协议，在此之上是HTTP/2协议的实现，然后在HTTP/2协议之上又构建了针对Go语言的gRPC核心库（gRPC内核+解释器）。应用程序通过gRPC插件生成的Stub代码和gRPC核心库通信，也可以直接和gRPC核心库通信。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="安装protoc"><a href="#安装protoc" class="headerlink" title="安装protoc"></a>安装protoc</h3><p>ubuntu环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install protobuf-compiler</span><br><span class="line"></span><br><span class="line">root@YBNJ0101:~/go/pkg/mod<span class="comment"># protoc --version</span></span><br><span class="line">libprotoc 3.21.2</span><br></pre></td></tr></table></figure>

<h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><ol>
<li><p>安装插件的目的是为了将protobuf文件，生成Go代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.26</span><br><span class="line">$ go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@v1.1</span><br></pre></td></tr></table></figure></li>
<li><p>设置插件环境变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$PATH</span>:<span class="subst">$(go env GOPATH)</span>/bin&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>验证插件是否成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看protoc-gen-go版本</span></span><br><span class="line">$ protoc-gen-go --version                                      </span><br><span class="line">protoc-gen-go v1.26.0</span><br></pre></td></tr></table></figure></li>
<li><p>查看protoc-gen-go-grpc版本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ protoc-gen-go-grpc --version</span><br><span class="line">protoc-gen-go-grpc 1.1.0</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>编写一个使用grpc进行大小写转换的程序，其目录结构如下<br><img src="915fbb210e462a4ea17e54064d50bfa73e4145053783c0162640f559cca79973.png" alt="图 1">  </p>
<h3 id="定义protobuf文件"><a href="#定义protobuf文件" class="headerlink" title="定义protobuf文件"></a>定义protobuf文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line">package proto;</span><br><span class="line"></span><br><span class="line">// 定义go生成后的包名</span><br><span class="line">option go_package = <span class="string">&quot;proto/toupper&quot;</span>;</span><br><span class="line"></span><br><span class="line">// 定义接口</span><br><span class="line">service ToUpper&#123;</span><br><span class="line">  // Sends a greeting</span><br><span class="line">  rpc Upper (UpperRequest) returns (UpperReply) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义入参</span><br><span class="line">message UpperRequest &#123;</span><br><span class="line">  string name = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 定义返回</span><br><span class="line">message UpperReply &#123;</span><br><span class="line">  string message = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="执行protoc命令"><a href="#执行protoc命令" class="headerlink" title="执行protoc命令"></a>执行protoc命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">protoc --go-grpc_out=. --go_out=. proto/toupper.proto</span><br></pre></td></tr></table></figure>

<h3 id="toupper-pb-go部分代码"><a href="#toupper-pb-go部分代码" class="headerlink" title="toupper.pb.go部分代码"></a>toupper.pb.go部分代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> toupper</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	protoreflect <span class="string">&quot;google.golang.org/protobuf/reflect/protoreflect&quot;</span></span><br><span class="line">	protoimpl <span class="string">&quot;google.golang.org/protobuf/runtime/protoimpl&quot;</span></span><br><span class="line">	reflect <span class="string">&quot;reflect&quot;</span></span><br><span class="line">	sync <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	<span class="comment">// Verify that this generated code is sufficiently up-to-date.</span></span><br><span class="line">	_ = protoimpl.EnforceVersion(<span class="number">20</span> - protoimpl.MinVersion)</span><br><span class="line">	<span class="comment">// Verify that runtime/protoimpl is sufficiently up-to-date.</span></span><br><span class="line">	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - <span class="number">20</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义入参</span></span><br><span class="line"><span class="keyword">type</span> UpperRequest <span class="keyword">struct</span> &#123;</span><br><span class="line">	state         protoimpl.MessageState</span><br><span class="line">	sizeCache     protoimpl.SizeCache</span><br><span class="line">	unknownFields protoimpl.UnknownFields</span><br><span class="line"></span><br><span class="line">	Name <span class="type">string</span> <span class="string">`protobuf:&quot;bytes,1,opt,name=name,proto3&quot; json:&quot;name,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *UpperRequest)</span></span> GetName() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> x != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> x.Name</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义返回</span></span><br><span class="line"><span class="keyword">type</span> UpperReply <span class="keyword">struct</span> &#123;</span><br><span class="line">	state         protoimpl.MessageState</span><br><span class="line">	sizeCache     protoimpl.SizeCache</span><br><span class="line">	unknownFields protoimpl.UnknownFields</span><br><span class="line"></span><br><span class="line">	Message <span class="type">string</span> <span class="string">`protobuf:&quot;bytes,1,opt,name=message,proto3&quot; json:&quot;message,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(x *UpperReply)</span></span> GetMessage() <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> x != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> x.Message</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="toupper-grpc-pb-go部分代码"><a href="#toupper-grpc-pb-go部分代码" class="headerlink" title="toupper_grpc.pb.go部分代码"></a>toupper_grpc.pb.go部分代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> toupper</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	context <span class="string">&quot;context&quot;</span></span><br><span class="line">	grpc <span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">	codes <span class="string">&quot;google.golang.org/grpc/codes&quot;</span></span><br><span class="line">	status <span class="string">&quot;google.golang.org/grpc/status&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is a compile-time assertion to ensure that this generated file</span></span><br><span class="line"><span class="comment">// is compatible with the grpc package it is being compiled against.</span></span><br><span class="line"><span class="comment">// Requires gRPC-Go v1.32.0 or later.</span></span><br><span class="line"><span class="keyword">const</span> _ = grpc.SupportPackageIsVersion7</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------- 客户端相关代码 --------</span></span><br><span class="line"><span class="comment">// 客户端接口</span></span><br><span class="line"><span class="keyword">type</span> ToUpperClient <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Sends a greeting</span></span><br><span class="line">	Upper(ctx context.Context, in *UpperRequest, opts ...grpc.CallOption) (*UpperReply, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现客户端接口</span></span><br><span class="line"><span class="keyword">type</span> toUpperClient <span class="keyword">struct</span> &#123;</span><br><span class="line">	cc grpc.ClientConnInterface</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化客户端</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewToUpperClient</span><span class="params">(cc grpc.ClientConnInterface)</span></span> ToUpperClient &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;toUpperClient&#123;cc&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端调用Upper方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *toUpperClient)</span></span> Upper(ctx context.Context, in *UpperRequest, opts ...grpc.CallOption) (*UpperReply, <span class="type">error</span>) &#123;</span><br><span class="line">	out := <span class="built_in">new</span>(UpperReply)</span><br><span class="line">	err := c.cc.Invoke(ctx, <span class="string">&quot;/proto.ToUpper/Upper&quot;</span>, in, out, opts...)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> out, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------- 服务端相关代码 ------------------</span></span><br><span class="line"><span class="comment">// 定义服务端接口</span></span><br><span class="line"><span class="keyword">type</span> ToUpperServer <span class="keyword">interface</span> &#123;</span><br><span class="line">	<span class="comment">// Sends a greeting</span></span><br><span class="line">	Upper(context.Context, *UpperRequest) (*UpperReply, <span class="type">error</span>)</span><br><span class="line">	mustEmbedUnimplementedToUpperServer()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现服务端接口</span></span><br><span class="line"><span class="keyword">type</span> UnimplementedToUpperServer <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现方法，业务代码重写</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(UnimplementedToUpperServer)</span></span> Upper(context.Context, *UpperRequest) (*UpperReply, <span class="type">error</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, status.Errorf(codes.Unimplemented, <span class="string">&quot;method Upper not implemented&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(UnimplementedToUpperServer)</span></span> mustEmbedUnimplementedToUpperServer() &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RegisterToUpperServer</span><span class="params">(s grpc.ServiceRegistrar, srv ToUpperServer)</span></span> &#123;</span><br><span class="line">	s.RegisterService(&amp;ToUpper_ServiceDesc, srv)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="业务server端代码"><a href="#业务server端代码" class="headerlink" title="业务server端代码"></a>业务server端代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;net&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line"></span><br><span class="line">	pb <span class="string">&quot;toupper/proto/toupper&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;golang.org/x/net/context&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc/reflection&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	port = <span class="string">&quot;:50051&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> server <span class="keyword">struct</span> &#123;</span><br><span class="line">	pb.UnimplementedToUpperServer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重写Upper方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *server)</span></span> Upper(ctx context.Context, in *pb.UpperRequest) (*pb.UpperReply, <span class="type">error</span>) &#123;</span><br><span class="line">	log.Printf(<span class="string">&quot;Received: %s&quot;</span>, in.Name)</span><br><span class="line">	<span class="keyword">return</span> &amp;pb.UpperReply&#123;Message: strings.ToUpper(in.Name)&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, port)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;failed to listen: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	s := grpc.NewServer()</span><br><span class="line">	pb.RegisterToUpperServer(s, &amp;server&#123;&#125;)</span><br><span class="line">	<span class="comment">// Register reflection service on gRPC server.</span></span><br><span class="line">	reflection.Register(s)</span><br><span class="line">	<span class="keyword">if</span> err := s.Serve(lis); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;failed to serve: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="业务client端代码"><a href="#业务client端代码" class="headerlink" title="业务client端代码"></a>业务client端代码</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;log&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line"></span><br><span class="line">	pb <span class="string">&quot;toupper/proto/toupper&quot;</span></span><br><span class="line"></span><br><span class="line">	<span class="string">&quot;golang.org/x/net/context&quot;</span></span><br><span class="line">	<span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	address = <span class="string">&quot;localhost:50051&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// Set up a connection to the server.</span></span><br><span class="line">	conn, err := grpc.Dial(address, grpc.WithInsecure())</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;did not connect: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">defer</span> conn.Close()</span><br><span class="line">	c := pb.NewToUpperClient(conn)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Contact the server and print out its response.</span></span><br><span class="line">	name := <span class="string">&quot;hello world&quot;</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(os.Args) &gt; <span class="number">1</span> &#123;</span><br><span class="line">		name = os.Args[<span class="number">1</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	r, err := c.Upper(context.Background(), &amp;pb.UpperRequest&#123;Name: name&#125;)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatalf(<span class="string">&quot;could not greet: %v&quot;</span>, err)</span><br><span class="line">	&#125;</span><br><span class="line">	log.Printf(<span class="string">&quot;Response: %s&quot;</span>, r.Message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># go mod init toupper</span></span><br><span class="line"><span class="comment"># go mod tidy</span></span><br><span class="line">root@YBNJ0101:/home/rma/mr_work/go_test/toupper<span class="comment"># make </span></span><br><span class="line">protoc --go-grpc_out=. --go_out=. proto/toupper.proto</span><br><span class="line">go build main/client.go</span><br><span class="line">go build main/server.go</span><br></pre></td></tr></table></figure>

<p>运行结果如下<br><img src="fc1fef8e5b134a34d33fbf00c34ab04ea3b77b953852d889f0614fe1a26aa6c1.png" alt="图 2"><br><img src="fecbbc770af2af4ffd88b410cdc82c082773e2998103403068c489aa8f081534.png" alt="图 3">  </p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>包依赖管理</title>
    <url>/2021/04/18/%E5%8C%85%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h2 id="失宠的-Vendor-目录"><a href="#失宠的-Vendor-目录" class="headerlink" title="失宠的 Vendor 目录"></a>失宠的 Vendor 目录</h2><blockquote>
<p>Vendor目录是Golang从1.5版本开始引入的，为项目开发提供了一种离线保存第三方依赖包的方法。但是到了Golang 1.11之后，由于引入了Module功能，在运行go build时，优先引用的是Module依赖包的逻辑，所以Vendor目录就被“无视”了，进而可能发生编译错误， moudle 说还是很想他，于是 提供了 go mod vendor 命令用来生成 vendor 目录。这样能避免一些编译问题，依赖可以先从 vendor 目录进行扫描。</p>
</blockquote>
<span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ go mod <span class="built_in">help</span> vendor</span><br><span class="line">usage: go mod vendor [-v]</span><br><span class="line"></span><br><span class="line">Vendor resets the main module<span class="string">&#x27;s vendor directory to include all packages needed to build and test all the main module&#x27;</span>s packages.</span><br><span class="line">It does not include <span class="built_in">test</span> code <span class="keyword">for</span> vendored packages.</span><br></pre></td></tr></table></figure>
<p>这句话的意思是： 把 go mod init 后下载的相关依 赖包(Gopath 的 pkg) 目录，拷贝到 vendor 目录。</p>
<h2 id="GOROOT-和-GOPATH"><a href="#GOROOT-和-GOPATH" class="headerlink" title="GOROOT 和 GOPATH"></a>GOROOT 和 GOPATH</h2><p><code>GOROOT</code>： go的安装路径，默认usr/local/go，go自带的包放在/usr/local/go/src底下。<br><code>GOPATH</code>： go mod 是 Golang 1.11 版本引入的依赖包管理工具，替换旧的基于 GOPATH 的依赖包管理方式。GOPATH 不再需要包含 src 子目录，使用 go.mod 方式管理的依赖包都被下载到了 $GOPATH/pkg/mod 目录</p>
<h2 id="包依赖查找顺序"><a href="#包依赖查找顺序" class="headerlink" title="包依赖查找顺序"></a>包依赖查找顺序</h2><ul>
<li>优先使用vendor目录下面的包</li>
<li>搜索$GOPATH/pkg/mod下面的包</li>
<li>搜索$GOROOT/src下面的包</li>
</ul>
<p><strong>注意</strong>：vendor和$GOPATH只能选择其一，不能混用</p>
<h2 id="go-mod"><a href="#go-mod" class="headerlink" title="go mod"></a>go mod</h2><p>有了 go mod 之后，每个项目（源代码目录）就是一个 Module，只要其中包含了 go.mod 文件。go mod 指令和 go.mod 文件用于记录和解析模块之间的依赖性。<br>go.mod 文件一旦创建后，它的内容将会被 go toolchain（工具链）完全掌控，比如：执行 go get、go build、go mod 等指令时，会自动修改和维护 go.mod 文件。<br>除了 go.mod 之外，go 指令还维护了一个 go.sum 文件，其中包含特定模块版本内容的加密哈希。go 指令使用 go.sum 文件来确保这些模块的哈希值，以确保项目所依赖的模块不会出现意外更改。<br>go.mod 和 go.sum 都应该应用于版本控制。 并且 go.sum 不需要手工维护，所以可以不用太关注。</p>
<h2 id="使用go-mod"><a href="#使用go-mod" class="headerlink" title="使用go mod"></a>使用go mod</h2><p>初始化一个 Module：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go mod init &lt;project_name&gt;</span><br></pre></td></tr></table></figure>

<p>删除错误或者不使用的 Modules：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go mod tidy</span><br></pre></td></tr></table></figure>
<p>此时当前工程目录下会生成两个文件go.mod和go.sum<br><img src="4a771fd6162103583ef57364eb268d064690bde30f1b21bfdefa45f3941ca600.png" alt="图 1">  </p>
<p><img src="4d9d0377985f1aed11bd0982191d8a001923891ea66e9d4cb21f27052638f278.png" alt="图 2">  </p>
<h2 id="防止包依赖升级不兼容"><a href="#防止包依赖升级不兼容" class="headerlink" title="防止包依赖升级不兼容"></a>防止包依赖升级不兼容</h2><p>生成 Vendor 目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go mod vendor</span><br></pre></td></tr></table></figure>
<p>此时会将$GOPATH/pkg/mod底下依赖的包拷贝当前工程vendor底下<br><img src="a7f44963848995870bc26d49e4f8bea4a1333c6e47c829a9446536f92c6ef590.png" alt="图 3">  </p>
<p>这样项目包搜索时会优先搜索vendor目录下的包</p>
<p>后续如果引入新的包依赖，则需要再次执行<code>go mod tidy</code><br>由于vendor和$GOPATH只能选择其一，不能混用，所以还需要执行<code>go mod vendor</code></p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go常用包列表</title>
    <url>/2021/04/17/go%E5%B8%B8%E7%94%A8%E5%8C%85%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<p>net yaml glog</p>
<p>go常用包(三十五):高性能的goroutine池[ants]<br>1.介绍ants是一个高性能的 goroutine 池，实现了对大规模 goroutine 的调度管理、goroutine 复用，允许使用者在开发并发程序的时候限制 goroutine 数量，复用资源…</p>
<span id="more"></span>

<p>go常用包(三十四):高性能http客户端fasthttp</p>
<ol>
<li>介绍fasthttp是由valyala编写,并宣称比Go官方标准库net/http快十倍。fasthttp采用了许多性能优化上的最佳实践，尤其是在内存对象的重用上，大量使用sync.Pool以降…</li>
</ol>
<p>go常用包(三十三):高性能json解析器</p>
<ol>
<li>介绍json-iterator是一款快且灵活的JSON解析器,不但100%兼容标准库encoding/json,而且比其更快。虽然官网说比标准包encoding/json快6倍之多，但是随着Go…</li>
</ol>
<p>go常用包(三十二):现代的go工具库go-funk</p>
<ol>
<li>介绍Go-funk 是基于反射(reflect )实现的一个现代Go工具库，封装了对slice/map/struct/string等的操作。2. 下载# 下载go get github.com/…</li>
</ol>
<p>go常用包(三十一):性能调试利器使用(下)</p>
<ol>
<li>trace说明在pprof的分析中，能够知道一段时间内的CPU占用、内存分配、协程堆栈信息。这些信息都是一段时间内数据的汇总，但是它们并没有提供整个周期内发生的事件，例如指定的Goroutine…</li>
</ol>
<p>go常用包(三十):性能调试利器使用(中)</p>
<ol>
<li>调用图说明1.1 示例图1.2 节点颜色红色代表累计值cum为正，并且很大；绿色代表累计值cum为负，并且很大；灰色代表累计值cum可以忽略不计。1.3 节点字体大小较大的字体表示较大的当前值；…</li>
</ol>
<p>go常用包(二十九):性能调试利器使用(上)</p>
<ol>
<li>介绍Go语言中的pprof指对于指标或特征的分析（Profiling），通过分析不仅可以查找到程序中的错误（内存泄漏、race冲突、协程泄漏），也能对程序进行优化（例如CPU利用率不足）。由于G…</li>
</ol>
<p>go常用包(二十八):构建现代cli应用库cobra</p>
<ol>
<li>介绍cobra是一个用来构建现代CLI工具的库。相比flag标准库，它提供更多方便的特性和功能。Cobra 由 Go 项目成员和 hugo 作者 spf13 创建，已经被许多流行的 Go 项目采…</li>
</ol>
<p>go常用包(二十七):定时任务管理库cron<br>1.介绍在Linux中，通过crontab命令使任务在约定的时间执行已经计划好的工作，而Go由于语言的特性，不适合直接使用crontab来管理计划任务，cron (目前 Star8.3k)是一个用Go…</p>
<p>go常用包(二十六):知名爬虫框架colly<br>1.介绍Colly是Golang世界中最知名的Web爬虫框架,它提供简洁的 API，拥有强劲的性能、可以自动处理 cookie&amp;session、提供灵活的扩展机制,同时支持分布式抓取和多种存储…</p>
<p>go常用包(二十五):elasticsearch客户端的实现<br>1.介绍Elasticsearch（ES）是一个基于Lucene构建的开源、分布式、RESTful接口的全文搜索引擎。Elasticsearch还是一个分布式文档数据库，其中每个字段均可被索引，而且每…</p>
<p>go常用包(二十四):单元测试(testinng)</p>
<ol>
<li>介绍testing 包为Go 语言提供自动化测试的支持。通过 go test 命令来执行单元测试文件，单元测试文件命名格式为: xxx_test.go,在单元测试文件中,根据测试类型不同可以分为…</li>
</ol>
<p>go常用包(二十三):操作redis开源库(go-redis)</p>
<ol>
<li>介绍redis官网推荐使用redigo(<a href="https://github.com/gomodule/redigo)%EF%BC%8C%E6%88%AA%E6%AD%A2%E5%88%B0%E4%BB%8A%E5%A4%A9Github">https://github.com/gomodule/redigo)，截止到今天Github</a> Start是8.2k 但go-redis(https://…</li>
</ol>
<p>go常用包(二十二):jwt在golang中的实现(jwt-go)</p>
<ol>
<li>介绍JWT全称JSON Web Token是一种跨域认证解决方案，属于一个开放的标准，它规定了一种Token实现方式，目前多用于前后端分离项目和OAuth2.0业务场景下。jwt-go 是使用G…</li>
</ol>
<p>go常用包(二十一):360开源高性能excel库(excelize)</p>
<ol>
<li>介绍1. 1 什么是ExcelizeExcelize 是 Go 语言编写的用于操作 Office Excel 文档基础库，基于 ECMA-376，ISO/IEC 29500 国际标准。可以使用它…</li>
</ol>
<p>go常用包(二十):数学计算和常数(math)</p>
<ol>
<li>介绍Go标准包math,提供了基本的数学常数和数学函数。2. 常量2.1 整数取值const ( MaxInt8 = 1&lt;&lt;7 - 1 // int8最大值 MinI…</li>
</ol>
<p>gin集成(三):集成全功能orm框架-gorm<br>齐全，对开发者友好，支持主流数据库。具体使用可参考之前的文章go常用包(十九):全功能ORM框架(gorm)1.1 集成流程1.2 涉及目录2. 配置2.1 编辑主配置./config.yamlmysql: host: 127.0.0.1 port: 33…</p>
<p>go常用包(十九):全功能orm框架[gorm]使用</p>
<ol>
<li>介绍gorm是一个使用Go语言编写的ORM框架。 它文档齐全，对开发者友好，支持主流数据库。官方中文文档 <a href="https://gorm.io/zh_CN/docs/index.html2">https://gorm.io/zh_CN/docs/index.html2</a>. 安装go…</li>
</ol>
<p>go常用包(十八):结构体匿名字段的json序列化、反序列化</p>
<ol>
<li>介绍Go的标准包 encoding/json实现了json对象的编码和解码。这篇文章主要讲的是结构体中嵌套匿名字段时的序列化和反序列化，因结构体在参与序列时会有很多细节规则，平时常用的也是结构体…</li>
</ol>
<p>go常用包(十七):crypto之rsa非对称加解密</p>
<ol>
<li>维基百科释义RSA加密算法是一种非对称加密算法，在公开密钥加密和电子商业中被广泛使用。RSA是由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（L…</li>
</ol>
<p>go常用包(十六):crypto之aes加解密<br>1.介绍高级加密标准（英语：Advanced Encryption Standard，缩写：AES），又称Rijndael加密法（荷兰语发音：[ˈrɛindaːl]，音似英文的“Rhine doll”…</p>
<p>go常用包(十五):系统基本操作包使用(os)<br>1.介绍os包中提供了操作系统函数的接口，是一个比较重要的包。它的作用主要是在服务器上进行系统的基本操作，如文件操作、目录操作、执行命令、信号与中断、进程、系统状态等等。下面分模块归纳一些常用函数。2…</p>
<p>go常用包(十二):rune字符操作包(unicode)<br>1.介绍unicode包提供了诸多处理rune字符相关功能的函数（比如区分字母和数字，或者是字母的大写和小写转换等)2.判断函数2.1 是否为空格(IsSpace)func TestJudge(t *…</p>
<p>go常用包(十一):sort排序和查询<br>1.介绍sort包实现了四种基本排序算法：插入排序、归并排序、堆排序、快速排序。 但是这四种排序方法是不公开的，它们只能在 sort 包内部使用。sort 包会根据实际数据自动选择高效的排序算法，所以…</p>
<p>go常用包(九):flag命令行参数解析<br>1.介绍在 Go中，如果要接收命令行参数，需要使用 flag包进行解析。不同的参数类型可以通过不同的方法接收。2.参数接受2.1 接受方式使用flag接收参数，可以由以下三种方式接受：方式一: fla…</p>
<p>go常用包(八):sync辅助并发安全<br>1.介绍sync包提供了互斥锁。除了Once和WaitGroup类型，其余多数适用于低水平的程序，多数情况下，高水平的同步使用channel通信性能会更优一些。2.并发等待组(WaitGroup)Wa…</p>
<p>go常用包(七):context上下文<br>1.什么是上下文?从Go 1.7开始,标准库引入context(上下文)，他主要用来在goroutine之间传递上下文信息(同步信号、超时时间、截止时间、Key-Val值对)。2. 为什么要用上下文?…</p>
<p>go常用包(六):bufio有缓存的io包使用<br>1.介绍bufio包实现了有缓冲的I/O。它包装一个io.Reader或io.Writer接口对象，使用这个包可以大幅提高文件读写的效率。1.如何提高效率?1.写入流程梳理:当写入内容小于缓冲区(bu…</p>
<p>go常用包(五):ioutil包使用<br>1.介绍在Go语言中，io包主要声明的是对I/O操作的基本接口，而io/ioutil包则实现了对应的方法，方便我们直接使用。2.方法列表方法名描述NopCloser对Reader进行封装，返回一个Re…</p>
<p>go常用包(四):fmt包使用<br>1.输出控制台1.1 PrintfPrintf根据format参数生成格式化的字符串并写入标准输出。返回写入的字节数和遇到的任何错误。1.format格式动 词功 能%v 按值的本来值输出%+v在…</p>
<p>go常用包(三):time(时间)包使用<br>1.获取时间1.1 当前时间unix := time.Now().Unix()fmt.Printf(“当前时间戳(单位秒): %v \n”,unix)nano := time.No…</p>
<p>go常用包(二):strconv(字符串转换)包使用<br>1.转换成其他类型（Parse类函数）1.1 转换成整型(Atoi)1.语法func Atoi(s string) (int, error)2.使用示例package mainimport (&amp;quo…</p>
<p>go常用包(一):strings(字符串操作)包使用<br>字符串查找strings是Go内置的标准包,主要用于字符串查找、替换、比较等。</p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go select详解</title>
    <url>/2021/04/16/go-select%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>select是一种go可以处理多个通道之间的机制，看起来和switch语句很相似，但是select其实和IO机制中的select一样，多路复用通道，随机选取一个进行执行，如果说通道(channel)实现了多个goroutine之前的同步或者通信，那么select则实现了多个通道(channel)的同步或者通信，并且select具有阻塞的特性。</p>
</blockquote>
<span id="more"></span>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span> </span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> func1 ()  &#123;</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        ch1 &lt;- <span class="number">1</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> func2 ()  &#123;</span><br><span class="line">        ch2 &lt;- <span class="number">3</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> i := &lt;-ch1:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;从ch1读取了数据%d&quot;</span>, i)</span><br><span class="line">    <span class="keyword">case</span> j := &lt;-ch2:</span><br><span class="line">        fmt.Printf(<span class="string">&quot;从ch2读取了数据%d&quot;</span>, j)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码很简单，我们创建了两个无缓冲的channel，通过两个goroutine向ch1，ch2两个通道发送数据，通过select随机读取ch1，ch2的返回值，但是由于func1有sleep，所以这个例子我们总是从ch2读到结果，打印从ch2读取了数据3<br><img src="46ac4f2ed81a35effa77adda1402be4892bc97d8d9a877c4bc2e8c1ec3a921da.png" alt="图 1">  </p>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>select这个特性到底有什么用呢，下面我们来介绍一些使用select的场景</p>
<h3 id="竞争选举"><a href="#竞争选举" class="headerlink" title="竞争选举"></a>竞争选举</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> i := &lt;-ch1:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;从ch1读取了数据%d&quot;</span>, i)</span><br><span class="line"><span class="keyword">case</span> j := &lt;-ch2:</span><br><span class="line">    fmt.Printf(<span class="string">&quot;从ch2读取了数据%d&quot;</span>, j)</span><br><span class="line"><span class="keyword">case</span> m := &lt;-ch3</span><br><span class="line">    fmt.Printf(<span class="string">&quot;从ch3读取了数据%d&quot;</span>, m)</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个是最常见的使用场景，多个通道，有一个满足条件可以读取，就可以“竞选成功”</p>
<h3 id="超时处理（保证不阻塞）"><a href="#超时处理（保证不阻塞）" class="headerlink" title="超时处理（保证不阻塞）"></a>超时处理（保证不阻塞）</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag.Parse()</span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">	time_wait := flag.Arg(<span class="number">0</span>)</span><br><span class="line">	<span class="type">int64</span>, err := strconv.ParseInt(time_wait, <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(time.Second * time.Duration(<span class="type">int64</span>))</span><br><span class="line">		ch1 &lt;- <span class="number">1</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> str := &lt;-ch1:</span><br><span class="line">		fmt.Println(<span class="string">&quot;receive str&quot;</span>, str)</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(time.Second * <span class="number">3</span>):</span><br><span class="line">		fmt.Println(<span class="string">&quot;timeout!!&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：<br><img src="d0d3e6659b280473c457134eef984b8e1826932dfd744db2fad60427be2dcc0f.png" alt="图 2">  </p>
<p>因为select是阻塞的，我们有时候就需要搭配超时处理来处理这种情况，超过某一个时间就要进行处理，保证程序不阻塞。</p>
<p>判断buffered channel是否阻塞<br>比如我们有一个有限的资源（这里用buffer channel实现），我们每一秒向bufChan传送数据，由于生产者的生产速度大于消费者的消费速度，故会触发default语句，这个就很像我们web端来显示并发过高的提示了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span> </span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    bufChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">5</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span> <span class="params">()</span></span>  &#123;</span><br><span class="line">        time.Sleep(time.Second)</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            &lt;-bufChan</span><br><span class="line">            time.Sleep(<span class="number">5</span>*time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;() </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> bufChan &lt;- <span class="number">1</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;add success&quot;</span>)</span><br><span class="line">            time.Sleep(time.Second)</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(<span class="string">&quot;资源已满，请稍后再试&quot;</span>)</span><br><span class="line">            time.Sleep(time.Second)</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果如下：<br><img src="041886cbb4cb63fa48864f3c6ef0755724d0960a572cbcfdfe0350ec4757688d.png" alt="图 3">  </p>
<h3 id="阻塞main函数"><a href="#阻塞main函数" class="headerlink" title="阻塞main函数"></a>阻塞main函数</h3><p>有时候我们会让main函数阻塞不退出，如http服务，我们会使用空的select{}来阻塞main goroutine</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    bufChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span>&#123;</span><br><span class="line">            bufChan &lt;<span class="number">-1</span></span><br><span class="line">            time.Sleep(time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span>&#123;</span><br><span class="line">            fmt.Println(&lt;-bufChan)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">select</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：<br><img src="30e1d7fd42b02ff6ff4d420bef2393f02d4fe420d23ef2c108723ecfc7109d12.png" alt="图 4">  </p>
<p>如上所示，这样主函数就永远阻塞住了，这里要注意上面一定要有一直活动的goroutine,否则会报deadlock。<br>如果这里使用for {}，那么top查看该进程cpu 100%。</p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go打印调用栈信息</title>
    <url>/2021/04/15/go%E6%89%93%E5%8D%B0%E8%B0%83%E7%94%A8%E6%A0%88%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><blockquote>
<p>在日志信息中，有时需要获取当前函数的调用信息，比如打印调用栈<br>debug.Stack() []byte</p>
</blockquote>
<span id="more"></span>

<p><code>debug.Stack()</code>函数可以获取当前 goroutine 的调用栈信息，需要import “runtime/debug”</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;--- BEGIN ---&quot;</span>)</span><br><span class="line">    fmt.Println(string(debug.Stack()))</span><br><span class="line">    fmt.Println(<span class="string">&quot;--- END ---&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">boom</span></span>() &#123;</span><br><span class="line">    foo()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    boom()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以获得类似输出结果：<br><img src="0b0adaa3d5e6c9ba15bd2eb91ccefc7f6cf360ac25ac2abb4939c227b5ffd0fe.png" alt="图 1">  </p>
<p>debug.Stack()函数源码在runtime/debug/stack.go中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func Stack() []byte &#123;</span><br><span class="line">    buf := make([]byte, 1024)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        n := runtime.Stack(buf, <span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">if</span> n &lt; len(buf) &#123;</span><br><span class="line">            <span class="built_in">return</span> buf[:n]</span><br><span class="line">        &#125;</span><br><span class="line">        buf = make([]byte, 2*len(buf))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到它是通过调用runtime.Stack获取的调用栈信息， 其中第二个参数all表示是否获取所有 goroutine 的调用栈。可以将第二个参数改为true然后创建多个 goroutine 查看输出效果。</p>
<h2 id="更可控的调用信息"><a href="#更可控的调用信息" class="headerlink" title="更可控的调用信息"></a>更可控的调用信息</h2><p>上面两个函数虽然可以获取调用栈，但是直接将所有调用信息返回，控制参数较少。</p>
<p>下面几个函数可以实现获取单层的调用信息</p>
<p><code>runtime.Caller</code>函数可以获取调用者的信息</p>
<p>参数<code>skip</code>：表示跳过的层级，相当于往上获取第几层的调用者。0 表示当前函数，1 表示上一层函数，依次往上。</p>
<p>返回值<br><code>pc</code>：program counter（不知道该怎么翻译，程序计数器？），可以大概理解为函数编号，可以通过<code>runtime.FuncForPC</code>解析<br><code>file</code>：文件名<br><code>line</code>：行号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">    pc, file, line, ok := runtime.Caller(1)</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        fmt.Println(runtime.FuncForPC(pc).Name(), file, line)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以得到这样一条输出：<br><img src="65532387773ae03007e8d918d927388d402b6bb9d16e5c8c2d2b816180fb5312.png" alt="图 2">  </p>
<h3 id="runtime-CallersFrames-callers-uintptr-runtime-Frames"><a href="#runtime-CallersFrames-callers-uintptr-runtime-Frames" class="headerlink" title="runtime.CallersFrames(callers []uintptr) *runtime.Frames"></a>runtime.CallersFrames(callers []uintptr) *runtime.Frames</h3><p><code>runtime.CallersFrames</code>可以一次解析多个pc</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">func <span class="function"><span class="title">foo</span></span>() &#123;</span><br><span class="line">    pc := make([]uintptr, 10)</span><br><span class="line">    n := runtime.Callers(1, pc)</span><br><span class="line">    frames := runtime.CallersFrames(pc[:n])</span><br><span class="line"></span><br><span class="line">    var frame runtime.Frame</span><br><span class="line">    more := n &gt; 0</span><br><span class="line">    <span class="keyword">for</span> more &#123;</span><br><span class="line">        frame, more = frames.Next()</span><br><span class="line">        fmt.Printf(<span class="string">&quot;%s %d %s\n&quot;</span>, frame.File, frame.Line, frame.Function)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：<br><img src="4f7ebb587aa9aadeb191b91014112e7dac4e7d89046dcdd2e0f8099af431e5eb.png" alt="图 3">  </p>
<h3 id="func-runtime-FuncForPC-pc-uintptr-runtime-Func"><a href="#func-runtime-FuncForPC-pc-uintptr-runtime-Func" class="headerlink" title="func runtime.FuncForPC(pc uintptr) *runtime.Func"></a>func runtime.FuncForPC(pc uintptr) *runtime.Func</h3><p>前面使用了runtime.FuncForPC来解析pc，获得函数信息。</p>
<p>它返回的*runtime.Func主要有三个方法：<br><code>Entry() uintptr</code>: 返回函数入口地址（函数注释Entry address of the function）<br><code>Name() string</code>: 返回函数名<br><code>FileLine(pc uintptr) (file string, line int)</code>: 返回文件名和行号</p>
]]></content>
      <categories>
        <category>GO</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>lex文件分析</title>
    <url>/2021/04/14/lex%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="lex文件组成"><a href="#lex文件组成" class="headerlink" title="lex文件组成"></a>lex文件组成</h2><blockquote>
<p>lex文件由3段组成，用2个%%行把这3段隔开。<br>定义段 Definition section<br>%%<br>规则段 Rules section<br>%%<br>用户代码段 user code section</p>
</blockquote>
<span id="more"></span>

<h2 id="定义段"><a href="#定义段" class="headerlink" title="定义段"></a>定义段</h2><blockquote>
<p>可以包括：<br>1-C代码，这块可以放C语言的各种各种include，define等声明语句，但是要用%{ %}括起来。这些声明会原样拷到生成的.c文件中。<br>2-状态condition声明，如%x COMMENT。<br>3-正则式定义，如digit ([0-9])。</p>
</blockquote>
<h3 id="定义段（definitions）开始。"><a href="#定义段（definitions）开始。" class="headerlink" title="定义段（definitions）开始。"></a>定义段（definitions）开始。</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_GLOB_H</span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;glob.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util/config_file.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util/configparser.h&quot;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ub_c_error</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *message)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEXOUT(s)  printf s <span class="comment">/* used ONLY when debugging */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEXOUT(s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** avoid warning in about fwrite return value */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ECHO ub_c_error_msg(<span class="string">&quot;syntax error at text: %s&quot;</span>, yytext)</span></span><br></pre></td></tr></table></figure>

<p>定义了一个YDVAR的宏，该宏用于处理config文件里的变量定义行，例如：<br>server:<br>interface: 192.168.200.83<br>port: 20053<br>access-control: 127.0.0.0/8 allow<br>module-config: “iterator”<br>等类似这样的定义，主要功能是进入val状态（在变量数量大于0的情况下），返回一个token number(return var)。</p>
<p>两个参数，nargs：变量数，var：token值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** A parser variable, this is a statement in the config file which is</span></span><br><span class="line"><span class="comment"> * of the form variable: value1 value2 ...  nargs is the number of values. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YDVAR(nargs, var) \</span></span><br><span class="line"><span class="meta">	num_args=(nargs); \</span></span><br><span class="line"><span class="meta">	LEXOUT((<span class="string">&quot;v(%s%d) &quot;</span>, yytext, num_args)); \</span></span><br><span class="line"><span class="meta">	<span class="keyword">if</span>(num_args &gt; 0) &#123; BEGIN(val); &#125; \</span></span><br><span class="line"><span class="meta">	return (var);</span></span><br></pre></td></tr></table></figure>

<p>定义一个保存include其他文件状态的结构体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inc_state</span> &#123;</span></span><br><span class="line">	<span class="type">char</span>* filename;</span><br><span class="line">	<span class="type">int</span> line;</span><br><span class="line">	YY_BUFFER_STATE buffer;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inc_state</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">inc_state</span>* <span class="title">config_include_stack</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> inc_depth = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> inc_prev = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> num_args = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_cfg_parse</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	config_include_stack = <span class="literal">NULL</span>;</span><br><span class="line">	inc_depth = <span class="number">0</span>;</span><br><span class="line">	inc_prev = <span class="number">0</span>;</span><br><span class="line">	num_args = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为开始处理include文件做准备工作。打开文件，创建一个inc_state的结构，存储相关信息，然后放入config_include_stack堆栈中，调用yy_switch_to_buffer，切换文件输入流。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">config_start_include</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename)</span></span><br><span class="line">&#123;</span><br><span class="line">	FILE *input;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inc_state</span>* <span class="title">s</span>;</span></span><br><span class="line">	<span class="type">char</span>* nm;</span><br><span class="line">	<span class="keyword">if</span>(inc_depth++ &gt; <span class="number">100000</span>) &#123;</span><br><span class="line">		ub_c_error_msg(<span class="string">&quot;too many include files&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(*filename == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		ub_c_error_msg(<span class="string">&quot;empty include file name&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	s = (<span class="keyword">struct</span> inc_state*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*s));</span><br><span class="line">	<span class="keyword">if</span>(!s) &#123;</span><br><span class="line">		ub_c_error_msg(<span class="string">&quot;include %s: malloc failure&quot;</span>, filename);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(cfg_parser-&gt;chroot &amp;&amp; <span class="built_in">strncmp</span>(filename, cfg_parser-&gt;chroot,</span><br><span class="line">		<span class="built_in">strlen</span>(cfg_parser-&gt;chroot)) == <span class="number">0</span>) &#123;</span><br><span class="line">		filename += <span class="built_in">strlen</span>(cfg_parser-&gt;chroot);</span><br><span class="line">	&#125;</span><br><span class="line">	nm = strdup(filename);</span><br><span class="line">	<span class="keyword">if</span>(!nm) &#123;</span><br><span class="line">		ub_c_error_msg(<span class="string">&quot;include %s: strdup failure&quot;</span>, filename);</span><br><span class="line">		<span class="built_in">free</span>(s);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	input = fopen(filename, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(!input) &#123;</span><br><span class="line">		ub_c_error_msg(<span class="string">&quot;cannot open include file &#x27;%s&#x27;: %s&quot;</span>,</span><br><span class="line">			filename, strerror(errno));</span><br><span class="line">		<span class="built_in">free</span>(s);</span><br><span class="line">		<span class="built_in">free</span>(nm);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	LEXOUT((<span class="string">&quot;switch_to_include_file(%s)\n&quot;</span>, filename));</span><br><span class="line">	s-&gt;filename = cfg_parser-&gt;filename;</span><br><span class="line">	s-&gt;line = cfg_parser-&gt;line;</span><br><span class="line">	s-&gt;buffer = YY_CURRENT_BUFFER;</span><br><span class="line">	s-&gt;next = config_include_stack;</span><br><span class="line">	config_include_stack = s;</span><br><span class="line">	cfg_parser-&gt;filename = nm;</span><br><span class="line">	cfg_parser-&gt;line = <span class="number">1</span>;</span><br><span class="line">	yy_switch_to_buffer(yy_create_buffer(input, YY_BUF_SIZE));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">config_start_include_glob</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* filename)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* check for wildcards */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> HAVE_GLOB</span></span><br><span class="line">	<span class="type">glob_t</span> g;</span><br><span class="line">	<span class="type">size_t</span> i;</span><br><span class="line">	<span class="type">int</span> r, flags;</span><br><span class="line">	<span class="keyword">if</span>(!(!<span class="built_in">strchr</span>(filename, <span class="string">&#x27;*&#x27;</span>) &amp;&amp; !<span class="built_in">strchr</span>(filename, <span class="string">&#x27;?&#x27;</span>) &amp;&amp; !<span class="built_in">strchr</span>(filename, <span class="string">&#x27;[&#x27;</span>) &amp;&amp;</span><br><span class="line">		!<span class="built_in">strchr</span>(filename, <span class="string">&#x27;&#123;&#x27;</span>) &amp;&amp; !<span class="built_in">strchr</span>(filename, <span class="string">&#x27;~&#x27;</span>))) &#123;</span><br><span class="line">		flags = <span class="number">0</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> GLOB_ERR</span></span><br><span class="line">			| GLOB_ERR</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> GLOB_NOSORT</span></span><br><span class="line">			| GLOB_NOSORT</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> GLOB_BRACE</span></span><br><span class="line">			| GLOB_BRACE</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> GLOB_TILDE</span></span><br><span class="line">			| GLOB_TILDE</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">		;</span><br><span class="line">		<span class="built_in">memset</span>(&amp;g, <span class="number">0</span>, <span class="keyword">sizeof</span>(g));</span><br><span class="line">		<span class="keyword">if</span>(cfg_parser-&gt;chroot &amp;&amp; <span class="built_in">strncmp</span>(filename, cfg_parser-&gt;chroot,</span><br><span class="line">			<span class="built_in">strlen</span>(cfg_parser-&gt;chroot)) == <span class="number">0</span>) &#123;</span><br><span class="line">			filename += <span class="built_in">strlen</span>(cfg_parser-&gt;chroot);</span><br><span class="line">		&#125;</span><br><span class="line">		r = glob(filename, flags, <span class="literal">NULL</span>, &amp;g);</span><br><span class="line">		<span class="keyword">if</span>(r) &#123;</span><br><span class="line">			<span class="comment">/* some error */</span></span><br><span class="line">			globfree(&amp;g);</span><br><span class="line">			<span class="keyword">if</span>(r == GLOB_NOMATCH)</span><br><span class="line">				<span class="keyword">return</span>; <span class="comment">/* no matches for pattern */</span></span><br><span class="line">			config_start_include(filename); <span class="comment">/* let original deal with it */</span></span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* process files found, if any */</span></span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;(<span class="type">size_t</span>)g.gl_pathc; i++) &#123;</span><br><span class="line">			config_start_include(g.gl_pathv[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		globfree(&amp;g);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* HAVE_GLOB */</span></span></span><br><span class="line"></span><br><span class="line">	config_start_include(filename);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Include文件处理结束，恢复文件处理堆栈，继续上一个文件的处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">config_end_include</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">inc_state</span>* <span class="title">s</span> =</span> config_include_stack;</span><br><span class="line">	--inc_depth;</span><br><span class="line">	<span class="keyword">if</span>(!s) <span class="keyword">return</span>;</span><br><span class="line">	<span class="built_in">free</span>(cfg_parser-&gt;filename);</span><br><span class="line">	cfg_parser-&gt;filename = s-&gt;filename;</span><br><span class="line">	cfg_parser-&gt;line = s-&gt;line;</span><br><span class="line">	yy_delete_buffer(YY_CURRENT_BUFFER);</span><br><span class="line">	yy_switch_to_buffer(s-&gt;buffer);</span><br><span class="line">	config_include_stack = s-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> yy_set_bol <span class="comment">/* compat definition, for flex 2.4.6 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> yy_set_bol(at_bol) \</span></span><br><span class="line"><span class="meta">        &#123; \</span></span><br><span class="line"><span class="meta">	        <span class="keyword">if</span> ( ! yy_current_buffer ) \</span></span><br><span class="line"><span class="meta">	                yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \</span></span><br><span class="line"><span class="meta">	        yy_current_buffer-&gt;yy_ch_buf[0] = ((at_bol)?<span class="string">&#x27;\n&#x27;</span>:<span class="string">&#x27; &#x27;</span>); \</span></span><br><span class="line"><span class="meta">        &#125;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">%&#125;</span><br></pre></td></tr></table></figure>

<p>定义lex配置，指示flex生成文件时不使用input和unput函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%option noinput</span><br><span class="line">%option nounput</span><br><span class="line"></span><br><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> YY_NO_UNPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YY_NO_UNPUT 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> YY_NO_INPUT</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YY_NO_INPUT 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">%&#125;</span><br></pre></td></tr></table></figure>

<p>正则式定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SPACE   [ \t]</span><br><span class="line">LETTER  [a-zA-Z]</span><br><span class="line">UNQUOTEDLETTER [^\<span class="string">&#x27;\&quot;\n\r \t\\]|\\.</span></span><br><span class="line"><span class="string">UNQUOTEDLETTER_NOCOLON [^\:\&#x27;</span>\<span class="string">&quot;\n\r \t\\]|\\.</span></span><br><span class="line"><span class="string">NEWLINE [\r\n]</span></span><br><span class="line"><span class="string">COMMENT \#</span></span><br><span class="line"><span class="string">COLON 	\:</span></span><br><span class="line"><span class="string">DQANY     [^\&quot;\n\r\\]|\\.</span></span><br><span class="line"><span class="string">SQANY     [^\&#x27;\n\r\\]|\\.</span></span><br></pre></td></tr></table></figure>

<p>定义了几个状态（condition），分别指示：双引号后字符的处理，单引号后字符的处理，“include:“后字符的处理，，关键字（如server、num-threads等）+:后变量的处理。</p>
<p>lex的每个正则式前面可以带有”&lt;状态&gt;“，例如”\n”。每个状态要先用%x声明才能使用。 当lex开始运行时，默认状态是INITIAL，以后可在C代码里用”BEGIN 状态名;“切换到其它状态(BEGIN是lex/yacc内置的宏)。 这时，只有当lex状态切换到COMMENT后，才会去匹配以开头的正则式，而不匹配其它状态开头的。 也就是说，lex当前处在什么状态，就考虑以该状态开头的正则式，而忽略其它的正则式。 其应用例如，在一段C代码里，同样是串”abc”，如果它写在代码段里，会被识别为标识符，如果写在注释里则就不会。所以对串”abc”的识别结果，应根据不同的状态加以区分。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%x	quotedstring singlequotedstr include include_quoted val</span><br></pre></td></tr></table></figure>

<h2 id="规则段"><a href="#规则段" class="headerlink" title="规则段"></a>规则段</h2><p>新的一段（规则段 rules）开始。<br>规则区包含了一系列具有pattern-action形式的规则，并且模式 pattern 位于行首不能缩进，action 也应该起始于同一行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%%</span><br></pre></td></tr></table></figure>
<p>初始状态或者val状态忽略任意长度的空格</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;INITIAL,val&gt;&#123;SPACE&#125;*	&#123; </span><br><span class="line">	LEXOUT((<span class="string">&quot;SP &quot;</span>)); <span class="comment">/* ignore */</span> &#125;</span><br></pre></td></tr></table></figure>

<p>初始状态或者val状态遇到#号后的任意长度任意字符，都认为是注释语句，全部忽略</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;INITIAL,val&gt;&#123;SPACE&#125;*&#123;COMMENT&#125;.*	&#123; </span><br><span class="line">	<span class="comment">/* note that flex makes the longest match and &#x27;.&#x27; is any but not nl */</span></span><br><span class="line">	LEXOUT((<span class="string">&quot;comment(%s) &quot;</span>, yytext)); <span class="comment">/* ignore */</span> &#125;</span><br></pre></td></tr></table></figure>

<p>遇到“server:“，执行宏YDVAR，后面0个参数，进入val状态，返回名为VAR_SERVER的token。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">server&#123;COLON&#125;			&#123; YDVAR(<span class="number">0</span>, VAR_SERVER) &#125;</span><br></pre></td></tr></table></figure>
<p>遇到“num-threads:“，执行YDVAR，后面1个参数(线程数)，进入val状态（lex将解析1个参数），返回名为VAR_NUM_THREADS的token。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">num-threads&#123;COLON&#125;		&#123; YDVAR(<span class="number">1</span>, VAR_NUM_THREADS) &#125;</span><br></pre></td></tr></table></figure>
<p>处理变量时，遇到双引号，则进入双引号状态quotedstring，QS-Quoted Start</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Quoted strings. Strip leading and ending quotes */</span></span><br><span class="line">&lt;val&gt;\<span class="string">&quot;			&#123; BEGIN(quotedstring); LEXOUT((&quot;</span>QS <span class="string">&quot;)); &#125;</span></span><br></pre></td></tr></table></figure>

<p>处理双引号字符串时遇到文件结束，应该是非正常结束，因为还没找到下一个双引号</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;quotedstring&gt;&lt;&lt;EOF&gt;&gt;   &#123;</span><br><span class="line">        yyerror(<span class="string">&quot;EOF inside quoted string&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span>(--num_args == <span class="number">0</span>) &#123; BEGIN(INITIAL); &#125;</span><br><span class="line">	<span class="keyword">else</span>		    &#123; BEGIN(val); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;quotedstring&gt;&#123;DQANY&#125;*  &#123; LEXOUT((<span class="string">&quot;STR(%s) &quot;</span>, yytext)); yymore(); &#125;</span><br></pre></td></tr></table></figure>

<h2 id="用户代码段"><a href="#用户代码段" class="headerlink" title="用户代码段"></a>用户代码段</h2><p>开始新的段，用户代码段(user code)，本例无数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%%</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Lex</category>
      </categories>
      <tags>
        <tag>lex</tag>
      </tags>
  </entry>
  <entry>
    <title>Yacc文件分析</title>
    <url>/2021/04/13/Yacc%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="Yacc文件组成"><a href="#Yacc文件组成" class="headerlink" title="Yacc文件组成"></a>Yacc文件组成</h2><blockquote>
<p>Yacc文件的格式和lex文件格式基本相同，也是由3段组成，用2个%%行把这3段隔开。<br>定义段… definitions …<br>%%<br>规则段… rules …<br>%%<br>用户代码段… subroutines …</p>
</blockquote>
<span id="more"></span>

<h2 id="定义段"><a href="#定义段" class="headerlink" title="定义段"></a>定义段</h2><blockquote>
<p>定义段包含的内容：<br>％｛<br>头文件表<br>宏定义<br>数据类型定义<br>全局变量定义<br>％｝<br>语法开始符定义<br>语义值类型定义<br>终结符定义<br>运算符优先级及结合性定义</p>
</blockquote>
<p>上述四部分括在 ％{和％}之间的内容是由yacc原样照抄到编译后的源文件（y.tab.c）中去，所以必须完全符合C语言文法。</p>
<p>规则段由语法规则和包括C代码的动作组成</p>
<h3 id="定义段开始"><a href="#定义段开始" class="headerlink" title="定义段开始"></a>定义段开始</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;config.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util/configyyrename.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util/config_file.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;util/net_help.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">ub_c_lex</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ub_c_error</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *message)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* these need to be global, otherwise they cannot be used inside yacc */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">config_parser_state</span>* <span class="title">cfg_parser</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OUTYY(s)  printf s <span class="comment">/* used ONLY when debugging */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OUTYY(s)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">%&#125;</span><br></pre></td></tr></table></figure>

<h3 id="语义值类型定义"><a href="#语义值类型定义" class="headerlink" title="语义值类型定义"></a>语义值类型定义</h3><p>定义YYSTYPE的union类型。如果不进行定义，YYSTYPE默认为int类型。即yylval是一个int型的变量。Lex与yacc之间的通信就是靠%union里定义的联合体来完成。<br>%union里定义的联合体最终会被生成一个叫yylval的全局变量，这个全局变量可以在lex和yacc之间传递变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">	<span class="type">char</span>*	str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以％token开始的行定义的是终结符，所以SPACE, STRING_ARG, VAR_SERVER都是终结符，尖括号中的名字就是这些终结符的语义值的具体类型。<br>另外还有以％type开始的行是说明非终结符语义值的类型。本例中并未涉及，因为本例中所有的非终结符均不需要获取其值。</p>
<p>终结符token定义，可分多行，一行中可以定义多个终结符，它们之间用空格分开。<br>yacc规定每个终结符都有一个唯一的编号（token number）。终结符的编号由yacc内部决定，其编号规则是从258开始依次递增，每次加1。0-255被保留作为字符值。lexer解析到定义的特定字串，会返回此token值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%token SPACE LETTER NEWLINE COMMENT COLON ANY ZONESTR</span><br></pre></td></tr></table></figure>
<p>定义一个名为STRING_ARG的token，并且告诉yacc，其语义值为str,这时yylval.str中的值是有意义的可用的值。当然，这是因为我们的lexer已经正确的进行了如下的处理：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;val&gt;&#123;UNQUOTEDLETTER&#125;*	&#123; </span><br><span class="line">			<span class="keyword">if</span>(--num_args == <span class="number">0</span>) &#123; BEGIN(INITIAL); &#125;</span><br><span class="line">			yylval.str = strdup(yytext); </span><br><span class="line"><span class="keyword">return</span> STRING_ARG; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%token &lt;str&gt; STRING_ARG</span><br></pre></td></tr></table></figure>

<p>继续定义其它的终结符</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">%token VAR_SERVER VAR_VERBOSITY VAR_NUM_THREADS VAR_PORT</span><br><span class="line">%token VAR_OUTGOING_RANGE VAR_INTERFACE</span><br><span class="line">%token VAR_DO_IP4 VAR_DO_IP6 VAR_DO_UDP VAR_DO_TCP </span><br><span class="line">%token VAR_TCP_MSS VAR_OUTGOING_TCP_MSS</span><br></pre></td></tr></table></figure>
<h2 id="规则段"><a href="#规则段" class="headerlink" title="规则段"></a>规则段</h2><p>在yacc中，语法开始符定义在定义段中，语句是：</p>
<blockquote>
<p>%start 非终结符</p>
</blockquote>
<p>如果定义段中没有上面的说明，yacc自动将语法规则部分中第一条语法规则左部的非终结符作为语法开始符。</p>
<p>因此我们的开始非终结符为toplevelvars,它可以为空，可以是toplevelvars toplevelvar组成，注意，它是一个递归结构。<br>规则定义部分每个都是以分号结束。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">toplevelvars: <span class="comment">/* empty */</span> | toplevelvars toplevelvar ;</span><br></pre></td></tr></table></figure>
<p>继续：<br>toplevelvar 是由serverstart contents_server 或 forwardstart contents_forward等部分或共同组成的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">toplevelvar: serverstart contents_server | stubstart contents_stub |</span><br><span class="line">	forwardstart contents_forward | pythonstart contents_py | </span><br><span class="line">	rcstart contents_rc | dtstart contents_dt</span><br><span class="line">	;</span><br></pre></td></tr></table></figure>
<p>继续：<br>serverstart是由VAR_SERVER的token构成，它是一个终结符，由lexer来解析提供。<br>即:server:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* server: declaration */</span></span><br><span class="line">serverstart: VAR_SERVER</span><br><span class="line">	&#123; </span><br><span class="line">		OUTYY((<span class="string">&quot;\nP(server:)\n&quot;</span>)); </span><br><span class="line">	&#125;</span><br><span class="line">	;</span><br></pre></td></tr></table></figure>

<p>继续：<br>contents_server(应该是server section的内容)是由contents_server和content_server来构成，也可以为空，它也是一个递归结构。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">contents_server: contents_server content_server </span><br><span class="line">	| ;</span><br></pre></td></tr></table></figure>
<p>继续：</p>
<p>content_server由server_num_threads、server_verbosity等下列部分构成。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">content_server: server_num_threads | server_verbosity | server_port |</span><br><span class="line">	server_outgoing_range | server_do_ip4 |</span><br><span class="line">	server_do_ip6 | server_do_udp | server_do_tcp | </span><br><span class="line">	server_tcp_mss | server_outgoing_tcp_mss |</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">stubstart: VAR_STUB_ZONE</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">config_stub</span>* <span class="title">s</span>;</span></span><br><span class="line">		OUTYY((<span class="string">&quot;\nP(stub_zone:)\n&quot;</span>)); </span><br><span class="line">		s = (<span class="keyword">struct</span> config_stub*)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> config_stub));</span><br><span class="line">		<span class="keyword">if</span>(s) &#123;</span><br><span class="line">			s-&gt;next = cfg_parser-&gt;cfg-&gt;stubs;</span><br><span class="line">			cfg_parser-&gt;cfg-&gt;stubs = s;</span><br><span class="line">		&#125; <span class="keyword">else</span> </span><br><span class="line">			yyerror(<span class="string">&quot;out of memory&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	;</span><br><span class="line">contents_stub: contents_stub content_stub </span><br><span class="line">	| ;</span><br><span class="line">content_stub: stub_name | stub_host | stub_addr | stub_prime | stub_first</span><br><span class="line">	;</span><br></pre></td></tr></table></figure>

<p>server_num_threads 定义，它由两个token组成，VAR_NUM_THREADS 和STRING_ARG,即配置项名 server_num_threads: 和参数：一个整数构成。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">server_num_threads: VAR_NUM_THREADS STRING_ARG </span><br><span class="line">	&#123; </span><br><span class="line">		OUTYY((<span class="string">&quot;P(server_num_threads:%s)\n&quot;</span>, $<span class="number">2</span>)); </span><br><span class="line">		<span class="keyword">if</span>(atoi($<span class="number">2</span>) == <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>($<span class="number">2</span>, <span class="string">&quot;0&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">			yyerror(<span class="string">&quot;number expected&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> cfg_parser-&gt;cfg-&gt;num_threads = atoi($<span class="number">2</span>);</span><br><span class="line">		<span class="built_in">free</span>($<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	;</span><br></pre></td></tr></table></figure>

<p>yacc 允许通过符号名引用表达式的组成部分。当解析非终结符时，进入解析器的组成部分被命名为 $1 、 $2 ，依次类推；它将向高层解析器返回的值名为 $$ 。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">server_verbosity: VAR_VERBOSITY STRING_ARG </span><br><span class="line">	&#123; </span><br><span class="line">		OUTYY((<span class="string">&quot;P(server_verbosity:%s)\n&quot;</span>, $<span class="number">2</span>)); </span><br><span class="line">		<span class="keyword">if</span>(atoi($<span class="number">2</span>) == <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>($<span class="number">2</span>, <span class="string">&quot;0&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">			yyerror(<span class="string">&quot;number expected&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> cfg_parser-&gt;cfg-&gt;verbosity = atoi($<span class="number">2</span>);</span><br><span class="line">		<span class="built_in">free</span>($<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	;</span><br></pre></td></tr></table></figure>

<p>上述语句编译得到的C语言代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">case</span> <span class="number">154</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">line</span> 241 <span class="string">&quot;util/configparser.y&quot;</span> <span class="comment">/* yacc.c:1646  */</span></span></span><br><span class="line">    &#123; </span><br><span class="line">		OUTYY((<span class="string">&quot;P(server_verbosity:%s)\n&quot;</span>, (yyvsp[<span class="number">0</span>].str))); </span><br><span class="line">		<span class="keyword">if</span>(atoi((yyvsp[<span class="number">0</span>].str)) == <span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>((yyvsp[<span class="number">0</span>].str), <span class="string">&quot;0&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">			yyerror(<span class="string">&quot;number expected&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> cfg_parser-&gt;cfg-&gt;verbosity = atoi((yyvsp[<span class="number">0</span>].str));</span><br><span class="line">		<span class="built_in">free</span>((yyvsp[<span class="number">0</span>].str));</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">line</span> 2121 <span class="string">&quot;util/configparser.c&quot;</span> <span class="comment">/* yacc.c:1646  */</span></span></span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>两个参数STRING_ARG的情况</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">server_access_control: VAR_ACCESS_CONTROL STRING_ARG STRING_ARG</span><br><span class="line">	&#123;</span><br><span class="line">		OUTYY((<span class="string">&quot;P(server_access_control:%s %s)\n&quot;</span>, $<span class="number">2</span>, $<span class="number">3</span>));</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">strcmp</span>($<span class="number">3</span>, <span class="string">&quot;deny&quot;</span>)!=<span class="number">0</span> &amp;&amp; <span class="built_in">strcmp</span>($<span class="number">3</span>, <span class="string">&quot;refuse&quot;</span>)!=<span class="number">0</span> &amp;&amp;</span><br><span class="line">			<span class="built_in">strcmp</span>($<span class="number">3</span>, <span class="string">&quot;deny_non_local&quot;</span>)!=<span class="number">0</span> &amp;&amp;</span><br><span class="line">			<span class="built_in">strcmp</span>($<span class="number">3</span>, <span class="string">&quot;refuse_non_local&quot;</span>)!=<span class="number">0</span> &amp;&amp;</span><br><span class="line">			<span class="built_in">strcmp</span>($<span class="number">3</span>, <span class="string">&quot;allow&quot;</span>)!=<span class="number">0</span> &amp;&amp; </span><br><span class="line">			<span class="built_in">strcmp</span>($<span class="number">3</span>, <span class="string">&quot;allow_snoop&quot;</span>)!=<span class="number">0</span>) &#123;</span><br><span class="line">			yyerror(<span class="string">&quot;expected deny, refuse, deny_non_local, &quot;</span></span><br><span class="line">				<span class="string">&quot;refuse_non_local, allow or allow_snoop &quot;</span></span><br><span class="line">				<span class="string">&quot;in access control action&quot;</span>);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">if</span>(!cfg_str2list_insert(&amp;cfg_parser-&gt;cfg-&gt;acls, $<span class="number">2</span>, $<span class="number">3</span>))</span><br><span class="line">				fatal_exit(<span class="string">&quot;out of memory adding acl&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Yacc</category>
      </categories>
      <tags>
        <tag>Yacc</tag>
      </tags>
  </entry>
  <entry>
    <title>UML类图常用关系</title>
    <url>/2021/04/12/UML%E7%B1%BB%E5%9B%BE%E5%B8%B8%E7%94%A8%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h2 id="UML类图常用关系"><a href="#UML类图常用关系" class="headerlink" title="UML类图常用关系"></a>UML类图常用关系</h2><blockquote>
<p>在UML类图中，常有以下几种关系：<br>泛化(Generalization)、实现(Realization)、关联(Association)、聚合(Aggregation)、组合(Composition)和依赖(Dependency)。<br>按照关系的强弱顺序：泛化≥实现&gt;关联&gt;聚合&gt;组合&gt;依赖。</p>
</blockquote>
<span id="more"></span>

<h2 id="类图定义"><a href="#类图定义" class="headerlink" title="类图定义"></a>类图定义</h2><p><img src="95e11d9e34c28a82fb8a84bae9cd4a3749c44769e9e7ea46976e55fda1e3a9af.png" alt="图 9">  </p>
<p><code>-</code>：private——私有<br><code>+</code>：public——公有<br><code>#</code>：protected——保护性<br>例如：<br><img src="4b6b17de98d0a199af0723462e30ca60ed23688f7ac57ea94695d2da692429b9.png" alt="图 10">  </p>
<h2 id="泛化-Generalization"><a href="#泛化-Generalization" class="headerlink" title="泛化(Generalization)"></a>泛化(Generalization)</h2><p><img src="9b3aecb0abccab07f031a5ce7b2d591502ec398270c97bd5f57d842fc54961ca.png" alt="图 1">  </p>
<h2 id="实现-Realization"><a href="#实现-Realization" class="headerlink" title="实现(Realization)"></a>实现(Realization)</h2><p><img src="fac5736514f3a60bc072e23bdc33eecb4551da8dcca7d5fc617cb5d246032f4a.png" alt="图 2">  </p>
<h2 id="关联-Association"><a href="#关联-Association" class="headerlink" title="关联(Association)"></a>关联(Association)</h2><p>单向关联、双向关联、自有关联<br><img src="d2ac8614aa4b1c9751e93a50b4eff831fbad26fa25760865d5084ddf0d5c8e92.png" alt="图 3"><br><img src="b30f66dfb2c4755deb1fbf3efa9aa948307d3bd4ec320c0409ab641e05589be0.png" alt="图 4">  </p>
<h2 id="聚合-Aggregation"><a href="#聚合-Aggregation" class="headerlink" title="聚合(Aggregation)"></a>聚合(Aggregation)</h2><p><img src="262c8c17e368511f86f7aba001239d100bc4f60238a6228c0002216d0f2f4ee9.png" alt="图 5">  </p>
<h2 id="组合-Composition"><a href="#组合-Composition" class="headerlink" title="组合(Composition)"></a>组合(Composition)</h2><p><img src="05470d078e48896c17e46ba5e4bc76ae03f8a11511d5ccf85a44402244b33bb2.png" alt="图 6">  </p>
<h2 id="依赖-Dependency"><a href="#依赖-Dependency" class="headerlink" title="依赖(Dependency)"></a>依赖(Dependency)</h2><p><img src="ef50d3977d2e56a3feb8010e8f1bf724e2f642ac161922b142cb7fd09fa7861b.png" alt="图 7">  </p>
]]></content>
      <categories>
        <category>UML</category>
      </categories>
      <tags>
        <tag>astah</tag>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>pcap</title>
    <url>/2021/04/11/pcap/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>PCAP是常用的数据报存储格式。</li>
<li>基于libpcap，是tcpdump、tshark等网络工具报文捕获的主要文件格式。</li>
<li>格式：文件头 + 帧头 + 帧数据<span id="more"></span>
<img src="78371cae51385780a52c3d1a7e3f2f77f8e460e750b4d9d65073eb89218c3ce2.png" alt="图 1">  </li>
</ul>
<p><img src="784dbc0d2a7dd9651976aecdf8e7005325fbc22d52e2f68ea7490c66930fb5c4.png" alt="图 2">  </p>
<h2 id="文件头格式"><a href="#文件头格式" class="headerlink" title="文件头格式"></a>文件头格式</h2><p>文件头：每个PCAP文件只有一个，占24字节<br><img src="a5bf1b2e94e2b4259a14a6f2f548f999fec9a4da12ea8c6deed94d01bd19e15d.png" alt="图 3"><br><code>Magic</code>：4B，魔数，识别文件和字节顺序；<br>             0xa1b2c3d4表示大端模式；<br>             0xd4c3b2a1表示小端模式；<br><code>Major/Minor</code>：4B，版本号；<br><code>ThisZone</code>：4B，时区；<br><code>SigFigs</code>：4B，时间戳精度；<br><code>SnapLen</code>：4B，最大捕获长度；<br><code>LinkType</code>：4B，链路类型: 常见ETH(1)、PPP(9)、CHDLC(104)等。</p>
<h2 id="帧头格式"><a href="#帧头格式" class="headerlink" title="帧头格式"></a>帧头格式</h2><p>帧头：每一帧报文都带有一个帧头，占16字节<br><img src="612f57ac698ab2869f8cfa0070a37e850e5af2017155fef4b40f8e76e0bcaabe.png" alt="图 4"><br><code>Timestamp(s)</code>：4B，捕获时间戳，精确到秒；<br><code>Timestamp(us)</code> ：4B，捕获时间戳，精确到微秒；<br><code>CapLen</code>：4B，当前捕获的数据帧长度；<br><code>Len</code>：4B，网络中实际数据帧长度；受限于SnapLen，可能会截断，一般等于CapLen。</p>
<h2 id="PCAP工具"><a href="#PCAP工具" class="headerlink" title="PCAP工具"></a>PCAP工具</h2><p><code>wireshark</code>：windows下网络封包分析软件；<br><code>tshark</code>：Linux版本的wireshark命令行工具；<br><code>tcpdump</code>：报文捕获工具；<br>                例如抓取eth0 53端口udp报文：<br>                tcpdump –i eth0 udp port 53 –s 0 –w save.pcap –v<br><code>tcpreplay</code>：报文重放工具；<br>                例如向eth0以10Mbps速率循环放包：<br>                tcpreplay –i eth0 –M 10 –l 0 local.pcap -v<br><code>editcap</code>：报文编辑工具；<br>                例如将报文切割为每1000帧一个PCAP文件：<br>                editcap –c 1000 src.pcap out.pcap<br><code>mergecap</code>：报文合并工具；<br>                例如合并多个原始PCAP文件：<br>                mergecap –w all.pca src1.pcap src2.pcap</p>
<h2 id="修改报文用于功能分支测试"><a href="#修改报文用于功能分支测试" class="headerlink" title="修改报文用于功能分支测试"></a>修改报文用于功能分支测试</h2><p>例如：测试DNS请求类型为DLV的场景，但无该类型报文；<br>        以十六进制显示帧内容，找到对应位置修改；<br>        需注意修改的内容要满足对应协议格式；<br>        字节增加删除需要将关联的长度也修改。<br><img src="295c62d4468bc057fe98104817d6c719e35c39180a14cb2753976a32daf069a9.png" alt="图 5">  </p>
<h2 id="开发场景，下载调试报文"><a href="#开发场景，下载调试报文" class="headerlink" title="开发场景，下载调试报文"></a>开发场景，下载调试报文</h2><p>例如：异常分支下，将对应内存保存到本地PCAP文件。<br>    gdb模式下导出内存：<br>    dump memory out.mem pStart pEnd<br>    转储hex格式：<br>    xxd –g 1 out.mem out.hex<br>    转换pcap格式：<br>    text2pcap out.hex out.pcap<br><img src="355d5c2325a46ad6e3ad72110713074132910c5ce33d81517f4304da221d811d.png" alt="图 7">  </p>
]]></content>
      <categories>
        <category>PCAP</category>
      </categories>
      <tags>
        <tag>pcap</tag>
      </tags>
  </entry>
  <entry>
    <title>signal capture + libunwind</title>
    <url>/2021/04/11/signal-capture-libunwind/</url>
    <content><![CDATA[<h2 id="常见跑飞问题定位"><a href="#常见跑飞问题定位" class="headerlink" title="常见跑飞问题定位"></a>常见跑飞问题定位</h2><h3 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h3><p>段错误触发时，GDB会直接告诉我们问题出现在哪一行代码，并且可以利用backtrace命令查看完整调用栈信息。<br>此外，还可以利用其他常规调试命令来查看参数、变量、内存等数据。</p>
<p>缺点：很多时候，问题并不是100%必现的，我们不可能一直把程序运行在GDB中，这对程序的执行性能等会有很大的影响。</p>
<span id="more"></span>

<h3 id="coredump-gdb"><a href="#coredump-gdb" class="headerlink" title="coredump + gdb"></a>coredump + gdb</h3><p>程序异常中断时，OS会把程序当前的工作状态存储成一个coredump文件。</p>
<p>其提供了程序的内存、堆栈、寄存器、函数栈等各种信息，方便问题的追踪定位。</p>
<p>缺点：当程序运行时占用大量内存，异常奔溃时生成的coredump会非常大，相应落盘过程也会非常缓慢。</p>
<p>由于某种原因，系统可能无法生存core dump文件。</p>
<p>比如出于安全考虑，core dump功能可能是被彻底禁止的，或者在一些存储空间受限的嵌入式系统中，也无法生成core dump文件。</p>
<h2 id="替代方案"><a href="#替代方案" class="headerlink" title="替代方案"></a>替代方案</h2><p>程序自己捕捉信号，获取中断时的堆栈信息</p>
<ul>
<li>signal capture + libunwind</li>
</ul>
<h2 id="libunwind简介"><a href="#libunwind简介" class="headerlink" title="libunwind简介"></a>libunwind简介</h2><p>用于获取程序的调用栈和异常处理和跳转需要，常用的unwind库根据Assembling a Complete Toolchain有：</p>
<ul>
<li>libunwind (llvm)，LLVM内置的unwind库，主要为了不依赖GNU的实现。</li>
<li>libgcc_s (GNU)，GCC内置的unwind库，不需要其他的外部unwind库。</li>
<li>libunwind，The libunwind project - News 1.1版本从2012年后有几年不更新，2017年恢复更新发布了1.2版本支持aarch64并且支持了快速stacktrace。当初导入gperftools时有简单用过这个库。</li>
<li>libunwind (PathScale)，pathscale/libunwind。</li>
<li>gabi++，早期的Android实现，包含在ndk中，在ndk/sources/cxx-stl/gabi++中找到，从NDK r9到r16均有提供，从NDK r11开始以源码方式提供，默认不编译。</li>
<li>Android 9.0开始使用新的unwind库，见<a href="https://android.googlesource.com/">https://android.googlesource.com</a>。</li>
<li>更多API的信息可以访问<a href="https://www.nongnu.org/libunwind/docs.html">libunwind documentation</a></li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>测试代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> UNW_LOCAL_ONLY</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;execinfo.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;libunwind.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRACE_COUNT 16</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">my_backtrace</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unw_cursor_t</span> cursor;</span><br><span class="line">	<span class="type">unw_context_t</span> context;</span><br><span class="line"></span><br><span class="line">	unw_getcontext(&amp;context);</span><br><span class="line">	unw_init_local(&amp;cursor, &amp;context);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (unw_step(&amp;cursor) &gt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">unw_word_t</span> offset, pc;</span><br><span class="line">		unw_get_reg(&amp;cursor, UNW_REG_IP, &amp;pc);</span><br><span class="line">		<span class="keyword">if</span> (pc == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;0x%lx:&quot;</span>, pc);</span><br><span class="line"></span><br><span class="line">		<span class="type">char</span> sym[<span class="number">256</span>];</span><br><span class="line">		<span class="keyword">if</span> (unw_get_proc_name(&amp;cursor, sym, <span class="keyword">sizeof</span>(sym), &amp;offset) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot; (%s+0x%lx)\n&quot;</span>, sym, offset);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot; -- error: unable to obtain symbol name for this frame\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">signal_handle3</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">void</span> *dump_arr[TRACE_COUNT];</span><br><span class="line">	<span class="type">int</span> size = backtrace(dump_arr, TRACE_COUNT);</span><br><span class="line"></span><br><span class="line">	FILE *fd = fopen(<span class="string">&quot;b.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line">	backtrace_symbols_fd(dump_arr, size, fileno(fd));</span><br><span class="line">	fclose(fd);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">signal_handle</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">	my_backtrace();</span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun_core_sigfpe</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun_core_sigabrt</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *p = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun_core_sigsegv</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> *q1;</span><br><span class="line">	<span class="built_in">memcpy</span>(q1, <span class="string">&quot;aaaaaaaaa&quot;</span>, <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">switch</span> (sig)</span><br><span class="line">	&#123;</span><br><span class="line">	<span class="keyword">case</span> SIGSEGV:</span><br><span class="line">		fun_core_sigsegv();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SIGABRT:</span><br><span class="line">		fun_core_sigabrt();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> SIGFPE:</span><br><span class="line">		fun_core_sigfpe();</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">signal_handle2</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> buf[<span class="number">256</span>];</span><br><span class="line">	<span class="type">char</span> cmd[<span class="number">256</span>];</span><br><span class="line">	FILE *fh;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">&quot;/proc/%d/cmdline&quot;</span>, getpid());</span><br><span class="line">	<span class="keyword">if</span> (!(fh = fopen(buf, <span class="string">&quot;r&quot;</span>)))</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (!fgets(buf, <span class="keyword">sizeof</span>(buf), fh))</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	fclose(fh);</span><br><span class="line">	<span class="keyword">if</span> (buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">		buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	<span class="built_in">snprintf</span>(cmd, <span class="keyword">sizeof</span>(cmd), <span class="string">&quot;gdb %s %d -ex=bt &gt; ./a.txt&quot;</span>, buf, getpid());</span><br><span class="line">	system(cmd);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">	signal(SIGSEGV, signal_handle);</span><br><span class="line">	signal(SIGABRT, signal_handle);</span><br><span class="line">	signal(SIGFPE, signal_handle);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// SIGFPE 算术异常</span></span><br><span class="line">	<span class="comment">// fun(SIGFPE);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// SIGABRT 异常终止</span></span><br><span class="line">	<span class="comment">// fun(SIGABRT);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// SIGSEGV 无效存储访问</span></span><br><span class="line">	fun(SIGSEGV);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果<br><img src="97e114fd24980501019a763eb1bca50b8da68dbfca1d73d8c6487103c97dab74.png" alt="图 2"><br><img src="7be43c3a08bc23324a62735446f2deb9ea2632513500c29192bf80c4eec4c945.png" alt="图 3">  </p>
<h2 id="抛栈解析脚本"><a href="#抛栈解析脚本" class="headerlink" title="抛栈解析脚本"></a>抛栈解析脚本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">DEFAULT_PROC_NAME=<span class="string">&quot;hyper_commander&quot;</span></span><br><span class="line">DEFAULT_PROC_SO=<span class="string">&quot;jmnd_admin.so&quot;</span></span><br><span class="line">DEFAULT_CORE_FILE=<span class="string">&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="title">get_default_core_file</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">pushd</span> /var/log/jmnd 2&gt;/dev/null 1&gt;/dev/null</span><br><span class="line">  DEFAULT_CORE_FILE=$(<span class="built_in">ls</span> | grep hyper_commander_core | <span class="built_in">head</span> -1)</span><br><span class="line">  <span class="built_in">popd</span> 2&gt;/dev/null 1&gt;/dev/null</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">args=<span class="string">&quot;$*&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="title">usage</span></span> ()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;args=<span class="variable">$args</span>&quot;</span></span><br><span class="line">  <span class="built_in">echo</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;sh <span class="subst">$(basename <span class="string">&quot;<span class="variable">$0</span>&quot;</span>)</span> -h -e &lt;proc_name&gt; -f &lt;core_file&gt;&quot;</span></span><br><span class="line">  <span class="built_in">echo</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;Helper script, used to addr2line.&quot;</span></span><br><span class="line">  <span class="built_in">echo</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot; -h               Help Usage&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot; -e &lt;proc_name&gt; proc name&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot; -f &lt;core_file&gt; core file&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;example:&quot;</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;    sh <span class="subst">$(basename <span class="string">&quot;<span class="variable">$0</span>&quot;</span>)</span> -e <span class="variable">$DEFAULT_PROC_NAME</span>&quot;</span></span><br><span class="line">  <span class="built_in">echo</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> <span class="string">&quot;he:f:&quot;</span> opt</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="keyword">case</span> <span class="variable">$opt</span> <span class="keyword">in</span></span><br><span class="line">    h)  show_usage=1</span><br><span class="line">        ;;</span><br><span class="line">    e)  proc_name=<span class="string">&quot;<span class="variable">$OPTARG</span>&quot;</span></span><br><span class="line">        ;;</span><br><span class="line">    f)  core_file=<span class="string">&quot;<span class="variable">$OPTARG</span>&quot;</span></span><br><span class="line">        ;;</span><br><span class="line">    \?)</span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;Invalid option: -<span class="variable">$OPTARG</span>&quot;</span> &gt;&amp;2</span><br><span class="line">      show_usage=1</span><br><span class="line">      ;;</span><br><span class="line">  <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$show_usage</span>&quot;</span> = <span class="string">&quot;1&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">  usage</span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$proc_name</span>&quot;</span> == <span class="string">&quot;&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  proc_name=<span class="variable">$DEFAULT_PROC_NAME</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$proc_name</span>&quot;</span> == <span class="string">&quot;hyper_commander&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  so_name=<span class="string">&quot;/usr/share/jmnd/<span class="variable">$DEFAULT_PROC_SO</span>&quot;</span></span><br><span class="line">  <span class="keyword">if</span> [ ! -e <span class="variable">$so_name</span> ]</span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$so_name</span> not exist&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 2</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line">proc_name=<span class="string">&quot;/usr/share/jmnd/bin/<span class="variable">$proc_name</span>&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ ! -e <span class="variable">$proc_name</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$proc_name</span> not exist&quot;</span></span><br><span class="line">  <span class="built_in">exit</span> 2</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line">get_default_core_file</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$core_file</span>&quot;</span> == <span class="string">&quot;&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  core_file=<span class="variable">$DEFAULT_CORE_FILE</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$core_file</span>&quot;</span> == <span class="string">&quot;&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;no core_file&quot;</span></span><br><span class="line">  <span class="built_in">exit</span> 3</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">core_file=<span class="string">&quot;/var/log/jmnd/<span class="variable">$core_file</span>&quot;</span></span><br><span class="line"> </span><br><span class="line">abs_addr=$(awk -F <span class="string">&#x27;[:(+)]&#x27;</span> <span class="string">&#x27;&#123;print $1&#125;&#x27;</span> <span class="variable">$core_file</span>)</span><br><span class="line">func_name=$(awk -F <span class="string">&#x27;[:(+)]&#x27;</span> <span class="string">&#x27;&#123;print $3&#125;&#x27;</span> <span class="variable">$core_file</span>)</span><br><span class="line">func_offset=$(awk -F <span class="string">&#x27;[:(+)]&#x27;</span> <span class="string">&#x27;&#123;print $4&#125;&#x27;</span> <span class="variable">$core_file</span>)</span><br><span class="line"> </span><br><span class="line">func_name=(<span class="variable">$&#123;func_name// /&#125;</span>)</span><br><span class="line">func_offset=(<span class="variable">$&#123;func_offset// /&#125;</span>)</span><br><span class="line">num_name=<span class="variable">$&#123;#func_name[@]&#125;</span></span><br><span class="line">num_off=<span class="variable">$&#123;#func_offset[@]&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$num_name</span>&quot;</span> != <span class="string">&quot;<span class="variable">$num_off</span>&quot;</span> ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&quot;num not match&quot;</span></span><br><span class="line">  <span class="built_in">exit</span> 4</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"> </span><br><span class="line">j=0</span><br><span class="line"><span class="keyword">for</span>((i=0;i&lt;<span class="variable">$num_name</span>;i++));</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  func_v=<span class="variable">$&#123;func_name[$i]&#125;</span></span><br><span class="line">  off_v=<span class="variable">$&#123;func_offset[$i]&#125;</span></span><br><span class="line">  nm_v=$(nm <span class="variable">$proc_name</span> | grep -w <span class="variable">$func_v</span>)</span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$nm_v</span>&quot;</span> == <span class="string">&quot;&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$so_name</span>&quot;</span> != <span class="string">&quot;&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">      nm_so_v=$(nm <span class="variable">$so_name</span> | grep -w <span class="variable">$func_v</span>)</span><br><span class="line">      <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$nm_so_v</span>&quot;</span> == <span class="string">&quot;&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">continue</span></span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$nm_v</span>&quot;</span> != <span class="string">&quot;&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    rel_addr=<span class="variable">$&#123;nm_v%% *&#125;</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    rel_addr=<span class="variable">$&#123;nm_so_v%% *&#125;</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$rel_addr</span>&quot;</span> == <span class="string">&quot;&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">continue</span></span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  rel_addr=<span class="string">&quot;0x&quot;</span>`<span class="built_in">echo</span> <span class="string">&quot;obase=16; <span class="subst">$((16#$&#123;rel_addr&#125;+off_v)</span>)&quot;</span> | bc`</span><br><span class="line">  <span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$nm_v</span>&quot;</span> != <span class="string">&quot;&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">    func_line=`addr2line <span class="variable">$rel_addr</span> -e <span class="variable">$proc_name</span> -f`</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    func_line=`addr2line <span class="variable">$rel_addr</span> -e <span class="variable">$so_name</span> -f`</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">  func_line=(<span class="variable">$&#123;func_line// /&#125;</span>)</span><br><span class="line">  <span class="built_in">printf</span> <span class="string">&quot;#%-3s %-10s in %s\n&quot;</span> <span class="variable">$j</span> <span class="variable">$rel_addr</span> <span class="variable">$&#123;func_line[0]&#125;</span></span><br><span class="line">  <span class="built_in">printf</span> <span class="string">&quot;     at %s\n&quot;</span> <span class="variable">$&#123;func_line[1]&#125;</span></span><br><span class="line">  ((j=j+1))</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>libunwind</category>
      </categories>
      <tags>
        <tag>libunwind</tag>
      </tags>
  </entry>
  <entry>
    <title>用Jenkins构建CI/CD流水线</title>
    <url>/2021/04/10/%E7%94%A8Jenkins%E6%9E%84%E5%BB%BACI-CD%E6%B5%81%E6%B0%B4%E7%BA%BF/</url>
    <content><![CDATA[<p>在正式学习Jenkins之前我们需要对两个名词有一定了解，其一是DevOps，另外一个就是CI/CD。</p>
<h2 id="何为DevOps？"><a href="#何为DevOps？" class="headerlink" title="何为DevOps？"></a>何为DevOps？</h2><p>来自wiki百科介绍</p>
<blockquote>
<p>DevOps是一系列软件开发实践，强调开发人员（Dev）和测试人员（QA）及运维人员（Ops）之间的沟通合作，通过自动化流程，使得软件构建、测试、发布更加快捷、频繁和可靠。</p>
</blockquote>
<span id="more"></span>

<p>简单来说通过DevOps可以将开发、测试、运维三个团队紧密联系在一起，能够使得项目快速迭代、缩短项目上线时间。<br>需要注意的是DevOps是一种理念，而不是一种技术，在实际工作中落地应用这套理念需要有相对应得技术作为支撑，而CI/CD就是作为DevOps得最佳实践技术手段。</p>
<h2 id="何为CI-CD？"><a href="#何为CI-CD？" class="headerlink" title="何为CI/CD？"></a>何为CI/CD？</h2><h3 id="持续集成-（Continuous-integration，简称CI）"><a href="#持续集成-（Continuous-integration，简称CI）" class="headerlink" title="持续集成 （Continuous integration，简称CI）"></a>持续集成 （Continuous integration，简称CI）</h3><p>持续集成是一种开发实践，它倡导团队成员需要频繁的集成他们的工作，每次集成都通过自动化构建（包括编译、构建、自动化测试）来验证，从而尽快地发现集成中的错误。让正在开发的软件始终处于可工作状态，让产品可以快速迭代，同时还能保持高质量。</p>
<h3 id="持续交付（Continuous-Delivery）"><a href="#持续交付（Continuous-Delivery）" class="headerlink" title="持续交付（Continuous Delivery）"></a>持续交付（Continuous Delivery）</h3><p>持续交付是持续集成的延伸或者看作持续集成的下一步，它将集成后的代码部署到类生产环境，确保可以以可持续的方式快速向客户发布新的更改。如果代码没有问题，可以继续部署到生产环境中。它强调的是，不管怎么更新，软件是随时随地可以交付的。</p>
<h3 id="持续部署（Continuous-Deployment）"><a href="#持续部署（Continuous-Deployment）" class="headerlink" title="持续部署（Continuous Deployment）"></a>持续部署（Continuous Deployment）</h3><p>持续部署是持续交付的下一步，在持续交付的基础上，由开发人员或运维人员定期向生产环境部署稳定的构建版本，持续部署的目标是代码在任何时刻都是可部署的，并可自动进入到生产环境。</p>
<p>而CI/CD整套流水线体系的运行我们需要Jenkins这样的平台去支撑。</p>
<h2 id="安装配置JDK环境"><a href="#安装配置JDK环境" class="headerlink" title="安装配置JDK环境"></a>安装配置JDK环境</h2><p>从官网下载jdk压缩包，拷贝到linux系统opt目录下<br><a href="http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p>
<p>解压：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -xzvf jdk-8u121-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>
<p>配置环境变量，/etc/profile文件每个用户登录时都会运行的环境变量设置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure>
<p>在最末尾进行配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/opt/jdk1.8.0_121</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=$:CLASSPATH:<span class="variable">$JAVA_HOME</span>/lib/</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br></pre></td></tr></table></figure>
<p>注意：JAVA_HOME需要配置为本地JDK家目录</p>
<p>使配置生效</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>
<p>验证JDK配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure>
<h2 id="安装配置Jenkins"><a href="#安装配置Jenkins" class="headerlink" title="安装配置Jenkins"></a>安装配置Jenkins</h2><p>从官网下载Jenkins rpm包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://pkg.jenkins.io/redhat-stable/jenkins-2.249.3-1.1.noarch.rpm</span><br></pre></td></tr></table></figure>
<p>从官网下载可能速度较慢，可以换成清华的地址：<a href="https://mirrors.tuna.tsinghua.edu.cn/jenkins/redhat-stable/">https://mirrors.tuna.tsinghua.edu.cn/jenkins/redhat-stable/</a></p>
<p>安装Jenkins</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rpm -ivh jenkins-2.249.3-1.1.noarch.rpm</span><br></pre></td></tr></table></figure>
<p>启动Jenkins</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start jenkins</span><br></pre></td></tr></table></figure>
<p>可能遇到的报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Starting Jenkins bash: /usr/bin/java: No such file or directory</span><br></pre></td></tr></table></figure>
<p>解决方案： 添加java命令的的软链接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s /opt/jdk1.8.0_121/bin/java /usr/bin/java</span><br></pre></td></tr></table></figure>
<p>修改Jenkins端口号</p>
<p>默认Jenkins会使用8080端口，此端口会被很多程序使用，比如tomcat</p>
<p>编辑JENKINS_PORT配置选项</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/sysconfig/jenkins</span><br><span class="line"></span><br><span class="line"><span class="comment">## Type:        integer(0:65535)</span></span><br><span class="line"><span class="comment">## Default:     8080</span></span><br><span class="line"><span class="comment">## ServiceRestart: jenkins</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Port Jenkins is listening on.</span></span><br><span class="line"><span class="comment"># Set to -1 to disable</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">JENKINS_PORT=<span class="string">&quot;8081&quot;</span></span><br></pre></td></tr></table></figure>
<p>重启Jenkins</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl restart jenkins</span><br></pre></td></tr></table></figure>
<h2 id="使用Jenkins"><a href="#使用Jenkins" class="headerlink" title="使用Jenkins"></a>使用Jenkins</h2><p>访问Jenkins通过http://你的服务器ip地址:8081即可访问</p>
<p>一、初始化配置，进入到对应目录通过cat命令查看初始化密码</p>
<p>cat /var/lib/jenkins/secrets/initialAdminPassword<br><img src="9f31164162a48629df266f6967baedba9703d6ae208f1f85adfa44dcb215c7f9.png" alt="图 6">  </p>
<p>二、自定义插件进行安装</p>
<p><img src="bdb13e0b23a5c2382bac06595bfcde137da82852268f9e579b953542a075da27.png" alt="图 5">  </p>
<p>三、勾选【无】选择安装，这里不选择插件安装是因为插件可能会下载失败，我们可以选择后续再去安装。</p>
<p><img src="8330d6ca6c73b205ec567850855f7fca0541790aa2f3b5dd99842d8d5244ef6c.png" alt="图 4">  </p>
<p>四、填写管理员用户信息</p>
<p><img src="5dbb99dbbb175edc62243e4be6fdadab01421e456828a629f257920239337ad2.png" alt="图 2">  </p>
<p>五、点击保存并完成即可<br><img src="fcba9c43ad948ce0cb267d38f6f576410c905d6a25ef2252ed3bc6eede90ba6a.png" alt="图 3">  </p>
]]></content>
      <categories>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>Jenkins</tag>
        <tag>CI/CD</tag>
      </tags>
  </entry>
  <entry>
    <title>signal capture + backtrace</title>
    <url>/2021/04/10/signal-capture-backtrace/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>要获取堆栈信息，要使用库提供的三个堆栈相关的系统函数：</p>
<ul>
<li>backtrace：返回当前线程栈帧信息，形式为栈帧地址</li>
<li>backtrace_symbols：将栈帧地址转换为可读的字符串形式</li>
<li>backtrace_symbols_fd：同上，转换后写入文件句柄fd<span id="more"></span></li>
</ul>
<p>函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;execinfo.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>       <span class="title function_">backtrace</span><span class="params">(<span class="type">void</span> **buffer, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">char</span> **<span class="title function_">backtrace_symbols</span><span class="params">(<span class="type">void</span> *<span class="type">const</span> *buffer, <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">void</span>    <span class="title function_">backtrace_symbols_fd</span><span class="params">(<span class="type">void</span> *<span class="type">const</span> *buffer, <span class="type">int</span> size, <span class="type">int</span> fd)</span>;</span><br></pre></td></tr></table></figure>


<h2 id="常见异常中断信号"><a href="#常见异常中断信号" class="headerlink" title="常见异常中断信号"></a>常见异常中断信号</h2><ul>
<li>SIGFPE：算术异常，例如除数为0</li>
<li>SIGABRT：异常终止，例如内存重复释放</li>
<li>SIGSEGV：无效存储访问，例如越界操作访问</li>
</ul>
<p>信号捕捉：通过signal系统函数绑定信号处理函数，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">signal(SIGSEGV, signal_handle);</span><br><span class="line">signal(SIGABRT, signal_handle);</span><br><span class="line">signal(SIGFPE, signal_handle);</span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>测试代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fun_core_sigfpe</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span> / <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun_core_sigabrt</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun_core_sigsegv</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *q1;</span><br><span class="line">    <span class="built_in">memcpy</span>(q1, <span class="string">&quot;aaaaaaaaa&quot;</span>, <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span>(sig)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> SIGSEGV:</span><br><span class="line">            fun_core_sigsegv();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SIGABRT:</span><br><span class="line">            fun_core_sigabrt();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SIGFPE:</span><br><span class="line">            fun_core_sigfpe();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">signal_handle3</span><span class="params">(<span class="type">int</span> sig)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> * dump_arr[TRACE_COUNT];</span><br><span class="line">    <span class="type">int</span> size = backtrace(dump_arr, TRACE_COUNT);</span><br><span class="line"></span><br><span class="line">    FILE *fd = fopen(<span class="string">&quot;b.txt&quot;</span>, <span class="string">&quot;w+&quot;</span>);</span><br><span class="line">    backtrace_symbols_fd(dump_arr, size, fileno(fd));</span><br><span class="line">    fclose(fd);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> ** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    signal(SIGSEGV, signal_handle3);</span><br><span class="line">    signal(SIGABRT, signal_handle3);</span><br><span class="line">    signal(SIGFPE,  signal_handle3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//SIGFPE 算术异常</span></span><br><span class="line">    fun(SIGFPE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//SIGABRT 异常终止</span></span><br><span class="line">    fun(SIGABRT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//SIGSEGV 无效存储访问</span></span><br><span class="line">    fun(SIGSEGV);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果<br><img src="437db2da189fe666d5a761a7767d640a984c663ae440d219aa328bec69bdf37b.png" alt="图 1">  </p>
<p>nm+addr2line解析具体抛栈行号<br><img src="fb66fbd0611768797c4448503c40f83fd2cf7a5e1a333dec87ce5c78dd87ada6.png" alt="图 2">  </p>
<p><img src="c337bbf22f9c52b246b6afd440b0b155b98031c79cab476f4183874419a76bbd.png" alt="图 3">  </p>
]]></content>
      <categories>
        <category>backtrace</category>
      </categories>
      <tags>
        <tag>backtrace</tag>
      </tags>
  </entry>
  <entry>
    <title>mlx5 dpdk编译</title>
    <url>/2021/01/07/mlx5-dpdk%E7%BC%96%E8%AF%91/</url>
    <content><![CDATA[<h2 id="MLX5运行环境安装"><a href="#MLX5运行环境安装" class="headerlink" title="MLX5运行环境安装"></a>MLX5运行环境安装</h2><p>MLNX_OFED_LINUX-5.4-1.0.3.0-rhel7.4-x86_64.tgz </p>
<ol>
<li>该驱动下载官网：<br><a href="https://www.mellanox.com/products/infiniband-drivers/linux/mlnx_ofed">https://www.mellanox.com/products/infiniband-drivers/linux/mlnx_ofed</a><span id="more"></span></li>
<li>简要安装步骤:<br>将MLNX_OFED_LINUX-5.4-1.0.3.0-rhel7.4-x86_64.tgz放在/home/setup目录，解压，<br>进入解压包的顶层目录,里面有两个脚本mlnxofedinstall跟mlnx_add_kernel_support.sh， 首先执行<br><code>./mlnxofedinstall --upstream-libs --dpdk --add-kernel-support</code></li>
</ol>
<p>请严格按照所给参数进行安装，安装中间可能会出现一些依赖库的安装，请自行使用yum安装。安装完成后进行下一步<br><code>/etc/init.d/openibd restart</code></p>
<p>这里有个特殊点，如果出现以上报错 ： rmmod: ERROR: Module rdma_cm is in use by: rpcrdma ib_isert<br>把对应的模块停掉就好了。查看 <code>lsmod |grep rdma_cm </code><br><code>modprobe -r rpcrdma </code><br><code>modprobe -r ib_isert </code><br>这个完成后，然后运行第二个脚本<br><code>./mlnx_add_kernel_support.sh -m /home/setup/MLNX_OFED_LINUX-5.4-1.0.3.0-rhel7.4-x86_64 -v</code></p>
<p><strong>注意：</strong><br> /home/setup/MLNX_OFED_LINUX-5.4-1.0.3.0-rhel7.4-x86_64 这个是实际该安装包的压缩目录，最好使用绝对路径（相对路径未使用过）</p>
<h2 id="DPDK编译（20-11）"><a href="#DPDK编译（20-11）" class="headerlink" title="DPDK编译（20.11）"></a>DPDK编译（20.11）</h2><p>DPDK编译版本：20.11<br>编译依赖：MLX5运行环境的安装，因为meson build时会检查当前系统环境，存在MLX5运行环境时，meson build会自动加载MLX5相关的静态动态库<br>应用程序编译：</p>
<ol>
<li><p>检查DPDK编译是否存在MLX5相关的静态动态库，如果不存在需要重新安装MLX5运行环境<br><img src="44d0628aecf620aed3d1ec30cfc18e64f190703e83be9b80c34777eac91ec158.png" alt="图 7">  </p>
</li>
<li><p>编译配置添加rte_common_mlx5、rte_net_mlx5静态库 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DBDK_LIBS        += -lrte_common_mlx5</span><br><span class="line">DBDK_LIBS        += -lrte_net_mlx5</span><br></pre></td></tr></table></figure></li>
<li><p>链接-lmlx5 -libverbs动态库</p>
</li>
<li><p>执行程序编译，编译完之后检查应用程序是否能找到链接的动态库，如果不能的话需要检查动态库的安装位置</p>
</li>
</ol>
<h2 id="DPDK编译（18-11）"><a href="#DPDK编译（18-11）" class="headerlink" title="DPDK编译（18.11）"></a>DPDK编译（18.11）</h2><p>DPDK编译版本：18.11<br>编译依赖：MLX5运行环境的安装，依赖安装后的动态库<br>应用程序编译： </p>
<ol>
<li><p>18.11通过make&amp;&amp;make install来编译相关网卡支持的驱动库<br>修改DPDK源码目录config/common-base文件内的CONFIG_RTE_LIBRTE_MLX5_PMD选项<br>CONFIG_RTE_LIBRTE_MLX5_PMD=y<br>会将rte_pmd_mlx5静态库编译到指定目录中 </p>
</li>
<li><p>编译配置添加rte_pmd_mlx5静态库 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DBDK_LIBS        += -lrte_pmd_mlx5</span><br></pre></td></tr></table></figure></li>
<li><p>链接 -lmlx5 -libverbs -lmnl动态库</p>
</li>
<li><p>执行程序编译，编译完之后检查应用程序是否能找到链接的动态库，如果不能的话需要检查动态库的安装位置<br><img src="f559d10e5e4010af751779993a8476d896d3546c5fa7de3a248ce553c39a1454.png" alt="图 8">  </p>
</li>
</ol>
<h2 id="DPDK应用程序启动"><a href="#DPDK应用程序启动" class="headerlink" title="DPDK应用程序启动"></a>DPDK应用程序启动</h2><ol>
<li><p>判断网卡驱动是否为MLX</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./DPDK/dpdk-devbind.py -s | grep <span class="variable">$&#123;DEV_LIST[0]&#125;</span> | grep mlx</span><br></pre></td></tr></table></figure></li>
<li><p>如果是MLX驱动则加载ib_uverbs mlx5_core mlx5_ib，正常分配大页 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /sbin/modprobe -a ib_uverbs mlx5_core mlx5_ib</span><br><span class="line">/sbin/lsmod | grep -s ib_uverbs &gt; /dev/null</span><br><span class="line"><span class="keyword">if</span> [ $? -ne 0 ] ; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;## ERROR: Could not load ib_uverbs.&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">/sbin/lsmod | grep -s mlx5_core &gt; /dev/null</span><br><span class="line"><span class="keyword">if</span> [ $? -ne 0 ] ; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;## ERROR: Could not load mlx5_core.&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">/sbin/lsmod | grep -s mlx5_ib &gt; /dev/null</span><br><span class="line"><span class="keyword">if</span> [ $? -ne 0 ] ; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;## ERROR: Could not load mlx5_ib.&quot;</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>注意：</strong><br>    <strong>千万不要安装igb_uio与vfio-pci驱动，要不然mlx5无法启动</strong></p>
<ol start="3">
<li>添加pci的id号至bind_nic.log<br>程序在eal初始化时需要-a指定该文件中的参数，<strong>注意不要将管理口添加进去</strong>，否则进程会将管理口托管，导致其他应用无法使用管理口</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pci_id[0]=`./DPDK/dpdk-devbind.py -s | grep <span class="variable">$&#123;DEV_LIST[0]&#125;</span> | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>`</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;pci_id[0]&#125;</span> if=<span class="variable">$&#123;DEV_LIST[0]&#125;</span> ip=None mask=None now_drv=mlx5_core old_drv=igb_uio&quot;</span> &gt; bind_nic.log</span><br><span class="line"><span class="keyword">for</span>((i=1; i&lt;<span class="variable">$&#123;DEV_NUM&#125;</span>; i++));</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    pci_id[<span class="variable">$i</span>]=`./DPDK/dpdk-devbind.py -s | grep <span class="variable">$&#123;DEV_LIST[$i]&#125;</span> | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>`</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$&#123;pci_id[$i]&#125;</span> if=<span class="variable">$&#123;DEV_LIST[$i]&#125;</span> ip=None mask=None now_drv=mlx5_core old_drv=igb_uio&quot;</span> &gt;&gt; bind_nic.log</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>DPDK</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>DPDK</tag>
      </tags>
  </entry>
  <entry>
    <title>rebase + merge</title>
    <url>/2020/11/13/rebase-merge/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>git rebase</code> 和 <code>git merge</code> 一样都是用于从一个分支获取并且合并到当前分支，但是他们采取不同的工作方式，以下面的一个工作场景说明其区别</p>
<span id="more"></span>

<p>场景：</p>
<p>如图所示：你在一个feature分支进行新特性的开发，与此同时，master 分支的也有新的提交。<br><img src="10d112b9d1e18b14aad2682fc0245ac4f21f11727af55627ac28fa305be6b557.png" alt="图 6">  </p>
<p>为了将master 上新的提交合并到你的feature分支上，你有两种选择：<code>merge</code> or <code>rebase</code></p>
<h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><p>执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line">git merge master</span><br></pre></td></tr></table></figure>
<p>或者执行更简单的：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge master feature</span><br></pre></td></tr></table></figure>
<p>那么此时在feature上git 自动会产生一个新的commit(merge commit)</p>
<p><img src="329561e5949faafb4940dc500bdea86b4203c08715fb0124f2bb35262c303c27.png" alt="图 7">  </p>
<p><strong>marge 特点</strong>：</p>
<ul>
<li>自动创建一个新的commit</li>
<li>如果合并的时候遇到冲突，仅需要修改后重新commit</li>
<li>优点：记录了真实的commit情况，包括每个分支的详情</li>
<li>缺点：因为每次merge会自动产生一个merge commit，所以在使用一些git 的GUI tools，特别是commit比较频繁时，看到分支很杂乱。</li>
</ul>
<h2 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h2><p>本质是变基 变基 变基<br>变基是什么? 找公共祖先</p>
<p>执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line">git rebase master</span><br></pre></td></tr></table></figure>
<p><img src="4afc22fd0e1bd665a6076695dab490d2b62c2199443b04ff4ebec332a6ecbe3e.png" alt="图 8">  </p>
<p><strong>rebase 特点</strong>：</p>
<ul>
<li>会合并之前的commit历史</li>
<li>优点：得到更简洁的项目历史，去掉了merge commit</li>
<li>缺点：如果合并出现代码问题不容易定位，因为re-write了history</li>
</ul>
<p>合并时如果出现冲突需要按照如下步骤解决</p>
<p><strong>修改冲突部分</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add</span><br><span class="line">git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure>
<p>（如果第三步无效可以执行 git rebase –skip）<br>不要在git add 之后习惯性的执行 git commit命令</p>
<p><strong>注意</strong>：<br>不要在公共分支上使用<br>比如说如下场景：如图所示<br><img src="2ad414bcc983f0ae1222fa405ff797c61da0ac786ea7ea65f42497edba95fe31.png" alt="图 9">  </p>
<p>如果你rebase master 到你的feature分支：</p>
<p>rebase 将所有master的commit移动到你的feature 的顶端。问题是：其他人还在original master上开发，由于你使用了rebase移动了master，git 会认为你的主分支的历史与其他人的有分歧，会产生冲突。</p>
]]></content>
      <categories>
        <category>GIT</category>
      </categories>
      <tags>
        <tag>rebase</tag>
        <tag>merge</tag>
      </tags>
  </entry>
  <entry>
    <title>remote + cherry-pick</title>
    <url>/2020/11/12/remote-cherry-pick/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote>
<p>对于多分支的代码库，将代码从一个分支转移到另一个分支是常见需求。<br>这时分两种情况。一种情况是，你需要另一个分支的所有代码变动，那么就采用合并（git merge）。<br>另一种情况是，你只需要部分代码变动（某几个提交），这时可以采用 Cherry pick。</p>
</blockquote>
<span id="more"></span>

<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>git cherry-pick命令的作用，就是将指定的提交（commit）应用于其他分支。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cherry-pick &lt;commitHash&gt;</span><br></pre></td></tr></table></figure>
<p>上面命令就会将指定的提交commitHash，应用于当前分支。这会在当前分支产生一个新的提交，当然它们的哈希值会不一样。</p>
<p>举例来说，代码仓库有master和feature两个分支。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a - b - c - d   Master</span><br><span class="line">     \</span><br><span class="line">       e - f - g Feature</span><br></pre></td></tr></table></figure>
<p>现在将提交f应用到master分支。</p>
<h1 id="切换到-master-分支"><a href="#切换到-master-分支" class="headerlink" title="切换到 master 分支"></a>切换到 master 分支</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line"></span><br><span class="line"><span class="comment"># Cherry pick 操作</span></span><br><span class="line">$ git cherry-pick f</span><br></pre></td></tr></table></figure>
<p>上面的操作完成以后，代码库就变成了下面的样子。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a - b - c - d - f   Master</span><br><span class="line">     \</span><br><span class="line">       e - f - g Feature</span><br></pre></td></tr></table></figure>
<p>从上面可以看到，master分支的末尾增加了一个提交f。</p>
<p><code>git cherry-pick</code>命令的参数，不一定是提交的哈希值，分支名也是可以的，表示转移该分支的最新提交。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cherry-pick feature</span><br></pre></td></tr></table></figure>
<p>上面代码表示将feature分支的最近一次提交，转移到当前分支。</p>
<h2 id="转移多个提交"><a href="#转移多个提交" class="headerlink" title="转移多个提交"></a>转移多个提交</h2><p>Cherry pick 支持一次转移多个提交。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cherry-pick &lt;HashA&gt; &lt;HashB&gt;</span><br></pre></td></tr></table></figure>
<p>上面的命令将 A 和 B 两个提交应用到当前分支。这会在当前分支生成两个对应的新提交。</p>
<p>如果想要转移一系列的连续提交，可以使用下面的简便语法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cherry-pick A..B </span><br></pre></td></tr></table></figure>
<p>上面的命令可以转移从 A 到 B 的所有提交。它们必须按照正确的顺序放置：提交 A 必须早于提交 B，否则命令将失败，但不会报错。</p>
<p>注意，使用上面的命令，提交 A 将不会包含在 Cherry pick 中。如果要包含提交 A，可以使用下面的语法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cherry-pick A^..B </span><br></pre></td></tr></table></figure>

<h2 id="配置项"><a href="#配置项" class="headerlink" title="配置项"></a>配置项</h2><p><code>git cherry-pick</code>命令的常用配置项如下。</p>
<p>（1）<code>-e，--edit</code></p>
<p>打开外部编辑器，编辑提交信息。</p>
<p>（2）<code>-n，--no-commit</code></p>
<p>只更新工作区和暂存区，不产生新的提交。</p>
<p>（3）<code>-x</code></p>
<p>在提交信息的末尾追加一行(cherry picked from commit …)，方便以后查到这个提交是如何产生的。</p>
<p>（4）<code>-s，--signoff</code></p>
<p>在提交信息的末尾追加一行操作者的签名，表示是谁进行了这个操作。</p>
<p>（5）<code>-m parent-number，--mainline parent-number</code></p>
<p>如果原始提交是一个合并节点，来自于两个分支的合并，那么 Cherry pick 默认将失败，因为它不知道应该采用哪个分支的代码变动。</p>
<p><code>-m</code>配置项告诉 Git，应该采用哪个分支的变动。它的参数<code>parent-number</code>是一个从1开始的整数，代表原始提交的父分支编号。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cherry-pick -m 1 &lt;commitHash&gt;</span><br></pre></td></tr></table></figure>
<p>上面命令表示，Cherry pick 采用提交commitHash来自编号1的父分支的变动。</p>
<p>一般来说，1号父分支是接受变动的分支（the branch being merged into），2号父分支是作为变动来源的分支（the branch being merged from）。</p>
<h2 id="代码冲突"><a href="#代码冲突" class="headerlink" title="代码冲突"></a>代码冲突</h2><p>如果操作过程中发生代码冲突，Cherry pick 会停下来，让用户决定如何继续操作。</p>
<p>（1）<code>--continue</code></p>
<p>用户解决代码冲突后，第一步将修改的文件重新加入暂存区（git add .），第二步使用下面的命令，让 Cherry pick 过程继续执行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cherry-pick --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure>
<p>（2）<code>--abort</code></p>
<p>发生代码冲突后，放弃合并，回到操作前的样子。</p>
<p>（3）<code>--quit</code></p>
<p>发生代码冲突后，退出 Cherry pick，但是不回到操作前的样子。</p>
<p>（4）结合vscode<br>结合vscode的图形界面，可以高效的完成冲突的修复，会将所有的冲突文件呈现出来</p>
<h2 id="转移到另一个代码库"><a href="#转移到另一个代码库" class="headerlink" title="转移到另一个代码库"></a>转移到另一个代码库</h2><p>Cherry pick 也支持转移另一个代码库的提交，方法是先将该库加为远程仓库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git remote add target git://gitUrl</span><br></pre></td></tr></table></figure>

<p>上面命令添加了一个远程仓库target。</p>
<p>然后，将远程代码抓取到本地。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git fetch target</span><br></pre></td></tr></table></figure>

<p>上面命令将远程代码仓库抓取到本地。</p>
<p>接着，检查一下要从远程仓库转移的提交，获取它的哈希值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> target/master</span><br></pre></td></tr></table></figure>

<p>最后，使用git cherry-pick命令转移提交。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git cherry-pick &lt;commitHash&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>GIT</category>
      </categories>
      <tags>
        <tag>cherry-pick</tag>
      </tags>
  </entry>
  <entry>
    <title>format-patch + am</title>
    <url>/2020/11/11/format-patch-am/</url>
    <content><![CDATA[<h2 id="生成所选的patch"><a href="#生成所选的patch" class="headerlink" title="生成所选的patch"></a>生成所选的patch</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git format-patch HEAD^       <span class="comment">#生成最近的1次commit的patch</span></span><br><span class="line">$ git format-patch HEAD^^      <span class="comment">#生成最近的2次commit的patch</span></span><br><span class="line">$ git format-patch HEAD^^^     <span class="comment">#生成最近的3次commit的patch</span></span><br><span class="line">$ git format-patch HEAD^^^^    <span class="comment">#生成最近的4次commit的patch</span></span><br><span class="line">$ git format-patch &lt;r1&gt;..&lt;r2&gt;  <span class="comment">#生成两个commit间的修改的patch（生成的patch不包含r1. &lt;r1&gt;和&lt;r2&gt;都是具体的commit号)</span></span><br><span class="line">$ git format-patch -1 &lt;r1&gt;     <span class="comment">#生成单个commit的patch</span></span><br><span class="line">$ git format-patch &lt;r1&gt;        <span class="comment">#生成某commit以来的修改patch（不包含该commit）</span></span><br><span class="line">$ git format-patch --root &lt;r1&gt; <span class="comment">#生成从根到r1提交的所有patch</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="使用am应用patch"><a href="#使用am应用patch" class="headerlink" title="使用am应用patch"></a>使用am应用patch</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git am 0001-limit-log-function.patch           <span class="comment"># 将名字为0001-limit-log-function.patch的patch打上</span></span><br><span class="line">$ git am --signoff 0001-limit-log-function.patch <span class="comment"># 添加-s或者--signoff，还可以把自己的名字添加为signed off by信息，作用是注明打patch的人是谁，因为有时打patch的人并不是patch的作者</span></span><br><span class="line">$ git am ~/patch-set/*.patch                     <span class="comment"># 将路径~/patch-set/*.patch 按照先后顺序打上</span></span><br><span class="line">$ git am --abort                                 <span class="comment"># 当git am失败时，用以将已经在am过程中打上的patch废弃掉(比如有三个patch，打到第三个patch时有冲突，那么这条命令会把打上的前两个patch丢弃掉，返回没有打patch的状态)</span></span><br><span class="line">$ git am --resolved                              <span class="comment"># 当git am失败，解决完冲突后，这条命令会接着打patch</span></span><br></pre></td></tr></table></figure>

<h2 id="使用apply应用patch"><a href="#使用apply应用patch" class="headerlink" title="使用apply应用patch"></a>使用apply应用patch</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git apply --<span class="built_in">stat</span>    xxx.patch 查看哪些文件需要合入</span><br><span class="line">git apply --check   xxx.patch 检查合入后是否有冲突</span><br><span class="line">git apply --reject  xxx.patch 合入改动</span><br></pre></td></tr></table></figure>

<h2 id="am和apply区别"><a href="#am和apply区别" class="headerlink" title="am和apply区别"></a>am和apply区别</h2><p>git am会直接将patch的所有信息打上去，而且不用重新git add和git commit，author也是patch的author而不是打patch的人。<br>git apply并不会将commit message等打上去，打完patch后需要重新git add和git commit。</p>
]]></content>
      <categories>
        <category>GIT</category>
      </categories>
      <tags>
        <tag>format-patch</tag>
        <tag>am</tag>
      </tags>
  </entry>
  <entry>
    <title>git常用命令</title>
    <url>/2020/11/10/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><blockquote>
<p>远端版本库、本地版本库、工作区、暂存区<br>从远端版本库<code>clone</code>到本地版本库，<code>checkout</code>创建一个分支到工作区，<br>修改代码，<code>add</code>到暂存区，<code>commit</code>到本地版本库，<code>push</code>到远端版本库</p>
</blockquote>
<span id="more"></span>

<h2 id="新建代码库"><a href="#新建代码库" class="headerlink" title="新建代码库"></a>新建代码库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在当前目录新建一个Git代码库</span></span><br><span class="line">$ git init</span><br><span class="line"><span class="comment"># 新建一个目录，将其初始化为Git代码库</span></span><br><span class="line">$ git init [project-name]</span><br><span class="line"><span class="comment"># 下载一个项目和它的整个代码历史</span></span><br><span class="line">$ git <span class="built_in">clone</span> [url]</span><br></pre></td></tr></table></figure>

<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下(全局配置)，也可以在项目目录下(项目配置)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示当前的Git配置</span></span><br><span class="line">$ git config --list</span><br><span class="line"><span class="comment"># 编辑Git配置文件</span></span><br><span class="line">$ git config -e [--global]</span><br><span class="line"><span class="comment"># 设置提交代码时的用户信息</span></span><br><span class="line">$ git config [--global] user.name <span class="string">&quot;[name]&quot;</span></span><br><span class="line">$ git config [--global] user.email <span class="string">&quot;[email address]&quot;</span></span><br><span class="line"><span class="comment"># 颜色设置</span></span><br><span class="line">git config --global color.ui <span class="literal">true</span>                         <span class="comment"># git status等命令自动着色</span></span><br><span class="line">git config --global color.status auto</span><br><span class="line">git config --global color.diff auto</span><br><span class="line">git config --global color.branch auto</span><br><span class="line">git config --global color.interactive auto</span><br><span class="line">git config --global --<span class="built_in">unset</span> http.proxy                    <span class="comment"># remove  proxy configuration on git</span></span><br></pre></td></tr></table></figure>

<h2 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加/删除文件"></a>增加/删除文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加指定文件到暂存区</span></span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"><span class="comment"># 添加指定目录到暂存区，包括子目录</span></span><br><span class="line">$ git add [<span class="built_in">dir</span>]</span><br><span class="line"><span class="comment"># 添加当前目录的所有文件到暂存区</span></span><br><span class="line">$ git add .</span><br><span class="line"><span class="comment"># 添加每个变化前，都会要求确认</span></span><br><span class="line"><span class="comment"># 对于同一个文件的多处变化，可以实现分次提交</span></span><br><span class="line">$ git add -p</span><br><span class="line"><span class="comment"># 删除工作区文件，并且将这次删除放入暂存区</span></span><br><span class="line">$ git <span class="built_in">rm</span> [file1] [file2] ...</span><br><span class="line"><span class="comment"># 停止追踪指定文件，但该文件会保留在工作区</span></span><br><span class="line">$ git <span class="built_in">rm</span> --cached [file]</span><br><span class="line"><span class="comment"># 改名文件，并且将这个改名放入暂存区</span></span><br><span class="line">$ git <span class="built_in">mv</span> [file-original] [file-renamed]</span><br></pre></td></tr></table></figure>

<h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 提交暂存区到仓库区</span></span><br><span class="line">$ git commit -m [message]</span><br><span class="line"><span class="comment"># 提交暂存区的指定文件到仓库区</span></span><br><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br><span class="line"><span class="comment"># 提交工作区自上次commit之后的变化，直接到仓库区</span></span><br><span class="line">$ git commit -a</span><br><span class="line"><span class="comment"># 提交时显示所有diff信息</span></span><br><span class="line">$ git commit -v</span><br><span class="line"><span class="comment"># 将add和commit合为一步</span></span><br><span class="line">$ git commit -am <span class="string">&#x27;message&#x27;</span></span><br><span class="line"><span class="comment"># 使用一次新的commit，替代上一次提交</span></span><br><span class="line"><span class="comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span></span><br><span class="line">$ git commit --amend -m [message]</span><br><span class="line"><span class="comment"># 重做上一次commit，并包括指定文件的新变化</span></span><br><span class="line">$ git commit --amend [file1] [file2] ...</span><br></pre></td></tr></table></figure>

<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有本地分支</span></span><br><span class="line">$ git branch</span><br><span class="line"><span class="comment"># 列出所有远程分支</span></span><br><span class="line">$ git branch -r</span><br><span class="line"><span class="comment"># 列出所有本地分支和远程分支</span></span><br><span class="line">$ git branch -a</span><br><span class="line"><span class="comment"># 新建一个分支，但依然停留在当前分支</span></span><br><span class="line">$ git branch [branch-name]</span><br><span class="line"><span class="comment"># 新建一个分支，并切换到该分支</span></span><br><span class="line">$ git checkout -b [branch]</span><br><span class="line"><span class="comment"># 新建一个分支，指向指定commit</span></span><br><span class="line">$ git branch [branch] [commit]</span><br><span class="line"><span class="comment"># 新建一个分支，与指定的远程分支建立追踪关系</span></span><br><span class="line">$ git branch --track [branch] [remote-branch]</span><br><span class="line"><span class="comment"># 切换到指定分支，并更新工作区</span></span><br><span class="line">$ git checkout [branch-name]</span><br><span class="line"><span class="comment"># 切换到上一个分支</span></span><br><span class="line">$ git checkout -</span><br><span class="line"><span class="comment"># 建立追踪关系，在现有分支与指定的远程分支之间</span></span><br><span class="line">$ git branch --set-upstream [branch] [remote-branch]</span><br><span class="line"><span class="comment"># 合并指定分支到当前分支</span></span><br><span class="line">$ git merge [branch]</span><br><span class="line"><span class="comment"># 选择一个commit，合并进当前分支</span></span><br><span class="line">$ git cherry-pick [commit]</span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">$ git branch -d [branch-name]</span><br><span class="line"><span class="comment"># 删除远程分支</span></span><br><span class="line">$ git push origin --delete [branch-name]</span><br><span class="line">$ git branch -dr [remote/branch]</span><br><span class="line"><span class="comment"># 检出版本v2.0</span></span><br><span class="line">$ git checkout v2.0</span><br><span class="line"><span class="comment"># 从远程分支develop创建新本地分支devel并检出</span></span><br><span class="line">$ git checkout -b devel origin/develop</span><br><span class="line"><span class="comment"># 检出head版本的README文件（可用于修改错误回退）</span></span><br><span class="line">git checkout -- README </span><br></pre></td></tr></table></figure>

<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列出所有tag</span></span><br><span class="line">$ git tag</span><br><span class="line"><span class="comment"># 新建一个tag在当前commit</span></span><br><span class="line">$ git tag [tag]</span><br><span class="line"><span class="comment"># 新建一个tag在指定commit</span></span><br><span class="line">$ git tag [tag] [commit]</span><br><span class="line"><span class="comment"># 删除本地tag</span></span><br><span class="line">$ git tag -d [tag]</span><br><span class="line"><span class="comment"># 删除远程tag</span></span><br><span class="line">$ git push origin :refs/tags/[tagName]</span><br><span class="line"><span class="comment"># 查看tag信息</span></span><br><span class="line">$ git show [tag]</span><br><span class="line"><span class="comment"># 提交指定tag</span></span><br><span class="line">$ git push [remote] [tag]</span><br><span class="line"><span class="comment"># 提交所有tag</span></span><br><span class="line">$ git push [remote] --tags</span><br><span class="line"><span class="comment"># 新建一个分支，指向某个tag</span></span><br><span class="line">$ git checkout -b [branch] [tag]</span><br></pre></td></tr></table></figure>

<h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 显示有变更的文件</span></span><br><span class="line">$ git status</span><br><span class="line"><span class="comment"># 显示当前分支的版本历史</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"><span class="comment"># 显示commit历史，以及每次commit发生变更的文件</span></span><br><span class="line">$ git <span class="built_in">log</span> --<span class="built_in">stat</span></span><br><span class="line"><span class="comment"># 搜索提交历史，根据关键词</span></span><br><span class="line">$ git <span class="built_in">log</span> -S [keyword]</span><br><span class="line"><span class="comment"># 显示某个commit之后的所有变动，每个commit占据一行</span></span><br><span class="line">$ git <span class="built_in">log</span> [tag] HEAD --pretty=format:%s</span><br><span class="line"><span class="comment"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span></span><br><span class="line">$ git <span class="built_in">log</span> [tag] HEAD --grep feature</span><br><span class="line"><span class="comment"># 显示某个文件的版本历史，包括文件改名</span></span><br><span class="line">$ git <span class="built_in">log</span> --follow [file]</span><br><span class="line">$ git whatchanged [file]</span><br><span class="line"><span class="comment"># 显示指定文件相关的每一次diff</span></span><br><span class="line">$ git <span class="built_in">log</span> -p [file]</span><br><span class="line"><span class="comment"># 显示过去5次提交</span></span><br><span class="line">$ git <span class="built_in">log</span> -5 --pretty --oneline</span><br><span class="line"><span class="comment"># 显示所有提交过的用户，按提交次数排序</span></span><br><span class="line">$ git shortlog -sn</span><br><span class="line"><span class="comment"># 显示指定文件是什么人在什么时间修改过</span></span><br><span class="line">$ git blame [file]</span><br><span class="line"><span class="comment"># 显示暂存区和工作区的差异</span></span><br><span class="line">$ git diff</span><br><span class="line"><span class="comment"># 显示暂存区和上一个commit的差异</span></span><br><span class="line">$ git diff --cached [file]</span><br><span class="line"><span class="comment"># 显示工作区与当前分支最新commit之间的差异</span></span><br><span class="line">$ git diff HEAD</span><br><span class="line"><span class="comment"># 显示两次提交之间的差异</span></span><br><span class="line">$ git diff [first-branch]...[second-branch]</span><br><span class="line"><span class="comment"># 显示今天你写了多少行代码</span></span><br><span class="line">$ git diff --shortstat <span class="string">&quot;@&#123;0 day ago&#125;&quot;</span></span><br><span class="line"><span class="comment"># 显示某次提交的元数据和内容变化</span></span><br><span class="line">$ git show [commit]</span><br><span class="line"><span class="comment"># 显示某次提交发生变化的文件</span></span><br><span class="line">$ git show --name-only [commit]</span><br><span class="line"><span class="comment"># 显示某次提交时，某个文件的内容</span></span><br><span class="line">$ git show [commit]:[filename]</span><br><span class="line"><span class="comment"># 显示当前分支的最近几次提交</span></span><br><span class="line">$ git reflog</span><br></pre></td></tr></table></figure>

<h2 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载远程仓库的所有变动</span></span><br><span class="line">$ git fetch [remote]</span><br><span class="line"><span class="comment"># 显示所有远程仓库</span></span><br><span class="line">$ git remote -v</span><br><span class="line"><span class="comment"># 显示某个远程仓库的信息</span></span><br><span class="line">$ git remote show [remote]</span><br><span class="line"><span class="comment"># 增加一个新的远程仓库，并命名</span></span><br><span class="line">$ git remote add [shortname] [url]</span><br><span class="line"><span class="comment"># 取回远程仓库的变化，并与本地分支合并</span></span><br><span class="line">$ git pull [remote] [branch]</span><br><span class="line"><span class="comment"># 上传本地指定分支到远程仓库</span></span><br><span class="line">$ git push [remote] [branch]</span><br><span class="line"><span class="comment"># 强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class="line">$ git push [remote] --force</span><br><span class="line"><span class="comment"># 推送所有分支到远程仓库</span></span><br><span class="line">$ git push [remote] --all</span><br></pre></td></tr></table></figure>

<h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 恢复暂存区的指定文件到工作区</span></span><br><span class="line">$ git checkout [file]</span><br><span class="line"><span class="comment"># 恢复某个commit的指定文件到暂存区和工作区</span></span><br><span class="line">$ git checkout [commit] [file]</span><br><span class="line"><span class="comment"># 恢复暂存区的所有文件到工作区</span></span><br><span class="line">$ git checkout .</span><br><span class="line"><span class="comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span></span><br><span class="line">$ git reset [file]</span><br><span class="line"><span class="comment"># 重置暂存区与工作区，与上一次commit保持一致</span></span><br><span class="line">$ git reset --hard</span><br><span class="line"><span class="comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span></span><br><span class="line">$ git reset [commit]</span><br><span class="line"><span class="comment"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span></span><br><span class="line">$ git reset --hard [commit]</span><br><span class="line"><span class="comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span></span><br><span class="line">$ git reset --keep [commit]</span><br><span class="line"><span class="comment"># 新建一个commit，用来撤销指定commit</span></span><br><span class="line"><span class="comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span></span><br><span class="line">$ git revert [commit]</span><br><span class="line"><span class="comment"># 暂时将未提交的变化移除，稍后再移入</span></span><br><span class="line">$ git stash</span><br><span class="line">$ git stash pop</span><br></pre></td></tr></table></figure>

<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init                                                  <span class="comment"># 初始化本地git仓库（创建新仓库）</span></span><br><span class="line">git config --global user.name <span class="string">&quot;xxx&quot;</span>                       <span class="comment"># 配置用户名</span></span><br><span class="line">git config --global user.email <span class="string">&quot;xxx@xxx.com&quot;</span>              <span class="comment"># 配置邮件</span></span><br><span class="line">git config --global color.ui <span class="literal">true</span>                         <span class="comment"># git status等命令自动着色</span></span><br><span class="line">git config --global color.status auto</span><br><span class="line">git config --global color.diff auto</span><br><span class="line">git config --global color.branch auto</span><br><span class="line">git config --global color.interactive auto</span><br><span class="line">git config --global --<span class="built_in">unset</span> http.proxy                    <span class="comment"># remove  proxy configuration on git</span></span><br><span class="line">git <span class="built_in">clone</span> git+ssh://git@192.168.53.168/VT.git             <span class="comment"># clone远程仓库</span></span><br><span class="line">git status                                                <span class="comment"># 查看当前版本状态（是否修改）</span></span><br><span class="line">git add xyz                                               <span class="comment"># 添加xyz文件至index</span></span><br><span class="line">git add .                                                 <span class="comment"># 增加当前子目录下所有更改过的文件至index</span></span><br><span class="line">git commit -m <span class="string">&#x27;xxx&#x27;</span>                                       <span class="comment"># 提交</span></span><br><span class="line">git commit --amend -m <span class="string">&#x27;xxx&#x27;</span>                               <span class="comment"># 合并上一次提交（用于反复修改）</span></span><br><span class="line">git commit -am <span class="string">&#x27;xxx&#x27;</span>                                      <span class="comment"># 将add和commit合为一步</span></span><br><span class="line">git <span class="built_in">rm</span> xxx                                                <span class="comment"># 删除index中的文件</span></span><br><span class="line">git <span class="built_in">rm</span> -r *                                               <span class="comment"># 递归删除</span></span><br><span class="line">git <span class="built_in">log</span>                                                   <span class="comment"># 显示提交日志</span></span><br><span class="line">git <span class="built_in">log</span> -1                                                <span class="comment"># 显示1行日志 -n为n行</span></span><br><span class="line">git <span class="built_in">log</span> -5</span><br><span class="line">git <span class="built_in">log</span> --<span class="built_in">stat</span>                                            <span class="comment"># 显示提交日志及相关变动文件</span></span><br><span class="line">git <span class="built_in">log</span> -p -m</span><br><span class="line">git show dfb02e6e4f2f7b573337763e5c0013802e392818         <span class="comment"># 显示某个提交的详细内容</span></span><br><span class="line">git show dfb02                                            <span class="comment"># 可只用commitid的前几位</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>GIT</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>git log使用</title>
    <url>/2020/11/09/git-log%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h2><blockquote>
<p>任何版本控制器都是用来记录代码的变动历史。这能帮助你在项目中找到谁提交了什么代码，bug在哪次提交被引入的，并且能帮助你回滚有问题的改动。但是，只是存储这些信息而不知道怎么去引导和分类，也是没有用的。这就是git log这条命令被引入的原因。</p>
</blockquote>
<span id="more"></span>

<h2 id="输出格式化"><a href="#输出格式化" class="headerlink" title="输出格式化"></a>输出格式化</h2><p>我们先来看看如何通过传入一些参数，将<code>git log</code>的输出格式化。<br>如果你不喜欢<code>git log</code>默认的格式，可以用<code>git config</code>创建一个git log的别名，The git config Command</p>
<p><code>Oneline</code><br><code>--oneline</code>参数将每次提交记录汇总成一行，默认情况下，会展示commit的id和commit信息的第一行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline</span><br><span class="line"></span><br><span class="line">0e25143 Merge branch <span class="string">&#x27;feature&#x27;</span></span><br><span class="line">ad8621a Fix a bug <span class="keyword">in</span> the feature</span><br><span class="line">16b36c6 Add a new feature</span><br><span class="line">23ad9ad Add the initial code base</span><br></pre></td></tr></table></figure>

<p><code>Decorating</code><br>很多时候需要了解每次commit的关联的分支或者是标签。<code>--decorate</code>参数会展示每次commit对象的相关信息。<br>这个参数和可以和其他参数配合使用，比如，使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span> --oneline --decorate</span><br><span class="line"><span class="comment">#这个命令会对输出进行如下格式化</span></span><br><span class="line"></span><br><span class="line">0e25143 (HEAD, master) Merge branch <span class="string">&#x27;feature&#x27;</span></span><br><span class="line">ad8621a (feature) Fix a bug <span class="keyword">in</span> the feature</span><br><span class="line">16b36c6 Add a new feature</span><br><span class="line">23ad9ad (tag: v0.9) Add the initial code base</span><br></pre></td></tr></table></figure>

<p>从上面的输出可以看出，第一个commit是master分支的最后一条提交(HEAD)。第二条commit有一个叫feature的分支也指向了它。第4条commit被打上了v0.9的标签。</p>
<p>分支，标签，HEAD，commit历史几乎就是你git版本库里的信息，这个命令能让你了解项目完整的逻辑结构。</p>
<p><code>Diffs</code><br><code>git log</code>命令提供了很多参数用于展示每个commit的更改的信息。最常用的有<code>--stat</code>和<code>-p</code></p>
<p><code>--stat</code>参数将会显示每次提交中，每个文件加入和删除的行数（修改一行等同于加入一行和删除一行）。如果想要简单了解每个commit大致的改动，这个参数是很有用的。举个例子，下面这个commit中，hello.py这个文件添加了67行，删除了38行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">commit f2a238924e89ca1d4947662928218a06d39068c3</span><br><span class="line">Author: John &lt;john@example.com&gt;</span><br><span class="line">Date: Fri Jun 25 17:30:28 2014 -0500 </span><br><span class="line">Add a new feature hello.py | 105 ++++++++++++++++++++++++----------------- </span><br><span class="line">1 file changed, 67 insertion(+), 38 deletions(-)</span><br><span class="line"><span class="comment">#“+”和“-”数量显示的是添加和删除行数的占比。</span></span><br></pre></td></tr></table></figure>

<p>如果想要知道改动的详细信息，可以使用</p>
<p><code>git log -p</code><br>这个命令会将补丁的信息完整输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">commit 16b36c697eb2d24302f89aa22d9170dfe609855b</span><br><span class="line">Author: Mary &lt;mary@example.com&gt;</span><br><span class="line">Date: Fri Jun 25 17:31:57 2014 -0500 </span><br><span class="line">Fix a bug <span class="keyword">in</span> the feature</span><br><span class="line">diff --git a/hello.py b/hello.py</span><br><span class="line">index 18ca709..c673b40 100644</span><br><span class="line">--- a/hello.py</span><br><span class="line">+++ b/hello.py</span><br><span class="line">@@ -13,14 +13,14 @@ B</span><br><span class="line">-<span class="built_in">print</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">+<span class="built_in">print</span>(<span class="string">&quot;Hello, Git!&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>如果提交中包含了大量改动，输出信息可能会很长并且很复杂。通常，你会在完整的补丁信息中寻找特定的改动，这种情况下，可以使用pickaxe参数。</p>
<p><code>Shortlog</code><br><code>git shortlog</code>是<code>git log</code>的一个特别版本，用于生成发布的通告。它会将每个开发者提交的信息汇总，并且展示出来。使用这个命令可以可以很快看到各自做的事情。<br>举个例子，如果两个开发者提交了5次commit，<code>git shortlog</code>会输出这样的信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Mary (2): </span><br><span class="line">    Fix a bug <span class="keyword">in</span> the feature </span><br><span class="line">    Fix a serious security hole <span class="keyword">in</span> our framework</span><br><span class="line">John (3): </span><br><span class="line">    Add the initial code base </span><br><span class="line">    Add a new feature </span><br><span class="line">    Merge branch <span class="string">&#x27;feature&#x27;</span></span><br></pre></td></tr></table></figure>
<p><code>git shortlog</code>默认会按提交者名字排序，也可以传入<code>-n</code>参数按每个人的提交次数排序</p>
<p><code>Graphs</code><br><code>--graph</code> 参数会根据分枝提交历史绘出图像。这个命令通常和<code>--oneline</code>，<code>--decorate</code>一起使用</p>
<p><code>git log --graph --oneline --decorate</code><br>如果版本库中有两个分支，会有如下输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">* 0e25143 (HEAD, master) Merge branch <span class="string">&#x27;feature&#x27;</span></span><br><span class="line">|\ </span><br><span class="line">| * 16b36c6 Fix a bug <span class="keyword">in</span> the new feature</span><br><span class="line">| * 23ad9ad Start a new feature</span><br><span class="line">* | ad8621a Fix a critical security issue</span><br><span class="line">|/ </span><br><span class="line">* 400e4b7 Fix typos <span class="keyword">in</span> the documentation</span><br><span class="line">* 160e224 Add the initial code base</span><br></pre></td></tr></table></figure>
<p>*号的意思是commit在哪个分支上，所以上面的图像告诉我们23ad9ad和16b36c6者两个commit提交在了topic分支上，其他的commit提交在master分支上。</p>
<h2 id="自定义格式化"><a href="#自定义格式化" class="headerlink" title="自定义格式化"></a>自定义格式化</h2><p>可以使用<code>--pretty=format:&quot;&lt;string&gt;&quot;</code>来自定义输出的格式。输出格式有点像printf中的占位符。<br>举个例子，下面的命令中，%cn,%h和%cd会被提交者姓名，commit的hash缩写，提交的日期占据</p>
<p><code>git log --pretty=format:&quot;%cn committed %h on %cd&quot;</code><br>这会产生如下的输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">John committed 400e4b7 on Fri Jun 24 12:30:04 2014 -0500</span><br><span class="line">John committed 89ab2cf on Thu Jun 23 17:09:42 2014 -0500</span><br><span class="line">Mary committed 180e223 on Wed Jun 22 17:21:19 2014 -0500</span><br><span class="line">John committed f12ca28 on Wed Jun 22 13:50:31 2014 -0500</span><br></pre></td></tr></table></figure>
<p>占位符的说明可以在 <code>Pretty Formats</code>找到。</p>
<p>需要将git log信息重定向作为其他命令的输出时，这个命令尤其有用。</p>
<h2 id="过滤提交提交历史"><a href="#过滤提交提交历史" class="headerlink" title="过滤提交提交历史"></a>过滤提交提交历史</h2><p>格式化输出只是git log强大功能的一部分。git log还能够根据需求筛选commit。下面就来看看这部分的功能，上面提交的格式化功能也可以配合这部分使用。</p>
<p><strong>根据数量过滤</strong><br>最基本的过滤就是限制输出的commit个数。如果你只对最近的几次commit感兴趣，就不用讲所有commit历史输出。</p>
<p>使用<code>-&lt;n&gt;</code>参数可以做到这一点。举个例子，下面的命令只输出最近3条提交</p>
<p><code>git log -3</code></p>
<p><strong>根据日期过滤</strong><br>如果想找特定时间段的提交记录，可以使用<code>--after</code>或者是<code>--before</code>参数。这两个参数接受很多种日期格式，举个例子，下面的命令只显示2014年7月1号后的提交</p>
<p><code>git log --after=&quot;2014-7-1&quot;</code><br>也可以传入相对的时间概念，像”1 week ago”，或者是”yesterday”</p>
<p><code>git log --after=&quot;yesterday&quot;</code><br>如果想找某个时间区间的提交记录，可以同时传入<code>--before</code>和<code>--after</code>参数。<br>举个例子，可以用下面的命令找到2014年7月1号到4号之间的提交。</p>
<p><code>git log --after=&quot;2014-7-1&quot; --before=&quot;2014-7-4&quot;</code><br><code>--since</code>，<code>--until</code>和<code>--after</code>，<code>--before</code>是同义的</p>
<p><strong>按照提交者过滤</strong><br>如果想找某个开发者提交的commit，可以使用<code>--auther</code>参数，传入一个正则表达式，返回所有符合表达式的开发者提交的commit。如果知道想找的人是谁，直接传入字符也可以</p>
<p><code>git log --author=&quot;John&quot;</code><br>上面的命令会筛选出所有名字里包含”John”的作者提交的commit。</p>
<p>也可以用<code>正则</code>来满足更复杂的需求，比如筛选出名字里包含了John和Mary的开发者的提交。</p>
<p><code>git log --author=&quot;John\|Mary&quot;</code></p>
<p><strong>根据commit信息过滤</strong><br>使用<code>--grep</code>可以根据commit提交的信息过滤。这个和上面的–author差不多，只不过匹配的是commit信息，比如说可以这样</p>
<p><code>git log --grep=&quot;JRA-224:&quot;</code><br>也可以使用<code>-i</code>参数忽略大小写。</p>
<p><strong>根据文件过滤</strong><br>有很多时候，你只对某个文件的改动感兴趣。传入文件路径，就能找到所有和这个文件相关的提交记录，比如，下面的命令会筛出foo.py 和bar.py相关的提交</p>
<p><code>git log -- foo.py bar.py</code><br><code>-- </code>参数是告诉<code>git log</code>，后面传入的参数是文件路径，而不是分支的名字。如果传入的文件路径不可能是分支名的话，可以省略掉它。</p>
<p><strong>根据改动过滤</strong><br>根据代码中加入或者移除的某一行代码，也能筛选出相应的commit。这个叫做pickaxe，它接受形如<code>-S&quot;&lt;string&gt;&quot;</code>的参数。如果你想知道Hello, World!这行代码是何时加入到文件中的，可以使用下面的命令</p>
<p><code>git log -S&quot;Hello, World!&quot;</code><br>如果想查找匹配某个正则表达式的代码，可以传入这样子的参数-G”<regex>“。<br>这个功能在debug的时候是很有用的，因为它能够筛选出所有影响某一行代码的提交。它甚至能告诉你这一行代码是什么时候移到另外一个文件中的</regex></p>
<p><strong>过滤Merge信息</strong><br>git log输出包含merge信息。但是，如果开发组总是把上游分支里的更新mege到feature分支，而不是将feature分支rebase到上游分支，就会在代码库中看到非常多的merge信息。<br>可以使用<code>--no-merges</code>来过滤掉这个merge信息</p>
<p><code>git log --no-merges</code><br>另一方面，如果只想看到merge信息，可以使用<code>--merges</code></p>
<p><code>git log --merges</code></p>
<h2 id="统计git提交数脚本示例"><a href="#统计git提交数脚本示例" class="headerlink" title="统计git提交数脚本示例"></a>统计git提交数脚本示例</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#使用：修改AUTHOR配置，在项目根目录下，执行sh gitstat.sh</span></span><br><span class="line"><span class="comment">#生成gitstat.log</span></span><br><span class="line"></span><br><span class="line">GITSTAT_LOG=<span class="string">&quot;gitstat.log&quot;</span></span><br><span class="line">AUTHOR=<span class="string">&quot;Rma Ma&quot;</span> </span><br><span class="line">DURATION_OPS=<span class="string">&quot;--after=&quot;</span>2021-12-31<span class="string">&quot; --before=&quot;</span>2023-1-1<span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">&gt; <span class="variable">$&#123;GITSTAT_LOG&#125;</span></span><br><span class="line"></span><br><span class="line">commit_num=`git <span class="built_in">log</span> <span class="variable">$&#123;DURATION_OPS&#125;</span> --author=<span class="string">&quot;<span class="variable">$&#123;AUTHOR&#125;</span>&quot;</span> --no-merges   --oneline | <span class="built_in">wc</span> -l`</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;commit num : <span class="variable">$&#123;commit_num&#125;</span>&quot;</span> &gt;&gt; <span class="variable">$&#123;GITSTAT_LOG&#125;</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">log</span> --author=<span class="string">&quot;<span class="variable">$&#123;AUTHOR&#125;</span>&quot;</span> --no-merges <span class="variable">$&#123;DURATION_OPS&#125;</span> \</span><br><span class="line">--pretty=tformat: --numstat  | \</span><br><span class="line">awk <span class="string">&#x27;&#123;adds += $1; subs += $2; changes += $1 + $2&#125; END \</span></span><br><span class="line"><span class="string">&#123;printf &quot;added lines: %s, removed lines: %s, changed lines: %s\n&quot;, adds, subs, changes&#125;&#x27;</span> &gt;&gt; <span class="variable">$&#123;GITSTAT_LOG&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;commit info :&quot;</span> &gt;&gt; <span class="variable">$&#123;GITSTAT_LOG&#125;</span></span><br><span class="line">git <span class="built_in">log</span> --author=<span class="string">&quot;<span class="variable">$&#123;AUTHOR&#125;</span>&quot;</span> --no-merges <span class="variable">$&#123;DURATION_OPS&#125;</span>  --oneline  &gt;&gt; <span class="variable">$&#123;GITSTAT_LOG&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>呈现如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">commit num : 58</span><br><span class="line">added lines: 6099, removed lines: 1020, changed lines: 7119</span><br><span class="line">commit info :</span><br><span class="line">49542d8 commit info 1</span><br><span class="line">62d11a9 commit info 2</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>GIT</category>
      </categories>
      <tags>
        <tag>git_log</tag>
      </tags>
  </entry>
  <entry>
    <title>tcpdump使用介绍</title>
    <url>/2020/11/08/tcpdump%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>tcpdump 是一款强大的网络抓包工具，运行在 linux 平台上。熟悉 tcpdump 的使用能够帮助你分析、调试网络数据。</p>
<span id="more"></span>
<p>要想使用很好地掌握 tcpdump， 必须对网络报文（TCP/IP 协议）有一定的了解。不过对于简单的使用来说，只要有网络基础概念就行了。</p>
<p>tcpdump 是一个很复杂的命令，想了解它的方方面面非常不易，也不值得推荐，能够使用它解决日常工作中的问题才是关键。</p>
<h2 id="列子"><a href="#列子" class="headerlink" title="列子"></a>列子</h2><p>抓取eth0 53端口udp报文：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump –i eth0 udp port 53 –s 0 –w save.pcap –v </span><br></pre></td></tr></table></figure>

<h2 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h2><h3 id="设置不解析域名提升速度"><a href="#设置不解析域名提升速度" class="headerlink" title="设置不解析域名提升速度"></a>设置不解析域名提升速度</h3><p><code>-n</code>：不把ip转化成域名，直接显示 ip，避免执行 DNS lookups 的过程，速度会快很多<br><code>-nn</code>：不把协议和端口号转化成名字，速度也会快很多。</p>
<h3 id="结果输出到文件"><a href="#结果输出到文件" class="headerlink" title="结果输出到文件"></a>结果输出到文件</h3><p><code>-w</code>: 可用于wireshark分析</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump icmp -w icmp.pcap</span><br></pre></td></tr></table></figure>

<h3 id="从文件中读取包数据"><a href="#从文件中读取包数据" class="headerlink" title="从文件中读取包数据"></a>从文件中读取包数据</h3><p><code>-r</code>: 从文件中读取数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump icmp -r icmp.pcap</span><br></pre></td></tr></table></figure>

<h3 id="控制详细内容的输出"><a href="#控制详细内容的输出" class="headerlink" title="控制详细内容的输出"></a>控制详细内容的输出</h3><p><code>-v</code>：产生详细的输出. 比如包的TTL，id标识，数据包长度，以及IP包的一些选项。同时它还会打开一些附加的包完整性检测，比如对IP或ICMP包头部的校验和。<br><code>-vv</code>：产生比-v更详细的输出. 比如NFS回应包中的附加域将会被打印, SMB数据包也会被完全解码。<br><code>-vvv</code>：产生比-vv更详细的输出。比如 telent 时所使用的SB, SE 选项将会被打印, 如果telnet同时使用的是图形界面，其相应的图形选项将会以16进制的方式打印出来</p>
<h3 id="控制时间的显示"><a href="#控制时间的显示" class="headerlink" title="控制时间的显示"></a>控制时间的显示</h3><p><code>-t</code>：在每行的输出中不输出时间<br><code>-tt</code>：在每行的输出中会输出时间戳<br><code>-ttt</code>：输出每两行打印的时间间隔(以毫秒为单位)<br><code>-tttt</code>：在每行打印的时间戳之前添加日期的打印（此种选项，输出的时间最直观）</p>
<h3 id="显示数据包的头部"><a href="#显示数据包的头部" class="headerlink" title="显示数据包的头部"></a>显示数据包的头部</h3><p><code>-x</code>：以16进制的形式打印每个包的头部数据（但不包括数据链路层的头部）<br><code>-xx</code>：以16进制的形式打印每个包的头部数据（包括数据链路层的头部）<br><code>-X</code>：以16进制和 ASCII码形式打印出每个包的数据(但不包括连接层的头部)，这在分析一些新协议的数据包很方便。<br><code>-XX</code>：以16进制和 ASCII码形式打印出每个包的数据(包括连接层的头部)，这在分析一些新协议的数据包很方便。</p>
<h3 id="过滤指定网卡的数据包"><a href="#过滤指定网卡的数据包" class="headerlink" title="过滤指定网卡的数据包"></a>过滤指定网卡的数据包</h3><p><code>-i</code>：指定要过滤的网卡接口，如果要查看所有网卡，可以 <code>-i any</code></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><code>-q</code> : 简洁地打印输出。即打印很少的协议相关信息, 从而输出行都比较简短.<br><code>-c</code> : 捕获 count 个包 tcpdump 就退出<br><code>-s</code> : tcpdump 默认只会截取前 96 字节的内容，要想截取所有的报文内容，可以使用 -s number， number 就是你要截取的报文字节数，如果是 0 的话，表示截取报文全部内容。<br><code>-S</code> : 使用绝对序列号，而不是相对序列号</p>
<h2 id="常规过滤规则"><a href="#常规过滤规则" class="headerlink" title="常规过滤规则"></a>常规过滤规则</h2><h3 id="基于IP地址过滤：host"><a href="#基于IP地址过滤：host" class="headerlink" title="基于IP地址过滤：host"></a>基于IP地址过滤：host</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump host 192.168.10.100</span><br></pre></td></tr></table></figure>
<p>数据包的 ip 可以再细分为源ip和目标ip两种</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据源ip进行过滤</span></span><br><span class="line">$ tcpdump -i eth2 src 192.168.10.100</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据目标ip进行过滤</span></span><br><span class="line">$ tcpdump -i eth2 dst 192.168.10.200</span><br></pre></td></tr></table></figure>

<h3 id="基于网段进行过滤：net"><a href="#基于网段进行过滤：net" class="headerlink" title="基于网段进行过滤：net"></a>基于网段进行过滤：net</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump net 192.168.10.0/24</span><br></pre></td></tr></table></figure>
<p>网段同样可以再细分为源网段和目标网段</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据源网段进行过滤</span></span><br><span class="line">$ tcpdump src net 192.168</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据目标网段进行过滤</span></span><br><span class="line">$ tcpdump dst net 192.168</span><br></pre></td></tr></table></figure>
<h3 id="基于端口进行过滤：port"><a href="#基于端口进行过滤：port" class="headerlink" title="基于端口进行过滤：port"></a>基于端口进行过滤：port</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump port 8088</span><br></pre></td></tr></table></figure>
<p>端口同样可以再细分为源端口，目标端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据源端口进行过滤</span></span><br><span class="line">$ tcpdump src port 8088</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据目标端口进行过滤</span></span><br><span class="line">$ tcpdump dst port 8088</span><br></pre></td></tr></table></figure>
<p>如果你想要同时指定两个端口你可以这样写</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump port 80 or port 8088</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump port 80 or 8088</span><br></pre></td></tr></table></figure>

<h3 id="基于协议进行过滤：proto"><a href="#基于协议进行过滤：proto" class="headerlink" title="基于协议进行过滤：proto"></a>基于协议进行过滤：proto</h3><p>常见的网络协议有：tcp, udp, icmp, http, ip,ipv6 等</p>
<h2 id="如何抓取到更精准的包？"><a href="#如何抓取到更精准的包？" class="headerlink" title="如何抓取到更精准的包？"></a>如何抓取到更精准的包？</h2><p>例如：只想抓取HTTP 的 POST 请求，则命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tcpdump -s 0 -A -vv <span class="string">&#x27;tcp[((tcp[12:1] &amp; 0xf0) &gt;&gt; 2):4]&#x27;</span></span><br></pre></td></tr></table></figure>
<p>具体用法如下：<br><code>tcp[n]</code>：表示 tcp 报文里 第 n 个字节<br><code>tcp[n:c]</code>：表示 tcp 报文里从第n个字节开始取 c 个字节<br>例如：<br><code>tcp[12:1]</code> 表示从报文的第12个字节（因为有第0个字节，所以这里的12其实表示的是13）开始算起取一个字节，也就是 8 个bit。查看 <a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol#TCP_segment_structure">tcp 的报文首部结构</a>，可以得知这 8 个bit 其实就是下图中的红框圈起来的位置，而在这里我们只要前面 4个bit，也就是实际数据在整个报文首部中的偏移量。<br><img src="2c2c84fde3a9e30df481d71c00ae384b454fc22c0d73a10af2a823680cd052a9.png" alt="图 1"><br><code>&amp;</code>：是位运算里的 and 操作符，比如 0011 &amp; 0010 = 0010<br><code>&gt;&gt;</code>：是位运算里的右移操作，比如 0111 &gt;&gt; 2 = 0001<br><code>0xf0</code>：是 10 进制的 240 的 16 进制表示，但对于位操作来说，10进制和16进制都将毫无意义，我们需要的是二进制，将其转换成二进制后是：11110000，这个数有什么特点呢？前面个 4bit 全部是 1，后面4个bit全部是0</p>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>tcpdump</tag>
      </tags>
  </entry>
  <entry>
    <title>wsl常用命令</title>
    <url>/2020/11/07/wsl%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h1><h2 id="列出可用的-Linux-发行版"><a href="#列出可用的-Linux-发行版" class="headerlink" title="列出可用的 Linux 发行版"></a>列出可用的 Linux 发行版</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --list --online</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p><img src="7ec56d6171fba0cf87c50f6de7c7b91acf1ae3f2f158f41d224f2292ff1875de.png" alt="图 10">  </p>
<h2 id="列出已安装的-Linux-发行版"><a href="#列出已安装的-Linux-发行版" class="headerlink" title="列出已安装的 Linux 发行版"></a>列出已安装的 Linux 发行版</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --list --verbose</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl -l -v</span><br></pre></td></tr></table></figure>
<p><img src="8910516bd8ed4d4e895e9d4783f8a8ed25359315f576169c8b6570b7a1febe42.png" alt="图 11">  </p>
<h2 id="安装特定的-Linux-发行版"><a href="#安装特定的-Linux-发行版" class="headerlink" title="安装特定的 Linux 发行版"></a>安装特定的 Linux 发行版</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --install --distribution &lt;Distribution Name&gt;</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --install -d &lt;Distribution Name&gt;</span><br></pre></td></tr></table></figure>


<h2 id="启动并进入特定的版本"><a href="#启动并进入特定的版本" class="headerlink" title="启动并进入特定的版本"></a>启动并进入特定的版本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl -d &lt;Distribution Name&gt;</span><br></pre></td></tr></table></figure>

<h2 id="将-WSL-版本设置为-1-或-2"><a href="#将-WSL-版本设置为-1-或-2" class="headerlink" title="将 WSL 版本设置为 1 或 2"></a>将 WSL 版本设置为 1 或 2</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --set-version &lt;distribution name&gt; &lt;versionNumber&gt;</span><br></pre></td></tr></table></figure>

<h2 id="设置默认-WSL-版本"><a href="#设置默认-WSL-版本" class="headerlink" title="设置默认 WSL 版本"></a>设置默认 WSL 版本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --set-default-version &lt;Version&gt;</span><br></pre></td></tr></table></figure>

<h2 id="设置默认-Linux-发行版"><a href="#设置默认-Linux-发行版" class="headerlink" title="设置默认 Linux 发行版"></a>设置默认 Linux 发行版</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --set-default &lt;Distribution Name&gt;</span><br></pre></td></tr></table></figure>

<h2 id="更新-WSL"><a href="#更新-WSL" class="headerlink" title="更新 WSL"></a>更新 WSL</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --update</span><br></pre></td></tr></table></figure>

<h2 id="检查-WSL-状态"><a href="#检查-WSL-状态" class="headerlink" title="检查 WSL 状态"></a>检查 WSL 状态</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --status</span><br></pre></td></tr></table></figure>

<h2 id="Help-命令"><a href="#Help-命令" class="headerlink" title="Help 命令"></a>Help 命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --<span class="built_in">help</span></span><br></pre></td></tr></table></figure>

<h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><h2 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --<span class="built_in">export</span> Ubuntu-20.04 d:\ubuntu20.04.tar</span><br></pre></td></tr></table></figure>

<h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --import &lt;DistributionName&gt;  &lt;安装位置&gt;  &lt;tar文件名&gt;</span><br></pre></td></tr></table></figure>
<p>例如：<br>在d盘ubuntu目录下导入ubuntu20.04.tar，指定wsl2版本，则命令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --import Ubuntu-20.04 d:\ubuntu d:\ubuntu20.04.tar --version 2</span><br></pre></td></tr></table></figure>
<p><strong>导入时改变DistributionName(如Ubuntu-20.04改成Ubuntu)，会导致WSL不可用。</strong></p>
<h2 id="Ubuntu修改默认登陆用户"><a href="#Ubuntu修改默认登陆用户" class="headerlink" title="Ubuntu修改默认登陆用户"></a>Ubuntu修改默认登陆用户</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ubuntu2004.exe config --default-user root</span><br></pre></td></tr></table></figure>

<h2 id="注销发行版"><a href="#注销发行版" class="headerlink" title="注销发行版"></a>注销发行版</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --unregister Ubuntu-20.04</span><br></pre></td></tr></table></figure>

<h2 id="LxRunOffline"><a href="#LxRunOffline" class="headerlink" title="LxRunOffline"></a>LxRunOffline</h2><p>可以安装任何linux发行版，例如centos</p>
]]></content>
      <categories>
        <category>WSL</category>
      </categories>
      <tags>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title>wsl设置开机启动ssh服务</title>
    <url>/2020/11/07/wsl%E8%AE%BE%E7%BD%AE%E5%BC%80%E6%9C%BA%E5%90%AF%E5%8A%A8ssh%E6%9C%8D%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="安装ssh服务"><a href="#安装ssh服务" class="headerlink" title="安装ssh服务"></a>安装ssh服务</h2><p>说明:虽然已经安装了ssh服务，但是好像默认自带的不能用。所以需要先卸载再安装。</p>
<p>执行以下命令进行卸载和安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">sudo apt remove openssh-server</span><br><span class="line">sudo apt install openssh-server</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>编辑ssh配置文件，/etc/ssh/sshd_config，修改的配置项如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">Port 1220</span><br><span class="line">ListenAddress 0.0.0.0</span><br><span class="line"></span><br><span class="line">PermitRootLogin <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line">PasswordAuthentication <span class="built_in">yes</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>service ssh restart</code></p>
<h2 id="添加开机自启动ssh服务"><a href="#添加开机自启动ssh服务" class="headerlink" title="添加开机自启动ssh服务"></a>添加开机自启动ssh服务</h2><ol>
<li>在 Windows10 上，使用 windows + r 键，调出运行，输入 shell:startup 进入开机启动项文件夹</li>
<li>新建wsl.bat</li>
<li>添加如下内容：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">C:\Users\rma.ma\AppData\Local\Microsoft\WindowsApps\ubuntu1804.exe run <span class="string">&quot;sudo service ssh start&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>WSL</category>
      </categories>
      <tags>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title>wsl安装Ubuntu</title>
    <url>/2020/11/07/wsl%E5%AE%89%E8%A3%85Ubuntu/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>wsl常用命令<br>wsl设置开机启动ssh服务</p>
<h2 id="查看已经安装和可安装的版本"><a href="#查看已经安装和可安装的版本" class="headerlink" title="查看已经安装和可安装的版本"></a>查看已经安装和可安装的版本</h2><p>通过<code>wsl -l -v</code>和<code>wsl -l -o</code>查看已经安装和可安装的版本，本次已Ubuntu-20.04为例做安装</p>
<span id="more"></span>
<p><img src="89215c6f60f9caf5a5f38ee811a945b01e4da2330e72059db9818db0a9f1b4ff.png" alt="图 1">  </p>
<h2 id="安装Ubuntu-20-04发行版"><a href="#安装Ubuntu-20-04发行版" class="headerlink" title="安装Ubuntu-20.04发行版"></a>安装Ubuntu-20.04发行版</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --install -d Ubuntu-20.04</span><br></pre></td></tr></table></figure>
<p><img src="81a43f49f8cb1b173ca879badc27f2759dbbf6a494d06eec9c85248927b1b9a2.png" alt="图 2">  </p>
<h2 id="设置默认登录用户为root"><a href="#设置默认登录用户为root" class="headerlink" title="设置默认登录用户为root"></a>设置默认登录用户为root</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ubuntu2004.exe config --default-user root</span><br></pre></td></tr></table></figure>
<p>设置root密码<br><img src="541acf7bef46d4c729ce79102a7f79530634818c2c5a011be37a4b245d0b7a5b.png" alt="图 3">  </p>
<h2 id="ssh登录"><a href="#ssh登录" class="headerlink" title="ssh登录"></a>ssh登录</h2><ol>
<li><p>启动并进入Ubuntu-20.04</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl -d Ubuntu-20.04</span><br></pre></td></tr></table></figure></li>
<li><p><a href="https://www.cnblogs.com/zqifa/p/12910989.html">更换apt源</a><br>sudo cp /etc/apt/sources.list /etc/apt/sources.list.backup<br>vim /etc/apt/sources.list<br>内容如下</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#阿里云源</span></span><br><span class="line"></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"><span class="comment">#清华源</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 预发布软件源，不建议启用</span></span><br><span class="line"><span class="comment"># deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse</span></span><br><span class="line"><span class="comment"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#中科大源</span></span><br><span class="line"></span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"><span class="comment">#网易163源</span></span><br><span class="line"></span><br><span class="line">deb http://mirrors.163.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>sudo apt-get update<br>sudo apt-get upgrade</p>
<ol start="3">
<li>wsl设置开机启动ssh服务</li>
</ol>
<h2 id="wsl连不上外网修复"><a href="#wsl连不上外网修复" class="headerlink" title="wsl连不上外网修复"></a>wsl连不上外网修复</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wsl --shutdown</span><br><span class="line">netsh winsock reset</span><br><span class="line">netsh int ip reset all</span><br><span class="line">netsh winhttp reset proxy</span><br><span class="line">ipconfig /flushdns</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>重启电脑</p>
]]></content>
      <categories>
        <category>WSL</category>
      </categories>
      <tags>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title>mlx5环境安装</title>
    <url>/2020/11/06/mlx5%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>环境信息：centos7 x86_64 LINUX-5</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install python-devel lsof</span><br><span class="line">yum install -y createrepo</span><br><span class="line">yum install tk</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="安装包准备"><a href="#安装包准备" class="headerlink" title="安装包准备"></a>安装包准备</h2><p>MLNX_OFED_LINUX-5.4-1.0.3.0-rhel7.4-x86_64.tgz<br>该驱动下载官网：<a href="https://www.mellanox.com/products/infiniband-drivers/linux/mlnx_ofed">https://www.mellanox.com/products/infiniband-drivers/linux/mlnx_ofed</a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>cd /home/setup/MLNX_OFED_LINUX-5.4-3.0.3.0-rhel7.4-x86_64<br>./mlnxofedinstall –upstream-libs –dpdk –add-kernel-support<br><img src="4e802edfe5cc5c05e95ffa36e3e6dfff420d76854025737d8fb3443e86735814.png" alt="图 1">  </p>
<p>/etc/init.d/openibd restart<br><img src="29957518d473b6b6cdaa1e4480719011baf03d8227fd6f6ede00c2d4d5ec2f49.png" alt="图 2"><br><img src="1d4b811ccacdda6cc4e574bdaf079b2dc3b8f90df193afac667c9fe17038ee82.png" alt="图 3">  </p>
<p>./mlnx_add_kernel_support.sh -m /home/setup/MLNX_OFED_LINUX-5.4-3.0.3.0-rhel7.4-x86_64<br><img src="341a0189edff3f9b0067fc99d88cb0013ec896541ec2512522dc34cbb067711d.png" alt="图 4"><br><img src="e4b42ff5bc2aa8054c16240c88013b6115ebb3a25474d2243f2245d7df1d9b36.png" alt="图 5">  </p>
<p>环境安装好后会有以下文件生成<br><img src="98bea2c8977a696b56a4a749b18c5fd7090eab8c98184d163332961836a417bf.png" alt="图 6">  </p>
]]></content>
      <categories>
        <category>DPDK</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>DPDK</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux之大页内存</title>
    <url>/2020/11/06/Linux%E4%B9%8B%E5%A4%A7%E9%A1%B5%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<h2 id="Linux之大页内存"><a href="#Linux之大页内存" class="headerlink" title="Linux之大页内存"></a>Linux之大页内存</h2><p>Linux通过使用大页内存来取代传统的4kb内存页面，使得管理虚拟地址数变少，加快了从虚拟地址到物理地址的映射以及通过摒弃内存页面的换入换出以提高内存的整体性能。</p>
<ul>
<li>优点1：不存在页面由于内存空间不足引起的换入换出。</li>
<li>优点2：相同的内存大小情况下，管理的虚拟地址减少，降低CPU管理内存地址压力。</li>
<li>优点3：普通内存结构，每一个页面（4K）就需要64字节进行管理。使用大页内存可以降低管理查找页面负载。</li>
<li>优点4：提高内存的整体性能。<span id="more"></span>
<h2 id="Linux之透明大页"><a href="#Linux之透明大页" class="headerlink" title="Linux之透明大页"></a>Linux之透明大页</h2></li>
</ul>
<p>由于 Huge pages 很难手动管理，而且通常需要对代码进行重大的更改才能有效的使用，因此 RHEL 6 开始引入了 Transparent Huge Pages （ THP ）， THP 是一个抽象层，能够自动创建、管理和使用传统大页。<br>大页面不是某个进程独占的，它是一个系统资源，<strong>如果透明大页面功能被打开，那么大页面会为所有进程服务</strong>。<br>Linux操作系统，<strong>默认打开了透明大页面功能</strong>（Transparent Hugepages），这个功能会使操作系统看到有大页面存在的时候，会在应用进程或者内核进程申请大块内存的时候，优先为它们分配大页面，大页面无法分配时，才会分配传统的4KB页面。</p>
<h2 id="DPDK与大页内存"><a href="#DPDK与大页内存" class="headerlink" title="DPDK与大页内存"></a>DPDK与大页内存</h2><p>DPDK程序启动，rte_eal_init初始化环境抽象层（ EAL ）时候，映射Hugepages 。<br>当系统运行一段时间后，DPDK重启时rte_eal_init初始化可能失败，报错类似如下信息：<br>EAL: No free hugepages reported in hugepages-2048kB<br>EAL: Can only reserve 927 pages from 4096 requested<br>这个问题是说，在EAL在初始化的时候，无法从操作系统的Hugepages中找到所需要的连续的大页面。<br><strong>根本原因在于当前系统开启了透明大页，大页内存被系统分配给其他程序使用了</strong>。</p>
<h2 id="查看与关闭透明大页"><a href="#查看与关闭透明大页" class="headerlink" title="查看与关闭透明大页"></a>查看与关闭透明大页</h2><p>相关命令：cat  /sys/kernel/mm/transparent_hugepage/enabled<br>echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled<br>echo never &gt; /sys/kernel/mm/transparent_hugepage/defrag</p>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>DPDK</tag>
        <tag>大页内存</tag>
        <tag>透明大页</tag>
      </tags>
  </entry>
  <entry>
    <title>内存检测之valgrind</title>
    <url>/2020/11/05/%E5%86%85%E5%AD%98%E6%A3%80%E6%B5%8B%E4%B9%8Bvalgrind/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>valgrind包含几个标准的工具，它们是：</p>
<span id="more"></span>
<p>1、memcheck</p>
<p>memcheck探测程序中内存管理存在的问题。它检查所有对内存的读/写操作，并截取所有的malloc/new/free/delete调用。因此memcheck工具能够探测到以下问题：</p>
<p>1）使用未初始化的内存</p>
<p>2）读/写已经被释放的内存</p>
<p>3）读/写内存越界</p>
<p>4）读/写不恰当的内存栈空间</p>
<p>5）内存泄漏</p>
<p>6）使用malloc/new/new[]和free/delete/delete[]不匹配。</p>
<p>2、cachegrind</p>
<p>cachegrind是一个cache剖析器。它模拟执行CPU中的L1, D1和L2 cache，因此它能很精确的指出代码中的cache未命中。如果你需要，它可以打印出cache未命中的次数，内存引用和发生cache未命中的每一行代码，每一个函数，每一个模块和整个程序的摘要。如果你要求更细致的信息，它可以打印出每一行机器码的未命中次数。在x86和amd64上，cachegrind通过CPUID自动探测机器的cache配置，所以在多数情况下它不再需要更多的配置信息了。</p>
<p>3、helgrind</p>
<p>helgrind查找多线程程序中的竞争数据。helgrind查找内存地址，那些被多于一条线程访问的内存地址，但是没有使用一致的锁就会被查出。这表示这些地址在多线程间访问的时候没有进行同步，很可能会引起很难查找的时序问题。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">valgrind --tool=memcheck --leak-check=full --show-reachable=<span class="built_in">yes</span> --trace-children=<span class="built_in">yes</span> --log-file=reportleak ./xxx</span><br></pre></td></tr></table></figure>

<p>其中./xxx代表可执行程序，执行完之后将生产日志文件reportleak，<br>注意：如果是不停止程序，那么可以通过ctrl+c停止运行；如果是后台运行程序，那么可以top查看memcheck进程的pid，通过kill -2 该pid，发送ctrl+c信号停止。<br>一定要停止才能生存完整的reportleak</p>
<h3 id="使用样例"><a href="#使用样例" class="headerlink" title="使用样例"></a>使用样例</h3><ol>
<li><p>样例代码: 代码中Leak和AvoidLeak存在内存泄漏<br><img src="4f4d3f0f999e05d2751a403ca94b51e93d2cfe2ca198e493add36f27c1be5e12.png" alt="图 20">  </p>
</li>
<li><p>编译运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">valgrind --tool=memcheck --leak-check=full --show-reachable=<span class="built_in">yes</span> --trace-children=<span class="built_in">yes</span> --log-file=reportleak ./test</span><br></pre></td></tr></table></figure>
<p>查看reportleak中definitely的日志<br><img src="b217a8cfe633d131b63f5a5fe4656e37f93e91c0151b2b86e52e274289e3a51b.png" alt="图 21">  </p>
</li>
</ol>
<h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><p>valgrind 的好处是不用编译应用程序即可进行内存泄漏的检测，而且内存泄漏无处遁形，上述相同的测试程序使用tcmalloc无法报出Leak的内存泄漏</p>
<p>然而valgrind 太过于庞大，对机器硬件性能要求较高，在目前8核的机器上使用valgrind 会导致CPU飙高</p>
]]></content>
      <categories>
        <category>内存检测</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>内存检测</tag>
        <tag>valgrind</tag>
      </tags>
  </entry>
  <entry>
    <title>内存检测之asan</title>
    <url>/2020/11/04/%E5%86%85%E5%AD%98%E6%A3%80%E6%B5%8B%E4%B9%8Basan/</url>
    <content><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>addressSanitizer主要包括两部分：插桩(Instrumentation)和动态运行库(Run-time library)。    </p>
<span id="more"></span>
<p>插桩主要是针对在llvm编译器级别对访问内存的操作(store，load，alloca等)，将它们进行处理。<br>动态运行库主要提供一些运行时的复杂的功能(比如poison/unpoison shadow memory)以及将malloc,free等系统调用函数hook住。<br>该算法的思路是：如果想防住Buffer Overflow漏洞，只需要在每块内存区域右端（或两端，能防overflow和underflow）加一块区域（RedZone），使RedZone的区域的影子内存（Shadow Memory)设置为不可写即可。</p>
<h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><ul>
<li>GCC版本4.8以及以上</li>
<li>安装asan动态库(libasan)</li>
<li>编译参数加上 -fsanitize=address -fno-omit-frame-pointer –g</li>
<li>运行程序，查看结果</li>
</ul>
<h2 id="使用样例"><a href="#使用样例" class="headerlink" title="使用样例"></a>使用样例</h2><ul>
<li><p>样例代码: 代码存在内存泄漏<br><img src="74b8a5a4910de02d7b8c993258ad787fcb32996313ef3cee0e2fd49e2f893f89.png" alt="图 10"></p>
</li>
<li><p>编译运行<br><img src="17b5883dc069c8c32892d589d2c9273eaf8124babca0590e2e5933689c15ada7.png" alt="图 11"></p>
</li>
<li><p>样例代码: 代码存在内存越界<br><img src="b92b03582a8c04de6737c16ec405f89fac0f399f3d068a802f478846ddc29634.png" alt="图 12"></p>
</li>
<li><p>编译运行<br><img src="5a57213a417566f56b5a0e91af3a8add8f4f77a95671a5830a807a5e4a97bc53.png" alt="图 13"></p>
</li>
</ul>
<h1 id="AddressSanitizer能检测的错误"><a href="#AddressSanitizer能检测的错误" class="headerlink" title="AddressSanitizer能检测的错误"></a>AddressSanitizer能检测的错误</h1><p><img src="40fd715d333285db18a8d99dd4fa300f9f8105a6b0b3d80ceb78aeb4397aaa77.png" alt="图 14"></p>
<h1 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h1><p>Asan目前能定位绝大都部分的内存越界；但是对于一些特殊情况下的越界访问好像是无法定位的；例如下面的场景</p>
<p><img src="9871fbda3864c971db9013d26118f10f0cefc0081f03aa6b6eb0f8aae87427f0.png" alt="图 15"></p>
<p>编译运行后，asan工具无法很好的抛出异常<br><img src="b8f42ac1161a0a1ab95e8f6bee047502485ba41942a947391067d3413c3a15d3.png" alt="图 16"><br>即，asan无法定位分配的有效内存内的越界，例如内存池或者结构体等，在连续有效的内存内哪怕一个成员覆盖了相邻成员的内存。</p>
]]></content>
      <categories>
        <category>内存检测</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>内存检测</tag>
        <tag>asan</tag>
      </tags>
  </entry>
  <entry>
    <title>内存检测之TCMalloc</title>
    <url>/2020/11/03/%E5%86%85%E5%AD%98%E6%A3%80%E6%B5%8B%E4%B9%8Btcmalloc/</url>
    <content><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>TCMalloc就是一个内存分配器，管理堆内存，主要影响malloc和free，用于降低频繁分配、释放内存造成的性能损耗，并且有效地控制内存碎片。</p>
<span id="more"></span>
<p>glibc中的内存分配器是ptmalloc2，tcmalloc号称要比它快。<br>一次malloc和free操作，ptmalloc需要300ns，而tcmalloc只要50ns。<br>同时tcmalloc也优化了小对象的存储，需要更少的空间。<br>tcmalloc特别对多线程做了优化，对于小对象的分配基本上是不存在锁竞争，而大对象使用了细粒度、高效的自旋锁（spinlock）。<br>分配给线程的本地缓存，在长时间空闲的情况下会被回收，供其他线程使用，这样提高了在多线程情况下的内存利用率，不会浪费内存，而这一点ptmalloc2是做不到的。<br> <br>TCMalloc除了解决内存碎片，提升申请释放效率，还包含了一个堆检查器以及一个堆测量器，用于检测程序内存泄漏。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol>
<li><p>tcmalloc库安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install libgoogle-perftools-dev</span><br></pre></td></tr></table></figure></li>
<li><p>安装pprof工具</p>
<ul>
<li>安装autotools工具包<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install autotools-dev m4 autoconf2.13 autoconf-archive gnu-standards autoconf-doc libtool autoconf</span><br></pre></td></tr></table></figure></li>
<li>源码下载 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:gperftools/gperftools.git</span><br></pre></td></tr></table></figure></li>
<li>进入gperftools目录执行./autogen.sh</li>
<li>./configure &amp;&amp; make &amp;&amp; make install</li>
<li>查看pprof是否安装成功<br><img src="b8ad9413113be96825243c343f1785e1b45ffe3934604b0e23d948aa0cc9e59c.png" alt="图 7">  </li>
</ul>
</li>
<li><p>测试程序验证</p>
<ul>
<li>编译链接时添加-ltcmalloc</li>
<li>env HEAPCHECK=normal PPROF_PATH=/usr/local/bin/pprof ./test<br><img src="5d929d3cf8389aada4f8273a654e4d0a7dbe5a913cc4701d06d2b54a00324921.png" alt="图 8">  </li>
<li>参数说明:<br><img src="368850a3ea956629e4abd887c9282def0d08c00238af402bb51e5fd473e7ad23.png" alt="图 9">  </li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>内存检测</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>内存检测</tag>
        <tag>TCMalloc</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode如何优雅的显示大纲</title>
    <url>/2020/10/27/vscode%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E6%98%BE%E7%A4%BA%E5%A4%A7%E7%BA%B2/</url>
    <content><![CDATA[<h2 id="内置大纲"><a href="#内置大纲" class="headerlink" title="内置大纲"></a>内置大纲</h2><p>vscode 内置的大纲可以帮助我们理清代码层级。在设置<strong>跟随光标</strong>后还可以自动展开节点，清楚地看到代码上下文的结构。<br>但它有个缺点， 节点不会自己折叠，造成大纲只会越来越长。</p>
<span id="more"></span>
<p><img src="2bb6e7220bffcb46bf2ed064fcce7b3b7fd6fa398d9cdf5df93189515d4f77ea.png" alt="图 1">  </p>
<p>实际上，在同级作用域中显示变量和函数并不能帮助我们理解我们关注的代码的组织。<br>vscode 内置的缩略地图 minimap 提供了源代码的高层级概述，这对快速导航和理解代码很有用。<br>但是，小屏幕的用户可能只能将缩略图作为大号的彩色滚动条。</p>
<p>为什么不把二者的优点结合起来呢？</p>
<h2 id="Outline-Map"><a href="#Outline-Map" class="headerlink" title="Outline Map"></a>Outline Map</h2><p>可视，可互动的大纲地图，提供大纲的清晰条理与缩略地图的直观概览</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p><strong>跟随光标</strong><br>高亮光标所在位置。</p>
<p>高亮编辑器可见区域。</p>
<p>自动展开编辑器视图中可见的作用域， 折叠不可见的作用域，保持清晰的层级。<br><img src="4605c9451918be66cb14a2aa9c41ac7c52ffcc121792c0d99b9822b72c72a76a.png" alt="图 2">  </p>
<p><strong>快速导航</strong><br>点击节点即可跳转，正如大纲中的那样。<br><img src="879658d6c56b3fdafbe447346f1d34414c92b52ca3033faf9990a09354b205de.png" alt="图 3">  </p>
<p><strong>标记诊断信息</strong><br><img src="78103a712162b947bff0c1ce429acbcc161c60ef211fb8abc65a03f987691f7a.png" alt="图 4">  </p>
<p><strong>自定义颜色主题</strong></p>
<p>设置<code>outline-map.color</code></p>
<p><img src="3d47664c20bcfdb371ab5646cc8a31c3ddc3f12f19332412a8248517e9fac68c.png" alt="图 5">  </p>
<p><strong>自动减少缩进</strong></p>
<p>设置 <code>outline-map.enableAutomaticIndentReduction: true</code><br><img src="b81d20034bc31d39c24ceb1e9429edef9ad9976dcf5eb0e1097b1a1c8e69aa94.png" alt="图 6">  </p>
<p><strong>固定📌大纲</strong></p>
<p><img src="97fe644af1925c45ba6204c4562e64ded7c9ae187b0d66f0385addd2c9fa0fe2.png" alt="图 7">  </p>
<p><strong>手动展开</strong></p>
<p><img src="568487cd751b293ce009556601d6b5a3d60be8e709c47ef30804ec7ff5bbdaf9.png" alt="图 8">  </p>
<p><strong>增加/减少最大深度</strong><br><img src="bda8b52eb31f7023c49404badfb681758404dceac9fe6d10ef72e107ad8bcd0c.png" alt="图 9">  </p>
]]></content>
      <categories>
        <category>VSCODE</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>settings-sync同步vscode配置</title>
    <url>/2020/10/27/settings-sync%E5%90%8C%E6%AD%A5vscode%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="配置同步：将自己本地的配置云同步到-GitHub"><a href="#配置同步：将自己本地的配置云同步到-GitHub" class="headerlink" title="配置同步：将自己本地的配置云同步到 GitHub"></a>配置同步：将自己本地的配置云同步到 GitHub</h2><ol>
<li><p>安装插件 settings-sync</p>
</li>
<li><p>安装完插件后，在插件里使用 GitHub 账号登录</p>
</li>
<li><p>登录后在 vscode 的界面中，可以选择一个别人的 gist；也可以忽略掉，然后创建一个属于自己的 gist</p>
</li>
<li><p>使用快捷键 「Command + Shift + P」，在弹出的命令框中输入 sync，并选择「更新/上传配置」，这样就可以把最新的配置上传到 GitHub</p>
<span id="more"></span>
<h2 id="管理同步：（换另外一个电脑时，从云端同步配置到本地）"><a href="#管理同步：（换另外一个电脑时，从云端同步配置到本地）" class="headerlink" title="管理同步：（换另外一个电脑时，从云端同步配置到本地）"></a>管理同步：（换另外一个电脑时，从云端同步配置到本地）</h2></li>
<li><p>当我们换另外一台电脑时，可以先在 VS Code 中安装 settings-sync 插件</p>
</li>
<li><p>安装完插件后，在插件里使用 GitHub 账号登录</p>
</li>
<li><p>登录之后，插件的界面上，会自动出现之前的同步记录：<br><img src="3c26e5a5e56f386ea70dafd7f60d5a822d9599946e1750b6b165739b797d969d.png" alt="图 5">  </p>
</li>
<li><p>上图中，我们点击最新的那条记录，就可将云端的最新配置同步到本地：<br><img src="a0101f018a94c658d2ecba2b99de840513e76f78fbfb401e4fde4f6cf4ffc564.png" alt="图 6">  </p>
</li>
<li><p>如果你远程的配置没有成功同步到本地，那可能是网络的问题，此时，可以使用快捷键 「Command + Shift + P」，在弹出的命令框中输入 sync，并选择「下载配置」，多试几次</p>
</li>
</ol>
<h2 id="使用其他人的配置"><a href="#使用其他人的配置" class="headerlink" title="使用其他人的配置"></a>使用其他人的配置</h2><p>如果我们想使用别人的配置，首先需要对方提供给你 gist。具体步骤如下：</p>
<ol>
<li>安装插件 settings-sync。</li>
<li>使用快捷键 「Command + Shift + P」，在弹出的命令框中输入 sync，并选择「下载配置」</li>
<li>在弹出的界面中，选择「Download Public Gist」，然后输入别人分享给你的 gist。注意，这一步不需要登录 GitHub 账号。</li>
</ol>
]]></content>
      <categories>
        <category>VSCODE</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode 中TODO的使用</title>
    <url>/2020/10/26/vscode-%E4%B8%ADTODO%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>关于在vscode中想标识一些未完成的事件。推荐大家一款非常方便的插件。<br>我们先打开vscode软件，先在扩展中搜索todo插件</p>
<span id="more"></span>
<h2 id="安装TODO-Highlight"><a href="#安装TODO-Highlight" class="headerlink" title="安装TODO Highlight"></a>安装TODO Highlight</h2><p><img src="b5946132aba47eef30b53a79429b8e2d90539f4f4b298baf3f09ca916a185297.png" alt="图 1">  </p>
<h2 id="安装Todo-Tree"><a href="#安装Todo-Tree" class="headerlink" title="安装Todo Tree"></a>安装Todo Tree</h2><p><img src="e405f7816e0ead47ca536f929fd270b28a66b3dd6761c07c93f4207d0716bb5b.png" alt="图 2">  </p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>点击侧边栏Todo Tree，如下图标<br><img src="909b7dbe5d928a5e8b6968c925a0f26b6ff34d8a9570391b56ac55a25b6f2b34.png" alt="图 3"><br>如下图，显示代办事项<br><img src="efe3b59a96b586c4615b98240218df831488f7b1121d4e660a706b782736fbb9.png" alt="图 4">  </p>
]]></content>
      <categories>
        <category>VSCODE</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux小工具</title>
    <url>/2020/10/25/Linux%E5%B0%8F%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="w"><a href="#w" class="headerlink" title="w"></a>w</h2><p>可以查看当前登陆系统的用户有哪些</p>
<span id="more"></span>
<h2 id="nmon"><a href="#nmon" class="headerlink" title="nmon"></a>nmon</h2><p>nmon 是一个可以监控当前系统性能的小工具， 可以查看网络、CPU、内存和磁盘的使用情况<br><a href="https://blog.csdn.net/qq_35304570/article/details/81351065">下载及安装地址</a><br><img src="7412cebccfaa9dcfcfb8949d91a8bc1c328a30575b5cb9a654df8f6128293eca.png" alt="图 1">  </p>
<ul>
<li>按键“c”可以查看CPU相 关信息;</li>
<li>“m”对应内存、“n”对应网络;</li>
<li>按键“d”可以查看磁盘信息;</li>
<li>按键“t”可以查看系统的进程信息，h是帮助等等；<br><img src="0f372c8376114a6a7d5b8f69a311381262922683addbd7b178d99cf8348df8ee.png" alt="图 2">  </li>
</ul>
<h2 id="ncdu"><a href="#ncdu" class="headerlink" title="ncdu"></a>ncdu</h2><p>ncdu 命令可以用来查看和分析 Linux 中各目录对磁盘空间占用情况的工具<br>执行 命令  ncdu /home/alipms</p>
<ul>
<li>分析完成后，会生成类似如下截图的输出。</li>
<li><a href="http://blog.51cto.com/daxionglaiba/1828379">下载及安装地址</a></li>
</ul>
<p> <img src="b0e3db3c71edf8969fc99b30c4d601ac3a5dfee64a7780247710c3ca70305811.png" alt="图 3">  </p>
<h2 id="findmnt"><a href="#findmnt" class="headerlink" title="findmnt"></a>findmnt</h2><p>是一个 Linux 内置的命令行工具，它主要用于查找挂载的文件系统状态。Findmnt 可以查看到当前系统中已挂载的设备，在必要时还可进行 mount 或 umount 操作<br><img src="89dcb4566e506c15bb4a169ae465f7bfe31ee003ac1df04c821b706fa362a42f.png" alt="图 4">  </p>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode使用md</title>
    <url>/2020/10/24/vscode%E4%BD%BF%E7%94%A8md/</url>
    <content><![CDATA[<h2 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h2><ul>
<li>MarkDown All in One</li>
<li>Markdown Preview Enhanced</li>
<li>markdown image</li>
</ul>
<h2 id="markdown语法"><a href="#markdown语法" class="headerlink" title="markdown语法"></a>markdown语法</h2><p><a href="https://www.appinn.com/markdown">参考</a></p>
<span id="more"></span>

<h2 id="生成目录"><a href="#生成目录" class="headerlink" title="生成目录"></a>生成目录</h2><p>F1 搜索 content</p>
<p><img src="53cdbbd9b4026329bccfa6d18d80f44c3bf78b30cc77235dfe944309fd7e1816.png" alt="图 1"></p>
<h2 id="插入表格"><a href="#插入表格" class="headerlink" title="插入表格"></a>插入表格</h2><p>创建表格：</p>
<p>使用html</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;<span class="built_in">tr</span>&gt;</span><br><span class="line">        &lt;th&gt;班级&lt;/th&gt;&lt;th&gt;课程&lt;/th&gt;&lt;th&gt;平均分&lt;/th&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;<span class="built_in">tr</span>&gt;</span><br><span class="line">        &lt;td rowspan=<span class="string">&quot;3&quot;</span> align=<span class="string">&quot;center&quot;</span>&gt;1班&lt;/td&gt;&lt;td&gt;语文&lt;/td&gt;&lt;td&gt;95&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;<span class="built_in">tr</span>&gt;</span><br><span class="line">        &lt;td&gt;数学&lt;/td&gt;&lt;td&gt;96&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;<span class="built_in">tr</span>&gt;</span><br><span class="line">        &lt;td&gt;英语&lt;/td&gt;&lt;td&gt;92&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;<span class="built_in">tr</span>&gt;</span><br><span class="line">        &lt;td colspan=<span class="string">&quot;3&quot;</span> align=<span class="string">&quot;center&quot;</span>&gt;1班&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>

<table>
    <tr>
        <th>班级</th><th>课程</th><th>平均分</th>
    </tr>
    <tr>
        <td rowspan="3" align="center">1班</td><td>语文</td><td>95</td>
    </tr>
    <tr>
        <td>数学</td><td>96</td>
    </tr>
    <tr>
        <td>英语</td><td>92</td>
    </tr>
    <tr>
        <td colspan="3" align="center">1班</td>
    </tr>
</table>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;table align=<span class="string">&quot;center&quot;</span>&gt;</span><br><span class="line">	&lt;tbody&gt;</span><br><span class="line">		&lt;<span class="built_in">tr</span>&gt;</span><br><span class="line">			&lt;th&gt;Cell 1x1&lt;/th&gt;</span><br><span class="line">			&lt;th&gt;Cell 2x1&lt;/th&gt;</span><br><span class="line">			&lt;th&gt;Cell 3x1&lt;/th&gt;</span><br><span class="line">		&lt;/tr&gt;</span><br><span class="line">		&lt;<span class="built_in">tr</span>&gt;</span><br><span class="line">			&lt;td&gt;Cell 1x2&lt;/td&gt;</span><br><span class="line">			&lt;td&gt;Cell 2x2&lt;/td&gt;</span><br><span class="line">			&lt;td&gt;Cell 3x2&lt;/td&gt;</span><br><span class="line">		&lt;/tr&gt;</span><br><span class="line">	&lt;/tbody&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>
<table align="center">
    <tbody>
        <tr>
            <th>Cell 1x1</th>
            <th>Cell 2x1</th>
            <th>Cell 3x1</th>
        </tr>
        <tr>
            <td>Cell 1x2</td>
            <td>Cell 2x2</td>
            <td>Cell 3x2</td>
        </tr>
    </tbody>
</table>

<h2 id="水平线"><a href="#水平线" class="headerlink" title="水平线"></a>水平线</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br></pre></td></tr></table></figure>
<hr>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">___</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">**This is bold text**</span><br><span class="line"></span><br><span class="line">__This is bold text__</span><br><span class="line"></span><br><span class="line">*This is italic text*</span><br><span class="line"></span><br><span class="line">_This is italic text_</span><br><span class="line"></span><br><span class="line">~~Strikethrough~~</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><strong>This is bold text</strong></p>
<p><strong>This is bold text</strong></p>
<p><em>This is italic text</em></p>
<p><em>This is italic text</em></p>
<p><del>Strikethrough</del></p>
<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>开头使用```bash/python/c/c++/go</p>
<p>结尾使用```</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$i</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="type">int</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">a := <span class="number">0</span></span><br><span class="line">b := <span class="keyword">map</span>()</span><br></pre></td></tr></table></figure>

<h2 id="行内代码"><a href="#行内代码" class="headerlink" title="行内代码"></a>行内代码</h2><p>正文中的代码 <code>uname -a</code></p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>输入数字，加一个句点，然后空格即可</p>
<ol>
<li>列表1</li>
<li>列表2</li>
<li>列表3</li>
</ol>
<h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>输入 - ,然后空格</p>
<ul>
<li>列表1</li>
<li>列表2</li>
<li>列表3</li>
</ul>
]]></content>
      <categories>
        <category>VSCODE</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode常用插件和设置</title>
    <url>/2020/10/24/vscode%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%92%8C%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p><strong>说明</strong>：插件并非全局生效，有的插件需要在wsl/ssh中另装</p>
<span id="more"></span>
<h3 id="语言插件"><a href="#语言插件" class="headerlink" title="语言插件"></a>语言插件</h3><ol>
<li><p>c/c++<br>C/C++ Extension Pack</p>
</li>
<li><p>shell<br>补全： shellman<br>格式化： shell-format、手动下载shfmt_v3.3.1_linux_amd64</p>
</li>
<li><p>go<br>go<br>安装go Install/Update Tools<br><img src="a96b3fea0c6428186f35e1214660ae10b9e2e7ecdef2d20a291c957da4e0b040.png" alt="图 10">  </p>
</li>
</ol>
<ol start="4">
<li>python<br>Python</li>
</ol>
<h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><p>Git History<br>compareit</p>
<h3 id="远程"><a href="#远程" class="headerlink" title="远程"></a>远程</h3><p>Remote - SSH<br>WSL</p>
<h3 id="md"><a href="#md" class="headerlink" title="md"></a>md</h3><p>MarkDown All in One<br>Markdown Preview Enhanced<br>markdown image</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>高亮：highlight-words<br>大纲：Outline Map<br>待办：Todo Tree<br>统计：VS Code Counter</p>
<h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><p><strong>说明</strong>：全局生效</p>
<h3 id="搜索内容不全"><a href="#搜索内容不全" class="headerlink" title="搜索内容不全"></a>搜索内容不全</h3><p>设置，搜索Use Ignore Files，取消勾选，重载vscode</p>
<h3 id="光标离开后保存文件"><a href="#光标离开后保存文件" class="headerlink" title="光标离开后保存文件"></a>光标离开后保存文件</h3><p>设置搜索auto save，选择onFocusChange<br><img src="e8ef5767321296703101e079e053c385ae44d2b408447dd6b8fc0a260dd8a216.png" alt="图 5">  </p>
<h3 id="大小写转换快捷键"><a href="#大小写转换快捷键" class="headerlink" title="大小写转换快捷键"></a>大小写转换快捷键</h3><p>键盘快捷方式，搜索 转换为大写， 设置快捷键ctrl+shift+u<br>搜索 转换为小写， 设置快捷键ctrl+shift+l，需要先清除前面两个绑定的快捷键</p>
<h3 id="前进-后退快捷键"><a href="#前进-后退快捷键" class="headerlink" title="前进/后退快捷键"></a>前进/后退快捷键</h3><p>键盘快捷方式中搜索navigateBack navigateForward<br>设置喜欢的快捷键，我的是alt+,  alt+.</p>
<h3 id="选中即复制、右键粘贴"><a href="#选中即复制、右键粘贴" class="headerlink" title="选中即复制、右键粘贴"></a>选中即复制、右键粘贴</h3><p>设置中搜索copy on，勾选<br><img src="28523ce1b944f8a23f668683b9dc8a66069bd75b34cc3bda158e476d47524e79.png" alt="图 2"><br>设置中搜索right click，下拉选择 paste<br><img src="8d1fc2b3862c7e21a286a7e96eaa8c79ac2d0b2295c662a5d2d43453140e8b55.png" alt="图 3">  </p>
<h3 id="markdown背景设置"><a href="#markdown背景设置" class="headerlink" title="markdown背景设置"></a>markdown背景设置</h3><p>点击vscode左下角的设置图标，打开vscode设置，在搜索框输入：markdown preview enhanced: Preview theme。结果如下图：<br><img src="5ec0e46c9b911ce4ea30f5d9bb1806c0b42ce509ce6b161540642d0b0c6b8d0f.png" alt="图 1">  </p>
<h3 id="高亮设置"><a href="#高亮设置" class="headerlink" title="高亮设置"></a>高亮设置</h3><p>键盘快捷方式中搜索Highlight Toggle Current<br>设置，我的是f8，不过事先要将之前f8绑定的快捷键删除</p>
<h3 id="显示tab"><a href="#显示tab" class="headerlink" title="显示tab"></a>显示tab</h3><p>设置，搜索renderWhitespace，下拉选择 all<br><img src="50e58a623395a9a3ae4f278c46176634779d61888c03b805ec7562218aea8557.png" alt="图 4">  </p>
<h3 id="设置删除一行的快捷"><a href="#设置删除一行的快捷" class="headerlink" title="设置删除一行的快捷"></a>设置删除一行的快捷</h3><p>键盘快捷方式中搜索ctrl+shift+K，<br>设置为ctrl+d</p>
<h3 id="键盘快捷取消ctrl-e"><a href="#键盘快捷取消ctrl-e" class="headerlink" title="键盘快捷取消ctrl+e"></a>键盘快捷取消ctrl+e</h3><p>键盘快捷方式中搜索ctrl+e，取消绑定</p>
<h3 id="复制代码取消背景色"><a href="#复制代码取消背景色" class="headerlink" title="复制代码取消背景色"></a>复制代码取消背景色</h3><p>设置，搜索Copy With Syntax，勾选去掉<br><img src="24e867e238923100c37ebae65f55ef5301fcafda24675ce4016f040c4bf93c0c.png" alt="图 10">  </p>
<h3 id="统计代码行"><a href="#统计代码行" class="headerlink" title="统计代码行"></a>统计代码行</h3><p>F1 在命令输入：Count lines in workspace<br><strong>注意</strong>：建议在Windows端统计，wsl统计偶现失效<br>基于语言统计：<br><img src="ab7b6207d4ee44ebcf7271f0da0a23daec2924a62269b2e576a68ee640d69832.png" alt="图 9">  </p>
<p>基于文件夹统计：<br><img src="b5af3d8e63a050ae2c42f4371bcafca762df22d8167e8a2284b05a32f4026d78.png" alt="图 8">  </p>
]]></content>
      <categories>
        <category>VSCODE</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>vscode配置ssh</title>
    <url>/2020/10/24/vscode%E9%85%8D%E7%BD%AEssh/</url>
    <content><![CDATA[<h2 id="本机安装ssh"><a href="#本机安装ssh" class="headerlink" title="本机安装ssh"></a>本机安装ssh</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>可以使用 Windows Server 2019 和 Windows 10 设备上的 Windows 设置安装这两个 OpenSSH 组件。<br>若要安装 OpenSSH 组件：</p>
<ol>
<li>打开“设置”，选择“应用”&gt;“应用和功能”，然后选择“可选功能” 。</li>
<li>扫描列表，查看是否已安装 OpenSSH。 如果未安装，请在页面顶部选择“添加功能”，然后：</li>
</ol>
<span id="more"></span>
<ul>
<li>查找“OpenSSH 客户端”，再单击“安装”</li>
<li>查找“OpenSSH 服务器”，再单击“安装”</li>
</ul>
<p>设置完成后，回到“应用”&gt;“应用和功能”和“可选功能”，你应会看到已列出 OpenSSH<br><a href="https://learn.microsoft.com/zh-cn/windows-server/administration/openssh/openssh_install_firstuse">参考</a></p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh 或者 ssh-V</span><br></pre></td></tr></table></figure>
<h2 id="vscode安装Remote-SSH插件"><a href="#vscode安装Remote-SSH插件" class="headerlink" title="vscode安装Remote - SSH插件"></a>vscode安装Remote - SSH插件</h2><h3 id="免密登录配置"><a href="#免密登录配置" class="headerlink" title="免密登录配置"></a>免密登录配置</h3><ol>
<li><p>生成密钥对</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> C:\Users\&lt;user&gt;\.ssh</span><br><span class="line">ssh-keygen -t rsa -b 4096 -f id_rsa-remote-ssh</span><br></pre></td></tr></table></figure>
<p><img src="a67dc3712e025e8a68a003a9ab10c3a6aa362c72517926f5995162f80330d08b.png" alt="图 1">  </p>
</li>
<li><p>公钥拷贝<br>将本机的id_rsa-remote-ssh.pub拷贝到目标服务器上/root/.ssh/authorized_keys中</p>
</li>
<li><p>vscode上配置私钥<br><img src="bfeb91acdcb2cabf3a2e0c4d688410253087d5995cfe032cc96b59a56627bc0e.png" alt="图 2"><br><img src="cf206f6a63f0e331b2f3d9294e2536055e4a9cf16912421f481ccfd3f7ce1a70.png" alt="图 3"></p>
</li>
</ol>
<p><strong>注意</strong>：<br>配置后，需要reload vscode，才会出现目标服务器的选项</p>
]]></content>
      <categories>
        <category>VSCODE</category>
      </categories>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo Next主题中文Toc无法展开</title>
    <url>/2020/10/03/Hexo%20Next%E4%B8%BB%E9%A2%98%E4%B8%AD%E6%96%87Toc%E6%97%A0%E6%B3%95%E5%B1%95%E5%BC%80/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>如下图，当编辑多级标题时，在主页的侧边栏无法显示完全</p>
<span id="more"></span>
<p><img src="edd95282baee44c9f19d0e60498dca2126541ae7233bcfd8a70177864391a72d.png" alt="图 19">  </p>
<h2 id="问题修复"><a href="#问题修复" class="headerlink" title="问题修复"></a>问题修复</h2><p>在themes\next\source\css_custom\custom.styl文件中添加</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">.post-toc .nav .nav-child &#123;</span><br><span class="line">   display: block;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>HEXO</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>hexo故障修复</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo Next主题中文Toc无法跳转</title>
    <url>/2020/10/03/Hexo%20Next%E4%B8%BB%E9%A2%98%E4%B8%AD%E6%96%87Toc%E6%97%A0%E6%B3%95%E8%B7%B3%E8%BD%AC/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>安装 Next 主题后, 侧边栏目录中中文目录锚点点击后无法正常跳转</p>
<span id="more"></span>
<h2 id="故障描述"><a href="#故障描述" class="headerlink" title="故障描述"></a>故障描述</h2><p>如图，点击左边侧边栏无法正常跳转<br><img src="74e496c94572c1caef9b9e5f6fc755161b3fbb628194a8299880617fc7f643ee.png" alt="图 18">  </p>
<h2 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h2><p>知道是 ‘post-details.js’ 文件报错后就简单了. 阅读源码后我们发现是 targetSelector 解析 UTF8 有问题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// TOC item animation navigate &amp; prevent <span class="comment">#item selector in adress bar.</span></span><br><span class="line">$(<span class="string">&#x27;.post-toc a&#x27;</span>).on(<span class="string">&#x27;click&#x27;</span>, <span class="keyword">function</span> (e) &#123;</span><br><span class="line">  e.preventDefault();</span><br><span class="line">  &lt;!-- targetSelector 解析UTF8的问题 -&gt;</span><br><span class="line">  var targetSelector = NexT.utils.escapeSelector(this.getAttribute(<span class="string">&#x27;href&#x27;</span>));</span><br><span class="line">  var offset = $(targetSelector).offset().top;</span><br><span class="line"></span><br><span class="line">  hasVelocity ?</span><br><span class="line">    html.velocity(<span class="string">&#x27;stop&#x27;</span>).velocity(<span class="string">&#x27;scroll&#x27;</span>, &#123;</span><br><span class="line">      offset: offset  + <span class="string">&#x27;px&#x27;</span>,</span><br><span class="line">      mobileHA: <span class="literal">false</span></span><br><span class="line">    &#125;) :</span><br><span class="line">    $(<span class="string">&#x27;html, body&#x27;</span>).stop().animate(&#123;</span><br><span class="line">      scrollTop: offset</span><br><span class="line">    &#125;, 500);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="问题修复"><a href="#问题修复" class="headerlink" title="问题修复"></a>问题修复</h2><p>将 targetSelector 再解析一次就好了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var targetSelector = NexT.utils.escapeSelector(this.getAttribute(<span class="string">&#x27;href&#x27;</span>));</span><br><span class="line">&lt;!-- 添加下面这行代码, 重新解析 URL -&gt;</span><br><span class="line">targetSelector = decodeURI(this.getAttribute(<span class="string">&#x27;href&#x27;</span>))</span><br><span class="line">var offset = $(targetSelector).offset().top;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>HEXO</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>hexo故障修复</tag>
      </tags>
  </entry>
  <entry>
    <title>readelf</title>
    <url>/2020/09/26/readelf/</url>
    <content><![CDATA[<h2 id="readelf-elf文件格式分析"><a href="#readelf-elf文件格式分析" class="headerlink" title="readelf elf文件格式分析"></a>readelf elf文件格式分析</h2><p>这个工具和objdump命令提供的功能类似，但是它显示的信息更为具体，并且它不依赖BFD库(BFD库是一个GNU项目，它的目标就是希望通过一种统一的接口来处理不同的目标文件）</p>
<span id="more"></span>

<h2 id="ELF文件类型"><a href="#ELF文件类型" class="headerlink" title="ELF文件类型"></a>ELF文件类型</h2><p>ELF(Executable and Linking Format)是一种对象文件的格式，用于定义不同类型的对象文件(Object files)中都放了什么东西、以及都以什么样的格式去放这些东西。它自最早在 System V 系统上出现后，被 xNIX 世界所广泛接受，作为缺省的二进制文件格式来使用。可以说，ELF是构成众多xNIX系统的基础之一。<br>ELF文件有三种类型：</p>
<ol>
<li>可重定位的对象文件(Relocatable file)<br>由汇编器汇编生成的 .o 文件</li>
<li>可执行的对象文件(Executable file)<br>可执行应用程序</li>
<li>可被共享的对象文件(Shared object file)<br>动态库文件，也即 .so 文件</li>
</ol>
<ul>
<li>.text section 里装载了可执行代码；</li>
<li>.data section 里面装载了被初始化的数据；</li>
<li>.bss section 里面装载了未被初始化的数据；</li>
<li>以 .rec 打头的 sections 里面装载了重定位条目；</li>
<li>.symtab 或者 .dynsym section 里面装载了符号信息；</li>
<li>.strtab 或者 .dynstr section 里面装载了字符串信息；</li>
</ul>
<h2 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h2><p><code>-a –all</code> 全部 Equivalent to: -h -l -S -s -r -d -V -A -I<br><code>-h –file-header</code> 文件头 Display the ELF file header<br><code>-l –program-headers</code> 程序 Display the program headers<br><code>–segments</code> An alias for –program-headers<br><code>-S –section-headers</code> 段头 Display the sections’ header<br><code>--sections    </code> An alias for –section-headers<br><code>-e –headers</code> 全部头 Equivalent to: -h -l -S<br><code>-s –syms</code> 符号表 Display the symbol table<br><code>--symbols</code>    An alias for –syms<br><code>-n –notes</code> 内核注释 Display the core notes (if present)<br><code>-r –relocs</code> 重定位 Display the relocations (if present)<br><code>-u –unwind</code> Display the unwind info (if present)<br><code>-d –dynamic</code> 动态段 Display the dynamic segment (if present)<br><code>-V –version-info</code> 版本 Display the version sections (if present)<br><code>-A –arch-specific</code> CPU构架 Display architecture specific information (if any).<br><code>-D –use-dynamic</code> 动态段 Use the dynamic section info when displaying symbols<br><code>-x –hex-dump=&lt;number&gt;</code> 显示 段内内容Dump the contents of section <number><br><code>-w[liaprmfFso] or -I</code> –histogram Display histogram of bucket list lengths<br><code>-W –wide</code> 宽行输出 Allow output width to exceed 80 characters<br><code>-H –help</code> Display this information<br><code>-v –version</code> Display the version number of readelf</number></p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>想知道一个应用程序的可运行的架构平台:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$readelf</span> -h main| grep Machine</span><br></pre></td></tr></table></figure>
<p><code>-h</code>选项将显示文件头的概要信息，从里面可以看到，有很多有用的信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$readelf</span> -h main</span><br><span class="line">ELF Header:</span><br><span class="line">Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">Class:                             ELF64</span><br><span class="line">Data:                              2 s complement, little endian</span><br><span class="line">Version:                           1 (current)</span><br><span class="line">OS/ABI:                            UNIX - System V</span><br><span class="line">ABI Version:                       0</span><br><span class="line">Type:                              EXEC (Executable file)</span><br><span class="line">Machine:                           Advanced Micro Devices X86-64</span><br><span class="line">Version:                           0x1</span><br><span class="line">Entry point address:               0x400790</span><br><span class="line">Start of program headers:          64 (bytes into file)</span><br><span class="line">Start of section headers:          5224 (bytes into file)</span><br><span class="line">Flags:                             0x0</span><br><span class="line">Size of this header:               64 (bytes)</span><br><span class="line">Size of program headers:           56 (bytes)</span><br><span class="line">Number of program headers:         8</span><br><span class="line">Size of section headers:           64 (bytes)</span><br><span class="line">Number of section headers:         29</span><br><span class="line">Section header string table index: 26</span><br></pre></td></tr></table></figure>
<p>一个编译好的应用程序，想知道其编译时是否使用了-g选项（加入调试信息）:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$readelf</span> -S main| grep debug</span><br></pre></td></tr></table></figure>
<p>用-S选项是显示所有段信息；如果编译时使用了-g选项，则会有debug段;<br>未加-g时无显示<br><img src="e35e573e40be9d30fecfdc25520c6e2fb432d3c323ed63b48ad6e9754c5195b1.png" alt="图 1">  </p>
<p>添加-g时显示debug段信息<br><img src="a872fe53b83a036ba82fdb125de153f252467a30db81143bf18c496e386ff910.png" alt="图 2">  </p>
<p>查看.o文件是否编入了调试信息（编译的时候是否加了-g):</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$readelf</span> -S Shpos.o | grep debug</span><br></pre></td></tr></table></figure>

<h2 id="完整输出"><a href="#完整输出" class="headerlink" title="完整输出"></a>完整输出</h2><p>readelf输出的完整内容:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$readelf</span> -all a.out</span><br><span class="line">ELF Header:</span><br><span class="line">  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00</span><br><span class="line">  Class:                             ELF32</span><br><span class="line">  Data:                              2<span class="string">&#x27;s complement, little endian</span></span><br><span class="line"><span class="string">  Version:                           1 (current)</span></span><br><span class="line"><span class="string">  OS/ABI:                            UNIX - System V</span></span><br><span class="line"><span class="string">  ABI Version:                       0</span></span><br><span class="line"><span class="string">  Type:                              EXEC (Executable file)</span></span><br><span class="line"><span class="string">  Machine:                           Intel 80386</span></span><br><span class="line"><span class="string">  Version:                           0x1</span></span><br><span class="line"><span class="string">  Entry point address:               0x8048330</span></span><br><span class="line"><span class="string">  Start of program headers:          52 (bytes into file)</span></span><br><span class="line"><span class="string">  Start of section headers:          4412 (bytes into file)</span></span><br><span class="line"><span class="string">  Flags:                             0x0</span></span><br><span class="line"><span class="string">  Size of this header:               52 (bytes)</span></span><br><span class="line"><span class="string">  Size of program headers:           32 (bytes)</span></span><br><span class="line"><span class="string">  Number of program headers:         9</span></span><br><span class="line"><span class="string">  Size of section headers:           40 (bytes)</span></span><br><span class="line"><span class="string">  Number of section headers:         30</span></span><br><span class="line"><span class="string">  Section header string table index: 27</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Section Headers:</span></span><br><span class="line"><span class="string">  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al</span></span><br><span class="line"><span class="string">  [ 0]                   NULL            00000000 000000 000000 00      0   0  0</span></span><br><span class="line"><span class="string">  [ 1] .interp           PROGBITS        08048154 000154 000013 00   A  0   0  1</span></span><br><span class="line"><span class="string">  [ 2] .note.ABI-tag     NOTE            08048168 000168 000020 00   A  0   0  4</span></span><br><span class="line"><span class="string">  [ 3] .note.gnu.build-i NOTE            08048188 000188 000024 00   A  0   0  4</span></span><br><span class="line"><span class="string">  [ 4] .gnu.hash         GNU_HASH        080481ac 0001ac 000020 04   A  5   0  4</span></span><br><span class="line"><span class="string">  [ 5] .dynsym           DYNSYM          080481cc 0001cc 000050 10   A  6   1  4</span></span><br><span class="line"><span class="string">  [ 6] .dynstr           STRTAB          0804821c 00021c 00004c 00   A  0   0  1</span></span><br><span class="line"><span class="string">  [ 7] .gnu.version      VERSYM          08048268 000268 00000a 02   A  5   0  2</span></span><br><span class="line"><span class="string">  [ 8] .gnu.version_r    VERNEED         08048274 000274 000020 00   A  6   1  4</span></span><br><span class="line"><span class="string">  [ 9] .rel.dyn          REL             08048294 000294 000008 08   A  5   0  4</span></span><br><span class="line"><span class="string">  [10] .rel.plt          REL             0804829c 00029c 000018 08   A  5  12  4</span></span><br><span class="line"><span class="string">  [11] .init             PROGBITS        080482b4 0002b4 00002e 00  AX  0   0  4</span></span><br><span class="line"><span class="string">  [12] .plt              PROGBITS        080482f0 0002f0 000040 04  AX  0   0 16</span></span><br><span class="line"><span class="string">  [13] .text             PROGBITS        08048330 000330 00018c 00  AX  0   0 16</span></span><br><span class="line"><span class="string">  [14] .fini             PROGBITS        080484bc 0004bc 00001a 00  AX  0   0  4</span></span><br><span class="line"><span class="string">  [15] .rodata           PROGBITS        080484d8 0004d8 000011 00   A  0   0  4</span></span><br><span class="line"><span class="string">  [16] .eh_frame_hdr     PROGBITS        080484ec 0004ec 000034 00   A  0   0  4</span></span><br><span class="line"><span class="string">  [17] .eh_frame         PROGBITS        08048520 000520 0000c4 00   A  0   0  4</span></span><br><span class="line"><span class="string">  [18] .ctors            PROGBITS        08049f14 000f14 000008 00  WA  0   0  4</span></span><br><span class="line"><span class="string">  [19] .dtors            PROGBITS        08049f1c 000f1c 000008 00  WA  0   0  4</span></span><br><span class="line"><span class="string">  [20] .jcr              PROGBITS        08049f24 000f24 000004 00  WA  0   0  4</span></span><br><span class="line"><span class="string">  [21] .dynamic          DYNAMIC         08049f28 000f28 0000c8 08  WA  6   0  4</span></span><br><span class="line"><span class="string">  [22] .got              PROGBITS        08049ff0 000ff0 000004 04  WA  0   0  4</span></span><br><span class="line"><span class="string">  [23] .got.plt          PROGBITS        08049ff4 000ff4 000018 04  WA  0   0  4</span></span><br><span class="line"><span class="string">  [24] .data             PROGBITS        0804a00c 00100c 000008 00  WA  0   0  4</span></span><br><span class="line"><span class="string">  [25] .bss              NOBITS          0804a014 001014 000008 00  WA  0   0  4</span></span><br><span class="line"><span class="string">  [26] .comment          PROGBITS        00000000 001014 00002a 01  MS  0   0  1</span></span><br><span class="line"><span class="string">  [27] .shstrtab         STRTAB          00000000 00103e 0000fc 00      0   0  1</span></span><br><span class="line"><span class="string">  [28] .symtab           SYMTAB          00000000 0015ec 000410 10     29  45  4</span></span><br><span class="line"><span class="string">  [29] .strtab           STRTAB          00000000 0019fc 0001f9 00      0   0  1</span></span><br><span class="line"><span class="string">Key to Flags:</span></span><br><span class="line"><span class="string">  W (write), A (alloc), X (execute), M (merge), S (strings)</span></span><br><span class="line"><span class="string">  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)</span></span><br><span class="line"><span class="string">  O (extra OS processing required) o (OS specific), p (processor specific)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">There are no section groups in this file.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Program Headers:</span></span><br><span class="line"><span class="string">  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align</span></span><br><span class="line"><span class="string">  PHDR           0x000034 0x08048034 0x08048034 0x00120 0x00120 R E 0x4</span></span><br><span class="line"><span class="string">  INTERP         0x000154 0x08048154 0x08048154 0x00013 0x00013 R   0x1</span></span><br><span class="line"><span class="string">      [Requesting program interpreter: /lib/ld-linux.so.2]</span></span><br><span class="line"><span class="string">  LOAD           0x000000 0x08048000 0x08048000 0x005e4 0x005e4 R E 0x1000</span></span><br><span class="line"><span class="string">  LOAD           0x000f14 0x08049f14 0x08049f14 0x00100 0x00108 RW  0x1000</span></span><br><span class="line"><span class="string">  DYNAMIC        0x000f28 0x08049f28 0x08049f28 0x000c8 0x000c8 RW  0x4</span></span><br><span class="line"><span class="string">  NOTE           0x000168 0x08048168 0x08048168 0x00044 0x00044 R   0x4</span></span><br><span class="line"><span class="string">  GNU_EH_FRAME   0x0004ec 0x080484ec 0x080484ec 0x00034 0x00034 R   0x4</span></span><br><span class="line"><span class="string">  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x4</span></span><br><span class="line"><span class="string">  GNU_RELRO      0x000f14 0x08049f14 0x08049f14 0x000ec 0x000ec R   0x1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> Section to Segment mapping:</span></span><br><span class="line"><span class="string">  Segment Sections...</span></span><br><span class="line"><span class="string">   00</span></span><br><span class="line"><span class="string">   01     .interp</span></span><br><span class="line"><span class="string">   02     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .text .fini .rodata .eh_frame_hdr .eh_frame</span></span><br><span class="line"><span class="string">   03     .ctors .dtors .jcr .dynamic .got .got.plt .data .bss</span></span><br><span class="line"><span class="string">   04     .dynamic</span></span><br><span class="line"><span class="string">   05     .note.ABI-tag .note.gnu.build-id</span></span><br><span class="line"><span class="string">   06     .eh_frame_hdr</span></span><br><span class="line"><span class="string">   07</span></span><br><span class="line"><span class="string">   08     .ctors .dtors .jcr .dynamic .got</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Dynamic section at offset 0xf28 contains 20 entries:</span></span><br><span class="line"><span class="string">  Tag        Type                         Name/Value</span></span><br><span class="line"><span class="string"> 0x00000001 (NEEDED)                     Shared library: [libc.so.6]</span></span><br><span class="line"><span class="string"> 0x0000000c (INIT)                       0x80482b4</span></span><br><span class="line"><span class="string"> 0x0000000d (FINI)                       0x80484bc</span></span><br><span class="line"><span class="string"> 0x6ffffef5 (GNU_HASH)                   0x80481ac</span></span><br><span class="line"><span class="string"> 0x00000005 (STRTAB)                     0x804821c</span></span><br><span class="line"><span class="string"> 0x00000006 (SYMTAB)                     0x80481cc</span></span><br><span class="line"><span class="string"> 0x0000000a (STRSZ)                      76 (bytes)</span></span><br><span class="line"><span class="string"> 0x0000000b (SYMENT)                     16 (bytes)</span></span><br><span class="line"><span class="string"> 0x00000015 (DEBUG)                      0x0</span></span><br><span class="line"><span class="string"> 0x00000003 (PLTGOT)                     0x8049ff4</span></span><br><span class="line"><span class="string"> 0x00000002 (PLTRELSZ)                   24 (bytes)</span></span><br><span class="line"><span class="string"> 0x00000014 (PLTREL)                     REL</span></span><br><span class="line"><span class="string"> 0x00000017 (JMPREL)                     0x804829c</span></span><br><span class="line"><span class="string"> 0x00000011 (REL)                        0x8048294</span></span><br><span class="line"><span class="string"> 0x00000012 (RELSZ)                      8 (bytes)</span></span><br><span class="line"><span class="string"> 0x00000013 (RELENT)                     8 (bytes)</span></span><br><span class="line"><span class="string"> 0x6ffffffe (VERNEED)                    0x8048274</span></span><br><span class="line"><span class="string"> 0x6fffffff (VERNEEDNUM)                 1</span></span><br><span class="line"><span class="string"> 0x6ffffff0 (VERSYM)                     0x8048268</span></span><br><span class="line"><span class="string"> 0x00000000 (NULL)                       0x0</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Relocation section &#x27;</span>.rel.dyn<span class="string">&#x27; at offset 0x294 contains 1 entries:</span></span><br><span class="line"><span class="string"> Offset     Info    Type            Sym.Value  Sym. Name</span></span><br><span class="line"><span class="string">08049ff0  00000206 R_386_GLOB_DAT    00000000   __gmon_start__</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Relocation section &#x27;</span>.rel.plt<span class="string">&#x27; at offset 0x29c contains 3 entries:</span></span><br><span class="line"><span class="string"> Offset     Info    Type            Sym.Value  Sym. Name</span></span><br><span class="line"><span class="string">0804a000  00000107 R_386_JUMP_SLOT   00000000   printf</span></span><br><span class="line"><span class="string">0804a004  00000207 R_386_JUMP_SLOT   00000000   __gmon_start__</span></span><br><span class="line"><span class="string">0804a008  00000307 R_386_JUMP_SLOT   00000000   __libc_start_main</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">There are no unwind sections in this file.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Symbol table &#x27;</span>.dynsym<span class="string">&#x27; contains 5 entries:</span></span><br><span class="line"><span class="string">   Num:    Value  Size Type    Bind   Vis      Ndx Name</span></span><br><span class="line"><span class="string">     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND</span></span><br><span class="line"><span class="string">     1: 00000000     0 FUNC    GLOBAL DEFAULT  UND printf@GLIBC_2.0 (2)</span></span><br><span class="line"><span class="string">     2: 00000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__</span></span><br><span class="line"><span class="string">     3: 00000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2.0 (2)</span></span><br><span class="line"><span class="string">     4: 080484dc     4 OBJECT  GLOBAL DEFAULT   15 _IO_stdin_used</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Symbol table &#x27;</span>.symtab<span class="string">&#x27; contains 65 entries:</span></span><br><span class="line"><span class="string">   Num:    Value  Size Type    Bind   Vis      Ndx Name</span></span><br><span class="line"><span class="string">     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND</span></span><br><span class="line"><span class="string">     1: 08048154     0 SECTION LOCAL  DEFAULT    1</span></span><br><span class="line"><span class="string">     2: 08048168     0 SECTION LOCAL  DEFAULT    2</span></span><br><span class="line"><span class="string">     3: 08048188     0 SECTION LOCAL  DEFAULT    3</span></span><br><span class="line"><span class="string">     4: 080481ac     0 SECTION LOCAL  DEFAULT    4</span></span><br><span class="line"><span class="string">     5: 080481cc     0 SECTION LOCAL  DEFAULT    5</span></span><br><span class="line"><span class="string">     6: 0804821c     0 SECTION LOCAL  DEFAULT    6</span></span><br><span class="line"><span class="string">     7: 08048268     0 SECTION LOCAL  DEFAULT    7</span></span><br><span class="line"><span class="string">     8: 08048274     0 SECTION LOCAL  DEFAULT    8</span></span><br><span class="line"><span class="string">     9: 08048294     0 SECTION LOCAL  DEFAULT    9</span></span><br><span class="line"><span class="string">    10: 0804829c     0 SECTION LOCAL  DEFAULT   10</span></span><br><span class="line"><span class="string">    11: 080482b4     0 SECTION LOCAL  DEFAULT   11</span></span><br><span class="line"><span class="string">    12: 080482f0     0 SECTION LOCAL  DEFAULT   12</span></span><br><span class="line"><span class="string">    13: 08048330     0 SECTION LOCAL  DEFAULT   13</span></span><br><span class="line"><span class="string">    14: 080484bc     0 SECTION LOCAL  DEFAULT   14</span></span><br><span class="line"><span class="string">    15: 080484d8     0 SECTION LOCAL  DEFAULT   15</span></span><br><span class="line"><span class="string">    16: 080484ec     0 SECTION LOCAL  DEFAULT   16</span></span><br><span class="line"><span class="string">    17: 08048520     0 SECTION LOCAL  DEFAULT   17</span></span><br><span class="line"><span class="string">    18: 08049f14     0 SECTION LOCAL  DEFAULT   18</span></span><br><span class="line"><span class="string">    19: 08049f1c     0 SECTION LOCAL  DEFAULT   19</span></span><br><span class="line"><span class="string">    20: 08049f24     0 SECTION LOCAL  DEFAULT   20</span></span><br><span class="line"><span class="string">    21: 08049f28     0 SECTION LOCAL  DEFAULT   21</span></span><br><span class="line"><span class="string">    22: 08049ff0     0 SECTION LOCAL  DEFAULT   22</span></span><br><span class="line"><span class="string">    23: 08049ff4     0 SECTION LOCAL  DEFAULT   23</span></span><br><span class="line"><span class="string">    24: 0804a00c     0 SECTION LOCAL  DEFAULT   24</span></span><br><span class="line"><span class="string">    25: 0804a014     0 SECTION LOCAL  DEFAULT   25</span></span><br><span class="line"><span class="string">    26: 00000000     0 SECTION LOCAL  DEFAULT   26</span></span><br><span class="line"><span class="string">    27: 00000000     0 FILE    LOCAL  DEFAULT  ABS crtstuff.c</span></span><br><span class="line"><span class="string">    28: 08049f14     0 OBJECT  LOCAL  DEFAULT   18 __CTOR_LIST__</span></span><br><span class="line"><span class="string">    29: 08049f1c     0 OBJECT  LOCAL  DEFAULT   19 __DTOR_LIST__</span></span><br><span class="line"><span class="string">    30: 08049f24     0 OBJECT  LOCAL  DEFAULT   20 __JCR_LIST__</span></span><br><span class="line"><span class="string">    31: 08048360     0 FUNC    LOCAL  DEFAULT   13 __do_global_dtors_aux</span></span><br><span class="line"><span class="string">    32: 0804a014     1 OBJECT  LOCAL  DEFAULT   25 completed.6086</span></span><br><span class="line"><span class="string">    33: 0804a018     4 OBJECT  LOCAL  DEFAULT   25 dtor_idx.6088</span></span><br><span class="line"><span class="string">    34: 080483c0     0 FUNC    LOCAL  DEFAULT   13 frame_dummy</span></span><br><span class="line"><span class="string">    35: 00000000     0 FILE    LOCAL  DEFAULT  ABS crtstuff.c</span></span><br><span class="line"><span class="string">    36: 08049f18     0 OBJECT  LOCAL  DEFAULT   18 __CTOR_END__</span></span><br><span class="line"><span class="string">    37: 080485e0     0 OBJECT  LOCAL  DEFAULT   17 __FRAME_END__</span></span><br><span class="line"><span class="string">    38: 08049f24     0 OBJECT  LOCAL  DEFAULT   20 __JCR_END__</span></span><br><span class="line"><span class="string">    39: 08048490     0 FUNC    LOCAL  DEFAULT   13 __do_global_ctors_aux</span></span><br><span class="line"><span class="string">    40: 00000000     0 FILE    LOCAL  DEFAULT  ABS a.c</span></span><br><span class="line"><span class="string">    41: 08049f14     0 NOTYPE  LOCAL  DEFAULT   18 __init_array_end</span></span><br><span class="line"><span class="string">    42: 08049f28     0 OBJECT  LOCAL  DEFAULT   21 _DYNAMIC</span></span><br><span class="line"><span class="string">    43: 08049f14     0 NOTYPE  LOCAL  DEFAULT   18 __init_array_start</span></span><br><span class="line"><span class="string">    44: 08049ff4     0 OBJECT  LOCAL  DEFAULT   23 _GLOBAL_OFFSET_TABLE_</span></span><br><span class="line"><span class="string">    45: 08048480     2 FUNC    GLOBAL DEFAULT   13 __libc_csu_fini</span></span><br><span class="line"><span class="string">    46: 08048482     0 FUNC    GLOBAL HIDDEN    13 __i686.get_pc_thunk.bx</span></span><br><span class="line"><span class="string">    47: 0804a00c     0 NOTYPE  WEAK   DEFAULT   24 data_start</span></span><br><span class="line"><span class="string">    48: 00000000     0 FUNC    GLOBAL DEFAULT  UND printf@@GLIBC_2.0</span></span><br><span class="line"><span class="string">    49: 0804a014     0 NOTYPE  GLOBAL DEFAULT  ABS _edata</span></span><br><span class="line"><span class="string">    50: 080484bc     0 FUNC    GLOBAL DEFAULT   14 _fini</span></span><br><span class="line"><span class="string">    51: 08049f20     0 OBJECT  GLOBAL HIDDEN    19 __DTOR_END__</span></span><br><span class="line"><span class="string">    52: 0804a00c     0 NOTYPE  GLOBAL DEFAULT   24 __data_start</span></span><br><span class="line"><span class="string">    53: 00000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__</span></span><br><span class="line"><span class="string">    54: 0804a010     0 OBJECT  GLOBAL HIDDEN    24 __dso_handle</span></span><br><span class="line"><span class="string">    55: 080484dc     4 OBJECT  GLOBAL DEFAULT   15 _IO_stdin_used</span></span><br><span class="line"><span class="string">    56: 00000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@@GLIBC_</span></span><br><span class="line"><span class="string">    57: 08048410    97 FUNC    GLOBAL DEFAULT   13 __libc_csu_init</span></span><br><span class="line"><span class="string">    58: 0804a01c     0 NOTYPE  GLOBAL DEFAULT  ABS _end</span></span><br><span class="line"><span class="string">    59: 08048330     0 FUNC    GLOBAL DEFAULT   13 _start</span></span><br><span class="line"><span class="string">    60: 080484d8     4 OBJECT  GLOBAL DEFAULT   15 _fp_hw</span></span><br><span class="line"><span class="string">    61: 0804a014     0 NOTYPE  GLOBAL DEFAULT  ABS __bss_start</span></span><br><span class="line"><span class="string">    62: 080483e4    40 FUNC    GLOBAL DEFAULT   13 main</span></span><br><span class="line"><span class="string">    63: 00000000     0 NOTYPE  WEAK   DEFAULT  UND _Jv_RegisterClasses</span></span><br><span class="line"><span class="string">    64: 080482b4     0 FUNC    GLOBAL DEFAULT   11 _init</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Histogram for `.gnu.hash&#x27;</span> bucket list length (total of 2 buckets):</span><br><span class="line"> Length  Number     % of total  Coverage</span><br><span class="line">      0  1          ( 50.0%)</span><br><span class="line">      1  1          ( 50.0%)    100.0%</span><br><span class="line"></span><br><span class="line">Version symbols section <span class="string">&#x27;.gnu.version&#x27;</span> contains 5 entries:</span><br><span class="line"> Addr: 0000000008048268  Offset: 0x000268  Link: 5 (.dynsym)</span><br><span class="line">  000:   0 (*<span class="built_in">local</span>*)       2 (GLIBC_2.0)     0 (*<span class="built_in">local</span>*)       2 (GLIBC_2.0)</span><br><span class="line">  004:   1 (*global*)</span><br><span class="line"></span><br><span class="line">Version needs section <span class="string">&#x27;.gnu.version_r&#x27;</span> contains 1 entries:</span><br><span class="line"> Addr: 0x0000000008048274  Offset: 0x000274  Link: 6 (.dynstr)</span><br><span class="line">  000000: Version: 1  File: libc.so.6  Cnt: 1</span><br><span class="line">  0x0010:   Name: GLIBC_2.0  Flags: none  Version: 2</span><br><span class="line"></span><br><span class="line">Notes at offset 0x00000168 with length 0x00000020:</span><br><span class="line">  Owner                 Data size   Description</span><br><span class="line">  GNU                  0x00000010   NT_GNU_ABI_TAG (ABI version tag)</span><br><span class="line">    OS: Linux, ABI: 2.6.15</span><br><span class="line"></span><br><span class="line">Notes at offset 0x00000188 with length 0x00000024:</span><br><span class="line">  Owner                 Data size   Description</span><br><span class="line">  GNU                  0x00000014   NT_GNU_BUILD_ID (unique build ID bitstring)</span><br><span class="line">    Build ID: 17fb9651029b6a8543bfafec9eea23bd16454e65</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>readelf</tag>
      </tags>
  </entry>
  <entry>
    <title>objdump二进制文件分析</title>
    <url>/2020/09/25/objdump%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在Linux环境下，我们可以使用objdump命令对目标文件(obj)或可执行文件进行反汇编，它以一种可阅读的格式让你更多的了解二进制文件可能带有的附加信息。</p>
<span id="more"></span>

<h2 id="常用参数说明"><a href="#常用参数说明" class="headerlink" title="常用参数说明"></a>常用参数说明</h2><p><code>-f</code> 显示文件头信息<br><code>-D</code> 反汇编所有section (-d反汇编特定section)<br><code>-h</code> 显示目标文件各个section的头部摘要信息<br><code>-x</code> 显示所有可用的头信息，包括符号表、重定位入口。-x 等价于 -a -f -h -r -t 同时指定。<br><code>-i</code> 显示对于 -b 或者 -m 选项可用的架构和目标格式列表。<br><code>-r</code> 显示文件的重定位入口。如果和-d或者-D一起使用，重定位部分以反汇编后的格式显示出来。<br><code>-R</code> 显示文件的动态重定位入口，仅仅对于动态目标文件有意义，比如某些共享库。<br><code>-S</code> 尽可能反汇编出源代码，尤其当编译的时候指定了-g这种调试参数时，效果比较明显。隐含了-d参数。<br><code>-t</code> 显示文件的符号表入口。类似于nm -s提供的信息</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="测试示例代码"><a href="#测试示例代码" class="headerlink" title="测试示例代码"></a>测试示例代码</h3><h4 id="头文件add-h"><a href="#头文件add-h" class="headerlink" title="头文件add.h"></a>头文件add.h</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> __ADD_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __ADD_H_</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __cplusplus */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> module_id;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> *module_name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* __cplusplus */</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h4 id="源文件add-c"><a href="#源文件add-c" class="headerlink" title="源文件add.c"></a>源文件add.c</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;add.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> module_id = <span class="number">1001</span>;</span><br><span class="line"><span class="type">char</span> *module_name = <span class="string">&quot;calc&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="测试文件main-c"><a href="#测试文件main-c" class="headerlink" title="测试文件main.c"></a>测试文件main.c</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;add.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> out_sum;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="type">int</span> id = module_id;</span><br><span class="line">        <span class="type">char</span> *name = module_name;</span><br><span class="line">        <span class="type">int</span> sum;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;module：%d %s\n&quot;</span>, id, name);</span><br><span class="line"></span><br><span class="line">        sum = add(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sum: %d\n&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        out_sum = sum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="编译代码"><a href="#编译代码" class="headerlink" title="编译代码"></a>编译代码</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># gcc -g -c add.c -o add.o</span></span><br><span class="line"><span class="comment"># gcc -g -c main.c -o main.o</span></span><br><span class="line"><span class="comment"># gcc -o main main.o add.o</span></span><br><span class="line"><span class="comment"># ls</span></span><br><span class="line">add.c  add.h  add.o  main  main.c  main.o</span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="查看对象文件的所有sections的头部摘要信息"><a href="#查看对象文件的所有sections的头部摘要信息" class="headerlink" title="查看对象文件的所有sections的头部摘要信息"></a>查看对象文件的所有sections的头部摘要信息</h3><ul>
<li><p>add.o目标文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># objdump -h ./add.o</span></span><br><span class="line"></span><br><span class="line">./add.o:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA       LMA       File off  Algn</span><br><span class="line">  0 .text         0000000d  00000000  00000000  00000034  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line">  1 .data         00000008  00000000  00000000  00000044  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, DATA</span><br><span class="line">  2 .bss          00000000  00000000  00000000  0000004c  2**0</span><br><span class="line">                  ALLOC</span><br><span class="line">  3 .rodata       00000005  00000000  00000000  0000004c  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  4 .debug_info   0000008e  00000000  00000000  00000051  2**0</span><br><span class="line">                  CONTENTS, RELOC, READONLY, DEBUGGING</span><br><span class="line">  5 .debug_abbrev 0000006f  00000000  00000000  000000df  2**0</span><br><span class="line">                  CONTENTS, READONLY, DEBUGGING</span><br><span class="line">  6 .debug_aranges 00000020  00000000  00000000  0000014e  2**0</span><br><span class="line">                  CONTENTS, RELOC, READONLY, DEBUGGING</span><br><span class="line">  7 .debug_line   00000035  00000000  00000000  0000016e  2**0</span><br><span class="line">                  CONTENTS, RELOC, READONLY, DEBUGGING</span><br><span class="line">  8 .debug_str    0000007f  00000000  00000000  000001a3  2**0</span><br><span class="line">                  CONTENTS, READONLY, DEBUGGING</span><br><span class="line">  9 .comment      00000036  00000000  00000000  00000222  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line"> 10 .note.GNU-stack 00000000  00000000  00000000  00000258  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line"> 11 .eh_frame     00000038  00000000  00000000  00000258  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br></pre></td></tr></table></figure></li>
<li><p>main.o目标文件</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># objdump -h main.o</span></span><br><span class="line"></span><br><span class="line">main.o:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA       LMA       File off  Algn</span><br><span class="line">  0 .text         00000071  00000000  00000000  00000034  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE</span><br><span class="line">  1 .data         00000000  00000000  00000000  000000a5  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line">  2 .bss          00000000  00000000  00000000  000000a5  2**0</span><br><span class="line">                  ALLOC</span><br><span class="line">  3 .rodata       00000019  00000000  00000000  000000a5  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  4 .debug_info   0000010c  00000000  00000000  000000be  2**0</span><br><span class="line">                  CONTENTS, RELOC, READONLY, DEBUGGING</span><br><span class="line">  5 .debug_abbrev 0000009e  00000000  00000000  000001ca  2**0</span><br><span class="line">                  CONTENTS, READONLY, DEBUGGING</span><br><span class="line">  6 .debug_aranges 00000020  00000000  00000000  00000268  2**0</span><br><span class="line">                  CONTENTS, RELOC, READONLY, DEBUGGING</span><br><span class="line">  7 .debug_line   0000004b  00000000  00000000  00000288  2**0</span><br><span class="line">                  CONTENTS, RELOC, READONLY, DEBUGGING</span><br><span class="line">  8 .debug_str    00000129  00000000  00000000  000002d3  2**0</span><br><span class="line">                  CONTENTS, READONLY, DEBUGGING</span><br><span class="line">  9 .comment      00000036  00000000  00000000  000003fc  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line"> 10 .note.GNU-stack 00000000  00000000  00000000  00000432  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br><span class="line"> 11 .eh_frame     00000044  00000000  00000000  00000434  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>main可执行程序<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># objdump -h main</span></span><br><span class="line"></span><br><span class="line">main:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA       LMA       File off  Algn</span><br><span class="line">  0 .interp       00000013  08048154  08048154  00000154  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  1 .note.ABI-tag 00000020  08048168  08048168  00000168  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  2 .note.gnu.build-id 00000024  08048188  08048188  00000188  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  3 .gnu.hash     00000020  080481ac  080481ac  000001ac  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  4 .dynsym       00000050  080481cc  080481cc  000001cc  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  5 .dynstr       0000004c  0804821c  0804821c  0000021c  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  6 .gnu.version  0000000a  08048268  08048268  00000268  2**1</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  7 .gnu.version_r 00000020  08048274  08048274  00000274  2**2</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="显示目标文件的整体头部摘要信息"><a href="#显示目标文件的整体头部摘要信息" class="headerlink" title="显示目标文件的整体头部摘要信息"></a>显示目标文件的整体头部摘要信息</h3><ul>
<li><p>add.o目标文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># objdump -f ./add.o</span></span><br><span class="line"></span><br><span class="line">./add.o:     file format elf32-i386</span><br><span class="line">architecture: i386, flags 0x00000011:</span><br><span class="line">HAS_RELOC, HAS_SYMS</span><br><span class="line">start address 0x00000000</span><br></pre></td></tr></table></figure></li>
<li><p>main.o目标文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># objdump -f ./main.o</span></span><br><span class="line"></span><br><span class="line">./main.o:     file format elf32-i386</span><br><span class="line">architecture: i386, flags 0x00000011:</span><br><span class="line">HAS_RELOC, HAS_SYMS</span><br><span class="line">start address 0x00000000</span><br></pre></td></tr></table></figure></li>
<li><p>main目标文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># objdump -f ./main</span></span><br><span class="line"></span><br><span class="line">./main:     file format elf32-i386</span><br><span class="line">architecture: i386, flags 0x00000112:</span><br><span class="line">EXEC_P, HAS_SYMS, D_PAGED</span><br><span class="line">start address 0x08048310</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="查看目标文件符号表"><a href="#查看目标文件符号表" class="headerlink" title="查看目标文件符号表"></a>查看目标文件符号表</h3><ul>
<li>add.o符号表<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># objdump -t ./add.o</span></span><br><span class="line"></span><br><span class="line">./add.o:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">SYMBOL TABLE:</span><br><span class="line">00000000 l    <span class="built_in">df</span> *ABS*  00000000 add.c</span><br><span class="line">00000000 l    d  .text  00000000 .text</span><br><span class="line">00000000 l    d  .data  00000000 .data</span><br><span class="line">00000000 l    d  .bss   00000000 .bss</span><br><span class="line">00000000 l    d  .rodata        00000000 .rodata</span><br><span class="line">00000000 l    d  .debug_info    00000000 .debug_info</span><br><span class="line">00000000 l    d  .debug_abbrev  00000000 .debug_abbrev</span><br><span class="line">00000000 l    d  .debug_aranges 00000000 .debug_aranges</span><br><span class="line">00000000 l    d  .debug_line    00000000 .debug_line</span><br><span class="line">00000000 l    d  .debug_str     00000000 .debug_str</span><br><span class="line">00000000 l    d  .note.GNU-stack        00000000 .note.GNU-stack</span><br><span class="line">00000000 l    d  .eh_frame      00000000 .eh_frame</span><br><span class="line">00000000 l    d  .comment       00000000 .comment</span><br><span class="line">00000000 g     O .data  00000004 module_id</span><br><span class="line">00000004 g     O .data  00000004 module_name</span><br><span class="line">00000000 g     F .text  0000000d add</span><br></pre></td></tr></table></figure></li>
<li>main.o符号表<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># objdump -t ./main.o</span></span><br><span class="line"></span><br><span class="line">./main.o:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">SYMBOL TABLE:</span><br><span class="line">00000000 l    <span class="built_in">df</span> *ABS*  00000000 main.c</span><br><span class="line">00000000 l    d  .text  00000000 .text</span><br><span class="line">00000000 l    d  .data  00000000 .data</span><br><span class="line">00000000 l    d  .bss   00000000 .bss</span><br><span class="line">00000000 l    d  .rodata        00000000 .rodata</span><br><span class="line">00000000 l    d  .debug_info    00000000 .debug_info</span><br><span class="line">00000000 l    d  .debug_abbrev  00000000 .debug_abbrev</span><br><span class="line">00000000 l    d  .debug_aranges 00000000 .debug_aranges</span><br><span class="line">00000000 l    d  .debug_line    00000000 .debug_line</span><br><span class="line">00000000 l    d  .debug_str     00000000 .debug_str</span><br><span class="line">00000000 l    d  .note.GNU-stack        00000000 .note.GNU-stack</span><br><span class="line">00000000 l    d  .eh_frame      00000000 .eh_frame</span><br><span class="line">00000000 l    d  .comment       00000000 .comment</span><br><span class="line">00000004       O *COM*  00000004 out_sum</span><br><span class="line">00000000 g     F .text  00000071 main</span><br><span class="line">00000000         *UND*  00000000 module_id</span><br><span class="line">00000000         *UND*  00000000 module_name</span><br><span class="line">00000000         *UND*  00000000 <span class="built_in">printf</span></span><br><span class="line">00000000         *UND*  00000000 add</span><br></pre></td></tr></table></figure></li>
<li>main符号表<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># objdump -t ./main</span></span><br><span class="line"></span><br><span class="line">./main:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">SYMBOL TABLE:</span><br><span class="line">08048154 l    d  .interp        00000000              .interp</span><br><span class="line">08048168 l    d  .note.ABI-tag  00000000              .note.ABI-tag</span><br><span class="line">08048188 l    d  .note.gnu.build-id     00000000              .note.gnu.build-id</span><br><span class="line">080481ac l    d  .gnu.hash      00000000              .gnu.hash</span><br><span class="line">080481cc l    d  .dynsym        00000000              .dynsym</span><br><span class="line">0804821c l    d  .dynstr        00000000              .dynstr</span><br><span class="line">08048268 l    d  .gnu.version   00000000              .gnu.version</span><br><span class="line">08048274 l    d  .gnu.version_r 00000000              .gnu.version_r</span><br><span class="line">08048294 l    d  .rel.dyn       00000000              .rel.dyn</span><br><span class="line">0804829c l    d  .rel.plt       00000000              .rel.plt</span><br><span class="line">080482ac l    d  .init  00000000              .init</span><br><span class="line">080482d0 l    d  .plt   00000000              .plt</span><br><span class="line">08048300 l    d  .plt.got       00000000              .plt.got</span><br><span class="line">08048310 l    d  .text  00000000              .text</span><br><span class="line">080484f4 l    d  .fini  00000000              .fini</span><br><span class="line">08048508 l    d  .rodata        00000000              .rodata</span><br><span class="line">08048530 l    d  .eh_frame_hdr  00000000              .eh_frame_hdr</span><br><span class="line">08048564 l    d  .eh_frame      00000000              .eh_frame</span><br><span class="line">08049f08 l    d  .init_array    00000000              .init_array</span><br><span class="line">08049f0c l    d  .fini_array    00000000              .fini_array</span><br><span class="line">08049f10 l    d  .jcr   00000000              .jcr</span><br><span class="line">08049f14 l    d  .dynamic       00000000              .dynamic</span><br><span class="line">08049ffc l    d  .got   00000000              .got</span><br><span class="line">0804a000 l    d  .got.plt       00000000              .got.plt</span><br><span class="line">0804a014 l    d  .data  00000000              .data</span><br><span class="line">0804a024 l    d  .bss   00000000              .bss</span><br><span class="line">00000000 l    d  .comment       00000000              .comment</span><br><span class="line">00000000 l    d  .debug_aranges 00000000              .debug_aranges</span><br><span class="line">00000000 l    d  .debug_info    00000000              .debug_info</span><br><span class="line">00000000 l    d  .debug_abbrev  00000000              .debug_abbrev</span><br><span class="line">00000000 l    d  .debug_line    00000000              .debug_line</span><br><span class="line">00000000 l    d  .debug_str     00000000              .debug_str</span><br><span class="line">00000000 l    <span class="built_in">df</span> *ABS*  00000000              crtstuff.c</span><br><span class="line">08049f10 l     O .jcr   00000000              __JCR_LIST__</span><br><span class="line">08048350 l     F .text  00000000              deregister_tm_clones</span><br><span class="line">08048380 l     F .text  00000000              register_tm_clones</span><br><span class="line">080483c0 l     F .text  00000000              __do_global_dtors_aux</span><br><span class="line">0804a024 l     O .bss   00000001              completed.7209</span><br><span class="line">08049f0c l     O .fini_array    00000000              __do_global_dtors_aux_fini_array_entry</span><br><span class="line">080483e0 l     F .text  00000000              frame_dummy</span><br><span class="line">08049f08 l     O .init_array    00000000              __frame_dummy_init_array_entry</span><br><span class="line">00000000 l    <span class="built_in">df</span> *ABS*  00000000              main.c</span><br><span class="line">00000000 l    <span class="built_in">df</span> *ABS*  00000000              add.c</span><br><span class="line">00000000 l    <span class="built_in">df</span> *ABS*  00000000              crtstuff.c</span><br><span class="line">0804864c l     O .eh_frame      00000000              __FRAME_END__</span><br><span class="line">08049f10 l     O .jcr   00000000              __JCR_END__</span><br><span class="line">00000000 l    <span class="built_in">df</span> *ABS*  00000000              </span><br><span class="line">08049f0c l       .init_array    00000000              __init_array_end</span><br><span class="line">08049f14 l     O .dynamic       00000000              _DYNAMIC</span><br><span class="line">08049f08 l       .init_array    00000000              __init_array_start</span><br><span class="line">08048530 l       .eh_frame_hdr  00000000              __GNU_EH_FRAME_HDR</span><br><span class="line">0804a000 l     O .got.plt       00000000              _GLOBAL_OFFSET_TABLE_</span><br><span class="line">080484f0 g     F .text  00000002              __libc_csu_fini</span><br><span class="line">00000000  w      *UND*  00000000              _ITM_deregisterTMCloneTable</span><br><span class="line">08048340 g     F .text  00000004              .hidden __x86.get_pc_thunk.bx</span><br><span class="line">0804a014  w      .data  00000000              data_start</span><br><span class="line">0804847c g     F .text  0000000d              add</span><br><span class="line">00000000       F *UND*  00000000              <span class="built_in">printf</span>@@GLIBC_2.0</span><br><span class="line">0804a01c g     O .data  00000004              module_id</span><br><span class="line">0804a024 g       .data  00000000              _edata</span><br><span class="line">0804a020 g     O .data  00000004              module_name</span><br><span class="line">080484f4 g     F .fini  00000000              _fini</span><br><span class="line">0804a014 g       .data  00000000              __data_start</span><br><span class="line">00000000  w      *UND*  00000000              __gmon_start__</span><br><span class="line">0804a018 g     O .data  00000000              .hidden __dso_handle</span><br><span class="line">0804850c g     O .rodata        00000004              _IO_stdin_used</span><br><span class="line">00000000       F *UND*  00000000              __libc_start_main@@GLIBC_2.0</span><br><span class="line">08048490 g     F .text  0000005d              __libc_csu_init</span><br><span class="line">0804a02c g       .bss   00000000              _end</span><br><span class="line">08048310 g     F .text  00000000              _start</span><br><span class="line">08048508 g     O .rodata        00000004              _fp_hw</span><br><span class="line">0804a024 g       .bss   00000000              __bss_start</span><br><span class="line">0804a028 g     O .bss   00000004              out_sum</span><br><span class="line">0804840b g     F .text  00000071              main</span><br><span class="line">00000000  w      *UND*  00000000              _Jv_RegisterClasses</span><br><span class="line">0804a024 g     O .data  00000000              .hidden __TMC_END__</span><br><span class="line">00000000  w      *UND*  00000000              _ITM_registerTMCloneTable</span><br><span class="line">080482ac g     F .init  00000000              _init</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="对目标文件进行反汇编"><a href="#对目标文件进行反汇编" class="headerlink" title="对目标文件进行反汇编"></a>对目标文件进行反汇编</h3><ul>
<li>add.o进行反汇编<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># objdump -d ./add.o</span></span><br><span class="line"></span><br><span class="line">./add.o:     file format elf32-i386</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">00000000 &lt;add&gt;:</span><br><span class="line">   0:   55                      push   %ebp</span><br><span class="line">   1:   89 e5                   mov    %esp,%ebp</span><br><span class="line">   3:   8b 55 08                mov    0x8(%ebp),%edx</span><br><span class="line">   6:   8b 45 0c                mov    0xc(%ebp),%eax</span><br><span class="line">   9:   01 d0                   add    %edx,%eax</span><br><span class="line">   b:   5d                      pop    %ebp</span><br><span class="line">   c:   c3                      ret </span><br></pre></td></tr></table></figure></li>
<li>main.o进行反汇编<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># objdump -d -S ./main.o</span></span><br><span class="line"></span><br><span class="line">./main.o:     file format elf32-i386</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">00000000 &lt;main&gt;:</span><br><span class="line"></span><br><span class="line">int out_sum;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">   0:   8d 4c 24 04             lea    0x4(%esp),%ecx</span><br><span class="line">   4:   83 e4 f0                and    <span class="variable">$0xfffffff0</span>,%esp</span><br><span class="line">   7:   ff 71 <span class="built_in">fc</span>                pushl  -0x4(%ecx)</span><br><span class="line">   a:   55                      push   %ebp</span><br><span class="line">   b:   89 e5                   mov    %esp,%ebp</span><br><span class="line">   d:   51                      push   %ecx</span><br><span class="line">   e:   83 ec 14                sub    <span class="variable">$0x14</span>,%esp</span><br><span class="line">        int <span class="built_in">id</span> = module_id;</span><br><span class="line">  11:   a1 00 00 00 00          mov    0x0,%eax</span><br><span class="line">  16:   89 45 ec                mov    %eax,-0x14(%ebp)</span><br><span class="line">        char *name = module_name;</span><br><span class="line">  19:   a1 00 00 00 00          mov    0x0,%eax</span><br><span class="line">  1e:   89 45 f0                mov    %eax,-0x10(%ebp)</span><br><span class="line">        int <span class="built_in">sum</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;module：%d %s\n&quot;</span>, <span class="built_in">id</span>, name);</span><br><span class="line">  21:   83 ec 04                sub    <span class="variable">$0x4</span>,%esp</span><br><span class="line">  24:   ff 75 f0                pushl  -0x10(%ebp)</span><br><span class="line">  27:   ff 75 ec                pushl  -0x14(%ebp)</span><br><span class="line">  2a:   68 00 00 00 00          push   <span class="variable">$0x0</span></span><br><span class="line">  2f:   e8 <span class="built_in">fc</span> ff ff ff          call   30 &lt;main+0x30&gt;</span><br><span class="line">  34:   83 c4 10                add    <span class="variable">$0x10</span>,%esp</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sum</span> = add(2,3);</span><br><span class="line">  37:   83 ec 08                sub    <span class="variable">$0x8</span>,%esp</span><br><span class="line">  3a:   6a 03                   push   <span class="variable">$0x3</span></span><br><span class="line">  3c:   6a 02                   push   <span class="variable">$0x2</span></span><br><span class="line">  3e:   e8 <span class="built_in">fc</span> ff ff ff          call   3f &lt;main+0x3f&gt;</span><br><span class="line">  43:   83 c4 10                add    <span class="variable">$0x10</span>,%esp</span><br><span class="line">  46:   89 45 f4                mov    %eax,-0xc(%ebp)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sum: %d\n&quot;</span>, <span class="built_in">sum</span>);</span><br><span class="line">  49:   83 ec 08                sub    <span class="variable">$0x8</span>,%esp</span><br><span class="line">  4c:   ff 75 f4                pushl  -0xc(%ebp)</span><br><span class="line">  4f:   68 10 00 00 00          push   <span class="variable">$0x10</span></span><br><span class="line">  54:   e8 <span class="built_in">fc</span> ff ff ff          call   55 &lt;main+0x55&gt;</span><br><span class="line">  59:   83 c4 10                add    <span class="variable">$0x10</span>,%esp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        out_sum = <span class="built_in">sum</span>;</span><br><span class="line">  5c:   8b 45 f4                mov    -0xc(%ebp),%eax</span><br><span class="line">  5f:   a3 00 00 00 00          mov    %eax,0x0</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> 0x0;</span><br><span class="line">  64:   b8 00 00 00 00          mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">&#125;</span><br><span class="line">  69:   8b 4d <span class="built_in">fc</span>                mov    -0x4(%ebp),%ecx</span><br><span class="line">  6c:   c9                      leave  </span><br><span class="line">  6d:   8d 61 <span class="built_in">fc</span>                lea    -0x4(%ecx),%esp</span><br><span class="line">  70:   c3                      ret    </span><br></pre></td></tr></table></figure></li>
<li>main进行反汇编<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># objdump -d -S ./main</span></span><br><span class="line"></span><br><span class="line">./main:     file format elf32-i386</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disassembly of section .init:</span><br><span class="line"></span><br><span class="line">080482ac &lt;_init&gt;:</span><br><span class="line"> 80482ac:       53                      push   %ebx</span><br><span class="line"> 80482ad:       83 ec 08                sub    <span class="variable">$0x8</span>,%esp</span><br><span class="line"> 80482b0:       e8 8b 00 00 00          call   8048340 &lt;__x86.get_pc_thunk.bx&gt;</span><br><span class="line"> 80482b5:       81 c3 4b 1d 00 00       add    <span class="variable">$0x1d4b</span>,%ebx</span><br><span class="line"> 80482bb:       8b 83 <span class="built_in">fc</span> ff ff ff       mov    -0x4(%ebx),%eax</span><br><span class="line"> 80482c1:       85 c0                   <span class="built_in">test</span>   %eax,%eax</span><br><span class="line"> 80482c3:       74 05                   je     80482ca &lt;_init+0x1e&gt;</span><br><span class="line"> 80482c5:       e8 36 00 00 00          call   8048300 &lt;__libc_start_main@plt+0x10&gt;</span><br><span class="line"> 80482ca:       83 c4 08                add    <span class="variable">$0x8</span>,%esp</span><br><span class="line"> 80482cd:       5b                      pop    %ebx</span><br><span class="line"> 80482ce:       c3                      ret    </span><br><span class="line"></span><br><span class="line">Disassembly of section .plt:</span><br><span class="line"></span><br><span class="line">080482d0 &lt;<span class="built_in">printf</span>@plt-0x10&gt;:</span><br><span class="line"> 80482d0:       ff 35 04 a0 04 08       pushl  0x804a004</span><br><span class="line"> 80482d6:       ff 25 08 a0 04 08       jmp    *0x804a008</span><br><span class="line"> 80482dc:       00 00                   add    %al,(%eax)</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">080482e0 &lt;<span class="built_in">printf</span>@plt&gt;:</span><br><span class="line"> 80482e0:       ff 25 0c a0 04 08       jmp    *0x804a00c</span><br><span class="line"> 80482e6:       68 00 00 00 00          push   <span class="variable">$0x0</span></span><br><span class="line"> 80482eb:       e9 e0 ff ff ff          jmp    80482d0 &lt;_init+0x24&gt;</span><br><span class="line"></span><br><span class="line">080482f0 &lt;__libc_start_main@plt&gt;:</span><br><span class="line"> 80482f0:       ff 25 10 a0 04 08       jmp    *0x804a010</span><br><span class="line"> 80482f6:       68 08 00 00 00          push   <span class="variable">$0x8</span></span><br><span class="line"> 80482fb:       e9 d0 ff ff ff          jmp    80482d0 &lt;_init+0x24&gt;</span><br><span class="line"></span><br><span class="line">Disassembly of section .plt.got:</span><br><span class="line"></span><br><span class="line">08048300 &lt;.plt.got&gt;:</span><br><span class="line"> 8048300:       ff 25 <span class="built_in">fc</span> 9f 04 08       jmp    *0x8049ffc</span><br><span class="line"> 8048306:       66 90                   xchg   %ax,%ax</span><br><span class="line"></span><br><span class="line">Disassembly of section .text:</span><br><span class="line"></span><br><span class="line">08048310 &lt;_start&gt;:</span><br><span class="line"> 8048310:       31 ed                   xor    %ebp,%ebp</span><br><span class="line"> 8048312:       5e                      pop    %esi</span><br><span class="line"> 8048313:       89 e1                   mov    %esp,%ecx</span><br><span class="line"> 8048315:       83 e4 f0                and    <span class="variable">$0xfffffff0</span>,%esp</span><br><span class="line"> 8048318:       50                      push   %eax</span><br><span class="line"> 8048319:       54                      push   %esp</span><br><span class="line"> 804831a:       52                      push   %edx</span><br><span class="line"> 804831b:       68 f0 84 04 08          push   <span class="variable">$0x80484f0</span></span><br><span class="line"> 8048320:       68 90 84 04 08          push   <span class="variable">$0x8048490</span></span><br><span class="line"> 8048325:       51                      push   %ecx</span><br><span class="line"> 8048326:       56                      push   %esi</span><br><span class="line"> 8048327:       68 0b 84 04 08          push   <span class="variable">$0x804840b</span></span><br><span class="line"> 804832c:       e8 bf ff ff ff          call   80482f0 &lt;__libc_start_main@plt&gt;</span><br><span class="line"> 8048331:       f4                      hlt    </span><br><span class="line"> 8048332:       66 90                   xchg   %ax,%ax</span><br><span class="line"> 8048334:       66 90                   xchg   %ax,%ax</span><br><span class="line"> 8048336:       66 90                   xchg   %ax,%ax</span><br><span class="line"> 8048338:       66 90                   xchg   %ax,%ax</span><br><span class="line"> 804833a:       66 90                   xchg   %ax,%ax</span><br><span class="line"> 804833c:       66 90                   xchg   %ax,%ax</span><br><span class="line"> 804833e:       66 90                   xchg   %ax,%ax</span><br><span class="line"></span><br><span class="line">08048340 &lt;__x86.get_pc_thunk.bx&gt;:</span><br><span class="line"> 8048340:       8b 1c 24                mov    (%esp),%ebx</span><br><span class="line"> 8048343:       c3                      ret    </span><br><span class="line"> 8048344:       66 90                   xchg   %ax,%ax</span><br><span class="line"> 8048346:       66 90                   xchg   %ax,%ax</span><br><span class="line"> 8048348:       66 90                   xchg   %ax,%ax</span><br><span class="line"> 804834a:       66 90                   xchg   %ax,%ax</span><br><span class="line"> 804834c:       66 90                   xchg   %ax,%ax</span><br><span class="line"> 804834e:       66 90                   xchg   %ax,%ax</span><br><span class="line"></span><br><span class="line">08048350 &lt;deregister_tm_clones&gt;:</span><br><span class="line"> 8048350:       b8 27 a0 04 08          mov    <span class="variable">$0x804a027</span>,%eax</span><br><span class="line"> 8048355:       2d 24 a0 04 08          sub    <span class="variable">$0x804a024</span>,%eax</span><br><span class="line"> 804835a:       83 f8 06                cmp    <span class="variable">$0x6</span>,%eax</span><br><span class="line"> 804835d:       76 1a                   jbe    8048379 &lt;deregister_tm_clones+0x29&gt;</span><br><span class="line"> 804835f:       b8 00 00 00 00          mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line"> 8048364:       85 c0                   <span class="built_in">test</span>   %eax,%eax</span><br><span class="line"> 8048366:       74 11                   je     8048379 &lt;deregister_tm_clones+0x29&gt;</span><br><span class="line"> 8048368:       55                      push   %ebp</span><br><span class="line"> 8048369:       89 e5                   mov    %esp,%ebp</span><br><span class="line"> 804836b:       83 ec 14                sub    <span class="variable">$0x14</span>,%esp</span><br><span class="line"> 804836e:       68 24 a0 04 08          push   <span class="variable">$0x804a024</span></span><br><span class="line"> 8048373:       ff d0                   call   *%eax</span><br><span class="line"> 8048375:       83 c4 10                add    <span class="variable">$0x10</span>,%esp</span><br><span class="line"> 8048378:       c9                      leave  </span><br><span class="line"> 8048379:       f3 c3                   repz ret </span><br><span class="line"> 804837b:       90                      nop</span><br><span class="line"> 804837c:       8d 74 26 00             lea    0x0(%esi,%eiz,1),%esi</span><br><span class="line"></span><br><span class="line">08048380 &lt;register_tm_clones&gt;:</span><br><span class="line"> 8048380:       b8 24 a0 04 08          mov    <span class="variable">$0x804a024</span>,%eax</span><br><span class="line"> 8048385:       2d 24 a0 04 08          sub    <span class="variable">$0x804a024</span>,%eax</span><br><span class="line"> 804838a:       c1 f8 02                sar    <span class="variable">$0x2</span>,%eax</span><br><span class="line"> 804838d:       89 c2                   mov    %eax,%edx</span><br><span class="line"> 804838f:       c1 ea 1f                shr    <span class="variable">$0x1f</span>,%edx</span><br><span class="line"> 8048392:       01 d0                   add    %edx,%eax</span><br><span class="line"> 8048394:       d1 f8                   sar    %eax</span><br><span class="line"> 8048396:       74 1b                   je     80483b3 &lt;register_tm_clones+0x33&gt;</span><br><span class="line"> 8048398:       ba 00 00 00 00          mov    <span class="variable">$0x0</span>,%edx</span><br><span class="line"> 804839d:       85 d2                   <span class="built_in">test</span>   %edx,%edx</span><br><span class="line"> 804839f:       74 12                   je     80483b3 &lt;register_tm_clones+0x33&gt;</span><br><span class="line"> 80483a1:       55                      push   %ebp</span><br><span class="line"> 80483a2:       89 e5                   mov    %esp,%ebp</span><br><span class="line"> 80483a4:       83 ec 10                sub    <span class="variable">$0x10</span>,%esp</span><br><span class="line"> 80483a7:       50                      push   %eax</span><br><span class="line"> 80483a8:       68 24 a0 04 08          push   <span class="variable">$0x804a024</span></span><br><span class="line"> 80483ad:       ff d2                   call   *%edx</span><br><span class="line"> 80483af:       83 c4 10                add    <span class="variable">$0x10</span>,%esp</span><br><span class="line"> 80483b2:       c9                      leave  </span><br><span class="line"> 80483b3:       f3 c3                   repz ret </span><br><span class="line"> 80483b5:       8d 74 26 00             lea    0x0(%esi,%eiz,1),%esi</span><br><span class="line"> 80483b9:       8d bc 27 00 00 00 00    lea    0x0(%edi,%eiz,1),%edi</span><br><span class="line"></span><br><span class="line">080483c0 &lt;__do_global_dtors_aux&gt;:</span><br><span class="line"> 80483c0:       80 3d 24 a0 04 08 00    cmpb   <span class="variable">$0x0</span>,0x804a024</span><br><span class="line"> 80483c7:       75 13                   jne    80483dc &lt;__do_global_dtors_aux+0x1c&gt;</span><br><span class="line"> 80483c9:       55                      push   %ebp</span><br><span class="line"> 80483ca:       89 e5                   mov    %esp,%ebp</span><br><span class="line"> 80483cc:       83 ec 08                sub    <span class="variable">$0x8</span>,%esp</span><br><span class="line"> 80483cf:       e8 7c ff ff ff          call   8048350 &lt;deregister_tm_clones&gt;</span><br><span class="line"> 80483d4:       c6 05 24 a0 04 08 01    movb   <span class="variable">$0x1</span>,0x804a024</span><br><span class="line"> 80483db:       c9                      leave  </span><br><span class="line"> 80483dc:       f3 c3                   repz ret </span><br><span class="line"> 80483de:       66 90                   xchg   %ax,%ax</span><br><span class="line"></span><br><span class="line">080483e0 &lt;frame_dummy&gt;:</span><br><span class="line"> 80483e0:       b8 10 9f 04 08          mov    <span class="variable">$0x8049f10</span>,%eax</span><br><span class="line"> 80483e5:       8b 10                   mov    (%eax),%edx</span><br><span class="line"> 80483e7:       85 d2                   <span class="built_in">test</span>   %edx,%edx</span><br><span class="line"> 80483e9:       75 05                   jne    80483f0 &lt;frame_dummy+0x10&gt;</span><br><span class="line"> 80483eb:       eb 93                   jmp    8048380 &lt;register_tm_clones&gt;</span><br><span class="line"> 80483ed:       8d 76 00                lea    0x0(%esi),%esi</span><br><span class="line"> 80483f0:       ba 00 00 00 00          mov    <span class="variable">$0x0</span>,%edx</span><br><span class="line"> 80483f5:       85 d2                   <span class="built_in">test</span>   %edx,%edx</span><br><span class="line"> 80483f7:       74 f2                   je     80483eb &lt;frame_dummy+0xb&gt;</span><br><span class="line"> 80483f9:       55                      push   %ebp</span><br><span class="line"> 80483fa:       89 e5                   mov    %esp,%ebp</span><br><span class="line"> 80483fc:       83 ec 14                sub    <span class="variable">$0x14</span>,%esp</span><br><span class="line"> 80483ff:       50                      push   %eax</span><br><span class="line"> 8048400:       ff d2                   call   *%edx</span><br><span class="line"> 8048402:       83 c4 10                add    <span class="variable">$0x10</span>,%esp</span><br><span class="line"> 8048405:       c9                      leave  </span><br><span class="line"> 8048406:       e9 75 ff ff ff          jmp    8048380 &lt;register_tm_clones&gt;</span><br><span class="line"></span><br><span class="line">0804840b &lt;main&gt;:</span><br><span class="line"></span><br><span class="line">int out_sum;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line"> 804840b:       8d 4c 24 04             lea    0x4(%esp),%ecx</span><br><span class="line"> 804840f:       83 e4 f0                and    <span class="variable">$0xfffffff0</span>,%esp</span><br><span class="line"> 8048412:       ff 71 <span class="built_in">fc</span>                pushl  -0x4(%ecx)</span><br><span class="line"> 8048415:       55                      push   %ebp</span><br><span class="line"> 8048416:       89 e5                   mov    %esp,%ebp</span><br><span class="line"> 8048418:       51                      push   %ecx</span><br><span class="line"> 8048419:       83 ec 14                sub    <span class="variable">$0x14</span>,%esp</span><br><span class="line">        int <span class="built_in">id</span> = module_id;</span><br><span class="line"> 804841c:       a1 1c a0 04 08          mov    0x804a01c,%eax</span><br><span class="line"> 8048421:       89 45 ec                mov    %eax,-0x14(%ebp)</span><br><span class="line">        char *name = module_name;</span><br><span class="line"> 8048424:       a1 20 a0 04 08          mov    0x804a020,%eax</span><br><span class="line"> 8048429:       89 45 f0                mov    %eax,-0x10(%ebp)</span><br><span class="line">        int <span class="built_in">sum</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;module：%d %s\n&quot;</span>, <span class="built_in">id</span>, name);</span><br><span class="line"> 804842c:       83 ec 04                sub    <span class="variable">$0x4</span>,%esp</span><br><span class="line"> 804842f:       ff 75 f0                pushl  -0x10(%ebp)</span><br><span class="line"> 8048432:       ff 75 ec                pushl  -0x14(%ebp)</span><br><span class="line"> 8048435:       68 10 85 04 08          push   <span class="variable">$0x8048510</span></span><br><span class="line"> 804843a:       e8 a1 fe ff ff          call   80482e0 &lt;<span class="built_in">printf</span>@plt&gt;</span><br><span class="line"> 804843f:       83 c4 10                add    <span class="variable">$0x10</span>,%esp</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sum</span> = add(2,3);</span><br><span class="line"> 8048442:       83 ec 08                sub    <span class="variable">$0x8</span>,%esp</span><br><span class="line"> 8048445:       6a 03                   push   <span class="variable">$0x3</span></span><br><span class="line"> 8048447:       6a 02                   push   <span class="variable">$0x2</span></span><br><span class="line"> 8048449:       e8 2e 00 00 00          call   804847c &lt;add&gt;</span><br><span class="line"> 804844e:       83 c4 10                add    <span class="variable">$0x10</span>,%esp</span><br><span class="line"> 8048451:       89 45 f4                mov    %eax,-0xc(%ebp)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;sum: %d\n&quot;</span>, <span class="built_in">sum</span>);</span><br><span class="line"> 8048454:       83 ec 08                sub    <span class="variable">$0x8</span>,%esp</span><br><span class="line"> 8048457:       ff 75 f4                pushl  -0xc(%ebp)</span><br><span class="line"> 804845a:       68 20 85 04 08          push   <span class="variable">$0x8048520</span></span><br><span class="line"> 804845f:       e8 7c fe ff ff          call   80482e0 &lt;<span class="built_in">printf</span>@plt&gt;</span><br><span class="line"> 8048464:       83 c4 10                add    <span class="variable">$0x10</span>,%esp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        out_sum = <span class="built_in">sum</span>;</span><br><span class="line"> 8048467:       8b 45 f4                mov    -0xc(%ebp),%eax</span><br><span class="line"> 804846a:       a3 28 a0 04 08          mov    %eax,0x804a028</span><br><span class="line"></span><br><span class="line">        <span class="built_in">return</span> 0x0;</span><br><span class="line"> 804846f:       b8 00 00 00 00          mov    <span class="variable">$0x0</span>,%eax</span><br><span class="line">&#125;</span><br><span class="line"> 8048474:       8b 4d <span class="built_in">fc</span>                mov    -0x4(%ebp),%ecx</span><br><span class="line"> 8048477:       c9                      leave  </span><br><span class="line"> 8048478:       8d 61 <span class="built_in">fc</span>                lea    -0x4(%ecx),%esp</span><br><span class="line"> 804847b:       c3                      ret    </span><br><span class="line"></span><br><span class="line">0804847c &lt;add&gt;:</span><br><span class="line"></span><br><span class="line">int module_id = 1001;</span><br><span class="line">char *module_name = <span class="string">&quot;calc&quot;</span>;</span><br><span class="line"></span><br><span class="line">int add(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line"> 804847c:       55                      push   %ebp</span><br><span class="line"> 804847d:       89 e5                   mov    %esp,%ebp</span><br><span class="line">        <span class="built_in">return</span> a+b;</span><br><span class="line"> 804847f:       8b 55 08                mov    0x8(%ebp),%edx</span><br><span class="line"> 8048482:       8b 45 0c                mov    0xc(%ebp),%eax</span><br><span class="line"> 8048485:       01 d0                   add    %edx,%eax</span><br><span class="line">&#125;</span><br><span class="line"> 8048487:       5d                      pop    %ebp</span><br><span class="line"> 8048488:       c3                      ret    </span><br><span class="line"> 8048489:       66 90                   xchg   %ax,%ax</span><br><span class="line"> 804848b:       66 90                   xchg   %ax,%ax</span><br><span class="line"> 804848d:       66 90                   xchg   %ax,%ax</span><br><span class="line"> 804848f:       90                      nop</span><br><span class="line"></span><br><span class="line">08048490 &lt;__libc_csu_init&gt;:</span><br><span class="line"> 8048490:       55                      push   %ebp</span><br><span class="line"> 8048491:       57                      push   %edi</span><br><span class="line"> 8048492:       56                      push   %esi</span><br><span class="line"> 8048493:       53                      push   %ebx</span><br><span class="line"> 8048494:       e8 a7 fe ff ff          call   8048340 &lt;__x86.get_pc_thunk.bx&gt;</span><br><span class="line"> 8048499:       81 c3 67 1b 00 00       add    <span class="variable">$0x1b67</span>,%ebx</span><br><span class="line"> 804849f:       83 ec 0c                sub    <span class="variable">$0xc</span>,%esp</span><br><span class="line"> 80484a2:       8b 6c 24 20             mov    0x20(%esp),%ebp</span><br><span class="line"> 80484a6:       8d b3 0c ff ff ff       lea    -0xf4(%ebx),%esi</span><br><span class="line"> 80484ac:       e8 fb fd ff ff          call   80482ac &lt;_init&gt;</span><br><span class="line"> 80484b1:       8d 83 08 ff ff ff       lea    -0xf8(%ebx),%eax</span><br><span class="line"> 80484b7:       29 c6                   sub    %eax,%esi</span><br><span class="line"> 80484b9:       c1 fe 02                sar    <span class="variable">$0x2</span>,%esi</span><br><span class="line"> 80484bc:       85 f6                   <span class="built_in">test</span>   %esi,%esi</span><br><span class="line"> 80484be:       74 25                   je     80484e5 &lt;__libc_csu_init+0x55&gt;</span><br><span class="line"> 80484c0:       31 ff                   xor    %edi,%edi</span><br><span class="line"> 80484c2:       8d b6 00 00 00 00       lea    0x0(%esi),%esi</span><br><span class="line"> 80484c8:       83 ec 04                sub    <span class="variable">$0x4</span>,%esp</span><br><span class="line"> 80484cb:       ff 74 24 2c             pushl  0x2c(%esp)</span><br><span class="line"> 80484cf:       ff 74 24 2c             pushl  0x2c(%esp)</span><br><span class="line"> 80484d3:       55                      push   %ebp</span><br><span class="line"> 80484d4:       ff 94 bb 08 ff ff ff    call   *-0xf8(%ebx,%edi,4)</span><br><span class="line"> 80484db:       83 c7 01                add    <span class="variable">$0x1</span>,%edi</span><br><span class="line"> 80484de:       83 c4 10                add    <span class="variable">$0x10</span>,%esp</span><br><span class="line"> 80484e1:       39 f7                   cmp    %esi,%edi</span><br><span class="line"> 80484e3:       75 e3                   jne    80484c8 &lt;__libc_csu_init+0x38&gt;</span><br><span class="line"> 80484e5:       83 c4 0c                add    <span class="variable">$0xc</span>,%esp</span><br><span class="line"> 80484e8:       5b                      pop    %ebx</span><br><span class="line"> 80484e9:       5e                      pop    %esi</span><br><span class="line"> 80484ea:       5f                      pop    %edi</span><br><span class="line"> 80484eb:       5d                      pop    %ebp</span><br><span class="line"> 80484ec:       c3                      ret    </span><br><span class="line"> 80484ed:       8d 76 00                lea    0x0(%esi),%esi</span><br><span class="line"></span><br><span class="line">080484f0 &lt;__libc_csu_fini&gt;:</span><br><span class="line"> 80484f0:       f3 c3                   repz ret </span><br><span class="line"></span><br><span class="line">Disassembly of section .fini:</span><br><span class="line"></span><br><span class="line">080484f4 &lt;_fini&gt;:</span><br><span class="line"> 80484f4:       53                      push   %ebx</span><br><span class="line"> 80484f5:       83 ec 08                sub    <span class="variable">$0x8</span>,%esp</span><br><span class="line"> 80484f8:       e8 43 fe ff ff          call   8048340 &lt;__x86.get_pc_thunk.bx&gt;</span><br><span class="line"> 80484fd:       81 c3 03 1b 00 00       add    <span class="variable">$0x1b03</span>,%ebx</span><br><span class="line"> 8048503:       83 c4 08                add    <span class="variable">$0x8</span>,%esp</span><br><span class="line"> 8048506:       5b                      pop    %ebx</span><br><span class="line"> 8048507:       c3                      ret    </span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>objdump</tag>
      </tags>
  </entry>
  <entry>
    <title>nm目标文件格式分析</title>
    <url>/2020/09/24/nm%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>nm 命令显示关于指定 File 中符号的信息，文件可以是对象文件、可执行文件或对象文件库。</li>
<li>如果文件没有包含符号信息，nm 命令报告该情况，但不把它解释为出错条件。 </li>
<li>nm 命令缺省情况下报告十六进制符号表示法下的数字值。<span id="more"></span></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$nm</span> myProgrammer</span><br><span class="line">08049f28 d _DYNAMIC</span><br><span class="line">08049ff4 d _GLOBAL_OFFSET_TABLE_</span><br><span class="line">080484dc R _IO_stdin_used</span><br><span class="line">         w _Jv_RegisterClasses</span><br><span class="line">08049f18 d __CTOR_END__</span><br><span class="line">08049f14 d __CTOR_LIST__</span><br><span class="line">08049f20 D __DTOR_END__</span><br><span class="line">08049f1c d __DTOR_LIST__</span><br><span class="line">080485e0 r __FRAME_END__</span><br><span class="line">08049f24 d __JCR_END__</span><br><span class="line">08049f24 d __JCR_LIST__</span><br><span class="line">0804a014 A __bss_start</span><br><span class="line">0804a00c D __data_start</span><br><span class="line">08048490 t __do_global_ctors_aux</span><br><span class="line">08048360 t __do_global_dtors_aux</span><br><span class="line">0804a010 D __dso_handle</span><br><span class="line">         w __gmon_start__</span><br><span class="line">08048482 T __i686.get_pc_thunk.bx</span><br><span class="line">08049f14 d __init_array_end</span><br><span class="line">08049f14 d __init_array_start</span><br><span class="line">08048480 T __libc_csu_fini</span><br><span class="line">08048410 T __libc_csu_init</span><br><span class="line">         U __libc_start_main@@GLIBC_2.0</span><br><span class="line">0804a014 A _edata</span><br><span class="line">0804a01c A _end</span><br><span class="line">080484bc T _fini</span><br><span class="line">080484d8 R _fp_hw</span><br><span class="line">080482b4 T _init</span><br><span class="line">08048330 T _start</span><br><span class="line">0804a014 b completed.6086</span><br><span class="line">0804a00c W data_start</span><br><span class="line">0804a018 b dtor_idx.6088</span><br><span class="line">080483c0 t frame_dummy</span><br><span class="line">080483e4 T main</span><br><span class="line">         U <span class="built_in">printf</span>@@GLIBC_2.0</span><br></pre></td></tr></table></figure>
<p>这些包含可执行代码的段称为代码段。<br>同样地，数据段包含了不可执行的信息或数据。<br>另一种类型的段，称为 BSS 段，它包含以符号数据开头的块。<br>对于 nm 命令列出的每个符号，它们的值使用十六进制来表示（缺省行为），并且在该符号前面加上了一个表示符号类型的编码字符。</p>
<p>可以将目标文件中所包含的不同的部分划分为段。段可以包含可执行代码、符号名称、初始数据值和许多其他类型的数据。有关这些类型的数据的详细信息，可以阅读 UNIX 中 nm 的 man 页面，其中按照该命令输出中的字符编码分别对每种类型进行了描述。</p>
<h2 id="选项说明"><a href="#选项说明" class="headerlink" title="选项说明"></a>选项说明</h2><p><code>-a或–debug-syms</code>：显示所有的符号，包括debugger-only symbols。<br><code>-B</code>：等同于–format=bsd，用来兼容MIPS的nm。<br><code>-C或–demangle</code>：将低级符号名解析(demangle)成用户级名字。这样可以使得C++函数名具有可读性。<br><code>–no-demangle</code>：默认的选项，不需要将低级符号名解析成用户级名。<br><code>-D或–dynamic</code>：显示动态符号。该任选项仅对于动态目标(例如特定类型的共享库)有意义。<br><code>-f format</code>：使用format格式输出。format可以选取bsd、sysv或posix，该选项在GNU的nm中有用。默认为bsd。<br><code>-g或–extern-only</code>：仅显示外部符号。<br><code>-n、-v或–numeric-sort</code>：按符号对应地址的顺序排序，而非按符号名的字符顺序。<br><code>-p或–no-sort</code>：按目标文件中遇到的符号顺序显示，不排序。<br><code>-P或–portability</code>：使用POSIX.2标准输出格式代替默认的输出格式。等同于使用任选项-f posix。<br><code>-s或–print-armap</code>：当列出库中成员的符号时，包含索引。索引的内容包含：哪些模块包含哪些名字的映射。<br><code>-r或–reverse-sort</code>：反转排序的顺序(例如，升序变为降序)。<br><code>–size-sort</code>：按大小排列符号顺序。该大小是按照一个符号的值与它下一个符号的值进行计算的。<br><code>–target=bfdname</code>：指定一个目标代码的格式，而非使用系统的默认格式。<br><code>-u或–undefined-only</code>：仅显示没有定义的符号(那些外部符号)。<br><code>–defined-only</code>:仅显示定义的符号。<br><code>-l或–line-numbers</code>：对每个符号，使用调试信息来试图找到文件名和行号。<br><code>-V或–version</code>：显示nm的版本号。<br><code>–help</code>：显示nm的选项。</p>
<h2 id="符号说明"><a href="#符号说明" class="headerlink" title="符号说明"></a>符号说明</h2><p>对于每一个符号来说，其类型如果是<strong>小写</strong>的，则表明该符号是<strong>local</strong>的；<br><strong>大写</strong>则表明该符号是<strong>global</strong>的。</p>
<p><code>A</code> 该符号的值是绝对的，在以后的链接过程中，不允许进行改变。<br>这样的符号值，常常出现在<strong>中断向量表</strong>中，例如用符号来表示各个中断向量函数在中断向量表中的位置。<br><code>B</code> 该符号的值出现在<strong>非初始化static数据段bss</strong>中。例如，在一个文件中定义全局static int test。<br>则该符号test的类型为b，位于bss section中。其值表示该符号在bss段中的偏移。一般而言，bss段分配于RAM中。<br><code>C</code> 该符号为common。common symbol是<strong>非初始化数据段</strong>。该符号没有包含于一个普通section中。只有在链接过程中才进行分配。符号的值表示该符号需要的字节数。<br>例如在一个c文件中，定义int test，并且该符号在别的地方会被引用，则该符号类型即为C。否则其类型为B。<br><code>D</code> 该符号位于<strong>初始化数据段</strong>中。一般来说，分配到data section中。<br>例如：定义全局int baud_table[5] = {9600, 19200, 38400, 57600, 115200}，会分配到初始化数据段中。<br><code>G</code> 该符号也位于初始化数据段中。主要用于small object提高访问small data object的一种方式。<br><code>I</code> 该符号是对另一个符号的间接引用。<br><code>N</code> 该符号是一个debugging符号。<br><code>R</code> 该符号位于只读数据区。<br>例如定义全局const int test[] = {123, 123};则test就是一个只读数据区的符号。<br>值得注意的是，如果在一个函数中定义const char *test = “abc”, const char test_int = 3。使用nm都不会得到符号信息，但是字符串”abc”分配于只读存储器中，test在rodata section中，大小为4。<br><code>S</code> 符号位于非初始化数据区，用于small object。<br><code>T</code> 该符号位于代码区text section。<br><code>U</code> 该符号在当前文件中是未定义的，即该符号的定义在别的文件中。<br>例如，当前文件调用另一个文件中定义的函数，在这个被调用的函数在当前就是未定义的；但是在定义它的文件中类型是T。但是对于全局变量来说，在定义它的文件中，其符号类型为C，在使用它的文件中，其类型为U。<br><code>V</code> 该符号是一个weak object。<br><code>W</code> The symbol is a weak symbol that has not been specifically tagged as a weak object symbol.<br><code>?</code> 该符号类型没有定义<br>库或对象名 如果您指定了 -A 选项，则 nm 命令只报告与该文件有关的或者库或者对象名。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>寻找特殊标识<br>有时会碰到一个编译了但没有链接的代码，那是因为它缺失了标识符；这种情况，可以用nm和objdump、readelf命令来查看程序的符号表；所有这些命令做的工作基本一样；</p>
<p>比如连接器报错有未定义的标识符；大多数情况下，会发生在库的缺失或企图链接一个错误版本的库的时候；浏览目标代码来寻找一个特殊标识符的引用:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nm -uCA *.o | grep foo</span><br></pre></td></tr></table></figure>
<p><code>-u</code>选项限制了每个目标文件中未定义标识符的输出。<br><code>-A</code>选项用于显示每个标识符的文件名信息；对于C++代码，常用的还有<code>-C</code>选项，它也为解码这些标识符；</p>
<p>注解<br>objdump、readld命令可以完成同样的任务。等效命令为： <code>$objdump -t $readelf -s</code></p>
<p>列出 a.out 对象文件的静态和外部符:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$nm</span> -e a.out</span><br></pre></td></tr></table></figure>

<p>以十六进制显示符号大小和值并且按值排序符号:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$nm</span> -xv a.out</span><br></pre></td></tr></table></figure>

<p>显示 libc.a 中所有 64 位对象符号，忽略所有 32 位对象:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$nm</span> -X64 /usr/lib/libc.a</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>nm</tag>
      </tags>
  </entry>
  <entry>
    <title>strace</title>
    <url>/2020/09/23/strace/</url>
    <content><![CDATA[<h2 id="跟踪进程中的系统调用"><a href="#跟踪进程中的系统调用" class="headerlink" title="跟踪进程中的系统调用"></a>跟踪进程中的系统调用</h2><ul>
<li>strace常用来跟踪进程执行时的系统调用和所接收的信号。 </li>
<li>在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。</li>
<li>strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。<br>追踪test进程关于信号的系统调用：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">strace -tt -e trace=signal -p `pidof <span class="built_in">test</span>`</span><br></pre></td></tr></table></figure>
<span id="more"></span></li>
</ul>
<h2 id="输出参数含义"><a href="#输出参数含义" class="headerlink" title="输出参数含义"></a>输出参数含义</h2><p>每一行都是一条系统调用，等号左边是系统调用的函数名及其参数，右边是该调用的返回值。 strace 显示这些调用的参数并返回符号形式的值。strace 从内核接收信息，而且不需要以任何特殊的方式来构建内核。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$strace</span> <span class="built_in">cat</span> /dev/null</span><br><span class="line">execve(<span class="string">&quot;/bin/cat&quot;</span>, [<span class="string">&quot;cat&quot;</span>, <span class="string">&quot;/dev/null&quot;</span>], [/* 22 vars */]) = 0</span><br><span class="line">brk(0)                                  = 0xab1000</span><br><span class="line">access(<span class="string">&quot;/etc/ld.so.nohwcap&quot;</span>, F_OK)      = -1 ENOENT (No such file or directory)</span><br><span class="line">mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f29379a7000</span><br><span class="line">access(<span class="string">&quot;/etc/ld.so.preload&quot;</span>, R_OK)      = -1 ENOENT (No such file or directory)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><p><code>-c</code> 统计每一系统调用的所执行的时间,次数和出错的次数等.<br><code>-d</code> 输出strace关于标准错误的调试信息.<br><code>-f</code> 跟踪由fork调用所产生的子进程.<br><code>-ff</code> 如果提供-o filename,则所有进程的跟踪结果输出到相应的filename.pid中,pid是各进程的进程号.<br><code>-F</code> 尝试跟踪vfork调用.在-f时,vfork不被跟踪.<br><code>-h</code> 输出简要的帮助信息.<br><code>-i</code> 输出系统调用的入口指针.<br><code>-q</code> 禁止输出关于脱离的消息.<br><code>-r</code> 打印出相对时间关于,,每一个系统调用.<br><code>-t</code> 在输出中的每一行前加上时间信息.<br><code>-tt</code> 在输出中的每一行前加上时间信息,微秒级.<br><code>-ttt</code> 微秒级输出,以秒了表示时间.<br><code>-T</code> 显示每一调用所耗的时间.<br><code>-v</code> 输出所有的系统调用.一些调用关于环境变量,状态,输入输出等调用由于使用频繁,默认不输出.<br><code>-V</code> 输出strace的版本信息.<br><code>-x</code> 以十六进制形式输出非标准字符串<br><code>-xx</code> 所有字符串以十六进制形式输出.<br><code>-a</code> column<br>设置返回值的输出位置.默认 为40.<br><code>-e expr</code><br>指定一个表达式,用来控制如何跟踪.格式如下:<br>[qualifier=][!]value1[,value2]…<br>qualifier只能是 trace,abbrev,verbose,raw,signal,read,write其中之一.value是用来限定的符号或数字.默认的 qualifier是 trace.感叹号是否定符号.例如:<br>-eopen等价于 -e trace=open,表示只跟踪open调用.而-e trace!=open表示跟踪除了open以外的其他调用.有两个特殊的符号 all 和 none.<br>注意有些shell使用!来执行历史记录里的命令,所以要使用\.<br><code>-e trace=set</code><br>只跟踪指定的系统 调用.例如:-e trace=open,close,rean,write表示只跟踪这四个系统调用.默认的为set=all.<br><code>-e trace=file</code><br>只跟踪有关文件操作的系统调用.<br><code>-e trace=process</code><br>只跟踪有关进程控制的系统调用.<br><code>-e trace=network</code><br>跟踪与网络有关的所有系统调用.<br><code>-e trace=signal</code><br>跟踪所有与系统信号有关的 系统调用<br><code>-e trace=ipc</code><br>跟踪所有与进程通讯有关的系统调用<br><code>-e abbrev=set</code><br>设定 strace输出的系统调用的结果集.-v 等与 abbrev=none.默认为abbrev=all.<br><code>-e raw=set</code><br>将指 定的系统调用的参数以十六进制显示.<br><code>-e signal=set</code><br>指定跟踪的系统信号.默认为all.如 signal=!SIGIO(或者signal=!io),表示不跟踪SIGIO信号.<br><code>-e read=set</code><br>输出从指定文件中读出 的数据.例如:<br><code>-e read=3,5</code><br><code>-e write=set</code><br>输出写入到指定文件中的数据.<br><code>-o filename</code><br>将strace的输出写入文件filename<br><code>-p pid</code><br>跟踪指定的进程pid.<br><code>-s strsize</code><br>指定输出的字符串的最大长度.默认为32.文件名一直全部输出.<br><code>-u username</code><br>以username 的UID和GID执行被跟踪的命令</p>
<h2 id="命令实例"><a href="#命令实例" class="headerlink" title="命令实例"></a>命令实例</h2><p>跟踪可执行程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">strace -f -F -o ~/straceout.txt myserver</span><br></pre></td></tr></table></figure>
<p><code>-f -F</code>选项告诉strace同时跟踪fork和vfork出来的进程<br><code>-o</code>选项把所有strace输出写到~/straceout.txt里 面，myserver是要启动和调试的程序。</p>
<p>跟踪服务程序</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">strace -o output.txt -T -tt -e trace=all -p 28979</span><br></pre></td></tr></table></figure>
<p>跟踪28979进程的所有系统调用（-e trace=all），并统计系统调用的花费时间，以及开始时间（并以可视化的时分秒格式显示），最后将记录结果存在output.txt文件里面。</p>
]]></content>
      <categories>
        <category>进程调试</category>
      </categories>
      <tags>
        <tag>strace</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb</title>
    <url>/2020/09/22/gdb/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>GDB是一个由GNU开源组织发布的、UNIX/LINUX操作系统下的、基于命令行的、功能强大的程序调试工具。 对于一名Linux下工作的c/c++程序员，gdb是必不可少的工具。</p>
<span id="more"></span>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>对C/C++程序的调试，需要在编译前就加上-g选项:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$g</span>++ -g hello.cpp -o hello</span><br></pre></td></tr></table></figure>
<p>调试可执行文件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$gdb</span> &lt;program&gt;</span><br></pre></td></tr></table></figure>
<p>program也就是你的执行文件，一般在当前目录下。</p>
<p>调试core文件(core是程序非法执行后core dump后产生的文件):</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$gdb</span> &lt;program&gt; &lt;core dump file&gt;</span><br><span class="line"><span class="variable">$gdb</span> program core.11127</span><br></pre></td></tr></table></figure>

<p>调试服务程序:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$gdb</span> &lt;program&gt; &lt;PID&gt;</span><br><span class="line"><span class="variable">$gdb</span> hello 11127</span><br></pre></td></tr></table></figure>
<p>如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他。program应该在PATH环境变量中搜索得到。</p>
<h2 id="gdb交互命令"><a href="#gdb交互命令" class="headerlink" title="gdb交互命令"></a>gdb交互命令</h2><p>启动gdb后，进入到交互模式，通过以下命令完成对程序的调试；注意高频使用的命令一般都会有缩写，熟练使用这些缩写命令能提高调试的效率；</p>
<h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p><code>run</code>：简记为<code>r</code> ，其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。<br><code>continue</code> （简写<code>c</code> ）：继续执行，到下一个断点处（或运行结束）<br><code>next</code>：（简写 <code>n</code>），单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内。<br><code>step</code> （简写<code>s</code>）：单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的<br><code>until</code>：当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。<br><code>until+行号</code>或者<code>adv+行号</code>： 运行至某行，不仅仅用来跳出循环<br><code>finish</code>： 运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。<br><code>call 函数(参数)</code>：调用程序中可见的函数，并传递“参数”，如：<code>call gdb_test(55)</code><br><code>quit</code>：简记为 <code>q</code> ，退出gdb</p>
<h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><p><code>break n</code> （简写<code>b n</code>）:在第n行处设置断点<br>（可以带上代码路径和代码名称： <code>b OAGUPDATE.cpp:578</code>）<br><code>b fn1 if a＞b</code>：条件断点设置<br><code>break func（break缩写为b）</code>：在函数func()的入口处设置断点，如：<code>break cb_button</code><br><code>delete 断点号n</code>：删除第n个断点<br><code>disable 断点号n</code>：暂停第n个断点<br><code>enable 断点号n</code>：开启第n个断点<br><code>clear 行号n</code>：清除第n行的断点<br><code>info b （info breakpoints）</code> ：显示当前程序的断点设置情况<br><code>delete breakpoints</code>：清除所有断点</p>
<h3 id="查看源代码"><a href="#查看源代码" class="headerlink" title="查看源代码"></a>查看源代码</h3><p><code>list</code> ：简记为 <code>l</code> ，其作用就是列出程序的源代码，默认每次显示10行。<br><code>list 行号</code>：将显示当前文件以“行号”为中心的前后10行代码，如：list 12<br><code>list 函数名</code>：将显示“函数名”所在函数的源代码，如：<code>list main</code><br><code>list</code> ：不带参数，将接着上一次 list 命令的，输出下边的内容。</p>
<h3 id="打印表达式"><a href="#打印表达式" class="headerlink" title="打印表达式"></a>打印表达式</h3><p><code>print 表达式</code>：简记为 <code>p</code> ，其中“表达式”可以是任何当前正在被测试程序的有效表达式，比如当前正在调试C语言的程序，那么“表达式”可以是任何C语言的有效表达式，包括数字，变量甚至是函数调用。<br><code>print a</code>：将显示整数 a 的值<br><code>print ++a</code>：将把 a 中的值加1,并显示出来<br><code>print name</code>：将显示字符串 name 的值<br><code>print gdb_test(22)</code>：将以整数22作为参数调用 gdb_test() 函数<br><code>print gdb_test(a)</code>：将以变量 a 作为参数调用 gdb_test() 函数<br><code>display 表达式</code>：在单步运行时将非常有用，使用display命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值。如： <code>display a</code><br><code>watch 表达式</code>：设置一个监视点，一旦被监视的“表达式”的值改变，gdb将强行终止正在被调试的程序。如： <code>watch a</code><br><code>whatis</code> ：查询变量或函数<br><code>info function</code>： 查询函数<br>扩展<code>info locals</code>： 显示当前堆栈页的所有变量</p>
<h3 id="查询运行信息"><a href="#查询运行信息" class="headerlink" title="查询运行信息"></a>查询运行信息</h3><p><code>where/bt</code> ：当前运行的堆栈列表；<br><code>bt</code> backtrace 显示当前调用堆栈<br><code>up/down</code> 改变堆栈显示的深度<br><code>set args</code> 参数:指定运行时的参数<br><code>show args</code>：查看设置好的参数<br><code>info program</code>： 来查看程序的是否在运行，进程号，被暂停的原因。<br><code>info variables</code>：查看全局和静态变量<br><code>info locals</code>：查看当前stack frame局部变量<br><code>info args</code>：查看当前stack frame参数</p>
<h3 id="分割窗口"><a href="#分割窗口" class="headerlink" title="分割窗口"></a>分割窗口</h3><p><code>layout</code>：用于分割窗口，可以一边查看代码，一边测试：<br><code>layout src</code>：显示源代码窗口<br><code>layout asm</code>：显示反汇编窗口<br><code>layout regs</code>：显示源代码/反汇编和CPU寄存器窗口<br><code>layout split</code>：显示源代码和反汇编窗口<br><code>Ctrl + L</code>：刷新窗口</p>
<h3 id="多线程调试"><a href="#多线程调试" class="headerlink" title="多线程调试"></a>多线程调试</h3><p><code>info threads</code>: 查看执行线程号<br><code>threads 线程号n</code>：进入到第n个线程<br><code>set scheduler-locking on</code> ： 多线程下禁止线程切换<br>编译选项<code>-g3</code>可以调试宏</p>
<h3 id="终端显示代码"><a href="#终端显示代码" class="headerlink" title="终端显示代码"></a>终端显示代码</h3><p><code>export TERM=xterm</code>：设置终端格式<br><code>ctrl + x + a</code>: 在gdb终端显示代码，此时代码目录需要被指定<br><code>dir</code>: 用来指定源文件目录<br>批量指定目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># find /opt/apigw/gwhw/src/hw/gw_parser -type d &gt; srcdir.cmd</span></span><br><span class="line"><span class="comment"># sed -i &#x27;s/^/dir /g&#x27; srcdir.cmd </span></span><br><span class="line">(gdb) <span class="built_in">source</span> srcdir1.cmd </span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure>
<p>指定具体某个目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">(gdb) <span class="built_in">dir</span> /home/alipms/mr_work/prj_proc/commonLib/src/rtec</span><br><span class="line">Source directories searched: /home/alipms/mr_work/prj_proc/commonLib/src/rtec:<span class="variable">$cdir</span>:<span class="variable">$cwd</span></span><br><span class="line"></span><br><span class="line">(gdb) <span class="built_in">dir</span> /home/alipms/mr_work/ddi_cache/src/policy</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>进程调试</category>
      </categories>
      <tags>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>pstack</title>
    <url>/2020/09/21/pstack/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>pstack是一个脚本工具，可显示每个进程的栈跟踪。pstack 命令必须由相应进程的属主或 root 运行。其核心实现就是使用了gdb以及thread apply all bt命令;</p>
<p>语法:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$pstrack</span> &lt;program-pid&gt;</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="脚本实现"><a href="#脚本实现" class="headerlink" title="脚本实现"></a>脚本实现</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> <span class="variable">$#</span> -ne 1; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Usage: `basename <span class="variable">$0</span> .sh` &lt;process-id&gt;&quot;</span> 1&gt;&amp;2</span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> ! -r /proc/<span class="variable">$1</span>; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Process <span class="variable">$1</span> not found.&quot;</span> 1&gt;&amp;2</span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># GDB doesn&#x27;t allow &quot;thread apply all bt&quot; when the process isn&#x27;t</span></span><br><span class="line"><span class="comment"># threaded; need to peek at the process to determine if that or the</span></span><br><span class="line"><span class="comment"># simpler &quot;bt&quot; should be used.</span></span><br><span class="line"></span><br><span class="line">backtrace=<span class="string">&quot;bt&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> -d /proc/<span class="variable">$1</span>/task ; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># Newer kernel; has a task/ directory.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">test</span> `/bin/ls /proc/<span class="variable">$1</span>/task | /usr/bin/wc -l` -gt 1 2&gt;/dev/null ; <span class="keyword">then</span></span><br><span class="line">	backtrace=<span class="string">&quot;thread apply all bt&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">test</span> -f /proc/<span class="variable">$1</span>/maps ; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># Older kernel; go by it loading libpthread.</span></span><br><span class="line">    <span class="keyword">if</span> /bin/grep -e libpthread /proc/<span class="variable">$1</span>/maps &gt; /dev/null 2&gt;&amp;1 ; <span class="keyword">then</span></span><br><span class="line">	backtrace=<span class="string">&quot;thread apply all bt&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">GDB=<span class="variable">$&#123;GDB:-gdb&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Run GDB, strip out unwanted noise.</span></span><br><span class="line"><span class="comment"># --readnever is no longer used since .gdb_index is now in use.</span></span><br><span class="line"><span class="variable">$GDB</span> --quiet -nx <span class="variable">$GDBARGS</span> /proc/<span class="variable">$1</span>/exe <span class="variable">$1</span> &lt;&lt;<span class="string">EOF 2&gt;&amp;1 | </span></span><br><span class="line"><span class="string">set width 0</span></span><br><span class="line"><span class="string">set height 0</span></span><br><span class="line"><span class="string">set pagination no</span></span><br><span class="line"><span class="string">$backtrace</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">/bin/sed -n \</span><br><span class="line">    -e <span class="string">&#x27;s/^\((gdb) \)*//&#x27;</span> \</span><br><span class="line">    -e <span class="string">&#x27;/^#/p&#x27;</span> \</span><br><span class="line">    -e <span class="string">&#x27;/^Thread/p&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pstack 4551</span><br><span class="line">Thread 7 (Thread 1084229984 (LWP 4552)):</span><br><span class="line"><span class="comment">#0  0x000000302afc63dc in epoll_wait () from /lib64/tls/libc.so.6</span></span><br><span class="line"><span class="comment">#1  0x00000000006f0730 in ub::EPollEx::poll ()</span></span><br><span class="line"><span class="comment">#2  0x00000000006f172a in ub::NetReactor::callback ()</span></span><br><span class="line"><span class="comment">#3  0x00000000006fbbbb in ub::UBTask::CALLBACK ()</span></span><br><span class="line"><span class="comment">#4  0x000000302b80610a in start_thread () from /lib64/tls/libpthread.so.0</span></span><br><span class="line"><span class="comment">#5  0x000000302afc6003 in clone () from /lib64/tls/libc.so.6</span></span><br><span class="line"><span class="comment">#6  0x0000000000000000 in ?? ()</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>进程调试</category>
      </categories>
      <tags>
        <tag>pstack</tag>
      </tags>
  </entry>
  <entry>
    <title>awk数据流处理工具</title>
    <url>/2020/09/20/awk%E6%95%B0%E6%8D%AE%E6%B5%81%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="awk脚本结构"><a href="#awk脚本结构" class="headerlink" title="awk脚本结构"></a>awk脚本结构</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27; BEGIN&#123; statements &#125; statements2 END&#123; statements &#125; &#x27;</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h2><ol>
<li>执行begin中语句块；</li>
<li>从文件或stdin中读入一行，然后执行statements2，重复这个过程，直到文件全部被读取完毕；</li>
<li>执行end语句块；</li>
</ol>
<h2 id="print-打印当前行"><a href="#print-打印当前行" class="headerlink" title="print 打印当前行"></a>print 打印当前行</h2><p>使用不带参数的print时，会打印当前行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;line1\nline2&quot;</span> | awk <span class="string">&#x27;BEGIN&#123;print &quot;start&quot;&#125; &#123;print &#125; END&#123; print &quot;End&quot; &#125;&#x27;</span></span><br><span class="line">start</span><br><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">End</span><br></pre></td></tr></table></figure>

<p>print 以逗号分割时，参数以空格定界;</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> | awk <span class="string">&#x27; &#123;var1 = &quot;v1&quot; ; var2 = &quot;V2&quot;; var3=&quot;v3&quot;; print var1, var2 , var3; &#125;&#x27;</span></span><br><span class="line">v1 V2 v3</span><br></pre></td></tr></table></figure>
<p>使用-拼接符的方式（””作为拼接符）;</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> | awk <span class="string">&#x27; &#123;var1 = &quot;v1&quot; ; var2 = &quot;V2&quot;; var3=&quot;v3&quot;; print var1&quot;-&quot;var2&quot;-&quot;var3; &#125;&#x27;</span></span><br><span class="line">v1-V2-v3</span><br></pre></td></tr></table></figure>

<h2 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h2><p><code>NR</code>:表示记录数量，在执行过程中对应当前行号；<br><code>NF</code>:表示字段数量，在执行过程总对应当前行的字段数；<br><code>$0</code>:这个变量包含执行过程中当前行的文本内容；<br><code>$1</code>:第一个字段的文本内容；<br><code>$2</code>:第二个字段的文本内容；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;line1 f2 f3\n line2 \n line 3&quot;</span> | awk <span class="string">&#x27;&#123;print NR&quot;:&quot;$1&quot;-&quot;$2&#125;&#x27;</span></span><br><span class="line">1:line1-f2</span><br><span class="line">2:line2-</span><br><span class="line">3:line-3</span><br></pre></td></tr></table></figure>

<p>打印每一行的第二和第三个字段</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;&#123;print $2, $3&#125;&#x27;</span> file</span><br></pre></td></tr></table></figure>
<p>统计文件的行数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27; END &#123;print NR&#125;&#x27;</span> file</span><br></pre></td></tr></table></figure>
<h2 id="累加每一行的第一个字段"><a href="#累加每一行的第一个字段" class="headerlink" title="累加每一行的第一个字段"></a>累加每一行的第一个字段</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> -e <span class="string">&quot;1\n 2\n 3\n 4\n&quot;</span> | awk <span class="string">&#x27;BEGIN&#123;num = 0&#125; &#123;sum += $1;&#125; END &#123;print sum &#125;&#x27;</span></span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<h2 id="传递外部变量"><a href="#传递外部变量" class="headerlink" title="传递外部变量"></a>传递外部变量</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var=1000</span><br><span class="line"><span class="built_in">echo</span> | awk <span class="string">&#x27;&#123;print vara&#125;&#x27;</span> vara=<span class="variable">$var</span> <span class="comment">#  输入来自stdin</span></span><br><span class="line">awk <span class="string">&#x27;&#123;print vara&#125;&#x27;</span> vara=<span class="variable">$var</span> file <span class="comment"># 输入来自文件</span></span><br></pre></td></tr></table></figure>
<h2 id="用样式对awk处理的行进行过滤"><a href="#用样式对awk处理的行进行过滤" class="headerlink" title="用样式对awk处理的行进行过滤"></a>用样式对awk处理的行进行过滤</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;NR &lt; 5&#x27;</span> <span class="comment">#行号小于5</span></span><br><span class="line">awk <span class="string">&#x27;NR==1,NR==4 &#123;print&#125;&#x27;</span> file <span class="comment">#行号等于1和4的打印出来</span></span><br><span class="line">awk <span class="string">&#x27;/linux/&#x27;</span> <span class="comment">#包含linux文本的行（可以用正则表达式来指定，超级强大）</span></span><br><span class="line">awk <span class="string">&#x27;!/linux/&#x27;</span> <span class="comment">#不包含linux文本的行</span></span><br></pre></td></tr></table></figure>
<h2 id="设置定界符"><a href="#设置定界符" class="headerlink" title="设置定界符"></a>设置定界符</h2><p>使用-F来设置定界符（默认为空格）:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk -F: <span class="string">&#x27;&#123;print $NF&#125;&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure>
<h2 id="读取命令输出"><a href="#读取命令输出" class="headerlink" title="读取命令输出"></a>读取命令输出</h2><p>使用getline，将外部shell命令的输出读入到变量cmdout中:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> | awk <span class="string">&#x27;&#123;&quot;grep root /etc/passwd&quot; | getline cmdout; print cmdout &#125;&#x27;</span></span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br></pre></td></tr></table></figure>

<h2 id="在awk中使用循环"><a href="#在awk中使用循环" class="headerlink" title="在awk中使用循环"></a>在awk中使用循环</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=0;i&lt;10;i++)&#123;<span class="built_in">print</span> <span class="variable">$i</span>;&#125;</span><br><span class="line"><span class="keyword">for</span>(i <span class="keyword">in</span> array)&#123;<span class="built_in">print</span> array[i];&#125;</span><br></pre></td></tr></table></figure>

<p>以逆序的形式打印行：(tac命令的实现）:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">seq</span> 9| \</span><br><span class="line">awk <span class="string">&#x27;&#123;lifo[NR] = $0; lno=NR&#125; \</span></span><br><span class="line"><span class="string">END&#123; for(;lno&gt;-1;lno--)&#123;print lifo[lno];&#125;</span></span><br><span class="line"><span class="string">&#125; &#x27;</span>\</span><br></pre></td></tr></table></figure>
<p>等同于<code>seq 9|tac</code></p>
<p>awk结合grep找到指定的服务，然后将其kill掉</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef| grep msv8 | grep -v MFORWARD | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> | xargs <span class="built_in">kill</span> -9;</span><br></pre></td></tr></table></figure>

<h2 id="打印指定列"><a href="#打印指定列" class="headerlink" title="打印指定列"></a>打印指定列</h2><p>awk方式实现</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -lrt | awk <span class="string">&#x27;&#123;print $6&#125;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>cut方式实现</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -lrt | <span class="built_in">cut</span> -f6</span><br></pre></td></tr></table></figure>

<h2 id="打印指定文本区域"><a href="#打印指定文本区域" class="headerlink" title="打印指定文本区域"></a>打印指定文本区域</h2><p>确定行号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">seq</span> 100| awk <span class="string">&#x27;NR==4,NR==6&#123;print&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>确定文本<br>打印处于start_pattern 和end_pattern之间的文本:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">awk <span class="string">&#x27;/start_pattern/, /end_pattern/&#x27;</span> filename</span><br></pre></td></tr></table></figure>

<p>示例:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">seq</span> 100 | awk <span class="string">&#x27;/13/,/15/&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="awk常用内建函数"><a href="#awk常用内建函数" class="headerlink" title="awk常用内建函数"></a>awk常用内建函数</h2><p><code>index(string,search_string)</code>:返回search_string在string中出现的位置<br><code>sub(regex,replacement_str,string)</code>:将正则匹配到的第一处内容替换为replacement_str;<br><code>match(regex,string)</code>:检查正则表达式是否能够匹配字符串；<br><code>length(string)</code>：返回字符串长度</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> | awk <span class="string">&#x27;&#123;&quot;grep root /etc/passwd&quot; | getline cmdout; print length(cmdout) &#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>printf 类似c语言中的printf，对输出进行格式化:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">seq</span> 10 | awk <span class="string">&#x27;&#123;printf &quot;-&gt;%4s\n&quot;, $1&#125;&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SHELL</category>
      </categories>
      <tags>
        <tag>awk</tag>
      </tags>
  </entry>
  <entry>
    <title>sed文本替换利器</title>
    <url>/2020/09/19/sed%E6%96%87%E6%9C%AC%E6%9B%BF%E6%8D%A2%E5%88%A9%E5%99%A8/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>sed 是一种流编辑器，它是文本处理中非常重要的工具，能够完美的配合正则表达式使用，功能不同凡响。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。</p>
<span id="more"></span>

<h2 id="sed的选项、命令、替换标记"><a href="#sed的选项、命令、替换标记" class="headerlink" title="sed的选项、命令、替换标记"></a>sed的选项、命令、替换标记</h2><h3 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed [options] <span class="string">&#x27;command&#x27;</span> file(s)</span><br><span class="line">sed [options] -f scriptfile file(s)</span><br></pre></td></tr></table></figure>

<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p><code>-e&lt;script&gt;或--expression=&lt;script&gt;</code>：以选项中的指定的script来处理输入的文本文件；<br><code>-f&lt;script文件&gt;或--file=&lt;script文件&gt;</code>：以选项中指定的script文件来处理输入的文本文件；<br><code>-h或--help</code>：显示帮助；<br><code>-n或--quiet或——silent</code>：仅显示script处理后的结果；<br><code>-V或--version</code>：显示版本信息。</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>文件：指定待处理的文本文件列表。</p>
<h3 id="sed命令"><a href="#sed命令" class="headerlink" title="sed命令"></a>sed命令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a\ <span class="comment"># 在当前行下面插入文本。</span></span><br><span class="line">i\ <span class="comment"># 在当前行上面插入文本。</span></span><br><span class="line">c\ <span class="comment"># 把选定的行改为新的文本。</span></span><br><span class="line">d <span class="comment"># 删除，删除选择的行。</span></span><br><span class="line">D <span class="comment"># 删除模板块的第一行。</span></span><br><span class="line">s <span class="comment"># 替换指定字符</span></span><br><span class="line">h <span class="comment"># 拷贝模板块的内容到内存中的缓冲区。</span></span><br><span class="line">H <span class="comment"># 追加模板块的内容到内存中的缓冲区。</span></span><br><span class="line">g <span class="comment"># 获得内存缓冲区的内容，并替代当前模板块中的文本。</span></span><br><span class="line">G <span class="comment"># 获得内存缓冲区的内容，并追加到当前模板块文本的后面。</span></span><br><span class="line">l <span class="comment"># 列表不能打印字符的清单。</span></span><br><span class="line">n <span class="comment"># 读取下一个输入行，用下一个命令处理新的行而不是用第一个命令。</span></span><br><span class="line">N <span class="comment"># 追加下一个输入行到模板块后面并在二者间嵌入一个新行，改变当前行号码。</span></span><br><span class="line">p <span class="comment"># 打印模板块的行。</span></span><br><span class="line">P <span class="comment"># (大写) 打印模板块的第一行。</span></span><br><span class="line">q <span class="comment"># 退出Sed。</span></span><br><span class="line">b lable <span class="comment"># 分支到脚本中带有标记的地方，如果分支不存在则分支到脚本的末尾。</span></span><br><span class="line">r file <span class="comment"># 从file中读行。</span></span><br><span class="line">t label <span class="comment"># if分支，从最后一行开始，条件一旦满足或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。</span></span><br><span class="line">T label <span class="comment"># 错误分支，从最后一行开始，一旦发生错误或者T，t命令，将导致分支到带有标号的命令处，或者到脚本的末尾。</span></span><br><span class="line">w file <span class="comment"># 写并追加模板块到file末尾。  </span></span><br><span class="line">W file <span class="comment"># 写并追加模板块的第一行到file末尾。  </span></span><br><span class="line">! <span class="comment"># 表示后面的命令对所有没有被选定的行发生作用。  </span></span><br><span class="line">= <span class="comment"># 打印当前行号码。  </span></span><br><span class="line"><span class="comment"># # 把注释扩展到下一个换行符以前。 </span></span><br></pre></td></tr></table></figure>

<h3 id="sed替换标记"><a href="#sed替换标记" class="headerlink" title="sed替换标记"></a>sed替换标记</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g <span class="comment"># 表示行内全面替换。  </span></span><br><span class="line">p <span class="comment"># 表示打印行。  </span></span><br><span class="line">w <span class="comment"># 表示把行写入一个文件。  </span></span><br><span class="line">x <span class="comment"># 表示互换模板块中的文本和缓冲区中的文本。  </span></span><br><span class="line">y <span class="comment"># 表示把一个字符翻译为另外的字符（但是不用于正则表达式）</span></span><br><span class="line">\1 <span class="comment"># 子串匹配标记</span></span><br><span class="line">&amp; <span class="comment"># 已匹配字符串标记</span></span><br></pre></td></tr></table></figure>

<h3 id="sed元字符集"><a href="#sed元字符集" class="headerlink" title="sed元字符集"></a>sed元字符集</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">^ <span class="comment"># 匹配行开始，如：/^sed/匹配所有以sed开头的行。</span></span><br><span class="line">$ <span class="comment"># 匹配行结束，如：/sed$/匹配所有以sed结尾的行。</span></span><br><span class="line">. <span class="comment"># 匹配一个非换行符的任意字符，如：/s.d/匹配s后接一个任意字符，最后是d。</span></span><br><span class="line">* <span class="comment"># 匹配0个或多个字符，如：/*sed/匹配所有模板是一个或多个空格后紧跟sed的行。</span></span><br><span class="line">[] <span class="comment"># 匹配一个指定范围内的字符，如/[sS]ed/匹配sed和Sed。  </span></span><br><span class="line">[^] <span class="comment"># 匹配一个不在指定范围内的字符，如：/[^A-RT-Z]ed/匹配不包含A-R和T-Z的一个字母开头，紧跟ed的行。</span></span><br><span class="line">\(..\) <span class="comment"># 匹配子串，保存匹配的字符，如s/\(love\)able/\1rs，loveable被替换成lovers。</span></span><br><span class="line">&amp; <span class="comment"># 保存搜索字符用来替换其他字符，如s/love/ **&amp;** /，love这成 **love** 。</span></span><br><span class="line">\&lt; <span class="comment"># 匹配单词的开始，如:/\&lt;love/匹配包含以love开头的单词的行。</span></span><br><span class="line">\&gt; <span class="comment"># 匹配单词的结束，如/love\&gt;/匹配包含以love结尾的单词的行。</span></span><br><span class="line">x\&#123;m\&#125; <span class="comment"># 重复字符x，m次，如：/0\&#123;5\&#125;/匹配包含5个0的行。</span></span><br><span class="line">x\&#123;m,\&#125; <span class="comment"># 重复字符x，至少m次，如：/0\&#123;5,\&#125;/匹配至少有5个0的行。</span></span><br><span class="line">x\&#123;m,n\&#125; <span class="comment"># 重复字符x，至少m次，不多于n次，如：/0\&#123;5,10\&#125;/匹配5~10个0的行。  </span></span><br></pre></td></tr></table></figure>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="替换操作：s命令"><a href="#替换操作：s命令" class="headerlink" title="替换操作：s命令"></a>替换操作：s命令</h3><p>替换文本中的字符串：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/book/books/&#x27;</span> file</span><br></pre></td></tr></table></figure>
<p>-n选项 和 p命令 一起使用表示只打印那些发生替换的行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -n <span class="string">&#x27;s/test/TEST/p&#x27;</span> file</span><br></pre></td></tr></table></figure>
<p>直接编辑文件 选项-i ，会匹配file文件中每一行的所有book替换为books：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s/book/books/g&#x27;</span> file</span><br></pre></td></tr></table></figure>
<p>全面替换标记g<br>使用后缀 /g 标记会替换每一行中的所有匹配：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/book/books/g&#x27;</span> file</span><br></pre></td></tr></table></figure>
<p>当需要从第N处匹配开始替换时，可以使用 /Ng：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> sksksksksksk | sed <span class="string">&#x27;s/sk/SK/2g&#x27;</span></span><br><span class="line">skSKSKSKSKSK</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> sksksksksksk | sed <span class="string">&#x27;s/sk/SK/3g&#x27;</span></span><br><span class="line">skskSKSKSKSK</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> sksksksksksk | sed <span class="string">&#x27;s/sk/SK/4g&#x27;</span></span><br><span class="line">skskskSKSKSK</span><br></pre></td></tr></table></figure>

<h3 id="定界符"><a href="#定界符" class="headerlink" title="定界符"></a>定界符</h3><p>以上命令中字符 / 在sed中作为定界符使用，也可以使用任意的定界符：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;s:test:TEXT:g&#x27;</span></span><br><span class="line">sed <span class="string">&#x27;s|test|TEXT|g&#x27;</span></span><br></pre></td></tr></table></figure>
<p>定界符出现在样式内部时，需要进行转义：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/\/bin/\/usr\/local\/bin/g&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="删除操作：d命令"><a href="#删除操作：d命令" class="headerlink" title="删除操作：d命令"></a>删除操作：d命令</h3><p>删除空白行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;/^$/d&#x27;</span> file</span><br></pre></td></tr></table></figure>
<p>删除文件的第2行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;2d&#x27;</span> file</span><br></pre></td></tr></table></figure>
<p>删除文件的第2行到末尾所有行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;2,$d&#x27;</span> file</span><br></pre></td></tr></table></figure>
<p>删除文件最后一行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;$d&#x27;</span> file</span><br></pre></td></tr></table></figure>
<p>删除文件中所有开头是test的行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;/^test/&#x27;</span>d file</span><br></pre></td></tr></table></figure>

<h3 id="已匹配字符串标记-amp"><a href="#已匹配字符串标记-amp" class="headerlink" title="已匹配字符串标记&amp;"></a>已匹配字符串标记&amp;</h3><p>正则表达式 \w+ 匹配每一个单词，使用 [&amp;] 替换它，&amp; 对应于之前所匹配到的单词：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> this is a <span class="built_in">test</span> line | sed <span class="string">&#x27;s/\w\+/[&amp;]/g&#x27;</span></span><br><span class="line">[this] [is] [a] [<span class="built_in">test</span>] [line]</span><br></pre></td></tr></table></figure>
<p>所有以192.168.0.1开头的行都会被替换成它自已加localhost：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;s/^192.168.0.1/&amp;localhost/&#x27;</span> file</span><br><span class="line">192.168.0.1localhost</span><br></pre></td></tr></table></figure>

<h3 id="子串匹配标记-1"><a href="#子串匹配标记-1" class="headerlink" title="子串匹配标记\1"></a>子串匹配标记\1</h3><p>匹配给定样式的其中一部分：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> this is digit 7 <span class="keyword">in</span> a number | sed <span class="string">&#x27;s/digit \([0-9]\)/\1/&#x27;</span></span><br><span class="line">this is 7 <span class="keyword">in</span> a number</span><br></pre></td></tr></table></figure>

<p>对于匹配到的第一个子串就标记为 \1 ，依此类推匹配到的第二个结果就是 \2 ，例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> aaa BBB | sed <span class="string">&#x27;s/\([a-z]\+\) \([A-Z]\+\)/\2 \1/&#x27;</span></span><br><span class="line">BBB aaa</span><br></pre></td></tr></table></figure>

<p>通过替换获取ip：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig ens32 | sed -n <span class="string">&#x27;/inet /p&#x27;</span> | sed <span class="string">&#x27;s/inet \([0-9.]\+\).*/\1/&#x27;</span></span><br><span class="line">192.168.75.126</span><br></pre></td></tr></table></figure>

<h3 id="大小写转换U-L"><a href="#大小写转换U-L" class="headerlink" title="大小写转换U/L"></a>大小写转换U/L</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">\u：	首字母转换为大写</span><br><span class="line">\U：  全部转换为大写</span><br><span class="line">\l：	 首字母转换为小写</span><br><span class="line">\L：	 全部转换为小写</span><br></pre></td></tr></table></figure>

<p>首字母转换为大写：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node6 ~]<span class="comment"># sed &#x27;s/^[a-z]\+/\u&amp;/&#x27; passwd </span></span><br><span class="line">Root:x:0:0:root:/root:/bin/bash</span><br><span class="line">Bin:x:1:1:bin:/bin:/sbin/nologin</span><br><span class="line">Daemon:x:2:2:daemon:/sbin:/sbin/nologin</span><br><span class="line">Adm:x:3:4:adm:/var/adm:/sbin/nologin</span><br><span class="line">Lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin</span><br><span class="line">Sync:x:5:0:<span class="built_in">sync</span>:/sbin:/bin/sync</span><br></pre></td></tr></table></figure>

<p>匹配到的字符全部转换为大写：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node6 ~]<span class="comment"># sed &#x27;s/^[a-z]\+/\U&amp;/&#x27; passwd </span></span><br><span class="line">ROOT:x:0:0:root:/root:/bin/bash</span><br><span class="line">BIN:x:1:1:bin:/bin:/sbin/nologin</span><br></pre></td></tr></table></figure>

<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>sed表达式可以使用单引号来引用，但是如果表达式内部包含变量字符串，就需要使用双引号。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">test</span>=hello</span><br><span class="line"><span class="built_in">echo</span> hello WORLD | sed <span class="string">&quot;s/<span class="variable">$test</span>/HELLO&quot;</span></span><br><span class="line">HELLO WORLD</span><br></pre></td></tr></table></figure>

<h3 id="选定行的范围：-（逗号）"><a href="#选定行的范围：-（逗号）" class="headerlink" title="选定行的范围：,（逗号）"></a>选定行的范围：,（逗号）</h3><p>所有在模板test和check所确定的范围内的行都被打印：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -n <span class="string">&#x27;/test/,/check/p&#x27;</span> file</span><br></pre></td></tr></table></figure>
<p>打印从第5行开始到第一个包含以test开始的行之间的所有行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -n <span class="string">&#x27;5,/^test/p&#x27;</span> file</span><br></pre></td></tr></table></figure>
<p>对于模板test和west之间的行，每行的末尾用字符串aaa bbb替换：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;/test/,/west/s/$/aaa bbb/&#x27;</span> file</span><br></pre></td></tr></table></figure>

<h3 id="多点编辑：e命令"><a href="#多点编辑：e命令" class="headerlink" title="多点编辑：e命令"></a>多点编辑：e命令</h3><p>-e选项允许在同一行里执行多条命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -e <span class="string">&#x27;1,5d&#x27;</span> -e <span class="string">&#x27;s/test/check/&#x27;</span> file</span><br></pre></td></tr></table></figure>
<p>上面sed表达式的第一条命令删除1至5行，第二条命令用check替换test。命令的执行顺序对结果有影响。如果两个命令都是替换命令，那么第一个替换命令将影响第二个替换命令的结果。</p>
<h3 id="追加（行下）：a-命令"><a href="#追加（行下）：a-命令" class="headerlink" title="追加（行下）：a\命令"></a>追加（行下）：a\命令</h3><p>将 this is a test line 追加到 以test 开头的行后面：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;/^test/a\this is a test line&#x27;</span> file</span><br></pre></td></tr></table></figure>

<p>在 test.conf 文件第2行之后插入 this is a test line：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;2a\this is a test line&#x27;</span> test.conf</span><br></pre></td></tr></table></figure>

<h3 id="插入（行上）：i-命令"><a href="#插入（行上）：i-命令" class="headerlink" title="插入（行上）：i\命令"></a>插入（行上）：i\命令</h3><p>将 this is a test line 追加到以test开头的行前面：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;/^test/i\this is a test line&#x27;</span> file</span><br></pre></td></tr></table></figure>
<p>在test.conf文件第5行之前插入this is a test line：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;5i\this is a test line&#x27;</span> test.conf</span><br></pre></td></tr></table></figure>
<p>替换指定行：c\命令<br>把root开头的行替换新内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node6 ~]<span class="comment"># sed &#x27;/^root/c this is new line!&#x27; passwd </span></span><br><span class="line">this is new line!</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br></pre></td></tr></table></figure>
<p>如果是指定范围替换，需要注意，sed不是每行进行替换，而是把整个范围作为整体替换：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node6 ~]<span class="comment"># nl passwd | sed &#x27;1,5c\   this is dangerous!&#x27;</span></span><br><span class="line">     this is dangerous!</span><br><span class="line">     6	<span class="built_in">sync</span>:x:5:0:<span class="built_in">sync</span>:/sbin:/bin/sync</span><br><span class="line">     7	shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown</span><br></pre></td></tr></table></figure>
<p>如果想实现对第一行到第五行统一替换为相同内容，可以用下面的命令实现：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@node5 ~]<span class="comment"># sed &#x27;1&#123;:a;s/.*/lutxixia/;n;6!ba&#125;&#x27; passwd </span></span><br><span class="line">lutxixia</span><br><span class="line">lutxixia</span><br><span class="line">lutxixia</span><br><span class="line">lutxixia</span><br><span class="line">lutxixia</span><br><span class="line"><span class="built_in">sync</span>:x:5:0:<span class="built_in">sync</span>:/sbin:/bin/sync</span><br><span class="line"></span><br><span class="line">其中：</span><br><span class="line">:a  	是设置一个循环标签</span><br><span class="line">s/.*/lutixia/	是用lutixia字符替换匹配到的每行内容</span><br><span class="line">n	是读取下一行</span><br><span class="line">6!	是读到第六行退出循环，终止操作,如果没有，则继续循环。</span><br><span class="line">ba	是如果没有到第六行就跳转到a继续循环</span><br></pre></td></tr></table></figure>

<h3 id="变形：y命令"><a href="#变形：y命令" class="headerlink" title="变形：y命令"></a>变形：y命令</h3><p>把1~10行内所有abcde转变为大写，注意，正则表达式元字符不能使用这个命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">&#x27;1,10y/abcde/ABCDE/&#x27;</span> file</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SHELL</category>
      </categories>
      <tags>
        <tag>sed</tag>
      </tags>
  </entry>
  <entry>
    <title>paste and wc</title>
    <url>/2020/09/19/paste-and-wc/</url>
    <content><![CDATA[<h2 id="paste"><a href="#paste" class="headerlink" title="paste"></a>paste</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>将两个文本按列拼接到一起</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> file1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line"></span><br><span class="line"><span class="built_in">cat</span> file2</span><br><span class="line">colin</span><br><span class="line">book</span><br><span class="line"></span><br><span class="line"><span class="built_in">paste</span> file1 file2</span><br><span class="line">1 colin</span><br><span class="line">2 book</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>默认的定界符是制表符，可以用-d指明定界符:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">paste</span> file1 file2 -d <span class="string">&quot;,&quot;</span></span><br><span class="line">1,colin</span><br><span class="line">2,book</span><br></pre></td></tr></table></figure>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">paste</span> [-s][-d &lt;间隔字符&gt;][--<span class="built_in">help</span>][--version][文件...]</span><br></pre></td></tr></table></figure>

<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p><code>-d</code>&lt;间隔字符&gt;或–delimiters=&lt;间隔字符&gt; 　用指定的间隔字符取代跳格字符。<br><code>-s或--serial</code> 　串列进行而非平行处理。<br><code>--help</code> 　在线帮助。<br><code>--version</code> 　显示帮助信息。<br><code>[文件…]</code> 指定操作的文件路径</p>
<h2 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h2><h3 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h3><p>Linux wc命令用于计算字数。<br>利用wc指令我们可以计算文件的Byte数、字数、或是列数，若不指定文件名称、或是所给予的文件名为”-“，则wc指令会从标准输入设备读取数据。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$wc</span> -l file // 统计行数</span><br><span class="line"><span class="variable">$wc</span> -w file // 统计单词数</span><br><span class="line"><span class="variable">$wc</span> -c file // 统计字符数</span><br></pre></td></tr></table></figure>

<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">wc</span> [-clw][--<span class="built_in">help</span>][--version][文件...]</span><br></pre></td></tr></table></figure>

<h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><p><code>-c</code>或–bytes或–chars 只显示Bytes数。<br><code>-l</code>或–lines 显示行数。<br><code>-w</code>或–words 只显示字数。<br><code>--help</code> 在线帮助。<br><code>--version</code> 显示版本信息。</p>
]]></content>
      <categories>
        <category>SHELL</category>
      </categories>
      <tags>
        <tag>paste</tag>
        <tag>wc</tag>
      </tags>
  </entry>
  <entry>
    <title>cut按列切分文本</title>
    <url>/2020/09/18/cut%E6%8C%89%E5%88%97%E5%88%87%E5%88%86%E6%96%87%E6%9C%AC/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>cut命令主要有3个定位方法：</p>
<ul>
<li>对字节的定位，用 -b 选项</li>
<li>对字符的定位，用 -c 选项</li>
<li>域，用选型 -f      （-d 区分域）<span id="more"></span></li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># echo $&#123;PATH&#125;</span></span><br><span class="line">/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin</span><br><span class="line"></span><br><span class="line"><span class="comment"># echo $&#123;PATH&#125; | cut -d : -f1,2</span></span><br><span class="line">/usr/local/sbin:/usr/local/bin</span><br><span class="line"><span class="comment"># echo $&#123;PATH&#125; | cut -d : -f2</span></span><br><span class="line">/usr/local/bin</span><br></pre></td></tr></table></figure>

<p>类似于awk</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># echo $&#123;PATH&#125; | awk -F : &#x27;&#123;print $1,$2&#125;&#x27;</span></span><br><span class="line">/usr/local/sbin /usr/local/bin</span><br><span class="line"><span class="comment"># echo $&#123;PATH&#125; | awk -F : &#x27;&#123;print $2&#125;&#x27;</span></span><br><span class="line">/usr/local/bin</span><br></pre></td></tr></table></figure>


<h2 id="缺陷和不足"><a href="#缺陷和不足" class="headerlink" title="缺陷和不足"></a>缺陷和不足</h2><p>在处理多空格时，如果文件里面的某些域是由若干个空格来间隔的，那么用cut就有点麻烦了，因为cut只擅长处理“以一个字符间隔”的文本内容</p>
]]></content>
      <categories>
        <category>SHELL</category>
      </categories>
      <tags>
        <tag>cut</tag>
      </tags>
  </entry>
  <entry>
    <title>用tr进行转换</title>
    <url>/2020/09/18/%E7%94%A8tr%E8%BF%9B%E8%A1%8C%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Shell 用 tr 进行转换，tr是Unix命令行专家工具箱中的一件万能工具。它可用于编写优雅的单行命令。tr可以对来自标准输入的内容进行字符替换、字符删除以及重复字符压缩。tr是translate（转换）的简写，因为它可以将一组字符转换成另一组字符。在本章中，我们会看到如何使用tr进行基本的集合转换。</p>
<span id="more"></span>

<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>tr只能通过stdin（标准输入）接收输入（无法通过命令行参数接收）。其调用格式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tr</span> [options] set1 set2</span><br></pre></td></tr></table></figure>

<p>来自stdin的输入字符会按照位置从set1映射到set2（set1中的第一个字符映射到set2中的第一个字符，以此类推），然后将输出写入stdout（标准输出）。set1和set2是字符类或字符组。如果两个字符组的长度不相等，那么set2会不断复制其最后一个字符，直到长度与set1相同。如果set2的长度大于set1，那么在set2中超出set1长度的那部分字符则全部被忽略。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>要将输入中的字符由大写转换成小写，可以使用下面的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;HELLO WHO IS THIS&quot;</span> | <span class="built_in">tr</span> <span class="string">&#x27;A-Z&#x27;</span> <span class="string">&#x27;a-z&#x27;</span></span><br><span class="line">hello <span class="built_in">who</span> is this</span><br></pre></td></tr></table></figure>

<p>数字转换：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> 12345 | <span class="built_in">tr</span> <span class="string">&#x27;0-9&#x27;</span> <span class="string">&#x27;9876543210&#x27;</span></span><br><span class="line">87654    <span class="comment"># 已加密</span></span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> 87654 | <span class="built_in">tr</span> <span class="string">&#x27;9876543210&#x27;</span> <span class="string">&#x27;0-9&#x27;</span></span><br><span class="line">12345    <span class="comment"># 已解密</span></span><br></pre></td></tr></table></figure>

<h2 id="用tr删除字符"><a href="#用tr删除字符" class="headerlink" title="用tr删除字符"></a>用tr删除字符</h2><p><code>-d</code> 可以通过指定需要被删除的字符集合，将出现在stdin中的特定字符清除掉</p>
<p>例如：将stdin中的数字删除并打印删除后的结果</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;Hello 123 world 456&quot;</span> | <span class="built_in">tr</span> -d <span class="string">&#x27;0-9&#x27;</span></span><br><span class="line">Hello world</span><br></pre></td></tr></table></figure>

<h2 id="字符组补集"><a href="#字符组补集" class="headerlink" title="字符组补集"></a>字符组补集</h2><p>我们可以利用选项-c来使用set1的补集：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tr</span> -c [set1] [set2]</span><br></pre></td></tr></table></figure>
<p>如果使用了-c选项，set1和set2必须都给出。<br>如果-c与-d选项同时出现，你只能使用set1，其他所有的字符都会被删除。</p>
<p>下面的例子会从输入文本中删除不在补集中的所有字符：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> hello 1 char 2 next 4 | <span class="built_in">tr</span> -d -c <span class="string">&#x27;0-9\n&#x27;</span></span><br><span class="line">124</span><br></pre></td></tr></table></figure>
<p>接下来的例子会将不在set1中的字符替换成空格：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> hello 1 char 2 next 4 | <span class="built_in">tr</span> -c <span class="string">&#x27;0-9\n&#x27;</span> <span class="string">&#x27; &#x27;</span></span><br><span class="line">      1      2      4</span><br></pre></td></tr></table></figure>

<h2 id="用tr压缩字符"><a href="#用tr压缩字符" class="headerlink" title="用tr压缩字符"></a>用tr压缩字符</h2><p>tr命令能够完成很多文本处理任务。例如，它可以删除字符串中重复出现的字符。基本实现形式如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">tr</span> -s <span class="string">&#x27;[需要被压缩的一组字符]&#x27;</span></span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;GNU is       not     UNIX. Recursive   right ?&quot;</span> | <span class="built_in">tr</span> -s <span class="string">&#x27; &#x27;</span></span><br><span class="line">GNU is not UNIX. Recursive right ?</span><br></pre></td></tr></table></figure>

<p>tr命令还可以用来删除多余的换行符：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> multi_blanks.txt</span><br><span class="line">line 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">line 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">line 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">line 4</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cat</span> multi_blanks.txt | <span class="built_in">tr</span> -s <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">line 1</span><br><span class="line">line 2</span><br><span class="line">line 3</span><br><span class="line">line 4</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SHELL</category>
      </categories>
      <tags>
        <tag>tr</tag>
      </tags>
  </entry>
  <entry>
    <title>sort and uniq</title>
    <url>/2020/09/17/sort-and-uniq/</url>
    <content><![CDATA[<h2 id="sort字段说明"><a href="#sort字段说明" class="headerlink" title="sort字段说明"></a>sort字段说明</h2><p><code>-n</code> 按数字进行排序<br><code>-d</code> 按字典序进行排序<br><code>-r</code> 逆序排序<br><code>-t</code>&lt;分隔字符&gt; 指定排序时所用的栏位分隔字符。<br><code>-k</code> N 指定按第N列排序</p>
<span id="more"></span>

<h2 id="sort示例"><a href="#sort示例" class="headerlink" title="sort示例"></a>sort示例</h2><p>按照文件大小显示，从小到大</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ll | <span class="built_in">sort</span> -n -t <span class="string">&#x27; &#x27;</span> -k6</span><br></pre></td></tr></table></figure>

<h2 id="uniq-消除重复行"><a href="#uniq-消除重复行" class="headerlink" title="uniq 消除重复行"></a>uniq 消除重复行</h2><p>消除重复行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span> unsort.txt | <span class="built_in">uniq</span></span><br></pre></td></tr></table></figure>

<p>统计各行在文件中出现的次数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span> unsort.txt | <span class="built_in">uniq</span> -c</span><br></pre></td></tr></table></figure>

<p>找出重复行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span> unsort.txt | <span class="built_in">uniq</span> -d</span><br></pre></td></tr></table></figure>

<h2 id="sort-u"><a href="#sort-u" class="headerlink" title="sort -u"></a>sort -u</h2><p>作用是uniq的缩写选项，消除重复行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> seq.txt</span><br><span class="line">banana</span><br><span class="line">apple</span><br><span class="line">pear</span><br><span class="line">orange</span><br><span class="line">pear</span><br><span class="line">$ <span class="built_in">sort</span> seq.txt</span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">orange</span><br><span class="line">pear</span><br><span class="line">pear</span><br><span class="line">$ <span class="built_in">sort</span> -u seq.txt</span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">orange</span><br><span class="line">pear</span><br><span class="line"><span class="comment">#等同于</span></span><br><span class="line">$ <span class="built_in">sort</span> seq.txt | <span class="built_in">uniq</span> </span><br><span class="line">apple</span><br><span class="line">banana</span><br><span class="line">orange</span><br><span class="line">pear</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SHELL</category>
      </categories>
      <tags>
        <tag>sort</tag>
        <tag>uniq</tag>
      </tags>
  </entry>
  <entry>
    <title>xargs命令行参数转换</title>
    <url>/2020/09/17/xargs%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>xargs 能够将输入数据转化为特定命令的命令行参数；</li>
<li>这样，可以配合很多命令来组合使用。比如grep，比如find；</li>
<li>将多行输出转化为单行输出:<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> file.txt| xargs</span><br></pre></td></tr></table></figure>
<span id="more"></span></li>
</ul>
<p><code>-n</code> 是多行文本间的定界符</p>
<p>将单行转化为多行输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> single.txt | xargs -n 3</span><br><span class="line">-n：指定每行显示的字段数</span><br></pre></td></tr></table></figure>

<h2 id="xargs参数说明"><a href="#xargs参数说明" class="headerlink" title="xargs参数说明"></a>xargs参数说明</h2><p><code>-d</code> 定义定界符 （默认为空格 多行的定界符为 n）<br><code>-n</code> 指定输出为多行<br><code>-I</code> {} 指定替换字符串，这个字符串在xargs扩展时会被替换掉,用于待执行的命令需要多个参数时<br><code>-0</code> 指定0为输入定界符</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>-d 选项可以自定义一个定界符</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># echo &quot;nameXnameXnameXname&quot; | xargs -dX</span></span><br><span class="line"></span><br><span class="line">name name name name</span><br></pre></td></tr></table></figure>



<p>结合 -n 选项使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># echo &quot;nameXnameXnameXname&quot; | xargs -dX -n2</span></span><br><span class="line"></span><br><span class="line">name name</span><br><span class="line">name name</span><br></pre></td></tr></table></figure>


<p>统计程序行数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find source_dir/ -<span class="built_in">type</span> f -name <span class="string">&quot;*.cpp&quot;</span> -print0 | xargs -0 | <span class="built_in">wc</span> -l</span><br></pre></td></tr></table></figure>


<p>复制所有图片文件到 /data/images 目录下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> *.jpg | xargs -n1 -I &#123;&#125; <span class="built_in">cp</span> &#123;&#125; /data/images</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SHELL</category>
      </categories>
      <tags>
        <tag>xargs</tag>
      </tags>
  </entry>
  <entry>
    <title>grep</title>
    <url>/2020/09/17/grep/</url>
    <content><![CDATA[<h2 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep match_patten file // 默认访问匹配行</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><p><code>-o</code> 只输出匹配的文本行<br><code>-v</code> 只输出没有匹配的文本行<br><code>-c</code> 统计文件中包含文本的次数 <code>grep -c “text” filename</code><br><code>-n</code> 打印匹配的行号<br><code>-i</code> 搜索时忽略大小写<br><code>-l</code> 只打印文件名<br><code>-w</code> 全词匹配</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>在多级目录中对文本递归搜索(程序员搜代码的最爱）:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep <span class="string">&quot;class&quot;</span> . -R -n</span><br></pre></td></tr></table></figure>

<p>匹配多个模式:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep -e <span class="string">&quot;class&quot;</span> -e <span class="string">&quot;vitural&quot;</span> file</span><br></pre></td></tr></table></figure>

<p>grep输出以0作为结尾符的文件名（-z）:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep <span class="string">&quot;test&quot;</span> file* -lZ| xargs -0 <span class="built_in">rm</span></span><br></pre></td></tr></table></figure>

<p>将日志中的所有带where条件的sql查找查找出来:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> LOG.* | <span class="built_in">tr</span> a-z A-Z | grep <span class="string">&quot;FROM &quot;</span> | grep <span class="string">&quot;WHERE&quot;</span> &gt; b</span><br></pre></td></tr></table></figure>

<p>全词匹配：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># free -h | grep -i me</span></span><br><span class="line">Mem:            30G         15G        3.2G        909M         12G         13G</span><br><span class="line"><span class="comment"># free -h | grep -i -w me</span></span><br><span class="line"><span class="comment"># </span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SHELL</category>
      </categories>
      <tags>
        <tag>grep</tag>
      </tags>
  </entry>
  <entry>
    <title>find</title>
    <url>/2020/09/16/find/</url>
    <content><![CDATA[<h2 id="查找txt和pdf文件"><a href="#查找txt和pdf文件" class="headerlink" title="查找txt和pdf文件"></a>查找txt和pdf文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . \( -name <span class="string">&quot;*.txt&quot;</span> -o -name <span class="string">&quot;*.pdf&quot;</span> \) -<span class="built_in">print</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h2 id="过滤掉某个路径"><a href="#过滤掉某个路径" class="headerlink" title="过滤掉某个路径"></a>过滤掉某个路径</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find / -path /mnt -prune -o  -name <span class="string">&quot;libunwind*&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="正则方式查找-txt和pdf"><a href="#正则方式查找-txt和pdf" class="headerlink" title="正则方式查找.txt和pdf:"></a>正则方式查找.txt和pdf:</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -regex  <span class="string">&quot;.*\(\.txt|\.pdf\)$&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>-iregex</code>： 忽略大小写的正则</p>
<h2 id="否定参数-查找所有非txt文本"><a href="#否定参数-查找所有非txt文本" class="headerlink" title="否定参数 ,查找所有非txt文本:"></a>否定参数 ,查找所有非txt文本:</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . ! -name <span class="string">&quot;*.txt&quot;</span> -<span class="built_in">print</span></span><br></pre></td></tr></table></figure>

<h2 id="指定搜索深度-打印出当前目录的文件（深度为1）"><a href="#指定搜索深度-打印出当前目录的文件（深度为1）" class="headerlink" title="指定搜索深度,打印出当前目录的文件（深度为1）:"></a>指定搜索深度,打印出当前目录的文件（深度为1）:</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -maxdepth 1 -<span class="built_in">type</span> f</span><br></pre></td></tr></table></figure>

<h2 id="定制搜索"><a href="#定制搜索" class="headerlink" title="定制搜索"></a>定制搜索</h2><h3 id="按类型搜索"><a href="#按类型搜索" class="headerlink" title="按类型搜索"></a>按类型搜索</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> d -<span class="built_in">print</span>  //只列出所有目录</span><br></pre></td></tr></table></figure>
<p><code>-type</code> f 文件 / l 符号链接 / d 目录</p>
<p>find支持的文件检索类型可以区分普通文件和符号链接、目录等，但是二进制文件和文本文件无法直接通过find的类型区分出来；</p>
<p>file命令可以检查文件具体类型（二进制或文本）:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$file</span> redis-cli  <span class="comment"># 二进制文件</span></span><br><span class="line">redis-cli: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), <span class="keyword">for</span> GNU/Linux 2.6.9, not stripped</span><br><span class="line"><span class="variable">$file</span> redis.pid  <span class="comment"># 文本文件</span></span><br><span class="line">redis.pid: ASCII text</span><br></pre></td></tr></table></figure>
<p>所以,可以用以下命令组合来实现查找本地目录下的所有二进制文件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ls</span> -lrt | awk <span class="string">&#x27;&#123;print $9&#125;&#x27;</span>|xargs file|grep  ELF| awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>|<span class="built_in">tr</span> -d <span class="string">&#x27;:&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="按时间搜索"><a href="#按时间搜索" class="headerlink" title="按时间搜索"></a>按时间搜索</h3><p><code>-atime</code> 访问时间 (单位是天，分钟单位则是-amin，以下类似）<br><code>-mtime</code> 修改时间 （内容被修改）<br><code>-ctime</code> 变化时间 （元数据或权限变化）<br>最近第7天被访问过的所有文件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -atime 7 -<span class="built_in">type</span> f -<span class="built_in">print</span></span><br></pre></td></tr></table></figure>
<p>最近7天内被访问过的所有文件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -atime -7 -<span class="built_in">type</span> f -<span class="built_in">print</span></span><br></pre></td></tr></table></figure>
<p>查询7天前被访问过的所有文件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -atime +7 <span class="built_in">type</span> f -<span class="built_in">print</span></span><br></pre></td></tr></table></figure>
<h3 id="按大小搜索"><a href="#按大小搜索" class="headerlink" title="按大小搜索"></a>按大小搜索</h3><p>w字 k M G 寻找大于2k的文件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -size +2k</span><br></pre></td></tr></table></figure>
<h3 id="按权限查找"><a href="#按权限查找" class="headerlink" title="按权限查找"></a>按权限查找</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -perm 644 -<span class="built_in">print</span> //找具有可执行权限的所有文件</span><br></pre></td></tr></table></figure>
<h3 id="按用户查找"><a href="#按用户查找" class="headerlink" title="按用户查找"></a>按用户查找</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -user weber -<span class="built_in">print</span>// 找用户weber所拥有的文件</span><br></pre></td></tr></table></figure>
<h2 id="找到后的后续动作"><a href="#找到后的后续动作" class="headerlink" title="找到后的后续动作"></a>找到后的后续动作</h2><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除当前目录下所有的swp文件:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -name <span class="string">&quot;*.swp&quot;</span> -delete</span><br></pre></td></tr></table></figure>
<p>另一种语法:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . <span class="built_in">type</span> f -name <span class="string">&quot;*.swp&quot;</span> | xargs <span class="built_in">rm</span></span><br></pre></td></tr></table></figure>
<h3 id="执行动作（强大的exec）"><a href="#执行动作（强大的exec）" class="headerlink" title="执行动作（强大的exec）"></a>执行动作（强大的exec）</h3><p>将当前目录下的所有权变更为weber:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -user root -<span class="built_in">exec</span> <span class="built_in">chown</span> weber &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<p><strong>注</strong>：{}是一个特殊的字符串，对于每一个匹配的文件，{}会被替换成相应的文件名；</p>
<p>将找到的文件全都copy到另一个目录:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find . -<span class="built_in">type</span> f -mtime +10 -name <span class="string">&quot;*.txt&quot;</span> -<span class="built_in">exec</span> <span class="built_in">cp</span> &#123;&#125; OLD \;</span><br></pre></td></tr></table></figure>
<h3 id="结合多个命令"><a href="#结合多个命令" class="headerlink" title="结合多个命令"></a>结合多个命令</h3><p>如果需要后续执行多个命令，可以将多个命令写成一个脚本。然后 -exec 调用时执行脚本即可:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-<span class="built_in">exec</span> ./commands.sh &#123;&#125; \;</span><br></pre></td></tr></table></figure>
<h2 id="print的定界符"><a href="#print的定界符" class="headerlink" title="-print的定界符"></a>-print的定界符</h2><p>默认使用’\n’作为文件的定界符；</p>
<p><code>-print0</code> 使用’\0’作为文件的定界符，这样就可以搜索包含空格的文件；</p>
]]></content>
      <categories>
        <category>SHELL</category>
      </categories>
      <tags>
        <tag>find</tag>
      </tags>
  </entry>
  <entry>
    <title>lsof一切皆文件</title>
    <url>/2020/09/15/lsof%E4%B8%80%E5%88%87%E7%9A%86%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>lsof（list open files）是一个查看当前系统文件的工具。</li>
<li>在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。<span id="more"></span></li>
<li>如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等；</li>
<li>系统在后台都为该应用程序分配了一个文件描述符，该文件描述符提供了大量关于这个应用程序本身的信息。</li>
</ul>
<p>lsof打开的文件可以是：</p>
<ul>
<li>普通文件</li>
<li>目录</li>
<li>网络文件系统的文件</li>
<li>字符或设备文件</li>
<li>(函数)共享库</li>
<li>管道，命名管道</li>
<li>符号链接</li>
<li>网络文件（例如：NFS file、网络socket，unix域名socket）</li>
<li>还有其它类型的文件，等等</li>
</ul>
<h2 id="命令参数"><a href="#命令参数" class="headerlink" title="命令参数"></a>命令参数</h2><p><code>-a</code> 列出打开文件存在的进程<br><code>-c</code>&lt;进程名&gt; 列出指定进程所打开的文件<br><code>-g</code> 列出GID号进程详情<br><code>-d</code>&lt;文件号&gt; 列出占用该文件号的进程<br><code>+d</code>&lt;目录&gt; 列出目录下被打开的文件<br><code>+D</code>&lt;目录&gt; 递归列出目录下被打开的文件<br><code>-n</code>&lt;目录&gt; 列出使用NFS的文件<br><code>-i</code>&lt;条件&gt; 列出符合条件的进程。（4、6、协议、:端口、 @ip ）<br><code>-p</code>&lt;进程号&gt; 列出指定进程号所打开的文件<br><code>-u</code> 列出UID号进程详情<br><code>-h</code> 显示帮助信息<br><code>-v</code> 显示版本信息</p>
<h2 id="使用无任何参数"><a href="#使用无任何参数" class="headerlink" title="使用无任何参数"></a>使用无任何参数</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$lsof</span>| more</span><br><span class="line">COMMAND     PID      USER   FD      TYPE             DEVICE SIZE/OFF       NODE NAME</span><br><span class="line">init          1      root  cwd       DIR              253,0     4096          2 /</span><br><span class="line">init          1      root  rtd       DIR              253,0     4096          2 /</span><br><span class="line">init          1      root  txt       REG              253,0   150352    1310795 /sbin/init</span><br><span class="line">init          1      root  mem       REG              253,0    65928    5505054 /lib64/libnss_files-2.12.so</span><br><span class="line">init          1      root  mem       REG              253,0  1918016    5521405 /lib64/libc-2.12.so</span><br><span class="line">init          1      root  mem       REG              253,0    93224    5521440 /lib64/libgcc_s-4.4.6-20120305.so.1</span><br><span class="line">init          1      root  mem       REG              253,0    47064    5521407 /lib64/librt-2.12.so</span><br><span class="line">init          1      root  mem       REG              253,0   145720    5521406 /lib64/libpthread-2.12.so</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>说明：</p>
<p>lsof输出各列信息的意义如下：<br><code>COMMAND</code>：进程的名称<br><code>PID</code>：进程标识符<br><code>PPID</code>：父进程标识符（需要指定-R参数）<br><code>USER</code>：进程所有者<br><code>PGID</code>：进程所属组<br><code>FD</code>：文件描述符，应用程序通过文件描述符识别该文件。如cwd、txt等:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">（1）cwd：表示current work dirctory，即：应用程序的当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改</span><br><span class="line">（2）txt ：该类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 /sbin/init 程序</span><br><span class="line">（3）lnn：library references (AIX);</span><br><span class="line">（4）er：FD information error (see NAME column);</span><br><span class="line">（5）jld：jail directory (FreeBSD);</span><br><span class="line">（6）ltx：shared library text (code and data);</span><br><span class="line">（7）mxx ：hex memory-mapped <span class="built_in">type</span> number xx.</span><br><span class="line">（8）m86：DOS Merge mapped file;</span><br><span class="line">（9）mem：memory-mapped file;</span><br><span class="line">（10）mmap：memory-mapped device;</span><br><span class="line">（11）pd：parent directory;</span><br><span class="line">（12）rtd：root directory;</span><br><span class="line">（13）<span class="built_in">tr</span>：kernel trace file (OpenBSD);</span><br><span class="line">（14）v86  VP/ix mapped file;</span><br><span class="line">（15）0：表示标准输入</span><br><span class="line">（16）1：表示标准输出</span><br><span class="line">（17）2：表示标准错误</span><br><span class="line">一般在标准输出、标准错误、标准输入后还跟着文件状态模式：r、w、u等</span><br><span class="line">（1）u：表示该文件被打开并处于读取/写入模式</span><br><span class="line">（2）r：表示该文件被打开并处于只读模式</span><br><span class="line">（3）w：表示该文件被打开并处于</span><br><span class="line">（4）空格：表示该文件的状态模式为unknow，且没有锁定</span><br><span class="line">（5）-：表示该文件的状态模式为unknow，且被锁定</span><br><span class="line">同时在文件状态模式后面，还跟着相关的锁</span><br><span class="line">（1）N：<span class="keyword">for</span> a Solaris NFS lock of unknown <span class="built_in">type</span>;</span><br><span class="line">（2）r：<span class="keyword">for</span> <span class="built_in">read</span> lock on part of the file;</span><br><span class="line">（3）R：<span class="keyword">for</span> a <span class="built_in">read</span> lock on the entire file;</span><br><span class="line">（4）w：<span class="keyword">for</span> a write lock on part of the file;（文件的部分写锁）</span><br><span class="line">（5）W：<span class="keyword">for</span> a write lock on the entire file;（整个文件的写锁）</span><br><span class="line">（6）u：<span class="keyword">for</span> a <span class="built_in">read</span> and write lock of any length;</span><br><span class="line">（7）U：<span class="keyword">for</span> a lock of unknown <span class="built_in">type</span>;</span><br><span class="line">（8）x：<span class="keyword">for</span> an SCO OpenServer Xenix lock on part      of the file;</span><br><span class="line">（9）X：<span class="keyword">for</span> an SCO OpenServer Xenix lock on the      entire file;</span><br><span class="line">（10）space：<span class="keyword">if</span> there is no lock.</span><br></pre></td></tr></table></figure>

<p><code>TYPE</code>：文件类型，如DIR、REG等，常见的文件类型:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">（1）DIR：表示目录</span><br><span class="line">（2）CHR：表示字符类型</span><br><span class="line">（3）BLK：块设备类型</span><br><span class="line">（4）UNIX： UNIX 域套接字</span><br><span class="line">（5）FIFO：先进先出 (FIFO) 队列</span><br><span class="line">（6）IPv4：网际协议 (IP) 套接字</span><br></pre></td></tr></table></figure>

<p><code>DEVICE</code>：指定磁盘的名称<br><code>SIZE</code>：文件的大小<br><code>NODE</code>：索引节点（文件在磁盘上的标识）<br><code>NAME</code>：打开文件的确切名称</p>
<h2 id="查找某个文件相关的进程"><a href="#查找某个文件相关的进程" class="headerlink" title="查找某个文件相关的进程"></a>查找某个文件相关的进程</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$lsof</span> /bin/bash</span><br><span class="line">COMMAND     PID USER  FD   TYPE DEVICE SIZE/OFF    NODE NAME</span><br><span class="line">mysqld_sa  2169 root txt    REG  253,0   938736 4587562 /bin/bash</span><br><span class="line">ksmtuned   2334 root txt    REG  253,0   938736 4587562 /bin/bash</span><br><span class="line">bash      20121 root txt    REG  253,0   938736 4587562 /bin/bash</span><br></pre></td></tr></table></figure>

<h2 id="列出某个用户打开的文件信息"><a href="#列出某个用户打开的文件信息" class="headerlink" title="列出某个用户打开的文件信息"></a>列出某个用户打开的文件信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">   <span class="variable">$lsof</span> -u username</span><br><span class="line">-u 选项，u是user的缩写</span><br></pre></td></tr></table></figure>

<h2 id="列出某个程序进程所打开的文件信息"><a href="#列出某个程序进程所打开的文件信息" class="headerlink" title="列出某个程序进程所打开的文件信息"></a>列出某个程序进程所打开的文件信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$lsof</span> -c mysql</span><br><span class="line">-c 选项将会列出所有以mysql这个进程开头的程序的文件，</span><br><span class="line">可以写成 lsof | grep mysql, 但是第一种方法明显比第二种方法要少打几个字符；</span><br></pre></td></tr></table></figure>

<h2 id="列出某个用户以及某个进程所打开的文件信息"><a href="#列出某个用户以及某个进程所打开的文件信息" class="headerlink" title="列出某个用户以及某个进程所打开的文件信息"></a>列出某个用户以及某个进程所打开的文件信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$lsof</span>  -u <span class="built_in">test</span> -c mysql</span><br></pre></td></tr></table></figure>

<h2 id="通过某个进程号显示该进程打开的文件"><a href="#通过某个进程号显示该进程打开的文件" class="headerlink" title="通过某个进程号显示该进程打开的文件"></a>通过某个进程号显示该进程打开的文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$lsof</span> -p 11968</span><br></pre></td></tr></table></figure>

<h2 id="列出所有的网络连接"><a href="#列出所有的网络连接" class="headerlink" title="列出所有的网络连接"></a>列出所有的网络连接</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$lsof</span> -i</span><br></pre></td></tr></table></figure>

<h2 id="列出所有tcp网络连接信息"><a href="#列出所有tcp网络连接信息" class="headerlink" title="列出所有tcp网络连接信息"></a>列出所有tcp网络连接信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$lsof</span> -i tcp</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$lsof</span> -n -i tcp</span><br><span class="line">COMMAND     PID  USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME</span><br><span class="line">svnserve  11552 weber    3u  IPv4 3799399      0t0  TCP *:svn (LISTEN)</span><br><span class="line">redis-ser 25501 weber    4u  IPv4  113150      0t0  TCP 127.0.0.1:6379 (LISTEN)</span><br></pre></td></tr></table></figure>

<h2 id="列出谁在使用某个端口"><a href="#列出谁在使用某个端口" class="headerlink" title="列出谁在使用某个端口"></a>列出谁在使用某个端口</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$lsof</span> -i :3306</span><br></pre></td></tr></table></figure>

<h2 id="列出某个用户的所有活跃的网络端口"><a href="#列出某个用户的所有活跃的网络端口" class="headerlink" title="列出某个用户的所有活跃的网络端口"></a>列出某个用户的所有活跃的网络端口</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$lsof</span> -a -u <span class="built_in">test</span> -i</span><br></pre></td></tr></table></figure>

<h2 id="根据文件描述列出对应的文件信息"><a href="#根据文件描述列出对应的文件信息" class="headerlink" title="根据文件描述列出对应的文件信息"></a>根据文件描述列出对应的文件信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$lsof</span> -d description(like 2)</span><br></pre></td></tr></table></figure>
<p>示例:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$lsof</span> -d 3 | grep PARSER1</span><br><span class="line"><span class="built_in">tail</span>      6499 tde    3r   REG    253,3   4514722     417798 /opt/applog/open/log/HOSTPARSER1_ERROR_141217.log.001</span><br></pre></td></tr></table></figure>
<p>说明： 0表示标准输入，1表示标准输出，2表示标准错误，从而可知：所以大多数应用程序所打开的文件的 FD 都是从 3 开始</p>
<h2 id="列出被进程号为1234的进程所打开的所有IPV4-network-files"><a href="#列出被进程号为1234的进程所打开的所有IPV4-network-files" class="headerlink" title="列出被进程号为1234的进程所打开的所有IPV4 network files"></a>列出被进程号为1234的进程所打开的所有IPV4 network files</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$lsof</span> -i 4 -a -p 1234</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>lsof</tag>
      </tags>
  </entry>
  <entry>
    <title>top命令</title>
    <url>/2020/09/14/top-linux%E4%B8%8B%E7%9A%84%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul>
<li>top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器；<span id="more"></span></li>
<li>top是一个动态显示过程,即可以通过用户按键来不断刷新当前状态，如果在前台执行该命令,它将独占前台,直到用户终止该程序为止；</li>
<li>比较准确的说,top命令提供了实时的对系统处理器的状态监视；</li>
<li>它将显示系统中CPU最“敏感”的任务列表，该命令可以按CPU使用，内存使用和执行时间对任务进行排序；</li>
<li>而且该命令的很多特性都可以通过交互式命令或者在个人定制文件中进行设定。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$top</span></span><br><span class="line">    top - 09:14:56 up 264 days, 20:56,  1 user,  load average: 0.02, 0.04, 0.00</span><br><span class="line">    Tasks:  87 total,   1 running,  86 sleeping,   0 stopped,   0 zombie</span><br><span class="line">    Cpu(s):  0.0%us,  0.2%sy,  0.0%ni, 99.7%<span class="built_in">id</span>,  0.0%wa,  0.0%hi,  0.0%si,  0.2%st</span><br><span class="line">    Mem:    377672k total,   322332k used,    55340k free,    32592k buffers</span><br><span class="line">    Swap:   397308k total,    67192k used,   330116k free,    71900k cached</span><br><span class="line">    PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND</span><br><span class="line">    1 root      20   0  2856  656  388 S  0.0  0.2   0:49.40 init</span><br><span class="line">    2 root      20   0     0    0    0 S  0.0  0.0   0:00.00 kthreadd</span><br><span class="line">    3 root      20   0     0    0    0 S  0.0  0.0   7:15.20 ksoftirqd/0</span><br><span class="line">    4 root      RT   0     0    0    0 S  0.0  0.0   0:00.00 migration/0</span><br></pre></td></tr></table></figure>

<h2 id="top命令名词解释"><a href="#top命令名词解释" class="headerlink" title="top命令名词解释"></a>top命令名词解释</h2><p>第一行<br><code>09:14:56</code> ： 系统当前时间<br><code>264 days, 20:56</code> ： 系统开机到现在经过了多少时间<br><code>1 users</code> ： 当前2用户在线<br><code>load average: 0.02, 0.04, 0.00</code>： 系统1分钟、5分钟、15分钟的CPU负载信息<br>第二行<br><code>Tasks</code>：任务;<br><code>87 total</code>：很好理解，就是当前有87个任务，也就是87个进程。<br><code>1 running</code>：1个进程正在运行<br><code>86 sleeping</code>：86个进程睡眠<br><code>0 stopped</code>：停止的进程数<br><code>0 zombie</code>：僵死的进程数<br>第三行<br><code>Cpu(s)</code>：表示这一行显示CPU总体信息<br><code>0.0%us</code>：用户态进程占用CPU时间百分比，不包含renice值为负的任务占用的CPU的时间。<br><code>0.7%sy</code>：内核占用CPU时间百分比<br><code>0.0%ni</code>：改变过优先级的进程占用CPU的百分比<br><code>99.3%id</code>：空闲CPU时间百分比<br><code>0.0%wa</code>：等待I/O的CPU时间百分比<br><code>0.0%hi</code>：CPU硬中断时间百分比<br><code>0.0%si</code>：CPU软中断时间百分比<br><strong>注</strong>：这里显示数据是所有cpu的平均值，如果想看每一个cpu的处理情况，按1即可；折叠，再次按1；<br>第四行<br><code>Mem</code>：内存的意思<br><code>8175320kk total</code>：物理内存总量<br><code>8058868k used</code>：使用的物理内存量<br><code>116452k free</code>：空闲的物理内存量<br><code>283084k buffers</code>：用作内核缓存的物理内存量<br>第五行<br><code>Swap</code>：交换空间<br><code>6881272k total</code>：交换区总量<br><code>4010444k used</code>：使用的交换区量<br><code>2870828k free</code>：空闲的交换区量<br><code>4336992k cached</code>：缓冲交换区总量<br>进程信息<br>再下面就是进程信息：<br><code>PID</code>：进程的ID<br><code>USER</code>：进程所有者<br><code>PR</code>：进程的优先级别，越小越优先被执行<br><code>NI</code>nice：值<br><code>VIRT</code>：进程占用的虚拟内存<br><code>RES</code>：进程占用的物理内存<br><code>SHR</code>：进程使用的共享内存<br><code>S</code>：进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负数<br><code>%CPU</code>：进程占用CPU的使用率<br><code>%MEM</code>：进程使用的物理内存和总内存的百分比<br><code>TIME+</code>：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值。<br><code>COMMAND</code>：进程启动命令名称</p>
<h2 id="top命令交互操作指令"><a href="#top命令交互操作指令" class="headerlink" title="top命令交互操作指令"></a>top命令交互操作指令</h2><p>下面列出一些常用的 top命令操作指令</p>
<p><code>q</code>：退出top命令<br><code>&lt;Space&gt;</code>：立即刷新<br><code>s</code>：设置刷新时间间隔<br><code>c</code>：显示命令完全模式<br><code>t</code>：显示或隐藏进程和CPU状态信息<br><code>m</code>：显示或隐藏内存状态信息<br><code>l</code>：显示或隐藏uptime信息<br><code>f</code>：增加或减少进程显示标志<br><code>S</code>：累计模式，会把已完成或退出的子进程占用的CPU时间累计到父进程的MITE+<br><code>P</code>：按%CPU使用率排行<br><code>T</code>：按MITE+排行<br><code>M</code>：按%MEM排行<br><code>u</code>：指定显示用户进程<br><code>r</code>：修改进程renice值<br><code>k</code>kill：进程<br><code>i</code>：只显示正在运行的进程<br><code>W</code>：保存对top的设置到文件^/.toprc，下次启动将自动调用toprc文件的设置。<br><code>h</code>：帮助命令。<br><code>q</code>：退出<br><strong>注</strong>：强调一下，使用频率最高的是P、T、M，因为通常使用top，我们就想看看是哪些进程最耗cpu资源、占用的内存最多； 注：通过”shift + &gt;”或”shift + &lt;”可以向右或左改变排序列 如果只需要查看内存：可用free命令。只查看uptime信息（第一行），可用uptime命令；</p>
<h2 id="查看线程绑定在哪个核"><a href="#查看线程绑定在哪个核" class="headerlink" title="查看线程绑定在哪个核"></a>查看线程绑定在哪个核</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top -Hp `pidof 进程名`</span><br></pre></td></tr></table></figure>
<p>按f，选中SMP，按下空格键，再按下esc返回<br><img src="1851a559fa0049439666269588b5696a633d8d789de2be4e226c0e562a3ad282.png" alt="图 1">  </p>
<p>如下图，P列表示线程对应的CPU核号<br><img src="9aaf6394f686b8f5c84e6ad022ba9233bd36c8ee09365dcf332b91c6033d9e17.png" alt="图 2">  </p>
<h2 id="多核CPU监控"><a href="#多核CPU监控" class="headerlink" title="多核CPU监控"></a>多核CPU监控</h2><p>在top基本视图中，按键盘数字“1”，可监控每个逻辑CPU的状况</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[rdtfr@bl685cb4-t ^]$ top</span><br><span class="line">top - 09:10:44 up 20 days, 16:51,  4 <span class="built_in">users</span>,  load average: 3.82, 4.40, 4.40</span><br><span class="line">Tasks: 1201 total,  10 running, 1189 sleeping,   0 stopped,   2 zombie</span><br><span class="line">Cpu0  :  1.3%us,  2.3%sy,  0.0%ni, 96.4%<span class="built_in">id</span>,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st</span><br><span class="line">Cpu1  :  1.3%us,  2.6%sy,  0.0%ni, 96.1%<span class="built_in">id</span>,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st</span><br><span class="line">Cpu2  :  1.0%us,  2.0%sy,  0.0%ni, 92.5%<span class="built_in">id</span>,  0.0%wa,  0.0%hi,  4.6%si,  0.0%st</span><br><span class="line">Cpu3  :  3.9%us,  7.8%sy,  0.0%ni, 83.2%<span class="built_in">id</span>,  0.0%wa,  0.0%hi,  5.2%si,  0.0%st</span><br><span class="line">Cpu4  :  4.2%us, 10.4%sy,  0.0%ni, 63.8%<span class="built_in">id</span>,  0.0%wa,  0.0%hi, 21.5%si,  0.0%st</span><br><span class="line">Cpu5  :  6.8%us, 12.7%sy,  0.0%ni, 80.5%<span class="built_in">id</span>,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st</span><br><span class="line">Cpu6  :  2.9%us,  7.2%sy,  0.0%ni, 85.3%<span class="built_in">id</span>,  0.0%wa,  0.0%hi,  4.6%si,  0.0%st</span><br><span class="line">Cpu7  :  6.2%us, 13.0%sy,  0.0%ni, 75.3%<span class="built_in">id</span>,  0.0%wa,  0.0%hi,  5.5%si,  0.0%st</span><br><span class="line">Mem:  32943888k total, 32834216k used,   109672k free,   642704k buffers</span><br><span class="line">Swap: 35651576k total,  5761928k used, 29889648k free, 16611500k cached</span><br></pre></td></tr></table></figure>

<h2 id="高亮显示当前运行进程"><a href="#高亮显示当前运行进程" class="headerlink" title="高亮显示当前运行进程"></a>高亮显示当前运行进程</h2><p>在top基本视图中,按键盘“b”（打开/关闭加亮效果）</p>
<h2 id="显示完整的程序命令"><a href="#显示完整的程序命令" class="headerlink" title="显示完整的程序命令"></a>显示完整的程序命令</h2><p><code>top -c</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[rdtfr@bl685cb4-t ^]$ top -c</span><br><span class="line">top - 09:14:35 up 20 days, 16:55,  4 <span class="built_in">users</span>,  load average: 5.77, 5.01, 4.64</span><br><span class="line">Tasks: 1200 total,   5 running, 1192 sleeping,   0 stopped,   3 zombie</span><br><span class="line">Cpu(s):  4.4%us,  6.0%sy,  0.0%ni, 83.8%<span class="built_in">id</span>,  0.2%wa,  0.0%hi,  5.5%si,  0.0%st</span><br><span class="line">Mem:  32943888k total, 32842896k used,   100992k free,   591484k buffers</span><br><span class="line">Swap: 35651576k total,  5761808k used, 29889768k free, 16918824k cached</span><br><span class="line">PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND</span><br><span class="line">2013 apache    18   0  403m  88m 5304 S 25.0  0.3   6:37.44 /usr/sbin/httpd</span><br><span class="line">18335 pubtest   22   0 65576  996  728 R  7.8  0.0   0:00.24 netstat -naltp</span><br><span class="line">16499 rdtfare   15   0 13672 2080  824 R  2.6  0.0   0:00.38 top -c</span><br><span class="line">29684 rdtfare   15   0 1164m 837m  14m S  2.3  2.6 148:47.54 ./autodata data1.txt</span><br><span class="line">12976 pubtest   18   0  238m 9000 1932 S  1.6  0.0 439:28.44 tscagent -s TOEV_P</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>top</tag>
      </tags>
  </entry>
  <entry>
    <title>Anycast</title>
    <url>/2020/09/12/anycast/</url>
    <content><![CDATA[<h2 id="什么是-Anycast？"><a href="#什么是-Anycast？" class="headerlink" title="什么是 Anycast？"></a>什么是 Anycast？</h2><ul>
<li>Anycast实质上是一种网络技术，它借助于网络中动态路由协议实现服务的负载均衡和冗余。<span id="more"></span></li>
<li>当存在多条到同一目的ip地址的等价路由时，路由器/三层交换机根据特定算法把流量负载均衡到这多条等价路由上。</li>
<li>DNS的局域网anycast技术就是使用路由器/三层交换机的这一功能，在下挂的多台后台服务器上配置相同loopback地址，</li>
<li>互联接口地址采用不同ip地址，配置指向该loopback的多条等价路由，从而使用路由器/三层交换机的等价路由负载均衡机制，以到达负载均衡的目的。</li>
</ul>
<h2 id="Anycast优势"><a href="#Anycast优势" class="headerlink" title="Anycast优势"></a>Anycast优势</h2><ol>
<li><p>不同客户端将访问不同目的主机，此过程对客户端透明，从而实现了目的主机的负载均衡;</p>
</li>
<li><p>当任意目的主机接入的网络出现故障，导致该目的主机不可达时，客户端请求可以在无人为干预的情况下自动被路由到目前可达的最近目的主机，在一定程度上为目标主机提供了冗余性;</p>
</li>
<li><p>当目的主机受到DoS攻击而无法到达时，由于网络不可到达，客户端请求也将路由到其他目的主机上，而在DDoS攻击时，由于Anycast的负载均衡效应，避免了单台目的主机承受所有攻击流量，因此在一定程度上为目的主机提高了安全性;</p>
</li>
<li><p>因为Anycast利用路由度量到“最近”的目的主机，提高了客户端响应速度。</p>
</li>
</ol>
<h2 id="Anycast技术原理"><a href="#Anycast技术原理" class="headerlink" title="Anycast技术原理"></a>Anycast技术原理</h2><p><img src="a305e0a3b3f79d7c6abf7a52d3af9190caffd34944f236b0f86242a6d0cb6ba9.png" alt="图 2"><br>路由器下挂三台SERVER，配置相同的loopback0地址：10.0.0.1/32，互联接口地址分别为192.168.1.2/30、192.168.2.2/30、192.168.3.2/30。</p>
<p><img src="de2b88ec508a2a1c68dd14e2d27bd32b0a440d16112e6b44d3df4df17db1a47d.png" alt="图 3"><br>在路由器上有三条等价的到10.0.0.1/32的路由，下一跳分别为三个互联接口地址，这三条路由通过IGP（静态或动态路由协议）产生，通过BGP发布给骨干网。路由器根据这三条等价路由进行负载均衡。</p>
<p><img src="813ffdf7349f4dbb2f1dd704dd7c796e94820319d5aabe440392d667f42f53ed.png" alt="图 4"><br>根据路由表，路由器并不能识别出地址欺骗的存在，而是认为10.0.0.1/32同时下挂在RouterA、RouterB、RouterC下，可以通过这三台路由器到达该Server，从而在三个接口上实现负载均衡。</p>
<h2 id="Anycast问题"><a href="#Anycast问题" class="headerlink" title="Anycast问题"></a>Anycast问题</h2><ol>
<li>缺少健康检查机制<br>由于anycast是基于网络等价路径实现负载均衡的，网络设备本身不能提供检查检查。导致当某台服务器中的服务出现异常时，用户请求流量仍然送到该服务器，从而用户解析请求失败。</li>
<li>后台服务器台数限制<br>由于路由器/三层交换机支持的等价路由有个数限定（视不同品牌的产品和不同的路由协议而定），所以在每台DNS路由器下挂后台服务器不能超过个数限制，这就限制了未来的扩容需求。</li>
</ol>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>Anycast</tag>
      </tags>
  </entry>
  <entry>
    <title>licenses</title>
    <url>/2020/09/11/licenses/</url>
    <content><![CDATA[<h3 id="BSD许可协议"><a href="#BSD许可协议" class="headerlink" title="BSD许可协议"></a>BSD许可协议</h3><p><strong>1、概念：</strong></p>
<p>BSD 许可协议，即 Berkeley Software Distribution license 的简称，是由加州大学伯克利分校发布并维护的开源软件许可证。BSD许可证是自由软件中使用最广泛的许可协议之一。</p>
<span id="more"></span>
<p><strong>2、两个概念：</strong></p>
<p>BSD：人们常说的BSD，指的是 Berkeley Software Distribution，即伯克利软件套件，是加州大学伯克利分校在AT&amp;T贝尔实验室的Unix操作系统基础上，开发打包的操作系统及相关软件套件。</p>
<p>BSD许可协议：BSD套件遵循某种开源许可证的方式发布，这种许许可证因此而得名，被叫做 BSD许可证。</p>
<p><strong>3、BSD协议特点：</strong></p>
<p>BSD开源协议是一个给予使用者很大自由的协议，可以自由的使用、修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。</p>
<p><strong>4、版本演进历史：</strong></p>
<p>旧版BSD：1998发布初版。<br>新版BSD：1999年发布修订版。</p>
<p>BSD协议的初稿内含有一项额外的条款，要求所有从以BSD许可证授权的软件派生著作，都必须要包含一段文字以交代源代码的来源。该条文列于原BSD许可证的第三条。</p>
<p>GNU项目将这个称为“令人感到不舒服的BSD交代条款”，GNU工程认为存在两个问题：</p>
<p>第一，修改源码的人都希望将其大名加到鸣谢中，如果一个项目参加的人非常多，或者软件包中包含许多个单独项目，鸣谢阵容将会变得非常庞大。<br>第二，这跟GNU通用公共许可协议相抵触，GPL不允许增加额外的限制，所以软件只能在GNU跟BSD之间选择。由于这两个许可证在自由软件中使用很普遍，如果作者想将GPL和BSD有所结合，就会出现冲突。</p>
<p>应自由软件基金会和GNU计划的发起者斯托曼的请求，1999年7月22日，伯克利技术许可办公室的主管 William Hoskins 删除了BSD许可证的第三条。从此以后，自由软件作者就可以方便地采用BSD许可证下的软件，从而跟GPL下的作品融合。</p>
<p>原来的许可证有时被称为“BSD-old”（老BSD）或“4-clause BSD”（四句版BSD），当前的BSD许可证有的被称为“BSD-new”（新BSD）、“revised BSD”（修订的BSD）或“3-clause BSD”（三句版BSD）。</p>
<p><strong>5、协议分析：</strong></p>
<p>当发布使用了BSD协议的代码或以BSD协议代码为基础做二次开发自己的产品时，需满足以下三个条件：</p>
<ul>
<li>如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。</li>
<li>如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。</li>
<li>不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。</li>
</ul>
<p>BSD协议鼓励项目代码共享，但需要尊重作者的著作权。BSD协议由于允许使用者修改和重新发布代码，也允许在BSD代码上开发商业软件发布和销售，因此是对商业集成很友好的协议。</p>
<p>很多公司在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。遵守BSD 协议的软件，允许用作商业用途，甚至可按照专属许可证进行再发布。</p>
<h3 id="GNU-GPL-LGPL"><a href="#GNU-GPL-LGPL" class="headerlink" title="GNU(GPL, LGPL)"></a>GNU(GPL, LGPL)</h3><h4 id="GPL"><a href="#GPL" class="headerlink" title="GPL"></a>GPL</h4><p><strong>1、概念：</strong></p>
<p>GPL，即GNU通用公共许可协议，是 GNU General Public License 的简写。它是由自由软件基金会(FSF)公布的自由软件许可证。</p>
<p><strong>2、版本演进历史：</strong></p>
<p>GPLv1：1989年2月25日发布。<br>GPLv2：1991年6月发布。<br>GPLv3：2007年6月29日发布。</p>
<p><strong>3、协议特点：</strong></p>
<p>GPL协议最大的一个特征是具有传染性，即GPL对于许可证有强制继承的要求，这也是GPL与其他许可证在哲学思想上最大的差异。</p>
<p><strong>4、权利和义务：</strong></p>
<p>GPL 规定了使用遵循了GPL协议软件时，使用者的权力和义务如下：</p>
<p><strong>权力：</strong></p>
<ul>
<li>获取源码的权力；</li>
<li>修改源码的权利；</li>
<li>自由处理衍生作品的权利。</li>
</ul>
<p><strong>义务：</strong></p>
<ul>
<li>使用了遵循GPL协议发布的软件，自身也必须遵守GPL协议。这也是GPL被人称为有传染性的原因。</li>
<li>必须开放源代码；允许使用者自由获取(复制)、修改、发布的产品，即拥有获取源码、修改源码、分发软件的自由。</li>
</ul>
<p><strong>5、GPL 自由权利的描述：</strong></p>
<p>GPL的条款和条件必须提供给任何接受GPL应用的作品的副本（“被许可人”）的人员。<br>任何遵守条款和条件的被授证人员都有权修改作品，以及复制和重新分发作品或任何派生版本。<br>GPL下的软件可以用于所有目的，包括商业目的，甚至作为创建专有软件的工具，例如使用GPL许可的编译器时，分发GPL许可作品（如软件）的用户或公司可能会收取副本费用或无偿提供费用。</p>
<p><strong>6、分析说明：</strong></p>
<p>这里被授权人，可以理解为，是使用了遵循GPL协议软件的作品的作者或者组织。<br>第三点将GPL与禁止商业再分发的软件许可区分开来，也与共享软件许可证区分开来。FSF认为自由软件不应该限制商业使用和发布（包括再发布）。GPL明确规定，GPL作品可能以任何价格出售。<br>许可只依赖于使用的库和软件组件，而不是依赖于底层平台。例如，作为GPL许可操作系统（如Linux）下的应用程序运行的软件不需要根据GPL进行许可或者以源代码可用性分发。</p>
<p><strong>7、官方网址：</strong></p>
<p>gnu.org/licenses/gpl-3.0.html</p>
<h4 id="LGPL"><a href="#LGPL" class="headerlink" title="LGPL"></a>LGPL</h4><p><strong>1、概念：</strong></p>
<p>LGPL，即GNU宽通用公共许可证，是 GNU Lesser General Public License 的简称。它是由自由软件基金会(FSF)公布的自由软件许可证。</p>
<p><strong>2、版本演进历史：</strong></p>
<p>第一版(2.0)：1991年发布，第一个字母 L 定义为 Library，为与 GPLv2 保持一致而采用 2.0 版的编号。</p>
<p>第二版(2.1)：1999年发布，第一个字母 L 定义为 Lesser，以显示 FSF 认为并不是所有程序库都应当采用该许可证的态度。</p>
<p>第三版(3.0)：2007年发布，它以在 GPL 第3版之上附加应用一系列许可的方式表现。</p>
<p><strong>3、协议特点：</strong></p>
<p>LGPL和GPL不同，GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同，LGPL允许商业软件通过引用(link)的方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并发布和销售。</p>
<p><strong>4、LGPL的发展和分析：</strong></p>
<p>从第一版的 L 表示 Library 的含义以及其版本号直接和GPL保持一致(第一版就是2.0)可知，该协议是GPL的补充协议，是一个主要为开源类库使用设计的开源协议，因为FSF逐渐意识到，GPL协议的强制传染性在某些场景下太过苛刻，会阻碍开源产品被更广泛的传播和使用，实际上很多软件开发过程中使用开源软件的场景，仅仅是把某个开源软件当做底层的库来引用，针对此种场景，FSF在1991年发布GPL第二版时，发布了LGPL第一版。</p>
<p>LGPL的含义可以理解为：它允许企业与软件开发者将LGPL授权的软件以依赖库链接的形式集成至他们自己的软件内（即使该软件是私有软件也被允许），同时不会受到类似于GPL传染特性的许可证强制对软件开源的限制。但如果修改LGPL协议的代码而产生的衍生代码，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。</p>
<p>采用LGPL的项目本身虽然仍有“Copyleft”的限制条件，但这些限制不会感染到仅仅只链接到本项目的软件。因此LGPL协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。LGPL为了在GPL与其他许可式许可证之间获取折衷，常被用于一些GNU程序库，亦可使用于独立存在的应用程序中，比较有名的例子为 Mozilla 跟 <a href="http://openoffice.org./">http://OpenOffice.Org。</a></p>
<h3 id="MIT"><a href="#MIT" class="headerlink" title="MIT"></a>MIT</h3><p><strong>1、概念：</strong></p>
<p>MIT 许可协议：即 The MIT License，该许可协议之名源自麻省理工学院（Massachusetts Institute of Technology, MIT），又称“X许可协议”（X License）或“X11许可协议”（X11 License）。</p>
<p><strong>2、版本演进历史：</strong></p>
<p>1988，由自麻省理工学院(MIT)发布。</p>
<p><strong>3、协议特点：</strong></p>
<p>MIT许可协议是许多软件许可条款中被广泛使用的其中一种。与其他常见的软件许可协议（如GPL、LGPL、BSD）相比，MIT是相对宽松的软件许可协议，赋予软件被许可人更大的权利与更少的限制。</p>
<p><strong>4、协议分析：</strong></p>
<p>被许可人权利：被许可人有权利使用、复制、修改、合并、出版发行、散布、再许可和/或贩售软件及软件的副本，及授予被供应人同等权利，惟服从以下义务。<br>被许可人义务：在软件和软件的所有副本中都必须包含以上著作权声明和本许可声明。</p>
<p><strong>5、其他重要特性：</strong></p>
<p>此许可协议并非属copyleft的自由软件许可协议条款，允许在自由及开放源代码软件或非自由软件（proprietary software）所使用。<br>MIT的内容可依照软件代码著作权者的需求更改内容，这也是MIT与BSD本质上的不同处。<br>MIT许可协议可与其他许可协议并存。MIT条款也是自由软件基金会（FSF）所认可的自由软件许可协议条款，与GPL兼容。</p>
<p>有许多团体均采用MIT许可证，例如著名的SSH连线软件PuTTY与X窗口系统、Expat、Mono开发平台库、Ruby on Rails、Lua等等也都采用MIT许可协议。</p>
<h3 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h3><p><strong>1、概念：</strong></p>
<p>Apache许可证，即 Apache License，是一个由Apache软件基金会(ASF)发布的自由软件许可证。</p>
<p>Apache许可证最初为 Apache Web 服务器而撰写，Apache许可证在Apache社区内外被广泛使用；Apache基金会下属所有项目都使用Apache许可证；许多非Apache基金会项目也使用了Apache许可证。</p>
<p>官网：<a href="http://www.apache.org/licenses/">http://www.apache.org/licenses/</a></p>
<p><strong>2、版本演进历史：</strong></p>
<p>Apache License 1.0，1995年发布。</p>
<p><a href="http://www.apache.org/licenses/LICENSE-1.0">http://www.apache.org/licenses/LICENSE-1.0</a></p>
<p>Apache License 1.1，2000年发布。<br><a href="http://www.apache.org/licenses/LICENSE-1.1">http://www.apache.org/licenses/LICENSE-1.1</a></p>
<p>Apache License 2.0，2004年发布。<br><a href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p><strong>3、协议要求：</strong></p>
<p>Apache许可证，具体要求如下：</p>
<p>对所有未修改的部分应用相同的许可证，并且在每个许可文件中，必须保留再分发代码中的任何原始著作权、专利、商标和归属通知(不需要包括任何部分的派生作品)；</p>
<p>在每个更改的许可文件中，都必须添加一条通知，说明对该文件进行了更改。</p>
<p>不强制要求派生和修改产物使用相同的许可证进行发布。</p>
<p><strong>4、协议分析说明：</strong></p>
<p>如果声明文本文件是作为原始作品发布的一部分，则派生作品必须包含该通知文本文件的可读副本，可以是文档或显示在软件中。</p>
<p>声明文件的内容不会修改许可证，因为它们仅用于提供信息，并且可以在许可证文本中添加更多属性声明，前提是这些声明不能被理解为修改许可证。修改可能有适当的著作权声明，并可能为修改提供不同的许可条款。</p>
<h3 id="Mozilla-MPL"><a href="#Mozilla-MPL" class="headerlink" title="Mozilla (MPL)"></a>Mozilla (MPL)</h3><p><strong>1、概念：</strong></p>
<p>MPL，即 Mozilla公共许可证，是 Mozilla Public License 的简称，由Mozilla基金会开发并维护。</p>
<p><strong>2、版本演进历史：</strong></p>
<p>第一版，1.0版本，1998年发布。</p>
<p>第二版，1.1版本，其主要变更是理清了关于专利部分的条款，以及允许多个许可证之间共存。</p>
<p>第三版，2.0版本，2012年1月3日发布。该版本使许可协议更加清晰，更加方便应用，同时也兼容于GPL及Apache许可证。</p>
<p>从1.1版本开始，允许遵循MPL许可证的项目里多个许可证的共存，这一特性旨在鼓励与偏好使用GPL许可的开发者合作。1.1版本的结构，法律切合度，以及其对专利权的明确态度都深深的影响了后来流行的许可协议，有点像是第三版的GPL。很多项目都以此派生出他们自己的许可协议，如Sun Microsystems的通用开发与散布许可证。</p>
<p><strong>3、协议特点：</strong></p>
<p>MPL允许在其授权下的源代码与其他授权的文件进行混合，包括私有许可证，但在MPL授权下的代码文件必须保持MPL授权，并且保持开源。</p>
<p>可以理解为：遵循MPL的项目允许使用者对于MPL作品进行二次开发和发布，但MPL的部分、以及修改的部分，需要遵循MPL协议，并对修改部分作出说明，但允许衍生项目中有私有模块的存在。</p>
<p>这样的条款让MPL既不像MIT和BSD那样允许派生作品完全转化为私有，也不像GPL那样要求所有的派生作品包括新的组件在内的作品全部必须保持GPL。</p>
<p>一句话，MPL协议通过允许在派生项目中存在私有模块，同时保证核心文件的开源，同时激励了商业及开源社区来参与帮助开发核心软件。</p>
<p><strong>4、发展与应用：</strong></p>
<p>MPL既是得到自由软件基金会(FSF)承认的自由软件许可证，也是得到开放源代码促进会(OSF)承认的开源软件许可证。</p>
<p>该协议融合了BSD许可证和GNU通用公共许可协议的特性，追求平衡专有软件和开源软件开发者之间的顾虑。</p>
<p>MPL用于 Mozilla Firefox、Mozilla Thunderbird 及其他 Mozilla软件的许可，也被其他产品所用，如Adobe以此为Flex产品线许可，还有LibreOffice 4.0（同时使用LGPLv3）。</p>
<p><strong>对比</strong><br><img src="8ea9ebf985a55a4924d29135f341d7db96481dcb0daf7fc4d6e8a1ca764898a3.png" alt="图 3"><br><img src="ac478febdf707959be88d11b80c3cb90ca6b80ebdc20bd35d9f588b8827ff7e3.png" alt="图 4">  </p>
<h3 id="开源工程中licenses"><a href="#开源工程中licenses" class="headerlink" title="开源工程中licenses"></a>开源工程中licenses</h3><p><img src="21a6eb647e8f2233756b138d55cfdbb919119940a3b58153a8a2b1f459deed47.png" alt="图 2">  </p>
<p><strong>样例</strong></p>
<p>GPLv2  </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line"> * jmnd interface</span><br><span class="line"> *</span><br><span class="line"> * Copyright Jaguarmicro. 2022-2028 </span><br><span class="line"> *</span><br><span class="line"> * This work is licensed under the terms of the GNU GPL, version 2. </span><br><span class="line"> *</span><br><span class="line"> * Contributions after 2012-01-13 are licensed under the terms of the</span><br><span class="line"> * GNU GPL, version 2 or (at your option) any later version.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>


<p> BSD</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/*-</span><br><span class="line"> *   BSD LICENSE</span><br><span class="line"> *</span><br><span class="line"> *   Copyright (c) Jaguarmicro Corporation.</span><br><span class="line"> *   All rights reserved.</span><br><span class="line"> *</span><br><span class="line"> *   Redistribution and use <span class="keyword">in</span> <span class="built_in">source</span> and binary forms, with or without</span><br><span class="line"> *   modification, are permitted provided that the following conditions</span><br><span class="line"> *   are met:</span><br><span class="line"> *</span><br><span class="line"> *     * Redistributions of <span class="built_in">source</span> code must retain the above copyright</span><br><span class="line"> *       notice, this list of conditions and the following disclaimer.</span><br><span class="line"> *     * Redistributions <span class="keyword">in</span> binary form must reproduce the above copyright</span><br><span class="line"> *       notice, this list of conditions and the following disclaimer <span class="keyword">in</span></span><br><span class="line"> *       the documentation and/or other materials provided with the</span><br><span class="line"> *       distribution.</span><br><span class="line"> *     * Neither the name of Intel Corporation nor the names of its</span><br><span class="line"> *       contributors may be used to endorse or promote products derived</span><br><span class="line"> *       from this software without specific prior written permission.</span><br><span class="line"> *</span><br><span class="line"> *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span><br><span class="line"> *   <span class="string">&quot;AS IS&quot;</span> AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span><br><span class="line"> *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span><br><span class="line"> *   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span><br><span class="line"> *   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span><br><span class="line"> *   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span><br><span class="line"> *   LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span><br><span class="line"> *   DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span><br><span class="line"> *   THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span><br><span class="line"> *   (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span><br><span class="line"> *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>

<p>私有licence</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/* xxx.c - XXXXXXXXX */</span><br><span class="line"></span><br><span class="line">/* Copyright 2022-2028 Jaguarmicro Corporation. */</span><br></pre></td></tr></table></figure>

<p>参考vxworks</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/* privateCode.c - uses VM contexts to make data private to a code segment */</span><br><span class="line"></span><br><span class="line">/* Copyright 1984-1997 Wind River Systems, Inc. */</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>licenses</category>
      </categories>
      <tags>
        <tag>licenses</tag>
      </tags>
  </entry>
  <entry>
    <title>Quagga使用</title>
    <url>/2020/09/10/Quagga%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>Quagga是一个开源路由软件套件，可以将Linux变成支持如RIP、OSPF、BGP和IS-IS等主要路由协议的路由器。它具有对IPv4和IPv6的完整支持，并支持路由/前缀过滤。<span id="more"></span></li>
</ul>
<h2 id="网络拓扑"><a href="#网络拓扑" class="headerlink" title="网络拓扑"></a>网络拓扑</h2><p>如下，CentOS位于所述专用链路的两端。两台主机名分别设置为“site-A-RTR”和“site-B-RTR’。下面是IP地址的详细信息。<br><img src="f2c55d4d98ca0648e8e62227eb283e42a15612b325b166af2e15d05d6f6b46df.png" alt="图 16">  </p>
<ul>
<li>Site-A: 192.168.1.0/24</li>
<li>Site-B: 172.16.1.0/24</li>
<li>两个 Linux 路由器之间的对等网络: 10.10.10.0/30</li>
</ul>
<h2 id="Quagga核心"><a href="#Quagga核心" class="headerlink" title="Quagga核心"></a>Quagga核心</h2><ul>
<li>Zebra: 核心守护进程，负责内核接口和静态路由。</li>
<li>Ospfd: IPv4 OSPF 守护进程。</li>
</ul>
<h2 id="在CentOS上安装Quagga"><a href="#在CentOS上安装Quagga" class="headerlink" title="在CentOS上安装Quagga"></a>在CentOS上安装Quagga</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># yum install quagga </span></span><br></pre></td></tr></table></figure>

<p>如果是centos7，则关闭SELinux </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># setenforce 0</span></span><br></pre></td></tr></table></figure>
<p>或者 启用“zebra_write_config”</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># setsebool -P zebra_write_config 1 </span></span><br></pre></td></tr></table></figure>
<p>如果没有做这个修改，则尝试在Quagga命令行中保存配置的时候看到如下错误。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Can<span class="string">&#x27;t open configuration file /etc/quagga/zebra.conf.OS1Uu5.</span></span><br></pre></td></tr></table></figure>
<p>安装完Quagga后，需要配置必要的对等IP地址，并更新OSPF设置。Quagga自带了一个命令行称为vtysh。vtysh里面用到的Quagga命令与主要的路由器厂商如思科和Juniper是相似的。</p>
<h3 id="配置-Zebra"><a href="#配置-Zebra" class="headerlink" title="配置 Zebra"></a>配置 Zebra</h3><p>创建Zebra配置文件，并启用Zebra守护进程。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cp /usr/share/doc/quagga-XXXXX/zebra.conf.sample /etc/quagga/zebra.conf</span></span><br><span class="line"><span class="comment"># service zebra start</span></span><br><span class="line"><span class="comment"># chkconfig zebra on </span></span><br></pre></td></tr></table></figure>
<p>启动vtysh命令行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vtysh </span></span><br></pre></td></tr></table></figure>
<p>配置日志</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">site-A-RTR<span class="comment"># configure terminal</span></span><br><span class="line">site-A-RTR(config)<span class="comment"># log file /var/log/quagga/quagga.log</span></span><br><span class="line">site-A-RTR(config)<span class="comment"># exit</span></span><br><span class="line">site-A-RTR<span class="comment"># write</span></span><br></pre></td></tr></table></figure>
<p>配置IP</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">site-A-RTR<span class="comment"># show interface </span></span><br><span class="line">Interface eth0 is up, line protocol detection is disabled</span><br><span class="line">. . . . .</span><br><span class="line">Interface eth1 is up, line protocol detection is disabled</span><br><span class="line">. . . . .</span><br></pre></td></tr></table></figure>
<p>配置eth0参数:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">site-A-RTR<span class="comment"># configure terminal</span></span><br><span class="line">site-A-RTR(config)<span class="comment"># interface eth0</span></span><br><span class="line">site-A-RTR(config-if)<span class="comment"># ip address 10.10.10.1/30</span></span><br><span class="line">site-A-RTR(config-if)<span class="comment"># description to-site-B</span></span><br><span class="line">site-A-RTR(config-if)<span class="comment"># no shutdown </span></span><br></pre></td></tr></table></figure>
<p>配置eth1参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">site-A-RTR(config)<span class="comment"># interface eth1</span></span><br><span class="line">site-A-RTR(config-if)<span class="comment"># ip address 192.168.1.1/24</span></span><br><span class="line">site-A-RTR(config-if)<span class="comment"># description to-site-A-LAN</span></span><br><span class="line">site-A-RTR(config-if)<span class="comment"># no shutdown </span></span><br></pre></td></tr></table></figure>

<p>验证配置:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">site-A-RTR(config-if)<span class="comment"># do show interface </span></span><br><span class="line">Interface eth0 is up, line protocol detection is disabled</span><br><span class="line">. . . . .</span><br><span class="line">  inet 10.10.10.1/30 broadcast 10.10.10.3</span><br><span class="line">. . . . .</span><br><span class="line">Interface eth1 is up, line protocol detection is disabled</span><br><span class="line">. . . . .</span><br><span class="line">  inet 192.168.1.1/24 broadcast 192.168.1.255</span><br><span class="line">. . . . .</span><br><span class="line"></span><br><span class="line">site-A-RTR(config-if)<span class="comment"># do show interface description </span></span><br><span class="line">Interface      Status  Protocol  Description</span><br><span class="line">eth0           up      unknown   to-site-B</span><br><span class="line">eth1           up      unknown   to-site-A-LAN</span><br></pre></td></tr></table></figure>

<p>永久保存配置:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">site-A-RTR(config-if)<span class="comment"># do write </span></span><br></pre></td></tr></table></figure>

<p>在site-B上重复上面配置IP地址的步骤。<br>如果一切顺利，可以在site-A的服务器上ping通site-B上的对等IP地址10.10.10.2了。<br>注意：一旦Zebra的守护进程启动了，在vtysh命令行中的任何改变都会立即生效。因此没有必要在更改配置后重启Zebra守护进程。</p>
<h3 id="配置OSPF"><a href="#配置OSPF" class="headerlink" title="配置OSPF"></a>配置OSPF</h3><p>创建OSPF配置文件，并启动OSPF守护进程：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cp /usr/share/doc/quagga-XXXXX/ospfd.conf.sample /etc/quagga/ospfd.conf</span></span><br><span class="line"><span class="comment"># service ospfd start</span></span><br><span class="line"><span class="comment"># chkconfig ospfd on </span></span><br></pre></td></tr></table></figure>

<p>现在启动vtysh命令行来继续OSPF配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vtysh</span></span><br></pre></td></tr></table></figure>

<p>输入路由配置模式:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">site-A-RTR<span class="comment"># configure terminal</span></span><br><span class="line">site-A-RTR(config)<span class="comment"># router ospf</span></span><br></pre></td></tr></table></figure>

<p>可选配置路由id:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">site-A-RTR(config-router)<span class="comment"># router-id 10.10.10.1</span></span><br></pre></td></tr></table></figure>

<p>添加在OSPF中的网络:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">site-A-RTR(config-router)<span class="comment"># network 10.10.10.0/30 area 0</span></span><br><span class="line">site-A-RTR(config-router)<span class="comment"># network 192.168.1.0/24 area 0</span></span><br></pre></td></tr></table></figure>

<p>保存：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">site-A-RTR(config-router)<span class="comment"># do write</span></span><br></pre></td></tr></table></figure>

<p>在site-B上重复和上面相似的OSPF配置:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">site-B-RTR(config-router)<span class="comment"># network 10.10.10.0/30 area 0</span></span><br><span class="line">site-B-RTR(config-router)<span class="comment"># network 172.16.1.0/24 area 0</span></span><br><span class="line">site-B-RTR(config-router)<span class="comment"># do write </span></span><br></pre></td></tr></table></figure>

<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><h3 id="通过ping测试"><a href="#通过ping测试" class="headerlink" title="通过ping测试"></a>通过ping测试</h3><p>可以从site-A ping通site-B的LAN子网。确保防火墙没有阻止ping的流量。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@site-A-RTR ~]<span class="comment"># ping 172.16.1.1 -c 2 </span></span><br></pre></td></tr></table></figure>
<h3 id="检查路由表"><a href="#检查路由表" class="headerlink" title="检查路由表"></a>检查路由表</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@site-A-RTR ~]<span class="comment"># ip route </span></span><br><span class="line">10.10.10.0/30 dev eth0  proto kernel  scope <span class="built_in">link</span>  src 10.10.10.1</span><br><span class="line">172.16.1.0/30 via 10.10.10.2 dev eth0  proto zebra  metric 20</span><br><span class="line">192.168.1.0/24 dev eth1  proto kernel  scope <span class="built_in">link</span>  src 192.168.1.1</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@site-A-RTR ~]<span class="comment"># vtysh</span></span><br><span class="line">site-A-RTR<span class="comment"># show ip route </span></span><br><span class="line"></span><br><span class="line">Codes: K - kernel route, C - connected, S - static, R - RIP, O - OSPF,</span><br><span class="line">       I - ISIS, B - BGP, &gt; - selected route, * - FIB route</span><br><span class="line"> </span><br><span class="line">O   10.10.10.0/30 [110/10] is directly connected, eth0, 00:14:29</span><br><span class="line">C&gt;* 10.10.10.0/30 is directly connected, eth0</span><br><span class="line">C&gt;* 127.0.0.0/8 is directly connected, lo</span><br><span class="line">O&gt;* 172.16.1.0/30 [110/20] via 10.10.10.2, eth0, 00:14:14</span><br><span class="line">C&gt;* 192.168.1.0/24 is directly connected, eth1</span><br></pre></td></tr></table></figure>

<h3 id="验证OSPF邻居和路由"><a href="#验证OSPF邻居和路由" class="headerlink" title="验证OSPF邻居和路由"></a>验证OSPF邻居和路由</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@site-A-RTR ~]<span class="comment"># vtysh</span></span><br><span class="line">site-A-RTR<span class="comment"># show ip ospf neighbor </span></span><br></pre></td></tr></table></figure>
<p><img src="19578b06dd67d51e47097962c3632bbd1ff2158ec7803711502c36c53bbb8b31.png" alt="图 17">  </p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>Quagga</tag>
      </tags>
  </entry>
  <entry>
    <title>CPU超线程</title>
    <url>/2020/09/09/CPU%E8%B6%85%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="什么是超线程？"><a href="#什么是超线程？" class="headerlink" title="什么是超线程？"></a>什么是超线程？</h2><ul>
<li>“超线程”（Hyperthreading Technology）技术可以把一个物理内核模拟成两个逻辑内核。在相应的软硬件的支持下大幅度的提高运行效能，从而使单处理器上模拟双处理器的效能。</li>
<li>其实，从实质上说，超线程是一种可以将CPU内部暂时闲置处理资源充分“调动”起来的技术。<span id="more"></span>
<img src="8db9d383c368be72efbd3809ee64bbb29313050a0d8c4942c6691b4b453dc0ac.png" alt="图 10">  </li>
</ul>
<h2 id="CPU超线程原理"><a href="#CPU超线程原理" class="headerlink" title="CPU超线程原理"></a>CPU超线程原理</h2><p>CPU中两个相关的模块：</p>
<ol>
<li>Processing Unit（运算处理单元），简称PU</li>
<li>Architectual State（架构状态单元），简称AS<br>PU一般就是执行运算，比如算数运算加减乘除。<br>AS执行一些逻辑和调度方面的操作，比如控制内存访问等。</li>
</ol>
<p><strong>双核心系统</strong>:<br><img src="4ae42920bf8b3b071dd663d667e015960632be71b009e78288b4e0c203774145.png" alt="双核心系统">  </p>
<p><strong>单核心超线程系统</strong>:<br><img src="7532259dd76bacac58f31a2c87411cc0d03852fe4cf4c803057539df8a4c4708.png" alt="单核心超线程系统">  </p>
<h2 id="Linux下CPU超线程配置查看"><a href="#Linux下CPU超线程配置查看" class="headerlink" title="Linux下CPU超线程配置查看"></a>Linux下CPU超线程配置查看</h2><p>通过 /proc/cpuinfo  查看cpu信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">processor　   ：体系中逻辑核的编号，顺序加1</span><br><span class="line">…..</span><br><span class="line">physical <span class="built_in">id</span>   ：单个物理CPU的标号</span><br><span class="line">siblings      ：此物理CPU种逻辑核总数</span><br><span class="line">core <span class="built_in">id</span>       ：此物理CPU中某物理核的编号</span><br><span class="line">cpu cores     ：此物理CPU的物理核总数</span><br></pre></td></tr></table></figure>

<p>查询是否存在超线程？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/cpuinfo | grep -e <span class="string">&quot;cpu cores&quot;</span>  -e <span class="string">&quot;siblings&quot;</span> | <span class="built_in">sort</span> | <span class="built_in">uniq</span></span><br></pre></td></tr></table></figure>
<p><img src="a2df011701a4d4b337db30c09568b19322141f00ff760e67d6f3f1b06f8ac2dc.png" alt="图 13">  </p>
<p>如果启用超线程， “siblings”是“cpu cores”的2倍。<br><img src="749fc356489c78d2ad189c6abe82436dd6011e5a70429e6f51853ac9ffdd136a.png" alt="图 14"><br>如果未启用超线程， “siblings”等于“cpu cores” 。</p>
<h2 id="哪2个核是超线程兄弟？"><a href="#哪2个核是超线程兄弟？" class="headerlink" title="哪2个核是超线程兄弟？"></a>哪2个核是超线程兄弟？</h2><p>查看 /proc/cpuinfo ， 如果两个逻辑核（processor）的“physical id”和“core id”相同，那么他们就是属于同一物理核的2个超线程逻辑核。<br><img src="51c9d082b993e414d937d40856d2e25c59ce57dd3416a3be997e77a7297cd2e9.png" alt="图 15">  </p>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>linux调优</title>
    <url>/2020/09/08/linux%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<p>下图诠释了linux内核各个模块对应的调优诊断工具</p>
<span id="more"></span>
<p><img src="89be2ee91d755c1a58c33374e212ad341d9c339261a8b444c1aab29cfdd02d38.png" alt="图 28">       </p>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>调优</tag>
      </tags>
  </entry>
  <entry>
    <title>ethtool调优</title>
    <url>/2020/09/07/ethtool%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<h2 id="网卡多队列"><a href="#网卡多队列" class="headerlink" title="网卡多队列"></a>网卡多队列</h2><p>如果网卡及其驱动支持 RSS/多队列，那你可以会调整 RX queue（也叫 RX channel）的数量。这可以用 ethtool 完成。<br>查看 RX queue 数量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo ethtool -l eth0</span><br><span class="line">Channel parameters <span class="keyword">for</span> eth0:</span><br><span class="line">Pre-<span class="built_in">set</span> maximums:</span><br><span class="line">RX:   0</span><br><span class="line">TX:   0</span><br><span class="line">Other:    0</span><br><span class="line">Combined: 8</span><br><span class="line">Current hardware settings:</span><br><span class="line">RX:   0</span><br><span class="line">TX:   0</span><br><span class="line">Other:    0</span><br><span class="line">Combined: 4</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<p>这里可以看到允许的最大值（网卡及驱动限制），以及当前设置的值。</p>
<h2 id="调整RX-queues"><a href="#调整RX-queues" class="headerlink" title="调整RX queues"></a>调整RX queues</h2><p>设置 combined 类型网卡的收发队列为 8 个：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo ethtool -L eth0 combined 8</span><br></pre></td></tr></table></figure>
<p>如果你的网卡支持独立的 RX 和 TX 队列数量，那你可以只修改 RX queue 数量：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo ethtool -L eth0 rx 8</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：对于大部分驱动，修改以上配置会使网卡先 down 再 up，因此会造成丢包。请酌情使用。</p>
<p>kvm中设置网卡多队列：<br>编辑虚拟机yaml文件，添加 <driver name="vhost" queues="4"><br>一般队列数和虚拟机的vcpu保持一致</driver></p>
<h2 id="网卡队列长度"><a href="#网卡队列长度" class="headerlink" title="网卡队列长度"></a>网卡队列长度</h2><p>增加RX queue 的大小可以在流量很大的时候缓解丢包问题，但是，只调整这个还不够，软件层面仍然可能会丢包，因此还需要其他的一些调优才能彻底的缓解或解决丢包问题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo ethtool -g eth0</span><br><span class="line">Ring parameters <span class="keyword">for</span> eth0:</span><br><span class="line">Pre-<span class="built_in">set</span> maximums:</span><br><span class="line">RX:   4096</span><br><span class="line">RX Mini:  0</span><br><span class="line">RX Jumbo: 0</span><br><span class="line">TX:   4096</span><br><span class="line">Current hardware settings:</span><br><span class="line">RX:   512</span><br><span class="line">RX Mini:  0</span><br><span class="line">RX Jumbo: 0</span><br><span class="line">TX:   512</span><br></pre></td></tr></table></figure>

<p>以上显式网卡支持最多 4096 个接收和发送 descriptor（描述符，简单理解，存放的是指向包的指针），但是现在只用到了 512 个。</p>
<p>用 ethtool -G 修改 queue 大小：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo ethtool -G eth0 rx 4096</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：对于大部分驱动，修改以上配置会使网卡先 down 再 up，因此会造成丢包。请酌情使用。</p>
<h2 id="网卡RSS"><a href="#网卡RSS" class="headerlink" title="网卡RSS"></a>网卡RSS</h2><p>可以用 ethtool 调整 RSS 计算哈希时所使用的字段。<br>查看 UDP RX flow 哈希所使用的字段：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo ethtool -n eth0 rx-flow-hash udp4</span><br><span class="line">UDP over IPV4 flows use these fields <span class="keyword">for</span> computing Hash flow key:</span><br><span class="line">IP SA</span><br><span class="line">IP DA</span><br></pre></td></tr></table></figure>
<p>可以看到只用到了源 IP（SA：Source Address）和目的 IP。</p>
<p>我们接下来修改一下，加入源端口和目的端口：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ sudo ethtool -N eth0 rx-flow-hash udp4 sdfn</span><br></pre></td></tr></table></figure>

<p>其中：<br>对于udp协议来说<code>f</code>、<code>n</code>为源端口、目的端口，<code>s</code>、<code>d</code>为源ip、目的ip<br>使用这种方法，可以改变RSS通道的分配方法。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//查看</span><br><span class="line"><span class="comment"># ethtool -n eth0 rx-flow-hash udp4    </span></span><br><span class="line">UDP over IPV4 flows use these fields <span class="keyword">for</span> computing Hash flow key:</span><br><span class="line">IP SA</span><br><span class="line">IP DA</span><br><span class="line">//修改</span><br><span class="line"><span class="comment"># ethtool -N eth0 rx-flow-hash udp4 sdfn</span></span><br><span class="line">//再次查看</span><br><span class="line"><span class="comment"># ethtool -n eth0 rx-flow-hash udp4     </span></span><br><span class="line">UDP over IPV4 flows use these fields <span class="keyword">for</span> computing Hash flow key:</span><br><span class="line">IP SA</span><br><span class="line">IP DA</span><br><span class="line">L4 bytes 0 &amp; 1 [TCP/UDP src port]</span><br><span class="line">L4 bytes 2 &amp; 3 [TCP/UDP dst port]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>ETHTOOL</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>ethtool</tag>
      </tags>
  </entry>
  <entry>
    <title>inet_ntoa函数</title>
    <url>/2020/09/06/inet-ntoa%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="inet-ntoa简介"><a href="#inet-ntoa简介" class="headerlink" title="inet_ntoa简介"></a>inet_ntoa简介</h2><ul>
<li>char *inet_ntoa(struct in_addr in);</li>
<li>功能：将一个十进制网络字节序转换为点分十进制IP格式的字符串<span id="more"></span></li>
<li>参数：<br>  一个网络上的IP地址</li>
<li>返回值：<br>  如果正确，返回一个字符指针，指向一块存储着点分格式IP地址的静态缓冲区（同一线程内共享此内存）；<br>  错误，返回NULL。</li>
</ul>
<h2 id="使用问题"><a href="#使用问题" class="headerlink" title="使用问题"></a>使用问题</h2><p>inet_ntoa函数连续调用两次产生的返回值相同。<br><img src="315ac77f2681b218a2701ea836cb2a74d07052becaf5f2a71605bea15345c483.png" alt="图 21"><br><img src="3a48ee6e4345a6810adaf407431ccb74efa9b8ec44ce3b8d8568661f6b327d5e.png" alt="图 22">  </p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p><img src="9530d8ccccab525d7451505cf66fadef6cb1b5ad4674e9f6aefc69343cc76463.png" alt="图 23">  </p>
<ul>
<li>根据官网定义，我们看到inet_ntoa函数返回一个字符指针，它指向一个定义在函数inet_ntoa中的static 类型字符串。</li>
<li>也就是说，每次调用inet_ntoa函数，都会改变最后一次调用inet_ntoa函数时得到的结果。</li>
</ul>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>如果需要把结果保存下来，那么可以在每次调用inet_ntoa函数后调用strcpy函数或memcpy函数将结果存到自定义的字符串中。<br><img src="cf7e364079c402d99b28829a660ca87519e1536edb4f4c7e5218821fe82c64e7.png" alt="图 24"><br><img src="88cf94fcfcb14a4fcc299a576c6852f0d8d6b71acef5e1b30756bfc08d0c24e0.png" alt="图 25">  </p>
]]></content>
      <categories>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>inet_ntoa</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS Flag Day</title>
    <url>/2020/09/05/DNS-Flag-Day/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>2019 年 02 月 01 日由 Google、Cloudflare、Cisco、PowerDNS、ISC(BIND) 等知名 DNS 服务提供商将不再主动采用”EDNS error workaround”获取域名 NS 服务器的解析记录。</li>
<li>当前 DNS 响应速度没必要地慢，并且无法部署新功能。为了解决这些问题，DNS 软件供应商以及大型公共 DNS 提供商将在 2019 年 2 月 1 日删除某些解决方法”EDNS error workaround”。<span id="more"></span></li>
<li>Google 公共DNS服务：8.8.8.8 </li>
<li>Cloudflare公共DNS服务：1.1.1.1</li>
<li>PowerDNS、ISC：DNS软件提供商，开源软件</li>
</ul>
<h2 id="DNS-Flag-Day-缘由"><a href="#DNS-Flag-Day-缘由" class="headerlink" title="DNS Flag Day 缘由"></a>DNS Flag Day 缘由</h2><ul>
<li>DNS 扩展机制于 1999 年制定，2013 年稍作更新，建立了用 EDNS 选项或标志回复查询的 “道路规则”。尽管如此，一些实现仍然违反规则。DNS 软件开发人员试图通过各种非标准行为的变通方法来解决 DNS 协议的互操作性问题，特别是其 EDNS 扩展（RFC 6891 标准）。这与具有通行权的驾驶员在继续之前在交叉路口犹豫的方式没有什么不同，如果交叉路口中有另一个驾驶员表现不正常。这些变通办法使 DNS 软件过于复杂，现在也对 DNS 产生负面影响。</li>
<li>主要变化是来自上述供应商的 DNS 软件过去会将 DNS 查询超时解释为网络或服务器问题的标志。从 2019 年 2 月 1 日开始，将不会尝试禁用 EDNS 作为对 DNS 查询超时的反应。</li>
<li>这实际上意味着所有对 EDNS 查询完全没有响应的 DNS 服务器将被视为死机。</li>
</ul>
<h2 id="DNS-Flag-Day-检查"><a href="#DNS-Flag-Day-检查" class="headerlink" title="DNS Flag Day 检查"></a>DNS Flag Day 检查</h2><ul>
<li>为了检查 EDNS 的合规性，建议您使用项目主页的工具，为整个域生成简化的检查结果。</li>
<li>可以使用 <a href="https://ednscomp.isc.org/ednscomp">ednscomp</a> 工具测试 NS 服务器的实现，以确保正确处理 EDNS。</li>
<li>值得注意的是，EDNS 仍然不是强制性的。如果决定不支持 EDNS，只要您的 NS 服务器根据 EDNS 标准第 7 节回复即可。</li>
</ul>
<h2 id="部分知名网站的检查结果"><a href="#部分知名网站的检查结果" class="headerlink" title="部分知名网站的检查结果"></a>部分知名网站的检查结果</h2><p><img src="6cf818cb24706eff78b66f893388f1bbd4dd48dc81b0309bb5ce444d130f40ea.png" alt="图 15"><br><img src="da968feec46613df7e09a9861f61cb67dee7afc1c96bb546f7ede59d8b353c15.png" alt="图 16"><br><img src="1983f2152e994ad09be2385e35412d7204e2720ed695cac77b8d9bdd444963c6.png" alt="图 17">  </p>
<h2 id="江苏移动授权服务器的检查结果"><a href="#江苏移动授权服务器的检查结果" class="headerlink" title="江苏移动授权服务器的检查结果"></a>江苏移动授权服务器的检查结果</h2><p><img src="81fd00778366859f9a322ec868fd58db0a25dbc4d98e036d89a4e5c3fa5b8277.png" alt="图 18">  </p>
<h2 id="江苏移动授权服务器的问题"><a href="#江苏移动授权服务器的问题" class="headerlink" title="江苏移动授权服务器的问题"></a>江苏移动授权服务器的问题</h2><p><img src="71136f54bf04d34711bbeef9d486eddad8f2318d71c6b519e73f84391de2ac50.png" alt="图 19">  </p>
<h2 id="问题解读"><a href="#问题解读" class="headerlink" title="问题解读"></a>问题解读</h2><p><img src="61adfa43a14debd5b0331e7d2326afe16f14d4a5bb83935dcffd48d6ab55d8a6.png" alt="图 20">  </p>
<h2 id="问题影响分析"><a href="#问题影响分析" class="headerlink" title="问题影响分析"></a>问题影响分析</h2><ul>
<li>DNS Flag Day 本质上是DNS软件开发商对目前仍在运行的不能遵守EDNS规范各类授权服务器的新的应对处理措施。</li>
<li>以前的处理措施比较宽容，会采取EDNS错误应对措施（EDNS error workaround）。<br>比如：如果递归服务器请求包携带EDNS数据，而授权服务器无应答，超时后，递归服务器会认为授权服务器可能不支持EDNS，再发一次不携带EDNS的请求包到授权服务器。这样以来，会使得递归服务器程序逻辑复杂，运行缓慢。</li>
<li>现在，这样的错误应对措施将从2019年2月1号开始从发布或部署的代码里去除。</li>
<li>但这样的影响仅限于发布的代码，不影响现行部署的程序。也可能会影响Google和Cloudflare的公共DNS。如果一个用户的DNS设置为Google的DNS，在2月1日后访问网络可能会受到影响。但如果用户使用的是缺省的运营商DNS，则完全不受影响。</li>
</ul>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>经过测试发现：<br>江苏移动的授权服务器对正常的EDNS数据能够正确应答，返回正确的数据。但缺少对EDNS版本号的校验，而一般情况下，正常的请求是不会使用非法的EDNS版本来请求数据的。因此基本上不会有什么影响。<br>另外，授权服务器不支持EDNS的TCP请求。</p>
<p>以上与EDNS规范不兼容的问题可以通过后续版本升级来解决。</p>
]]></content>
      <categories>
        <category>DNS</category>
      </categories>
      <tags>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS安全防护</title>
    <url>/2020/09/04/DNS%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4/</url>
    <content><![CDATA[<h2 id="DDOS攻击"><a href="#DDOS攻击" class="headerlink" title="DDOS攻击"></a>DDOS攻击</h2><p>DDoS （Distributed Denial ofservice）攻击通过僵尸网络利用各种服务请求耗尽被攻击网络的系统资源，造成被攻击网络无法处理合法用户的请求。而针对DNS的DDoS攻击又可按攻击发起者和攻击特征进行分类。主要表现特征如下：</p>
<span id="more"></span>
<ul>
<li>按照攻击发起者分类<br>僵尸网络：控制僵尸网络，利用真实DNS协议栈发起大量域名查询请求。<br>模拟工具：利用工具软件伪造源IP发送海量DNS查询。</li>
<li>按照攻击特征分类<br>Flood攻击：发送海量DNS查询报文导致网络带宽耗尽而无法传送正常DNS查询请求。<br>资源消耗攻击：发送大量非法域名查询报文引起DNS服务器持续进行迭代查询，从而达到较少的攻击流量消耗大量服务器资源的目的。<br><img src="89fc7f078285dd51ea13a165feb02772818d1a411478cb078d4d03432d397e7c.png" alt="图 9">  </li>
</ul>
<h2 id="DNS欺骗"><a href="#DNS欺骗" class="headerlink" title="DNS欺骗"></a>DNS欺骗</h2><p>（1）缓存污染：攻击者采用特殊的DNS请求，将虚假信息放入DNS的缓存中。<br><img src="af4d51c4482f05a0efdc6fa06dbbcc7550ff0385d1b022d433ed037bfdd2ed32.png" alt="图 10">  </p>
<p>（2）DNS信息劫持 ：攻击者监听DNS会话，猜测DNS服务器响应ID，抢先将虚假的响应提交给客户端。<br>（3）DNS重定向 ：将DNS名称查询重定向到恶意DNS服务器。<br><img src="0d8f88647eea3363d83cca8abc754b547dcdfa6c3982a4e91493d73b08adfab4.png" alt="图 11">  </p>
<h2 id="DNS安全防护措施"><a href="#DNS安全防护措施" class="headerlink" title="DNS安全防护措施"></a>DNS安全防护措施</h2><p>（1）提供至少2个以上的DNS服务地址。<br>用户的DNS解析服务可以进行轮循处理，只要保证一个DNS服务器运转正常，即可确认网站的访问将不受故障影响，尽量减少宕机的比率。<br>（2）智能DNS解析支持多路线多区域。<br>通过链路负载均衡功能将流量分配到不同的服务器上，可减少各种灾害带来的影响。<br>（3）DNS解析对外具有高防功能。<br>在抵御外来网络攻击方面DNS解析服务器需要做充分的准备，此外，宕机检测也是DNS解析里一大重要功能。系统将对域名进行24小时不间断检测，当其中有服务器出现故障问题时，宕机检测将对用户的解析自动切换到预先设置的备用服务器IP，应急响应到场时间不超过设定时间，保证业务访问的可持续性。<br>（4）建议采用TSIG和DNSSEC技术。</p>
<h2 id="DNSSEC技术"><a href="#DNSSEC技术" class="headerlink" title="DNSSEC技术"></a>DNSSEC技术</h2><p>域名系统安全扩展：Domain Name System Security Extensions</p>
<ul>
<li>DNSSEC通过公私钥验证的方式，服务端用私钥为每一条资源记录添加数字签名响应给客户端，客户端用公钥对签名进行验证，从而保证安全。</li>
<li>DNSSEC 就是一个对现有 DNS 协议进行安全完善的拓展。他在现有的 DNS 协议的基础上，增加了几个新的资源记录来达到这个目的。</li>
<li>新增四种资源记录类型：RRSIG (Resource Record Signature)、DNSKEY (DNS Public Key)、DS (Delegation Signer)、NSEC（用于验证不存在的资源记录）</li>
</ul>
<h2 id="RRSIG-（Resource-Record-Signature）"><a href="#RRSIG-（Resource-Record-Signature）" class="headerlink" title="RRSIG （Resource Record Signature）"></a>RRSIG （Resource Record Signature）</h2><p>该记录用于存放我们当前域名每一条记录的 DNSSEC 签名。</p>
<ul>
<li>算法类型 (参考附录「算法类型列表」)</li>
<li>标签 (泛解析中原先 RRSIG 记录的名称)</li>
<li>原 TTL 大小</li>
<li>签名失效时间</li>
<li>签名签署时间</li>
<li>Key 标签 (一个简短的数值，用来迅速判断应该用那个 DNSKEY 记录来验证)</li>
<li>签名名称 (用于验证该签名的 DNSKEY 名称)</li>
<li>加密签名<br><img src="6ffda5232e8de5dc23bb20be0133916679e12b301bf14917d252f22a2b3199ff.png" alt="图 12">  </li>
</ul>
<h2 id="DNSKEY-DNS-Public-Key"><a href="#DNSKEY-DNS-Public-Key" class="headerlink" title="DNSKEY(DNS Public Key)"></a>DNSKEY(DNS Public Key)</h2><p>该记录用于存放我们用于检查 DNSSEC 签名的公钥</p>
<ul>
<li>标识符 (Zone Key (DNSSEC密钥集) 以及 Secure Entry Point (KSK和简单密钥集))</li>
<li>协议 (固定值3 向下兼容)</li>
<li>算法类型 (参考附录「算法类型列表」)</li>
<li>公钥内容<br><img src="81ba5fc3cacbf8cf441dc74465fd3a2925bde7bd523d69cb844bfb76bcd8062b.png" alt="图 13">  </li>
</ul>
<h2 id="DS（Delegation-Signer"><a href="#DS（Delegation-Signer" class="headerlink" title="DS（Delegation Signer)"></a>DS（Delegation Signer)</h2><p>为什么挟持者不把 RRSIG 以及 DNSKEY 记录也给污染了呢？</p>
<ul>
<li>DS用于存放 DNSSEC 公钥的散列值</li>
<li>Key 标签 (一个简短的数值，用来迅速判断应该用那个 DNSKEY 记录来验证)</li>
<li>算法类型 (参考附录「算法类型列表」)</li>
<li>摘要类型 (创建摘要值的加密散列算法)(参考附录「摘要类型列表」)</li>
<li>Digest: A cryptographic hash value of the referenced DNSKEY-record.<br><img src="d798c60c403b0e651ba7406ee84c5aa13d5f9df50ab5593245140703e8032196.png" alt="图 14">  </li>
</ul>
<h2 id="DNSSEC现状及问题"><a href="#DNSSEC现状及问题" class="headerlink" title="DNSSEC现状及问题"></a>DNSSEC现状及问题</h2><ul>
<li>无法保证私密性<br>DNSSEC 并没有改变 DNS 基于 UDP 的通讯方式，数据流也都是明文传输，他所做的只是加上了一个数字签名，而中间人依然可以看到你请求了什么、结果是什么</li>
<li>挟持发生时不能告诉用户真正的记录<br>当用户的 DNS 被挟持的时候，用户通过检查 DNSSEC 签名，可以知道自己得到的并不是真正的解析结果，而是得到了一个被伪造的地址。但是，用户并不知道真正的解析结果是什么。</li>
<li>支持 DNSSEC 的递归服务器并不多</li>
</ul>
]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>DNS</tag>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title>shmget和shm_open</title>
    <url>/2020/09/03/shmget%E5%92%8Cshm-open/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>现代Linux有两种共享内存机制：</p>
<ul>
<li>POSIX共享内存(shm_open()、shm_unlink())</li>
<li>System V共享内存(shmget()、shmat()、shmdt())<span id="more"></span></li>
</ul>
<h2 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h2><ol>
<li>接口的区别，如上</li>
<li>shm_open通过mmap映射到文件/dev/shm/中</li>
<li>shmget通过ipcs查询</li>
</ol>
<p><strong>注意</strong><br>虽然shm_open映射到文件，但是系统重启后，仍然会丢失/dev/shm/文件，其持久性与shmget相当</p>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><h3 id="shm-open"><a href="#shm-open" class="headerlink" title="shm_open"></a>shm_open</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> test_shm_mmap_svr 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> test_shm_mmap_svr</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHMSZ     27</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHM_NAME     <span class="string">&quot;mmap_test&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> shmid;</span><br><span class="line">    <span class="type">char</span> *shm, *s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Create the segment.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((shmid = shm_open(SHM_NAME, O_CREAT | O_RDWR, <span class="number">0644</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shm_open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ftruncate(shmid, SHMSZ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;ftruncate&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Now we attach the segment to our data space.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	shm = mmap(<span class="number">0</span>, SHMSZ, PROT_READ | PROT_WRITE,</span><br><span class="line">			MAP_SHARED | MAP_POPULATE, shmid, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (shm == (<span class="type">char</span> *) <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Now put some things into the memory for the</span></span><br><span class="line"><span class="comment">     * other process to read.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    s = shm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (c = <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; c++)</span><br><span class="line">        *s++ = c;</span><br><span class="line">    *s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Finally, we wait until the other process </span></span><br><span class="line"><span class="comment">     * changes the first character of our memory</span></span><br><span class="line"><span class="comment">     * to &#x27;*&#x27;, indicating that it has read what </span></span><br><span class="line"><span class="comment">     * we put there.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> (*shm != <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> test_shm_mmap_cli 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> test_shm_mmap_cli</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHMSZ     27</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHM_NAME     <span class="string">&quot;mmap_test&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> shmid;</span><br><span class="line">    <span class="type">char</span> *shm, *s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Locate the segment.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((shmid = shm_open(SHM_NAME, O_CREAT | O_RDWR, <span class="number">0644</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shm_open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ftruncate(shmid, SHMSZ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;ftruncate&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Now we attach the segment to our data space.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	shm = mmap(<span class="number">0</span>, SHMSZ, PROT_READ | PROT_WRITE,</span><br><span class="line">			MAP_SHARED | MAP_POPULATE, shmid, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (shm == (<span class="type">char</span> *) <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Now read what the server put in the memory.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (s = shm; *s != <span class="number">0</span>; s++)</span><br><span class="line">        <span class="built_in">putchar</span>(*s);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Finally, change the first character of the </span></span><br><span class="line"><span class="comment">     * segment to &#x27;*&#x27;, indicating we have read </span></span><br><span class="line"><span class="comment">     * the segment.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    *shm = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>运行结果：<br><img src="cb535ff7ff0bf31aeb696788e261ecfd4d85723a4ce4c2129a3d2862ebcddfb7.png" alt="图 1"><br><img src="b4b8b776f8ccb3861330fbb1f8cfa9ed0f82d8ffdfc23b29cfe99044c8d8219b.png" alt="图 2">  </p>
<h3 id="shmget"><a href="#shmget" class="headerlink" title="shmget"></a>shmget</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> test_shm_sysv_svr 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> test_shm_sysv_svr</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHMSZ     27</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> shmid;</span><br><span class="line">    <span class="type">key_t</span> key;</span><br><span class="line">    <span class="type">char</span> *shm, *s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We&#x27;ll name our shared memory segment</span></span><br><span class="line"><span class="comment">     * &quot;5678&quot;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    key = <span class="number">5678</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Create the segment.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((shmid = shmget(key, SHMSZ, IPC_CREAT | <span class="number">0666</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Now we attach the segment to our data space.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((shm = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>)) == (<span class="type">char</span> *) <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmat&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Now put some things into the memory for the</span></span><br><span class="line"><span class="comment">     * other process to read.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    s = shm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (c = <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; c++)</span><br><span class="line">        *s++ = c;</span><br><span class="line">    *s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Finally, we wait until the other process </span></span><br><span class="line"><span class="comment">     * changes the first character of our memory</span></span><br><span class="line"><span class="comment">     * to &#x27;*&#x27;, indicating that it has read what </span></span><br><span class="line"><span class="comment">     * we put there.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> (*shm != <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> test_shm_sysv_cli 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> test_shm_sysv_cli</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHMSZ     27</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> shmid;</span><br><span class="line">    <span class="type">key_t</span> key;</span><br><span class="line">    <span class="type">char</span> *shm, *s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We need to get the segment named</span></span><br><span class="line"><span class="comment">     * &quot;5678&quot;, created by the server.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    key = <span class="number">5678</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Locate the segment.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((shmid = shmget(key, SHMSZ, <span class="number">0666</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Now we attach the segment to our data space.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((shm = shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>)) == (<span class="type">char</span> *) <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shmat&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Now read what the server put in the memory.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (s = shm; *s != <span class="number">0</span>; s++)</span><br><span class="line">        <span class="built_in">putchar</span>(*s);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Finally, change the first character of the </span></span><br><span class="line"><span class="comment">     * segment to &#x27;*&#x27;, indicating we have read </span></span><br><span class="line"><span class="comment">     * the segment.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    *shm = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> test_shm_mmap_svr 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> test_shm_mmap_svr</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHMSZ     27</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHM_NAME     <span class="string">&quot;mmap_test&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">int</span> shmid;</span><br><span class="line">    <span class="type">char</span> *shm, *s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * We&#x27;ll name our shared memory segment</span></span><br><span class="line"><span class="comment">     * &quot;5678&quot;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Create the segment.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> ((shmid = shm_open(SHM_NAME, O_CREAT | O_RDWR, <span class="number">0644</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;shm_open&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ftruncate(shmid, SHMSZ) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		perror(<span class="string">&quot;ftruncate&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Now we attach the segment to our data space.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	shm = mmap(<span class="number">0</span>, SHMSZ, PROT_READ | PROT_WRITE,</span><br><span class="line">			MAP_SHARED | MAP_POPULATE, shmid, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (shm == (<span class="type">char</span> *) <span class="number">-1</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;mmap&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Now put some things into the memory for the</span></span><br><span class="line"><span class="comment">     * other process to read.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    s = shm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (c = <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; c++)</span><br><span class="line">        *s++ = c;</span><br><span class="line">    *s = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Finally, we wait until the other process </span></span><br><span class="line"><span class="comment">     * changes the first character of our memory</span></span><br><span class="line"><span class="comment">     * to &#x27;*&#x27;, indicating that it has read what </span></span><br><span class="line"><span class="comment">     * we put there.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> (*shm != <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：<br><img src="32003a2bceafdc4d4a9f92696a4e83a8512fbc5777b5c5c046092335a23c9a0b.png" alt="图 3"><br><img src="10ae700eeae7568b2cc0fb17020428c33edd19504ad8e458a1eceff292a4ecb3.png" alt="图 4">  </p>
]]></content>
      <categories>
        <category>IPC</category>
      </categories>
      <tags>
        <tag>IPC</tag>
        <tag>共享内存</tag>
      </tags>
  </entry>
  <entry>
    <title>授权域配置</title>
    <url>/2020/09/03/%E6%8E%88%E6%9D%83%E5%9F%9F%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="DNS的资源记录"><a href="#DNS的资源记录" class="headerlink" title="DNS的资源记录"></a>DNS的资源记录</h2><p>A：IPV4地址。<br>AAAA：IPV6地址。<br>NS：名称服务器，说明该域有哪些DNS服务器提供解析服务。</p>
<span id="more"></span>
<p>SOA：起始授权机构(SOA) 资源记录。指示区域的源名称，并包含作为区域主要信息源的服务器的名称。它还表示该区域的其他基本属性。SOA 资源记录在任何标准区域中始终是首位记录。它表示最初创建它的DNS服务器或现在是该区域的主服务器的DNS服务器。它还用于存储会影响区域更新或过期的其他属性，如版本信息和计时。这些属性会影响在该区域的权威服务器之间进行区域传输的频繁程度语法：owner  TTL  CLASS SOA  name_server  responsible_person(serial_number  refresh_interval  retry_interval  expiration  minimum_time_to_live)<br><img src="0b96b12c242b619ad5738f79042759f28698baa21803959d0b684b4dcdf5f285.png" alt="图 5"><br>CNAME：别名记录。<br>PTR：反解。从IP到域名的映射。<br>MX：邮件交换器(MX) 资源记录如mail_exchanger_host中指定的那样，为邮件交换器主机提供邮件路由，以便将邮件发送给owner字段中指定的域名。preference表示在指定了多个交换器主机情况下的首选顺序。每个交换机主机都必须在有效区域中有一个相应的主机(A) 地址资源记录（RFC 1035）。<br>语法：owner  TTL  CLASS  MX  preference mail_exchanger_host<br>例如：mail.com. IN MX 10 baidu.mail.com.</p>
<h2 id="授权域的配置"><a href="#授权域的配置" class="headerlink" title="授权域的配置"></a>授权域的配置</h2><p><img src="6f5d9a7d33ade6609beea1aea74a660b08e94fd7e2be598ab1461964be4bd1d4.png" alt="图 6"><br><img src="49e60c99b98d6ba7484a7faa02127d8373d7745f7bc2f631773e37552970d22a.png" alt="图 7"><br><img src="b00556a6a996bca54a8b00d9819839d940164e71b9b40126811ae46b7429899f.png" alt="图 8">  </p>
]]></content>
      <categories>
        <category>DNS</category>
      </categories>
      <tags>
        <tag>DNS</tag>
        <tag>授权域</tag>
      </tags>
  </entry>
  <entry>
    <title>DPDK文档的错误</title>
    <url>/2020/09/02/DPDK%E6%96%87%E6%A1%A3%E7%9A%84%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<h2 id="DPDK文档里的一个坑"><a href="#DPDK文档里的一个坑" class="headerlink" title="DPDK文档里的一个坑"></a>DPDK文档里的一个坑</h2><p>rte_mempool_get_bulk的返回值注释有误</p>
<span id="more"></span>
<p><img src="9eb3bb869095b85e13fd4ce5b831fa4593525b74955a6df910a44110daa0b61a.png" alt="图 11">  </p>
<p><img src="2419fa7680d4eefae69cbace4cf3f2f39576cc6b09f75b7ba46392daa414246e.png" alt="图 12">  </p>
<h2 id="错误码意义"><a href="#错误码意义" class="headerlink" title="错误码意义"></a>错误码意义</h2><p><strong>#define ENOENT 2 /* No such file or directory */</strong><br><strong>#define ENOBUFS 105 /* No buffer space available */</strong></p>
<h2 id="代码错误判断"><a href="#代码错误判断" class="headerlink" title="代码错误判断"></a>代码错误判断</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">dns_decode_proc</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (!force_quit) &#123;</span><br><span class="line">		<span class="keyword">while</span> (!force_quit) &#123;</span><br><span class="line">			<span class="keyword">if</span> (rte_ring_sc_dequeue_bulk(</span><br><span class="line">				  process_ring, (<span class="type">void</span>**)pkts_burst, MAX_PKT_BURST, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			usleep(<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (!force_quit) &#123;</span><br><span class="line">			<span class="keyword">if</span> (rte_mempool_get_bulk(</span><br><span class="line">				  logstr_pool, (<span class="type">void</span>**)logs, MAX_PKT_BURST) == -ENOENT) &#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_PKT_BURST; i++) &#123;</span><br><span class="line">			logs[i]-&gt;len = <span class="number">0</span>;</span><br><span class="line">			m = pkts_burst[i];</span><br><span class="line">			<span class="type">uint8_t</span>* data = rte_pktmbuf_mtod(m, <span class="type">uint8_t</span>*);</span><br><span class="line">			<span class="type">int</span> data_len = m-&gt;data_len;</span><br><span class="line">			dns_packet_decode(dctx, logs[i], data, data_len, &amp;ts);</span><br><span class="line">			rte_pktmbuf_free(m);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		ret = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (ret == <span class="number">0</span> &amp;&amp; !force_quit) &#123;</span><br><span class="line">			ret = rte_ring_sp_enqueue_bulk(</span><br><span class="line">			  logstr_ring, (<span class="type">void</span>**)logs, MAX_PKT_BURST, <span class="literal">NULL</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>DPDK</category>
      </categories>
      <tags>
        <tag>DPDK</tag>
      </tags>
  </entry>
  <entry>
    <title>redhat root密码丢失找回</title>
    <url>/2020/09/02/redhat-root%E5%AF%86%E7%A0%81%E4%B8%A2%E5%A4%B1%E6%89%BE%E5%9B%9E/</url>
    <content><![CDATA[<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>使用redhat忘记root密码</p>
<span id="more"></span>
<h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><ol>
<li>启动redhat linux出现倒计时界面如下图<br><img src="83b1c96ee941ee6bf0e6b9783178de78d7fff6824b5f5ef249c5e0700b7b1bb5.png" alt="图 1">  </li>
<li>此时按任意键出现下图<br><img src="ed05bfb130f05f6ff9f9282e0fcb3fa26a4b4c3e97d049b1272c672d8831b995.png" alt="图 2">  </li>
<li>此时按e键出现下图<br><img src="128b2fa624ce97e4ddadd1d6d9b73ace478dfceca6d8512201dd1281ddf6f045.png" alt="图 3">  </li>
<li>按下箭头，走到第二个选项，按e键出现下图<br><img src="4fc064a4d48d511ac16c3dc1560273a2ad356a8f559c08c712e6598b6dc9f440.png" alt="图 4">  </li>
<li>输入：空格1，或者空格single，回车出现下图<br><img src="9fe4dbaaf140dd1b0ee551faac3b46a9910c0d5769f5f417d61dcea7d706e622.png" alt="图 5">  </li>
<li>此时按b键出现下图<br><img src="9eb3370c94d2fa2162f2649d263e2ace42c1d2b46e7cd1cc9f5de8af373a3434.png" alt="图 6">  </li>
<li>等待若干秒后出现下图界面，此时我们已经成功进入了单用户<br><img src="91126e6cbd1e2bc0829e947288103349cf1c4490673fb1126abd5b9c2c1c873b.png" alt="图 7">  </li>
<li>此时只需要输入passwd回车就可以修改root用户的密码<br><img src="db7b0cdde44f6b1d757b5d139844da3aed78c7b2be46d303b041a1906b6a9288.png" alt="图 8">  </li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul>
<li>密码需要确认一次才能修改成功，此时输入reboot重启，就可以用刚才设置的密码登陆系统</li>
<li>需要说明的是进入单用户模式的前提是grub没有加密。</li>
</ul>
]]></content>
      <categories>
        <category>LINUX</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>redhat</tag>
      </tags>
  </entry>
  <entry>
    <title>SecureCRT 端口转发及防火墙</title>
    <url>/2020/09/01/SecureCRT-%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%8F%8A%E9%98%B2%E7%81%AB%E5%A2%99/</url>
    <content><![CDATA[<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>通过跳板机访问内网机器或设置了登录限制的机器</p>
<span id="more"></span>
<p><img src="b09b5e0c860df6462fbd3663225a13177b7ba379387ba751cf590afd3b1ed237.png" alt="图 3">  </p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>方式1、手工登录，先登录跳板机，再手动输入ssh指令登录</p>
<p>方式2、使用SecureCRT的自动登录功能</p>
<p><img src="6303a363076324522ad2b70f0d27ae8e9288f7d92b1c71597853f2ccb0e45d94.png" alt="图 4">  </p>
<p>方式3、利用SecureCRT的端口转发及防火墙功能<br><img src="c371515100a33de3d6233f3abf0e70716a197b9fbb2e9a1c670db4c8bd956085.png" alt="图 5">  </p>
<h3 id="创建跳板机登录Session的端口转发"><a href="#创建跳板机登录Session的端口转发" class="headerlink" title="创建跳板机登录Session的端口转发"></a>创建跳板机登录Session的端口转发</h3><p><img src="d693ebe2f6b6835c143d5d93b1e163229ea77cd4c3f398cd2801b883803f6e4d.png" alt="图 6">  </p>
<h3 id="端口转发配置"><a href="#端口转发配置" class="headerlink" title="端口转发配置"></a>端口转发配置</h3><p><img src="81ac269008341454ef306312603784b05424625cb56891bd3ab70e85b30c38e7.png" alt="图 7">  </p>
<h3 id="添加防火墙"><a href="#添加防火墙" class="headerlink" title="添加防火墙"></a>添加防火墙</h3><p>菜单 Options -&gt; Global Options 新增防火墙<br><img src="34e14c21a6eef41ba673bed426c563e5381f3110c612ac043ff5a5ee7fd5fdff.png" alt="图 8">  </p>
<h3 id="配置防火墙属性"><a href="#配置防火墙属性" class="headerlink" title="配置防火墙属性"></a>配置防火墙属性</h3><p><img src="534dc68f268cd1c88ba9b2bf81cfd0f3e0e5221c3ad1cabc035629ed7819c3b3.png" alt="图 9">  </p>
<h3 id="连接内网机器时使用防火墙"><a href="#连接内网机器时使用防火墙" class="headerlink" title="连接内网机器时使用防火墙"></a>连接内网机器时使用防火墙</h3><p><img src="3e8855a4e5e243ed42f71734a2b3d3a352ad2d69bde00ac771e643edc36c1c6c.png" alt="图 10">  </p>
]]></content>
      <categories>
        <category>SecureCRT</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>SecureCRT</tag>
      </tags>
  </entry>
</search>
