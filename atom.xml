<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rma&#39;s Blog</title>
  
  <subtitle>Stay hungry, stay foolish</subtitle>
  <link href="https://rma-shuyu.github.io/atom.xml" rel="self"/>
  
  <link href="https://rma-shuyu.github.io/"/>
  <updated>2023-07-01T09:37:27.373Z</updated>
  <id>https://rma-shuyu.github.io/</id>
  
  <author>
    <name>rma-shuyu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>libvirt with dpdk-vdpa</title>
    <link href="https://rma-shuyu.github.io/2023/03/14/libvirt-with-dpdk-vdpa/"/>
    <id>https://rma-shuyu.github.io/2023/03/14/libvirt-with-dpdk-vdpa/</id>
    <published>2023-03-14T02:05:30.000Z</published>
    <updated>2023-07-01T09:37:27.373Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OS                               : CentOS Linux release 8.4.2105</span><br><span class="line">Kernel                           : 4.18.0-305.30.1.el8.x86_64</span><br><span class="line">qemu                             : 6.2.0</span><br><span class="line">dpdk                             : 22.11.1 </span><br><span class="line">libvirt                          : 8.0.0</span><br><span class="line">设备类型                         :  net</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="dpdk-vdpa启动"><a href="#dpdk-vdpa启动" class="headerlink" title="dpdk-vdpa启动"></a>dpdk-vdpa启动</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./dpdk-vdpa -c 0x2 -n 4 --socket-mem 1024,1024 \</span><br><span class="line">            -a 0000:cc:00.1,vdpa=1  -a 0000:cc:00.2,vdpa=1  \</span><br><span class="line">                -- --iface /tmp/vdpa-socket</span><br></pre></td></tr></table></figure><h2 id="libvirt-xml配置"><a href="#libvirt-xml配置" class="headerlink" title="libvirt xml配置"></a>libvirt xml配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">domain</span> <span class="attr">type</span>=<span class="string">&quot;kvm&quot;</span> <span class="attr">xmlns:qemu</span>=<span class="string">&#x27;http://libvirt.org/schemas/domain/qemu/1.0&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>vm0<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uuid</span>&gt;</span>d37f5411-b296-11ed-8e6c-0c48c6c879e4<span class="tag">&lt;/<span class="name">uuid</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">memory</span> <span class="attr">unit</span>=<span class="string">&quot;KiB&quot;</span>&gt;</span>2097152<span class="tag">&lt;/<span class="name">memory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">memoryBacking</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hugepages</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">page</span> <span class="attr">size</span>=<span class="string">&quot;2&quot;</span> <span class="attr">unit</span>=<span class="string">&quot;M&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hugepages</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nosharepages</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">locked</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">source</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">access</span> <span class="attr">mode</span>=<span class="string">&quot;shared&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">discard</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">memoryBacking</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">vcpu</span> <span class="attr">placement</span>=<span class="string">&quot;static&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">vcpu</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">os</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">type</span> <span class="attr">arch</span>=<span class="string">&quot;x86_64&quot;</span> <span class="attr">machine</span>=<span class="string">&quot;pc-i440fx-2.1&quot;</span>&gt;</span>hvm<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">os</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cpu</span> <span class="attr">mode</span>=<span class="string">&#x27;custom&#x27;</span> <span class="attr">match</span>=<span class="string">&#x27;exact&#x27;</span> <span class="attr">check</span>=<span class="string">&#x27;full&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">model</span> <span class="attr">fallback</span>=<span class="string">&#x27;forbid&#x27;</span>&gt;</span>kvm64<span class="tag">&lt;/<span class="name">model</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">feature</span> <span class="attr">policy</span>=<span class="string">&#x27;require&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;x2apic&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">feature</span> <span class="attr">policy</span>=<span class="string">&#x27;require&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;hypervisor&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">cpu</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">features</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">acpi</span>&gt;</span><span class="tag">&lt;/<span class="name">acpi</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">features</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">clock</span> <span class="attr">offset</span>=<span class="string">&quot;utc&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">clock</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">on_poweroff</span>&gt;</span>destroy<span class="tag">&lt;/<span class="name">on_poweroff</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">on_reboot</span>&gt;</span>restart<span class="tag">&lt;/<span class="name">on_reboot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">on_crash</span>&gt;</span>destroy<span class="tag">&lt;/<span class="name">on_crash</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">devices</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">emulator</span>&gt;</span>/root/pc-bios/qemu-system-x86_64<span class="tag">&lt;/<span class="name">emulator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">disk</span> <span class="attr">device</span>=<span class="string">&quot;disk&quot;</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">bus</span>=<span class="string">&quot;ide&quot;</span> <span class="attr">dev</span>=<span class="string">&quot;hda&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">source</span> <span class="attr">file</span>=<span class="string">&quot;/mnt/store/vm0-centos8.4-8g-ext4-host-dmar.img&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">disk</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">interface</span> <span class="attr">type</span>=<span class="string">&#x27;vhostuser&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mac</span> <span class="attr">address</span>=<span class="string">&#x27;00:aa:bb:cc:dd:ee&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">source</span> <span class="attr">type</span>=<span class="string">&#x27;unix&#x27;</span> <span class="attr">path</span>=<span class="string">&#x27;/tmp/vdpa-socket0&#x27;</span> <span class="attr">mode</span>=<span class="string">&#x27;client&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">model</span> <span class="attr">type</span>=<span class="string">&#x27;virtio&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">driver</span> <span class="attr">queues</span>=<span class="string">&#x27;4&#x27;</span> <span class="attr">rx_queue_size</span>=<span class="string">&#x27;512&#x27;</span> <span class="attr">tx_queue_size</span>=<span class="string">&#x27;512&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">serial</span> <span class="attr">type</span>=<span class="string">&quot;tcp&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">source</span> <span class="attr">mode</span>=<span class="string">&quot;bind&quot;</span> <span class="attr">host</span>=<span class="string">&quot;127.0.0.1&quot;</span> <span class="attr">service</span>=<span class="string">&quot;4321&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">protocol</span> <span class="attr">type</span>=<span class="string">&quot;telnet&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">port</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">serial</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">graphics</span> <span class="attr">type</span>=<span class="string">&#x27;vnc&#x27;</span> <span class="attr">port</span>=<span class="string">&#x27;5901&#x27;</span> <span class="attr">listen</span>=<span class="string">&#x27;0.0.0.0&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listen</span> <span class="attr">type</span>=<span class="string">&#x27;address&#x27;</span> <span class="attr">address</span>=<span class="string">&#x27;0.0.0.0&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">graphics</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">devices</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">qemu:commandline</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">qemu:arg</span> <span class="attr">value</span>=<span class="string">&#x27;-L&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">qemu:arg</span> <span class="attr">value</span>=<span class="string">&#x27;/root/pc-bios&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">qemu:commandline</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="验证结果"><a href="#验证结果" class="headerlink" title="验证结果"></a>验证结果</h2><p>1、查看libvirt是否正常拉起vm</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># virsh -c qemu+tcp:///system create vm.xml</span></span><br><span class="line">Domain <span class="string">&#x27;vm0&#x27;</span> created from vm.xml</span><br><span class="line"></span><br><span class="line"><span class="comment"># virsh list</span></span><br><span class="line"> Id   Name   State</span><br><span class="line">----------------------</span><br><span class="line"> 29   vm0    running</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2、ping测试<br><img src="03e2f3d08b21dc6b24565608fdd47abc9cbe6acb6bd8286f651bb44728647ad3.png" alt="图 2">  </p><h2 id="调试问题"><a href="#调试问题" class="headerlink" title="调试问题"></a>调试问题</h2><p>使用libvirt拉起vm时，ping failed<br><img src="3d9fe6c5801dcd971f82c9826d8fd9e596c0c1edd45cd42b49d299b31abe463e.png" alt="图 1">  </p><h3 id="定位过程"><a href="#定位过程" class="headerlink" title="定位过程"></a>定位过程</h3><p>1、查看/var/log/libvirt/qemu/vm0.log日志，发现存在错误日志打印，可以看到qemu启动参数需要指定<code>memory-backend-file</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2023-06-14T01:53:51.897860Z qemu-system-x86_64: Failed initializing vhost-user memory map, consider using -object memory-backend-file share=on</span><br><span class="line">2023-06-14T01:53:51.897958Z qemu-system-x86_64: vhost_set_mem_table failed: Input/output error (5)</span><br><span class="line">2023-06-14T01:53:51.912732Z qemu-system-x86_64: unable to start vhost net: 5: falling back on userspace virtio</span><br><span class="line">2023-06-14T01:53:51.949246Z qemu-system-x86_64: Failed initializing vhost-user memory map, consider using -object memory-backend-file share=on</span><br><span class="line">2023-06-14T01:53:51.949266Z qemu-system-x86_64: vhost_set_mem_table failed: Resource temporarily unavailable (11)</span><br><span class="line">2023-06-14T01:53:51.963736Z qemu-system-x86_64: unable to start vhost net: 11: falling back on userspace virtio</span><br></pre></td></tr></table></figure><p>2、查看qemu启动进程参数，发现qemu参数指定的是<code>memory-backend-ram</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root        6394       1 50 08:23 ?        00:00:47 /root/pc-bios/qemu-system-x86_64 -name guest=vm0,debug-threads=on -S -object &#123;<span class="string">&quot;qom-type&quot;</span>:<span class="string">&quot;secret&quot;</span>,<span class="string">&quot;id&quot;</span>:<span class="string">&quot;masterKey0&quot;</span>,<span class="string">&quot;format&quot;</span>:<span class="string">&quot;raw&quot;</span>,<span class="string">&quot;file&quot;</span>:<span class="string">&quot;/var/lib/libvirt/qemu/domain-10-vm0/master-key.aes&quot;</span>&#125; -machine pc-i440fx-2.1,usb=off,dump-guest-core=off,memory-backend=pc.ram -accel kvm -cpu kvm64,x2apic=on,hypervisor=on -m 2048 -object &#123;<span class="string">&quot;qom-type&quot;</span>:<span class="string">&quot;memory-backend-ram&quot;</span>,<span class="string">&quot;id&quot;</span>:<span class="string">&quot;pc.ram&quot;</span>,<span class="string">&quot;size&quot;</span>:2147483648&#125; -overcommit mem-lock=off -smp 2,sockets=2,cores=1,threads=1 -uuid d37f5411-b296-11ed-8e6c-0c48c6c879e4 -no-user-config -nodefaults -chardev socket,<span class="built_in">id</span>=charmonitor,fd=38,server=on,<span class="built_in">wait</span>=off -mon chardev=charmonitor,<span class="built_in">id</span>=monitor,mode=control -rtc base=utc -no-shutdown -boot strict=on -device piix3-usb-uhci,<span class="built_in">id</span>=usb,bus=pci.0,addr=0x1.0x2 -blockdev &#123;<span class="string">&quot;driver&quot;</span>:<span class="string">&quot;file&quot;</span>,<span class="string">&quot;filename&quot;</span>:<span class="string">&quot;/mnt/store/vm0-centos8.4-8g-ext4-host-dmar.img&quot;</span>,<span class="string">&quot;node-name&quot;</span>:<span class="string">&quot;libvirt-1-storage&quot;</span>,<span class="string">&quot;auto-read-only&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;discard&quot;</span>:<span class="string">&quot;unmap&quot;</span>&#125; -blockdev &#123;<span class="string">&quot;node-name&quot;</span>:<span class="string">&quot;libvirt-1-format&quot;</span>,<span class="string">&quot;read-only&quot;</span>:<span class="literal">false</span>,<span class="string">&quot;driver&quot;</span>:<span class="string">&quot;raw&quot;</span>,<span class="string">&quot;file&quot;</span>:<span class="string">&quot;libvirt-1-storage&quot;</span>&#125; -device ide-hd,bus=ide.0,unit=0,drive=libvirt-1-format,<span class="built_in">id</span>=ide0-0-0,bootindex=1 -chardev socket,<span class="built_in">id</span>=charnet0,path=/tmp/vdpa-socket0 -netdev vhost-user,chardev=charnet0,queues=4,<span class="built_in">id</span>=hostnet0 -device virtio-net-pci,mq=on,vectors=10,rx_queue_size=512,tx_queue_size=512,netdev=hostnet0,<span class="built_in">id</span>=net0,mac=00:aa:bb:cc:<span class="built_in">dd</span>:ee,bus=pci.0,addr=0x3 -chardev socket,<span class="built_in">id</span>=charserial0,host=127.0.0.1,port=4321,telnet=on,server=on,<span class="built_in">wait</span>=off -device isa-serial,chardev=charserial0,<span class="built_in">id</span>=serial0 -audiodev &#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;audio1&quot;</span>,<span class="string">&quot;driver&quot;</span>:<span class="string">&quot;none&quot;</span>&#125; -vnc 0.0.0.0:0,audiodev=audio1 -device cirrus-vga,<span class="built_in">id</span>=video0,bus=pci.0,addr=0x2 -device virtio-balloon-pci,<span class="built_in">id</span>=balloon0,bus=pci.0,addr=0x4 -L /root/pc-bios -msg timestamp=on</span><br></pre></td></tr></table></figure><h3 id="根因分析"><a href="#根因分析" class="headerlink" title="根因分析"></a>根因分析</h3><p>qemu进程在ram_block初始化的时候根据memory-backend-xxx，其中xxx可以指定file、memfd、ram，<br>从而指定不同的内存申请方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">host_memory_backend_memory_complete(UserCreatable *uc, Error **errp)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (bc-&gt;alloc) &#123;</span><br><span class="line">        bc-&gt;alloc(backend, &amp;local_err);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当指定memory-backend-file<br>则bc-&gt;alloc = file_backend_memory_alloc</p><p>当指定memory-backend-ram<br>则bc-&gt;alloc = ram_backend_memory_alloc;</p><p>这两个主要的区别在于申请ram_block时，file_backend_memory_alloc会额外申请一个fd，用于前后端进程共享内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RAMBlock *<span class="title function_">qemu_ram_alloc_from_file</span><span class="params">(<span class="type">ram_addr_t</span> size, MemoryRegion *mr,</span></span><br><span class="line"><span class="params">                                   <span class="type">uint32_t</span> ram_flags, <span class="type">const</span> <span class="type">char</span> *mem_path,</span></span><br><span class="line"><span class="params">                                   <span class="type">bool</span> readonly, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    fd = file_ram_open(mem_path, memory_region_name(mr), readonly, &amp;created,</span><br><span class="line">                       errp);</span><br><span class="line">...</span><br><span class="line">    block = qemu_ram_alloc_from_fd(size, mr, ram_flags, fd, <span class="number">0</span>, readonly, errp);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MemoryRegion通过vhost-user VHOST_USER_SET_MEM_TABLE消息传递到dpdk-vdpa进程<br>如果不指定memory-backend-file，VHOST_USER_SET_MEM_TABLE消息失败，在vhost_dev_start中返回失败，不会走后续设备启动流程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vhost_dev_start</span><span class="params">(<span class="keyword">struct</span> vhost_dev *hdev, VirtIODevice *vdev)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    r = hdev-&gt;vhost_ops-&gt;vhost_set_mem_table(hdev, hdev-&gt;mem);</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        VHOST_OPS_DEBUG(<span class="string">&quot;vhost_set_mem_table failed&quot;</span>);</span><br><span class="line">        r = -errno;</span><br><span class="line">        <span class="keyword">goto</span> fail_mem;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">     r = hdev-&gt;vhost_ops-&gt;vhost_dev_start(hdev, <span class="literal">true</span>);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题修复"><a href="#问题修复" class="headerlink" title="问题修复"></a>问题修复</h3><p>libvirt xml指定memoryBacking类型为file</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">domain</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;<span class="name">memoryBacking</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hugepages</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">page</span> <span class="attr">size</span>=<span class="string">&quot;2&quot;</span> <span class="attr">unit</span>=<span class="string">&quot;M&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hugepages</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nosharepages</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">locked</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">source</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">access</span> <span class="attr">mode</span>=<span class="string">&quot;shared&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">discard</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">memoryBacking</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时再次启动vm，可以发现此时qemu进程启动参数为<code>memory-backend-file</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root       17715       1 75 23:02 ?        00:00:47 /root/pc-bios/qemu-system-x86_64 -name guest=vm0,debug-threads=on -S -object &#123;<span class="string">&quot;qom-type&quot;</span>:<span class="string">&quot;secret&quot;</span>,<span class="string">&quot;id&quot;</span>:<span class="string">&quot;masterKey0&quot;</span>,<span class="string">&quot;format&quot;</span>:<span class="string">&quot;raw&quot;</span>,<span class="string">&quot;file&quot;</span>:<span class="string">&quot;/var/lib/libvirt/qemu/domain-3-vm0/master-key.aes&quot;</span>&#125; -machine pc-i440fx-2.1,usb=off,dump-guest-core=off,mem-merge=off,memory-backend=pc.ram -accel kvm -cpu kvm64,x2apic=on,hypervisor=on -m 2048 -object &#123;<span class="string">&quot;qom-type&quot;</span>:<span class="string">&quot;memory-backend-file&quot;</span>,<span class="string">&quot;id&quot;</span>:<span class="string">&quot;pc.ram&quot;</span>,<span class="string">&quot;mem-path&quot;</span>:<span class="string">&quot;/dev/hugepages/libvirt/qemu/3-vm0&quot;</span>,<span class="string">&quot;discard-data&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;share&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;x-use-canonical-path-for-ramblock-id&quot;</span>:<span class="literal">false</span>,<span class="string">&quot;prealloc&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;size&quot;</span>:2147483648&#125; -overcommit mem-lock=on -smp 2,sockets=2,cores=1,threads=1 -uuid d37f5411-b296-11ed-8e6c-0c48c6c879e4 -no-user-config -nodefaults -chardev socket,<span class="built_in">id</span>=charmonitor,fd=39,server=on,<span class="built_in">wait</span>=off -mon chardev=charmonitor,<span class="built_in">id</span>=monitor,mode=control -rtc base=utc -no-shutdown -boot strict=on -device piix3-usb-uhci,<span class="built_in">id</span>=usb,bus=pci.0,addr=0x1.0x2 -blockdev &#123;<span class="string">&quot;driver&quot;</span>:<span class="string">&quot;file&quot;</span>,<span class="string">&quot;filename&quot;</span>:<span class="string">&quot;/mnt/store/vm0-centos8.4-8g-ext4-host-dmar.img&quot;</span>,<span class="string">&quot;node-name&quot;</span>:<span class="string">&quot;libvirt-1-storage&quot;</span>,<span class="string">&quot;auto-read-only&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;discard&quot;</span>:<span class="string">&quot;unmap&quot;</span>&#125; -blockdev &#123;<span class="string">&quot;node-name&quot;</span>:<span class="string">&quot;libvirt-1-format&quot;</span>,<span class="string">&quot;read-only&quot;</span>:<span class="literal">false</span>,<span class="string">&quot;driver&quot;</span>:<span class="string">&quot;raw&quot;</span>,<span class="string">&quot;file&quot;</span>:<span class="string">&quot;libvirt-1-storage&quot;</span>&#125; -device ide-hd,bus=ide.0,unit=0,drive=libvirt-1-format,<span class="built_in">id</span>=ide0-0-0,bootindex=1 -chardev socket,<span class="built_in">id</span>=charnet0,path=/tmp/vdpa-socket0 -netdev vhost-user,chardev=charnet0,queues=4,<span class="built_in">id</span>=hostnet0 -device virtio-net-pci,mq=on,vectors=10,rx_queue_size=512,tx_queue_size=512,netdev=hostnet0,<span class="built_in">id</span>=net0,mac=00:aa:bb:cc:<span class="built_in">dd</span>:ee,bus=pci.0,addr=0x3 -chardev socket,<span class="built_in">id</span>=charserial0,host=127.0.0.1,port=4321,telnet=on,server=on,<span class="built_in">wait</span>=off -device isa-serial,chardev=charserial0,<span class="built_in">id</span>=serial0 -audiodev &#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;audio1&quot;</span>,<span class="string">&quot;driver&quot;</span>:<span class="string">&quot;none&quot;</span>&#125; -vnc 0.0.0.0:0,audiodev=audio1 -device cirrus-vga,<span class="built_in">id</span>=video0,bus=pci.0,addr=0x2 -device virtio-balloon-pci,<span class="built_in">id</span>=balloon0,bus=pci.0,addr=0x4 -L /root/pc-bios -msg timestamp=on</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;环境信息&quot;&gt;&lt;a href=&quot;#环境信息&quot; class=&quot;headerlink&quot; title=&quot;环境信息&quot;&gt;&lt;/a&gt;环境信息&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;OS                               : CentOS Linux release 8.4.2105&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Kernel                           : 4.18.0-305.30.1.el8.x86_64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;qemu                             : 6.2.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dpdk                             : 22.11.1 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;libvirt                          : 8.0.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;设备类型                         :  net&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="虚拟化" scheme="https://rma-shuyu.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="Libvirt" scheme="https://rma-shuyu.github.io/tags/Libvirt/"/>
    
  </entry>
  
  <entry>
    <title>DPDK+OVS+QEMU前后端启动vm</title>
    <link href="https://rma-shuyu.github.io/2023/03/06/DPDK-OVS-QEMU%E5%89%8D%E5%90%8E%E7%AB%AF%E5%90%AF%E5%8A%A8vm/"/>
    <id>https://rma-shuyu.github.io/2023/03/06/DPDK-OVS-QEMU%E5%89%8D%E5%90%8E%E7%AB%AF%E5%90%AF%E5%8A%A8vm/</id>
    <published>2023-03-06T08:01:04.000Z</published>
    <updated>2023-07-29T06:46:38.891Z</updated>
    
    <content type="html"><![CDATA[<h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><ul><li><p>DPDK 22.11.1</p></li><li><p>A DPDK supported NIC</p></li></ul><p>Only required when physical ports are in use</p><span id="more"></span><ul><li>A suitable kernel</li></ul><p>On Linux Distros running kernel version &gt;= 3.0, only IOMMU needs to enabled via the grub cmdline, assuming you are using VFIO. For older kernels, ensure the kernel is built with UIO, HUGETLBFS, PROC_PAGE_MONITOR, HPET, HPET_MMAP support. If these are not present, it will be necessary to upgrade your kernel or build a custom kernel with these flags enabled.</p><h2 id="dpdk环境设置"><a href="#dpdk环境设置" class="headerlink" title="dpdk环境设置"></a>dpdk环境设置</h2><p>检查VT-d功能是否打开</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/cmdline | grep iommu=pt</span><br><span class="line"><span class="built_in">cat</span> /proc/cmdline | grep intel_iommu=on</span><br></pre></td></tr></table></figure><p>如果没有开启，那么需要修改/etc/default/grub中GRUB_CMDLINE_LINUX_DEFAULT，重新创建引导grub</p><p>设置大页，加载vfio，绑定物理网卡到vfio</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">huge_set --setup 4g</span><br><span class="line">modprobe vfio-pci</span><br><span class="line">dpdk_bind -b vfio-pci ens33f1</span><br></pre></td></tr></table></figure><p>这里的<code>huge_set</code>、<code>dpdk_bind</code>对应dpdk bin中的<code>dpdk-devbind.py</code>、<code>dpdk-hugepages.py</code></p><h2 id="ovs启动"><a href="#ovs启动" class="headerlink" title="ovs启动"></a>ovs启动</h2><ul><li>创建ovs相关目录</li><li>第一次需要创建ovsdb</li><li>启动ovsdb-server</li><li>检查db.sock是否正常创建</li><li>设置other_config为dpdk模式</li><li>启动ovs-vswitchd</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /mnt/store/ovs/images/bin</span><br><span class="line"></span><br><span class="line">dpdk_socket_mem=<span class="string">&quot;1024,0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p /var/run/openvswitch</span><br><span class="line"><span class="built_in">mkdir</span> -p /etc/openvswitch</span><br><span class="line"><span class="built_in">mkdir</span> -p /var/log/openvswitch</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ! <span class="built_in">test</span> -f /etc/openvswitch/conf.db; <span class="keyword">then</span></span><br><span class="line">./ovsdb-tool create /etc/openvswitch/conf.db /mnt/store/ovs/images/db/vswitch.ovsschema</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">./ovsdb-server /etc/openvswitch/conf.db -vconsole:emer -vsyslog:err -vfile:info --remote=punix:/var/run/openvswitch/db.sock --private-key=db:Open_vSwitch,SSL,private_key --certificate=db:Open_vSwitch,SSL,certificate --bootstrap-ca-cert=db:Open_vSwitch,SSL,ca_cert --no-chdir --log-file=/var/log/openvswitch/ovsdb-server.log --pidfile=/var/run/openvswitch/ovsdb-server.pid --detach --monitor</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [ ! -S /var/run/openvswitch/db.sock ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">sleep</span> 1</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">./ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-init=<span class="literal">true</span></span><br><span class="line">./ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-extra=<span class="string">&quot;--iova-mode=pa&quot;</span></span><br><span class="line">./ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-socket-mem=<span class="variable">$dpdk_socket_mem</span></span><br><span class="line"></span><br><span class="line">./ovs-vswitchd unix:/var/run/openvswitch/db.sock -vconsole:emer -vsyslog:err -vfile:info --mlockall --no-chdir --log-file=/var/log/openvswitch/ovs-vswitchd.log --pidfile=/var/run/openvswitch/ovs-vswitchd.pid --detach --monitor</span><br></pre></td></tr></table></figure><h2 id="ovs停止运行"><a href="#ovs停止运行" class="headerlink" title="ovs停止运行"></a>ovs停止运行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ovs-appctl -t ovs-vswitchd <span class="built_in">exit</span></span><br><span class="line">ovs-appctl -t ovsdb-server <span class="built_in">exit</span></span><br></pre></td></tr></table></figure><h2 id="ovs创建port"><a href="#ovs创建port" class="headerlink" title="ovs创建port"></a>ovs创建port</h2><ul><li>创建网桥</li><li>物理端口绑定网桥</li><li>前后端通信端口绑定网桥</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">/mnt/store/ovs/images/bin/ovs-vsctl --may-exist add-br br0 -- <span class="built_in">set</span> bridge br0 datapath_type=netdev</span><br><span class="line"></span><br><span class="line"><span class="comment"># dpdk-devargs后面跟的是dpdk绑定网卡的pci bdf号</span></span><br><span class="line">/mnt/store/ovs/images/bin/ovs-vsctl --may-exist add-port br0 phy0 -- <span class="built_in">set</span> Interface phy0 <span class="built_in">type</span>=dpdk options:dpdk-devargs=0000:24:00.1</span><br><span class="line"></span><br><span class="line">/mnt/store/ovs/images/bin/ovs-vsctl --may-exist add-port br0 vhost-user-1 -- <span class="built_in">set</span> Interface vhost-user-1 <span class="built_in">type</span>=dpdkvhostuserclient options:vhost-server-path=<span class="string">&quot;/tmp/sock0&quot;</span></span><br></pre></td></tr></table></figure><ul><li>ovs-vsctl show查看运行结果</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /mnt/store/ovs/images/bin/ovs-vsctl show</span></span><br><span class="line">90ce12f9-3e63-4fff-b615-ae7e864858db</span><br><span class="line">    Bridge br0</span><br><span class="line">        datapath_type: netdev</span><br><span class="line">        Port br0</span><br><span class="line">            Interface br0</span><br><span class="line">                <span class="built_in">type</span>: internal</span><br><span class="line">        Port vhost-user-1</span><br><span class="line">            Interface vhost-user-1</span><br><span class="line">                <span class="built_in">type</span>: dpdkvhostuserclient</span><br><span class="line">                options: &#123;vhost-server-path=<span class="string">&quot;/tmp/sock0&quot;</span>&#125;</span><br><span class="line">        Port phy0</span><br><span class="line">            Interface phy0</span><br><span class="line">                <span class="built_in">type</span>: dpdk</span><br><span class="line">                options: &#123;dpdk-devargs=<span class="string">&quot;0000:24:00.1&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="qemu启动"><a href="#qemu启动" class="headerlink" title="qemu启动"></a>qemu启动</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">ulimit</span> -l unlimited</span><br><span class="line">/root/pc-bios/qemu-system-x86_64  \</span><br><span class="line">-enable-kvm -m 2048 -cpu host \</span><br><span class="line">-hda /mnt/store/vm0-centos8.4-8g-ext4-host-dmar.img \</span><br><span class="line">-object memory-backend-file,<span class="built_in">id</span>=mem,size=2048M,mem-path=/dev/hugepages,share=on \</span><br><span class="line">-mem-prealloc \</span><br><span class="line">-numa node,memdev=mem \</span><br><span class="line">-chardev socket,<span class="built_in">id</span>=char0,path=/tmp/sock0,server=on \</span><br><span class="line">-netdev <span class="built_in">type</span>=vhost-user,<span class="built_in">id</span>=vdpa,chardev=char0,queues=4 \</span><br><span class="line">-device virtio-net-pci,mq=on,rx_queue_size=512,tx_queue_size=512,netdev=vdpa,mac=00:aa:bb:cc:<span class="built_in">dd</span>:ee,page-per-vq=on,disable-modern=on,disable-legacy=off \</span><br><span class="line">-serial telnet:127.1:4321,server,nowait \</span><br><span class="line">-monitor stdio \</span><br><span class="line">-D ./qemu-vm0.<span class="built_in">log</span> \</span><br><span class="line">-vnc :90 -L /root/pc-bios</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ping包测试"><a href="#ping包测试" class="headerlink" title="ping包测试"></a>ping包测试</h2><p>host上网桥配置ip，端口up</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig br0 192.188.1.3/24 up</span><br></pre></td></tr></table></figure><p>geust上net口配置同网段ip，端口up</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig ens3 192.188.1.2/24 up</span><br></pre></td></tr></table></figure><p>vm ping host<br><img src="212553173cc3f955da5935e31ed69460df0ad4632296146b4ae845f52fe8edde.png" alt="图 1">  </p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;先决条件&quot;&gt;&lt;a href=&quot;#先决条件&quot; class=&quot;headerlink&quot; title=&quot;先决条件&quot;&gt;&lt;/a&gt;先决条件&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;DPDK 22.11.1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A DPDK supported NIC&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Only required when physical ports are in use&lt;/p&gt;</summary>
    
    
    
    <category term="虚拟化" scheme="https://rma-shuyu.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="DPDK" scheme="https://rma-shuyu.github.io/tags/DPDK/"/>
    
    <category term="OVS" scheme="https://rma-shuyu.github.io/tags/OVS/"/>
    
    <category term="QEMU" scheme="https://rma-shuyu.github.io/tags/QEMU/"/>
    
  </entry>
  
  <entry>
    <title>Python + Selenium</title>
    <link href="https://rma-shuyu.github.io/2023/02/16/Python-Selenium/"/>
    <id>https://rma-shuyu.github.io/2023/02/16/Python-Selenium/</id>
    <published>2023-02-16T12:17:45.000Z</published>
    <updated>2023-11-12T13:43:55.360Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Selenium-简介"><a href="#Selenium-简介" class="headerlink" title="Selenium 简介"></a>Selenium 简介</h1><blockquote><p>Selenium 是一个用于 Web 应用程序测试的工具。Selenium 测试直接运行在浏览器中，就像真正的用户在操作一样。支持的浏览器包括Mozilla Firefox，Safari，Chrome，Opera，Edge 等</p></blockquote><span id="more"></span><h1 id="Selenium-优势"><a href="#Selenium-优势" class="headerlink" title="Selenium 优势"></a>Selenium 优势</h1><p>1、免费开源</p><p>2、小巧，对于不同的语言而言，只是一个包的大小</p><p>3、支持多语言，python，java 等</p><p>4、支持多平台，多浏览器</p><h1 id="Selenium-原理"><a href="#Selenium-原理" class="headerlink" title="Selenium 原理"></a>Selenium 原理</h1><p><img src="https://tech.uupt.com/wp-content/uploads/2022/10/image-1024x551.png"></p><p>上图所示Selenium Client Library就是我们平时使用的编码语言，包括 java、python、C#等。可以看到这些语言并没有直接与 Browser Drivers 进行通信，而是通过了 JSON WireProtocol，这就是 webdriver 协议。</p><p>简单的说他定义了一套接口规范，以我们最熟悉的点击操作为例，他对应的接口协议是：</p><p>POST /session/{session id}/element/{element id}/click</p><p>这样以来，无论我们编码使用 python 代码来执行点击操作：</p><p>driver.find_element_by_id(“”).click()</p><p>还是以 java 代码执行点击操作：</p><p>driver.findElement(By.id(“”)).click();</p><p>都会通过 selenium 客户端的程序将 click 操作转化成对应的 webdriver 协议。这样对于 Browser Drivers 来说只需要解析具体协议，而无需关注客户端使用的是哪种代码了，这就是 selenium 支持多种语言的原理。</p><p>在 Browser Drivers 中可以看到各个浏览器的 driver，这里我们以 chromedriver 为例进行讲解。在代码中直接 new ChromeDriver() 将会启动一个 ChromeDriver 进程，ChromeDriver 是一个独立的服务，它是 google 为网站开发人员提供的自动化测试接口，它是 selenium 和 chrome 浏览器进行通信的桥梁。chromeDriver 解析 webdriver 协议，然后根据解析结果，调用与之对应的 Remote Debugging 协议来操控 chrome 浏览器，它可以和浏览器内核进行交互进而操控浏览器</p><h1 id="浏览器驱动"><a href="#浏览器驱动" class="headerlink" title="浏览器驱动"></a>浏览器驱动</h1><p>当 selenium 升级到 3.0 之后，对不同的浏览器驱动进行了规范。如果想使用 selenium 驱动不同的浏览器，必须单独下载并设置不同的浏览器驱动。</p><p>各浏览器驱动下载地址：</p><p>Firefox 浏览器驱动：<a href="https://github.com/mozilla/geckodriver/releases">geckodriver</a></p><p>Chrome 浏览器驱动：<a href="https://sites.google.com/a/chromium.org/chromedriver/home">chromedriver</a> , <a href="https://npm.taobao.org/mirrors/chromedriver">taobao</a>镜像</p><p>Edge 浏览器驱动：<a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver">MicrosoftWebDriver</a></p><p>Opera 浏览器驱动：<a href="https://github.com/operasoftware/operachromiumdriver/releases">operadriver</a></p><h1 id="python-安装Selenium"><a href="#python-安装Selenium" class="headerlink" title="python 安装Selenium"></a>python 安装Selenium</h1><p>通过命令安装：pip install selenium</p><p>注：如果电脑上既有 python2，又有 python3，在执行 pip 命令安装时，要注意区分</p><h1 id="设置浏览器驱动"><a href="#设置浏览器驱动" class="headerlink" title="设置浏览器驱动"></a>设置浏览器驱动</h1><p>1、设置浏览器的地址非常简单。 我们可以手动创建一个存放浏览器驱动的目录，如： C:\driver ,将下载的浏览器驱动文件放到该目录下，然后将此目录路径放在环境变量 Path 下</p><p>2、python 验证不同的浏览器驱动是否正常使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line"> </span><br><span class="line">driver = webdriver.Firefox()   # Firefox浏览器</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()    # Chrome浏览器</span><br><span class="line"> </span><br><span class="line">driver = webdriver.Edge()      # Edge浏览器</span><br><span class="line"> </span><br><span class="line">driver = webdriver.Opera()     # Opera浏览器</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3、测试是否正常打开浏览器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line"> </span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(&#x27;https://www.baidu.com&#x27;) # 打开百度</span><br><span class="line"> </span><br><span class="line">print(driver.title) # 获取网页title</span><br><span class="line"> </span><br><span class="line">driver.quit() # 关闭浏览器</span><br></pre></td></tr></table></figure><h1 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h1><h2 id="元素定位"><a href="#元素定位" class="headerlink" title="元素定位"></a>元素定位</h2><p>常用元素定位为 8 种，分别为：</p><p>通过 id 定位：find_element_by_id()</p><p>通过 id 定位一组元素：find_elements_by_id()</p><p>通过 name 定位：find_element_by_name()</p><p>通过 name 定位一组元素：find_elements_by_name()</p><p>通过 class name 定位：find_element_by_class_name()</p><p>通过 class name 定位一组元素：find_elements_by_class_name()</p><p>通过 tag name 定位：find_element_by_tag_name()</p><p>通过 tag name 定位一组元素：find_elements_by_tag_name()</p><p>通过 link text 定位：find_element_by_link_text()</p><p>通过 link text 定位一组元素：find_elements_by_link_text()</p><p>通过部分 link text 定位：find_element_by_partial_link_text()</p><p>通过部分 link text 定位一组元素：find_elements_by_partial_link_text()</p><p>通过 xpath 定位：find_element_by_xpath()</p><p>通过 xpath 定位一组元素：find_elements_by_xpath()</p><p>通过 css 定位：find_element_by_css_selector()</p><p>通过 css 定位一组元素：find_elements_by_css_selector()</p><p>注意：如果定位一组元素，则在 element 后面加一个 s</p><h2 id="控制浏览器"><a href="#控制浏览器" class="headerlink" title="控制浏览器"></a>控制浏览器</h2><ul><li>  控制浏览器大小</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line"></span><br><span class="line">driver = webdriver.Firefox()</span><br><span class="line">driver.get(&quot;http://www.baidu.com&quot;)</span><br><span class="line"> </span><br><span class="line"># 参数数字为像素点_</span><br><span class="line">print(&quot;设置浏览器宽500、高500显示&quot;)</span><br><span class="line">driver.set_window_size(500, 500)</span><br><span class="line">driver.quit()</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>  控制浏览器前进后退</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line"> </span><br><span class="line">driver = webdriver.Firefox()</span><br><span class="line"> </span><br><span class="line">#访问百度首页</span><br><span class="line">first_url= &#x27;http://www.baidu.com&#x27;</span><br><span class="line">print(&quot;access %s&quot; %(first_url))</span><br><span class="line">driver.get(first_url)</span><br><span class="line"> </span><br><span class="line">#访问新闻页面</span><br><span class="line">second_url=&#x27;http://news.baidu.com&#x27;</span><br><span class="line">print(&quot;access %s&quot; %(second_url))</span><br><span class="line">driver.get(second_url)</span><br><span class="line"> </span><br><span class="line">#返回（后退）到百度首页</span><br><span class="line">print(&quot;back to  %s &quot;%(first_url))</span><br><span class="line">driver.back()</span><br><span class="line"> </span><br><span class="line">#前进到新闻页</span><br><span class="line">print(&quot;forward to  %s&quot;%(second_url))</span><br><span class="line">driver.forward()</span><br><span class="line"> </span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure><h2 id="WebDriver-常用方法"><a href="#WebDriver-常用方法" class="headerlink" title="WebDriver 常用方法"></a>WebDriver 常用方法</h2><ul><li>  clear()： 清除文本</li><li>  send_keys (value)： 模拟按键输入</li><li>  click()： 单击元素</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line"> </span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(&quot;https://www.baidu.com&quot;)</span><br><span class="line">driver.find_element_by_id(&quot;kw&quot;).clear()</span><br><span class="line">driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;selenium&quot;)</span><br><span class="line">driver.find_element_by_id(&quot;su&quot;).click()</span><br><span class="line">driver.quit()</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>  submit()：用于提交表单</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line"> </span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(&quot;https://www.baidu.com&quot;)</span><br><span class="line"> </span><br><span class="line">search_text = driver.find_element_by_id(&#x27;kw&#x27;)</span><br><span class="line">search_text.send_keys(&#x27;selenium&#x27;)</span><br><span class="line">search_text.submit()</span><br><span class="line"> </span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure><h2 id="设置元素等待"><a href="#设置元素等待" class="headerlink" title="设置元素等待"></a>设置元素等待</h2><p>WebDriver 提供了两种类型的等待：显式等待和隐式等待</p><p>显式等待使 WebdDriver 等待某个条件成立时继续执行，否则在达到最大时长时抛出超时异常（TimeoutException）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">from selenium.webdriver.common.by import By</span><br><span class="line">from selenium.webdriver.support.ui import WebDriverWait</span><br><span class="line">from selenium.webdriver.support import expected_conditions as EC</span><br><span class="line"> </span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(&quot;http://www.baidu.com&quot;)</span><br><span class="line"> </span><br><span class="line">element = WebDriverWait(driver, 5, 0.5).until(EC.presence_of_element_located((By.ID, &quot;kw&quot;)))</span><br><span class="line">element.send_keys(&#x27;selenium&#x27;)</span><br><span class="line">driver.quit()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>隐式等待并不影响脚本的执行速度。其次，它并不针对页面上的某一元素进行等待。当脚本执行到某个元素定位时，如果元素可以定位，则继续执行；如果元素定位不到，则它将以轮询的方式不断地判断元素是否被定位到。假设在第 5 秒定位到了元素则继续执行，若直到超出设置时长（10 秒）还没有定位到元素，则抛出异常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">from selenium.common.exceptions import NoSuchElementException</span><br><span class="line">from time import ctime</span><br><span class="line"> </span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line"> </span><br><span class="line"># 设置隐式等待为10秒</span><br><span class="line">driver.implicitly_wait(10)</span><br><span class="line">driver.get(&quot;http://www.baidu.com&quot;)</span><br><span class="line"> </span><br><span class="line">try:</span><br><span class="line">    print(ctime())</span><br><span class="line">    driver.find_element_by_id(&quot;kww&quot;).send_keys(&#x27;selenium&#x27;)</span><br><span class="line">except NoSuchElementException as e:</span><br><span class="line">    print(e)</span><br><span class="line">finally:</span><br><span class="line">    print(ctime())</span><br><span class="line">    driver.quit()</span><br></pre></td></tr></table></figure><h1 id="Python-Selenium-实现识别图片验证码登录"><a href="#Python-Selenium-实现识别图片验证码登录" class="headerlink" title="Python+Selenium 实现识别图片验证码登录"></a>Python+Selenium 实现识别图片验证码登录</h1><p>1、打开网站设置要访问的网站地址，并把窗口最大化，这是能保证在电脑上每次截取的图片都是相同的大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">url = &quot;https://www.xxxxx.com&quot;</span><br><span class="line"># 1、打开浏览器，最大化浏览器</span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(url)</span><br><span class="line">#driver.implicitly_wait(10)#隐式等待10s</span><br><span class="line">driver.maximize_window()  #最大化窗口</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2、截取带图片验证码的网站内容，并保存在本地</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">driver.save_screenshot(&quot;H://test/01.png&quot;)#截取屏幕内容，保存到本地</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也可以通过 id 或者 Xpath 的方式定位到图片验证码的方式直接获取图片验证码，保存在本地</p><p><img src="https://tech.uupt.com/wp-content/uploads/2022/10/image-1-1024x456.png"></p><p>3、使用第三方库对图片进行识别（pytesseract 和ddddocr 都可以识别图片验证码）</p><p>a、使用pytesseract 识别图片验证码</p><p>定位在图片中验证码所在的位置，四个参数分别代表图片验证码的左，上，右，下坐标，可以通过 windows 自带的画图工具获取</p><p>当使用通过定位获取到验证码的方式时，可以跳过手动获取图片验证码的流程，直接跳转到图像处理步骤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ran = Image.open(&quot;H://test/01.png&quot;)   #打开截图，获取验证码位置，截取保存验证码</span><br><span class="line">box = (564, 395, 643, 423)  # 获取验证码位置,代表（左，上，右，下）</span><br><span class="line">ran.crop(box).save(&quot;H://test/02.png&quot;)   #把获取的验证码保存</span><br><span class="line">#获取验证码图片，读取验证码</span><br><span class="line">imageCode = Image.open(&quot;H://test/02.png&quot;)  #打开保存的验证码图片</span><br><span class="line">#imageCode.load()</span><br><span class="line"># 图像增强，二值化</span><br><span class="line">sharp_img = ImageEnhance.Contrast(imageCode).enhance(2.0)</span><br><span class="line">sharp_img.save(&quot;H://test/03.png&quot;) #保存图像增强，二值化之后的验证码图片</span><br><span class="line">sharp_img.load()  # 对比度增强</span><br><span class="line">time.sleep(2)</span><br><span class="line">print(sharp_img) #打印图片的信息</span><br><span class="line">code = pytesseract.image_to_string(sharp_img).strip() #读取验证码</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>b、使用 ddddocr 识别图片验证码</p><p>先将图片保存在本地，然后可以直接通过二进制读取图片，进行识别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 创建对象</span><br><span class="line">ocr = ddddocr.DdddOcr() </span><br><span class="line"># 使用二进制的方式读取图片</span><br><span class="line">with open(&#x27;./images/code1.png&#x27;, &#x27;rb&#x27;) as f:</span><br><span class="line">    img_tytes = f.read()</span><br><span class="line">    # 调用识别方法_</span><br><span class="line">    res = ocr.classification(img_tytes)</span><br><span class="line">    print(f&#x27;验证码为：&#123;res&#125;&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4、定位账号密码等输入框，并输入相关内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name=driver.find_element_by_id(&quot;username&quot;)  #定位账号输入框</span><br><span class="line">password=driver.find_element_by_id(&quot;password_1&quot;)  #定位密码输入框</span><br><span class="line">code1=driver.find_element_by_id(&quot;user_ck&quot;)  #定位验证码输入框</span><br><span class="line">name.send_keys(&#x27;username&#x27;)   #给定位账号的输入框中输入值</span><br><span class="line">password.send_keys(&#x27;password&#x27;)   #给定位密码的输入框中输入值</span><br><span class="line">code1.send_keys(code)   #给定位验证码的输入框中输入读取到的验证码</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>5、定位并点击按钮</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">driver.find_element_by_name(&quot;yt0&quot;).click() #点击登录</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>6、最后关闭页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#关闭浏览器</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Selenium-简介&quot;&gt;&lt;a href=&quot;#Selenium-简介&quot; class=&quot;headerlink&quot; title=&quot;Selenium 简介&quot;&gt;&lt;/a&gt;Selenium 简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Selenium 是一个用于 Web 应用程序测试的工具。Selenium 测试直接运行在浏览器中，就像真正的用户在操作一样。支持的浏览器包括Mozilla Firefox，Safari，Chrome，Opera，Edge 等&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="PYTHON" scheme="https://rma-shuyu.github.io/categories/PYTHON/"/>
    
    
    <category term="Selenium" scheme="https://rma-shuyu.github.io/tags/Selenium/"/>
    
  </entry>
  
  <entry>
    <title>ChromeDriver安装</title>
    <link href="https://rma-shuyu.github.io/2023/02/15/ChromeDriver%E5%AE%89%E8%A3%85/"/>
    <id>https://rma-shuyu.github.io/2023/02/15/ChromeDriver%E5%AE%89%E8%A3%85/</id>
    <published>2023-02-15T12:17:45.000Z</published>
    <updated>2023-11-12T13:43:55.351Z</updated>
    
    <content type="html"><![CDATA[<h1 id="官网下载"><a href="#官网下载" class="headerlink" title="官网下载"></a>官网下载</h1><ul><li>  官方网站：<a href="https://sites.google.com/a/chromium.org/chromedriver">https://sites.google.com/a/chromium.org/chromedriver</a></li><li>  下载地址：<a href="https://chromedriver.storage.googleapis.com/index.html">https://chromedriver.storage.googleapis.com/index.html</a><span id="more"></span></li></ul><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>在这之前请确保已经正确安装好了 Chrome 浏览器并可以正常运行，安装过程不再赘述。</p><h2 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h2><p>点击 Chrome 的菜单，帮助-&gt;关于 Chrome，即可查看 Chrome 的版本号，在这里我的版本是 114.0.5735.199，如图所示：</p><p><img src="4b19c10a0918a34aa2d1b682b01a86d939da61ec9233b23501343177662c0186.png" alt="picture 0">  </p><p>请记住 Chrome 版本号，在后面选择 ChromeDriver 版本时需要用到。</p><h2 id="禁用Chrome升级"><a href="#禁用Chrome升级" class="headerlink" title="禁用Chrome升级"></a>禁用Chrome升级</h2><p>由于ChromeDriver需要与Chrome 版本号一致，默认情况下Chrome会自动升级，这里需要禁用Chrome升级<br>第一步：禁用任务计划<br>首先是【右键计算机-&gt;管理】，在【计算机管理(本地)-&gt;系统工具-&gt;任务计划程序-&gt;任务计划程序库】中找到两个和Google自动更新相关的任务计划【GoogleUpdateTaskMachineCore】与【GoogleUpdateTaskMachineUA】，并把它俩禁用掉。<br><img src="709f9d6336c4807addf4a9fafe7563c9ed48b1e072e41ec5fa7862d4afeaa98b.png" alt="picture 1">  </p><p>第二步：禁用更新服务<br>然后在下方的【服务和应用程序-&gt;服务】中，找到两个和Google更新相关的服务【Google更新服务(gupdate)】、【Google更新服务(gupdatem)】，并右键，选择属性，把启动类型改为禁用。<br><img src="0950e09f69d4062b142820c0df774849c93d9d1d2d0de6d6334d6363bd03dea5.png" alt="picture 2">  </p><h2 id="下载-ChromeDriver"><a href="#下载-ChromeDriver" class="headerlink" title="下载 ChromeDriver"></a>下载 ChromeDriver</h2><p>打开 ChromeDriver 的官方网站，链接为：<a href="https://sites.google.com/chromium.org/driver/downloads">https://sites.google.com/chromium.org/driver/downloads</a><br>可以看到到目前为止最新支持的 Chrome 浏览器版本为 114，最新版本以官网为准，如图所示：</p><p><img src="6aa27b8893391cda5354530d6ad9eb976207c3fe832d832292c90ed2f360fc6f.png" alt="picture 3">  </p><p>每个版本都有相应的支持 Chrome 版本介绍，请找好自己的 Chrome 浏览器版本对应的 ChromeDriver 版本再下载，否则可能导致无法正常工作。</p><p>由于我这边的 ChromeDriver 版本是 114.*，找到对应的下载列表，如图所示：</p><p><img src="92bfce436feb13eb2aa165fb7e4d116e3a16bae282c84cb54bff8513d47edf1a.png" alt="picture 4">  </p><p>Windows 系统就下载 win32.zip，Mac 系统 Intel 芯片下载 mac64.zip，Linux 系统下载 linux64.zip，下载解压之后会得到一个 ChromeDriver 的可执行文件。</p><p>另外如果上面的链接打不开的话，也可以从对应的 ChromeDriver 镜像网站下载：<a href="https://chromedriver.storage.googleapis.com/index.html">https://chromedriver.storage.googleapis.com/index.html</a></p><h2 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h2><p>下载完成后将 ChromeDriver 的可执行文件配置到环境变量下。</p><p>在 Windows 下，建议直接将 chromedriver.exe 文件拖到 Python 的 Scripts 目录下，如图所示：</p><p><img src="f3b902f7fe49df4551c4b21747d5a360834e4f3f9d04a7e320c1136740233772.png" alt="picture 5">  </p><h2 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h2><p>配置完成之后，就可以在命令行下直接执行 chromedriver 命令了。</p><p>命令行下输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chromedriver</span><br></pre></td></tr></table></figure><p>输入控制台有类似输出，如图所示：</p><p><img src="7c8145799a2f568e5ac7923637ad8d94b5d19e5eca242fe1842e8fb1771417a4.png" alt="picture 6">  </p><p>如果有类似输出则证明 ChromeDriver 的环境变量配置好了。</p><p>另外如果要配合代码进行测试的话，可以安装 Selenium,<br>安装好了之后，随后再在程序中测试，执行如下 Python 代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">browser = webdriver.Chrome()</span><br></pre></td></tr></table></figure><p>运行之后会弹出一个空白的 Chrome 浏览器，证明所有的配置都没有问题，如果没有弹出，请检查之前的每一步的配置。</p><p>如果弹出之后闪退，则可能是 ChromeDriver 版本和 Chrome 版本不简容，请更换 ChromeDriver 版本。</p><p>如果没有问题，接下来我们就可以利用 Chrome 来做网页抓取了。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;官网下载&quot;&gt;&lt;a href=&quot;#官网下载&quot; class=&quot;headerlink&quot; title=&quot;官网下载&quot;&gt;&lt;/a&gt;官网下载&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;  官方网站：&lt;a href=&quot;https://sites.google.com/a/chromium.org/chromedriver&quot;&gt;https://sites.google.com/a/chromium.org/chromedriver&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;  下载地址：&lt;a href=&quot;https://chromedriver.storage.googleapis.com/index.html&quot;&gt;https://chromedriver.storage.googleapis.com/index.html&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="PYTHON" scheme="https://rma-shuyu.github.io/categories/PYTHON/"/>
    
    
    <category term="ChromeDriver" scheme="https://rma-shuyu.github.io/tags/ChromeDriver/"/>
    
  </entry>
  
  <entry>
    <title>VSCode使用CodeGPT</title>
    <link href="https://rma-shuyu.github.io/2023/02/10/VSCode%E4%BD%BF%E7%94%A8CodeGPT/"/>
    <id>https://rma-shuyu.github.io/2023/02/10/VSCode%E4%BD%BF%E7%94%A8CodeGPT/</id>
    <published>2023-02-10T12:48:58.000Z</published>
    <updated>2023-07-01T09:37:27.342Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>CodeGPT</code>允许我们通过官方<code>OpenAI API</code>在<code>VSCode</code>中使用<code>GPT-3</code>，使得我们可以在代码编辑器拥有了<code>ChatGPT</code>。<br>借助 <code>CodeGPT</code>，我们可以生成代码、解释代码、重构代码等等。</p><span id="more"></span><h2 id="安装和设置"><a href="#安装和设置" class="headerlink" title="安装和设置"></a>安装和设置</h2><p>打开VSCode编辑器，点击扩展，然后在搜索框中输入“Code GPT”，然后点击“安装”。<br><img src="11a74d39367434d81ee6d91b62f82591270e1597d59b0237479cd9ed18ad5c4f.png" alt="图 5">  </p><p>Code GPT安装完，进到“Settings”界面，然后找到扩展下的“Code GPT”<br>CodeGPT的设置界面如下：<br><img src="79e7618f461b768065b9fea7f62b8f19727bc3c644aa6a05a332f304007086c6.png" alt="图 4">  </p><p><img src="a551258121c4603e9a22a950ebcac95490ec3ed3132b6b65998478d96b0069e0.png" alt="图 6">  </p><p>想要让CodeGPT运行起来，需要在上图的输入框处输入<a href="https://platform.openai.com/account/api-keys">OpenAI API key</a>，API key需要到OpenAI的官网生成。<br><img src="1ec8c9b392d9b9c48adef2505b45788e26fae2b55c8e30fbd6db20885f54e342.png" alt="图 7">  </p><p><strong>使用注意</strong><br>在WSL中无法使用CodeGPT，需要在Windows端使用</p><h2 id="解释代码"><a href="#解释代码" class="headerlink" title="解释代码"></a>解释代码</h2><p>选中代码，右键点击<code>Explain CodeGPT</code><br><img src="a1f348872a247c684d3eb2ee93a9801cc1a7e5094b5b4696a572c5759883d1f5.png" alt="图 1">  </p><h2 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h2><p>在对应后缀的代码文件中描述注释，并将光标点击到文末，快捷键ctrl+shift+i<br><img src="7fef95c4a63f509a4d1ce45159b1e1a344f6ce8c991344b63d674e52fd9c108f.png" alt="图 3">  </p><h2 id="重构代码"><a href="#重构代码" class="headerlink" title="重构代码"></a>重构代码</h2><p>选中代码，右键点击<code>Refactor CodeGPT</code><br><img src="95d51eff9bcb3c7c2c3d03bc3b67ba6cb3e8f1da454757e2d083fae5c0f4c7b2.png" alt="图 2">  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重构后的代码</span></span><br><span class="line">wait_for_process() &#123;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">参数说明</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="variable">$1</span>: 进程名</span></span><br><span class="line">  </span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">输入验证</span></span><br><span class="line">  if [ $# -ne 1 ]; then</span><br><span class="line">    echo &quot;Parameters incorrect&quot;</span><br><span class="line">    exit 1</span><br><span class="line">  fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">设置超时时间</span></span><br><span class="line">  WAIT_TIMEOUT=10</span><br><span class="line"></span><br><span class="line">  for i in $(seq 1 $WAIT_TIMEOUT); do</span><br><span class="line">    # 检索进程ID</span><br><span class="line">    proc_pid=$(pidof $1)</span><br><span class="line"></span><br><span class="line">    if [ &quot;$proc_pid&quot; != &quot;&quot; ]</span><br><span class="line">    then</span><br><span class="line">      # 进程已启动，返回</span><br><span class="line">      echo &quot;$1 started&quot;</span><br><span class="line">      return</span><br><span class="line">    fi</span><br><span class="line">    </span><br><span class="line">    echo &quot;Waiting for $1 to start&quot;</span><br><span class="line">    sleep 1</span><br><span class="line">  done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">超时</span></span><br><span class="line">  echo &quot;Timeout waiting for $1 to start&quot;</span><br><span class="line">  exit 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;code&gt;CodeGPT&lt;/code&gt;允许我们通过官方&lt;code&gt;OpenAI API&lt;/code&gt;在&lt;code&gt;VSCode&lt;/code&gt;中使用&lt;code&gt;GPT-3&lt;/code&gt;，使得我们可以在代码编辑器拥有了&lt;code&gt;ChatGPT&lt;/code&gt;。&lt;br&gt;借助 &lt;code&gt;CodeGPT&lt;/code&gt;，我们可以生成代码、解释代码、重构代码等等。&lt;/p&gt;</summary>
    
    
    
    <category term="VSCODE" scheme="https://rma-shuyu.github.io/categories/VSCODE/"/>
    
    
    <category term="CodeGPT" scheme="https://rma-shuyu.github.io/tags/CodeGPT/"/>
    
  </entry>
  
  <entry>
    <title>gitstats使用介绍</title>
    <link href="https://rma-shuyu.github.io/2022/12/05/gitstats%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/"/>
    <id>https://rma-shuyu.github.io/2022/12/05/gitstats%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/</id>
    <published>2022-12-05T11:51:50.000Z</published>
    <updated>2023-01-27T12:06:26.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>进一步来讲，Gitstats它是一个git仓库分析软件，它可以检查仓库并生成历史数据的统计信息。可以帮助你查看git仓库的提交状态，根据不同维度分析计算，并自动生成数据图表。<br>官网介绍：<a href="http://gitstats.sourceforge.net/">http://gitstats.sourceforge.net/</a></p><span id="more"></span><p>当前GitStats所生成统计信息常用分为如下几类：<br><strong>常规的统计</strong>：文件总数，行数，提交量，作者数。<br><strong>活跃性</strong>：每天中每小时的、每周中每天的、每周中每小时的、每年中每月的、每年的提交量。<br><strong>作者数</strong>：列举所有的作者（提交数，第一次提交日期，最近一次的提交日期），并按月和年来划分。<br><strong>文件数</strong>：按日期划分，按扩展名名划分。<br><strong>行数</strong>：按日期划分。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//mac osx</span><br><span class="line">brew install gnuplot</span><br><span class="line">//centos linux</span><br><span class="line">yum install gnuplot</span><br><span class="line">//ubuntu linux</span><br><span class="line">apt install gnuplot</span><br></pre></td></tr></table></figure><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://github.com/hoxu/gitstats.git</span><br><span class="line"><span class="built_in">cd</span> gitstats</span><br><span class="line">./gitstats 你的项目的位置 生成统计的文件夹位置</span><br></pre></td></tr></table></figure><h2 id="展示"><a href="#展示" class="headerlink" title="展示"></a>展示</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> 生成统计的文件夹位置</span><br><span class="line">python3 -m http.server 8090</span><br></pre></td></tr></table></figure><h2 id="qemu示例"><a href="#qemu示例" class="headerlink" title="qemu示例"></a>qemu示例</h2><p>如下图所示。首先，在gitstats上提供了全局的统计数据报告，包括：</p><p><strong>报告产生时间及产生所花费的时间</strong>：如花费了710秒<br><strong>报告所覆盖的时间</strong>：如2003-02-19 to 2022-12-05<br><strong>年龄</strong>：该repo的年纪，如“7230天，其中5918天是活跃天.”<br><strong>文件数及代码</strong>：如：9256个文件，3130k行代码。<br><strong>总提交数</strong>：如：99776，平均每天13.8个<br><strong>作者数</strong>：如2160，每个作者平均提交次数46.2次。<br><img src="efbe731981191bf53d5ddccfb0d2ceddc68787753068302bb6b07ae3325161c7.png" alt="图 6">  </p><p>除此之外，还包括了：</p><ol><li>时间维度的效率分析：每天中每小时的、每周中每天的、每周中每小时的、每年中每月的、每年的提交量。<br><img src="e3f27ccfddf1d938e78059ed84dbee1e10029e531785d1c35dbd64ec9fd176e4.png" alt="图 7"><br><img src="c2af9654b130fbe357f60fc7d9b0d9f688909b0fd41cc173ed06bc9609bb03db.png" alt="图 8"><br><img src="fe0f04ea5472dac1bb45ef27504cf61e91c71154babe868b1d90ae164ffa901c.png" alt="图 9"><br><img src="d8a4aee3fe667a3fe39257feb14b177fc098d0952bfb78cf7a3139ac838adb95.png" alt="图 10"><br><img src="b04a8580c65f01373f091389a9c3a7d3138acb8aaf002e9a21a5ae8b8587acf5.png" alt="图 11"><br><img src="226d67aed51a110fa818c54b82b4e74434e727c354565bcf779b19f6ba31dd55.png" alt="图 12">  </li></ol><ol start="2"><li>提交者维度的活跃度统计：列举所有的作者（提交数，第一次提交日期，最近一次的提交日期），并按月和年来划分。<br><img src="1245268c1062710ee022fb12149e82705b29e4591c0e3aacb7fd844462b8bdaf.png" alt="图 13">  </li></ol><ol start="3"><li><p>按照文件数：按日期划分，按扩展名名划分。<br><img src="1bacc00060ca63e9f239802a91e68849e4337457d9909e0754eee5fc1664a4ee.png" alt="图 14">  </p></li><li><p>根据提交行数或提交的tag来统计。<br><img src="29853f0496e7b26c4d69af48e2d863367a2c96ee70534f89698a31e3f49b03a4.png" alt="图 15">  </p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;进一步来讲，Gitstats它是一个git仓库分析软件，它可以检查仓库并生成历史数据的统计信息。可以帮助你查看git仓库的提交状态，根据不同维度分析计算，并自动生成数据图表。&lt;br&gt;官网介绍：&lt;a href=&quot;http://gitstats.sourceforge.net/&quot;&gt;http://gitstats.sourceforge.net/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="GIT" scheme="https://rma-shuyu.github.io/categories/GIT/"/>
    
    
    <category term="git" scheme="https://rma-shuyu.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>centos8安装pprof</title>
    <link href="https://rma-shuyu.github.io/2022/11/22/centos8%E5%AE%89%E8%A3%85pprof/"/>
    <id>https://rma-shuyu.github.io/2022/11/22/centos8%E5%AE%89%E8%A3%85pprof/</id>
    <published>2022-11-22T12:24:34.000Z</published>
    <updated>2023-01-27T12:06:26.873Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这是谷歌的一个linux下性能测试的小工具。可以简单快速的发现程序的性能瓶颈。</p><span id="more"></span><h2 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /etc/*release</span></span><br><span class="line">CentOS Linux release 8.4.2105</span><br><span class="line">NAME=<span class="string">&quot;CentOS Linux&quot;</span></span><br><span class="line">VERSION=<span class="string">&quot;8&quot;</span></span><br><span class="line">ID=<span class="string">&quot;centos&quot;</span></span><br><span class="line">ID_LIKE=<span class="string">&quot;rhel fedora&quot;</span></span><br><span class="line">VERSION_ID=<span class="string">&quot;8&quot;</span></span><br><span class="line">PLATFORM_ID=<span class="string">&quot;platform:el8&quot;</span></span><br><span class="line">PRETTY_NAME=<span class="string">&quot;CentOS Linux 8&quot;</span></span><br><span class="line">ANSI_COLOR=<span class="string">&quot;0;31&quot;</span></span><br><span class="line">CPE_NAME=<span class="string">&quot;cpe:/o:centos:centos:8&quot;</span></span><br><span class="line">HOME_URL=<span class="string">&quot;https://centos.org/&quot;</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">&quot;https://bugs.centos.org/&quot;</span></span><br><span class="line">CENTOS_MANTISBT_PROJECT=<span class="string">&quot;CentOS-8&quot;</span></span><br><span class="line">CENTOS_MANTISBT_PROJECT_VERSION=<span class="string">&quot;8&quot;</span></span><br><span class="line">CentOS Linux release 8.4.2105</span><br><span class="line">CentOS Linux release 8.4.2105</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="安装编译工具"><a href="#安装编译工具" class="headerlink" title="安装编译工具"></a>安装编译工具</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc</span><br><span class="line">yum -y install gcc-c++</span><br><span class="line">yum -y install make</span><br><span class="line">yum install -y autoconf automake libtool</span><br><span class="line">yum install -y wget</span><br></pre></td></tr></table></figure><p><strong>提示</strong>：<br>安装过程中出现以下错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum -y install gcc</span></span><br><span class="line">Last metadata expiration check: 0:15:41 ago on Wed 23 Nov 2022 03:56:44 PM CST.</span><br><span class="line">Error: </span><br><span class="line"> Problem: package gcc-8.5.0-4.el8_5.x86_64 requires glibc-devel &gt;= 2.2.90-12, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libpthread.so.0, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libdl.so.2, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libm.so.6, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libresolv.so.2, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires librt.so.1, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libutil.so.1, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libBrokenLocale.so.1, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libanl.so.1, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libthread_db.so.1, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.x86_64 requires glibc = 2.28-164.el8, but none of the providers can be installed</span><br><span class="line">  - glibc-2.28-164.el8.i686 has inferior architecture</span><br><span class="line">  - cannot install both glibc-2.28-164.el8.x86_64 and glibc-2.28-203.el8.x86_64</span><br><span class="line">  - package glibc-gconv-extra-2.28-203.el8.x86_64 requires glibc(x86-64) = 2.28-203.el8, but none of the providers can be installed</span><br><span class="line">  - cannot install the best candidate <span class="keyword">for</span> the job</span><br><span class="line">  - problem with installed package glibc-gconv-extra-2.28-203.el8.x86_64</span><br><span class="line">(try to add <span class="string">&#x27;--allowerasing&#x27;</span> to <span class="built_in">command</span> line to replace conflicting packages or <span class="string">&#x27;--skip-broken&#x27;</span> to skip uninstallable packages or <span class="string">&#x27;--nobest&#x27;</span> to use not only best candidate packages)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>则执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc --allowerasing</span><br></pre></td></tr></table></figure><p>可执行文件对应的安装包查找：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum whatprovides autoreconf</span><br></pre></td></tr></table></figure><p><img src="c5dd6168b78ccf54aa38d65134cb70a21c2adb250934fcf9c448d9d29d12851c.png" alt="图 26"><br>则安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y autoconf</span><br></pre></td></tr></table></figure><h2 id="安装libunwind"><a href="#安装libunwind" class="headerlink" title="安装libunwind"></a>安装libunwind</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/libunwind/libunwind/archive/v0.99.tar.gz</span><br><span class="line">tar -xvf v0.99.tar.gz</span><br><span class="line"><span class="built_in">cd</span> libunwind-0.99</span><br><span class="line">autoreconf --force -v --install</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h2 id="安装perftools"><a href="#安装perftools" class="headerlink" title="安装perftools"></a>安装perftools</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/gperftools/gperftools/releases/download/gperftools-2.6.1/gperftools-2.6.1.tar.gz</span><br><span class="line">tar -xvf gperftools-2.6.1.tar.gz </span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h2 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h2><p><img src="e25c28feccf7bac3e0f524dec94e4a1f7f2d5db678b0fd3366351056d111b03a.png" alt="图 27">  </p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;这是谷歌的一个linux下性能测试的小工具。可以简单快速的发现程序的性能瓶颈。&lt;/p&gt;</summary>
    
    
    
    <category term="LINUX" scheme="https://rma-shuyu.github.io/categories/LINUX/"/>
    
    
    <category term="linux" scheme="https://rma-shuyu.github.io/tags/linux/"/>
    
    <category term="pprof" scheme="https://rma-shuyu.github.io/tags/pprof/"/>
    
  </entry>
  
  <entry>
    <title>base64编解码</title>
    <link href="https://rma-shuyu.github.io/2022/11/16/base64%E7%BC%96%E8%A7%A3%E7%A0%81/"/>
    <id>https://rma-shuyu.github.io/2022/11/16/base64%E7%BC%96%E8%A7%A3%E7%A0%81/</id>
    <published>2022-11-16T12:16:29.000Z</published>
    <updated>2023-01-27T12:06:26.868Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，是一种基于<strong>64个可打印字符</strong>来表示二进制数据的方法</p><span id="more"></span><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ol><li>Base64一般用于在 HTTP协议下传输二进制数据，由于 HTTP协议是文本协议，所以在HTTP协议下传输二进制数据需要将二进制数据转换为字符数据。然而直接转换是不行的。因为网络传输只能传输可打印字符，需要用Base64将不可显字符转换为可显字符</li><li>可用于将明文通过AES加密后，通过Base64将不可显的加密字符转换为可显字符</li></ol><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>base64编码表<br><img src="c617678b70d6a249a3556d4a16a4d49fbd9dc22f4be59bda0d0e52450c20be76.png" alt="图 2"> </p><p>由于base64编码是将编码前的3*8位数据，分解成4个6位的数据，所以经过base64编码后的字符串长度是4的倍数。<br>但往往我们进行编码的数据长度并不是3的倍数，这就造成了“编码”后的位数不为4的倍数，</p><p>比如Brisk共5×8=40位，以6位为一组可以分为7组，这样“编码”后就有7个字符，<br>但base64编码后的字符长度应该是4的倍数，显然这里就出问题了，那么怎么办呢？<br>前面的不可以抛弃掉，所以就只有“追加”了，所以Brisk经过base64编码后的长度应该是8个字符，而第8个编码后的字符是’=’，</p><p>再比如对单个字符a进行base64编码，由于它的长度不是3的倍数，以3个字节为一组它只能分一组，再以6位为一位它只能分两组，所以经过“编码”后它的长度是2，但base64编码后的个数应该是4的倍数，所以它的长度应该是4，所以在后面补上两个‘=’,</p><p>由于一个数求余3后有三个不同的结果，0、1、2，所以在对一个数据进行base64进行编码后它的长度为： </p><ol><li><p>当进行编码的数据长度是3的倍数时，len=strlen(str_in)/3*4;</p></li><li><p>当进行编码的数据长度不是3的倍数时，len=(strlen(str_in)/3+1)*4;</p></li></ol><p>我们以Brisk这个例子来说明一下base64编码的过程。首先我们以3个字符为一组将Brisk进行分组，Brisk被氛围两组：Bri 和 sk；然后我们取出这两个分组中每个字节的ASCII码，B:66 r:114 i:105 s:115 k:107。它们对应的二进制数为  B:01000010 r:01110010 i:01101001 s:01110011 k:01101011；</p><p>第一组，我们以6位为一组对每一个3字节分组进行再分组就变成了010000 100111 001001 101001。所对应的十进制数是16 39 9 41，对应base64表中的结果是 Q n J p；</p><p>第二组，011100 110110 101100(不够补0)，所以对应的十进制数是 28 54 44，对应base64表中的结果是 c 2 s，最终结果为QnJpc2s=（因为第二组“编码”后只有三个字节）。</p><p>解码的过程是一个逆过程，我们将经过编码后的字符按4个字符为一组，然后对照base64表得到相应的十进制数，再将其通过拆分和组合，组成3个8位数据，这个数据就是解码后的数据，下面给一个c语言实现编码和解码的代码。</p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">encode_string</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> * src, <span class="type">int</span> len,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">char</span> * dest, <span class="type">unsigned</span> <span class="type">char</span> * base64, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> one;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> two;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> thr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> fou;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ( len &gt;= <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        one = src[<span class="number">0</span>] &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        two = ( ( src[<span class="number">0</span>] &amp; <span class="number">0x03</span> ) &lt;&lt; <span class="number">4</span> ) | ( src[<span class="number">1</span>] &gt;&gt; <span class="number">4</span> );</span><br><span class="line">        thr = ( ( src[<span class="number">1</span>] &amp; <span class="number">0x0F</span> ) &lt;&lt; <span class="number">2</span> ) | ( src[<span class="number">2</span>] &gt;&gt; <span class="number">6</span> );</span><br><span class="line">        fou = src[<span class="number">2</span>] &amp; <span class="number">0x3F</span>;</span><br><span class="line"> </span><br><span class="line">        *( dest + index++ ) = base64[one];</span><br><span class="line">        *( dest + index++ ) = base64[two];</span><br><span class="line">        *( dest + index++ ) = base64[thr];</span><br><span class="line">        *( dest + index   ) = base64[fou];</span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( len == <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        one = src[<span class="number">0</span>] &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        two = ( ( src[<span class="number">0</span>] &amp; <span class="number">0x03</span>) &lt;&lt; <span class="number">4</span> ) | ( src[<span class="number">1</span>] &gt;&gt; <span class="number">4</span> );</span><br><span class="line">        thr = ( src[<span class="number">1</span>] &amp; <span class="number">0x0F</span> ) &lt;&lt; <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">        *( dest + index++ ) = base64[one];</span><br><span class="line">        *( dest + index++ ) = base64[two];</span><br><span class="line">        *( dest + index++ ) = base64[thr];</span><br><span class="line">        *( dest + index   ) = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( len == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        one = src[<span class="number">0</span>] &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        two = ( src[<span class="number">0</span>] &amp; <span class="number">0x03</span> ) &lt;&lt; <span class="number">4</span>;</span><br><span class="line"> </span><br><span class="line">        *( dest + index++ ) = base64[one];</span><br><span class="line">        *( dest + index++ ) = base64[two];</span><br><span class="line">        *( dest + index++ ) = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">        *( dest + index   ) = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;Unknow length\n&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">base64_encode</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> * src, <span class="type">int</span> src_len, <span class="type">char</span> * dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> base64[] = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( src_len &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> step = encode_string( src, src_len, (<span class="type">unsigned</span> <span class="type">char</span> *)dest, base64, index );</span><br><span class="line"> </span><br><span class="line">        index += <span class="number">4</span>;</span><br><span class="line">        src += step;</span><br><span class="line">src_len -= step;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    *( dest + index ) = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">create_array</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> * <span class="built_in">array</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( index  = <span class="number">0</span>; index &lt; <span class="number">123</span>; index += <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( index == <span class="number">0x2B</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            *( <span class="built_in">array</span> + index ) = <span class="number">0x3E</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( index == <span class="number">0x2F</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            *( <span class="built_in">array</span> + index ) = <span class="number">0x3F</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( index &gt;= <span class="number">0x30</span> &amp;&amp; index &lt;= <span class="number">0x39</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            *( <span class="built_in">array</span> + index ) = <span class="number">0x34</span> + index - <span class="number">0x30</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( index == <span class="number">0x3D</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            *( <span class="built_in">array</span> + index ) = <span class="number">0x00</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( index &gt;= <span class="number">0x41</span> &amp;&amp; index &lt;= <span class="number">0x5A</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            *( <span class="built_in">array</span> + index ) = index - <span class="number">0x41</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( index &gt;= <span class="number">0x61</span> &amp;&amp; index &lt;= <span class="number">0x7A</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            *( <span class="built_in">array</span> + index ) = <span class="number">0x1A</span> + index - <span class="number">0x61</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            *( <span class="built_in">array</span> + index ) = <span class="number">0x00</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    *( <span class="built_in">array</span> + <span class="number">123</span> ) = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">decode_string</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * src, <span class="type">unsigned</span> <span class="type">char</span> * dest, <span class="type">unsigned</span> <span class="type">char</span> * <span class="built_in">array</span>, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> step;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> one;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> two;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> thr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( src[<span class="number">3</span>] == <span class="string">&#x27;=&#x27;</span> &amp;&amp; src[<span class="number">2</span>] == <span class="string">&#x27;=&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        one = ( <span class="built_in">array</span>[src[<span class="number">0</span>]] &lt;&lt; <span class="number">2</span> ) | ( <span class="built_in">array</span>[src[<span class="number">1</span>]] &gt;&gt; <span class="number">4</span> );</span><br><span class="line">        *( dest + index ) = one;</span><br><span class="line"> </span><br><span class="line">        step = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( src[<span class="number">3</span>] == <span class="string">&#x27;=&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        one = ( <span class="built_in">array</span>[src[<span class="number">0</span>]] &lt;&lt; <span class="number">2</span> ) | ( <span class="built_in">array</span>[src[<span class="number">1</span>]] &gt;&gt; <span class="number">4</span> );</span><br><span class="line">        two = ( ( <span class="built_in">array</span>[src[<span class="number">1</span>]] &amp; <span class="number">0x0F</span> ) &lt;&lt; <span class="number">4</span> ) | ( <span class="built_in">array</span>[src[<span class="number">2</span>]] &gt;&gt; <span class="number">2</span> );</span><br><span class="line"> </span><br><span class="line">        *( dest + index++ ) = one;</span><br><span class="line">        *( dest + index   ) = two;</span><br><span class="line"> </span><br><span class="line">        step = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        one = ( <span class="built_in">array</span>[src[<span class="number">0</span>]] &lt;&lt; <span class="number">2</span> ) | ( <span class="built_in">array</span>[src[<span class="number">1</span>]] &gt;&gt; <span class="number">4</span> );</span><br><span class="line">        two = ( ( <span class="built_in">array</span>[src[<span class="number">1</span>]] &amp; <span class="number">0x0F</span> ) &lt;&lt; <span class="number">4</span> ) | ( <span class="built_in">array</span>[src[<span class="number">2</span>]] &gt;&gt; <span class="number">2</span> );</span><br><span class="line">        thr = ( <span class="built_in">array</span>[src[<span class="number">2</span>]] &lt;&lt; <span class="number">6</span> ) | <span class="built_in">array</span>[src[<span class="number">3</span>]];</span><br><span class="line"> </span><br><span class="line">        *( dest + index++ ) = one;</span><br><span class="line">        *( dest + index++ ) = two;</span><br><span class="line">        *( dest + index   ) = thr;</span><br><span class="line"> </span><br><span class="line">        step = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">base64_decode</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * src, <span class="type">unsigned</span> <span class="type">char</span> * dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> <span class="built_in">array</span>[<span class="number">124</span>];</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>( <span class="built_in">array</span>, <span class="number">0x00</span>, <span class="number">124</span> );</span><br><span class="line">    create_array( <span class="built_in">array</span> );</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> ( *src )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> step = decode_string( src, dest, <span class="built_in">array</span>, index );</span><br><span class="line"> </span><br><span class="line">        index += step;</span><br><span class="line">        src   += <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    *( dest + index ) = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>测试代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> *src_str = <span class="string">&quot;abcsjdhs123134&quot;</span>;</span><br><span class="line"><span class="type">int</span> src_str_len = <span class="built_in">strlen</span>(src_str);</span><br><span class="line"><span class="type">char</span> *out_buf = (<span class="type">char</span> *)<span class="built_in">malloc</span>(src_str_len * <span class="number">2</span>);</span><br><span class="line"><span class="type">char</span> *out_decode_buf = (<span class="type">char</span> *)<span class="built_in">malloc</span>(src_str_len * <span class="number">2</span>);</span><br><span class="line">base64_encode(src_str, src_str_len, out_buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;src_str:       %s\n&quot;</span>, src_str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;base64_encode: %s\n&quot;</span>, out_buf);</span><br><span class="line"></span><br><span class="line">base64_decode(out_buf, out_decode_buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;base64_decode: %s\n&quot;</span>, out_decode_buf);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果展示<br><img src="8106a76ff5b18e8cda5e478736125efeec53fcaf86e1744cf4fe4accaaf6a38b.png" alt="图 3">  </p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，是一种基于&lt;strong&gt;64个可打印字符&lt;/strong&gt;来表示二进制数据的方法&lt;/p&gt;</summary>
    
    
    
    <category term="BASE64" scheme="https://rma-shuyu.github.io/categories/BASE64/"/>
    
    
    <category term="BASE64" scheme="https://rma-shuyu.github.io/tags/BASE64/"/>
    
  </entry>
  
  <entry>
    <title>OpenSSL之AES用法</title>
    <link href="https://rma-shuyu.github.io/2022/11/16/OpenSSL%E4%B9%8BAES%E7%94%A8%E6%B3%95/"/>
    <id>https://rma-shuyu.github.io/2022/11/16/OpenSSL%E4%B9%8BAES%E7%94%A8%E6%B3%95/</id>
    <published>2022-11-16T11:20:44.000Z</published>
    <updated>2023-01-27T12:06:26.847Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>AES是<strong>对称</strong>加密的算法，使用128、192 和 256 位密钥，将被加密数据划分为128位（16字节）一块，然后使用某种加密模式进行加密</p><p>关键词：<br><strong>块大小</strong>：16字节<br><strong>密钥长度</strong>：AES算法下，key的长度有三种：128、192和256 bits。</p><span id="more"></span><p><strong>加密模式</strong>：AES属于块加密（Block Cipher），块加密中有CBC、ECB、CTR、OFB、CFB等几种工作模式。<br><strong>填充模式</strong>：</p><ul><li>NoPadding，数据长度不对齐时使用”\0”填充，否则不填充</li><li>PKCS7Padding，假设数据长度需要填充n(n&gt;0)个字节才对齐，那么填充n个字节，每个字节都是n;如果数据本身就已经对齐了，则填充一块长度为块大小的数据，每个字节都是块大小</li><li>PKCS5Padding，PKCS7Padding的子集，块大小固定为8字节。</li></ul><p>AES加密，如果输入是16<em>n字节，NoPadding填充的情况下，输出和输入相同；有填充的情况下，输出是16</em>（n+1）。<br>如果输入不是16字节整数倍，而是大于16<em>n小于16</em>（n+1），NoPadding填充情况下（只能是CFB和OFB模式），输出和输入长度相同；其他情况下，输出长度是16*（n+1）</p><h2 id="设置加解密接口"><a href="#设置加解密接口" class="headerlink" title="设置加解密接口"></a>设置加解密接口</h2><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><ul><li><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">AES_set_encrypt_key</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *userKey, <span class="type">const</span> <span class="type">int</span> bits,</span></span><br><span class="line"><span class="params">                        AES_KEY *key)</span>;</span><br></pre></td></tr></table></figure></li><li><p>函数作用<br>设定加密用的Key</p></li><li><p>参数说明<br><code>userKey</code>： 密钥数值；<br><code>bits</code>：密钥长度，以bit为单位，如果密钥数字是16个字节，则此参数值应为128；<br><code>key</code>： AES_KEY对象指针；<br><code>返回值</code>：<br>0: 成功<br>1: userkey，key为空<br>2: 密钥长度不是128，192，256</p></li></ul><h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><ul><li><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">AES_set_decrypt_key</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *userKey, <span class="type">const</span> <span class="type">int</span> bits,</span></span><br><span class="line"><span class="params">                        AES_KEY *key)</span>;</span><br></pre></td></tr></table></figure></li><li><p>函数作用<br>设定解密用的Key</p></li><li><p>参数说明<br><code>userKey</code>： 密钥数值；<br><code>bits</code>：密钥长度，以bit为单位，如果密钥数字是16个字节，则此参数值应为128；<br><code>key</code>： AES_KEY对象指针；<br><code>返回值</code>：<br>0: 成功<br>1: userkey，key为空<br>2: 密钥长度不是128，192，256</p></li></ul><h2 id="常用加密模式"><a href="#常用加密模式" class="headerlink" title="常用加密模式"></a>常用加密模式</h2><h3 id="CBC"><a href="#CBC" class="headerlink" title="CBC"></a>CBC</h3><ul><li><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AES_cbc_encrypt</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *in, <span class="type">unsigned</span> <span class="type">char</span> *out,</span></span><br><span class="line"><span class="params">                     <span class="type">size_t</span> length, <span class="type">const</span> AES_KEY *key,</span></span><br><span class="line"><span class="params">                     <span class="type">unsigned</span> <span class="type">char</span> *ivec, <span class="type">const</span> <span class="type">int</span> enc)</span>;</span><br></pre></td></tr></table></figure></li><li><p>函数作用：<br>AES加密/解密单个数据块（16个字节），CBC模式</p></li><li><p>参数说明：<br><code>in</code>： 需要加密/解密的数据；<br><code>out</code>： 计算后输出的数据；<br><code>length</code>： 数据长度（这里不包含初始向量数据长度）<br><code>key</code>：密钥<br><code>ivec</code>： 初始向量（一般为16字节全0）<br><code>enc</code>：<br>AES_ENCRYPT：代表加密<br>AES_DECRYPT：代表解密</p></li></ul><h3 id="ECB"><a href="#ECB" class="headerlink" title="ECB"></a>ECB</h3><ul><li><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AES_ecb_encrypt</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *in, <span class="type">unsigned</span> <span class="type">char</span> *out,</span></span><br><span class="line"><span class="params">                     <span class="type">const</span> AES_KEY *key, <span class="type">const</span> <span class="type">int</span> enc)</span>;</span><br></pre></td></tr></table></figure></li><li><p>函数作用：<br>AES加密/解密单个数据块（16个字节），ECB模式</p></li><li><p>参数说明：<br><code>in</code>: 需要加密/解密的数据；<br><code>out</code>: 计算后输出的数据；<br><code>key</code>: 密钥<br><code>enc</code>:<br>AES_ENCRYPT：代表加密<br>AES_DECRYPT：代表解密</p></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>测试代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TEST_ORG_DATA <span class="string">&quot;this is test aes data!&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">remove_padding</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buff, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">ch = buff[size - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; ch; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (buff[size - i] != buff[size - (i + <span class="number">1</span>)])</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buff[size - i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">str2hex</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *ret = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> str_len = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> sret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">ret = (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="built_in">malloc</span>(str_len / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; str_len; i += <span class="number">2</span>)</span><br><span class="line">sret = <span class="built_in">sscanf</span>(str + i, <span class="string">&quot;%2hhX&quot;</span>, &amp;ret[i/<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">if</span> (sret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">free</span>(ret);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">decode_aes128_ecb</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *encrypt_buff, <span class="type">int</span> buf_len, <span class="type">unsigned</span> <span class="type">char</span> **out)</span></span><br><span class="line">&#123;</span><br><span class="line">AES_KEY aes;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *decrypt_buff = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *key = str2hex(<span class="string">&quot;B1CFC3D787DC4511&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;aes, <span class="number">0</span>, <span class="keyword">sizeof</span>(aes));</span><br><span class="line">decrypt_buff = (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="built_in">malloc</span>((<span class="type">size_t</span>)buf_len);</span><br><span class="line"></span><br><span class="line">AES_set_decrypt_key(key, <span class="number">128</span>, &amp;aes);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; buf_len; i += AES_BLOCK_SIZE) &#123;</span><br><span class="line">AES_ecb_encrypt</span><br><span class="line">(encrypt_buff + i, decrypt_buff + i, &amp;aes, AES_DECRYPT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">remove_padding(decrypt_buff, buf_len);</span><br><span class="line"></span><br><span class="line">*out = decrypt_buff;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">encode_aes128_ecb</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> **out, <span class="type">int</span> *out_len)</span></span><br><span class="line">&#123;</span><br><span class="line">AES_KEY aes;</span><br><span class="line"><span class="type">int</span> data_len = <span class="built_in">strlen</span>(TEST_ORG_DATA);</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="type">json_error_t</span> error;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *encrypt_buff = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *decrypt_buff = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *key = str2hex(<span class="string">&quot;B1CFC3D787DC4511&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pad_len = AES_BLOCK_SIZE - (data_len % AES_BLOCK_SIZE);</span><br><span class="line">encrypt_buff = (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="built_in">malloc</span>(data_len + pad_len);</span><br><span class="line">decrypt_buff = (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="built_in">malloc</span>(data_len + pad_len);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(decrypt_buff, TEST_ORG_DATA, data_len);</span><br><span class="line"><span class="built_in">memset</span>(decrypt_buff+data_len, pad_len, pad_len);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;aes, <span class="number">0</span>, <span class="keyword">sizeof</span>(aes));</span><br><span class="line">AES_set_encrypt_key(key, <span class="number">128</span>, &amp;aes);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; data_len+pad_len; i += AES_BLOCK_SIZE) &#123;</span><br><span class="line">AES_ecb_encrypt</span><br><span class="line">(decrypt_buff + i, encrypt_buff + i, &amp;aes, AES_ENCRYPT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*out = encrypt_buff;</span><br><span class="line">*out_len = data_len+pad_len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;data before aes :\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, TEST_ORG_DATA);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *en_code = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> en_code_len;</span><br><span class="line">encode_aes128_ecb(&amp;en_code, &amp;en_code_len);</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *de_code = <span class="literal">NULL</span>;</span><br><span class="line">decode_aes128_ecb(en_code, en_code_len, &amp;de_code);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;data after aes encode and decode :\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, de_code);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试结果：<br><img src="4f8473f4df84e1e65d147bd49af24b1cf87b702462969287d002e093c7cfd2e1.png" alt="图 2">  </p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;AES是&lt;strong&gt;对称&lt;/strong&gt;加密的算法，使用128、192 和 256 位密钥，将被加密数据划分为128位（16字节）一块，然后使用某种加密模式进行加密&lt;/p&gt;
&lt;p&gt;关键词：&lt;br&gt;&lt;strong&gt;块大小&lt;/strong&gt;：16字节&lt;br&gt;&lt;strong&gt;密钥长度&lt;/strong&gt;：AES算法下，key的长度有三种：128、192和256 bits。&lt;/p&gt;</summary>
    
    
    
    <category term="OPENSSL" scheme="https://rma-shuyu.github.io/categories/OPENSSL/"/>
    
    
    <category term="AES" scheme="https://rma-shuyu.github.io/tags/AES/"/>
    
    <category term="OPENSSL" scheme="https://rma-shuyu.github.io/tags/OPENSSL/"/>
    
  </entry>
  
  <entry>
    <title>/dev/shm容器下调优</title>
    <link href="https://rma-shuyu.github.io/2022/07/12/dev-shm%E5%AE%B9%E5%99%A8%E4%B8%8B%E8%B0%83%E4%BC%98/"/>
    <id>https://rma-shuyu.github.io/2022/07/12/dev-shm%E5%AE%B9%E5%99%A8%E4%B8%8B%E8%B0%83%E4%BC%98/</id>
    <published>2022-07-12T12:50:20.000Z</published>
    <updated>2023-11-12T13:43:55.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>一些应用软件如oracle、postgresql在处理数据时通常会利用/dev/shm目录来缓存的数据文件,以加快IO读写,但是docker 默认只在容器里给这个文件分配64M大小,当应用软件需要缓存较大数据时,就会导致类似<code>could not resize shared memory segment &quot;/PostgreSQL.1131616928&quot; to 16777216 bytes: No space left on device</code>的报错,这样就需要调整/dev/shm大小</p><span id="more"></span><h3 id="dev-shm目录是什么"><a href="#dev-shm目录是什么" class="headerlink" title="/dev/shm目录是什么"></a>/dev/shm目录是什么</h3><p>/dev/shm在linux中被看作一个设备文件,可以把它看成是内存的入口、一块物理存储或者tmp filesystem，可以通过这个设备向内存中读写文件，以加快某些io高的操作。</p><h4 id="dev-shm-理论"><a href="#dev-shm-理论" class="headerlink" title="/dev/shm 理论"></a>/dev/shm 理论</h4><p>默认的Linux发行版中的内核配置都会开启tmpfs，映射到了/dev/下的shm目录。可以通过df 命令查看结果.<br>/dev/shm/是linux下一个非常有用的目录，因为这个目录不在硬盘上，而是在内存里。因此在linux下，就不需要大费周折去建ramdisk，直接使用/dev/shm/就可达到很好的优化效果。默认系统就会加载/dev/shm ，它就是所谓的tmpfs，有人说跟ramdisk（虚拟磁盘），但不一样。象虚拟磁盘一样，tmpfs 可以使用您的 RAM，但它也可以使用您的交换分区来存储。而且传统的虚拟磁盘是个块设备，并需要一个 mkfs 之类的命令才能真正地使用它，tmpfs 是一个文件系统，而不是块设备；您只是安装它，它就可以使用了。<br>tmpfs有以下优势：</p><ol><li>动态文件系统的大小，/dev /shm需要注意的一个是容量问题，在linux下，它默认最大为内存的一半大小，使用df -h命令可以看到。但它并不会真正的占用这块内存，如果/dev/shm/下没有任何文件，它占用的内存实际上就是0字节；如果它最大为1G，里头放有 100M文件，那剩余的900M仍然可为其它应用程序所使用，但它所占用的100M内存，是绝不会被系统回收重新划分的</li><li>tmpfs 的另一个主要的好处是它闪电般的速度。因为典型的 tmpfs 文件系统会完全驻留在 RAM 中，读写几乎可以是瞬间的。</li><li>tmpfs 数据在重新启动之后不会保留，因为虚拟内存本质上就是易失的。所以有必要做一些脚本做诸如加载，绑定的操作。</li></ol><h4 id="修改-dev-shm大小"><a href="#修改-dev-shm大小" class="headerlink" title="修改/dev/shm大小"></a>修改/dev/shm大小</h4><p>默认的最大一半内存大小在某些场合可能不够用，并且默认的inode数量很低一般都要调高些，这时可以用mount命令来管理它。<br><code>#mount -o size=1500M -o nr_inodes=1000000 -o noatime,nodiratime -o remount /dev/shm</code></p><p>也可以将mount配置写到fstab让其开机生效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;tmpfs /dev/shm tmpfs,defaults,size=512m 0 0&quot; &gt;&gt; /etc/fstab</span><br><span class="line">mount -o remount /dev/shm</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>下面我们可以创建一个目录绑定/dev/shm文件系统,并测试读写速度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mkdir /dev/shm/tmp</span><br><span class="line">chmod 1777 /dev/shm/tmp</span><br><span class="line">mkdir /fbo-tmp</span><br><span class="line">mount --bind /dev/shm/tmp /fbo-tmp</span><br><span class="line">cd /fbo-tmp</span><br><span class="line">dd if=/dev/zero of=./test.dt bs=1k count=10000</span><br><span class="line"></span><br><span class="line"># free -m 可以发现share内存被占用了10M</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="容器下怎么设置"><a href="#容器下怎么设置" class="headerlink" title="容器下怎么设置"></a>容器下怎么设置</h2><h3 id="docker设置"><a href="#docker设置" class="headerlink" title="docker设置"></a>docker设置</h3><p>docker启动时添加<code>--shm-size</code>参数调整/dev/shm文件系统大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --shm-size 124M -it --rm --name test-$RANDOM busybox /bin/sh</span><br><span class="line">Unable to find image &#x27;busybox:latest&#x27; locally</span><br><span class="line">latest: Pulling from library/busybox</span><br><span class="line">b71f96345d44: Pull complete </span><br><span class="line">Digest: sha256:930490f97e5b921535c153e0e7110d251134cc4b72bbb8133c6a5065cc68580d</span><br><span class="line">Status: Downloaded newer image for busybox:latest</span><br><span class="line">/ # df -h  | grep /dev/shm</span><br><span class="line">shm                     124.0M         0    124.0M   0% /dev/shm</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="k8s-中的设置"><a href="#k8s-中的设置" class="headerlink" title="k8s 中的设置"></a>k8s 中的设置</h3><p>可以通过emptyDir挂在内存到容器的/dev/shm目录实现设置容器内的/dev/shm大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">$ vim pods-shm.yml </span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: test-pd-shm</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - image: busybox</span><br><span class="line">    name: busybox-test</span><br><span class="line">    command: [ &quot;sleep&quot;, &quot;1000000&quot; ]</span><br><span class="line">    imagePullPolicy: &quot;IfNotPresent&quot;</span><br><span class="line">    volumeMounts:</span><br><span class="line">      - mountPath: /dev/shm</span><br><span class="line">        name: cache-volume</span><br><span class="line">  volumes:</span><br><span class="line">  - emptyDir:</span><br><span class="line">      medium: Memory</span><br><span class="line">      sizeLimit: 128Mi</span><br><span class="line">    name: cache-volume</span><br><span class="line">$ kubectl apply -f pods-shm.yml </span><br><span class="line">pod/test-pd-shm created</span><br><span class="line">$ kubectl exec -it test-pd-shm -- sh</span><br><span class="line">/ # df -h | grep /dev/shm</span><br><span class="line">tmpfs                    15.7G         0     15.7G   0% /dev/shm</span><br><span class="line">### 这里看到大小为15.7G,难道sizelimit没有生效?</span><br><span class="line">### 测试一下</span><br><span class="line">/dev/shm # dd if=/dev/zero of=test.dt bs=1M count=200</span><br><span class="line">200+0 records in</span><br><span class="line">200+0 records out</span><br><span class="line">209715200 bytes (200.0MB) copied, 0.099244 seconds, 2.0GB/s</span><br><span class="line">/dev/shm # df -h | grep /dev/shm</span><br><span class="line">tmpfs                    15.7G    200.0M     15.5G   1% /dev/shm</span><br><span class="line">/dev/shm # command terminated with exit code 137</span><br><span class="line">$ kubectl get pods </span><br><span class="line">NAME          READY   STATUS    RESTARTS   AGE</span><br><span class="line">test-pd-shm   0/1     Evicted   0          6m22s</span><br><span class="line">### 可以看到实际写入200m就会导致pod被驱散</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;一些应用软件如oracle、postgresql在处理数据时通常会利用/dev/shm目录来缓存的数据文件,以加快IO读写,但是docker 默认只在容器里给这个文件分配64M大小,当应用软件需要缓存较大数据时,就会导致类似&lt;code&gt;could not resize shared memory segment &amp;quot;/PostgreSQL.1131616928&amp;quot; to 16777216 bytes: No space left on device&lt;/code&gt;的报错,这样就需要调整/dev/shm大小&lt;/p&gt;</summary>
    
    
    
    <category term="DOCKER" scheme="https://rma-shuyu.github.io/categories/DOCKER/"/>
    
    
    <category term="DOCKER" scheme="https://rma-shuyu.github.io/tags/DOCKER/"/>
    
  </entry>
  
  <entry>
    <title>rpm-build打包</title>
    <link href="https://rma-shuyu.github.io/2022/07/11/rpm-build%E6%89%93%E5%8C%85/"/>
    <id>https://rma-shuyu.github.io/2022/07/11/rpm-build%E6%89%93%E5%8C%85/</id>
    <published>2022-07-11T12:50:20.000Z</published>
    <updated>2023-11-12T13:43:55.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>之前介绍yum是基于rpm的包管理工具，yum最终安装的是rpm包，那rpm包是如何来的呢？</p><p>按照网上的教程制作了个rpm包，这里记录下。</p><span id="more"></span><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>1）安装制作工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install rpm-build rpm-devel rpmdevtools</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2）生成开发目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpmdev-setuptree </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3）源代码<br>现在，我们来编码源代码，这里我们写个脚本，输出<code>Hello World!</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/rpmbuild/SOURCES/helloworld-1.0.0</span><br><span class="line">cd ~/rpmbuild/SOURCES/helloworld-1.0.0</span><br><span class="line">touch helloworld</span><br><span class="line">chmod 755 helloworld</span><br><span class="line">echo &#x27;#!/bin/sh&#x27; &gt;&gt; helloworld</span><br><span class="line">echo &#x27;echo Hello World!&#x27; &gt;&gt; helloworld</span><br><span class="line">cd ~/rpmbuild/SOURCES</span><br><span class="line">tar zcvf helloworld-1.0.0.tar.gz helloworld-1.0.0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样我们就有了我们的源代码<code>helloworld-1.0.0.tar.gz</code></p><p>4)编写spec文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd  ~/rpmbuild/SPECS</span><br><span class="line"># 生成spec模版文件</span><br><span class="line">rpmdev-newspec helloworld.spec</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>将内容修改为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Name:           helloworld</span><br><span class="line">Version:        1.0.0</span><br><span class="line">Release:        1%&#123;?dist&#125;</span><br><span class="line">Summary:        helloworld</span><br><span class="line"></span><br><span class="line">Group:          Development/Tools</span><br><span class="line">License:        GPL</span><br><span class="line">#URL:            </span><br><span class="line">Source0:        %&#123;name&#125;-%&#123;version&#125;.tar.gz</span><br><span class="line"></span><br><span class="line">#BuildRequires:  </span><br><span class="line">#Requires:       </span><br><span class="line"></span><br><span class="line">%description</span><br><span class="line"></span><br><span class="line">%prep</span><br><span class="line">%setup -q</span><br><span class="line"></span><br><span class="line">%build</span><br><span class="line"></span><br><span class="line">%install</span><br><span class="line">mkdir -p $RPM_BUILD_ROOT/usr/bin</span><br><span class="line">cp $RPM_BUILD_DIR/%&#123;name&#125;-%&#123;version&#125;/helloworld $RPM_BUILD_ROOT/usr/bin/</span><br><span class="line"></span><br><span class="line">%clean</span><br><span class="line">rm -rf $RPM_BUILD_ROOT</span><br><span class="line"></span><br><span class="line">%files</span><br><span class="line">%defattr(-,root,root,-)</span><br><span class="line">%doc</span><br><span class="line">/usr/bin/helloworld</span><br><span class="line"></span><br><span class="line">%changelog</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>5)打包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpmbuild -ba SPECS/helloworld.spec</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查看下最后的目录结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> tree ~/rpmbuild/</span><br><span class="line"> /root/rpmbuild/</span><br><span class="line">├── BUILD</span><br><span class="line">│   └── helloworld-1.0.0</span><br><span class="line">│       ├── debugfiles.list</span><br><span class="line">│       ├── debuglinks.list</span><br><span class="line">│       ├── debugsources.list</span><br><span class="line">│       ├── elfbins.list</span><br><span class="line">│       └── helloworld</span><br><span class="line">├── BUILDROOT</span><br><span class="line">├── RPMS</span><br><span class="line">│   └── x86_64</span><br><span class="line">│       ├── helloworld-1.0.0-1.el7.x86_64.rpm</span><br><span class="line">│       └── helloworld-debuginfo-1.0.0-1.el7.x86_64.rpm</span><br><span class="line">├── SOURCES</span><br><span class="line">│   ├── helloworld-1.0.0</span><br><span class="line">│   │   └── helloworld</span><br><span class="line">│   └── helloworld-1.0.0.tar.gz</span><br><span class="line">├── SPECS</span><br><span class="line">│   └── helloworld.spec</span><br><span class="line">└── SRPMS</span><br><span class="line">    └── helloworld-1.0.0-1.el7.src.rpm</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>BUILD是编译rpm包的临时目录<br>BUILDROOT是最后生成rpm包的临时安装目录<br>RPMS存放最终生成的rpm二进制包<br>SOURCES是源代码(.tar.gz)存放目录<br>SPECS用来存放spec文件<br>SRPMS存放最终生成的rpm源码包<br>rpmbuild/RPMS/x86_64/helloworld-1.0.0-1.el7.x86_64.rpm就是我们打出来的rpm包</p></blockquote><p>6)安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install ~/rpmbuild/RPMS/x86_64/helloworld-1.0.0-1.el7.x86_64.rpm </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh helloworld-1.0.0-1.el7.x86_64.rpm </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>命令行运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">helloworld</span><br><span class="line">Hello World!</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>好啦，成功了!</p><h1 id="spec"><a href="#spec" class="headerlink" title="spec"></a>spec</h1><p>好了，回过头再看看打包的步骤，最重要的莫过于<code>helloworld.spec</code>了，我们来详细解释下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Name:           helloworld</span><br><span class="line">Version:        1.0.0</span><br><span class="line">Release:        1%&#123;?dist&#125;</span><br><span class="line">Summary:        helloworld</span><br><span class="line"></span><br><span class="line">Group:          Development/Tools</span><br><span class="line">License:        GPL</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>名称、版本号、打包版本号、简介、Group、License</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Source0:        %&#123;name&#125;-%&#123;version&#125;.tar.gz</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>源代码路径，要确保在SOURCES目录下能找到该包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#BuildRequires:  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译需要的环境，如gcc&gt;=4.7，这里不需要</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#Requires:      </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该软件运行的依赖，如python rpm&gt;=0:4.1.1，这里不需要</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%description</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>详细描述</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%prep</span><br><span class="line">%setup -q</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译前的准备操作在这儿,%setup macro 会把 source code tarball 解开并自动进到 %{name}-%{version} 的目录中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%build</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译，对应源代码打包的./configure和make,例如(%configure –prefix=%{_prefix})</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">%install</span><br><span class="line">mkdir -p $RPM_BUILD_ROOT/usr/bin</span><br><span class="line">cp $RPM_BUILD_DIR/%&#123;name&#125;-%&#123;version&#125;/helloworld $RPM_BUILD_ROOT/usr/bin/</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>安装，对应源代码包打包的make install，一般我们是安装在$RPM_BUILD_ROOT下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">%files</span><br><span class="line">%defattr(-,root,root,-)</span><br><span class="line">%doc</span><br><span class="line">/usr/bin/helloworld</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>收集文件并创建二进制和源RPM文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">%clean</span><br><span class="line">rm -rf $RPM_BUILD_ROOT</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>删除临时构建目录</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;之前介绍yum是基于rpm的包管理工具，yum最终安装的是rpm包，那rpm包是如何来的呢？&lt;/p&gt;
&lt;p&gt;按照网上的教程制作了个rpm包，这里记录下。&lt;/p&gt;</summary>
    
    
    
    <category term="LINUX" scheme="https://rma-shuyu.github.io/categories/LINUX/"/>
    
    
    <category term="rpm-build" scheme="https://rma-shuyu.github.io/tags/rpm-build/"/>
    
  </entry>
  
  <entry>
    <title>x86架构下进行ARM镜像的构建与运行</title>
    <link href="https://rma-shuyu.github.io/2022/07/11/x86%E6%9E%B6%E6%9E%84%E4%B8%8B%E8%BF%9B%E8%A1%8CARM%E9%95%9C%E5%83%8F%E7%9A%84%E6%9E%84%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/"/>
    <id>https://rma-shuyu.github.io/2022/07/11/x86%E6%9E%B6%E6%9E%84%E4%B8%8B%E8%BF%9B%E8%A1%8CARM%E9%95%9C%E5%83%8F%E7%9A%84%E6%9E%84%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C/</id>
    <published>2022-07-11T12:50:20.000Z</published>
    <updated>2023-11-12T13:43:55.364Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><blockquote><p>在ARM体系结构的硬件环境中安装Docker，然后构建并运行ARM的镜像自然非常简单，但是如果没有ARM环境，只有x86的机器又想做这件事情，这时QEMU也就有了用武之地。</p></blockquote><span id="more"></span><h2 id="问题再现"><a href="#问题再现" class="headerlink" title="问题再现"></a>问题再现</h2><h3 id="事前准备"><a href="#事前准备" class="headerlink" title="事前准备"></a>事前准备</h3><ul><li>  获取ARM格式的Alpine镜像</li></ul><blockquote><p>执行命令：docker pull arm64v8/alpine:3.12.1</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker images |grep arm64v8/alpine</span><br><span class="line">arm64v8/alpine                                                       3.12.1                          2e77e061c27f        6 days ago          5.32MB</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="启动容器并进入"><a href="#启动容器并进入" class="headerlink" title="启动容器并进入"></a>启动容器并进入</h3><ul><li>  启动容器并进入</li></ul><blockquote><p>执行命令：docker run –rm -it arm64v8/alpine:3.12.1 sh</p></blockquote><p>可以看到在x86的机器上执行时出现了如下错误信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ uname -m</span><br><span class="line">x86_64</span><br><span class="line">$ docker run --rm -it arm64v8/alpine:3.12.1 sh</span><br><span class="line">standard_init_linux.go:211: exec user process caused &quot;no such file or directory&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>有的时候提示现象不同，其实主要原因就在于体系架构不同所导致的</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>可以根据需要到QEMU上下载对应的可执行文件进行执行，还有一种最为简单的方式就是使用容器的方式执行，使用如下命令，可使得当前机器可以直接直接模拟相应的体系结构</p><blockquote><p>执行命令：docker run –rm –privileged multiarch/qemu-user-static –reset –persistent yes</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm --privileged multiarch/qemu-user-static --reset --persistent yes</span><br><span class="line">Setting /usr/bin/qemu-alpha-static as binfmt interpreter for alpha</span><br><span class="line">Setting /usr/bin/qemu-arm-static as binfmt interpreter for arm</span><br><span class="line">Setting /usr/bin/qemu-armeb-static as binfmt interpreter for armeb</span><br><span class="line">Setting /usr/bin/qemu-sparc-static as binfmt interpreter for sparc</span><br><span class="line">Setting /usr/bin/qemu-sparc32plus-static as binfmt interpreter for sparc32plus</span><br><span class="line">Setting /usr/bin/qemu-sparc64-static as binfmt interpreter for sparc64</span><br><span class="line">Setting /usr/bin/qemu-ppc-static as binfmt interpreter for ppc</span><br><span class="line">Setting /usr/bin/qemu-ppc64-static as binfmt interpreter for ppc64</span><br><span class="line">Setting /usr/bin/qemu-ppc64le-static as binfmt interpreter for ppc64le</span><br><span class="line">Setting /usr/bin/qemu-m68k-static as binfmt interpreter for m68k</span><br><span class="line">Setting /usr/bin/qemu-mips-static as binfmt interpreter for mips</span><br><span class="line">Setting /usr/bin/qemu-mipsel-static as binfmt interpreter for mipsel</span><br><span class="line">Setting /usr/bin/qemu-mipsn32-static as binfmt interpreter for mipsn32</span><br><span class="line">Setting /usr/bin/qemu-mipsn32el-static as binfmt interpreter for mipsn32el</span><br><span class="line">Setting /usr/bin/qemu-mips64-static as binfmt interpreter for mips64</span><br><span class="line">Setting /usr/bin/qemu-mips64el-static as binfmt interpreter for mips64el</span><br><span class="line">Setting /usr/bin/qemu-sh4-static as binfmt interpreter for sh4</span><br><span class="line">Setting /usr/bin/qemu-sh4eb-static as binfmt interpreter for sh4eb</span><br><span class="line">Setting /usr/bin/qemu-s390x-static as binfmt interpreter for s390x</span><br><span class="line">Setting /usr/bin/qemu-aarch64-static as binfmt interpreter for aarch64</span><br><span class="line">Setting /usr/bin/qemu-aarch64_be-static as binfmt interpreter for aarch64_be</span><br><span class="line">Setting /usr/bin/qemu-hppa-static as binfmt interpreter for hppa</span><br><span class="line">Setting /usr/bin/qemu-riscv32-static as binfmt interpreter for riscv32</span><br><span class="line">Setting /usr/bin/qemu-riscv64-static as binfmt interpreter for riscv64</span><br><span class="line">Setting /usr/bin/qemu-xtensa-static as binfmt interpreter for xtensa</span><br><span class="line">Setting /usr/bin/qemu-xtensaeb-static as binfmt interpreter for xtensaeb</span><br><span class="line">Setting /usr/bin/qemu-microblaze-static as binfmt interpreter for microblaze</span><br><span class="line">Setting /usr/bin/qemu-microblazeel-static as binfmt interpreter for microblazeel</span><br><span class="line">Setting /usr/bin/qemu-or1k-static as binfmt interpreter for or1k</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="结果确认"><a href="#结果确认" class="headerlink" title="结果确认"></a>结果确认</h2><p>然后再次使用同样命令即可发现可进入ARM格式的容器中，使用uname命令也可以确认到其体系结构为ARM格式（aarch64）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -it arm64v8/alpine:3.12.1 sh</span><br><span class="line">/ # uname -m</span><br><span class="line">aarch64</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="构建ARM镜像并确认"><a href="#构建ARM镜像并确认" class="headerlink" title="构建ARM镜像并确认"></a>构建ARM镜像并确认</h2><ul><li>构建ARM镜像<br>  使用如下Dockerfile构建ARM镜像</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ cat Dockerfile </span><br><span class="line">FROM arm64v8/alpine:3.12.1</span><br><span class="line">RUN set -x \</span><br><span class="line">    &amp;&amp; sed -i &#x27;s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/&#x27; /etc/apk/repositories \</span><br><span class="line">    &amp;&amp; echo &#x27;http://mirrors.aliyun.com/alpine/edge/testing&#x27; &gt;&gt; /etc/apk/repositories \</span><br><span class="line">    &amp;&amp; apk update \</span><br><span class="line">    &amp;&amp; addgroup -g 101 -S nginx \</span><br><span class="line">    &amp;&amp; adduser -S -D -H -u 101 -h /var/cache/nginx -s /sbin/nologin -G nginx -g nginx nginx \</span><br><span class="line">    &amp;&amp; apk add --no-cache --allow-untrusted tzdata \</span><br><span class="line">    &amp;&amp; ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \</span><br><span class="line">    &amp;&amp; echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone \</span><br><span class="line">    &amp;&amp; /bin/rm -rf /tmp/* /var/cache/apk/*</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用docker build在x86机器上构建此ARM镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t myarmimage .</span><br><span class="line">Sending build context to Docker daemon   2.56kB</span><br><span class="line">Step 1/2 : FROM arm64v8/alpine:3.12.1</span><br><span class="line"> ---&gt; 2e77e061c27f</span><br><span class="line">Step 2/2 : RUN set -x     &amp;&amp; sed -i &#x27;s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/&#x27; /etc/apk/repositories     &amp;&amp; echo &#x27;http://mirrors.aliyun.com/alpine/edge/testing&#x27; &gt;&gt; /etc/apk/repositories     &amp;&amp; apk update     &amp;&amp; addgroup -g 101 -S nginx     &amp;&amp; adduser -S -D -H -u 101 -h /var/cache/nginx -s /sbin/nologin -G nginx -g nginx nginx     &amp;&amp; apk add --no-cache --allow-untrusted tzdata     &amp;&amp; ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime     &amp;&amp; echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone     &amp;&amp; /bin/rm -rf /tmp/* /var/cache/apk/*</span><br><span class="line"> ---&gt; Running in ffb20ef332b9</span><br><span class="line">+ sed -i s/dl-cdn.alpinelinux.org/mirrors.aliyun.com/ /etc/apk/repositories</span><br><span class="line">+ echo http://mirrors.aliyun.com/alpine/edge/testing</span><br><span class="line">+ apk update</span><br><span class="line">fetch http://mirrors.aliyun.com/alpine/v3.12/main/aarch64/APKINDEX.tar.gz</span><br><span class="line">fetch http://mirrors.aliyun.com/alpine/v3.12/community/aarch64/APKINDEX.tar.gz</span><br><span class="line">fetch http://mirrors.aliyun.com/alpine/edge/testing/aarch64/APKINDEX.tar.gz</span><br><span class="line">v3.12.1-8-ge053f6efb7 [http://mirrors.aliyun.com/alpine/v3.12/main]</span><br><span class="line">v3.12.1-5-g0954f48dc3 [http://mirrors.aliyun.com/alpine/v3.12/community]</span><br><span class="line">v20200917-2860-gaeb4459434 [http://mirrors.aliyun.com/alpine/edge/testing]</span><br><span class="line">OK: 16530 distinct packages available</span><br><span class="line">+ addgroup -g 101 -S nginx</span><br><span class="line">+ adduser -S -D -H -u 101 -h /var/cache/nginx -s /sbin/nologin -G nginx -g nginx nginx</span><br><span class="line">+ apk add --no-cache --allow-untrusted tzdata</span><br><span class="line">fetch http://mirrors.aliyun.com/alpine/v3.12/main/aarch64/APKINDEX.tar.gz</span><br><span class="line">fetch http://mirrors.aliyun.com/alpine/v3.12/community/aarch64/APKINDEX.tar.gz</span><br><span class="line">fetch http://mirrors.aliyun.com/alpine/edge/testing/aarch64/APKINDEX.tar.gz</span><br><span class="line">(1/1) Installing tzdata (2020c-r0)</span><br><span class="line">Executing busybox-1.31.1-r19.trigger</span><br><span class="line">OK: 9 MiB in 15 packages</span><br><span class="line">+ ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line">+ echo Asia/Shanghai</span><br><span class="line">+ /bin/rm -rf &#x27;/tmp/*&#x27; /var/cache/apk/APKINDEX.3a1aa0e6.tar.gz /var/cache/apk/APKINDEX.792faddc.tar.gz /var/cache/apk/APKINDEX.f46ee61c.tar.gz</span><br><span class="line">Removing intermediate container ffb20ef332b9</span><br><span class="line"> ---&gt; 181684f5ebfc</span><br><span class="line">Successfully built 181684f5ebfc</span><br><span class="line">Successfully tagged myarmimage:latest</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>  在x86机器上运行ARM格式的镜像并确认结果</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ docker images |grep myarmimage</span><br><span class="line">myarmimage                                                           latest                          181684f5ebfc        9 seconds ago       6.12MB</span><br><span class="line">$ docker run --rm -it myarmimage sh</span><br><span class="line">/ # uname -a</span><br><span class="line">Linux 2bcff8eaae37 4.9.184-linuxkit #1 SMP Tue Jul 2 22:58:16 UTC 2019 aarch64 Linux</span><br><span class="line">/ # uname -m</span><br><span class="line">aarch64</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在ARM体系结构的硬件环境中安装Docker，然后构建并运行ARM的镜像自然非常简单，但是如果没有ARM环境，只有x86的机器又想做这件事情，这时QEMU也就有了用武之地。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="DOCKER" scheme="https://rma-shuyu.github.io/categories/DOCKER/"/>
    
    
    <category term="DOCKER" scheme="https://rma-shuyu.github.io/tags/DOCKER/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu22.04安装Docker</title>
    <link href="https://rma-shuyu.github.io/2022/07/10/Ubuntu22-04%E5%AE%89%E8%A3%85Docker/"/>
    <id>https://rma-shuyu.github.io/2022/07/10/Ubuntu22-04%E5%AE%89%E8%A3%85Docker/</id>
    <published>2022-07-10T12:50:20.000Z</published>
    <updated>2023-11-12T13:43:55.360Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Docker-依赖项"><a href="#Docker-依赖项" class="headerlink" title="Docker 依赖项"></a>Docker 依赖项</h3><p>为了安装并配置 Docker ，你的系统必须满足下列最低要求：</p><ol><li> 64 位 Linux 或 Windows 系统</li><li> 如果使用 Linux ，内核版本必须不低于 3.10</li><li> 能够使用<code>sudo</code> 权限的用户</li><li> 在你系统 BIOS 上启用了 VT（虚拟化技术）支持 on your system BIOS（参考:<a href="https://ostechnix.com/how-to-find-if-a-cpu-supports-virtualization-technology-vt/">如何查看 CPU 支持 虚拟化技术（VT）</a>）</li><li> 你的系统应该联网<span id="more"></span></li></ol><p>在 Linux ，在终端上运行以下命令验证内核以及架构详细信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ uname -a</span><br></pre></td></tr></table></figure><p>输出样例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Linux Ubuntu22CT 5.15.35-3-pve #1 SMP PVE 5.15.35-6 (Fri, 17 Jun 2022 13:42:35 +0200) x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure><p>正如上面你看到的那样，我的 Ubuntu 系统内核版本是 <strong>5.15.35-3-pve</strong> 并且系统架构是 <strong>64 位</strong>（<strong>x86_64 x86_64 x86_64 GNU/Linux</strong>）。</p><blockquote><p><strong>注意：</strong> 这里，我在 <a href="https://ostechnix.com/install-proxmox-ve/">Proxmox</a> 中使用 Ubuntu 22.04 容器。这是你看到上方内核版本中有 “pve” 字符的原因。如果你正在使用 Ubuntu 实体（或者虚拟）机，你将看到系统版本为 <strong>5.15.35-3-generic</strong> 。</p></blockquote><p>内核版本需要不低于最低要求的版本，并且是 64 位机器。这样不会有任何问题，我们能顺利安装并使用 Docker 。</p><p>请注意你使用哪一个 Ubuntu 系统不重要。并且你使用 Ubuntu 桌面或服务器版本，亦或者其他 Ubuntu 变种如 Lubuntu 、Kubuntu 、Xubuntu ，都不重要。</p><p>只要你的系统内核版本不低于 3.10 ，并且是 64 位系统，Docker 都会正常运行。</p><h3 id="在-Ubuntu-22-04-LTS-中安装-Docker"><a href="#在-Ubuntu-22-04-LTS-中安装-Docker" class="headerlink" title="在 Ubuntu 22.04 LTS 中安装 Docker"></a>在 Ubuntu 22.04 LTS 中安装 Docker</h3><p>首先，更新你的 Ubuntu 系统。</p><h4 id="1、更新-Ubuntu"><a href="#1、更新-Ubuntu" class="headerlink" title="1、更新 Ubuntu"></a>1、更新 Ubuntu</h4><p>打开终端，依次运行下列命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt update</span><br><span class="line">$ sudo apt upgrade</span><br><span class="line">$ sudo apt full-upgrade</span><br></pre></td></tr></table></figure><h4 id="2、添加-Docker-库"><a href="#2、添加-Docker-库" class="headerlink" title="2、添加 Docker 库"></a>2、添加 Docker 库</h4><p>首先，安装必要的证书并允许 apt 包管理器使用以下命令通过 HTTPS 使用存储库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install apt-transport-https ca-certificates curl software-properties-common gnupg lsb-release</span><br></pre></td></tr></table></figure><p>然后，运行下列命令添加 Docker 的官方 GPG 密钥：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg</span><br></pre></td></tr></table></figure><p>添加 Docker 官方库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ echo &quot;deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable&quot; | sudo tee /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br></pre></td></tr></table></figure><p>使用命令更新 Ubuntu 源列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt update</span><br></pre></td></tr></table></figure><h4 id="3、安装-Docker"><a href="#3、安装-Docker" class="headerlink" title="3、安装 Docker"></a>3、安装 Docker</h4><p>最后，运行下列命令在 Ubuntu 22.04 LTS 服务器中安装最新 Docker CE：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><p>当然你也可以安装其他版本 Docker 。运行下列命令检查可以安装的 Docker 版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ apt-cache madison docker-ce</span><br></pre></td></tr></table></figure><p>输出样例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker-ce | 5:20.10.17~3-0~ubuntu-jammy | https://download.docker.com/linux/ubuntu jammy/stable amd64 Packages</span><br><span class="line">docker-ce | 5:20.10.16~3-0~ubuntu-jammy | https://download.docker.com/linux/ubuntu jammy/stable amd64 Packages</span><br><span class="line">docker-ce | 5:20.10.15~3-0~ubuntu-jammy | https://download.docker.com/linux/ubuntu jammy/stable amd64 Packages</span><br><span class="line">docker-ce | 5:20.10.14~3-0~ubuntu-jammy | https://download.docker.com/linux/ubuntu jammy/stable amd64 Packages</span><br><span class="line">docker-ce | 5:20.10.13~3-0~ubuntu-jammy | https://download.docker.com/linux/ubuntu jammy/stable amd64 Packages</span><br></pre></td></tr></table></figure><p>你可以挑选上面列表中的任何版本进行安装。例如，安装 <strong>5:20.10.16~ 3-0 ~ubuntu-jammy</strong> 这个版本，运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install docker-ce=5:20.10.16~3-0~ubuntu-jammy docker-ce-cli=5:20.10.16~3-0~ubuntu-jammy containerd.io</span><br></pre></td></tr></table></figure><p>安装完成后，运行如下命令验证 Docker 服务是否在运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl status docker</span><br></pre></td></tr></table></figure><p>你会看到类似下面的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">* docker.service - Docker Application Container Engine</span><br><span class="line">         Loaded: loaded (/lib/systemd/system/docker.service; enabled; vendor preset: enabled)</span><br><span class="line">         Active: active (running) since Mon 2022-06-27 13:07:43 UTC; 3min 4s ago</span><br><span class="line">    TriggeredBy: * docker.socket</span><br><span class="line">           Docs: https://docs.docker.com</span><br><span class="line">       Main PID: 2208 (dockerd)</span><br><span class="line">          Tasks: 8</span><br><span class="line">         Memory: 29.6M</span><br><span class="line">            CPU: 126ms</span><br><span class="line">         CGroup: /system.slice/docker.service</span><br><span class="line">                 `-2208 /usr/bin/dockerd -H fd:// --cnotallow=/run/containerd/containerd.sock</span><br><span class="line">    Jun 27 13:07:43 Ubuntu22CT dockerd[2208]: time=&quot;2022-06-27T13:07:43.071453522Z&quot; level=info msg=&quot;ccResolverWrapper: sending update to cc: &#123;[&#123;unix:&gt;</span><br><span class="line">    Jun 27 13:07:43 Ubuntu22CT dockerd[2208]: time=&quot;2022-06-27T13:07:43.071459974Z&quot; level=info msg=&quot;ClientConn switching balancer to \&quot;pick_first\&quot;&quot; &gt;</span><br><span class="line">    Jun 27 13:07:43 Ubuntu22CT dockerd[2208]: time=&quot;2022-06-27T13:07:43.130989294Z&quot; level=info msg=&quot;Loading containers: start.&quot;</span><br><span class="line">    Jun 27 13:07:43 Ubuntu22CT dockerd[2208]: time=&quot;2022-06-27T13:07:43.187439756Z&quot; level=info msg=&quot;Default bridge (docker0) is assigned with an IP a&gt;</span><br><span class="line">    Jun 27 13:07:43 Ubuntu22CT dockerd[2208]: time=&quot;2022-06-27T13:07:43.235966874Z&quot; level=info msg=&quot;Loading containers: done.&quot;</span><br><span class="line">    Jun 27 13:07:43 Ubuntu22CT dockerd[2208]: time=&quot;2022-06-27T13:07:43.240149866Z&quot; level=warning msg=&quot;Not using native diff for overlay2, this may c&gt;</span><br><span class="line">    Jun 27 13:07:43 Ubuntu22CT dockerd[2208]: time=&quot;2022-06-27T13:07:43.240281966Z&quot; level=info msg=&quot;Docker daemon&quot; commit=a89b842 graphdriver(s)=over&gt;</span><br><span class="line">    Jun 27 13:07:43 Ubuntu22CT dockerd[2208]: time=&quot;2022-06-27T13:07:43.240386856Z&quot; level=info msg=&quot;Daemon has completed initialization&quot;</span><br><span class="line">    Jun 27 13:07:43 Ubuntu22CT systemd[1]: Started Docker Application Container Engine.</span><br><span class="line">    Jun 27 13:07:43 Ubuntu22CT dockerd[2208]: time=&quot;2022-06-27T13:07:43.276336600Z&quot; level=info msg=&quot;API listen on /run/docker.sock&quot;</span><br></pre></td></tr></table></figure><p>好极了！Docker 服务已启动并运行！</p><p>如果没有运行，运行以下命令运行 Docker 服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure><p>使 Docker 服务在每次重启时自动启动：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl enable docker</span><br></pre></td></tr></table></figure><p>可以使用以下命令查看已安装的 Docker 版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker version</span><br></pre></td></tr></table></figure><p>输出样例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Client: Docker Engine - Community</span><br><span class="line">      Version:           20.10.17</span><br><span class="line">      API version:       1.41</span><br><span class="line">      Go version:        go1.17.11</span><br><span class="line">      Git commit:        100c701</span><br><span class="line">      Built:             Mon Jun  6 23:02:46 2022</span><br><span class="line">      OS/Arch:           linux/amd64</span><br><span class="line">      Context:           default</span><br><span class="line">      Experimental:      true</span><br><span class="line">    Server: Docker Engine - Community</span><br><span class="line">      Engine:</span><br><span class="line">        Version:          20.10.17</span><br><span class="line">        API version:      1.41 (minimum version 1.12)</span><br><span class="line">        Go version:       go1.17.11</span><br><span class="line">        Git commit:       a89b842</span><br><span class="line">      Built:            Mon Jun  6 23:00:51 2022</span><br><span class="line">        OS/Arch:          linux/amd64</span><br><span class="line">        Experimental:     false</span><br><span class="line">      containerd:</span><br><span class="line">        Version:          1.6.6</span><br><span class="line">        GitCommit:        10c12954828e7c7c9b6e0ea9b0c02b01407d3ae1</span><br><span class="line">      runc:</span><br><span class="line">        Version:          1.1.2</span><br><span class="line">        GitCommit:        v1.1.2-0-ga916309</span><br><span class="line">      docker-init:</span><br><span class="line">        Version:          0.19.0</span><br><span class="line">        GitCommit:        de40ad0</span><br></pre></td></tr></table></figure><h4 id="4、测试-Docker"><a href="#4、测试-Docker" class="headerlink" title="4、测试 Docker"></a>4、测试 Docker</h4><p>让我们继续，测试 Docker 是否运行正常：</p><p>运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run hello-world</span><br></pre></td></tr></table></figure><p>上述命令会下载一个 Docker 测试镜像，并在容器内执行一个 “hello_world” 样例程序。</p><p>如果你看到类似下方的输出，那么祝贺你！Docker 正常运行在你的 Ubuntu 系统中了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Unable to find image &#x27;hello-world:latest&#x27; locally</span><br><span class="line">    latest: Pulling from library/hello-world</span><br><span class="line">    2db29710123e: Pull complete </span><br><span class="line">    Digest: sha256:13e367d31ae85359f42d637adf6da428f76d75dc9afeb3c21faea0d976f5c651</span><br><span class="line">    Status: Downloaded newer image for hello-world:latest</span><br><span class="line">    Hello from Docker!</span><br><span class="line">    This message shows that your installation appears to be working correctly.</span><br><span class="line">    To generate this message, Docker took the following steps:</span><br><span class="line">     1. The Docker client contacted the Docker daemon.</span><br><span class="line">     2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class="line">        (amd64)</span><br><span class="line">     3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">        executable that produces the output you are currently reading.</span><br><span class="line">     4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">        to your terminal.</span><br><span class="line">    To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line">     $ docker run -it ubuntu bash</span><br><span class="line">    Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line">     https://hub.docker.com/</span><br><span class="line">    For more examples and ideas, visit:</span><br><span class="line">     https://docs.docker.com/get-started/</span><br></pre></td></tr></table></figure><p>很好！可以使用 Docker 了。</p><h4 id="5、作为非-root-用户运行-Docker-（选做）"><a href="#5、作为非-root-用户运行-Docker-（选做）" class="headerlink" title="5、作为非 root 用户运行 Docker （选做）"></a>5、作为非 root 用户运行 Docker （选做）</h4><p>默认情况下，Docker 守护进程绑定到 Unix 套接字而不是 TCP 端口。由于 <strong>Unix 套接字由 root 用户拥有</strong>，Docker 守护程序将仅以 root 用户身份运行。因此，普通用户无法执行大多数 Docker 命令。</p><p>如果你想要在 Linux 中作为非 root 用户运行 Docker ，参考下方链接：</p><ul><li>  <a href="https://ostechnix.com/how-to-run-docker-as-non-root-user-in-linux/">如何在 Linux 中作为非 root 用户运行 Docker</a></li></ul><p>我个人不这样做也<strong>不推荐</strong>你这么做。如果你不会在互联网上暴露你的系统，那没问题。然而，不要在生产系统中以非 root 用户身份运行 Docker 。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Docker-依赖项&quot;&gt;&lt;a href=&quot;#Docker-依赖项&quot; class=&quot;headerlink&quot; title=&quot;Docker 依赖项&quot;&gt;&lt;/a&gt;Docker 依赖项&lt;/h3&gt;&lt;p&gt;为了安装并配置 Docker ，你的系统必须满足下列最低要求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt; 64 位 Linux 或 Windows 系统&lt;/li&gt;
&lt;li&gt; 如果使用 Linux ，内核版本必须不低于 3.10&lt;/li&gt;
&lt;li&gt; 能够使用&lt;code&gt;sudo&lt;/code&gt; 权限的用户&lt;/li&gt;
&lt;li&gt; 在你系统 BIOS 上启用了 VT（虚拟化技术）支持 on your system BIOS（参考:&lt;a href=&quot;https://ostechnix.com/how-to-find-if-a-cpu-supports-virtualization-technology-vt/&quot;&gt;如何查看 CPU 支持 虚拟化技术（VT）&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt; 你的系统应该联网&lt;/li&gt;&lt;/ol&gt;</summary>
    
    
    
    <category term="DOCKER" scheme="https://rma-shuyu.github.io/categories/DOCKER/"/>
    
    
    <category term="DOCKER" scheme="https://rma-shuyu.github.io/tags/DOCKER/"/>
    
  </entry>
  
  <entry>
    <title>pkg-config</title>
    <link href="https://rma-shuyu.github.io/2022/07/09/pkg-config/"/>
    <id>https://rma-shuyu.github.io/2022/07/09/pkg-config/</id>
    <published>2022-07-09T12:50:20.000Z</published>
    <updated>2023-11-12T13:43:55.363Z</updated>
    
    <content type="html"><![CDATA[<h2 id="pkg-config简介"><a href="#pkg-config简介" class="headerlink" title="pkg-config简介"></a>pkg-config简介</h2><p><code>pkg-config</code>在编译应用程序和库的时候作为一个工具来使用。例如你在命令行通过如下命令编译程序时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># gcc -o test test.c `pkg-config --libs --cflags glib-2.0`</span><br></pre></td></tr></table></figure><span id="more"></span><p>pkg-config可以帮助你插入正确的编译选项，而不需要你通过硬编码的方式来找到glib(或其他库）。</p><p><code>--cflags</code>一般用于指定头文件，<code>--libs</code>一般用于指定库文件。</p><p>大家应该都知道一般用第三方库的时候，就少不了要使用到第三方的头文件和库文件。我们在编译、链接的时候，必须要指定这些头文件和库文件的位置。对于一个比较大的第三方库，其头文件和库文件的数量是比较多的，如果我们一个个手动地写，那将是相当的麻烦的。因此，pkg-config就应运而生了。pkg-config能够把这些头文件和库文件的位置指出来，给编译器使用。pkg-config主要提供了下面几个功能：</p><ul><li>  检查库的版本号。 如果所需要的库的版本不满足要求，它会打印出错误信息，避免链接错误版本的库文件</li><li>  获得编译预处理参数，如宏定义、头文件的位置</li><li>  获得链接参数，如库及依赖的其他库的位置，文件名及其他一些链接参数</li><li>  自动加入所依赖的其他库的设置</li></ul><p>pkg-config命令的基本用法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># pkg-config &lt;options&gt; &lt;library-name&gt;</span><br></pre></td></tr></table></figure><p>例如，我们可以通过如下命令来查看当前安装了哪些库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost pkgconfig]# pkg-config --list-all</span><br><span class="line">zlib                      zlib - zlib compression library</span><br><span class="line">gio-unix-2.0              GIO unix specific APIs - unix specific headers for glib I/O library</span><br><span class="line">inputproto                InputProto - Input extension headers</span><br><span class="line">cairo-xcb                 cairo-xcb - XCB surface backend for cairo graphics library</span><br><span class="line">gio-2.0                   GIO - glib I/O library</span><br><span class="line">//后续省略</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>事实上，pkg-config只是一个工具，所以不是你安装了一个第三方库，pkg-config就能知道第三方库的头文件和库文件的位置的。为了让pkg-config可以得到一个库的信息，就要求库的提供者提供一个.pc文件。默认情况下，比如执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># pkg-config --libs --cflags glib-2.0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>pkg-config会到<code>/usr/lib/pkconfig/</code>目录下去寻找glib-2.0.pc文件。也就是说在此目录下的.pc文件，pkg-config是可以自动找到的。然而假如我们安装了一个库，其生成的.pc文件并不在这个默认目录中的话，pkg-config就找不到了。此时我们需要通过<code>PKG_CONFIG_PATH</code>环境变量来指定pkg-config还应该在哪些地方去寻找.pc文件。</p><p>我们可以通过如下命令来设置<code>PKG_CONFIG_PATH</code>环境变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># export PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig/</span><br></pre></td></tr></table></figure><p>这样pkg-config就会在/usr/local/lib/pkgconfig/目录下寻找.pc文件了。我们在文章开头提到的找不到Leptonica 1.74.4的原因也正是因为其找不到lept.pc，因此我们只需要将对应的目录设置到PKG_CONFIG_PATH环境变量中即可。</p><p>另外还需要注意的是,上述环境变量的设置只对当前的终端窗口有效。为了让其永久生效，我们可以将上述命令写入到/etc/bash.bashrc等文件中，以方便后续使用。</p><h2 id="pkg-config与LD-LIBRARY-PATH"><a href="#pkg-config与LD-LIBRARY-PATH" class="headerlink" title="pkg-config与LD_LIBRARY_PATH"></a>pkg-config与LD_LIBRARY_PATH</h2><p>pkg-config与LD_LIBRARY_PATH在使用时有些类似，都可以帮助找到对应的库（静态库和共享库）。这里我们重点介绍一下它们两者的区别。我们知道一个程序从源代码，然后编译连接，最后再执行这一基本过程。这里我们列出pkg-config与LD_LIBRARY_PATH的主要工作阶段：</p><ul><li>  pkg-config: 编译时、 链接时</li><li>  LD_LIBRARY_PATH: 链接时、 运行时</li></ul><p>pkg-config主要是在编译时会用到其来查找对应的头文件、链接库等；而LD_LIBRARY_PATH环境变量则在 链接时 和 运行时 会用到。程序编译出来之后，在程序加载执行时也会通过LD_LIBRARY_PATH环境变量来查询所需要的库文件。</p><p>下面我们来讲述一下LD_LIBRARY_PATH及ldconfig命令：</p><p>库文件在链接（静态库和共享库）和运行（仅限于使用共享库的程序）时被使用，其搜索路径是在系统中进行设置的。一般Linux系统把/lib和/usr/lib这两个目录作为默认的库搜索路径，所以使用这两个目录中的库时不需要进行设置搜索路径即可直接使用。对于处于默认库搜索路径之外的库，需要将库的位置添加到库的搜索路径之中。设置库文件的搜索路径有下列两种方式，可任选其中一种使用：</p><ul><li>  在环境变量LD_LIBRARY_PATH中指明库的搜索路径</li><li>  在/etc/ld.so.conf文件中添加库的搜索路径</li></ul><p>将自己可能存放库文件的路径都加入到/etc/ld.so.conf中是明智的选择。添加方法也及其简单，将库文件的绝对路径直接写进去就OK了，一行一个。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/usr/X11R6/lib</span><br><span class="line">/usr/local/lib</span><br><span class="line">/opt/lib</span><br></pre></td></tr></table></figure><p>需要注意的是：第二种搜索路径的设置方式对于程序链接时的库（包括共享库和静态库）的定位已经足够了。但是对于使用了共享库的程序的执行还是不够的，这是因为为了加快程序执行时对共享库的定位速度，避免使用搜索路径查找共享库的低效率，所以是直接读取库列表文件/etc/ld.so.cache的方式从中进行搜索。/etc/ld.so.cache是一个非文本的数据文件，不能直接编辑，它是根据/etc/ld.so.conf中设置的搜索路径由/sbin/ldconfig命令将这些搜索路径下的共享库文件集中在一起而生成的（ldconfig命令要以root权限执行）。因此为了保证程序执行时对库的定位，在/etc/ld.so.conf中进行了库搜索路径的设置之后，还必须要运行/sbin/ldconfig命令更新/etc/ld.so.cache文件之后才可以。</p><p>ldconfig，简单的说，它的作用就是将/etc/ld.so.conf列出的路径下的库文件缓存到/etc/ld.so.cache以供使用。因此当安装完一些库文件（例如刚安装好glib)，或者修改ld.so.conf增加新的库路径之后，需要运行一下/sbin/ldconfig使所有的库文件都被缓存到ld.so.cache中。如果没有这样做，即使库文件明明就在/usr/lib下的，也是不会被使用的，结果在编译过程中报错。</p><p>在程序链接时，对于库文件（静态库和共享库）的搜索路径，除了上面的设置方式之外，还可以通过-L参数显示指定。因为用-L设置的路径将被优先搜索，所以在链接的时候通常都会以这种方式直接指定要链接的库的路径。</p><p>前面已经说明过了，库搜索路径的设置有两种方式：在环境变量 LD_LIBRARY_PATH 中设置以及在 /etc/ld.so.conf 文件中设置。其中，第二种设置方式需要 root 权限，以改变 /etc/ld.so.conf 文件并执行 /sbin/ldconfig 命令。而且，当系统重新启动后，所有的基于 GTK2 的程序在运行时都将使用新安装的 GTK+ 库。不幸的是，由于 GTK+ 版本的改变，这有时会给应用程序带来兼容性的问题，造成某些程序运行不正常。为了避免出现上面的这些情况，在 GTK+ 及其依赖库的安装过程中对于库的搜索路径的设置将采用第一种方式进行。这种设置方式不需要 root 权限，设置也简单：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># export LD_LIBRARY_PATH=/opt/gtk/lib:$LD_LIBRARY_PATH</span><br><span class="line"></span><br><span class="line"># echo $LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure><h2 id="pc文件书写规范"><a href="#pc文件书写规范" class="headerlink" title="pc文件书写规范"></a>pc文件书写规范</h2><p>这里我们首先来看一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost pkgconfig]# cat libevent.pc </span><br><span class="line">#libevent pkg-config source file</span><br><span class="line"></span><br><span class="line">prefix=/usr/local</span><br><span class="line">exec_prefix=$&#123;prefix&#125;</span><br><span class="line">libdir=$&#123;exec_prefix&#125;/lib</span><br><span class="line">includedir=$&#123;prefix&#125;/include</span><br><span class="line"></span><br><span class="line">Name: libevent</span><br><span class="line">Description: libevent is an asynchronous notification event loop library</span><br><span class="line">Version: 2.0.22-stable</span><br><span class="line">Requires:</span><br><span class="line">Conflicts:</span><br><span class="line">Libs: -L$&#123;libdir&#125; -levent</span><br><span class="line">Libs.private: </span><br><span class="line">Cflags: -I$&#123;includedir&#125;</span><br></pre></td></tr></table></figure><p>这是libevent库的一个真实的例子。下面我们简单描述一下pc文件中的用到的一些关键词：</p><ul><li>  Name: 一个针对library或package的便于人阅读的名称。这个名称可以是任意的，它并不会影响到pkg-config的使用，pkg-config是采用pc文件名的方式来工作的。</li><li>  Description: 对package的简短描述</li><li>  URL: 人们可以通过该URL地址来获取package的更多信息或者package的下载地址</li><li>  Version: 指定package版本号的字符串</li><li>  Requires: 本库所依赖的其他库文件。所依赖的库文件的版本号可以通过使用如下比较操作符指定：=,&lt;,&gt;,&lt;=,&gt;=</li><li>  Requires.private: 本库所依赖的一些私有库文件，但是这些私有库文件并不需要暴露给应用程序。这些私有库文件的版本指定方式与Requires中描述的类似。</li><li>  Conflicts: 是一个可选字段，其主要用于描述与本package所冲突的其他package。版本号的描述也与Requires中的描述类似。本字段也可以取值为同一个package的多个不同版本实例。例如: Conflicts: bar &lt; 1.2.3, bar &gt;= 1.3.0</li><li>  Cflags: 编译器编译本package时所指定的编译选项，和其他并不支持pkg-config的library的一些编译选项值。假如所需要的library支持pkg-config,则它们应该被添加到Requires或者Requires.private中</li><li>  Libs: 链接本库时所需要的一些链接选项，和其他一些并不支持pkg-config的library的链接选项值。与Cflags类似</li><li>  Libs.private: 本库所需要的一些私有库的链接选项。</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>如下我们给出一个使用pkg-config的程序例子(test_event.cpp)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;  </span><br><span class="line">#include &lt;event.h&gt;  </span><br><span class="line">#include &lt;sys/socket.h&gt;  </span><br><span class="line">#include &lt;sys/types.h&gt;  </span><br><span class="line">#include &lt;netinet/in.h&gt;  </span><br><span class="line">#include &lt;string.h&gt;  </span><br><span class="line">#include &lt;fcntl.h&gt;  </span><br><span class="line">  </span><br><span class="line">using namespace std;  </span><br><span class="line">  </span><br><span class="line">struct event_base* main_base;  </span><br><span class="line">  </span><br><span class="line">static const char MESSAGE[] =&quot;Hello, World!\n&quot;;  </span><br><span class="line">  </span><br><span class="line">void accept_handle(const int sfd, const short event, void *arg)  </span><br><span class="line">&#123;  </span><br><span class="line">    cout&lt;&lt;&quot;accept handle&quot;&lt;&lt;endl;  </span><br><span class="line">  </span><br><span class="line">    struct sockaddr_in addr;  </span><br><span class="line">  </span><br><span class="line">    socklen_t addrlen = sizeof(addr);  </span><br><span class="line">  </span><br><span class="line">    int fd = accept(sfd, (struct sockaddr *) &amp;addr, &amp;addrlen); //处理连接  </span><br><span class="line">  </span><br><span class="line">    struct bufferevent* buf_ev;  </span><br><span class="line">    buf_ev = bufferevent_new(fd, NULL, NULL, NULL, NULL);  </span><br><span class="line">  </span><br><span class="line">    buf_ev-&gt;wm_read.high = 4096;  </span><br><span class="line">  </span><br><span class="line">    cout&lt;&lt;&quot;event write&quot;&lt;&lt;endl;  </span><br><span class="line">    bufferevent_write(buf_ev, MESSAGE, strlen(MESSAGE));  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">    cout&lt;&lt;&quot;hello man!&quot;&lt;&lt;endl;  </span><br><span class="line">  </span><br><span class="line">    // 1. 初始化EVENT  </span><br><span class="line">    main_base = event_init();  </span><br><span class="line">    if(main_base)  </span><br><span class="line">        cout&lt;&lt;&quot;init event ok!&quot;&lt;&lt;endl;  </span><br><span class="line">  </span><br><span class="line">    // 2. 初始化SOCKET  </span><br><span class="line">    int sListen;  </span><br><span class="line">  </span><br><span class="line">    // Create listening socket  </span><br><span class="line">    sListen = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);  </span><br><span class="line">  </span><br><span class="line">    // Bind  </span><br><span class="line">    struct sockaddr_in server_addr;  </span><br><span class="line">    bzero(&amp;server_addr,sizeof(struct sockaddr_in));  </span><br><span class="line">    server_addr.sin_family=AF_INET;  </span><br><span class="line">    server_addr.sin_addr.s_addr=htonl(INADDR_ANY);  </span><br><span class="line">    int portnumber = 8080;  </span><br><span class="line">    server_addr.sin_port = htons(portnumber);  </span><br><span class="line">  </span><br><span class="line">    /* 捆绑sockfd描述符  */  </span><br><span class="line">    if(bind(sListen,(struct sockaddr *)(&amp;server_addr),sizeof(struct sockaddr))==-1)  </span><br><span class="line">    &#123;  </span><br><span class="line">        cout&lt;&lt;&quot;error!&quot;&lt;&lt;endl;  </span><br><span class="line">        return -1;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    // Listen  </span><br><span class="line">    ::listen(sListen, 3);  </span><br><span class="line">    cout&lt;&lt;&quot;Server is listening!\n&quot;&lt;&lt;endl;  </span><br><span class="line">  </span><br><span class="line">    /*将描述符设置为非阻塞*/  </span><br><span class="line">    int flags = ::fcntl(sListen, F_GETFL);  </span><br><span class="line">  </span><br><span class="line">    flags |= O_NONBLOCK;  </span><br><span class="line">  </span><br><span class="line">    fcntl(sListen, F_SETFL, flags);  </span><br><span class="line">  </span><br><span class="line">    // 3. 创建EVENT 事件  </span><br><span class="line">    struct event ev;  </span><br><span class="line">    event_set(&amp;ev, sListen, EV_READ | EV_PERSIST, accept_handle, (void *)&amp;ev);  </span><br><span class="line">  </span><br><span class="line">    // 4. 事件添加与删除  </span><br><span class="line">    event_add(&amp;ev, NULL);  </span><br><span class="line">  </span><br><span class="line">    // 5. 进入事件循环  </span><br><span class="line">    event_base_loop(main_base, 0);  </span><br><span class="line">  </span><br><span class="line">    cout&lt;&lt;&quot;over!&quot;&lt;&lt;endl;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行如下命令编译程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># gcc -o test_event test_event.cpp -lstdc++ `pkg-config --cflags --libs libevent`</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test-src]# ./test_event </span><br><span class="line">hello man!</span><br><span class="line">init event ok!</span><br><span class="line">Server is listening!</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>开启另外一个终端，采用nc命令连接test_event服务端程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# nc 127.0.0.1 8080</span><br><span class="line">Hello, World!</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到运行成功。</p><h2 id="Linux下链接库的路径顺序"><a href="#Linux下链接库的路径顺序" class="headerlink" title="Linux下链接库的路径顺序"></a>Linux下链接库的路径顺序</h2><h3 id="6-1-运行时链接库的搜索顺序"><a href="#6-1-运行时链接库的搜索顺序" class="headerlink" title="6.1 运行时链接库的搜索顺序"></a>6.1 运行时链接库的搜索顺序</h3><p>Linux程序在运行时对动态链接库的搜索顺序如下：</p><p>1） 在编译目标代码时所传递的动态库搜索路径（注意，这里指的是通过<code>-Wl,rpath=&lt;path1&gt;:&lt;path2&gt;</code>或<code>-R</code>选项传递的运行时动态库搜索路径，而不是通过<code>-L</code>选项传递的）</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># gcc -Wl,-rpath,/home/arc/test,-rpath,/lib/,-rpath,/usr/lib/,-rpath,/usr/local/lib test.c</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"># gcc -Wl,-rpath=/home/arc/test:/lib/:/usr/lib/:/usr/local/lib test.c</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2） 环境变量<code>LD_LIBRARY_PATH</code>指定的动态库搜索路径；</p><p>3） 配置文件/etc/ld.so.conf中所指定的动态库搜索路径(更改/etc/ld.so.conf之后，一定要执行命令ldconfig，该命令会将/etc/ld.so.conf文件中所有路径下的库载入内存）;</p><p>4） 默认的动态库搜索路径/lib；</p><p>5） 默认的动态库搜索路径/usr/lib;</p><h3 id="6-2-编译时与运行时动态库查找的比较"><a href="#6-2-编译时与运行时动态库查找的比较" class="headerlink" title="6.2 编译时与运行时动态库查找的比较"></a>6.2 编译时与运行时动态库查找的比较</h3><p>下面是对编译时库的查找与运行时库的查找做一个简单的比较：</p><ol><li><p>编译时查找的是静态库或动态库， 而运行时，查找的是动态库；</p></li><li><p>编译时可以用<code>-L</code>指定查找路径，或者用环境变量<code>LIBRARY_PATH</code>， 而运行时可以用<code>-Wl,rpath</code>或者<code>-R</code>选项，或者修改/etc/ld.so.conf，或者设置环境变量<code>LD_LIBRARY_PATH</code>;</p></li><li><p>编译时用的链接器是<code>ld</code>，而运行时用的链接器是<code>/lib/ld-linux.so.2</code></p></li><li><p>编译时与运行时都会查找默认路径/lib、/usr/lib</p></li><li><p>编译时还有一个默认路径/usr/local/lib，而运行时不会默认查找该路径；</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">说明： -Wl,rpath选项虽然是在编译时传递的，但是其实是工作在运行时。其本身其实也不算是gcc的一个选项，而是ld的选项，gcc只不过</span><br><span class="line">      是一个包装器而已。我们可以执行man ld来进一步了解相关信息</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-3-补充-gcc使用-Wl-rpath"><a href="#6-3-补充-gcc使用-Wl-rpath" class="headerlink" title="6.3 补充:gcc使用-Wl,-rpath"></a>6.3 补充:gcc使用-Wl,-rpath</h3><ol><li><strong>-Wl,-rpath</strong></li></ol><p>加上<code>-Wl,-rpath</code>选项的作用就是指定<code>程序运行时</code>的库搜索目录，是一个链接选项，生效于设置的环境变量之前(LD_LIBRARY_PATH)。下面我们通过一个例子来说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// add.h</span><br><span class="line">int add(int i, int j);</span><br><span class="line"> </span><br><span class="line">// add.c</span><br><span class="line">#include &quot;add.h&quot;</span><br><span class="line"> </span><br><span class="line">int add(int i, int j)</span><br><span class="line">&#123;</span><br><span class="line">return i + j;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// main.c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &quot;add.h&quot;</span><br><span class="line"> </span><br><span class="line">int main(int argc, char *argv[]) </span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;1 + 2 = %d\n&quot;, add(1, 2));</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>add.h</code>和<code>add.c</code>用于生成一个so库，实现了一个简单的加法，main.c中引用共享库计算1 + 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 编译共享库</span><br><span class="line">gcc add.c -fPIC -shared -o libadd.so</span><br><span class="line"># 编译主程序</span><br><span class="line">gcc main.o -L. -ladd -o app</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>编译好后运行依赖库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># ldd app</span><br><span class="line">linux-vdso.so.1 (0x00007ffeb23ab000)</span><br><span class="line">libadd.so =&gt; not found</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007febb7dd0000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007febb83d0000</span><br><span class="line"># ./app</span><br><span class="line">./app: error while loading shared libraries: libadd.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p>可以看到， <code>libadd.so</code>这个库没有找到，程序也无法运行，要运行它必须要把当前目录添加到环境变量或者搜索路径中去。但是如果在链接时加上<code>-Wl,rpath</code>选项之后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># gcc -c -o main.o main.c</span><br><span class="line"># gcc -Wl,-rpath=`pwd` main.o -L. -ladd -o app</span><br><span class="line"># ldd app</span><br><span class="line">linux-vdso.so.1 (0x00007fff8f4e3000)</span><br><span class="line">libadd.so =&gt; /data/code/c/1-sys/solib/libadd.so (0x00007faef8428000)</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007faef8030000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007faef8838000)</span><br><span class="line"># ./app</span><br><span class="line">1 + 2 = 3</span><br></pre></td></tr></table></figure><p>依赖库的查找路径就找到了，程序能正常运行。</p><p>下面我们再来看一下生成的可执行文件<code>app</code>，执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#  readelf app -d</span><br><span class="line"></span><br><span class="line">Dynamic section at offset 0xe08 contains 26 entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line"> 0x0000000000000001 (NEEDED)             Shared library: [libadd.so]</span><br><span class="line"> 0x0000000000000001 (NEEDED)             Shared library: [libc.so.6]</span><br><span class="line"> 0x000000000000000f (RPATH)              Library rpath: [/root/test]</span><br><span class="line"> 0x000000000000000c (INIT)               0x400578</span><br><span class="line"> 0x000000000000000d (FINI)               0x400784</span><br><span class="line"> 0x0000000000000019 (INIT_ARRAY)         0x600df0</span><br><span class="line"> 0x000000000000001b (INIT_ARRAYSZ)       8 (bytes)</span><br><span class="line"> 0x000000000000001a (FINI_ARRAY)         0x600df8</span><br><span class="line"> 0x000000000000001c (FINI_ARRAYSZ)       8 (bytes)</span><br><span class="line"> 0x000000006ffffef5 (GNU_HASH)           0x400298</span><br><span class="line"> 0x0000000000000005 (STRTAB)             0x400408</span><br><span class="line"> 0x0000000000000006 (SYMTAB)             0x4002d0</span><br><span class="line"> 0x000000000000000a (STRSZ)              189 (bytes)</span><br><span class="line"> 0x000000000000000b (SYMENT)             24 (bytes)</span><br><span class="line"> 0x0000000000000015 (DEBUG)              0x0</span><br><span class="line"> 0x0000000000000003 (PLTGOT)             0x601000</span><br><span class="line"> 0x0000000000000002 (PLTRELSZ)           96 (bytes)</span><br><span class="line"> 0x0000000000000014 (PLTREL)             RELA</span><br><span class="line"> 0x0000000000000017 (JMPREL)             0x400518</span><br><span class="line"> 0x0000000000000007 (RELA)               0x400500</span><br><span class="line"> 0x0000000000000008 (RELASZ)             24 (bytes)</span><br><span class="line"> 0x0000000000000009 (RELAENT)            24 (bytes)</span><br><span class="line"> 0x000000006ffffffe (VERNEED)            0x4004e0</span><br><span class="line"> 0x000000006fffffff (VERNEEDNUM)         1</span><br><span class="line"> 0x000000006ffffff0 (VERSYM)             0x4004c6</span><br><span class="line"> 0x0000000000000000 (NULL)               0x0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到是在编译后的程序中包含了库的搜索路径。</p><ol start="2"><li><strong>-Wl,rpath-link</strong></li></ol><p><code>-Wl,rpath-link</code>是设置编译链接时候的顺序，例如app运行依赖libadd.so，但是libadd.so又依赖libadd_ex.so，<code>rpath-link</code>就是指定libadd_ex.so的路径。和<code>-Wl,rpath</code>相比工作的时间不同，一个在链接期间，一个在运行期间。</p><h2 id="gcc编译头文件查找路径"><a href="#gcc编译头文件查找路径" class="headerlink" title="gcc编译头文件查找路径"></a>gcc编译头文件查找路径</h2><p>关于gcc编译时的查找路径，<a href="http://gcc.gnu.org/onlinedocs/cpp/Search-Path.html">GCC The C Preprocessor: Search Path</a>描述的比较清楚，我在这里将其复制出来：</p><p>By default, the preprocessor looks for header files included by the quote form of the directive #include “file” first relative to the directory of the current file, and then in a preconfigured list of standard system directories. For example, if /usr/include/sys/stat.h contains #include “types.h”, GCC looks for types.h first in /usr/include/sys, then in its usual search path.</p><p>For the angle-bracket form #include , the preprocessor’s default behavior is to look only in the standard system directories. The exact search directory list depends on the target system, how GCC is configured, and where it is installed. You can find the default search directory list for your version of CPP by invoking it with the -v option. For example,</p><p>cpp -v /dev/null -o /dev/null There are a number of command-line options you can use to add additional directories to the search path. The most commonly-used option is -Idir, which causes dir to be searched after the current directory (for the quote form of the directive) and ahead of the standard system directories. You can specify multiple -I options on the command line, in which case the directories are searched in left-to-right order.</p><p>If you need separate control over the search paths for the quote and angle-bracket forms of the ‘#include’ directive, you can use the -iquote and/or -isystem options instead of -I. See Invocation, for a detailed description of these options, as well as others that are less generally useful.</p><p>If you specify other options on the command line, such as -I, that affect where the preprocessor searches for header files, the directory list printed by the -v option reflects the actual search path used by the preprocessor.</p><p>Note that you can also prevent the preprocessor from searching any of the default system header directories with the -nostdinc option. This is useful when you are compiling an operating system kernel or some other program that does not use the standard C library facilities, or the standard C library itself.</p><p>除此之外，我们还可以通过相应的环境变量来指定头文件的搜索路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export C_INCLUDE_PATH=XXXX:$C_INCLUDE_PATH</span><br><span class="line">export CPLUS_INCLUDE_PATH=XXX:$CPLUS_INCLUDE_PATH</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以将以上代码添加到/etc/profile末尾。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;pkg-config简介&quot;&gt;&lt;a href=&quot;#pkg-config简介&quot; class=&quot;headerlink&quot; title=&quot;pkg-config简介&quot;&gt;&lt;/a&gt;pkg-config简介&lt;/h2&gt;&lt;p&gt;&lt;code&gt;pkg-config&lt;/code&gt;在编译应用程序和库的时候作为一个工具来使用。例如你在命令行通过如下命令编译程序时：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# gcc -o test test.c `pkg-config --libs --cflags glib-2.0`&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="LINUX" scheme="https://rma-shuyu.github.io/categories/LINUX/"/>
    
    
    <category term="pkg-config" scheme="https://rma-shuyu.github.io/tags/pkg-config/"/>
    
  </entry>
  
  <entry>
    <title>Clash配置allow lan</title>
    <link href="https://rma-shuyu.github.io/2022/07/07/Trojan%E9%85%8D%E7%BD%AEallow-lan/"/>
    <id>https://rma-shuyu.github.io/2022/07/07/Trojan%E9%85%8D%E7%BD%AEallow-lan/</id>
    <published>2022-07-07T11:55:44.000Z</published>
    <updated>2023-11-12T13:43:55.360Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Clash for Windows 是基于 <a href="https://github.com/Dreamacro/clash">Clash Core</a> 开发的 Windows 平台代理工具，支持 Shadowsocks(R) / V2Ray / Trojan / Socks5 / HTTP(S) 等代理协议，支持策略组及规则分流。</p><span id="more"></span><blockquote><p>下载地址： <a href="https://github.com/Fndroid/clash_for_windows_pkg/releases">Github Releases</a> </p><p>第一次使用？查看 <a href="https://docs.cfw.lbyczf.com/contents/quickstart.html">快速上手</a></p></blockquote><p>在配置好 Clash for Windows（下文略称为 CFW ）后，我们可以考虑开启 <code>Allow LAN</code> （局域网代理共享），以便处于同一局域网内的其他设备接入到本机代理环境中。这不仅可以节省在多台设备中重复部署代理软件的时间，同时也可以通过 CFW 内置的 Connections 对局域网内设备的网络情况实时地管理与监控。</p><p>具体方法如下：</p><h2 id="Clash-for-Windows-设置方法"><a href="#Clash-for-Windows-设置方法" class="headerlink" title="Clash for Windows 设置方法"></a>Clash for Windows 设置方法</h2><p>启动 CFW 后，在 General 设置中点击 General YAML 选项，将 Profile 中的 <code>allow-lan</code> 值设置为 <code>true</code> ，随后保存并关闭配置文件窗口。最终效果如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># HTTP 端口</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">7890</span></span><br><span class="line"><span class="comment"># Socks 5 端口</span></span><br><span class="line"><span class="attr">socks-port:</span> <span class="number">7891</span></span><br><span class="line"><span class="comment"># 局域网代理共享</span></span><br><span class="line"><span class="attr">allow-lan:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>此时，我们已经开启 CFW 的局域网代理共享，且可以在 General 设置中看到 Allow LAN 为启动状态。</p><p>将鼠标悬浮于 Allow LAN 选项上，可以显示此时 Windows 的内网 IP 地址。</p><p><img src="de169eeb984388932b8ac7e0974a26f80fe2795ddf4fa028bc965fd14984079f.png" alt="picture 0">  </p><p>这里需要关闭电脑端的防火墙</p><h2 id="端口被封，如何解决"><a href="#端口被封，如何解决" class="headerlink" title="端口被封，如何解决"></a>端口被封，如何解决</h2><p>就我目前使用来看，trojan最多被封端口，ip好像没有太大问题。上面哪些方法懒得搞，直接一条iptables解决问题 。<br>在VPS上执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 将40000~50000的端口流量转发到443端口</span><br><span class="line">iptables -t nat -A PREROUTING -p tcp --dport 40000:50000 -j REDIRECT --to-ports 443</span><br></pre></td></tr></table></figure><p>使用nat转发流量，在本机上是不会监听端口的，也就是netstat看不到。<br>执行之后就可以客户端使用40000至50000的任意端口和trojan通信了。</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p><strong>wsl配置proxy.sh</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">MY_PROXY_URL=&quot;http://172.19.96.1:7890&quot;</span><br><span class="line"> </span><br><span class="line">HTTP_PROXY=$MY_PROXY_URL</span><br><span class="line">HTTPS_PROXY=$MY_PROXY_URL</span><br><span class="line">FTP_PROXY=$MY_PROXY_URL</span><br><span class="line">http_proxy=$MY_PROXY_URL</span><br><span class="line">https_proxy=$MY_PROXY_URL</span><br><span class="line">ftp_proxy=$MY_PROXY_URL</span><br><span class="line"> </span><br><span class="line">export HTTP_PROXY HTTPS_PROXY FTP_PROXY http_proxy https_proxy ftp_proxy</span><br></pre></td></tr></table></figure><p>source一下proxy.sh即可开启端口代理</p><p><strong>wsl配置unproxy.sh</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line"> </span><br><span class="line">unset HTTP_PROXY HTTPS_PROXY FTP_PROXY http_proxy https_proxy ftp_proxy</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>source一下unproxy.sh即可关闭端口代理</p><p><strong>内网服务器配置proxy.sh</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">MY_PROXY_URL=&quot;http://10.20.19.191:7890&quot;</span><br><span class="line"> </span><br><span class="line">HTTP_PROXY=$MY_PROXY_URL</span><br><span class="line">HTTPS_PROXY=$MY_PROXY_URL</span><br><span class="line">FTP_PROXY=$MY_PROXY_URL</span><br><span class="line">http_proxy=$MY_PROXY_URL</span><br><span class="line">https_proxy=$MY_PROXY_URL</span><br><span class="line">ftp_proxy=$MY_PROXY_URL</span><br><span class="line"> </span><br><span class="line">export HTTP_PROXY HTTPS_PROXY FTP_PROXY http_proxy https_proxy ftp_proxy</span><br></pre></td></tr></table></figure><p>source一下proxy.sh即可开启端口代理</p><p><strong>内网服务器配置unproxy.sh</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line"> </span><br><span class="line">unset HTTP_PROXY HTTPS_PROXY FTP_PROXY http_proxy https_proxy ftp_proxy</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>source一下unproxy.sh即可关闭端口代理</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Clash for Windows 是基于 &lt;a href=&quot;https://github.com/Dreamacro/clash&quot;&gt;Clash Core&lt;/a&gt; 开发的 Windows 平台代理工具，支持 Shadowsocks(R) / V2Ray / Trojan / Socks5 / HTTP(S) 等代理协议，支持策略组及规则分流。&lt;/p&gt;</summary>
    
    
    
    <category term="Trojan" scheme="https://rma-shuyu.github.io/categories/Trojan/"/>
    
    
    <category term="Trojan" scheme="https://rma-shuyu.github.io/tags/Trojan/"/>
    
  </entry>
  
  <entry>
    <title>Trojan搭建</title>
    <link href="https://rma-shuyu.github.io/2022/07/06/Trojan%E6%90%AD%E5%BB%BA/"/>
    <id>https://rma-shuyu.github.io/2022/07/06/Trojan%E6%90%AD%E5%BB%BA/</id>
    <published>2022-07-06T11:55:44.000Z</published>
    <updated>2023-10-21T07:21:41.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-Trojan"><a href="#什么是-Trojan" class="headerlink" title="什么是 Trojan"></a>什么是 Trojan</h2><p>Trojan将流量伪装成用户正常访问网页时的HTTPS流量，防止流量被检测和干扰。</p><span id="more"></span><h2 id="搭建前准备"><a href="#搭建前准备" class="headerlink" title="搭建前准备"></a>搭建前准备</h2><h3 id="一台VPS服务器"><a href="#一台VPS服务器" class="headerlink" title="一台VPS服务器"></a>一台VPS服务器</h3><p>已有服务器的同学可以跳过这部分，没有服务器的同学可以先创建服务器，我使用的是<a href="https://www.itblogcn.com/vultr">Vultr</a>。</p><p><a href="https://www.itblogcn.com/vultr/t">Vultr VPS</a> 推出了 <strong>2023 年最新的限时促销活动</strong>，「新用户」注册并充值 10 美元以上，即可获得 100 美元的免费赠送金额！力度相当巨大！！ (去年仅送 $50) 用于建站、学习、自建网盘或各种网络服务等等都很实用，优势是价格低，按时计费，随时更换IP。有购买海外 <a href="https://www.itblogcn.com/vultr">VPS</a> 需求的同学就得抓紧机会了。</p><p><strong>Vultr活动地址：</strong><a href="https://www.itblogcn.com/vultr/t">https://www.itblogcn.com/vultr/t</a></p><p><strong>Vultr注册教程：</strong><a href="https://www.itblogcn.com/article/registervultr.html">注册Vultr教程和创建VPS服务器教程</a></p><p>预算充足的朋友也可以选择搬瓦工的VPS服务器，其CN2 GIA-E线路网速极快。</p><p><strong>搬瓦工注册教程(内附优惠券)：</strong><a href="https://www.itblogcn.com/article/bwg-register.html">https://www.itblogcn.com/article/bwg-register.html</a></p><p><strong>搬瓦工VPS在售列表一览：</strong><a href="https://www.itblogcn.com/bwg/index.html">https://www.itblogcn.com/bwg/index.html</a></p><p>这里也可以使用<a href="https://my.racknerd.com/cart.php?a=confproduct&i=0">racknerd</a>。</p><p><strong>racknerd注册教程：</strong><a href="https://www.vpsgo.com/racknerd-purchase-tutorial.html">https://www.vpsgo.com/racknerd-purchase-tutorial.html</a></p><p><strong>2023年便宜高性价比VPS推荐：</strong><a href="https://www.vps69.com/posts/cheap-vps">https://www.vps69.com/posts/cheap-vps</a></p><h3 id="域名申请"><a href="#域名申请" class="headerlink" title="域名申请"></a>域名申请</h3><p><strong>聚名教程：</strong><a href="https://www.juming.com/help/127.htm">https://www.juming.com/help/127.htm</a></p><p><strong>namecheap教程：</strong><a href="https://zhuanlan.zhihu.com/p/33261777">https://zhuanlan.zhihu.com/p/33261777</a></p><h3 id="端口开放"><a href="#端口开放" class="headerlink" title="端口开放"></a>端口开放</h3><p>安装前必须开放服务器的<code>80</code>和<code>443</code>端口</p><p>防火墙相关命令可阅读 ：<a href="https://www.itblogcn.com/article/vultr-centos-7-firewall.html">https://www.itblogcn.com/article/vultr-centos-7-firewall.html</a></p><h2 id="Xshell连接服务器"><a href="#Xshell连接服务器" class="headerlink" title="Xshell连接服务器"></a>Xshell连接服务器</h2><h3 id="电脑端-ssh-登录"><a href="#电脑端-ssh-登录" class="headerlink" title="电脑端 ssh 登录"></a>电脑端 ssh 登录</h3><h2 id="一键Trojan搭建"><a href="#一键Trojan搭建" class="headerlink" title="一键Trojan搭建"></a>一键Trojan搭建</h2><p>系统建议：</p><ul><li>  CentOS 7</li></ul><p>首先安装wget（Vultr VPS已安装）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y wget</span><br></pre></td></tr></table></figure><h3 id="一键安装Trojan脚本"><a href="#一键安装Trojan脚本" class="headerlink" title="一键安装Trojan脚本"></a>一键安装Trojan脚本</h3><p>输入以下命令，回车执行（<code>shift+insert</code>可粘贴）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -N --no-check-certificate -q -O trojan_install.sh &quot;https://raw.githubusercontent.com/xyz690/Trojan/master/trojan_install.sh&quot; &amp;&amp; chmod +x trojan_install.sh &amp;&amp; bash trojan_install.sh</span><br></pre></td></tr></table></figure><p>输入<code>1</code>回车</p><p><img src="https://www.itblogcn.com/wp-content/uploads/2021/03/post-1048-603ca6268a7bb.png" alt="tssh2"></p><p>输入你解析的域名，比如我解析的是<code>www.demo.com</code>，然后回车执行</p><p><img src="https://www.itblogcn.com/wp-content/uploads/2021/03/post-1048-603ca62778d41.png" alt="tssh4_edit"></p><p>如果解析不正常，可能是之前DNS解析还没生效，建议等几分钟重试。</p><p>显示一下信息代表安装成功：</p><p><img src="https://www.itblogcn.com/wp-content/uploads/2021/03/post-1048-603ca628677ed.png" alt="20210301003431"></p><h4 id="查看运行状态（执行）："><a href="#查看运行状态（执行）：" class="headerlink" title="查看运行状态（执行）："></a>查看运行状态（执行）：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status trojan.service</span><br></pre></td></tr></table></figure><p>成功运行显示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">● trojan.service - trojan</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/trojan.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Fri 2022-12-02 16:02:55 UTC; 37s ago</span><br><span class="line"> Main PID: 8263 (trojan)</span><br><span class="line">   CGroup: /system.slice/trojan.service</span><br><span class="line">           └─8263 /usr/src/trojan/trojan -c /usr/src/trojan/server.conf</span><br><span class="line"></span><br><span class="line">Dec 02 16:02:55 vultr.guest systemd[1]: Started trojan.</span><br><span class="line">Dec 02 16:02:55 vultr.guest trojan[8263]: Welcome to trojan 1.16.0</span><br><span class="line">Dec 02 16:02:55 vultr.guest trojan[8263]: [2022-12-02 16:02:55] [WARN] trojan service (server) started at 0.0.0.0:443</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="查看配置文件-该配置在后面链接时使用-："><a href="#查看配置文件-该配置在后面链接时使用-：" class="headerlink" title="查看配置文件(该配置在后面链接时使用)："></a>查看配置文件(该配置在后面链接时使用)：</h4><p>输入以下命令，回车执行（<code>shift+insert</code>可粘贴）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /usr/src/trojan-macos/trojan/config.json</span><br></pre></td></tr></table></figure><p>我的配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;run_type&quot;: &quot;client&quot;,</span><br><span class="line">    &quot;local_addr&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;local_port&quot;: 1080,</span><br><span class="line">    &quot;remote_addr&quot;: &quot;www.demo.com&quot;,</span><br><span class="line">    &quot;remote_port&quot;: 443,</span><br><span class="line">    &quot;password&quot;: [</span><br><span class="line">        &quot;ae412345&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;log_level&quot;: 1,</span><br><span class="line">    &quot;ssl&quot;: &#123;</span><br><span class="line">        &quot;verify&quot;: true,</span><br><span class="line">        &quot;verify_hostname&quot;: true,</span><br><span class="line">        &quot;cert&quot;: &quot;&quot;,</span><br><span class="line">        &quot;cipher&quot;: &quot;ECDHE-ECDSA-AES128-GCM-SHA256:...&quot;,</span><br><span class="line">        &quot;cipher_tls13&quot;: &quot;TLS_AES_128_GCM_SHA256:...&quot;,</span><br><span class="line">        &quot;sni&quot;: &quot;&quot;,</span><br><span class="line">        &quot;alpn&quot;: [</span><br><span class="line">            &quot;h2&quot;,</span><br><span class="line">            &quot;http/1.1&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;reuse_session&quot;: true,</span><br><span class="line">        &quot;session_ticket&quot;: false,</span><br><span class="line">        &quot;curves&quot;: &quot;&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;tcp&quot;: &#123;</span><br><span class="line">        &quot;no_delay&quot;: true,</span><br><span class="line">        &quot;keep_alive&quot;: true,</span><br><span class="line">        &quot;reuse_port&quot;: false,</span><br><span class="line">        &quot;fast_open&quot;: false,</span><br><span class="line">        &quot;fast_open_qlen&quot;: 20</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请重点关注配置文件中的如下参数：</p><ol><li> <code>remote_addr</code>：服务器地址（浏览器输入这个地址能打开网页）</li><li> <code>remote_port</code>：端口</li><li> <code>password</code>：密码</li></ol><h2 id="客户端链接Trojan"><a href="#客户端链接Trojan" class="headerlink" title="客户端链接Trojan"></a>客户端链接Trojan</h2><p><strong>clash-for-windows教程：</strong><a href="https://v2xtls.org/clash-for-windows%E9%85%8D%E7%BD%AEtrojan%E6%95%99%E7%A8%8B/">https://v2xtls.org/clash-for-windows%E9%85%8D%E7%BD%AEtrojan%E6%95%99%E7%A8%8B/</a></p><p>官网下载地址：<a href="https://github.com/Fndroid/clash_for_windows_pkg/releases">https://github.com/Fndroid/clash_for_windows_pkg/releases</a></p><p>下载运行后，点击“Profiles”，点击 <a href="https://v2xtls.org/clash_template2.yaml">https://v2xtls.org/clash_template2.yaml</a> 下载模板配置文件，用记事本、VS Code、Notepad++等编辑器打开，找到trojan配置块，把 server、port、password改成你服务器的信息</p><p>把修改好的配置文件拖到clash界面中，</p><p>然后双击选中拖进来的配置文件(深色表示选中)</p><p>最后回到主界面，点击“System Proxy”，开启系统代理，点击“Start with Windows”设置开机自启</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是-Trojan&quot;&gt;&lt;a href=&quot;#什么是-Trojan&quot; class=&quot;headerlink&quot; title=&quot;什么是 Trojan&quot;&gt;&lt;/a&gt;什么是 Trojan&lt;/h2&gt;&lt;p&gt;Trojan将流量伪装成用户正常访问网页时的HTTPS流量，防止流量被检测和干扰。&lt;/p&gt;</summary>
    
    
    
    <category term="Trojan" scheme="https://rma-shuyu.github.io/categories/Trojan/"/>
    
    
    <category term="Trojan" scheme="https://rma-shuyu.github.io/tags/Trojan/"/>
    
  </entry>
  
  <entry>
    <title>libvirt新增驱动</title>
    <link href="https://rma-shuyu.github.io/2022/07/05/libvirt%E6%96%B0%E5%A2%9E%E9%A9%B1%E5%8A%A8/"/>
    <id>https://rma-shuyu.github.io/2022/07/05/libvirt%E6%96%B0%E5%A2%9E%E9%A9%B1%E5%8A%A8/</id>
    <published>2022-07-05T11:55:44.000Z</published>
    <updated>2023-10-21T07:21:41.638Z</updated>
    
    <content type="html"><![CDATA[<h2 id="libvirtd驱动"><a href="#libvirtd驱动" class="headerlink" title="libvirtd驱动"></a>libvirtd驱动</h2><p>libvirtd qemu驱动的实现基于QEMU的API和命令行工具，它可以与QEMU进行交互，以便创建、启动、停止、重启、迁移、备份和恢复虚拟机等操作。</p><span id="more"></span><h2 id="修改背景"><a href="#修改背景" class="headerlink" title="修改背景"></a>修改背景</h2><p>如果是自研的虚拟化软件，那么在使用libvirtd时，需要开发对应的app驱动。<br>admin 2.0对libvirt 进行了开发，修改了原生7.2的代码，需要删除对原有功能的形象，完成现有功能的迭代</p><ol><li>支持2.0现有功能</li><li>增加新的jmnd_driver支持，可考虑新增代码单独目录放置</li></ol><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>原生libvirt增加jmnd_driver:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">编译meson:</span><br><span class="line"></span><br><span class="line">    meson.build：增加jmnd驱动编译</span><br><span class="line"></span><br><span class="line">    meson_options.txt: 增加jmnd驱动选项</span><br><span class="line"></span><br><span class="line">修改代码：</span><br><span class="line"></span><br><span class="line">    include/libvirt/virterror.h: 增加错误域</span><br><span class="line"></span><br><span class="line">    src/util/virerror.c: 增加错误域名</span><br><span class="line"></span><br><span class="line">    src/remote/remote_daemon.c: 增加驱动装载的执行</span><br><span class="line"></span><br><span class="line">    src/meson.build: 增加jmnd驱动编译</span><br><span class="line"></span><br><span class="line">新增驱动代码：</span><br><span class="line"></span><br><span class="line">    src/jmnd : jmnd_driver实现</span><br></pre></td></tr></table></figure><h2 id="virsh命令格式"><a href="#virsh命令格式" class="headerlink" title="virsh命令格式"></a>virsh命令格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    virsh -c jmnd+tcp:///system [CMD]</span><br><span class="line"></span><br><span class="line">    可以将jmnd设置成默认驱动：</span><br><span class="line"></span><br><span class="line">        /usr/share/jmnd/libvirt/etc/libvirt/libvirt.conf 中：uri_default = &quot;jmnd:///system&quot;</span><br><span class="line"></span><br><span class="line">        重启libvirt</span><br><span class="line"></span><br><span class="line">        然后执行virsh [CMD]，等同于执行virsh -c jmnd+tcp:///system [CMD]</span><br><span class="line"></span><br><span class="line">远程操作：</span><br><span class="line"></span><br><span class="line">     virsh -c jmnd+tcp://10.20.25.22/system [CMD]</span><br></pre></td></tr></table></figure><h2 id="libvird-l"><a href="#libvird-l" class="headerlink" title="libvird -l"></a>libvird -l</h2><p>用于监听libvirtd.conf中的tcp_port，如果不加-l参数，则virsh只能本地访问libvirtd，添加-l参数后可以远程访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@node-70-20:/usr/share/jmnd/libvirt/etc/libvirt# egrep -v &quot;^#|^$&quot; *</span><br><span class="line">libvirt.conf:uri_default = &quot;jmnd:///system&quot;</span><br><span class="line">libvirtd.conf:listen_tls = 0</span><br><span class="line">libvirtd.conf:listen_tcp = 1</span><br><span class="line">libvirtd.conf:tcp_port = &quot;16509&quot;</span><br><span class="line">libvirtd.conf:log_level = 3</span><br><span class="line">libvirtd.conf:log_outputs=&quot;1:file:/var/log/libvirt/libvirtd.log&quot;</span><br><span class="line">qemu.conf:max_files = 20480</span><br></pre></td></tr></table></figure><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>1.0和2.0可以共用libvirt</p><p>1.0用的是libvirt本身支持的qemu驱动、</p><p>2.0用的是libvirt支持的jmnd驱动</p><p>由于libvirt的jmnd驱动加载后有定时器定时连接jmnd_hypervisor，因此可以直接将jmnd驱动库删除，驱动库：/usr/share/jmnd/libvirt/lib/x86_64-linux-gnu/libvirt/connection-driver/libvirt_driver_jmnd.so</p><p>后续jmnd驱动修改代码可以直接替换这个驱动库后重启Libvirt生效</p><h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line">#0  jmndConnectHelloWorld (conn=0x7f5ca40051c0, printout=0x7f5cd6f32960) at ../src/jmnd/jmnd_driver.c:404</span><br><span class="line">#1  0x00007f5cde7ee786 in virConnectHelloWorld (conn=&lt;optimized out&gt;, printout=printout@entry=0x7f5cd6f32960) at ../src/libvirt-domain.c:191</span><br><span class="line">#2  0x000055af32336164 in remoteDispatchConnectHelloWorld (server=0x55af33b64080, msg=0x55af33b6e1c0, ret=0x7f5ccc0039d0, rerr=0x7f5cd6f32a30, client=0x7f5ca40050c0)</span><br><span class="line">    at src/remote/remote_daemon_dispatch_stubs.h:1317</span><br><span class="line">#3  remoteDispatchConnectHelloWorldHelper (server=0x55af33b64080, client=0x7f5ca40050c0, msg=0x55af33b6e1c0, rerr=0x7f5cd6f32a30, args=0x0, ret=0x7f5ccc0039d0) at src/remote/remote_daemon_dispatch_stubs.h:1297</span><br><span class="line">#4  0x00007f5cde7877c1 in virNetServerProgramDispatchCall (msg=0x55af33b6e1c0, client=0x7f5ca40050c0, server=0x55af33b64080, prog=0x55af33b65810) at ../src/rpc/virnetserverprogram.c:428</span><br><span class="line">#5  virNetServerProgramDispatch (prog=0x55af33b65810, server=server@entry=0x55af33b64080, client=0x7f5ca40050c0, msg=0x55af33b6e1c0) at ../src/rpc/virnetserverprogram.c:302</span><br><span class="line">#6  0x00007f5cde78c712 in virNetServerProcessMsg (msg=&lt;optimized out&gt;, prog=&lt;optimized out&gt;, client=&lt;optimized out&gt;, srv=0x55af33b64080) at ../src/rpc/virnetserver.c:137</span><br><span class="line">#7  virNetServerHandleJob (jobOpaque=0x55af33b35000, opaque=0x55af33b64080) at ../src/rpc/virnetserver.c:154</span><br><span class="line">#8  0x00007f5cde6d68f0 in virThreadPoolWorker (opaque=&lt;optimized out&gt;) at ../src/util/virthreadpool.c:163</span><br><span class="line">#9  0x00007f5cde6d6027 in virThreadHelper (data=&lt;optimized out&gt;) at ../src/util/virthread.c:233</span><br><span class="line">#10 0x00007f5cdbdae1ca in start_thread () from /lib64/libpthread.so.0</span><br><span class="line">#11 0x00007f5cdd0ecd83 in clone () from /lib64/libc.so.6</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;libvirtd驱动&quot;&gt;&lt;a href=&quot;#libvirtd驱动&quot; class=&quot;headerlink&quot; title=&quot;libvirtd驱动&quot;&gt;&lt;/a&gt;libvirtd驱动&lt;/h2&gt;&lt;p&gt;libvirtd qemu驱动的实现基于QEMU的API和命令行工具，它可以与QEMU进行交互，以便创建、启动、停止、重启、迁移、备份和恢复虚拟机等操作。&lt;/p&gt;</summary>
    
    
    
    <category term="LIBVIRT" scheme="https://rma-shuyu.github.io/categories/LIBVIRT/"/>
    
    
    <category term="driver" scheme="https://rma-shuyu.github.io/tags/driver/"/>
    
  </entry>
  
  <entry>
    <title>libvirtd初始化流程</title>
    <link href="https://rma-shuyu.github.io/2022/07/04/libvirtd%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/"/>
    <id>https://rma-shuyu.github.io/2022/07/04/libvirtd%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/</id>
    <published>2022-07-04T11:55:44.000Z</published>
    <updated>2023-10-21T07:21:41.637Z</updated>
    
    <content type="html"><![CDATA[<p>libvirtd daemon初始化流程比较复杂，本文对代码流程进行初步分析。</p><span id="more"></span><h2 id="总体代码流程"><a href="#总体代码流程" class="headerlink" title="总体代码流程"></a>总体代码流程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">main&#123;remote/remote_deamon.c&#125;</span><br><span class="line">|</span><br><span class="line">|--daemonConfigLoadFile&#123;读取libvirtd.conf配置项&#125;</span><br><span class="line">|</span><br><span class="line">|--Decided on pid file path &#x27;/usr/local/var/run/libvirtd.pid&#x27;</span><br><span class="line">|</span><br><span class="line">|--virDaemonUnixSocketPaths&#123;获取unix对应的socket文件名字，例如：/usr/local/var/run/libvirt/libvirt-sock&#125;</span><br><span class="line">|</span><br><span class="line">|--virDaemonForkIntoBackground&#123;如果设置-d参数的话，将启动的libvirtd进程变成后台的daemon进程&#125;</span><br><span class="line">|</span><br><span class="line">|--virPidFileAcquirePath&#123;&#x27;/usr/local/var/run/libvirtd.pid&#x27;&#125;</span><br><span class="line">|</span><br><span class="line">|--virNetDaemonNew&#123;生成的是daemon变量&#125;</span><br><span class="line">|</span><br><span class="line">|--virNetServerNew&#123;初始化的是libvirtd server变量，里面是一堆rpc-worker的线程&#125;</span><br><span class="line">|</span><br><span class="line">|--virNetDaemonAddServer&#123;把server变量放进daemon中的hash表中&#125;</span><br><span class="line">|</span><br><span class="line">|--daemonSetupSignals&#123;daemon的一些回调函数注册，例如SIGINT，SIGQUIT，SIGTERM，SIGHUP&#125;</span><br><span class="line">|</span><br><span class="line">|--daemonSetupNetworking&#123;前面已经启动线程，这里对socket进行监听和消息接收函数注册&#125;</span><br><span class="line">|</span><br><span class="line">|--daemonInitialize&#123;动态库添加，例如qemu驱动&#125;</span><br><span class="line">|</span><br><span class="line">|--daemonStateInit&#123;驱动初始化，例如qemu驱动的初始化&#125;</span><br><span class="line">|</span><br><span class="line">|--virNetServerProgramNew</span><br><span class="line">|</span><br><span class="line">|--virNetServerAddProgram(srv, qemuProgram)</span><br><span class="line">|</span><br><span class="line">|--virNetDaemonRun&#123;Run event loop&#125;</span><br></pre></td></tr></table></figure><h2 id="各个流程代码分析"><a href="#各个流程代码分析" class="headerlink" title="各个流程代码分析"></a>各个流程代码分析</h2><h3 id="子进程创建"><a href="#子进程创建" class="headerlink" title="子进程创建"></a>子进程创建</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">virDaemonForkIntoBackground&#123;如果启动libvirtd进程的时候，以-d启动，则会创建一个子进程来启动，之后在后台运行，否则libvirtd进程就会一直卡在终端界面上&#125;</span><br><span class="line">|</span><br><span class="line">|--virPipeQuiet(statuspipe)</span><br><span class="line">|</span><br><span class="line">|--fork()</span><br><span class="line">|</span><br><span class="line">|--child</span><br><span class="line">||</span><br><span class="line">||--VIR_FORCE_CLOSE(statuspipe[0])&#123;关闭读通道&#125;</span><br><span class="line">||</span><br><span class="line">||--setsid()&#123;为啥在这里设置，child后面就会关掉，为啥不在grand child中设置呢？&#125;</span><br><span class="line">||</span><br><span class="line">||--fork()&#123;继续创建进程&#125;</span><br><span class="line">||</span><br><span class="line">||--grand</span><br><span class="line">|||</span><br><span class="line">|||-statuspipe[1]&#123;返回写通道，用grand child作为daemon进程，如果初始化成功，则会向管道中写数据&#125;</span><br><span class="line">||</span><br><span class="line">||--child</span><br><span class="line">||</span><br><span class="line">||--_exit(EXIT_SUCCESS)&#123;child进程退出，但是是不是没有清理资源statuspipe[1]？&#125;</span><br><span class="line">|</span><br><span class="line">|--parent</span><br><span class="line">|</span><br><span class="line">|--VIR_FORCE_CLOSE(statuspipe[1])&#123;关闭写通道&#125;</span><br><span class="line">|</span><br><span class="line">|--waitpid(pid, &amp;exitstatus, 0)&#123;等到child退出&#125;</span><br><span class="line">|</span><br><span class="line">|--saferead(statuspipe[0], &amp;status, 1)&#123;grand child后面初始化成功之后会发送消息，但是这个是非阻塞的，难道会等待吗？&#125;</span><br><span class="line">|</span><br><span class="line">|--VIR_FORCE_CLOSE(statuspipe[0])&#123;关闭读通道&#125;</span><br><span class="line">|</span><br><span class="line">|--_exit(EXIT_SUCCESS)&#123;退出父进程&#125;</span><br><span class="line"></span><br><span class="line">virPidFileAcquirePath的目的是为了防止重复运行libvirtd进程；在该函数中会设置独占锁给pid_file；如果失败，则说明已经有libvirtd运行了，反之则将pid写入到pid_file中(pid_file=/usr/local/var/run/libvirtd.pid)</span><br><span class="line">virPidFileAcquirePath</span><br><span class="line">|</span><br><span class="line">|--open(path, O_WRONLY|O_CREAT, 0644)</span><br><span class="line">|</span><br><span class="line">|--&#123;Ensuring run dir &#x27;/usr/local/var/run/libvirt&#x27; exists&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="daemon对象创建"><a href="#daemon对象创建" class="headerlink" title="daemon对象创建"></a>daemon对象创建</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">virNetDaemonNew</span><br><span class="line">|</span><br><span class="line">|--virNetDaemonInitialize</span><br><span class="line">|</span><br><span class="line">|--dmn = virObjectLockableNew&#123;生成一个virNetDaemon对象，后续对该对象中的各个成员变量进行初始化&#125;</span><br><span class="line">|</span><br><span class="line">|--dmn-&gt;servers = virHashNew(virObjectFreeHashData)&#123;这里分配HASH表，并对哈希表进行初始化&#125;</span><br><span class="line">|</span><br><span class="line">|--virEventRegisterDefaultImpl</span><br><span class="line">|</span><br><span class="line">|--virInitialize&#123;所调用的函数只执行一次，pthread_once&#125;</span><br><span class="line">||</span><br><span class="line">||--virGlobalInit&#123;相应的driver注册&#125;</span><br><span class="line">||</span><br><span class="line">||--remoteRegister&#123;这个函数为啥没有日志打印？难道没有执行&#125;</span><br><span class="line">||</span><br><span class="line">||--virRegisterConnectDriver(&amp;connect_driver)</span><br><span class="line">||</span><br><span class="line">||--virRegisterStateDriver(&amp;state_driver)</span><br><span class="line">|</span><br><span class="line">|--virResetLastError</span><br><span class="line">|</span><br><span class="line">|--virEventGLibRegister</span><br><span class="line">|</span><br><span class="line">|--virEventGLibRegisterOnce&#123;函数只执行一次&#125;</span><br><span class="line">|</span><br><span class="line">|--virEventRegisterImpl&#123;这个是event事件相关函数句柄注册&#125;</span><br><span class="line">|</span><br><span class="line">|--removeHandleImpl=virEventGLibHandleRemove</span><br><span class="line">|--updateHandleImpl=virEventGLibHandleUpdate</span><br><span class="line">|--addHandleImpl=virEventGLibHandleAdd</span><br><span class="line">|</span><br><span class="line">|--GSource</span><br><span class="line">|--g_source_new</span><br><span class="line">|--g_source_add_poll</span><br><span class="line">|--g_source_set_callback</span><br><span class="line">|--g_source_attach</span><br></pre></td></tr></table></figure><h3 id="virNetServerNew创建"><a href="#virNetServerNew创建" class="headerlink" title="virNetServerNew创建"></a>virNetServerNew创建</h3><p>这个就是初始化一组worker pool,等待信号量，然后再调用消息处理函数处理具体的消息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">virNetServerNew&#123;这个是rpc-worker服务端的初始化函数&#125;</span><br><span class="line">|</span><br><span class="line">|--virObjectLockableNew(virNetServerClass)&#123;生成一个virNetServerPtr对象指针&#125;</span><br><span class="line">|</span><br><span class="line">|--srv-&gt;workers = virThreadPoolNewFull(virNetServerHandleJob, &quot;rpc-worker&quot;)</span><br><span class="line">||</span><br><span class="line">||--分配virThreadPoolPtr pool</span><br><span class="line">||</span><br><span class="line">||--pool-&gt;jobFunc = func=virNetServerHandleJob&#123;设置pool中的函数句柄&#125;</span><br><span class="line">||</span><br><span class="line">||--pool-&gt;jobName = name&#123;设置pool中的名字&#125;</span><br><span class="line">||</span><br><span class="line">||--pool-&gt;jobOpaque=server&#123;将server变量指针传入到pool的jobopaque指针变量中&#125;</span><br><span class="line">||</span><br><span class="line">||--virThreadPoolExpand(pool, minWorkers)&#123;如函数名称：线程池扩展函数，就是for循环创建多个线程池&#125;</span><br><span class="line">|||</span><br><span class="line">|||--data-&gt;pool = pool</span><br><span class="line">|||</span><br><span class="line">|||--virThreadCreateFull(&amp;(*workers)[i],virThreadPoolWorker,data)&#123;创建minWorkers个线程&#125;</span><br><span class="line">|||</span><br><span class="line">|||--args-&gt;func=virThreadPoolWorker</span><br><span class="line">|||</span><br><span class="line">|||--args-&gt;opaque=data</span><br><span class="line">|||</span><br><span class="line">|||--pthread_create(&amp;thread-&gt;thread, &amp;attr, virThreadHelper, args)</span><br><span class="line">|||</span><br><span class="line">|||--virThreadHelper(args)&#123;这是最终的线程函数&#125;</span><br><span class="line">|||</span><br><span class="line">|||--local = *args</span><br><span class="line">|||</span><br><span class="line">|||-local.func(local.opaque)&lt;==&gt;virThreadPoolWorker(data)</span><br><span class="line">|||</span><br><span class="line">|||--virThreadPoolWorker&#123;这个是线程的最终执行函数，里面有while循环&#125;</span><br><span class="line">|||</span><br><span class="line">|||-virMutexLock(&amp;pool-&gt;mutex)&#123;在进入while循环之前先获取锁&#125;</span><br><span class="line">|||</span><br><span class="line">|||--virCondWait(cond, &amp;pool-&gt;mutex)&#123;进入while循环之后，先解锁把cond放入等待队列中(原子动作)，获取信号之后，再加锁&#125;</span><br><span class="line">|||</span><br><span class="line">|||--pool-&gt;jobQueueDepth--&#123;队列深度减一&#125;</span><br><span class="line">|||--virMutexUnlock(&amp;pool-&gt;mutex)&#123;解锁&#125;</span><br><span class="line">|||--(pool-&gt;jobFunc)(job-&gt;data, pool-&gt;jobOpaque)&lt;===&gt;virNetServerHandleJob(server)&#123;这里是处理具体消息的函数&#125;</span><br><span class="line">|||--virMutexLock(&amp;pool-&gt;mutex)&#123;加锁，进入下一次等待&#125;</span><br><span class="line">||</span><br><span class="line">||--return pool&#123;server变量中的worker就是pool，即线程池&#125;</span><br><span class="line">|</span><br><span class="line">|--继续初始化server，这里的pool是server中的变量，同时也是线程中的变量，两边都可以使用</span><br></pre></td></tr></table></figure><h3 id="服务端创建"><a href="#服务端创建" class="headerlink" title="服务端创建"></a>服务端创建</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">daemonSetupNetworking(srv, srvAdm,config,sock_file)</span><br><span class="line">|</span><br><span class="line">|--virNetServerAddServiceActivation&#123;No activation FDs present，这个函数没啥作用，直接返回了&#125;</span><br><span class="line">|</span><br><span class="line">|--virNetServerAddServiceUNIX&#123;针对的unix的*.socket文件&#125;&#123;这里生成的是virNetServerService对象&#125;</span><br><span class="line">||</span><br><span class="line">||--virNetServerAddServiceActivation</span><br><span class="line">||</span><br><span class="line">||--virNetServerServiceNewUNIX</span><br><span class="line">|||</span><br><span class="line">|||--virNetSocketNewListenUNIX&#123;Creating new UNIX server path=&#x27;/usr/local/var/run/libvirt/libvirt-sock&#x27;&#125;</span><br><span class="line">||||</span><br><span class="line">||||--virNetSocketNew&#123;生成一个监听的套接字&#125;</span><br><span class="line">|||</span><br><span class="line">|||--virNetServerServiceNewSocket(&amp;sock)&#123;得到virNetServerServicePtr变量&#125;</span><br><span class="line">|||</span><br><span class="line">|||--virNetSocketListen(svc-&gt;socks[i], max_queued_clients)&#123;对该socket的fd进行监听&#125;</span><br><span class="line">|||</span><br><span class="line">|||--virNetSocketAddIOCallback(svc-&gt;socks[i],virNetServerServiceAccept)&#123;循环调用&#125;</span><br><span class="line">||||</span><br><span class="line">||||--sock-&gt;watch = virEventAddHandle(sock-&gt;fd,virNetSocketEventHandle)</span><br><span class="line">|||||</span><br><span class="line">|||||--virNetSocketEventHandle&#123;这里进行event—loop监听，并注册监听函数；添加之后，并没直接进入event-loop&#125;</span><br><span class="line">|||||</span><br><span class="line">|||||--virNetServerServiceAccept&#123;如果有客户端连接service，则会调用该函数&#125;</span><br><span class="line">||||</span><br><span class="line">||||--sock-&gt;func = virNetServerServiceAccept&#123;server端处理消息的回调函数&#125;</span><br><span class="line">|||</span><br><span class="line">|||--将sock中的值赋值给virNetServerServicePtr变量并返回</span><br><span class="line">||</span><br><span class="line">||--virNetServerAddService&#123;将virNetServerServicePtr变量放进virNetServerPtr变量中，virNetServer对象包含多个virNetServerService对象&#125;</span><br><span class="line">||</span><br><span class="line">||--virNetServerServiceSetDispatcher</span><br><span class="line">||</span><br><span class="line">||--svc-&gt;dispatchFunc=virNetServerDispatchNewClient&#123;注册客户端的回调函数，用于处于从Unix得到的消息&#125;</span><br><span class="line">|</span><br><span class="line">|--virNetServerAddServiceTCP(针对的是tcp的socket文件)</span><br></pre></td></tr></table></figure><p>后续如果socket套接字接收到client端发送的连接之后，经过glib的event-loop调用，会进入到此函数中创建serverclient对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">virNetServerServiceAccept&#123;server端如果接收到客户端的连接，则会调用这个回调函数进行处理创建客户端对象&#125;</span><br><span class="line">|</span><br><span class="line">|--virNetSocketAccept(sock, &amp;clientsock)</span><br><span class="line">||</span><br><span class="line">||--fd = accept(sock-&gt;fd, &amp;remoteAddr.data.sa, &amp;remoteAddr.len)</span><br><span class="line">||</span><br><span class="line">||--*clientsock = virNetSocketNew(&amp;localAddr,&amp;remoteAddr, true, fd,)&#123;这里根据得到的客户端创建新的套接字&#125;</span><br><span class="line">|</span><br><span class="line">|--svc-&gt;dispatchFunc(svc, clientsock, svc-&gt;dispatchOpaque)</span><br><span class="line">|</span><br><span class="line">|--virNetServerDispatchNewClient&#123;这个正是上面注册的回调函数&#125;</span><br><span class="line">|</span><br><span class="line">|--virNetServerClientNew&#123;分配_virNetServerClient对象，用于接收socket传来的消息&#125;</span><br><span class="line">|</span><br><span class="line">|--virNetServerAddClient(srv, client)</span><br><span class="line">|</span><br><span class="line">|--virNetServerClientInit</span><br><span class="line">||</span><br><span class="line">||--virNetServerClientRegisterEvent</span><br><span class="line">||</span><br><span class="line">||--virNetServerClientCalculateHandleMode</span><br><span class="line">||</span><br><span class="line">||--virNetSocketAddIOCallback(client-&gt;sock, virNetServerClientDispatchEvent)</span><br><span class="line">||</span><br><span class="line">||--virEventAddHandle(virNetSocketEventHandle)&#123;添加event-loop事件，对客户端的连接进行监听&#125;</span><br><span class="line">|</span><br><span class="line">|--srv-&gt;clients[srv-&gt;nclients-1] = virObjectRef(client)&#123;这里是每来一个client，则就在server中的client指针中新增一个client，释放是在后面的while循环中&#125;</span><br><span class="line">|</span><br><span class="line">|--virNetServerClientSetDispatcher(client, virNetServerDispatchNewMessage, srv)</span><br><span class="line">||</span><br><span class="line">||--client-&gt;dispatchFunc=virNetServerDispatchNewMessage&#123;server=0x55882b100880 client=0x55882b1112d0 message=0x55882b114690&#125;</span><br><span class="line">|</span><br><span class="line">|--virNetServerClientInitKeepAlive(client, srv-&gt;keepaliveInterval, srv-&gt;keepaliveCount)&#123;设置客户端与服务端之间的连接超时时间&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>client如果向该socket发送消息，则会进入到event事件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">virNetSocketEventHandle</span><br><span class="line">|</span><br><span class="line">|--virNetServerClientDispatchEvent</span><br><span class="line">|</span><br><span class="line">|--virNetServerClientDispatchWrite&#123;写&#125;</span><br><span class="line">|</span><br><span class="line">|--msg = virNetServerClientDispatchRead(client)&#123;读取消息&#125;</span><br><span class="line">|</span><br><span class="line">|--virNetServerClientDispatchMessage(client, msg)</span><br><span class="line">|</span><br><span class="line">|--client-&gt;dispatchFunc(client, msg, client-&gt;dispatchOpaque)</span><br><span class="line">|</span><br><span class="line">|--virNetServerDispatchNewMessage</span><br><span class="line">|</span><br><span class="line">|--virThreadPoolSendJob&#123;发送信号量，调用线程池去处理&#125;</span><br><span class="line">|</span><br><span class="line">|--进入到另外一个线程virNetServerHandleJob&#123;server=0x55882b100880 client=0x55882b1112d0 message=0x55882b114690 prog=0x55882b109c10&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：<br>一条消息是如何被处理的？<br>1. 在libvirtd初始化的时候，会创建一个worker-pool(线程池)，在线程池中会等待信号量，如果得到信号量则会调用消息处理函数，进行真正的消息处理；<br>2. 但是谁发送的信号量呢？这个是客户端发来的消息处理的。<br>    在初始化的时候，会针对libvirt.sock文件创建一个监听事件，如果客户端连接这个套接字文件之后，则会调用监听事件注册的回调函数。<br>3. 2中注册的回调函数，会重新建立一个客户端和服务端的连接用于接收客户端发来的消息，并对该连接(socket)进行监听，并注册监听事件。<br>4. 如果客户端发送来消息，则会调用3中注册的事件处理函数，读取socket中的消息，并发送信号量调用1中的worker-pool中的线程处理函数。<br>5. 因为线程处理进程是多个的，因此不会阻塞会并发运行。<br>6. 对于每一个客户端的连接都会新生成一个serverclient对象，并对该对象中的socket进行监听。</p><h3 id="驱动获取"><a href="#驱动获取" class="headerlink" title="驱动获取"></a>驱动获取</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">daemonInitialize</span><br><span class="line">|</span><br><span class="line">|--virDriverLoadModule(&quot;network&quot;, &quot;networkRegister&quot;, false)</span><br><span class="line">|</span><br><span class="line">|--***</span><br><span class="line">|</span><br><span class="line">|--virDriverLoadModule(&quot;qemu&quot;, &quot;qemuRegister&quot;, false)&#123;加载qemu驱动&#125;</span><br><span class="line">|</span><br><span class="line">|--virFileFindResourceFull&#123;path=/usr/local/lib/libvirt/connection-driver/libvirt_driver_qemu.so&#125;</span><br><span class="line">|</span><br><span class="line">|--virModuleLoad(path,&quot;qemuRegister&quot;,false)</span><br><span class="line">|</span><br><span class="line">|--handle=virModuleLoadFile(path)</span><br><span class="line">|</span><br><span class="line">|--virModuleLoadFunc(&quot;qemuRegister&quot;)</span><br><span class="line">||</span><br><span class="line">||--regsym = dlsym(handle, &quot;qemuRegister&quot;)</span><br><span class="line">|</span><br><span class="line">|--(*regsym)()-&gt;qemuRegister()</span><br><span class="line">|</span><br><span class="line">|--virRegisterConnectDriver</span><br><span class="line">||</span><br><span class="line">||--virConnectDriverTab[virConnectDriverTabCount]=qemuConnectDriver&#123;对应的函数句柄&#125;</span><br><span class="line">|</span><br><span class="line">|--virRegisterStateDriver</span><br><span class="line">|</span><br><span class="line">|--virStateDriverTab[virStateDriverTabCount]=qemuStateDriver&#123;qemu驱动的初始化和终止函数&#125;</span><br></pre></td></tr></table></figure><h3 id="驱动初始化"><a href="#驱动初始化" class="headerlink" title="驱动初始化"></a>驱动初始化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">daemonStateInit&#123;Initialize drivers &amp; then start accepting new clients from network&#125;</span><br><span class="line">|</span><br><span class="line">|--virThreadCreateFull&#123;thread-name=&quot;daemon-init&quot;&#125;</span><br><span class="line">|</span><br><span class="line">|--daemonRunStateInit</span><br><span class="line">|</span><br><span class="line">|--virIdentitySetCurrent</span><br><span class="line">|</span><br><span class="line">|--daemonInhibitCallback</span><br><span class="line">|</span><br><span class="line">|-virStateInitialize</span><br><span class="line">|</span><br><span class="line">|--virInitialize&#123;只初始化一次&#125;</span><br><span class="line">||</span><br><span class="line">||--virGlobalInit</span><br><span class="line">||</span><br><span class="line">||--testRegister</span><br><span class="line">||</span><br><span class="line">||--openvzRegister</span><br><span class="line">||</span><br><span class="line">||--hypervRegister</span><br><span class="line">||</span><br><span class="line">||--remoteRegister</span><br><span class="line">|</span><br><span class="line">|--virStateDriverTab[i]-&gt;stateInitialize&#123;这里是一个for循环，初始化之前注册的driver&#125;</span><br><span class="line">||</span><br><span class="line">||--qemuStateInitialize&#123;qemu_driver.c&#125;&#123;因为前面已经加载了对应的驱动函数&#125;</span><br><span class="line">|</span><br><span class="line">|--driversInitialized = true&#123;这里代表驱动的初始化已经完成&#125;</span><br><span class="line">|</span><br><span class="line">|--virNetDaemonUpdateServices(dmn, true)&#123;Only now accept clients from network&#125;</span><br><span class="line">|</span><br><span class="line">|--virHashForEach(dmn-&gt;servers, daemonServerUpdateServices, &amp;enabled)</span><br><span class="line">|</span><br><span class="line">|--daemonServerUpdateServices</span><br><span class="line">|</span><br><span class="line">|--virNetServerUpdateServices(srv, *enable)</span><br></pre></td></tr></table></figure><h3 id="event事件运行"><a href="#event事件运行" class="headerlink" title="event事件运行"></a>event事件运行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">virNetDaemonRun</span><br><span class="line">|</span><br><span class="line">|--进入while(1)循环</span><br><span class="line">|</span><br><span class="line">|--virEventRunDefaultImpl&#123;这里是运行poll去检测eventloop.handles中的每个描述符的事件，如果有事件发生就会调用回调函数去处理事件，但是未看出来&#125;</span><br><span class="line">||</span><br><span class="line">||--virEventGLibRunOnce</span><br><span class="line">||</span><br><span class="line">||--g_main_context_iteration(NULL, TRUE)&#123;该函数可以完成GMainContext的单次迭代&#125;</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">|--virHashForEach(dmn-&gt;servers, daemonServerProcessClients, NULL)&#123;这里处理客户端，因为libvirtd也需要连接其他的libvirtd&#125;</span><br><span class="line">||</span><br><span class="line">||--for循环调用</span><br><span class="line">||</span><br><span class="line">||--daemonServerProcessClients(servers[i]-&gt;payload, servers[i]-&gt;name)</span><br><span class="line">||</span><br><span class="line">||--virNetServerProcessClients</span><br><span class="line">||</span><br><span class="line">||--判断client-&gt;wantClose 是否为true，是，则会主动关闭client</span><br><span class="line">|</span><br><span class="line">|--dmn-&gt;quit&#123;判断是否是退出&#125;</span><br><span class="line">|</span><br><span class="line">|--virThreadCreateFull(&amp;shutdownThread, true, daemonShutdownWait，&quot;daemon-shutdown&quot;)</span><br><span class="line">|</span><br><span class="line">|--daemonShutdownWait&#123;创建新的&quot;daemon-shutdown&quot;线程去处理资源&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;libvirtd daemon初始化流程比较复杂，本文对代码流程进行初步分析。&lt;/p&gt;</summary>
    
    
    
    <category term="LIBVIRT" scheme="https://rma-shuyu.github.io/categories/LIBVIRT/"/>
    
    
    <category term="libvirt" scheme="https://rma-shuyu.github.io/tags/libvirt/"/>
    
  </entry>
  
  <entry>
    <title>libvirt日志配置</title>
    <link href="https://rma-shuyu.github.io/2022/07/03/libvirt%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE/"/>
    <id>https://rma-shuyu.github.io/2022/07/03/libvirt%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE/</id>
    <published>2022-07-03T11:55:44.000Z</published>
    <updated>2023-10-21T07:21:41.638Z</updated>
    
    <content type="html"><![CDATA[<h3 id="libvirt配置文件详解"><a href="#libvirt配置文件详解" class="headerlink" title="libvirt配置文件详解"></a>libvirt配置文件详解</h3><h4 id="配置文件：-etc-libvirt-libvirtd-conf"><a href="#配置文件：-etc-libvirt-libvirtd-conf" class="headerlink" title="配置文件：/etc/libvirt/libvirtd.conf"></a>配置文件：/etc/libvirt/libvirtd.conf</h4><span id="more"></span><p><strong>日志控制</strong></p><p> 日志级别: 4 errors, 3 warnings, 2 information, 1 debug<br> 基本上debug级别可以记录所有日志信息<br> 注意: <br>     journald会锁定libvirt守护进行，限制日志记录级别，如果想监控debug级别日志，必须显式配置到“log_outputs”选项中，<br>     否则，只有information级别的日志会被记录。<br>     如果日志级别设置为2，则通过log_outputs获取不到1 debug级别的日志。<br>     默认情况下，不会将日志输出到journald中，也不会输出到其它地方。</p><p><code>log_level = 1</code></p><p><strong>日志过滤</strong><br> <br> 日志过滤允许对给定类别的日志选择特定日志级别。<br> 过滤格式可以是如下的一种:<br>    x:name<br>    x:+name<br>    当name字符串匹配到源文件名，比如：“remote”、“qemu”、“util/json”，“+”前缀会告诉libvirt去记录匹配名字的调用栈日志。<br>      x为匹配日志的最低级别:<br>    1: DEBUG<br>    2: INFO<br>    3: WARNING<br>    4: ERROR</p><p> 多个过滤器可以同时使用，只需要用空格隔开就行。<br> 示例如下：<br>     只从remote层获取警告和错误信息，并且从event层获取错误信息。</p><p><code>log_filters=&quot;3:remote 4:event&quot;</code></p><p><strong>日志输出</strong><br> <br> 日志输出可以是如下的几个地方：<br> 日志输出配置格式如下:<br>    x:stderr<br>      输出到标准错误输出中<br>    x:syslog:name<br>      使用自定义的name标识符，输出到系统日志<br>    x:file:file_path<br>      输出到指定路径的文件中<br>    x:journald<br>      输出到journald日志系统中<br> x代表最小的日志输出过滤级别<br>    1: DEBUG<br>    2: INFO<br>    3: WARNING<br>    4: ERROR</p><p> 可以同时定义多个输出，只需要用空格分开就行。<br> 注意：<br>     这里要保证日志级别大于等于log_level中的配置，否则无效<br> 例如：使用libvirtd标识记录WARNING以上日志信息到syslog中</p><p><code>log_outputs=&quot;3:syslog:libvirtd&quot;</code></p><p> 同时将日志记录到libvirtd.log文件和journald（可通过journalctl -u libvirtd来查看）中。</p><p><code>log_outputs=&quot;3:file:/var/log/libvirt/libvirtd.log 3:journald&quot;</code></p><h4 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h4><p>1、编辑文件 /etc/libvirt/libvirtd.conf，修改如下行，将libvirt调试日志输出到/var/log/libvirt/libvirtd.log文件中：<br>log_level=1</p><p>log_outputs=”1:file:/var/log/libvirt/libvirtd.log”</p><p>2、重启libvirtd服务使配置生效。</p><p>service libvirtd restart</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;libvirt配置文件详解&quot;&gt;&lt;a href=&quot;#libvirt配置文件详解&quot; class=&quot;headerlink&quot; title=&quot;libvirt配置文件详解&quot;&gt;&lt;/a&gt;libvirt配置文件详解&lt;/h3&gt;&lt;h4 id=&quot;配置文件：-etc-libvirt-libvirtd-conf&quot;&gt;&lt;a href=&quot;#配置文件：-etc-libvirt-libvirtd-conf&quot; class=&quot;headerlink&quot; title=&quot;配置文件：/etc/libvirt/libvirtd.conf&quot;&gt;&lt;/a&gt;配置文件：/etc/libvirt/libvirtd.conf&lt;/h4&gt;</summary>
    
    
    
    <category term="LIBVIRT" scheme="https://rma-shuyu.github.io/categories/LIBVIRT/"/>
    
    
    <category term="log" scheme="https://rma-shuyu.github.io/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>增加一个virsh命令</title>
    <link href="https://rma-shuyu.github.io/2022/07/02/%E5%A2%9E%E5%8A%A0%E4%B8%80%E4%B8%AAvirsh%E5%91%BD%E4%BB%A4/"/>
    <id>https://rma-shuyu.github.io/2022/07/02/%E5%A2%9E%E5%8A%A0%E4%B8%80%E4%B8%AAvirsh%E5%91%BD%E4%BB%A4/</id>
    <published>2022-07-02T11:55:44.000Z</published>
    <updated>2023-10-21T07:21:41.642Z</updated>
    
    <content type="html"><![CDATA[<h2 id="libvirt-简介"><a href="#libvirt-简介" class="headerlink" title="libvirt 简介"></a>libvirt 简介</h2><p>libvirt 是用于管理虚拟化平台的开源API、后台程序和管理工具。</p><span id="more"></span><p>它对上层云管平台提供一套 API 接口，libvirt 也自带了一个 virsh 工具可以用来控制虚机的生命周期，包括创建、删除、修改虚机。</p><p>本文中使用的 libvirt 版本为 7.3.0。</p><h2 id="libvirt-命令增添步骤"><a href="#libvirt-命令增添步骤" class="headerlink" title="libvirt 命令增添步骤"></a>libvirt 命令增添步骤</h2><p>目前 libvirt 已经提供了强大的 API 支持，但由于云上环境比较复杂，有时需要新定义一个 libvirt API 接口。</p><p>由于每添加一个 API 接口几乎就要添加一个新的 RPC 调用，所以添加的文件非常多。</p><p>以增添一个 <code>cmdHelloWorld</code> 为例，总共包括以下步骤：</p><ol><li> virsh 命令的添加</li><li> API 接口的添加</li><li> RPC 的添加</li></ol><p>由于添加 API 接口的步骤过长，本文先给大家介绍如何添加一个新的 virsh 命令。</p><h2 id="增添一个-virsh-命令"><a href="#增添一个-virsh-命令" class="headerlink" title="增添一个 virsh 命令"></a>增添一个 virsh 命令</h2><p>所有 virsh 命令的相应函数及其后传递的命令行参数都是在 <code>virsh-domain.c</code> 中。</p><p>virsh 命令是指 virsh 后面跟的第一个命令行参数。本文我们以 <code>virsh helloworld</code> 为例教大家如何添加一个 helloworld 命令。</p><h3 id="增添-helloworld-函数-cmdHelloWorld"><a href="#增添-helloworld-函数-cmdHelloWorld" class="headerlink" title="增添 helloworld 函数 cmdHelloWorld"></a>增添 helloworld 函数 cmdHelloWorld</h3><p>命令的响应函数是 <code>cmdHelloWorld</code>。也就是执行 <code>virsh helloworld</code> 后将调用的函数。</p><p>这个函数由 virsh 进程调用，最终调用 <code>cmdHelloWorld</code>。</p><p><code>cmdHelloWorld</code> 再调用 RPC 与计算结点的守护进程 libvirtd 交互。</p><h3 id="为-helloworld-增添新的命令行参数"><a href="#为-helloworld-增添新的命令行参数" class="headerlink" title="为 helloworld 增添新的命令行参数"></a>为 helloworld 增添新的命令行参数</h3><p><code>virsh helloworld</code> 后我们设置了以下几个命令行参数：</p><ul><li>  <code>--local</code>：表示与本地的 libvirtd 相连。</li><li>  <code>--help</code>：显示帮助信息。</li></ul><p>libvirt 描述命令行参数是用 <code>vshCmdOptDef</code> 数组表示，也就是 <code>--local</code> 要添加到 <code>vshCmdOptDef</code> 数组中。</p><p>而 <code>virsh helloworld --help</code> 要显示的信息添加到 <code>vshCmdInfo</code> 数组中。</p><h3 id="相应代码实现"><a href="#相应代码实现" class="headerlink" title="相应代码实现"></a>相应代码实现</h3><h4 id="命令行参数实现"><a href="#命令行参数实现" class="headerlink" title="命令行参数实现"></a>命令行参数实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static const vshCmdInfo info_helloworld[] = &#123;</span><br><span class="line">    &#123;.name = &quot;help&quot;,</span><br><span class="line">     .data = N_(&quot;Print Hello World&quot;)&#125;,</span><br><span class="line">    &#123;.name = NULL&#125;</span><br><span class="line">&#125;;</span><br><span class="line">static const vshCmdOptDef opts_helloworld[] = &#123;</span><br><span class="line">    &#123;.name = &quot;local&quot;,</span><br><span class="line">     .type = VSH_OT_BOOL,</span><br><span class="line">     .help = N_(&quot;print Hello World in local.&quot;)&#125;,</span><br><span class="line">    &#123;.name = NULL&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>vshCmdOptDef opts_helloworld[]</code>：表示的是 <code>virsh helloworld</code> 后要接的两个命令行参数的描述。 <code>vshCmdInfo info_helloworld[]</code>: 是 <code>virsh helloworld --help</code> 所显示的描述打印。</p><h4 id="cmdHelloWorld-实现"><a href="#cmdHelloWorld-实现" class="headerlink" title="cmdHelloWorld 实现"></a>cmdHelloWorld 实现</h4><p>为了让示例程序最简单化，我们把virsh helloworld 的工作就是打印hello world字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static bool</span><br><span class="line">cmdHelloWorld(vshControl *ctl, const vshCmd *cmd)</span><br><span class="line">&#123;</span><br><span class="line">    bool ret = false;</span><br><span class="line">    char *buffer;</span><br><span class="line">    if (!vshCommandOptBool(cmd, &quot;local&quot;))</span><br><span class="line">        goto cleanup;</span><br><span class="line">    vshPrintExtra(ctl, _(&quot;hello, world\n&quot;));</span><br><span class="line">    ret = true;</span><br><span class="line">    cleanup:</span><br><span class="line">        return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="把-helloworld-命令添加进-vshCmdDef-domManagementCmds-中"><a href="#把-helloworld-命令添加进-vshCmdDef-domManagementCmds-中" class="headerlink" title="把 helloworld 命令添加进 vshCmdDef domManagementCmds[] 中"></a>把 helloworld 命令添加进 vshCmdDef domManagementCmds[] 中</h4><p>virsh 命令的命令行和处理函数都要注册到 <code>domManagementCmds[]</code> 中。</p><p>我们把刚刚添加的数据结构 <code>vshCmdOptDef</code>、<code>vshCmdInfo</code> 还有处理函数 <code>cmdHelloWorld</code> 添加到 <code>domManagementCmds[]</code> 中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const vshCmdDef domManagementCmds[] = &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#123;.name = &quot;helloworld&quot;,</span><br><span class="line">    .handler = cmdHelloWorld,</span><br><span class="line">    .opts = opts_helloworld,</span><br><span class="line">    .info = info_helloworld,</span><br><span class="line">    .flags = 0</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="编译、调试并运行新增的命令"><a href="#编译、调试并运行新增的命令" class="headerlink" title="编译、调试并运行新增的命令"></a>编译、调试并运行新增的命令</h3><p>centos 佩带的 libvirt 的 src.rpm 包的编译使用的是 spec 文件, 执行 <code>rpmbuild -ba libvirt.spec</code> 的时候会把配置、编译一气合成。</p><p>但当我们对自己修改的 libvirt 代码配置的时候，最好不要用 centos 的 spec 里的配置，如果按照 spec 里的配置，在启动我们的 libvirtd 的时候还要先执行 <code>systemctl stop libvirtd</code> 把系统的 libvirtd 的进程停掉。</p><p>所以下面分享一下我自己配置和调试 libvirt 的技巧。</p><h4 id="配置、编译和安装过程"><a href="#配置、编译和安装过程" class="headerlink" title="配置、编译和安装过程"></a>配置、编译和安装过程</h4><p>配置不加任何参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br></pre></td></tr></table></figure><p>编译就不用多说了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j 50</span><br></pre></td></tr></table></figure><p>后面这步很重要，每次编译后，都要重新卸载再进行安装，否则新编译的代码可能不会出现在 libvirtd 当中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make uninstall</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h4 id="手动启动-libvirtd"><a href="#手动启动-libvirtd" class="headerlink" title="手动启动 libvirtd"></a>手动启动 libvirtd</h4><p>libvirtd 是 libvirt 的守护进程，libvirt 的 API 接口几乎都是通过 RPC 调用链接到 libvirtd。virsh 命令就像一个 client 端，libvirtd 是服务端，virsh 的执行需要依靠 libvirtd。所以我们需要把 libvirtd 手动的拉起来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./daemon/libvirtd &amp;</span><br></pre></td></tr></table></figure><h4 id="使用的virsh-文件的路径"><a href="#使用的virsh-文件的路径" class="headerlink" title="使用的virsh 文件的路径"></a>使用的virsh 文件的路径</h4><p>使用 <code>./tools/.libs/virsh</code> 命令行执行。</p><p>注意，用 gdb 跟踪时使用 <code>./tools/.libs/virsh</code>，不要使用 <code>./tools/virsh</code>，因为 <code>./tools/virsh</code> 只是个脚本。</p><h4 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h4><p>执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># virsh helloworld --local</span><br><span class="line">hello, world</span><br></pre></td></tr></table></figure><h2 id="添加一个-API-接口"><a href="#添加一个-API-接口" class="headerlink" title="添加一个 API 接口"></a>添加一个 API 接口</h2><p>上面我们讲过了创建 libvirt API 接口的完整步骤，并且讲述了添加一个新的 virsh 命令的步骤。</p><p>但是添加的 virsh 命令并没有调用 API 接口。而真正的 virsh 命令一般都是借助 libvirt 的 API 接口来完成的。</p><p>下面就为大家介绍如何添加一个 API 接口，并且介绍 API 接口是如何通过 RPC 调用与守护进程 libvirtd 通信的。</p><h3 id="完整的-API-函数流程"><a href="#完整的-API-函数流程" class="headerlink" title="完整的 API 函数流程"></a>完整的 API 函数流程</h3><p><img src="8ce7f2070a2b17bade2e4cad7e74f0a6f903685dad6421e6b9a5485e573979b9.png" alt="picture 0">  </p><h3 id="添加-virConnectHelloWorld-函数"><a href="#添加-virConnectHelloWorld-函数" class="headerlink" title="添加 virConnectHelloWorld 函数"></a>添加 virConnectHelloWorld 函数</h3><h4 id="libvirt-domain-c"><a href="#libvirt-domain-c" class="headerlink" title="libvirt-domain.c"></a>libvirt-domain.c</h4><p>上一节中实现的 <code>cmdHelloWorld</code> 函数没有调用任何 libvirt API。</p><p>但实际上 virsh 命令都是调用 API 函数来实现功能的，同时这个文件里的函数也会给上层业务调用。</p><p>例如在云服务上创建虚机都是直接调用 <code>virDomainCreateXML</code> 函数，并不是通过 <code>virsh create aaa.xml</code> 这种方式。</p><p>下面给出 <code>cmdHelloWorld</code> 的完整实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">extern int virConnectHelloWorld(virConnectPtr dconn, char **printout);</span><br><span class="line"></span><br><span class="line">static bool</span><br><span class="line">cmdHelloWorld(vshControl *ctl, const vshCmd *cmd)</span><br><span class="line">&#123;</span><br><span class="line">    bool ret = false;</span><br><span class="line">    virshControlPtr priv = ctl-&gt;privData;</span><br><span class="line">    char *printout = NULL;</span><br><span class="line">    </span><br><span class="line">    if (!vshCommandOptBool(cmd, &quot;local&quot;))</span><br><span class="line">        goto cleanup;</span><br><span class="line"></span><br><span class="line">    if(virConnectHelloWorld(priv-&gt;conn, &amp;printout) &lt; 0) &#123;</span><br><span class="line">        vshError(ctl, _(&quot;Failed to say HelloWorld&quot;));</span><br><span class="line">        goto cleanup;</span><br><span class="line">    &#125;</span><br><span class="line">    vshPrintExtra(ctl, _(&quot;%s&quot;), printout);</span><br><span class="line">    ret = true;</span><br><span class="line">cleanup:</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="src-libvirt-public-syms"><a href="#src-libvirt-public-syms" class="headerlink" title="src/libvirt_public.syms"></a>src/libvirt_public.syms</h4><p>在 <code>virsh-domain.c</code> 中加入了 <code>virConnectHelloWorld</code> 的函数声明，但在编译过程中还是会报错。原因是要在 <code>libvirt_public.syms</code> 文件中加入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LIBVIRT_7.3.0 &#123;</span><br><span class="line">    global:</span><br><span class="line">        virConnectHelloWorld;</span><br><span class="line">&#125; LIBVIRT_7.2.0;</span><br></pre></td></tr></table></figure><h2 id="添加一个-RPC-调用"><a href="#添加一个-RPC-调用" class="headerlink" title="添加一个 RPC 调用"></a>添加一个 RPC 调用</h2><h3 id="添加-RPC-client-调用"><a href="#添加-RPC-client-调用" class="headerlink" title="添加 RPC client 调用"></a>添加 RPC client 调用</h3><p>libvirt API 完整的函数流程中是要通过 RPC 调用和 libvirtd 进行通信。</p><p>下面我们把实现完全的代码贴上:</p><p><code>virConnectHelloWorld</code> 的入参 <code>virConnectPtr dconn</code> 中的 driver 是一个很关键的字段。描述了 RPC 调用的 client 端和 server 端回调函数的声明。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct _virConnect &#123;</span><br><span class="line">    ...</span><br><span class="line">    virHypervisorDriverPtr driver;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="src-driver-hypervisor-h"><a href="#src-driver-hypervisor-h" class="headerlink" title="src/driver-hypervisor.h"></a>src/driver-hypervisor.h</h4><p>给 <code>_virHypervisorDriver</code> 加入 <code>virDrvConnectHelloWorld</code> 字段，并且添加 <code>virDrvConnectHelloWorld</code> 的定义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef int</span><br><span class="line">(*virDrvConnectHelloWorld) (virConnectPtr conn, char **printout);</span><br><span class="line"></span><br><span class="line">struct _virHypervisorDriver &#123;</span><br><span class="line">    ...</span><br><span class="line">    virDrvConnectHelloWorld connectHelloWorld;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="src-remote-remote-driver-c"><a href="#src-remote-remote-driver-c" class="headerlink" title="src/remote/remote_driver.c"></a>src/remote/remote_driver.c</h4><p>在 <code>driver-hypervisor.h</code> 中只是给 <code>_virHypervisorDriver</code> 添加了一个字段，还需要给出 RPC 调用的实现函数。</p><p><code>virConnectHelloWorld</code> 函数作为 RPC 的 client 端的实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">static int remoteConnectHelloWorld(virConnectPtr conn, char **printout)</span><br><span class="line">&#123;</span><br><span class="line">    int rv = -1;</span><br><span class="line">    remote_connect_hello_world_ret ret;</span><br><span class="line">    struct private_data *priv = conn-&gt;privateData;</span><br><span class="line">    remoteDriverLock(priv);</span><br><span class="line">    memset(&amp;ret, 0, sizeof(ret));</span><br><span class="line">    if (call(conn, priv, 0, REMOTE_PROC_CONNECT_HELLO_WORLD,</span><br><span class="line">            (xdrproc_t) xdr_void,</span><br><span class="line">            (char *) NULL,</span><br><span class="line">            (xdrproc_t) xdr_remote_connect_hello_world_ret,</span><br><span class="line">            (char *) &amp;ret) == -1)</span><br><span class="line">        goto done;</span><br><span class="line">    if (ret.printout == NULL)</span><br><span class="line">        goto error;</span><br><span class="line">    *printout = ret.printout;</span><br><span class="line">    rv = 0;</span><br><span class="line">done:</span><br><span class="line">    remoteDriverUnlock(priv);</span><br><span class="line">    return rv;</span><br><span class="line">error:</span><br><span class="line">    rv = -1;</span><br><span class="line">    goto done;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static virHypervisorDriver hypervisor_driver = &#123;</span><br><span class="line">    ...</span><br><span class="line">    .connectHelloWorld = remoteConnectHelloWorld, /* 7.3.0 */</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>函数的开头使用了 RPC 请求的返回值结构体 <code>remote_connect_hello_world_ret</code>，这个结构体的定义是自动生成的，模板会在 <code>remote_protocol.x</code> 中给出。</p><p>call 函数中的入参 <code>REMOTE_PROC_CONNECT_HELLO_WORLD</code> 是RPC 请求调用号。也是在 <code>remote_protocol.x</code> 中添加。</p><p>最后从 <code>ret.printout</code> 取出来自 libvirtd 返回的字符串。</p><p>注意: 给 <code>hypervisor_driver-&gt;connectHelloWorld</code> 赋值时, 后面的 <code>/* 7.3.0 */</code> 版本号必须要加上不然 <code>hvsupport.pl</code> 在执行的时候会报错。</p><h4 id="src-remote-remote-protocol-x"><a href="#src-remote-remote-protocol-x" class="headerlink" title="./src/remote/remote_protocol.x"></a>./src/remote/remote_protocol.x</h4><p>增添 <code>remote_connect_hello_world_ret</code> 的模板，并且在 <code>enum remote_procedure</code> 的枚举类型中给出 RPC 号的具体数值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct remote_connect_hello_world_ret &#123;</span><br><span class="line">    remote_nonnull_string printout;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">enum remote_procedure &#123;</span><br><span class="line">    /**</span><br><span class="line">    * @generate: none</span><br><span class="line">    * @acl: connect:read</span><br><span class="line">    */</span><br><span class="line">    REMOTE_PROC_CONNECT_HELLO_WORLD = 700</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="src-rpc-gendispatch-pl"><a href="#src-rpc-gendispatch-pl" class="headerlink" title="./src/rpc/gendispatch.pl"></a>./src/rpc/gendispatch.pl</h4><p>以上几个文件会被 <code>gendispatch.pl</code> 文件解析自动生成 <code>remote_protocol.h</code>，<code>remote_protocol.c</code> 和 <code>remote_daemon_dispatch_stubs.h</code> 文件。</p><p>这个文件在运行时会检查上面内容添加是否齐全。</p><h3 id="添加-RPC-server-端调用"><a href="#添加-RPC-server-端调用" class="headerlink" title="添加 RPC server 端调用"></a>添加 RPC server 端调用</h3><p>libvirtd 充当 RPC 调用的 server 端，<code>remoteDispatchConnectHelloWorld</code> 函数是由 libvirtd 执行的，作为 server 端的响应函数。</p><h4 id="src-remote-remote-daemon-dispatch-stubs-h"><a href="#src-remote-remote-daemon-dispatch-stubs-h" class="headerlink" title="src/remote/remote_daemon_dispatch_stubs.h"></a>src/remote/remote_daemon_dispatch_stubs.h</h4><p>增添了 <code>remote_protocol.x</code> 编译后系统会自动生成 <code>remote_dispatch.h</code> 文件，并自其中自动生成 server 端 RPC 处理函数：<code>remoteDispatchConnectHelloWorldHelper</code>。</p><p>同时 <code>remote_daemon_dispatch_stubs.h</code> 中会添加 <code>remoteDispatchConnectHelloWorld</code> 函数声明。</p><p><code>remoteDispatchConnectHelloWorld</code> 函数作为 RPC server 端的响应函数需要在 <code>remote_daemon_dispatch_stubs.h</code> 中自己手动实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static int</span><br><span class="line">remoteDispatchConnectHelloWorld(virNetServerPtr server ATTRIBUTE_UNUSED,</span><br><span class="line">                            virNetServerClientPtr client ATTRIBUTE_UNUSED,</span><br><span class="line">                            virNetMessagePtr msg ATTRIBUTE_UNUSED,</span><br><span class="line">                            virNetMessageErrorPtr rerr,</span><br><span class="line">                            remote_connect_hello_world_ret *ret)</span><br><span class="line">&#123;</span><br><span class="line">    char *printout = NULL;</span><br><span class="line">    int rv = -1;</span><br><span class="line">    struct daemonClientPrivate *priv =</span><br><span class="line">    virNetServerClientGetPrivateData(client);</span><br><span class="line">    if (!priv-&gt;conn) &#123;</span><br><span class="line">        virReportError(VIR_ERR_INTERNAL_ERROR, &quot;%s&quot;, _(&quot;connection not open&quot;));</span><br><span class="line">        goto cleanup;</span><br><span class="line">    &#125;</span><br><span class="line">    rv = virConnectHelloWorld(priv-&gt;conn, &amp;printout);</span><br><span class="line">    if(rv &lt; 0)</span><br><span class="line">        goto cleanup;</span><br><span class="line">    ret-&gt;printout = printout;</span><br><span class="line">cleanup:</span><br><span class="line">    if (rv &lt; 0)</span><br><span class="line">        virNetMessageSaveError(rerr);</span><br><span class="line">    return rv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="src-qemu-qemu-driver-c"><a href="#src-qemu-qemu-driver-c" class="headerlink" title="src/qemu/qemu_driver.c"></a>src/qemu/qemu_driver.c</h4><p>libvirtd 是 RPC 的 server 端，<code>virConnectHelloWorld</code> 采用的 <code>connectHelloWorld</code> 回调函数与 RPC clinet 端不同。</p><p>这里要新添加一个 <code>qemuConnectHelloWorld</code> 函数作为 RPC server 端的处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static int qemuConnectHelloWorld(virConnectPtr conn, char **printout)</span><br><span class="line">&#123;</span><br><span class="line">    if(VIR_STRDUP(*printout, &quot;hello, world&quot;) &lt; 0)</span><br><span class="line">        return -1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static virHypervisorDriver qemuHypervisorDriver = &#123;</span><br><span class="line">    ...</span><br><span class="line">    .connectHelloWorld = qemuConnectHelloWorld, /* 7.3.0 */</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行结果-1"><a href="#执行结果-1" class="headerlink" title="执行结果"></a>执行结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># virsh helloworld --local</span><br><span class="line">hello, world</span><br></pre></td></tr></table></figure><p>执行结果与第 3 节一样，但不同的是这次的 “hello, world” 是 virsh 命令通过 RPC 调用从 libvirtd 守护进程中拿过来的。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;libvirt-简介&quot;&gt;&lt;a href=&quot;#libvirt-简介&quot; class=&quot;headerlink&quot; title=&quot;libvirt 简介&quot;&gt;&lt;/a&gt;libvirt 简介&lt;/h2&gt;&lt;p&gt;libvirt 是用于管理虚拟化平台的开源API、后台程序和管理工具。&lt;/p&gt;</summary>
    
    
    
    <category term="LIBVIRT" scheme="https://rma-shuyu.github.io/categories/LIBVIRT/"/>
    
    
    <category term="virsh" scheme="https://rma-shuyu.github.io/tags/virsh/"/>
    
  </entry>
  
</feed>
