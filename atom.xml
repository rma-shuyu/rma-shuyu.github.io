<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rma&#39;s Blog</title>
  
  <subtitle>Stay hungry, stay foolish</subtitle>
  <link href="https://rma-shuyu.github.io/atom.xml" rel="self"/>
  
  <link href="https://rma-shuyu.github.io/"/>
  <updated>2023-01-27T12:06:26.878Z</updated>
  <id>https://rma-shuyu.github.io/</id>
  
  <author>
    <name>rma-shuyu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>gitstats使用介绍</title>
    <link href="https://rma-shuyu.github.io/2022/12/05/gitstats%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/"/>
    <id>https://rma-shuyu.github.io/2022/12/05/gitstats%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/</id>
    <published>2022-12-05T11:51:50.000Z</published>
    <updated>2023-01-27T12:06:26.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>进一步来讲，Gitstats它是一个git仓库分析软件，它可以检查仓库并生成历史数据的统计信息。可以帮助你查看git仓库的提交状态，根据不同维度分析计算，并自动生成数据图表。<br>官网介绍：<a href="http://gitstats.sourceforge.net/">http://gitstats.sourceforge.net/</a></p><span id="more"></span><p>当前GitStats所生成统计信息常用分为如下几类：<br><strong>常规的统计</strong>：文件总数，行数，提交量，作者数。<br><strong>活跃性</strong>：每天中每小时的、每周中每天的、每周中每小时的、每年中每月的、每年的提交量。<br><strong>作者数</strong>：列举所有的作者（提交数，第一次提交日期，最近一次的提交日期），并按月和年来划分。<br><strong>文件数</strong>：按日期划分，按扩展名名划分。<br><strong>行数</strong>：按日期划分。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//mac osx</span><br><span class="line">brew install gnuplot</span><br><span class="line">//centos linux</span><br><span class="line">yum install gnuplot</span><br><span class="line">//ubuntu linux</span><br><span class="line">apt install gnuplot</span><br></pre></td></tr></table></figure><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://github.com/hoxu/gitstats.git</span><br><span class="line"><span class="built_in">cd</span> gitstats</span><br><span class="line">./gitstats 你的项目的位置 生成统计的文件夹位置</span><br></pre></td></tr></table></figure><h2 id="展示"><a href="#展示" class="headerlink" title="展示"></a>展示</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> 生成统计的文件夹位置</span><br><span class="line">python3 -m http.server 8090</span><br></pre></td></tr></table></figure><h2 id="qemu示例"><a href="#qemu示例" class="headerlink" title="qemu示例"></a>qemu示例</h2><p>如下图所示。首先，在gitstats上提供了全局的统计数据报告，包括：</p><p><strong>报告产生时间及产生所花费的时间</strong>：如花费了710秒<br><strong>报告所覆盖的时间</strong>：如2003-02-19 to 2022-12-05<br><strong>年龄</strong>：该repo的年纪，如“7230天，其中5918天是活跃天.”<br><strong>文件数及代码</strong>：如：9256个文件，3130k行代码。<br><strong>总提交数</strong>：如：99776，平均每天13.8个<br><strong>作者数</strong>：如2160，每个作者平均提交次数46.2次。<br><img src="efbe731981191bf53d5ddccfb0d2ceddc68787753068302bb6b07ae3325161c7.png" alt="图 6">  </p><p>除此之外，还包括了：</p><ol><li>时间维度的效率分析：每天中每小时的、每周中每天的、每周中每小时的、每年中每月的、每年的提交量。<br><img src="e3f27ccfddf1d938e78059ed84dbee1e10029e531785d1c35dbd64ec9fd176e4.png" alt="图 7"><br><img src="c2af9654b130fbe357f60fc7d9b0d9f688909b0fd41cc173ed06bc9609bb03db.png" alt="图 8"><br><img src="fe0f04ea5472dac1bb45ef27504cf61e91c71154babe868b1d90ae164ffa901c.png" alt="图 9"><br><img src="d8a4aee3fe667a3fe39257feb14b177fc098d0952bfb78cf7a3139ac838adb95.png" alt="图 10"><br><img src="b04a8580c65f01373f091389a9c3a7d3138acb8aaf002e9a21a5ae8b8587acf5.png" alt="图 11"><br><img src="226d67aed51a110fa818c54b82b4e74434e727c354565bcf779b19f6ba31dd55.png" alt="图 12">  </li></ol><ol start="2"><li>提交者维度的活跃度统计：列举所有的作者（提交数，第一次提交日期，最近一次的提交日期），并按月和年来划分。<br><img src="1245268c1062710ee022fb12149e82705b29e4591c0e3aacb7fd844462b8bdaf.png" alt="图 13">  </li></ol><ol start="3"><li><p>按照文件数：按日期划分，按扩展名名划分。<br><img src="1bacc00060ca63e9f239802a91e68849e4337457d9909e0754eee5fc1664a4ee.png" alt="图 14">  </p></li><li><p>根据提交行数或提交的tag来统计。<br><img src="29853f0496e7b26c4d69af48e2d863367a2c96ee70534f89698a31e3f49b03a4.png" alt="图 15">  </p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;进一步来讲，Gitstats它是一个git仓库分析软件，它可以检查仓库并生成历史数据的统计信息。可以帮助你查看git仓库的提交状态，根据不同维度分析计算，并自动生成数据图表。&lt;br&gt;官网介绍：&lt;a href=&quot;http://gitstats.sourceforge.net/&quot;&gt;http://gitstats.sourceforge.net/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="GIT" scheme="https://rma-shuyu.github.io/categories/GIT/"/>
    
    
    <category term="git" scheme="https://rma-shuyu.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>centos8安装pprof</title>
    <link href="https://rma-shuyu.github.io/2022/11/22/centos8%E5%AE%89%E8%A3%85pprof/"/>
    <id>https://rma-shuyu.github.io/2022/11/22/centos8%E5%AE%89%E8%A3%85pprof/</id>
    <published>2022-11-22T12:24:34.000Z</published>
    <updated>2023-01-27T12:06:26.873Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这是谷歌的一个linux下性能测试的小工具。可以简单快速的发现程序的性能瓶颈。</p><span id="more"></span><h2 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /etc/*release</span></span><br><span class="line">CentOS Linux release 8.4.2105</span><br><span class="line">NAME=<span class="string">&quot;CentOS Linux&quot;</span></span><br><span class="line">VERSION=<span class="string">&quot;8&quot;</span></span><br><span class="line">ID=<span class="string">&quot;centos&quot;</span></span><br><span class="line">ID_LIKE=<span class="string">&quot;rhel fedora&quot;</span></span><br><span class="line">VERSION_ID=<span class="string">&quot;8&quot;</span></span><br><span class="line">PLATFORM_ID=<span class="string">&quot;platform:el8&quot;</span></span><br><span class="line">PRETTY_NAME=<span class="string">&quot;CentOS Linux 8&quot;</span></span><br><span class="line">ANSI_COLOR=<span class="string">&quot;0;31&quot;</span></span><br><span class="line">CPE_NAME=<span class="string">&quot;cpe:/o:centos:centos:8&quot;</span></span><br><span class="line">HOME_URL=<span class="string">&quot;https://centos.org/&quot;</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">&quot;https://bugs.centos.org/&quot;</span></span><br><span class="line">CENTOS_MANTISBT_PROJECT=<span class="string">&quot;CentOS-8&quot;</span></span><br><span class="line">CENTOS_MANTISBT_PROJECT_VERSION=<span class="string">&quot;8&quot;</span></span><br><span class="line">CentOS Linux release 8.4.2105</span><br><span class="line">CentOS Linux release 8.4.2105</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="安装编译工具"><a href="#安装编译工具" class="headerlink" title="安装编译工具"></a>安装编译工具</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc</span><br><span class="line">yum -y install gcc-c++</span><br><span class="line">yum -y install make</span><br><span class="line">yum install -y autoconf automake libtool</span><br><span class="line">yum install -y wget</span><br></pre></td></tr></table></figure><p><strong>提示</strong>：<br>安装过程中出现以下错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum -y install gcc</span></span><br><span class="line">Last metadata expiration check: 0:15:41 ago on Wed 23 Nov 2022 03:56:44 PM CST.</span><br><span class="line">Error: </span><br><span class="line"> Problem: package gcc-8.5.0-4.el8_5.x86_64 requires glibc-devel &gt;= 2.2.90-12, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libpthread.so.0, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libdl.so.2, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libm.so.6, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libresolv.so.2, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires librt.so.1, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libutil.so.1, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libBrokenLocale.so.1, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libanl.so.1, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libthread_db.so.1, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.x86_64 requires glibc = 2.28-164.el8, but none of the providers can be installed</span><br><span class="line">  - glibc-2.28-164.el8.i686 has inferior architecture</span><br><span class="line">  - cannot install both glibc-2.28-164.el8.x86_64 and glibc-2.28-203.el8.x86_64</span><br><span class="line">  - package glibc-gconv-extra-2.28-203.el8.x86_64 requires glibc(x86-64) = 2.28-203.el8, but none of the providers can be installed</span><br><span class="line">  - cannot install the best candidate <span class="keyword">for</span> the job</span><br><span class="line">  - problem with installed package glibc-gconv-extra-2.28-203.el8.x86_64</span><br><span class="line">(try to add <span class="string">&#x27;--allowerasing&#x27;</span> to <span class="built_in">command</span> line to replace conflicting packages or <span class="string">&#x27;--skip-broken&#x27;</span> to skip uninstallable packages or <span class="string">&#x27;--nobest&#x27;</span> to use not only best candidate packages)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>则执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc --allowerasing</span><br></pre></td></tr></table></figure><p>可执行文件对应的安装包查找：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum whatprovides autoreconf</span><br></pre></td></tr></table></figure><p><img src="c5dd6168b78ccf54aa38d65134cb70a21c2adb250934fcf9c448d9d29d12851c.png" alt="图 26"><br>则安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y autoconf</span><br></pre></td></tr></table></figure><h2 id="安装libunwind"><a href="#安装libunwind" class="headerlink" title="安装libunwind"></a>安装libunwind</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/libunwind/libunwind/archive/v0.99.tar.gz</span><br><span class="line">tar -xvf v0.99.tar.gz</span><br><span class="line"><span class="built_in">cd</span> libunwind-0.99</span><br><span class="line">autoreconf --force -v --install</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h2 id="安装perftools"><a href="#安装perftools" class="headerlink" title="安装perftools"></a>安装perftools</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/gperftools/gperftools/releases/download/gperftools-2.6.1/gperftools-2.6.1.tar.gz</span><br><span class="line">tar -xvf gperftools-2.6.1.tar.gz </span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h2 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h2><p><img src="e25c28feccf7bac3e0f524dec94e4a1f7f2d5db678b0fd3366351056d111b03a.png" alt="图 27">  </p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;这是谷歌的一个linux下性能测试的小工具。可以简单快速的发现程序的性能瓶颈。&lt;/p&gt;</summary>
    
    
    
    <category term="LINUX" scheme="https://rma-shuyu.github.io/categories/LINUX/"/>
    
    
    <category term="linux" scheme="https://rma-shuyu.github.io/tags/linux/"/>
    
    <category term="pprof" scheme="https://rma-shuyu.github.io/tags/pprof/"/>
    
  </entry>
  
  <entry>
    <title>base64编解码</title>
    <link href="https://rma-shuyu.github.io/2022/11/16/base64%E7%BC%96%E8%A7%A3%E7%A0%81/"/>
    <id>https://rma-shuyu.github.io/2022/11/16/base64%E7%BC%96%E8%A7%A3%E7%A0%81/</id>
    <published>2022-11-16T12:16:29.000Z</published>
    <updated>2023-01-27T12:06:26.868Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，是一种基于<strong>64个可打印字符</strong>来表示二进制数据的方法</p><span id="more"></span><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ol><li>Base64一般用于在 HTTP协议下传输二进制数据，由于 HTTP协议是文本协议，所以在HTTP协议下传输二进制数据需要将二进制数据转换为字符数据。然而直接转换是不行的。因为网络传输只能传输可打印字符，需要用Base64将不可显字符转换为可显字符</li><li>可用于将明文通过AES加密后，通过Base64将不可显的加密字符转换为可显字符</li></ol><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>base64编码表<br><img src="c617678b70d6a249a3556d4a16a4d49fbd9dc22f4be59bda0d0e52450c20be76.png" alt="图 2"> </p><p>由于base64编码是将编码前的3*8位数据，分解成4个6位的数据，所以经过base64编码后的字符串长度是4的倍数。<br>但往往我们进行编码的数据长度并不是3的倍数，这就造成了“编码”后的位数不为4的倍数，</p><p>比如Brisk共5×8=40位，以6位为一组可以分为7组，这样“编码”后就有7个字符，<br>但base64编码后的字符长度应该是4的倍数，显然这里就出问题了，那么怎么办呢？<br>前面的不可以抛弃掉，所以就只有“追加”了，所以Brisk经过base64编码后的长度应该是8个字符，而第8个编码后的字符是’=’，</p><p>再比如对单个字符a进行base64编码，由于它的长度不是3的倍数，以3个字节为一组它只能分一组，再以6位为一位它只能分两组，所以经过“编码”后它的长度是2，但base64编码后的个数应该是4的倍数，所以它的长度应该是4，所以在后面补上两个‘=’,</p><p>由于一个数求余3后有三个不同的结果，0、1、2，所以在对一个数据进行base64进行编码后它的长度为： </p><ol><li><p>当进行编码的数据长度是3的倍数时，len=strlen(str_in)/3*4;</p></li><li><p>当进行编码的数据长度不是3的倍数时，len=(strlen(str_in)/3+1)*4;</p></li></ol><p>我们以Brisk这个例子来说明一下base64编码的过程。首先我们以3个字符为一组将Brisk进行分组，Brisk被氛围两组：Bri 和 sk；然后我们取出这两个分组中每个字节的ASCII码，B:66 r:114 i:105 s:115 k:107。它们对应的二进制数为  B:01000010 r:01110010 i:01101001 s:01110011 k:01101011；</p><p>第一组，我们以6位为一组对每一个3字节分组进行再分组就变成了010000 100111 001001 101001。所对应的十进制数是16 39 9 41，对应base64表中的结果是 Q n J p；</p><p>第二组，011100 110110 101100(不够补0)，所以对应的十进制数是 28 54 44，对应base64表中的结果是 c 2 s，最终结果为QnJpc2s=（因为第二组“编码”后只有三个字节）。</p><p>解码的过程是一个逆过程，我们将经过编码后的字符按4个字符为一组，然后对照base64表得到相应的十进制数，再将其通过拆分和组合，组成3个8位数据，这个数据就是解码后的数据，下面给一个c语言实现编码和解码的代码。</p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">encode_string</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> * src, <span class="type">int</span> len,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">char</span> * dest, <span class="type">unsigned</span> <span class="type">char</span> * base64, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> one;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> two;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> thr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> fou;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ( len &gt;= <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        one = src[<span class="number">0</span>] &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        two = ( ( src[<span class="number">0</span>] &amp; <span class="number">0x03</span> ) &lt;&lt; <span class="number">4</span> ) | ( src[<span class="number">1</span>] &gt;&gt; <span class="number">4</span> );</span><br><span class="line">        thr = ( ( src[<span class="number">1</span>] &amp; <span class="number">0x0F</span> ) &lt;&lt; <span class="number">2</span> ) | ( src[<span class="number">2</span>] &gt;&gt; <span class="number">6</span> );</span><br><span class="line">        fou = src[<span class="number">2</span>] &amp; <span class="number">0x3F</span>;</span><br><span class="line"> </span><br><span class="line">        *( dest + index++ ) = base64[one];</span><br><span class="line">        *( dest + index++ ) = base64[two];</span><br><span class="line">        *( dest + index++ ) = base64[thr];</span><br><span class="line">        *( dest + index   ) = base64[fou];</span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( len == <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        one = src[<span class="number">0</span>] &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        two = ( ( src[<span class="number">0</span>] &amp; <span class="number">0x03</span>) &lt;&lt; <span class="number">4</span> ) | ( src[<span class="number">1</span>] &gt;&gt; <span class="number">4</span> );</span><br><span class="line">        thr = ( src[<span class="number">1</span>] &amp; <span class="number">0x0F</span> ) &lt;&lt; <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">        *( dest + index++ ) = base64[one];</span><br><span class="line">        *( dest + index++ ) = base64[two];</span><br><span class="line">        *( dest + index++ ) = base64[thr];</span><br><span class="line">        *( dest + index   ) = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( len == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        one = src[<span class="number">0</span>] &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        two = ( src[<span class="number">0</span>] &amp; <span class="number">0x03</span> ) &lt;&lt; <span class="number">4</span>;</span><br><span class="line"> </span><br><span class="line">        *( dest + index++ ) = base64[one];</span><br><span class="line">        *( dest + index++ ) = base64[two];</span><br><span class="line">        *( dest + index++ ) = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">        *( dest + index   ) = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;Unknow length\n&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">base64_encode</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> * src, <span class="type">int</span> src_len, <span class="type">char</span> * dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> base64[] = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( src_len &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> step = encode_string( src, src_len, (<span class="type">unsigned</span> <span class="type">char</span> *)dest, base64, index );</span><br><span class="line"> </span><br><span class="line">        index += <span class="number">4</span>;</span><br><span class="line">        src += step;</span><br><span class="line">src_len -= step;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    *( dest + index ) = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">create_array</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> * <span class="built_in">array</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( index  = <span class="number">0</span>; index &lt; <span class="number">123</span>; index += <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( index == <span class="number">0x2B</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            *( <span class="built_in">array</span> + index ) = <span class="number">0x3E</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( index == <span class="number">0x2F</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            *( <span class="built_in">array</span> + index ) = <span class="number">0x3F</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( index &gt;= <span class="number">0x30</span> &amp;&amp; index &lt;= <span class="number">0x39</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            *( <span class="built_in">array</span> + index ) = <span class="number">0x34</span> + index - <span class="number">0x30</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( index == <span class="number">0x3D</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            *( <span class="built_in">array</span> + index ) = <span class="number">0x00</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( index &gt;= <span class="number">0x41</span> &amp;&amp; index &lt;= <span class="number">0x5A</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            *( <span class="built_in">array</span> + index ) = index - <span class="number">0x41</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( index &gt;= <span class="number">0x61</span> &amp;&amp; index &lt;= <span class="number">0x7A</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            *( <span class="built_in">array</span> + index ) = <span class="number">0x1A</span> + index - <span class="number">0x61</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            *( <span class="built_in">array</span> + index ) = <span class="number">0x00</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    *( <span class="built_in">array</span> + <span class="number">123</span> ) = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">decode_string</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * src, <span class="type">unsigned</span> <span class="type">char</span> * dest, <span class="type">unsigned</span> <span class="type">char</span> * <span class="built_in">array</span>, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> step;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> one;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> two;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> thr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( src[<span class="number">3</span>] == <span class="string">&#x27;=&#x27;</span> &amp;&amp; src[<span class="number">2</span>] == <span class="string">&#x27;=&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        one = ( <span class="built_in">array</span>[src[<span class="number">0</span>]] &lt;&lt; <span class="number">2</span> ) | ( <span class="built_in">array</span>[src[<span class="number">1</span>]] &gt;&gt; <span class="number">4</span> );</span><br><span class="line">        *( dest + index ) = one;</span><br><span class="line"> </span><br><span class="line">        step = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( src[<span class="number">3</span>] == <span class="string">&#x27;=&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        one = ( <span class="built_in">array</span>[src[<span class="number">0</span>]] &lt;&lt; <span class="number">2</span> ) | ( <span class="built_in">array</span>[src[<span class="number">1</span>]] &gt;&gt; <span class="number">4</span> );</span><br><span class="line">        two = ( ( <span class="built_in">array</span>[src[<span class="number">1</span>]] &amp; <span class="number">0x0F</span> ) &lt;&lt; <span class="number">4</span> ) | ( <span class="built_in">array</span>[src[<span class="number">2</span>]] &gt;&gt; <span class="number">2</span> );</span><br><span class="line"> </span><br><span class="line">        *( dest + index++ ) = one;</span><br><span class="line">        *( dest + index   ) = two;</span><br><span class="line"> </span><br><span class="line">        step = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        one = ( <span class="built_in">array</span>[src[<span class="number">0</span>]] &lt;&lt; <span class="number">2</span> ) | ( <span class="built_in">array</span>[src[<span class="number">1</span>]] &gt;&gt; <span class="number">4</span> );</span><br><span class="line">        two = ( ( <span class="built_in">array</span>[src[<span class="number">1</span>]] &amp; <span class="number">0x0F</span> ) &lt;&lt; <span class="number">4</span> ) | ( <span class="built_in">array</span>[src[<span class="number">2</span>]] &gt;&gt; <span class="number">2</span> );</span><br><span class="line">        thr = ( <span class="built_in">array</span>[src[<span class="number">2</span>]] &lt;&lt; <span class="number">6</span> ) | <span class="built_in">array</span>[src[<span class="number">3</span>]];</span><br><span class="line"> </span><br><span class="line">        *( dest + index++ ) = one;</span><br><span class="line">        *( dest + index++ ) = two;</span><br><span class="line">        *( dest + index   ) = thr;</span><br><span class="line"> </span><br><span class="line">        step = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">base64_decode</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * src, <span class="type">unsigned</span> <span class="type">char</span> * dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> <span class="built_in">array</span>[<span class="number">124</span>];</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>( <span class="built_in">array</span>, <span class="number">0x00</span>, <span class="number">124</span> );</span><br><span class="line">    create_array( <span class="built_in">array</span> );</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> ( *src )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> step = decode_string( src, dest, <span class="built_in">array</span>, index );</span><br><span class="line"> </span><br><span class="line">        index += step;</span><br><span class="line">        src   += <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    *( dest + index ) = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>测试代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> *src_str = <span class="string">&quot;abcsjdhs123134&quot;</span>;</span><br><span class="line"><span class="type">int</span> src_str_len = <span class="built_in">strlen</span>(src_str);</span><br><span class="line"><span class="type">char</span> *out_buf = (<span class="type">char</span> *)<span class="built_in">malloc</span>(src_str_len * <span class="number">2</span>);</span><br><span class="line"><span class="type">char</span> *out_decode_buf = (<span class="type">char</span> *)<span class="built_in">malloc</span>(src_str_len * <span class="number">2</span>);</span><br><span class="line">base64_encode(src_str, src_str_len, out_buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;src_str:       %s\n&quot;</span>, src_str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;base64_encode: %s\n&quot;</span>, out_buf);</span><br><span class="line"></span><br><span class="line">base64_decode(out_buf, out_decode_buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;base64_decode: %s\n&quot;</span>, out_decode_buf);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果展示<br><img src="8106a76ff5b18e8cda5e478736125efeec53fcaf86e1744cf4fe4accaaf6a38b.png" alt="图 3">  </p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，是一种基于&lt;strong&gt;64个可打印字符&lt;/strong&gt;来表示二进制数据的方法&lt;/p&gt;</summary>
    
    
    
    <category term="BASE64" scheme="https://rma-shuyu.github.io/categories/BASE64/"/>
    
    
    <category term="BASE64" scheme="https://rma-shuyu.github.io/tags/BASE64/"/>
    
  </entry>
  
  <entry>
    <title>OpenSSL之AES用法</title>
    <link href="https://rma-shuyu.github.io/2022/11/16/OpenSSL%E4%B9%8BAES%E7%94%A8%E6%B3%95/"/>
    <id>https://rma-shuyu.github.io/2022/11/16/OpenSSL%E4%B9%8BAES%E7%94%A8%E6%B3%95/</id>
    <published>2022-11-16T11:20:44.000Z</published>
    <updated>2023-01-27T12:06:26.847Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>AES是<strong>对称</strong>加密的算法，使用128、192 和 256 位密钥，将被加密数据划分为128位（16字节）一块，然后使用某种加密模式进行加密</p><p>关键词：<br><strong>块大小</strong>：16字节<br><strong>密钥长度</strong>：AES算法下，key的长度有三种：128、192和256 bits。</p><span id="more"></span><p><strong>加密模式</strong>：AES属于块加密（Block Cipher），块加密中有CBC、ECB、CTR、OFB、CFB等几种工作模式。<br><strong>填充模式</strong>：</p><ul><li>NoPadding，数据长度不对齐时使用”\0”填充，否则不填充</li><li>PKCS7Padding，假设数据长度需要填充n(n&gt;0)个字节才对齐，那么填充n个字节，每个字节都是n;如果数据本身就已经对齐了，则填充一块长度为块大小的数据，每个字节都是块大小</li><li>PKCS5Padding，PKCS7Padding的子集，块大小固定为8字节。</li></ul><p>AES加密，如果输入是16<em>n字节，NoPadding填充的情况下，输出和输入相同；有填充的情况下，输出是16</em>（n+1）。<br>如果输入不是16字节整数倍，而是大于16<em>n小于16</em>（n+1），NoPadding填充情况下（只能是CFB和OFB模式），输出和输入长度相同；其他情况下，输出长度是16*（n+1）</p><h2 id="设置加解密接口"><a href="#设置加解密接口" class="headerlink" title="设置加解密接口"></a>设置加解密接口</h2><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><ul><li><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">AES_set_encrypt_key</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *userKey, <span class="type">const</span> <span class="type">int</span> bits,</span></span><br><span class="line"><span class="params">                        AES_KEY *key)</span>;</span><br></pre></td></tr></table></figure></li><li><p>函数作用<br>设定加密用的Key</p></li><li><p>参数说明<br><code>userKey</code>： 密钥数值；<br><code>bits</code>：密钥长度，以bit为单位，如果密钥数字是16个字节，则此参数值应为128；<br><code>key</code>： AES_KEY对象指针；<br><code>返回值</code>：<br>0: 成功<br>1: userkey，key为空<br>2: 密钥长度不是128，192，256</p></li></ul><h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><ul><li><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">AES_set_decrypt_key</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *userKey, <span class="type">const</span> <span class="type">int</span> bits,</span></span><br><span class="line"><span class="params">                        AES_KEY *key)</span>;</span><br></pre></td></tr></table></figure></li><li><p>函数作用<br>设定解密用的Key</p></li><li><p>参数说明<br><code>userKey</code>： 密钥数值；<br><code>bits</code>：密钥长度，以bit为单位，如果密钥数字是16个字节，则此参数值应为128；<br><code>key</code>： AES_KEY对象指针；<br><code>返回值</code>：<br>0: 成功<br>1: userkey，key为空<br>2: 密钥长度不是128，192，256</p></li></ul><h2 id="常用加密模式"><a href="#常用加密模式" class="headerlink" title="常用加密模式"></a>常用加密模式</h2><h3 id="CBC"><a href="#CBC" class="headerlink" title="CBC"></a>CBC</h3><ul><li><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AES_cbc_encrypt</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *in, <span class="type">unsigned</span> <span class="type">char</span> *out,</span></span><br><span class="line"><span class="params">                     <span class="type">size_t</span> length, <span class="type">const</span> AES_KEY *key,</span></span><br><span class="line"><span class="params">                     <span class="type">unsigned</span> <span class="type">char</span> *ivec, <span class="type">const</span> <span class="type">int</span> enc)</span>;</span><br></pre></td></tr></table></figure></li><li><p>函数作用：<br>AES加密/解密单个数据块（16个字节），CBC模式</p></li><li><p>参数说明：<br><code>in</code>： 需要加密/解密的数据；<br><code>out</code>： 计算后输出的数据；<br><code>length</code>： 数据长度（这里不包含初始向量数据长度）<br><code>key</code>：密钥<br><code>ivec</code>： 初始向量（一般为16字节全0）<br><code>enc</code>：<br>AES_ENCRYPT：代表加密<br>AES_DECRYPT：代表解密</p></li></ul><h3 id="ECB"><a href="#ECB" class="headerlink" title="ECB"></a>ECB</h3><ul><li><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AES_ecb_encrypt</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *in, <span class="type">unsigned</span> <span class="type">char</span> *out,</span></span><br><span class="line"><span class="params">                     <span class="type">const</span> AES_KEY *key, <span class="type">const</span> <span class="type">int</span> enc)</span>;</span><br></pre></td></tr></table></figure></li><li><p>函数作用：<br>AES加密/解密单个数据块（16个字节），ECB模式</p></li><li><p>参数说明：<br><code>in</code>: 需要加密/解密的数据；<br><code>out</code>: 计算后输出的数据；<br><code>key</code>: 密钥<br><code>enc</code>:<br>AES_ENCRYPT：代表加密<br>AES_DECRYPT：代表解密</p></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>测试代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TEST_ORG_DATA <span class="string">&quot;this is test aes data!&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">remove_padding</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buff, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">ch = buff[size - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; ch; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (buff[size - i] != buff[size - (i + <span class="number">1</span>)])</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buff[size - i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">str2hex</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *ret = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> str_len = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> sret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">ret = (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="built_in">malloc</span>(str_len / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; str_len; i += <span class="number">2</span>)</span><br><span class="line">sret = <span class="built_in">sscanf</span>(str + i, <span class="string">&quot;%2hhX&quot;</span>, &amp;ret[i/<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">if</span> (sret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">free</span>(ret);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">decode_aes128_ecb</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *encrypt_buff, <span class="type">int</span> buf_len, <span class="type">unsigned</span> <span class="type">char</span> **out)</span></span><br><span class="line">&#123;</span><br><span class="line">AES_KEY aes;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *decrypt_buff = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *key = str2hex(<span class="string">&quot;B1CFC3D787DC4511&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;aes, <span class="number">0</span>, <span class="keyword">sizeof</span>(aes));</span><br><span class="line">decrypt_buff = (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="built_in">malloc</span>((<span class="type">size_t</span>)buf_len);</span><br><span class="line"></span><br><span class="line">AES_set_decrypt_key(key, <span class="number">128</span>, &amp;aes);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; buf_len; i += AES_BLOCK_SIZE) &#123;</span><br><span class="line">AES_ecb_encrypt</span><br><span class="line">(encrypt_buff + i, decrypt_buff + i, &amp;aes, AES_DECRYPT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">remove_padding(decrypt_buff, buf_len);</span><br><span class="line"></span><br><span class="line">*out = decrypt_buff;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">encode_aes128_ecb</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> **out, <span class="type">int</span> *out_len)</span></span><br><span class="line">&#123;</span><br><span class="line">AES_KEY aes;</span><br><span class="line"><span class="type">int</span> data_len = <span class="built_in">strlen</span>(TEST_ORG_DATA);</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="type">json_error_t</span> error;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *encrypt_buff = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *decrypt_buff = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *key = str2hex(<span class="string">&quot;B1CFC3D787DC4511&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pad_len = AES_BLOCK_SIZE - (data_len % AES_BLOCK_SIZE);</span><br><span class="line">encrypt_buff = (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="built_in">malloc</span>(data_len + pad_len);</span><br><span class="line">decrypt_buff = (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="built_in">malloc</span>(data_len + pad_len);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(decrypt_buff, TEST_ORG_DATA, data_len);</span><br><span class="line"><span class="built_in">memset</span>(decrypt_buff+data_len, pad_len, pad_len);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;aes, <span class="number">0</span>, <span class="keyword">sizeof</span>(aes));</span><br><span class="line">AES_set_encrypt_key(key, <span class="number">128</span>, &amp;aes);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; data_len+pad_len; i += AES_BLOCK_SIZE) &#123;</span><br><span class="line">AES_ecb_encrypt</span><br><span class="line">(decrypt_buff + i, encrypt_buff + i, &amp;aes, AES_ENCRYPT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*out = encrypt_buff;</span><br><span class="line">*out_len = data_len+pad_len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;data before aes :\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, TEST_ORG_DATA);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *en_code = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> en_code_len;</span><br><span class="line">encode_aes128_ecb(&amp;en_code, &amp;en_code_len);</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *de_code = <span class="literal">NULL</span>;</span><br><span class="line">decode_aes128_ecb(en_code, en_code_len, &amp;de_code);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;data after aes encode and decode :\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, de_code);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试结果：<br><img src="4f8473f4df84e1e65d147bd49af24b1cf87b702462969287d002e093c7cfd2e1.png" alt="图 2">  </p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;AES是&lt;strong&gt;对称&lt;/strong&gt;加密的算法，使用128、192 和 256 位密钥，将被加密数据划分为128位（16字节）一块，然后使用某种加密模式进行加密&lt;/p&gt;
&lt;p&gt;关键词：&lt;br&gt;&lt;strong&gt;块大小&lt;/strong&gt;：16字节&lt;br&gt;&lt;strong&gt;密钥长度&lt;/strong&gt;：AES算法下，key的长度有三种：128、192和256 bits。&lt;/p&gt;</summary>
    
    
    
    <category term="OPENSSL" scheme="https://rma-shuyu.github.io/categories/OPENSSL/"/>
    
    
    <category term="AES" scheme="https://rma-shuyu.github.io/tags/AES/"/>
    
    <category term="OPENSSL" scheme="https://rma-shuyu.github.io/tags/OPENSSL/"/>
    
  </entry>
  
  <entry>
    <title>vscode C/C++插件失效</title>
    <link href="https://rma-shuyu.github.io/2022/03/08/vscode-C-C-%E6%89%A9%E5%B1%95%E5%A4%B1%E6%95%88/"/>
    <id>https://rma-shuyu.github.io/2022/03/08/vscode-C-C-%E6%89%A9%E5%B1%95%E5%A4%B1%E6%95%88/</id>
    <published>2022-03-08T12:52:23.000Z</published>
    <updated>2023-01-27T12:06:26.961Z</updated>
    
    <content type="html"><![CDATA[<h2 id="故障描述"><a href="#故障描述" class="headerlink" title="故障描述"></a>故障描述</h2><ul><li><p>打开项目工程后，过一段时间发现c/c++跳转失效</p></li><li><p>智能感知系统无法补全</p><span id="more"></span><p><img src="519c09334a7130005ac97e63cdabaf9c19ba78d30a0f27ca94b9996163e6c766.png" alt="图 2">  </p></li><li><p>并且，大纲无法加载符号<br><img src="da3040ce2169ddc0a1346799e3e1facd423444da76f7dbea51e27ca9dfbbe7bf.png" alt="图 3">  </p></li></ul><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><ol><li>网上搜索常见的C/C++插件失效的解决办法，发现都与设置的无关</li><li>终端发现cpptools的cpu利用率飙高，此时可初步判定为项目工程导致符号搜索循环引用了<br><img src="ff1e27ff7a065a725a164291088616be25e5896c385e74c612d9752da83b90a7.png" alt="图 4">  </li><li>排查发现项目中的一个文件目录比较大，将其删除后，发现C/C++插件可以继续运作，并且cpptools不会再cpu冲高<br><img src="6ed60181060f1615ed24a7ae6effdcb19a2e4f33cb2d7a9bf19dd88d309d17b6.png" alt="图 9">  </li></ol><h2 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h2><ul><li>由于编译依赖该文件目录，删除后会影响编译效率；</li><li>通过设置exclude将C/C++插件不再搜索该文件目录，修改如下：</li><li>文件-》首选项-》设置，搜索exclude，找到C_Cpp.files.exclude<br><img src="7d723ba1046f38ce1447de4b059ac2e65085ee66c1b440dd4d0984b9c1a4109c.png" alt="图 6">  </li><li>添加文件目录名至exclude配置中<br><img src="fb11eed86c18bcb5fe46c797e0e15411e3ee5c6adbb4a6e9cd41565a26218c7d.png" alt="图 8">  </li><li>重新加载vscode后，该C/C++插件失效问题得以解决</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;故障描述&quot;&gt;&lt;a href=&quot;#故障描述&quot; class=&quot;headerlink&quot; title=&quot;故障描述&quot;&gt;&lt;/a&gt;故障描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;打开项目工程后，过一段时间发现c/c++跳转失效&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;智能感知系统无法补全&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="VSCODE" scheme="https://rma-shuyu.github.io/categories/VSCODE/"/>
    
    
    <category term="vscode" scheme="https://rma-shuyu.github.io/tags/vscode/"/>
    
  </entry>
  
  <entry>
    <title>omitempty关键字</title>
    <link href="https://rma-shuyu.github.io/2021/05/10/omitempty%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://rma-shuyu.github.io/2021/05/10/omitempty%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2021-05-10T12:27:18.000Z</published>
    <updated>2023-01-27T12:06:26.921Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>结构体有标签名时, 标签名会作为key进行<code>json.Marshal</code>，<br>当结构体某个字段没有赋值时，<code>json.Marshal</code>无需序列化该字段，此时就要用到<code>omitempty</code>关键字</p></blockquote><span id="more"></span><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> address <span class="keyword">struct</span> &#123;</span><br><span class="line">Street  <span class="type">string</span> <span class="string">`json:&quot;street&quot;`</span>  <span class="comment">// 街道</span></span><br><span class="line">Ste     <span class="type">string</span> <span class="string">`json:&quot;suite&quot;`</span>   <span class="comment">// 单元（可以不存在）</span></span><br><span class="line">City    <span class="type">string</span> <span class="string">`json:&quot;city&quot;`</span>    <span class="comment">// 城市</span></span><br><span class="line">State   <span class="type">string</span> <span class="string">`json:&quot;state&quot;`</span>   <span class="comment">// 州/省</span></span><br><span class="line">Zipcode <span class="type">string</span> <span class="string">`json:&quot;zipcode&quot;`</span> <span class="comment">// 邮编</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">data := <span class="string">`&#123;</span></span><br><span class="line"><span class="string">  &quot;street&quot;: &quot;200 Larkin St&quot;,</span></span><br><span class="line"><span class="string">  &quot;city&quot;: &quot;San Francisco&quot;,</span></span><br><span class="line"><span class="string">  &quot;state&quot;: &quot;CA&quot;,</span></span><br><span class="line"><span class="string">  &quot;zipcode&quot;: &quot;94102&quot;</span></span><br><span class="line"><span class="string">  &#125;`</span></span><br><span class="line">addr := <span class="built_in">new</span>(address)</span><br><span class="line">json.Unmarshal([]<span class="type">byte</span>(data), &amp;addr)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理了一番 addr 变量...</span></span><br><span class="line"></span><br><span class="line">addressBytes, _ := json.MarshalIndent(addr, <span class="string">&quot;&quot;</span>, <span class="string">&quot;    &quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, <span class="type">string</span>(addressBytes))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到运行结果如下：<br><img src="4cd9ff01cf4568afd7712d2d5d2023d88c4746fa0ebcb6d3dd41a6be20744048.png" alt="图 1">  </p><p>多了一行 “suite”: “”, ，而这则信息在原本的 json 数据中是没有的，此时再序列化有点浪费字节空间了</p><p>可以将结构体定义为:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> address <span class="keyword">struct</span> &#123;</span><br><span class="line">Street  <span class="type">string</span> <span class="string">`json:&quot;street&quot;`</span></span><br><span class="line">Ste     <span class="type">string</span> <span class="string">`json:&quot;suite,omitempty&quot;`</span></span><br><span class="line">City    <span class="type">string</span> <span class="string">`json:&quot;city&quot;`</span></span><br><span class="line">State   <span class="type">string</span> <span class="string">`json:&quot;state&quot;`</span></span><br><span class="line">Zipcode <span class="type">string</span> <span class="string">`json:&quot;zipcode&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到预期结果：<br><img src="ef7e859c46b3844078ad6c9800293e6b95a28ffabaa6f20fd9dfa09694841688.png" alt="图 2">  </p><h2 id="陷阱"><a href="#陷阱" class="headerlink" title="陷阱"></a>陷阱</h2><p>带来方便的同时，使用 omitempty 也有些小陷阱，一个是该关键字无法忽略掉嵌套结构体。还是拿地址类型说事，这回我们想要往地址结构体中加一个新 field 来表示经纬度，如果缺乏相关的数据，暂时可以忽略。新的结构体定义如下所示</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> address <span class="keyword">struct</span> &#123;</span><br><span class="line">Street     <span class="type">string</span>     <span class="string">`json:&quot;street&quot;`</span></span><br><span class="line">Ste        <span class="type">string</span>     <span class="string">`json:&quot;suite,omitempty&quot;`</span></span><br><span class="line">City       <span class="type">string</span>     <span class="string">`json:&quot;city&quot;`</span></span><br><span class="line">State      <span class="type">string</span>     <span class="string">`json:&quot;state&quot;`</span></span><br><span class="line">Zipcode    <span class="type">string</span>     <span class="string">`json:&quot;zipcode&quot;`</span></span><br><span class="line">Coordinate coordinate <span class="string">`json:&quot;coordinate,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"> 你们BNBH美好关于jbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb</span><br><span class="line"><span class="keyword">type</span> coordinate <span class="keyword">struct</span> &#123;</span><br><span class="line">Lat <span class="type">float64</span> <span class="string">`json:&quot;latitude&quot;`</span></span><br><span class="line">Lng <span class="type">float64</span> <span class="string">`json:&quot;longitude&quot;`</span></span><br><span class="line">&#125;bhnmjvjhgmbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb</span><br></pre></td></tr></table></figure><p>读入原来的地址数据，处理后序列化输出，我们就会发现即使加上了 omitempty 关键字，输出的 json 还是带上了一个空的坐标信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;street&quot;</span>: <span class="string">&quot;200 Larkin St&quot;</span>,</span><br><span class="line">    <span class="string">&quot;city&quot;</span>: <span class="string">&quot;San Francisco&quot;</span>,</span><br><span class="line">    <span class="string">&quot;state&quot;</span>: <span class="string">&quot;CA&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zipcode&quot;</span>: <span class="string">&quot;94102&quot;</span>,</span><br><span class="line">    <span class="string">&quot;coordinate&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;latitude&quot;</span>: <span class="number">0</span>,</span><br><span class="line">        <span class="string">&quot;longitude&quot;</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了达到我们想要的效果，可以把坐标定义为指针类型，这样 Golang 就能知道一个指针的“空值”是多少了，否则面对一个我们自定义的结构， Golang 是猜不出我们想要的空值的。于是有了如下的结构体定义</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> address <span class="keyword">struct</span> &#123;</span><br><span class="line">Street     <span class="type">string</span>      <span class="string">`json:&quot;street&quot;`</span></span><br><span class="line">Ste        <span class="type">string</span>      <span class="string">`json:&quot;suite,omitempty&quot;`</span></span><br><span class="line">City       <span class="type">string</span>      <span class="string">`json:&quot;city&quot;`</span></span><br><span class="line">State      <span class="type">string</span>      <span class="string">`json:&quot;state&quot;`</span></span><br><span class="line">Zipcode    <span class="type">string</span>      <span class="string">`json:&quot;zipcode&quot;`</span></span><br><span class="line">Coordinate *coordinate <span class="string">`json:&quot;coordinate,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> coordinate <span class="keyword">struct</span> &#123;</span><br><span class="line">Lat <span class="type">float64</span> <span class="string">`json:&quot;latitude&quot;`</span></span><br><span class="line">Lng <span class="type">float64</span> <span class="string">`json:&quot;longitude&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相应的输出为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;street&quot;</span>: <span class="string">&quot;200 Larkin St&quot;</span>,</span><br><span class="line">    <span class="string">&quot;city&quot;</span>: <span class="string">&quot;San Francisco&quot;</span>,</span><br><span class="line">    <span class="string">&quot;state&quot;</span>: <span class="string">&quot;CA&quot;</span>,</span><br><span class="line">    <span class="string">&quot;zipcode&quot;</span>: <span class="string">&quot;94102&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一个“陷阱”是，对于用 omitempty 定义的 field ，如果给它赋的值恰好等于默认空值的话，在转为 json 之后也不会输出这个 field 。比如说上面定义的经纬度坐标结构体，如果我们将经纬度两个 field 都加上 omitempty</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> coordinate <span class="keyword">struct</span> &#123;</span><br><span class="line">Lat <span class="type">float64</span> <span class="string">`json:&quot;latitude,omitempty&quot;`</span></span><br><span class="line">Lng <span class="type">float64</span> <span class="string">`json:&quot;longitude,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们对非洲几内亚湾的“原点坐标”非常感兴趣，于是编写了如下代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">cData := <span class="string">`&#123;</span></span><br><span class="line"><span class="string">&quot;latitude&quot;: 0.0,</span></span><br><span class="line"><span class="string">&quot;longitude&quot;: 0.0</span></span><br><span class="line"><span class="string">&#125;`</span></span><br><span class="line">c := <span class="built_in">new</span>(coordinate)</span><br><span class="line">json.Unmarshal([]<span class="type">byte</span>(cData), &amp;c)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 具体处理逻辑...</span></span><br><span class="line"></span><br><span class="line">coordinateBytes, _ := json.MarshalIndent(c, <span class="string">&quot;&quot;</span>, <span class="string">&quot;    &quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, <span class="type">string</span>(coordinateBytes))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终我们得到了一个<br><code>&#123;&#125;</code></p><p>这个坐标消失不见了！但我们的设想是，如果一个地点没有经纬度信息，则悬空，这没有问题，但对于“原点坐标”，我们在确切知道它的经纬度的情况下，（0.0, 0.0）仍然被忽略了。正确的写法也是将结构体内的定义改为指针</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> coordinate <span class="keyword">struct</span> &#123;</span><br><span class="line">Lat *<span class="type">float64</span> <span class="string">`json:&quot;latitude,omitempty&quot;`</span></span><br><span class="line">Lng *<span class="type">float64</span> <span class="string">`json:&quot;longitude,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样空值就从 float64 的 0.0 变为了指针类型的 nil ，我们就能看到正确的经纬度输出。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;latitude&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&quot;longitude&quot;</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;结构体有标签名时, 标签名会作为key进行&lt;code&gt;json.Marshal&lt;/code&gt;，&lt;br&gt;当结构体某个字段没有赋值时，&lt;code&gt;json.Marshal&lt;/code&gt;无需序列化该字段，此时就要用到&lt;code&gt;omitempty&lt;/code&gt;关键字&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="GO" scheme="https://rma-shuyu.github.io/categories/GO/"/>
    
    
    <category term="go" scheme="https://rma-shuyu.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>json包使用</title>
    <link href="https://rma-shuyu.github.io/2021/05/09/json%E5%8C%85%E4%BD%BF%E7%94%A8/"/>
    <id>https://rma-shuyu.github.io/2021/05/09/json%E5%8C%85%E4%BD%BF%E7%94%A8/</id>
    <published>2021-05-09T12:27:18.000Z</published>
    <updated>2023-01-27T12:06:26.907Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>使用 <code>json.Unmarshal</code> 和 <code>json.Marshal</code> 函数，可以将 JSON 格式的二进制数据反序列化到指定的 Go 结构体中，以及将 Go 结构体序列化为二进制流。</p></blockquote><span id="more"></span><h2 id="Map转JSON"><a href="#Map转JSON" class="headerlink" title="Map转JSON"></a>Map转JSON</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">// map里面</span></span><br><span class="line">map1 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span> &#123;</span><br><span class="line"><span class="string">&quot;name&quot;</span>:<span class="string">&quot;张三&quot;</span>,</span><br><span class="line"><span class="string">&quot;age&quot;</span>:<span class="string">&quot;18&quot;</span>,</span><br><span class="line"><span class="string">&quot;home&quot;</span>:<span class="string">&quot;北京&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将map解析成json</span></span><br><span class="line">json1, err := json.Marshal(map1)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;json1: %s  类型: %T \n&quot;</span>,json1,json1)</span><br><span class="line">  </span><br><span class="line">map2 := <span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span> &#123;</span><br><span class="line"><span class="string">&quot;fruit&quot;</span>: &#123;<span class="string">&quot;香蕉&quot;</span>,<span class="string">&quot;葡萄&quot;</span>&#125;,</span><br><span class="line"><span class="string">&quot;coder&quot;</span>:&#123;<span class="string">&quot;PHP&quot;</span>,<span class="string">&quot;Go&quot;</span>,<span class="string">&quot;Java&quot;</span>&#125;,</span><br><span class="line"><span class="string">&quot;likes&quot;</span>:&#123;<span class="string">&quot;打游戏&quot;</span>,<span class="string">&quot;看动漫&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">json2, err := json.Marshal(map2)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;json2: %s  类型: %T \n&quot;</span>,json2,json2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">json1: &#123;&quot;age&quot;:&quot;18&quot;,&quot;home&quot;:&quot;北京&quot;,&quot;name&quot;:&quot;张三&quot;&#125;  类型: []uint8 </span></span><br><span class="line"><span class="comment">json2: &#123;&quot;coder&quot;:[&quot;PHP&quot;,&quot;Go&quot;,&quot;Java&quot;],&quot;fruit&quot;:[&quot;香蕉&quot;,&quot;葡萄&quot;],&quot;likes&quot;:[&quot;打游戏&quot;,&quot;看动漫&quot;]&#125;  类型: []uint8 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="Json转Map"><a href="#Json转Map" class="headerlink" title="Json转Map"></a>Json转Map</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">json1 := <span class="string">`&#123;&quot;age&quot;:&quot;18&quot;,&quot;home&quot;:&quot;北京&quot;,&quot;name&quot;:&quot;张三&quot;&#125;`</span></span><br><span class="line">map1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">err := json.Unmarshal([]<span class="type">byte</span>(json1), &amp;map1)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;map1: %v T: %T\n&quot;</span>,map1,map1)</span><br><span class="line"></span><br><span class="line">json2 := <span class="string">`&#123;&quot;coder&quot;:[&quot;PHP&quot;,&quot;Go&quot;,&quot;Java&quot;],&quot;fruit&quot;:[&quot;香蕉&quot;,&quot;葡萄&quot;],&quot;likes&quot;:[&quot;打游戏&quot;,&quot;看动漫&quot;]&#125;`</span></span><br><span class="line">map2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]<span class="type">string</span>)</span><br><span class="line">err = json.Unmarshal([]<span class="type">byte</span>(json2), &amp;map2)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;map2: %v T: %T\n&quot;</span>,map2,map2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">map1: map[age:18 home:北京 name:张三] T: map[string]string</span></span><br><span class="line"><span class="comment">map2: map[coder:[PHP Go Java] fruit:[香蕉 葡萄] likes:[打游戏 看动漫]] T: map[string][]string</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="结构体转JSON"><a href="#结构体转JSON" class="headerlink" title="结构体转JSON"></a>结构体转JSON</h2><p><strong>无字段标签</strong><br>结构体转换成JSON在开发中经常会用到。encoding/json包是通过反射机制来实现编解码的，因此结构体必须导出所转换的字段，没有导出的字段不会被encoding/json包解析。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">Age <span class="type">int</span></span><br><span class="line">Class <span class="type">string</span></span><br><span class="line">phone <span class="type">string</span> <span class="comment">//小写字段，则不是会导出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">s := Student&#123;</span><br><span class="line">Name:  <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">Age:   <span class="number">17</span>,</span><br><span class="line">Class: <span class="string">&quot;三年级&quot;</span>,</span><br><span class="line">phone: <span class="string">&quot;17600112222&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">json1, err := json.Marshal(s)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;json: %s \n&quot;</span>,json1)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 json: &#123;&quot;Name&quot;:&quot;张三&quot;,&quot;Age&quot;:17,&quot;Class&quot;:&quot;三年级&quot;&#125; </span></span><br></pre></td></tr></table></figure><p><strong>有字段标签</strong><br>json包在解析结构体时，如果遇到key为JSON的字段标签，则会按照一定规则解析该标签。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 定义一个学生结构体</span></span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">Name  <span class="type">string</span> <span class="string">`json:&quot;_name&quot;`</span> <span class="comment">// 字段标签的语法</span></span><br><span class="line">Age   <span class="type">int</span>    <span class="string">`json:&quot;_age&quot;`</span></span><br><span class="line">Class <span class="type">string</span> <span class="string">`json:&quot;-&quot;`</span> <span class="comment">// 不解析</span></span><br><span class="line">Phone <span class="type">string</span> <span class="string">`json:&quot;phone&quot;`</span></span><br><span class="line">Score <span class="type">float32</span> <span class="comment">// 没有标签时，则用字段名</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">s := Student&#123;</span><br><span class="line">Name:  <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">Age:   <span class="number">17</span>,</span><br><span class="line">Class: <span class="string">&quot;三年级&quot;</span>,</span><br><span class="line">Phone: <span class="string">&quot;17600112222&quot;</span>,</span><br><span class="line">Score: <span class="number">88.5</span>,</span><br><span class="line">&#125;</span><br><span class="line">json1, err := json.Marshal(s)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;json: %s \n&quot;</span>,json1)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出-&gt; json: &#123;&quot;_name&quot;:&quot;张三&quot;,&quot;_age&quot;:17,&quot;phone&quot;:&quot;17600112222&quot;,&quot;Score&quot;:88.5&#125;</span></span><br></pre></td></tr></table></figure><p><strong>规则总结</strong></p><ul><li>有标签名时,标签名会作为key</li><li>没有标签时,则会使用字段名。</li><li>有标签名时，但是标签名的值为-，则不会导出</li></ul><p><strong>匿名字段</strong><br>json包在解析匿名字段时，会将匿名字段的字段当成该结构体的字段处理。<br>而不会嵌套</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">Name  <span class="type">string</span> <span class="string">`json:&quot;_name&quot;`</span></span><br><span class="line">Age   <span class="type">int</span>    <span class="string">`json:&quot;_age&quot;`</span></span><br><span class="line">    Top <span class="comment">// 匿名字段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Top <span class="keyword">struct</span> &#123;</span><br><span class="line">Sort <span class="type">int</span> <span class="string">`json:&quot;sort&quot;`</span></span><br><span class="line">Score <span class="type">float64</span></span><br><span class="line">Class <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">s := Student&#123;</span><br><span class="line">Name: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">Age:  <span class="number">18</span>,</span><br><span class="line">Top:  Top&#123;<span class="number">1</span>,<span class="number">99.5</span>,<span class="string">&quot;一年级&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">json1, err := json.Marshal(s)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;json: %s \n&quot;</span>,json1)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出-&gt; json: &#123;&quot;_name&quot;:&quot;张三&quot;,&quot;_age&quot;:18,&quot;sort&quot;:1,&quot;Score&quot;:99.5,&quot;Class&quot;:&quot;一年级&quot;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="JSON转结构体"><a href="#JSON转结构体" class="headerlink" title="JSON转结构体"></a>JSON转结构体</h2><p>JSON可以转换成结构体。同编码一样，json包是通过反射机制来实现解码的，因此结构体必须导出所转换的字段，不导出的字段不会被json包解析。另外解析时不区分大小写。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> Student <span class="keyword">struct</span> &#123;</span><br><span class="line">Name  <span class="type">string</span> <span class="string">`json:&quot;_name&quot;`</span></span><br><span class="line">Age   <span class="type">int</span>    <span class="string">`json:&quot;_age&quot;`</span></span><br><span class="line">    Top <span class="comment">// 匿名字段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Top <span class="keyword">struct</span> &#123;</span><br><span class="line">Sort <span class="type">int</span> <span class="string">`json:&quot;sort&quot;`</span></span><br><span class="line">Score <span class="type">float64</span></span><br><span class="line">Class <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">student := Student&#123;&#125;</span><br><span class="line">js := <span class="string">`&#123;&quot;_name&quot;:&quot;张三&quot;,&quot;_age&quot;:18,&quot;sort&quot;:1,&quot;Score&quot;:99.5,&quot;Class&quot;:&quot;一年级&quot;&#125;`</span></span><br><span class="line">err := json.Unmarshal([]<span class="type">byte</span>(js), &amp;student)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;v: %+v  t: %T \n&quot;</span>,student,student)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出: v: &#123;Name:张三 Age:18 Top:&#123;Sort:1 Score:99.5 Class:一年级&#125;&#125;  t: main.Student</span></span><br></pre></td></tr></table></figure><h2 id="切片转JSON"><a href="#切片转JSON" class="headerlink" title="切片转JSON"></a>切片转JSON</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">student := []<span class="type">string</span> &#123;</span><br><span class="line"><span class="string">&quot;张三&quot;</span>,</span><br><span class="line"><span class="string">&quot;李四&quot;</span>,</span><br><span class="line"><span class="string">&quot;小米&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">marshal, err := json.Marshal(student)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;v :%s T:%T&quot;</span>,marshal,marshal)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出 v :[&quot;张三&quot;,&quot;李四&quot;,&quot;小米&quot;] T:[]uint8</span></span><br></pre></td></tr></table></figure><h2 id="JSON转切片"><a href="#JSON转切片" class="headerlink" title="JSON转切片"></a>JSON转切片</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">json1 := <span class="string">`[&quot;张三&quot;,&quot;李四&quot;,&quot;小米&quot;]`</span></span><br><span class="line"><span class="keyword">var</span> sc []<span class="type">string</span></span><br><span class="line">err := json.Unmarshal([]<span class="type">byte</span>(json1), &amp;sc)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;v :%v T:%T&quot;</span>,sc,sc)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出: v :[张三 李四 小米] T:[]string</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;使用 &lt;code&gt;json.Unmarshal&lt;/code&gt; 和 &lt;code&gt;json.Marshal&lt;/code&gt; 函数，可以将 JSON 格式的二进制数据反序列化到指定的 Go 结构体中，以及将 Go 结构体序列化为二进制流。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="GO" scheme="https://rma-shuyu.github.io/categories/GO/"/>
    
    
    <category term="go" scheme="https://rma-shuyu.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>go文件操作</title>
    <link href="https://rma-shuyu.github.io/2021/05/08/go%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <id>https://rma-shuyu.github.io/2021/05/08/go%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</id>
    <published>2021-05-08T12:27:18.000Z</published>
    <updated>2023-01-27T12:06:26.899Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote><p>在Go语言中，文件操作的大多数函数都在os包里面，文件的信息包括文件名、文件大小、修改权限、修改时间等。</p></blockquote><span id="more"></span><h3 id="文件接口属性-FileInfo"><a href="#文件接口属性-FileInfo" class="headerlink" title="文件接口属性(FileInfo)"></a>文件接口属性(FileInfo)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> FileInfo <span class="keyword">interface</span> &#123;</span><br><span class="line"> Name() <span class="type">string</span>       <span class="comment">// 文件名</span></span><br><span class="line"> Size() <span class="type">int64</span>        <span class="comment">// 文件大小</span></span><br><span class="line"> Mode() FileMode     <span class="comment">// 修改权限</span></span><br><span class="line"> ModTime() time.Time <span class="comment">// 最后修改时间</span></span><br><span class="line"> IsDir() <span class="type">bool</span>        <span class="comment">// 判断是否是目录</span></span><br><span class="line"> Sys() <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// 文件的详细信息，获取的值是*syscall.Stat_t类型 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件信息结构体-fileStat"><a href="#文件信息结构体-fileStat" class="headerlink" title="文件信息结构体(fileStat)"></a>文件信息结构体(fileStat)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> fileStat <span class="keyword">struct</span> &#123;</span><br><span class="line"> name    <span class="type">string</span></span><br><span class="line"> size    <span class="type">int64</span></span><br><span class="line"> mode    FileMode</span><br><span class="line"> modTime time.Time</span><br><span class="line"> sys     syscall.Stat_t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fileStat结构体的常用方法汇总"><a href="#fileStat结构体的常用方法汇总" class="headerlink" title="fileStat结构体的常用方法汇总"></a>fileStat结构体的常用方法汇总</h3><table>    <tr>        <th>方法名</th><th>描述</th>    </tr>    <tr>        <td>Name() string</td><td>返回文件名</td>    </tr>    <tr>        <td>IsDir() bool</td><td>判断是否是目录</td>    </tr>    <tr>        <td>Size() int64</td><td>返回文件大小</td>    </tr>    <tr>        <td>Mode() FileMode</td><td>返回文件权限</td>    </tr>    <tr>        <td>ModTime() time.Time</td><td>文件的最后修改时间</td>    </tr>    <tr>        <td>Sys() interface{}</td><td>文件的详细信息，获取的值是*syscall.Stat_t类型</td>    </tr></table><p><strong>使用示例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fp := <span class="string">&quot;./test.txt&quot;</span></span><br><span class="line">fileInfo, err := os.Stat(fp)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;类型: %T\n&quot;</span>, fileInfo)</span><br><span class="line">fmt.Printf(<span class="string">&quot;文件名: %v\n&quot;</span>, fileInfo.Name())</span><br><span class="line">fmt.Printf(<span class="string">&quot;文件大小: %v\n&quot;</span>, fileInfo.Size())</span><br><span class="line">fmt.Printf(<span class="string">&quot;是否为目录: %v\n&quot;</span>, fileInfo.IsDir())</span><br><span class="line">fmt.Printf(<span class="string">&quot;文件权限: %v\n&quot;</span>, fileInfo.Mode())</span><br><span class="line">fmt.Printf(<span class="string">&quot;文件最后修改的时间: %v\n&quot;</span>, fileInfo.ModTime())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><img src="f7ba8d9a73981205670855cc27c8b705258faf5008f71308c710d1f3a28cbfe8.png" alt="图 1">  </p><h2 id="求路径方法"><a href="#求路径方法" class="headerlink" title="求路径方法"></a>求路径方法</h2><p><strong>方法列表</strong><br>方法的所属包: <code>path/filepath</code></p><table>    <tr>        <th>方法名</th><th>描述</th>    </tr>    <tr>        <td>IsAbs(path string) bool</td><td>判断是否是绝对路径</td>    </tr>    <tr>        <td>Rel(basepath, targpath string) (string, error)</td><td>返回一个相对于basepath的路径</td>    </tr>    <tr>        <td>Abs(path string) (string, error)</td><td>返回绝对路径</td>    </tr>    <tr>        <td>Join(elem ...string) string</td><td>拼接路径</td>    </tr></table><p><strong>使用示例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">basePath, _ := filepath.Abs(filepath.Dir(os.Args[<span class="number">0</span>]))</span><br><span class="line">fp1 := <span class="string">&quot;./test.txt&quot;</span></span><br><span class="line">fp2 := <span class="string">&quot;/home/rma/mr_work/go_test/pkg/test.log&quot;</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;当前程序的绝对路径:  %v\n&quot;</span>, basePath)</span><br><span class="line">fmt.Printf(<span class="string">&quot;是绝对路径？: %t\n&quot;</span>, filepath.IsAbs(fp1))</span><br><span class="line"><span class="comment">// 相对路径</span></span><br><span class="line">rel, err := filepath.Rel(basePath, fp2)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;fp2的相对路径:  %v\n&quot;</span>, rel)</span><br><span class="line"><span class="comment">// 绝对路径</span></span><br><span class="line">abs, err := filepath.Abs(fp1)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;fp1的绝对路径:  %s\n&quot;</span>, abs)</span><br><span class="line"><span class="comment">// 拼接路径</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;拼接路径1: %s \n&quot;</span>, path.Join(<span class="string">&quot;/home/Item&quot;</span>, <span class="string">&quot;go&quot;</span>, <span class="string">&quot;study&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><img src="2af4c1123ebb00e55e56c87056a39c3ee9b37ce0175259158bbf541cc6a72d37.png" alt="图 2">  </p><h2 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h2><h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><p><strong>方法列表</strong></p><table>    <tr>        <th>方法名</th><th>描述</th>    </tr>    <tr>        <td>os.Mkdir(name string, perm FileMode) error</td><td>创建名称为name的目录，权限设置是perm</td>    </tr>    <tr>        <td>os.MkdirAll(path string, perm FileMode) error</td><td>根据path创建多级子目录</td>    </tr></table><p><strong>使用示例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">dirName := <span class="string">&quot;./img&quot;</span></span><br><span class="line"><span class="comment">// 创建目录,并分配权限</span></span><br><span class="line">err := os.Mkdir(dirName, os.ModePerm)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(dirName + <span class="string">&quot;  创建成功!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建多级目录</span></span><br><span class="line">dirName2 := <span class="string">&quot;./public/static/css&quot;</span></span><br><span class="line">err = os.MkdirAll(dirName2, os.ModePerm)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(dirName2 + <span class="string">&quot;  创建成功!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><img src="f326d3b1e256fdf20ecc79c9d5e8daef8a114651ae0cc1e934258482bff3db7b.png" alt="图 3">  </p><h3 id="删除目录-文件"><a href="#删除目录-文件" class="headerlink" title="删除目录/文件"></a>删除目录/文件</h3><p><strong>方法列表</strong></p><table>    <tr>        <th>方法名</th><th>描述</th>    </tr>    <tr>        <td>os.Remove(name string) error</td><td>删除名称为name的目录/文件，当目录下有文件或者其他目录会出错</td>    </tr>    <tr>        <td>os.RemoveAll(path string) error error</td><td>根据path删除多级子目录</td>    </tr></table><p><strong>使用示例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">err := os.Remove(<span class="string">&quot;./img&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Remove-&gt; 删除失败: &quot;</span> + err.Error())</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Remove-&gt; 删除成功!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err1 := os.Remove(<span class="string">&quot;./test.log&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Remove-&gt; 删除失败: &quot;</span> + err1.Error())</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Remove-&gt; 删除成功!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err1 = os.Remove(<span class="string">&quot;./public&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Remove-&gt; 删除失败: &quot;</span> + err1.Error())</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;Remove-&gt; 删除成功!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除多级子目录</span></span><br><span class="line">err2 := os.RemoveAll(<span class="string">&quot;./public&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err2 != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;RemoveAll-&gt; 删除失败: &quot;</span> + err2.Error())</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;RemoveAll-&gt; 删除成功!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="162909921ab7efbe9f64ac26c5fd54ca0849730f534838dbf0bfe71ebeb69a34.png" alt="图 4">  </p><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><p><code>os.Create()</code>创建文件，如果文件存在，会将其覆盖。<code>os.Create()</code>本质上调用的是<code>OpenFile</code>, 源码如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Create</span><span class="params">(name <span class="type">string</span>)</span></span> (*File, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, <span class="number">0666</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用示例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fileName := <span class="string">&quot;./file/a.txt&quot;</span></span><br><span class="line"><span class="comment">//如果文件存在,则会覆盖</span></span><br><span class="line">create, err := os.Create(fileName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;创建失败: &quot;</span> + err.Error())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;创建成功! %v\n&quot;</span>, create)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建成功! &amp;&#123;0xc00006e180&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="打开和关闭文件"><a href="#打开和关闭文件" class="headerlink" title="打开和关闭文件"></a>打开和关闭文件</h3><p><strong>方法列表</strong></p><table>    <tr>        <th>方法名</th><th>描述</th>    </tr>    <tr>        <td>Open(name string) (*File, error)</td><td>只读模式打开文件，本质上调用的是OpenFile</td>    </tr>    <tr>        <td>OpenFile(name string, flag int, perm FileMode) (*File, error)</td><td>打开文件，可以传入模式和权限</td>    </tr></table><p><strong>OpenFile入参介绍</strong></p><table>    <tr>        <th>flag值</th><th>代表的模式</th>    </tr>    <tr>        <td>O_RDONLY</td><td>只读模式</td>    </tr>    <tr>        <td>O_WRONLY</td><td>只写模式</td>    </tr>    <tr>        <td>O_RDWR</td><td>读写模式</td>    </tr>    <tr>        <td>O_APPEND</td><td>追加模式</td>    </tr>    <tr>        <td>O_CREATE</td><td>文件不存在，则创建</td>    </tr>    <tr>        <td>O_EXCL</td><td>和O_CREATE配合使用，文件必须不存在</td>    </tr>    <tr>        <td>O_SYNC</td><td>打开文件用于同步I/O</td>    </tr>    <tr>        <td>O_TRUNC</td><td>如果可能，打开时清空文件</td>    </tr></table><p><strong>使用示例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 该文件不存在</span></span><br><span class="line">fileName := <span class="string">&quot;./public/test.txt&quot;</span></span><br><span class="line">file1, err := os.Open(fileName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;os.Open 打开文件失败，err:%s \n&quot;</span>, err.Error())</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;os.Open 打开文件成功，open:%v \n&quot;</span>, file1)</span><br><span class="line"><span class="comment">// 关闭文件</span></span><br><span class="line"><span class="keyword">defer</span> file1.Close()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 文件不存在，则会创建文件</span></span><br><span class="line">file2, err1 := os.OpenFile(fileName, os.O_CREATE, os.ModePerm)</span><br><span class="line"><span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;os.OpenFile 打开文件失败，err:%s \n&quot;</span>, err1.Error())</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;os.OpenFile 打开文件成功，open:%v \n&quot;</span>, file2)</span><br><span class="line"><span class="comment">// 关闭文件</span></span><br><span class="line"><span class="keyword">defer</span> file2.Close()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">os.Open 打开文件失败，err:open ./public/test.txt: no such file or directory </span></span><br><span class="line"><span class="comment">os.OpenFile 打开文件成功，open:&amp;&#123;0xc0000b0120&#125; </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h3><p>读取文件步骤: 打开文件(<code>Open</code>) 、读取文件(<code>Read</code>)、关闭文件(<code>Close</code>)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fileName := <span class="string">&quot;./public/test.txt&quot;</span></span><br><span class="line">file1, err := os.Open(fileName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;os.Open 打开文件失败，err:%s \n&quot;</span>, err.Error())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义一个变量存储读取的内容</span></span><br><span class="line">b := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">1024</span>)</span><br><span class="line"><span class="comment">// 读取文件</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">read, _ := file1.Read(b)</span><br><span class="line"><span class="keyword">if</span> read == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;读取内容: %s \n&quot;</span>, b)</span><br><span class="line"><span class="comment">// 关闭文件</span></span><br><span class="line">_ = file1.Close()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">读取内容: hello world</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h3><p>写入文件步骤: 打开文件(<code>OpenFile</code>) 、写入文件(<code>Write</code>)、关闭文件(<code>Close</code>)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fileName := <span class="string">&quot;./public/hello.txt&quot;</span></span><br><span class="line"><span class="comment">// 读写|创建|追加的模式 模式打开文件</span></span><br><span class="line">file1, err := os.OpenFile(fileName, os.O_RDWR|os.O_CREATE|os.O_APPEND, os.ModePerm)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;os.OpenFile 打开文件失败，err:%s \n&quot;</span>, err.Error())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line">write, err := file1.Write([]<span class="type">byte</span>(<span class="string">&quot;Go! Go! Let&#x27;s Go!! 汉字 \n&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;写入失败: %s \n&quot;</span>, err.Error())</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;写入字节数: %d \n&quot;</span>, write)</span><br><span class="line"><span class="comment">// 关闭文件</span></span><br><span class="line">_ = file1.Close()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">写入字节数: 27</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h3><p>Go语言提供了<code>io.copy()</code>方法，用来复制文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 把fileA文件复制给fileB</span></span><br><span class="line">fileA := <span class="string">&quot;./public/hello.txt&quot;</span></span><br><span class="line">fileB := <span class="string">&quot;./public/new.txt&quot;</span></span><br><span class="line"><span class="comment">// 打开源文件</span></span><br><span class="line">sourceA, err := os.Open(fileA)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;os.Open 打开文件失败，err:%s \n&quot;</span>, err.Error())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭文件A</span></span><br><span class="line"><span class="keyword">defer</span> sourceA.Close()</span><br><span class="line"><span class="comment">// 打开新文件</span></span><br><span class="line">targetB, err := os.Create(fileB)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;os.Create 创建新文件失败，err:%s \n&quot;</span>, err.Error())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭文件B</span></span><br><span class="line"><span class="keyword">defer</span> targetB.Close()</span><br><span class="line"><span class="comment">// 把fileA文件复制给fileB</span></span><br><span class="line">written, err := io.Copy(targetB, sourceA)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;文件复制失败，err:%s \n&quot;</span>, err.Error())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;文件复制成功: %d \n&quot;</span>, written)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">文件复制成功: 54</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在Go语言中，文件操作的大多数函数都在os包里面，文件的信息包括文件名、文件大小、修改权限、修改时间等。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="GO" scheme="https://rma-shuyu.github.io/categories/GO/"/>
    
    
    <category term="go" scheme="https://rma-shuyu.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>os系统基本操作包使用</title>
    <link href="https://rma-shuyu.github.io/2021/05/07/os%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%8C%85%E4%BD%BF%E7%94%A8/"/>
    <id>https://rma-shuyu.github.io/2021/05/07/os%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E5%8C%85%E4%BD%BF%E7%94%A8/</id>
    <published>2021-05-07T12:27:18.000Z</published>
    <updated>2023-01-27T12:06:26.922Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote><p>os包中提供了操作系统函数的接口，是一个比较重要的包。它的作用主要是在服务器上进行系统的基本操作，如文件操作、目录操作、执行命令、信号与中断、进程、系统状态等等。下面分模块归纳一些常用函数。</p></blockquote><span id="more"></span><h2 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h2><p><strong>函数列表</strong></p><table>    <tr>        <th>函数</th><th>功能</th>    </tr>    <tr>        <td>Hostname()</td><td>获取当前主机名</td>    </tr>    <tr>        <td>Getpid()</td><td>返回调用者所在进程的进程ID</td>    </tr>    <tr>        <td>Getppid()</td><td>返回调用者所在进程的父进程的进程ID</td>    </tr>    <tr>        <td>Exit()</td><td>让程序以状态码code退出。状态码0表示成功，非0表示出错。code取值范围： [0,125]</td>    </tr></table><p><strong>代码示例</strong><br><strong>系统相关</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">hostname, _ := os.Hostname()</span><br><span class="line">fmt.Printf(<span class="string">&quot;主机名:%v \n&quot;</span>, hostname)</span><br><span class="line">fmt.Printf(<span class="string">&quot;调用者所在进程的进程ID: %v \n&quot;</span>, os.Getpid())</span><br><span class="line">fmt.Printf(<span class="string">&quot;调用者所在进程的进程的父进程ID: %v \n&quot;</span>, os.Getppid())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><img src="25716b6374e3cdaa9cca7b44ac92f5a570725bfb9f503c6d170ce72cdeb12ea7.png" alt="图 1">  </p><p><strong>Exit</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;调用前打印...&quot;</span>)</span><br><span class="line"><span class="comment">// 调用退出程序：code范围应在 0 &lt;= x &lt;= 125</span></span><br><span class="line">os.Exit(<span class="number">0</span>)</span><br><span class="line"><span class="comment">// 后面代码不会执行</span></span><br><span class="line">fmt.Println(<span class="string">&quot;调用后，这里不会输出&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><img src="be49c0cb5940e2f06b09cd48e0b638be6d7027904b67f257b44349c917b2ef31.png" alt="图 2">  </p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p><strong>函数列表</strong></p><table>    <tr>        <th>函数</th><th>功能</th>    </tr>    <tr>        <td>Environ()</td><td>获取所有环境变量</td>    </tr>    <tr>        <td>Setenv(key, value string)</td><td>设置环境变量</td>    </tr>    <tr>        <td>Getenv(key string)</td><td>获取环境变量</td>    </tr>    <tr>        <td>Clearenv()</td><td>清空所有环境变量</td>    </tr></table><p><strong>代码示例</strong><br><strong>环境变量相关</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 所有环境变量</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;所有环境变量:%+v \n&quot;</span>, os.Environ())</span><br><span class="line"><span class="comment">// 设置环境变量</span></span><br><span class="line">_ = os.Setenv(<span class="string">&quot;my-name&quot;</span>, <span class="string">&quot;张三&quot;</span>)</span><br><span class="line"><span class="comment">// 获取环境变量</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;获取环境变量: %v \n&quot;</span>, os.Getenv(<span class="string">&quot;my-name&quot;</span>))</span><br><span class="line"><span class="comment">// 清空所有环境变量</span></span><br><span class="line">os.Clearenv()</span><br><span class="line">fmt.Printf(<span class="string">&quot;清空环境变量后:%+v \n&quot;</span>, os.Environ())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><img src="9dd404b3c1d594ab4b191d9b9ecec66551749e6d89620b8e744b0ca87540b88c.png" alt="图 3">  </p><h2 id="文件相关"><a href="#文件相关" class="headerlink" title="文件相关"></a>文件相关</h2><p>关于文件相关的函数，参见之前的文章 go文件操作</p><h2 id="进程相关"><a href="#进程相关" class="headerlink" title="进程相关"></a>进程相关</h2><p><strong>方法列表</strong></p><table>    <tr>        <th>函数名</th><th>功能</th>    </tr>    <tr>        <td>os.StartProcess(..) (*Process, error)</td><td>根据提供的参数创建一个新进程</td>    </tr>    <tr>        <td>p.Signal(sig Signal)</td><td>向进程发送一个信号</td>    </tr>    <tr>        <td>p.Wait()</td><td>阻塞到进程退出,返回类型*os.ProcessState</td>    </tr>    <tr>        <td>ps.Pid()</td><td>返回一个已退出进程的id</td>    </tr>    <tr>        <td>ps.Exited()</td><td>报告进程是否已退出</td>    </tr>    <tr>        <td>ps.Success()</td><td>报告进程是否成功退出，在Unix中状态码0代表退出。</td>    </tr>    <tr>        <td>ps.SystemTime()</td><td>退出进程及子进程耗费的系统CPU时间</td>    </tr>    <tr>        <td>ps.UserTime()</td><td>退出进程及子进程耗费的用户CPU时间</td>    </tr>    <tr>        <td>ps.String()</td><td>退出进程的状态信息</td>    </tr></table><p>上表中<code>p</code>代表: <code>*os.Process</code>,  <code>ps</code>代表: <code>*os.ProcessState</code></p><p><strong>代码示例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个新进程执行； ls /</span></span><br><span class="line">args := []<span class="type">string</span>&#123;<span class="string">&quot;/&quot;</span>&#125;</span><br><span class="line">process, err := os.StartProcess(<span class="string">&quot;/bin/ls&quot;</span>, args, &amp;os.ProcAttr&#123;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;创建新进程失败: &quot;</span> + err.Error())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;当前新线程信息: %+v \n&quot;</span>, process)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2秒后向进程发送信号</span></span><br><span class="line">time.AfterFunc(<span class="number">2</span>*time.Second, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;发送进程退出信号...&quot;</span>)</span><br><span class="line">_ = process.Signal(os.Kill)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 手动阻塞看是否执行：发送信号</span></span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待进程退出,返回ProcessState类型</span></span><br><span class="line">processState, _ := process.Wait()</span><br><span class="line"><span class="comment">// 返回一个已退出进程的id</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;当前进程Id: %v \n&quot;</span>, processState.Pid())</span><br><span class="line"><span class="comment">// 报告进程是否已退出</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;进程是否已退出: %v \n&quot;</span>, processState.Exited())</span><br><span class="line"><span class="comment">// 报告进程是否成功退出，如在Unix里以状态码0退出。</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;进程是否成功退出: %v \n&quot;</span>, processState.Success())</span><br><span class="line"><span class="comment">// 返回已退出进程及其子进程耗费的系统CPU时间。</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;进程及子进程耗费系统CPU时间: %v \n&quot;</span>, processState.SystemTime())</span><br><span class="line"><span class="comment">// 返回已退出进程及其子进程耗费的用户CPU时间。</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;进程及子进程耗费用户CPU时间: %v \n&quot;</span>, processState.UserTime())</span><br><span class="line">fmt.Printf(<span class="string">&quot;进程状态: %s \n&quot;</span>, processState.String())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:<br><img src="e92f9e91fc71640b2a8c1309f422cebddff4e062b3925d0bf7b90fd1df2275b6.png" alt="图 4">  </p><h2 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h2><p><code>os/exec</code>包执行外部命令。它包装了<code>os.StartProcess</code>函数以便更容易的修正输入和输出，使用管道连接I/O，以及其它的一些优化。</p><p><strong>方法列表</strong></p><table>    <tr>        <th>函数名</th><th>功能</th>    </tr>    <tr>        <td>LookPath(file string) (string, error)</td><td>在环境变量PATH中搜索可执行文件</td>    </tr>    <tr>        <td>(c *Cmd) Run() error</td><td>执行c包含的命令，并阻塞直到完成</td>    </tr>    <tr>        <td>(c *Cmd) Start() error</td><td>执行c包含的命令即刻返回，但不会等待该命令完成。</td>    </tr>    <tr>        <td>(c *Cmd) Wait() error</td><td>会阻塞直到该命令执行完成,和Start()结合使用</td>    </tr>    <tr>        <td>(c *Cmd) Output() ([]byte, error)</td><td>执行命令并返回标准输出的切片</td>    </tr>    <tr>        <td>(c *Cmd) CombinedOutput() ([]byte, error)</td><td>执行命令并返回标准输出和错误输出合并的切片。</td>    </tr></table><p><strong>使用示例</strong><br><code>LookPath</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在环境变量PATH中搜索可执行文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">path, err := exec.LookPath(<span class="string">&quot;go&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(path)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><img src="ea3f85148064bee0fdd191e68ce25d2976499e77d1570616931eec0bf19aafed.png" alt="图 5">  </p><p><code>Run</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Run()执行命令</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">cmd := exec.Command(<span class="string">&quot;sleep&quot;</span>, <span class="string">&quot;3s&quot;</span>)</span><br><span class="line"><span class="comment">// 具体执行</span></span><br><span class="line">err := cmd.Run()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;执行失败:%v\n&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;cmd.Path: %v \n&quot;</span>, cmd.Path)</span><br><span class="line">fmt.Printf(<span class="string">&quot;cmd.Args: %v \n&quot;</span>, cmd.Args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><img src="897245d982566520021da8587f21c86f1813a8a9a1ac1c17bacd8a9c2fcf9d9b.png" alt="图 6">  </p><p><code>Start</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Start执行命令</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">cmd := exec.Command(<span class="string">&quot;sleep&quot;</span>, <span class="string">&quot;3s&quot;</span>)</span><br><span class="line"><span class="comment">// Start开始执行c包含的命令，但并不会等待该命令完成即返回</span></span><br><span class="line">err := cmd.Start()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;执行失败:%v\n&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Wait会阻塞直到该命令执行完成</span></span><br><span class="line">err = cmd.Wait()</span><br><span class="line">fmt.Printf(<span class="string">&quot;执行完成: %v \n&quot;</span>, err)</span><br><span class="line">fmt.Printf(<span class="string">&quot;cmd.Path: %v \n&quot;</span>, cmd.Path)</span><br><span class="line">fmt.Printf(<span class="string">&quot;cmd.Args: %v \n&quot;</span>, cmd.Args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>输出：<br><img src="25db6b3665963391aa957243a001cac77e91cf956ddcf773d26c122a0e3fb24c.png" alt="图 7">  </p><p><code>Output</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行命令并获取输出结果</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">output, _ := exec.Command(<span class="string">&quot;go&quot;</span>, <span class="string">&quot;version&quot;</span>).Output()</span><br><span class="line">fmt.Printf(<span class="string">&quot;结果: %s&quot;</span>, output)</span><br><span class="line"><span class="comment">// 执行: du -sh .</span></span><br><span class="line">output2, _ := exec.Command(<span class="string">&quot;du&quot;</span>, <span class="string">&quot;-sh&quot;</span>, <span class="string">&quot;.&quot;</span>).Output()</span><br><span class="line">fmt.Printf(<span class="string">&quot;结果: %s&quot;</span>, output2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><img src="78341914658e18326703cb8e438ce6ed7a4fe687ce368984b81ebe5a3b3e7a5d.png" alt="图 8">  </p><p><code>CombinedOutput</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行命令并返回标准输出和错误输出合并的切片</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 执行: go version-1 故意写错</span></span><br><span class="line">output, _ := exec.Command(<span class="string">&quot;go&quot;</span>, <span class="string">&quot;version-1&quot;</span>).Output()</span><br><span class="line">fmt.Printf(<span class="string">&quot;结果1: %s \n&quot;</span>, output)</span><br><span class="line"></span><br><span class="line">output, _ = exec.Command(<span class="string">&quot;go&quot;</span>, <span class="string">&quot;version-1&quot;</span>).CombinedOutput()</span><br><span class="line">fmt.Printf(<span class="string">&quot;结果2: %s \n&quot;</span>, output)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br><img src="c83901869a7a52f6d0eec8e4269aece5cabee87d8918ff1a347a74f75841cb5f.png" alt="图 9">  </p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;os包中提供了操作系统函数的接口，是一个比较重要的包。它的作用主要是在服务器上进行系统的基本操作，如文件操作、目录操作、执行命令、信号与中断、进程、系统状态等等。下面分模块归纳一些常用函数。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="GO" scheme="https://rma-shuyu.github.io/categories/GO/"/>
    
    
    <category term="go" scheme="https://rma-shuyu.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>rune字符操作包(unicode)</title>
    <link href="https://rma-shuyu.github.io/2021/05/06/rune%E5%AD%97%E7%AC%A6%E6%93%8D%E4%BD%9C%E5%8C%85-unicode/"/>
    <id>https://rma-shuyu.github.io/2021/05/06/rune%E5%AD%97%E7%AC%A6%E6%93%8D%E4%BD%9C%E5%8C%85-unicode/</id>
    <published>2021-05-06T12:27:18.000Z</published>
    <updated>2023-01-27T12:06:26.946Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote><p>unicode包提供了诸多处理rune字符相关功能的函数（比如区分字母和数字，或者是字母的大写和小写转换等)</p></blockquote><span id="more"></span><p><strong>说明</strong>：<br>golang中的字符有两种，<code>uint8（byte）</code>代表<code>ASCII</code>的一个字符，<code>rune</code>代表一个<code>utf-8</code>字符。<br>当需要处理中文、日文或者其他复合字符时，则需要用到<code>rune</code>类型，rune实际是一个<code>int32</code></p><h2 id="判断函数"><a href="#判断函数" class="headerlink" title="判断函数"></a>判断函数</h2><h3 id="是否为空格-IsSpace"><a href="#是否为空格-IsSpace" class="headerlink" title="是否为空格(IsSpace)"></a>是否为空格(IsSpace)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">rune1 := <span class="string">&#x27; &#x27;</span></span><br><span class="line">rune2 := <span class="string">&#x27;h&#x27;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%c] 是空格? %t\n&quot;</span>, rune1, unicode.IsSpace(rune1))</span><br><span class="line"><span class="comment">// 输出 [ ] 是空格? true</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%c] 是空格? %t\n&quot;</span>, rune2, unicode.IsSpace(rune2))</span><br><span class="line"><span class="comment">// 输出 [h] 是空格? false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="是否为十进制数-IsDigit"><a href="#是否为十进制数-IsDigit" class="headerlink" title="是否为十进制数(IsDigit)"></a>是否为十进制数(IsDigit)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">d1 := <span class="string">&#x27;1&#x27;</span></span><br><span class="line">d2 := <span class="string">&#x27;w&#x27;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%c] 是十进制数? %t\n&quot;</span>, d1, unicode.IsDigit(d1))</span><br><span class="line"><span class="comment">// 输出: [1] 是十进制数? true</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%c] 是十进制数? %t\n&quot;</span>, d2, unicode.IsDigit(d2))</span><br><span class="line"><span class="comment">// 输出: [w] 是十进制数? false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="是否为数字-IsNumber"><a href="#是否为数字-IsNumber" class="headerlink" title="是否为数字(IsNumber)"></a>是否为数字(IsNumber)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">d1 := <span class="string">&#x27;1&#x27;</span></span><br><span class="line">d2 := <span class="string">&#x27;w&#x27;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%c] 是数字? %t\n&quot;</span>, d1, unicode.IsNumber(d1))</span><br><span class="line"><span class="comment">// 输出: [1] 是数字? true</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%c] 是数字? %t\n&quot;</span>, d2, unicode.IsNumber(d2))</span><br><span class="line"><span class="comment">// 输出: [w] 是数字? false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="是否为字母字符-IsLetter"><a href="#是否为字母字符-IsLetter" class="headerlink" title="是否为字母字符(IsLetter)"></a>是否为字母字符(IsLetter)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">str1 := <span class="string">&#x27;刘&#x27;</span></span><br><span class="line">str2 := <span class="string">&#x27;l&#x27;</span></span><br><span class="line">str3 := <span class="string">&#x27;W&#x27;</span></span><br><span class="line">str4 := <span class="string">&#x27;!&#x27;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%c] 是字母? %t\n&quot;</span>, str1, unicode.IsLetter(str1))</span><br><span class="line"><span class="comment">// [刘] 是字母? true</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%c] 是字母? %t\n&quot;</span>, str2, unicode.IsLetter(str2))</span><br><span class="line"><span class="comment">// [l] 是字母? true</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%c] 是字母? %t\n&quot;</span>, str3, unicode.IsLetter(str3))</span><br><span class="line"><span class="comment">// [W] 是字母? true</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%c] 是字母? %t\n&quot;</span>, str4, unicode.IsLetter(str4))</span><br><span class="line"><span class="comment">// [!] 是字母? false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>: 汉字也是一个字母字符</p><h3 id="是否为标点符号-IsPunct"><a href="#是否为标点符号-IsPunct" class="headerlink" title="是否为标点符号(IsPunct)"></a>是否为标点符号(IsPunct)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">str1 := <span class="string">&#x27;刘&#x27;</span></span><br><span class="line">str2 := <span class="string">&#x27;l&#x27;</span></span><br><span class="line">str3 := <span class="string">&#x27;!&#x27;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%c] 是标点符号? %t\n&quot;</span>, str1, unicode.IsPunct(str1))</span><br><span class="line"><span class="comment">// [刘] 是标点符号? false</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%c] 是标点符号? %t\n&quot;</span>, str2, unicode.IsPunct(str2))</span><br><span class="line"><span class="comment">// [l] 是标点符号? false</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%c] 是标点符号? %t\n&quot;</span>, str3, unicode.IsPunct(str3))</span><br><span class="line"><span class="comment">// [!] 是标点符号? true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="是否为小写字母-IsLower"><a href="#是否为小写字母-IsLower" class="headerlink" title="是否为小写字母(IsLower)"></a>是否为小写字母(IsLower)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">str1 := <span class="string">&#x27;刘&#x27;</span></span><br><span class="line">str2 := <span class="string">&#x27;l&#x27;</span></span><br><span class="line">str3 := <span class="string">&#x27;W&#x27;</span></span><br><span class="line">str4 := <span class="string">&#x27;!&#x27;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%c] 是小写字母? %t\n&quot;</span>, str1, unicode.IsLower(str1))</span><br><span class="line"><span class="comment">// [刘] 是小写字母? false</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%c] 是小写字母? %t\n&quot;</span>, str2, unicode.IsLower(str2))</span><br><span class="line"><span class="comment">// [l] 是小写字母? true</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%c] 是小写字母? %t\n&quot;</span>, str3, unicode.IsLower(str3))</span><br><span class="line"><span class="comment">// [W] 是小写字母? false</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%c] 是小写字母? %t\n&quot;</span>, str4, unicode.IsLower(str4))</span><br><span class="line"><span class="comment">// [!] 是小写字母? false</span></span><br></pre></td></tr></table></figure><h3 id="是否为大写字母-IsUpper"><a href="#是否为大写字母-IsUpper" class="headerlink" title="是否为大写字母(IsUpper)"></a>是否为大写字母(IsUpper)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">str1 := <span class="string">&#x27;刘&#x27;</span></span><br><span class="line">str2 := <span class="string">&#x27;l&#x27;</span></span><br><span class="line">str3 := <span class="string">&#x27;W&#x27;</span></span><br><span class="line">str4 := <span class="string">&#x27;!&#x27;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%c] 是大写字母? %t\n&quot;</span>, str1, unicode.IsUpper(str1))</span><br><span class="line"><span class="comment">// [刘] 是大写字母? false</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%c] 是大写字母? %t\n&quot;</span>, str2, unicode.IsUpper(str2))</span><br><span class="line"><span class="comment">// [l] 是大写字母? false</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%c] 是大写字母? %t\n&quot;</span>, str3, unicode.IsUpper(str3))</span><br><span class="line"><span class="comment">// [W] 是大写字母? true</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%c] 是大写字母? %t\n&quot;</span>, str4, unicode.IsUpper(str4))</span><br><span class="line"><span class="comment">// [!] 是大写字母? false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="是否为汉字"><a href="#是否为汉字" class="headerlink" title="是否为汉字"></a>是否为汉字</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">str1 := <span class="string">&#x27;刘&#x27;</span></span><br><span class="line">str2 := <span class="string">&#x27;l&#x27;</span></span><br><span class="line">str3 := <span class="string">&#x27;!&#x27;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%c] 是汉字? %t\n&quot;</span>, str1, unicode.Is(unicode.Scripts[<span class="string">&quot;Han&quot;</span>], str1))</span><br><span class="line"><span class="comment">// [刘] 是汉字? true</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%c] 是汉字? %t\n&quot;</span>, str2, unicode.Is(unicode.Scripts[<span class="string">&quot;Han&quot;</span>], str2))</span><br><span class="line"><span class="comment">// [l] 是汉字? false</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%c] 是汉字? %t\n&quot;</span>, str3, unicode.Is(unicode.Scripts[<span class="string">&quot;Han&quot;</span>], str3))</span><br><span class="line"><span class="comment">// [!] 是汉字? false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="转换函数"><a href="#转换函数" class="headerlink" title="转换函数"></a>转换函数</h2><h3 id="转成小写-ToLower"><a href="#转成小写-ToLower" class="headerlink" title="转成小写(ToLower)"></a>转成小写(ToLower)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1 := <span class="string">&#x27;W&#x27;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%c] 转成小写: %c \n&quot;</span>, str1, unicode.ToLower(str1))</span><br><span class="line"><span class="comment">// [W] 转成小写: w </span></span><br></pre></td></tr></table></figure><h3 id="转成大写-ToUpper"><a href="#转成大写-ToUpper" class="headerlink" title="转成大写(ToUpper)"></a>转成大写(ToUpper)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str2 := <span class="string">&#x27;a&#x27;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;[%c] 转成大写: %c \n&quot;</span>, str2, unicode.ToUpper(str2))</span><br><span class="line"><span class="comment">// [a] 转成大写: A</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;unicode包提供了诸多处理rune字符相关功能的函数（比如区分字母和数字，或者是字母的大写和小写转换等)&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="GO" scheme="https://rma-shuyu.github.io/categories/GO/"/>
    
    
    <category term="go" scheme="https://rma-shuyu.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>sort排序和查询</title>
    <link href="https://rma-shuyu.github.io/2021/04/30/sort%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E8%AF%A2/"/>
    <id>https://rma-shuyu.github.io/2021/04/30/sort%E6%8E%92%E5%BA%8F%E5%92%8C%E6%9F%A5%E8%AF%A2/</id>
    <published>2021-04-30T12:27:18.000Z</published>
    <updated>2023-01-27T12:06:26.956Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote><p>sort包实现了四种基本排序算法：插入排序、归并排序、堆排序、快速排序。 但是这四种排序方法是不公开的，它们只能在 sort 包内部使用。sort 包会根据实际数据自动选择高效的排序算法，所以在对数据集合排序时不必考虑应当选择哪一种排序方法，只要实现了 sort.Interface 定义的三个方法,就可以顺利对数据集合进行排序</p></blockquote><span id="more"></span><p><code>Len() int</code>: 获取数据集合长度。<br><code>Less() bool</code>: 比较两个元素大小。<br><code>Swap()</code>: 交换两个元素位置。</p><h3 id="支持功能"><a href="#支持功能" class="headerlink" title="支持功能"></a>支持功能</h3><p>sort 包对[]int 、[]float64 、[]string 切片提供了完整的支持，主要功能有：</p><p>对基本数据类型切片的排序。<br>基本数据元素查找。<br>判断基本数据类型切片是否已经排序。<br>对排好序的数据集合逆序。</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="Sort"><a href="#Sort" class="headerlink" title="Sort"></a>Sort</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 定义整数序列</span></span><br><span class="line">nums := sort.IntSlice&#123;<span class="number">10</span>, <span class="number">40</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">23</span>, <span class="number">72</span>, <span class="number">89</span>&#125;</span><br><span class="line"><span class="comment">// 排序</span></span><br><span class="line">nums.Sort()</span><br><span class="line"><span class="comment">// 判断是否已排序</span></span><br><span class="line"><span class="keyword">if</span> sorted := sort.IsSorted(nums); sorted &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;排序结果:%+v\n&quot;</span>, nums)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;排序失败！&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 输出:</span></span><br><span class="line"><span class="comment">排序结果:[6 9 10 23 40 72 89]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="sort-Ints"><a href="#sort-Ints" class="headerlink" title="sort.Ints"></a>sort.Ints</h3><p>将 []int 进行升序排序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := []<span class="type">int</span>&#123;<span class="number">23</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">89</span>&#125;</span><br><span class="line"><span class="comment">// 调用排序</span></span><br><span class="line">sort.Ints(a)</span><br><span class="line"><span class="comment">// 检测是否已经排序</span></span><br><span class="line"><span class="keyword">if</span> sorted := sort.IntsAreSorted(a); sorted &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;排序成功: %v\n&quot;</span>, a)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;排序失败: %v\n&quot;</span>, a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查找元素</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;查找元素(存在): %v 索引:%v \n&quot;</span>, <span class="number">12</span>, sort.SearchInts(a, <span class="number">12</span>))</span><br><span class="line">fmt.Printf(<span class="string">&quot;查找元素(不存在): %v 索引:%v \n&quot;</span>, <span class="number">22</span>, sort.SearchInts(a, <span class="number">22</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 输出</span></span><br><span class="line"><span class="comment">排序成功: [2 3 9 12 12 23 89]</span></span><br><span class="line"><span class="comment">查找元素(存在): 12 索引:3 </span></span><br><span class="line"><span class="comment">查找元素(不存在): 22 索引:5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>同样的方法还有：<br><code>sort.Float64s</code>、<code>sort.Strings</code></p><h3 id="降序"><a href="#降序" class="headerlink" title="降序"></a>降序</h3><p>降序原理<br>前面介绍的都是排序规则都是升序(sort包默认都是升序),如果想要降序，可以使用sort.Reverse来调换Less()参数，从而实现降序的目的。</p><p><code>sort.Reverse</code> 源码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收一个Interface类型参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Reverse</span><span class="params">(data Interface)</span></span> Interface &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;reverse&#123;data&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以看到这里是把参数 i,j 互换成 j,i</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r reverse)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> r.Interface.Less(j, i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 使用sort包中的数据类型</span></span><br><span class="line">intSlice := sort.IntSlice&#123;<span class="number">23</span>, <span class="number">15</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">89</span>&#125;</span><br><span class="line"><span class="comment">// 互换j,i</span></span><br><span class="line">reverse := sort.Reverse(intSlice)</span><br><span class="line"><span class="comment">// 排序</span></span><br><span class="line">sort.Sort(reverse)</span><br><span class="line">fmt.Printf(<span class="string">&quot;排序结果: %v\n&quot;</span>, intSlice)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 输出</span></span><br><span class="line"><span class="comment">排序结果: [89 23 15 12 9 3 2]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p><strong>查找步骤</strong></p><ul><li>步骤一：定义类型变量</li><li>步骤二：先排序后查找(查找是基于排序后的结果)</li><li>步骤三：查询可能存在的索引</li><li>步骤四：判断是否相等</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search_var</span><span class="params">(searchVal <span class="type">int</span>, intSlice sort.IntSlice)</span></span> &#123;</span><br><span class="line">searchIndex := intSlice.Search(searchVal)</span><br><span class="line"><span class="comment">// 判断是否相等</span></span><br><span class="line"><span class="keyword">if</span> searchIndex &gt;= <span class="built_in">len</span>(intSlice) &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;未找到：%v\n&quot;</span>, searchVal)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> searchVal == intSlice[searchIndex] &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;找到: %v 索引为: %v \n&quot;</span>, searchVal, searchIndex)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;未找到：%v\n&quot;</span>, searchVal)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 1.定义类型</span></span><br><span class="line">intSlice := sort.IntSlice&#123;<span class="number">10</span>, <span class="number">40</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">23</span>, <span class="number">72</span>, <span class="number">89</span>&#125;</span><br><span class="line"><span class="comment">// 2.排序后查找</span></span><br><span class="line">intSlice.Sort()</span><br><span class="line"><span class="comment">// 3.查询可能存在的索引</span></span><br><span class="line">search_var(<span class="number">6</span>, intSlice)</span><br><span class="line"><span class="comment">// 4.查找不存在情况</span></span><br><span class="line">search_var(<span class="number">90</span>, intSlice)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">找到: 6 索引为: 0 </span></span><br><span class="line"><span class="comment">未找到：90</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>根据查询出的索引,取出对应的值，看是否与查找的值相等。如果相等则认为找到，不相等则认为没有找到。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;sort包实现了四种基本排序算法：插入排序、归并排序、堆排序、快速排序。 但是这四种排序方法是不公开的，它们只能在 sort 包内部使用。sort 包会根据实际数据自动选择高效的排序算法，所以在对数据集合排序时不必考虑应当选择哪一种排序方法，只要实现了 sort.Interface 定义的三个方法,就可以顺利对数据集合进行排序&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="GO" scheme="https://rma-shuyu.github.io/categories/GO/"/>
    
    
    <category term="go" scheme="https://rma-shuyu.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>flag包使用</title>
    <link href="https://rma-shuyu.github.io/2021/04/29/flag%E5%8C%85%E4%BD%BF%E7%94%A8/"/>
    <id>https://rma-shuyu.github.io/2021/04/29/flag%E5%8C%85%E4%BD%BF%E7%94%A8/</id>
    <published>2021-04-29T12:27:18.000Z</published>
    <updated>2023-01-27T12:06:26.876Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote><p>在 Go中，如果要接收命令行参数，需要使用 flag包进行解析。不同的参数类型可以通过不同的方法接收。</p></blockquote><span id="more"></span><h2 id="参数接受"><a href="#参数接受" class="headerlink" title="参数接受"></a>参数接受</h2><h3 id="接受方式"><a href="#接受方式" class="headerlink" title="接受方式"></a>接受方式</h3><p>使用<code>flag</code>接收参数，可以由以下三种方式接受：</p><ul><li>方式一: flag.Type(name,defaultVal,desc)</li><li>方式二: flag.TypeVar(&amp;flagVar,name,defaultVal,desc)</li><li>方式三: flag.Var(&amp;flagVar,name,desc)</li><li>方式四: flag.Args()</li><li>方式五: flag.Arg(i)</li></ul><table>    <tr>        <th>字段</th><th>说明</th>    </tr>    <tr>        <td>flag.Type</td><td>这里的Type是个抽象的概念,不是具体函数名</td>    </tr>    <tr>        <td>defaultVal</td><td>默认值</td>    </tr>    <tr>        <td>desc</td><td>描述信息</td>    </tr></table>        <h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>上面接收方式一、二、三，都是最后调用<code>flag.Parse()</code>,而方式四和方式五是提前调用<code>flag.Parse()</code>。<br>方式一、二、三传参时，注意布尔类型，尽量设置成-flag=val，否则会影响后面的参数解析。<br>方式四、五不能使用-flag=val这种格式传参。</p><h2 id="flag-Type"><a href="#flag-Type" class="headerlink" title="flag.Type"></a>flag.Type</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;flag&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line"><span class="comment">// 接收字符串</span></span><br><span class="line">str =  flag.String(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;默认名&quot;</span>,<span class="string">&quot;用户姓名&quot;</span>)</span><br><span class="line"><span class="comment">// 接收整型</span></span><br><span class="line">age = flag.Int(<span class="string">&quot;age&quot;</span>,<span class="number">18</span>,<span class="string">&quot;用户年龄&quot;</span>)</span><br><span class="line"><span class="comment">// 接收布尔型</span></span><br><span class="line">smoking = flag.Bool(<span class="string">&quot;smoking&quot;</span>,<span class="literal">false</span>,<span class="string">&quot;是否吸烟&quot;</span>)</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">// 解析</span></span><br><span class="line">flag.Parse()</span><br><span class="line">fmt.Printf(<span class="string">&quot;str: %v\n&quot;</span>,*str)</span><br><span class="line">fmt.Printf(<span class="string">&quot;age: %v\n&quot;</span>,*age)</span><br><span class="line">fmt.Printf(<span class="string">&quot;smoking: %v\n&quot;</span>,*smoking)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">str: 默认名</span></span><br><span class="line"><span class="comment">age: 18</span></span><br><span class="line"><span class="comment">smoking: false</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>运行(传参数时)</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># go run main.go -name 张三 -age 100 -smoking=true</span></span><br><span class="line">str: 张三</span><br><span class="line">age: 100</span><br><span class="line">smoking: <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="flag-TypeVar"><a href="#flag-TypeVar" class="headerlink" title="flag.TypeVar"></a>flag.TypeVar</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;flag&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 先定义变量</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">age <span class="type">int</span></span><br><span class="line">smoking <span class="type">bool</span></span><br><span class="line">weight <span class="type">float64</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="comment">// 接收字符串</span></span><br><span class="line">flag.StringVar(&amp;name,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;默认名字&quot;</span>,<span class="string">&quot;用户名&quot;</span>)</span><br><span class="line"><span class="comment">// 接收整型</span></span><br><span class="line">flag.IntVar(&amp;age,<span class="string">&quot;age&quot;</span>,<span class="number">18</span>,<span class="string">&quot;用户年龄&quot;</span>)</span><br><span class="line"><span class="comment">// 接收布尔类型</span></span><br><span class="line">flag.BoolVar(&amp;smoking,<span class="string">&quot;smoking&quot;</span>,<span class="literal">false</span>,<span class="string">&quot;是否吸烟？&quot;</span>)</span><br><span class="line"><span class="comment">// 接收浮点型</span></span><br><span class="line">flag.Float64Var(&amp;weight,<span class="string">&quot;w&quot;</span>,<span class="number">60.0</span>,<span class="string">&quot;体重&quot;</span>)</span><br><span class="line"><span class="comment">// 解析</span></span><br><span class="line">flag.Parse()</span><br><span class="line">fmt.Printf(<span class="string">&quot;姓名: %v\n&quot;</span>,name)</span><br><span class="line">fmt.Printf(<span class="string">&quot;年龄: %v\n&quot;</span>,age)</span><br><span class="line">fmt.Printf(<span class="string">&quot;是否吸烟？: %v\n&quot;</span>,smoking)</span><br><span class="line">fmt.Printf(<span class="string">&quot;体重: %v\n&quot;</span>,weight)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">姓名: 默认名字</span></span><br><span class="line"><span class="comment">年龄: 18</span></span><br><span class="line"><span class="comment">是否吸烟？: false</span></span><br><span class="line"><span class="comment">体重: 60</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>运行(传参数时)</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># go run main.go -name 张三 -age 22 -smoking=true  -w=88.9</span></span><br><span class="line">姓名: 张三</span><br><span class="line">年龄: 22</span><br><span class="line">是否吸烟？: <span class="literal">true</span></span><br><span class="line">体重: 88.9</span><br></pre></td></tr></table></figure><p><strong>细节</strong><br>在传参数过程中，发现布尔型传参如果不设置=，会影响后面的参数接收,具体如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 布尔型不设置 = (发现名字没有被接收)</span></span><br><span class="line"><span class="comment"># go run main.go -smoking true -name 哈哈 </span></span><br><span class="line">姓名: 默认名字</span><br><span class="line">年龄: 18</span><br><span class="line">是否吸烟？: <span class="literal">true</span></span><br><span class="line">体重: 60</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 布尔型设置 = </span></span><br><span class="line"><span class="comment"># go run main.go -smoking=true -name 哈哈 </span></span><br><span class="line">姓名: 哈哈</span><br><span class="line">年龄: 18</span><br><span class="line">是否吸烟？: <span class="literal">true</span></span><br><span class="line">体重: 60</span><br></pre></td></tr></table></figure><h2 id="flag-Var"><a href="#flag-Var" class="headerlink" title="flag.Var"></a>flag.Var</h2><p>通过 <code>flag.Var()</code> 绑定自定义类型，自定义类型需要实现 Value 接口(Receives必须为指针)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;flag&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义变量，并实现flag.Value接口</span></span><br><span class="line"><span class="keyword">type</span> Likes []<span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Likes)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%v&quot;</span>, *l)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(l *Likes)</span></span> Set(s <span class="type">string</span>) <span class="type">error</span> &#123;</span><br><span class="line"><span class="comment">// 分割字符串</span></span><br><span class="line">split := strings.Split(s, <span class="string">&quot;,&quot;</span>)</span><br><span class="line">*l = split</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> likeList Likes</span><br><span class="line"><span class="comment">// 接收自定义类型</span></span><br><span class="line">flag.Var(&amp;likeList, <span class="string">&quot;likes&quot;</span>, <span class="string">&quot;接收自定义类型&quot;</span>)</span><br><span class="line"><span class="comment">// 解析</span></span><br><span class="line">flag.Parse()</span><br><span class="line">fmt.Println(likeList)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># go run main.go -likes=篮球,足球,游戏</span></span><br><span class="line">[篮球 足球 游戏]</span><br></pre></td></tr></table></figure><h2 id="flag-Args"><a href="#flag-Args" class="headerlink" title="flag.Args"></a>flag.Args</h2><p>一次打印出全部的入参，注意入参格式不能是<code>-flag=val</code>格式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;flag&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 注意Parse是在Args之前调用</span></span><br><span class="line">flag.Parse()</span><br><span class="line"><span class="comment">// 一次接收所有的参数</span></span><br><span class="line">args := flag.Args()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> args &#123;</span><br><span class="line">fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># go run main.go 篮球 足球 游戏</span></span><br><span class="line">篮球</span><br><span class="line">足球</span><br><span class="line">游戏</span><br><span class="line">[篮球 足球 游戏]</span><br></pre></td></tr></table></figure><h2 id="flag-Arg-i"><a href="#flag-Arg-i" class="headerlink" title="flag.Arg(i)"></a>flag.Arg(i)</h2><p>获取指定索引位置的参数，默认索引位置是0;注意入参格式不能是<code>-flag=val</code>格式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;flag&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 注意Parse是在Arg之前调用</span></span><br><span class="line">flag.Parse()</span><br><span class="line"><span class="comment">// 获取指定索引位置参数</span></span><br><span class="line">p0 := flag.Arg(<span class="number">0</span>)</span><br><span class="line">p1 := flag.Arg(<span class="number">1</span>)</span><br><span class="line">p2 := flag.Arg(<span class="number">2</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;索引=0，v=%v\n&quot;</span>,p0)</span><br><span class="line">fmt.Printf(<span class="string">&quot;索引=1，v=%v\n&quot;</span>,p1)</span><br><span class="line">fmt.Printf(<span class="string">&quot;索引=2，v=%v\n&quot;</span>,p2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># go run main.go 篮球 足球 游戏</span></span><br><span class="line">索引=0，v=篮球</span><br><span class="line">索引=1，v=足球</span><br><span class="line">索引=2，v=游戏</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在 Go中，如果要接收命令行参数，需要使用 flag包进行解析。不同的参数类型可以通过不同的方法接收。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="GO" scheme="https://rma-shuyu.github.io/categories/GO/"/>
    
    
    <category term="go" scheme="https://rma-shuyu.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>sync包使用</title>
    <link href="https://rma-shuyu.github.io/2021/04/28/sync%E5%8C%85%E4%BD%BF%E7%94%A8/"/>
    <id>https://rma-shuyu.github.io/2021/04/28/sync%E5%8C%85%E4%BD%BF%E7%94%A8/</id>
    <published>2021-04-28T12:27:18.000Z</published>
    <updated>2023-01-27T12:06:26.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote><p>sync包提供了互斥锁。除了Once和WaitGroup类型，其余多数适用于低水平的程序，多数情况下，高水平的同步使用channel通信性能会更优一些。</p></blockquote><span id="more"></span><h2 id="并发等待组-WaitGroup"><a href="#并发等待组-WaitGroup" class="headerlink" title="并发等待组(WaitGroup)"></a>并发等待组(WaitGroup)</h2><p><code>WaitGroup</code>，即等待一组Goroutine结束。父Goroutine调用Add()方法来设置应等待Goroutine的数量。每个被等待的Goroutine在结束时应该调用Done()方法。与此同时，主Goroutine可调用Wait()方法阻塞至所有Goroutine结束。</p><p><strong>WaitGroup结构</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A WaitGroup must not be copied after first use.</span></span><br><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">noCopy noCopy</span><br><span class="line">state1 [<span class="number">3</span>]<span class="type">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法列表</strong></p><table>    <tr>        <th>方法名</th><th>功能</th>    </tr>    <tr>        <td>(wg *WaitGroup) Add(delta int)</td><td>等待组的计数器 +1</td>    </tr>    <tr>        <td>(wg *WaitGroup) Done()</td><td>等待组的计数器 -1</td>    </tr>    <tr>        <td>(wg *WaitGroup) Wait()</td><td>当等待组计数器不等于0时,阻塞直到0</td>    </tr></table><p><strong>Add参数取值范围</strong><br>等待组内部拥有一个计数器，计数器的值可以通过Add(delta int)方法调用实现计数器的增加和减少。该方法应该在创建新的Goroutine之前调用。</p><p>参数值x取值</p><table>    <tr>        <th>取值</th><th>描述</th>    </tr>    <tr>        <td>delta < 0</td><td>x小于0时,但会报错: panic: sync: negative WaitGroup counter</td>    </tr>    <tr>        <td>delta = 0</td><td>x等于0时,会释放Wait()方法阻塞等待的所有Goroutine</td>    </tr>    <tr>        <td>delta > 0</td><td>x大于0时,Wait()方法会阻塞Goroutine直到WaitGroup计数减为0</td>    </tr></table><p><strong>不使用WaitGroup示例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建通道</span></span><br><span class="line">intChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算1-50的和</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(intChan <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++ &#123;</span><br><span class="line">sum += i</span><br><span class="line">&#125;</span><br><span class="line">intChan &lt;- sum</span><br><span class="line">&#125;(intChan)</span><br><span class="line"><span class="comment">// 计算51-100的和</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(intChan <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">51</span>; i &lt;= <span class="number">100</span>; i++ &#123;</span><br><span class="line">sum += i</span><br><span class="line">&#125;</span><br><span class="line">intChan &lt;- sum</span><br><span class="line">&#125;(intChan)</span><br><span class="line"><span class="comment">// 另外创建个channle聚合结果</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(intChan <span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">sum1 := &lt;-intChan</span><br><span class="line">sum2 := &lt;-intChan</span><br><span class="line">fmt.Printf(<span class="string">&quot;sum1 = %d sum2 = %d  \nsum1 + sum2 = %d \n&quot;</span>, sum1, sum2, sum1+sum2)</span><br><span class="line">&#125;(intChan)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意,需求手动sleep</span></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">fmt.Println(<span class="string">&quot;运行结束&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 输出:</span></span><br><span class="line"><span class="comment">  sum1 = 1275 sum2 = 3775  </span></span><br><span class="line"><span class="comment">  sum1 + sum2 = 5050 </span></span><br><span class="line"><span class="comment">  运行结束</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>使用WaitGroup示例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 声明等待组</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="comment">// 设置，需要等待3个协程执行完成</span></span><br><span class="line">wg.Add(<span class="number">3</span>)</span><br><span class="line"><span class="comment">// 创建通道</span></span><br><span class="line">intChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line"><span class="comment">// 计算1-50的和</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(intChan <span class="keyword">chan</span> <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">50</span>; i++ &#123;</span><br><span class="line">sum += i</span><br><span class="line">&#125;</span><br><span class="line">intChan &lt;- sum</span><br><span class="line"><span class="comment">// 计数器减一</span></span><br><span class="line">wg.Done()</span><br><span class="line">&#125;(intChan, &amp;wg)</span><br><span class="line"><span class="comment">// 计算51-100的和</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(intChan <span class="keyword">chan</span> <span class="type">int</span>, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">51</span>; i &lt;= <span class="number">100</span>; i++ &#123;</span><br><span class="line">sum += i</span><br><span class="line">&#125;</span><br><span class="line">intChan &lt;- sum</span><br><span class="line"><span class="comment">// 计数器减一</span></span><br><span class="line">wg.Done()</span><br><span class="line">&#125;(intChan, &amp;wg)</span><br><span class="line"><span class="comment">// 另外创建个channle聚合结果</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(intChan <span class="keyword">chan</span> <span class="type">int</span>,wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">sum1 := &lt;-intChan</span><br><span class="line">sum2 := &lt;-intChan</span><br><span class="line">fmt.Printf(<span class="string">&quot;sum1 = %d sum2 = %d  \nsum1 + sum2 = %d \n&quot;</span>, sum1, sum2, sum1+sum2)</span><br><span class="line"><span class="comment">// 计数器减一</span></span><br><span class="line">wg.Done()</span><br><span class="line">&#125;(intChan,&amp;wg)</span><br><span class="line"><span class="comment">// 阻塞，直到等待组的计数器等于0</span></span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">&quot;运行结束&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">  sum1 = 1275 sum2 = 3775 </span></span><br><span class="line"><span class="comment">  sum1 + sum2 = 5050 </span></span><br><span class="line"><span class="comment">  运行结束</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="互斥锁-Mutex"><a href="#互斥锁-Mutex" class="headerlink" title="互斥锁(Mutex)"></a>互斥锁(Mutex)</h2><p><code>Mutex</code>是一个互斥锁，保证同时只有一个Goroutine可以访问共享资源。Mutex类型的锁和Goroutine无关，可以由不同的Goroutine加锁和解锁。也可以为其他结构体的字段，零值为解锁状态。</p><p><strong>结构介绍</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">state <span class="type">int32</span> <span class="comment">// state 表示当前互斥锁的状态</span></span><br><span class="line">sema  <span class="type">uint32</span> <span class="comment">// sema 是用于控制锁状态的信号量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法列表</strong></p><table>    <tr>        <th>方法名</th><th>功能</th>    </tr>    <tr>        <td>(m *Mutex) Lock()</td><td>方法锁住m，如果 m 已经加锁，则阻塞直到 m 解锁</td>    </tr>    <tr>        <td>(m *Mutex) Unlock()</td><td>解锁 m，如果 m 未加锁会导致运行时错误</td>    </tr></table><p><strong>模拟多个窗口售票</strong><br>不作为结构体属性使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 声明全局等待组</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="comment">// 声明全局锁</span></span><br><span class="line"><span class="keyword">var</span> mutex sync.Mutex</span><br><span class="line"><span class="comment">// 声明全局余票</span></span><br><span class="line"><span class="keyword">var</span> ticket <span class="type">int</span> = <span class="number">10</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 设置等待组计数器</span></span><br><span class="line">wg.Add(<span class="number">3</span>)</span><br><span class="line"><span class="comment">// 窗口卖票</span></span><br><span class="line"><span class="keyword">go</span> saleTicket(<span class="string">&quot;窗口A&quot;</span>,&amp;wg)</span><br><span class="line"><span class="keyword">go</span> saleTicket(<span class="string">&quot;窗口B&quot;</span>,&amp;wg)</span><br><span class="line"><span class="keyword">go</span> saleTicket(<span class="string">&quot;窗口C&quot;</span>,&amp;wg)</span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">&quot;运行结束!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 卖票流程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">saleTicket</span><span class="params">(windowName <span class="type">string</span>, wg *sync.WaitGroup)</span></span>  &#123;</span><br><span class="line"><span class="comment">// 卖票流程结束后关闭</span></span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">mutex.Lock()</span><br><span class="line"><span class="keyword">if</span>  ticket &gt; <span class="number">0</span>&#123;</span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Millisecond)</span><br><span class="line">ticket--</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s 卖出一张票，余票: %d \n&quot;</span>,windowName,ticket)</span><br><span class="line">&#125; <span class="keyword">else</span>  &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s 票已卖完! \n&quot;</span>,windowName)</span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">mutex.Unlock()</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 解锁</span></span><br><span class="line">mutex.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">  窗口C 卖出一张票，余票: 9 </span></span><br><span class="line"><span class="comment">  窗口C 卖出一张票，余票: 8 </span></span><br><span class="line"><span class="comment">  窗口B 卖出一张票，余票: 7 </span></span><br><span class="line"><span class="comment">  窗口A 卖出一张票，余票: 6 </span></span><br><span class="line"><span class="comment">  窗口C 卖出一张票，余票: 5 </span></span><br><span class="line"><span class="comment">  窗口B 卖出一张票，余票: 4 </span></span><br><span class="line"><span class="comment">  窗口A 卖出一张票，余票: 3 </span></span><br><span class="line"><span class="comment">  窗口C 卖出一张票，余票: 2 </span></span><br><span class="line"><span class="comment">  窗口B 卖出一张票，余票: 1 </span></span><br><span class="line"><span class="comment">  窗口A 卖出一张票，余票: 0 </span></span><br><span class="line"><span class="comment">  窗口C 票已卖完! </span></span><br><span class="line"><span class="comment">  窗口B 票已卖完! </span></span><br><span class="line"><span class="comment">  窗口A 票已卖完! </span></span><br><span class="line"><span class="comment">  运行结束!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>作为结构体属性使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 声明一个票池</span></span><br><span class="line"><span class="keyword">type</span> ticketPool <span class="keyword">struct</span> &#123;</span><br><span class="line">over <span class="type">int</span></span><br><span class="line">lock sync.Mutex</span><br><span class="line">wg   sync.WaitGroup</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义售票方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *ticketPool)</span></span> sellTicket(windowName <span class="type">string</span>) &#123;</span><br><span class="line"><span class="comment">// 等待组减一</span></span><br><span class="line"><span class="keyword">defer</span> t.wg.Done()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">t.lock.Lock()</span><br><span class="line"><span class="keyword">if</span> t.over &gt; <span class="number">0</span> &#123;</span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Millisecond)</span><br><span class="line">t.over--</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s 卖出一张票，余票: %d \n&quot;</span>, windowName, t.over)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 无票，跳无限循环并解锁</span></span><br><span class="line">t.lock.Unlock()</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s 票已卖完! \n&quot;</span>, windowName)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正常售票流程解锁</span></span><br><span class="line">t.lock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个票池</span></span><br><span class="line">ticketP := ticketPool&#123;over: <span class="number">10</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;T:%T v: %v \n&quot;</span>, ticketP, ticketP)</span><br><span class="line"><span class="comment">// 设置窗口数量</span></span><br><span class="line">windowNum := <span class="number">3</span></span><br><span class="line"><span class="comment">// 设置等待组计数器</span></span><br><span class="line">ticketP.wg.Add(windowNum)</span><br><span class="line"><span class="comment">// 定义3个窗口售票</span></span><br><span class="line"><span class="keyword">for</span> i:= <span class="number">1</span> ; i &lt;= windowNum; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> ticketP.sellTicket(<span class="string">&quot;窗口&quot;</span> + strconv.Itoa(i))</span><br><span class="line">&#125;</span><br><span class="line">ticketP.wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">&quot;运行结束!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">  窗口3 卖出一张票，余票: 9 </span></span><br><span class="line"><span class="comment">  窗口3 卖出一张票，余票: 8 </span></span><br><span class="line"><span class="comment">  窗口1 卖出一张票，余票: 7 </span></span><br><span class="line"><span class="comment">  窗口2 卖出一张票，余票: 6 </span></span><br><span class="line"><span class="comment">  窗口3 卖出一张票，余票: 5 </span></span><br><span class="line"><span class="comment">  窗口1 卖出一张票，余票: 4 </span></span><br><span class="line"><span class="comment">  窗口2 卖出一张票，余票: 3 </span></span><br><span class="line"><span class="comment">  窗口3 卖出一张票，余票: 2 </span></span><br><span class="line"><span class="comment">  窗口1 卖出一张票，余票: 1 </span></span><br><span class="line"><span class="comment">  窗口2 卖出一张票，余票: 0 </span></span><br><span class="line"><span class="comment">  窗口1 票已卖完! </span></span><br><span class="line"><span class="comment">  窗口2 票已卖完! </span></span><br><span class="line"><span class="comment">  窗口3 票已卖完! </span></span><br><span class="line"><span class="comment">  运行结束!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="读写锁-RWMutex"><a href="#读写锁-RWMutex" class="headerlink" title="读写锁(RWMutex)"></a>读写锁(RWMutex)</h2><p><strong>结构介绍</strong><br><code>RWMutex</code>是读写互斥锁，简称读写锁。该锁可以同时被多个读取者持有或被唯一个写入者持有。RWMutex类型锁跟Goroutine无关，可以由不同的Goroutine加锁、解锁。RWMutex也可以创建为其他结构体的字段；零值为解锁状态。</p><p><strong>RWMutex锁结构</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    w  Mutex <span class="comment">//用于控制多个写锁，获得写锁首先要获取该锁，如果有一个写锁在进行，那么再到来的写锁将会阻塞于此</span></span><br><span class="line">    writerSem  <span class="type">uint32</span> <span class="comment">//写阻塞等待的信号量，最后一个读者释放锁时会释放信号量</span></span><br><span class="line">    readerSem  <span class="type">uint32</span> <span class="comment">//读阻塞的协程等待的信号量，持有写锁的协程释放锁后会释放信号量</span></span><br><span class="line">    readerCount <span class="type">int32</span>  <span class="comment">//记录读者个数</span></span><br><span class="line">    readerWait  <span class="type">int32</span>  <span class="comment">//记录写阻塞时读者个数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>读写锁堵塞场景</strong></p><table>    <tr>        <th>场景</th><th>描述</th>    </tr>    <tr>        <td>写锁需要阻塞写锁</td><td>一个协程拥有写锁时，其他协程写锁需要阻塞</td>    </tr>    <tr>        <td>写锁需要阻塞读锁</td><td>一个协程拥有写锁时，其他协程读锁需要阻塞</td>    </tr>    <tr>        <td>读锁需要阻塞写锁</td><td>一个协程拥有读锁时，其他协程写锁需要阻塞</td>    </tr>    <tr>        <td>读锁不能阻塞读锁</td><td>一个协程拥有读锁时，其他协程也可以拥有读锁</td>    </tr></table><p><strong>方法列表</strong></p><table>    <tr>        <th>方法名</th><th>描述</th>    </tr>    <tr>        <td>(rw *RWMutex) RLock()</td><td>获取读锁,当一个协程拥有读锁时，其他协程写锁需要阻塞</td>    </tr>    <tr>        <td>(rw *RWMutex) RUnlock()</td><td>释放读锁</td>    </tr>    <tr>        <td>(rw *RWMutex) Lock()</td><td>获取写锁，与Mutex完全一致</td>    </tr>    <tr>        <td>(rw *RWMutex) Unlock()</td><td>释放写锁</td>    </tr></table><p><strong>读写文件</strong><br>不作为结构体属性使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 声明全局变量，文件内容</span></span><br><span class="line"><span class="keyword">var</span> fileContext <span class="type">string</span></span><br><span class="line"><span class="comment">// 声明全局读写互斥锁</span></span><br><span class="line"><span class="keyword">var</span> rxMutex sync.RWMutex</span><br><span class="line"><span class="comment">// 声明全局等待组</span></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 设置计数器</span></span><br><span class="line">wg.Add(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">name := <span class="string">&quot;同学-&quot;</span> + strconv.Itoa(i)</span><br><span class="line"><span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">go</span> readFile(name)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">go</span> writeFile(name, strconv.Itoa(i))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等待所有计数器执行完成</span></span><br><span class="line">wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">&quot;运行结束!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readFile</span><span class="params">(name <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 释放读锁</span></span><br><span class="line"><span class="keyword">defer</span> rxMutex.RUnlock()</span><br><span class="line"><span class="comment">// 获取读锁</span></span><br><span class="line">rxMutex.RLock()</span><br><span class="line"><span class="comment">// 打印读取内容</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s 获取读锁，读取内容为: %s \n&quot;</span>, name, fileContext)</span><br><span class="line"><span class="comment">// 计数器减一</span></span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeFile</span><span class="params">(name, s <span class="type">string</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 释放写锁</span></span><br><span class="line"><span class="keyword">defer</span> rxMutex.Unlock()</span><br><span class="line"><span class="comment">// 获取写锁</span></span><br><span class="line">rxMutex.Lock()</span><br><span class="line"><span class="comment">// 写入内容</span></span><br><span class="line">fileContext = fileContext + <span class="string">&quot; &quot;</span> + s</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s 获取写锁，写入内容: %s。 文件内容变成: %s \n&quot;</span>, name, s, fileContext)</span><br><span class="line"><span class="comment">// 计数器减一</span></span><br><span class="line">wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">  同学-1 获取写锁，写入内容: 1。 文件内容变成:  1 </span></span><br><span class="line"><span class="comment">  同学-4 获取读锁，读取内容为:  1 </span></span><br><span class="line"><span class="comment">  同学-2 获取读锁，读取内容为:  1 </span></span><br><span class="line"><span class="comment">  同学-5 获取写锁，写入内容: 5。 文件内容变成:  1 5 </span></span><br><span class="line"><span class="comment">  同学-3 获取写锁，写入内容: 3。 文件内容变成:  1 5 3 </span></span><br><span class="line"><span class="comment">  运行结束!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>作为结构体属性使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 定义一个文件结构体</span></span><br><span class="line"><span class="keyword">type</span> fileResource <span class="keyword">struct</span> &#123;</span><br><span class="line">content <span class="type">string</span></span><br><span class="line">wg sync.WaitGroup</span><br><span class="line">rwLock sync.RWMutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *fileResource)</span></span>readFile(name <span class="type">string</span>) &#123;</span><br><span class="line"><span class="comment">// 释放读锁</span></span><br><span class="line"><span class="keyword">defer</span> f.rwLock.RUnlock()</span><br><span class="line"><span class="comment">// 获取读锁</span></span><br><span class="line">f.rwLock.RLock()</span><br><span class="line"><span class="comment">// 打印读取内容</span></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s 获取读锁，读取内容为: %s \n&quot;</span>, name, f.content)</span><br><span class="line"><span class="comment">// 计数器减一</span></span><br><span class="line">f.wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *fileResource)</span></span>writeFile(name, s <span class="type">string</span>) &#123;</span><br><span class="line"><span class="comment">// 释放写锁</span></span><br><span class="line"><span class="keyword">defer</span> f.rwLock.Unlock()</span><br><span class="line"><span class="comment">// 获取写锁</span></span><br><span class="line">f.rwLock.Lock()</span><br><span class="line"><span class="comment">// 写入内容</span></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">f.content = f.content + <span class="string">&quot; &quot;</span> + s</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s 获取写锁，写入内容: %s。 文件内容变成: %s \n&quot;</span>, name, s, f.content)</span><br><span class="line"><span class="comment">// 计数器减一</span></span><br><span class="line">f.wg.Done()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 声明结构体</span></span><br><span class="line"><span class="keyword">var</span> file fileResource</span><br><span class="line"><span class="comment">// 设置计数器</span></span><br><span class="line">file.wg.Add(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++ &#123;</span><br><span class="line">name := <span class="string">&quot;同学-&quot;</span> + strconv.Itoa(i)</span><br><span class="line"><span class="keyword">if</span> i%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">go</span> file.readFile(name)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">go</span> file.writeFile(name, strconv.Itoa(i))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等待所有计数器执行完成</span></span><br><span class="line">file.wg.Wait()</span><br><span class="line">fmt.Println(<span class="string">&quot;运行结束!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">  同学-5 获取写锁，写入内容: 5。 文件内容变成:  5 </span></span><br><span class="line"><span class="comment">  同学-1 获取写锁，写入内容: 1。 文件内容变成:  5 1 </span></span><br><span class="line"><span class="comment">  同学-2 获取读锁，读取内容为:  5 1 </span></span><br><span class="line"><span class="comment">  同学-3 获取写锁，写入内容: 3。 文件内容变成:  5 1 3 </span></span><br><span class="line"><span class="comment">  同学-4 获取读锁，读取内容为:  5 1 3 </span></span><br><span class="line"><span class="comment">  运行结束!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="条件变量-Cond"><a href="#条件变量-Cond" class="headerlink" title="条件变量(Cond)"></a>条件变量(Cond)</h2><p><strong>介绍</strong><br>与互斥锁不同，条件变量的作用并不是保证在同一时刻仅有一个线程访问某一个共享数据，而是在对应的共享数据的状态发生变化时，通知其他因此而被阻塞的线程。条件变量总是与互斥锁组合使用，互斥锁为共享数据的访问提供互斥支持，而条件变量可以就共享数据的状态的变化向相关线程发出通知。</p><p>使用场景:  我需要完成一项任务，但是这项任务需要满足一定条件才可以执行，否则我就等着。</p><p><strong>方法列表</strong></p><table>    <tr>        <th>方法名</th><th>描述</th>    </tr>    <tr>        <td>NewCond(l Locker) *Cond</td><td>生成一个cond,需要传入实现Locker接口的变量，一般是*Mutex或*RWMutex类型的值</td>    </tr>    <tr>        <td>(c *Cond) Wait()</td><td>等待通知</td>    </tr>    <tr>        <td>(c *Cond) Signal()</td><td>发送单个通知</td>    </tr>    <tr>        <td>(c *Cond) Broadcast()</td><td>广播(多个通知)</td>    </tr></table><p><strong>使用示例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 声明互斥锁</span></span><br><span class="line"><span class="keyword">var</span> mutex sync.Mutex</span><br><span class="line"><span class="comment">// 声明条件变量</span></span><br><span class="line">cond := sync.NewCond(&amp;mutex)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line">cond.L.Lock()</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line"><span class="keyword">defer</span> cond.L.Unlock()</span><br><span class="line"><span class="comment">// 等待通知,阻塞当前协程</span></span><br><span class="line">cond.Wait()</span><br><span class="line"><span class="comment">// 等待通知后打印输出</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;输出:%d ! \n&quot;</span>, i)</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 单个通知</span></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">fmt.Println(<span class="string">&quot;单个通知A！&quot;</span>)</span><br><span class="line">cond.Signal()</span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">fmt.Println(<span class="string">&quot;单个通知B！&quot;</span>)</span><br><span class="line">cond.Signal()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 广播通知</span></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">fmt.Println(<span class="string">&quot;广播通知！并睡眠1秒，等待其他协程输出!&quot;</span>)</span><br><span class="line">cond.Broadcast()</span><br><span class="line"><span class="comment">// 等待其他协程处理完</span></span><br><span class="line">time.Sleep(time.Second)</span><br><span class="line">fmt.Println(<span class="string">&quot;运行结束！&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">  单个通知A！</span></span><br><span class="line"><span class="comment">  输出:1 ! </span></span><br><span class="line"><span class="comment">  单个通知B！</span></span><br><span class="line"><span class="comment">  输出:4 ! </span></span><br><span class="line"><span class="comment">  广播通知！并睡眠1秒，等待其他协程输出!</span></span><br><span class="line"><span class="comment">  输出:10 ! </span></span><br><span class="line"><span class="comment">  输出:2 ! </span></span><br><span class="line"><span class="comment">  输出:3 ! </span></span><br><span class="line"><span class="comment">  输出:8 ! </span></span><br><span class="line"><span class="comment">  输出:9 ! </span></span><br><span class="line"><span class="comment">  输出:6 ! </span></span><br><span class="line"><span class="comment">  输出:5 ! </span></span><br><span class="line"><span class="comment">  输出:7 ! </span></span><br><span class="line"><span class="comment">  运行结束！</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="一次-Once"><a href="#一次-Once" class="headerlink" title="一次(Once)"></a>一次(Once)</h2><p><code>sync.Once</code> 是使Go方法只执行一次的对象实现，作用与 init 函数类似,但也有所不同。区别如下:</p><p><code>init</code> 函数是在文件包首次被加载的时候执行，且只执行一次<br><code>sync.Onc</code> 是在代码运行中需要的时候执行，且只执行一次</p><p><strong>方法介绍</strong></p><table>    <tr>        <th>方法名</th><th>描述</th>    </tr>    <tr>        <td>(o *Once) Do(f func())</td><td>函数只会执行一次，并保证在返回时，传入Do的函数已经执行完成。</td>    </tr></table>多个 goroutine 同时执行 once.Do 的时候，可以保证抢占到 once.Do 执行权的 goroutine 执行完 once.Do 后，其他goroutine才能得到返回 。<p><strong>重复调用只执行一次</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">echo := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">t := time.Now().Unix()</span><br><span class="line">fmt.Printf(<span class="string">&quot;输出时间 %v &quot;</span>,strconv.FormatInt(t,<span class="number">10</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> one sync.Once</span><br><span class="line">  <span class="comment">// 虽然遍历调用，但是只会执行一次</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i&lt; <span class="number">10</span> ; i++  &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(a,b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">one.Do(echo)</span><br><span class="line">&#125;(i,i+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">fmt.Println(<span class="string">&quot;运行结束！&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">  输出时间 1608083525 </span></span><br><span class="line"><span class="comment">  运行结束！</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="对象池-Pool"><a href="#对象池-Pool" class="headerlink" title="对象池(Pool)"></a>对象池(Pool)</h2><p><strong>为什么使用?</strong><br>Go语言是支持垃圾自动回收的。对于一些暂时用不到但是后续会用到的对象，为了提升性能，可以先暂存起来，这虽然会占用一些内存，但是比起销毁了再新建，要节省运行时间。Go语言专门提供了暂存对象的工具，就是sync.Pool。</p><p><code>sync.Pool</code>是一个对象池，它是并发安全的，而且大小是可伸缩的，仅受限于内存。当需要使用对象的时候可以从对象池中直接取出使用。</p><p><strong>数据结构</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">noCopy noCopy <span class="comment">//禁止复制</span></span><br><span class="line">local     unsafe.Pointer <span class="comment">//本地缓冲池指针,每个处理器分配一个;其类型是[P]poolLocal数组</span></span><br><span class="line">localSize <span class="type">uintptr</span> <span class="comment">//数组大小</span></span><br><span class="line"></span><br><span class="line">victim     unsafe.Pointer <span class="comment">// local from previous cycle</span></span><br><span class="line">victimSize <span class="type">uintptr</span>        <span class="comment">// size of victims array</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 缓存池没有对象时,调用此方法创建</span></span><br><span class="line">New <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>方法列表</strong><br>sync.Pool提供以下两个公共方法，用来操作对象池。</p><table>    <tr>        <th>方法名</th><th>描述</th>    </tr>    <tr>        <td>(p *Pool) Put(x interface{})</td><td>向池中添加对象</td>    </tr>    <tr>        <td>(p *Pool) Get() interface{}</td><td>从池中获取对象</td>    </tr></table><p>Get方法是从池中获取对象，如果没有对象则调用New方法创建生成，如果未设置New则返回nil。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建对象池</span></span><br><span class="line">pool := sync.Pool&#123;</span><br><span class="line">New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">make</span>([]<span class="type">string</span>,<span class="number">5</span>)</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 首次获取</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;不设置直接获取: %v\n&quot;</span>,pool.Get())</span><br><span class="line"><span class="comment">// 设置后获取</span></span><br><span class="line">pool.Put([]<span class="type">string</span>&#123;<span class="string">&quot;Hello&quot;</span>,<span class="string">&quot;Word&quot;</span>&#125;)</span><br><span class="line"><span class="comment">// 设置后获取</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;设置后,第一次获取: %v\n&quot;</span>,pool.Get())</span><br><span class="line">fmt.Printf(<span class="string">&quot;设置后,第二次获取: %v\n&quot;</span>,pool.Get())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意事项</strong><br>存入sync.Pool的对象可能会在不通知的情况下被释放，这一点一定要注意。比如一些socket长连接就不适合存入sync.Pool内。</p><h2 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h2><p>如果要缓存的数据量不大，可以考虑使用sync.Map(Go 1.9+版本支持)。在1.6版本以前，Go语言自带标准的map类型是并发读安全的，但是并发写不安全。</p><h3 id="查询和新增"><a href="#查询和新增" class="headerlink" title="查询和新增"></a>查询和新增</h3><p><strong>查找方法</strong><br><code>Load</code>: 通过参数key查询对应的value，如果不存在则返回nil；ok表示是否找到对应的值。</p><p><strong>新增方法</strong><br><code>Store</code>: 对sync.Map的更新或新增，参数是键值对<br><code>LoadOrStore</code>: 参数为key和value。根据参数key查找对应的value，如果找到,则不修改原来的值并通过actual返回，并且loaded为true；如果未找到，则存储key-value并且将存储的value通过actual返回，loaded为false。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 定义map 类型</span></span><br><span class="line"><span class="keyword">var</span> syncMap sync.Map</span><br><span class="line"><span class="comment">// 新增</span></span><br><span class="line">syncMap.Store(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;张三&quot;</span>)</span><br><span class="line">load, _ := syncMap.Load(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Store新增-&gt;name:%v\n&quot;</span>,load)</span><br><span class="line"><span class="comment">// 找到则不更新，返回旧值</span></span><br><span class="line">store, loaded := syncMap.LoadOrStore(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;李四&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;找到则返回旧值-&gt; name:%v loaded:%v \n&quot;</span>,store,loaded)</span><br><span class="line"><span class="comment">// 找不到则新增</span></span><br><span class="line">age, loaded := syncMap.LoadOrStore(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;找不到则新增-&gt; age:%v loaded:%v \n&quot;</span>,age,loaded)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出:</span></span><br><span class="line"><span class="comment">Store新增-&gt;name:张三</span></span><br><span class="line"><span class="comment">找到则返回旧值-&gt; name:张三 loaded:true </span></span><br><span class="line"><span class="comment">找不到则新增-&gt; age:20 loaded:false </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p><code>LoadAndDelete</code>: 根据参数key删除对应的value，如果找到则删除，并通过value返回删除的值，并设置loaded为true；如果未找到，则value返回nil，loaded为false。<br><code>Delete</code>：根据参数key删除对应的value。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 定义map 类型</span></span><br><span class="line"><span class="keyword">var</span> syncMap sync.Map</span><br><span class="line"><span class="comment">// 新增</span></span><br><span class="line">syncMap.Store(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;张三&quot;</span>)</span><br><span class="line">syncMap.Store(<span class="string">&quot;age&quot;</span>,<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 找到情况</span></span><br><span class="line">andDelete, loaded := syncMap.LoadAndDelete(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;找到-&gt; val:%v loaded:%v \n&quot;</span>,andDelete,loaded)</span><br><span class="line">search, ok := syncMap.Load(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;删除name后查找-&gt; search:%v ok:%v \n&quot;</span>,search,ok)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找不到情况</span></span><br><span class="line">andDelete2, loaded := syncMap.LoadAndDelete(<span class="string">&quot;name2&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;找不到-&gt; val:%v loaded:%v \n&quot;</span>,andDelete2,loaded)</span><br><span class="line"></span><br><span class="line">syncMap.Delete(<span class="string">&quot;age&quot;</span>)</span><br><span class="line">searchAge, ok := syncMap.Load(<span class="string">&quot;name&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;删除age后查找-&gt; searchAge:%v ok:%v \n&quot;</span>,searchAge,ok)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 输出</span></span><br><span class="line"><span class="comment">找到-&gt; val:张三 loaded:true </span></span><br><span class="line"><span class="comment">删除name后查找-&gt; search:&lt;nil&gt; ok:false </span></span><br><span class="line"><span class="comment">找不到-&gt; val:&lt;nil&gt; loaded:false </span></span><br><span class="line"><span class="comment">删除age后查找-&gt; searchAge:&lt;nil&gt; ok:false </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>sync.Map不能通过for…range遍历，只能通过包提供的方法Range进行遍历。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 定义map 类型</span></span><br><span class="line"><span class="keyword">var</span> syncMap sync.Map</span><br><span class="line"><span class="comment">// 新增</span></span><br><span class="line">syncMap.Store(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>)</span><br><span class="line">syncMap.Store(<span class="string">&quot;age&quot;</span>, <span class="number">20</span>)</span><br><span class="line">syncMap.Store(<span class="string">&quot;home&quot;</span>, <span class="string">&quot;天津永和大区&quot;</span>)</span><br><span class="line">syncMap.Range(<span class="function"><span class="keyword">func</span><span class="params">(key, value <span class="keyword">interface</span>&#123;&#125;)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;key: %v value: %v \n&quot;</span>, key, value)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">key: name value: 张三 </span></span><br><span class="line"><span class="comment">key: age value: 20 </span></span><br><span class="line"><span class="comment">key: home value: 天津永和大区 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;sync包提供了互斥锁。除了Once和WaitGroup类型，其余多数适用于低水平的程序，多数情况下，高水平的同步使用channel通信性能会更优一些。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="GO" scheme="https://rma-shuyu.github.io/categories/GO/"/>
    
    
    <category term="go" scheme="https://rma-shuyu.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>context包使用</title>
    <link href="https://rma-shuyu.github.io/2021/04/27/context%E5%8C%85%E4%BD%BF%E7%94%A8/"/>
    <id>https://rma-shuyu.github.io/2021/04/27/context%E5%8C%85%E4%BD%BF%E7%94%A8/</id>
    <published>2021-04-27T12:27:18.000Z</published>
    <updated>2023-01-27T12:06:26.874Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是上下文"><a href="#什么是上下文" class="headerlink" title="什么是上下文?"></a>什么是上下文?</h2><blockquote><p>从Go 1.7开始, 标准库引入context(上下文)，他主要用来在goroutine之间传递上下文信息(同步信号、超时时间、截止时间、Key-Val值对)。</p></blockquote><span id="more"></span><h2 id="为什么要用上下文"><a href="#为什么要用上下文" class="headerlink" title="为什么要用上下文?"></a>为什么要用上下文?</h2><p><strong>场景说明</strong><br>在实际开发过程中，我们往往会在main.goroutine(主协程)中开启N 个goroutine(子协程)来处理其他逻辑，那么主协程和 子协程之间信号怎么同步呢？列举以下几个需要信号同步的场景。</p><p>当主协程报错或者因为其他原因需要取消时，需要通知子协程取消任务。<br>创建子协程时,希望指定超时时间或截止时间后，自动取消任务。</p><p><strong>怎么解决？</strong><br>context 包提供了一些函数，协助用户从现有的 Context 对象创建新的 Context 对象。<br>这些 Context 对象形成一棵树：当一个 Context 对象被取消时，继承自它的所有 Context 都会被取消。</p><p>Background 是所有 Context 对象树的根，它不能被取消。</p><h2 id="上下文接口"><a href="#上下文接口" class="headerlink" title="上下文接口"></a>上下文接口</h2><p>context包中定义了一个接口context.Context,具体定义代码如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="comment">// deadline: 返回取消的时间点(到点Context会自动取消请求)</span></span><br><span class="line">  <span class="comment">// ok：false代表没有设置截止时间</span></span><br><span class="line">Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 返回一个只读的Chan</span></span><br><span class="line">  <span class="comment">// 这个Channel 会在当前工作完成或者上下文被取消后关闭,</span></span><br><span class="line">  <span class="comment">// 多次调用 Done 方法会返回同一个 Channel；</span></span><br><span class="line">Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//返回 context.Context 结束的原因，</span></span><br><span class="line">  <span class="comment">// 它只会在 Done 方法对应的 Channel 关闭时返回非空的值；</span></span><br><span class="line">Err() <span class="type">error</span></span><br><span class="line"><span class="comment">// 从 context.Context 中获取键对应的值</span></span><br><span class="line">  <span class="comment">// 对于同一个上下文来说，多次调用 Value 并传入相同的 Key 会返回相同的结果</span></span><br><span class="line">Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="创建父上下文"><a href="#创建父上下文" class="headerlink" title="创建父上下文"></a>创建父上下文</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span></span> Context &#123;</span><br><span class="line"><span class="keyword">return</span> background</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TODO</span><span class="params">()</span></span> Context &#123;</span><br><span class="line"><span class="keyword">return</span> todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>context</code> 包中最常用的方法是 <code>context.Background</code>、<code>context.TODO</code>，这两个方法都会返回预先初始化好的私有变量 <code>background</code> 和 <code>todo</code>,使用区别如下:<br><code>Background</code>: 主要用于main函数、初始化以及测试代码中，作为最顶层的Context，也就是根Context。<br><code>TODO</code>: 当我们不知道该使用什么类型的Context的时候，可以使用这个。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 基于context.Background()为根，创建新的超时上下文</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Begin:%s\n&quot;</span>, time.Now())</span><br><span class="line">timeoutCtx, cancelFunc := context.WithTimeout(context.Background(), <span class="number">3</span>*time.Second)</span><br><span class="line"><span class="comment">// 3秒后自动取消</span></span><br><span class="line"><span class="keyword">defer</span> cancelFunc()</span><br><span class="line"><span class="comment">// 子协程执行取消</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;子协程输出...&quot;</span>)</span><br><span class="line">&#125;(timeoutCtx)</span><br><span class="line"><span class="comment">// 等待上下文处于完成状态</span></span><br><span class="line">&lt;-timeoutCtx.Done()</span><br><span class="line">fmt.Printf(<span class="string">&quot;等待超时结束：%s \n&quot;</span>, time.Now())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出()</span></span><br><span class="line"><span class="comment">Begin:2021-04-19 17:10:26.625493 +0800 CST m=+0.000780950</span></span><br><span class="line"><span class="comment">子协程输出...</span></span><br><span class="line"><span class="comment">等待超时结束：2021-04-19 17:10:29.627471 +0800 CST m=+3.002727432 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="创建子上下文"><a href="#创建子上下文" class="headerlink" title="创建子上下文"></a>创建子上下文</h2><h3 id="可取消的-WithCancel"><a href="#可取消的-WithCancel" class="headerlink" title="可取消的(WithCancel)"></a>可取消的(WithCancel)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent 父上下文</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc)</span><br></pre></td></tr></table></figure><p><code>context.WithCancel</code> 函数能够从 <code>context.Context</code> 中衍生出一个新的子上下文并返回用于取消该上下文的函数。一旦我们执行返回的取消函数，当前上下文以及它的子上下文都会被取消，所有的 Goroutine 都会同步收到这一取消信号。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Begin:%s\n&quot;</span>, time.Now())</span><br><span class="line"><span class="comment">// 基于context.Background()为根，创建一个可取消的子Context</span></span><br><span class="line">cancelCtx, cancelFunc := context.WithCancel(context.Background())</span><br><span class="line"><span class="comment">// 子协程执行取消</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">fmt.Println(<span class="string">&quot;子协程终止,上下文已被取消&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s: 子协程输出\n&quot;</span>, time.Now())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;(cancelCtx)</span><br><span class="line"><span class="comment">// 3秒后执行取消操作</span></span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line"><span class="comment">// 取消上下文，子协程也会停止输出</span></span><br><span class="line">cancelFunc()</span><br><span class="line"><span class="comment">// 看看子协程是否停止</span></span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">fmt.Printf(<span class="string">&quot;End：%s \n&quot;</span>, time.Now())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出</span></span><br><span class="line"><span class="comment">Begin:2021-04-20 11:08:29.77314 +0800 CST m=+0.000635148</span></span><br><span class="line"><span class="comment">2021-04-20 11:08:30.776474 +0800 CST m=+1.003963915: 子协程输出</span></span><br><span class="line"><span class="comment">2021-04-20 11:08:31.780469 +0800 CST m=+2.007953399: 子协程输出</span></span><br><span class="line"><span class="comment">2021-04-20 11:08:32.781569 +0800 CST m=+3.009048079: 子协程输出</span></span><br><span class="line"><span class="comment">子协程终止,上下文已被取消</span></span><br><span class="line"><span class="comment">End：2021-04-20 11:08:33.778543 +0800 CST m=+4.006016052 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="指定超时时间-WithTimeout"><a href="#指定超时时间-WithTimeout" class="headerlink" title="指定超时时间(WithTimeout)"></a>指定超时时间(WithTimeout)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc)</span><br></pre></td></tr></table></figure><p><code>context.WithTimeout</code> 函数接收父上下文(parent)和一个超时时间，能够从 <code>context.Context </code>中衍生出一个新的子上下文并返回用于取消该上下文的函数。执行取消函数时功能和WithCancel一样。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 等待超时，自动取消</span></span><br><span class="line">waitTimeOut()</span><br><span class="line"><span class="comment">// 子协程主动发送取消信号</span></span><br><span class="line">subSendCancel()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待超时，自动取消</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">waitTimeOut</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;等待超时——&gt; Begin:%s\n&quot;</span>, time.Now())</span><br><span class="line"><span class="comment">// 基于context.Background()为根，创建一个3秒后自动取消的子Context</span></span><br><span class="line">ctx, cancelFunc := context.WithTimeout(context.Background(), <span class="number">3</span>*time.Second)</span><br><span class="line"><span class="comment">// 延迟关闭</span></span><br><span class="line"><span class="keyword">defer</span> cancelFunc()</span><br><span class="line"><span class="comment">// 创建子协程</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">fmt.Println(<span class="string">&quot;子协程收到取消信号，终止&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">fmt.Printf(<span class="string">&quot;子协程输出:%s\n&quot;</span>, time.Now())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;(ctx)</span><br><span class="line"><span class="comment">// 等待超时，自动取消</span></span><br><span class="line">&lt;-ctx.Done()</span><br><span class="line"><span class="comment">// 超时后，查看子协程输出</span></span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">fmt.Printf(<span class="string">&quot;End：%s \n&quot;</span>, time.Now())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子协程主动发送取消信号</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subSendCancel</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;子协程主动发送取消信号——&gt; Begin:%s\n&quot;</span>, time.Now())</span><br><span class="line"><span class="comment">// 基于context.Background()为根，创建一个可取消的子Context</span></span><br><span class="line">cancelCtx, cancelFunc := context.WithTimeout(context.Background(), <span class="number">5</span>*time.Second)</span><br><span class="line"><span class="comment">// 创建子协程</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(cancelFunc context.CancelFunc)</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;子协程发送-&gt;取消信号&quot;</span>)</span><br><span class="line">cancelFunc()</span><br><span class="line">&#125;(cancelFunc)</span><br><span class="line"><span class="comment">// 同步阻塞</span></span><br><span class="line">&lt;-cancelCtx.Done()</span><br><span class="line">fmt.Printf(<span class="string">&quot;End：%s \n&quot;</span>, time.Now())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">等待超时——&gt; Begin:2021-04-20 11:43:59.232983 +0800 CST m=+0.000634095</span></span><br><span class="line"><span class="comment">子协程输出:2021-04-20 11:44:00.237187 +0800 CST m=+1.004832384</span></span><br><span class="line"><span class="comment">子协程输出:2021-04-20 11:44:01.240217 +0800 CST m=+2.007856775</span></span><br><span class="line"><span class="comment">子协程输出:2021-04-20 11:44:02.24042 +0800 CST m=+3.008054083</span></span><br><span class="line"><span class="comment">子协程收到取消信号，终止</span></span><br><span class="line"><span class="comment">End：2021-04-20 11:44:04.239543 +0800 CST m=+5.007166176 </span></span><br><span class="line"><span class="comment">子协程主动发送取消信号——&gt; Begin:2021-04-20 11:44:04.239701 +0800 CST m=+5.007323972</span></span><br><span class="line"><span class="comment">子协程发送-&gt;取消信号</span></span><br><span class="line"><span class="comment">End：2021-04-20 11:44:04.239809 +0800 CST m=+5.007432189 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="指定截止时间-WithDeadline"><a href="#指定截止时间-WithDeadline" class="headerlink" title="指定截止时间(WithDeadline)"></a>指定截止时间(WithDeadline)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span></span> (Context, CancelFunc) </span><br></pre></td></tr></table></figure><p><code>context.WithDeadline</code> 函数接收父上下文(parent)和一个截止时间，能够从 <code>context.Context</code> 中衍生出一个新的子上下文并返回用于取消该上下文的函数。执行取消函数时功能和WithCancel一样。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Begin:%s\n&quot;</span>, time.Now())</span><br><span class="line"><span class="comment">// 基于context.Background()为根，创建一个5秒后自动取消的子Context</span></span><br><span class="line">deadlineCtx, cancelFunc := context.WithDeadline(context.Background(), time.Now().Add(<span class="number">3</span>*time.Second))</span><br><span class="line"><span class="keyword">defer</span> cancelFunc()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span>  &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">fmt.Println(<span class="string">&quot;子协程终止,上下文已被取消&quot;</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">fmt.Printf(<span class="string">&quot;子协程输出: %s\n&quot;</span>,time.Now())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;(deadlineCtx)</span><br><span class="line"><span class="comment">// 同步阻塞，直到上下文被完成或取消</span></span><br><span class="line">&lt;-deadlineCtx.Done()</span><br><span class="line"><span class="comment">// 查看子协程是否收到取消信号</span></span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">fmt.Printf(<span class="string">&quot;End：%s \n&quot;</span>, time.Now())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">Begin:2021-04-20 13:54:56.224477 +0800 CST m=+0.000826415</span></span><br><span class="line"><span class="comment">子协程输出: 2021-04-20 13:54:57.227495 +0800 CST m=+1.003830376</span></span><br><span class="line"><span class="comment">子协程输出: 2021-04-20 13:54:58.229607 +0800 CST m=+2.005927050</span></span><br><span class="line"><span class="comment">子协程输出: 2021-04-20 13:54:59.230173 +0800 CST m=+3.006503681</span></span><br><span class="line"><span class="comment">子协程输出: 2021-04-20 13:55:00.233766 +0800 CST m=+4.010057104</span></span><br><span class="line"><span class="comment">子协程终止,上下文已被取消</span></span><br><span class="line"><span class="comment">End：2021-04-20 13:55:00.233781 +0800 CST m=+4.010072336 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="上下文中传值"><a href="#上下文中传值" class="headerlink" title="上下文中传值"></a>上下文中传值</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parent:父上下文</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span></span> Context </span><br></pre></td></tr></table></figure><p><code>context.WithValue</code> 能从父 Context中创建一个子子 Context,并传体一个键值对信息给子 Context，在子 Context中，通过context.Value获取对应的值信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Begin:%s\n&quot;</span>, time.Now())</span><br><span class="line"><span class="comment">// 基于context.Background()为根，创建一个5秒后自动取消的子Context</span></span><br><span class="line">parentCtx, cancelFunc := context.WithCancel(context.Background())</span><br><span class="line"><span class="comment">// 传体信息</span></span><br><span class="line">valueCtx := context.WithValue(parentCtx, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;张三&quot;</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context, cancelFunc2 context.CancelFunc)</span></span> &#123;</span><br><span class="line"><span class="comment">// 取出上下文中key=name的值</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;取出上下文中的name: %v\n&quot;</span>, ctx.Value(<span class="string">&quot;name&quot;</span>))</span><br><span class="line"><span class="comment">// 子协程发送取消信号</span></span><br><span class="line">cancelFunc()</span><br><span class="line">&#125;(valueCtx, cancelFunc)</span><br><span class="line"><span class="comment">// 等待工作完成或者上下文被取消</span></span><br><span class="line">&lt;-parentCtx.Done()</span><br><span class="line">fmt.Printf(<span class="string">&quot;End：%s \n&quot;</span>, time.Now())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">Begin:2021-04-20 14:15:57.243469 +0800 CST m=+0.000674192</span></span><br><span class="line"><span class="comment">取出上下文中的name: 张三</span></span><br><span class="line"><span class="comment">End：2021-04-20 14:15:57.243699 +0800 CST m=+0.000904753 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是上下文&quot;&gt;&lt;a href=&quot;#什么是上下文&quot; class=&quot;headerlink&quot; title=&quot;什么是上下文?&quot;&gt;&lt;/a&gt;什么是上下文?&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;从Go 1.7开始, 标准库引入context(上下文)，他主要用来在goroutine之间传递上下文信息(同步信号、超时时间、截止时间、Key-Val值对)。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="GO" scheme="https://rma-shuyu.github.io/categories/GO/"/>
    
    
    <category term="go" scheme="https://rma-shuyu.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>bufio包使用</title>
    <link href="https://rma-shuyu.github.io/2021/04/26/bufio%E5%8C%85%E4%BD%BF%E7%94%A8/"/>
    <id>https://rma-shuyu.github.io/2021/04/26/bufio%E5%8C%85%E4%BD%BF%E7%94%A8/</id>
    <published>2021-04-26T12:27:18.000Z</published>
    <updated>2023-01-27T12:06:26.870Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote><p>bufio包实现了有缓冲的I/O。它包装一个io.Reader或io.Writer接口对象，使用这个包可以大幅提高文件读写的效率。</p></blockquote><span id="more"></span><h2 id="如何提高效率"><a href="#如何提高效率" class="headerlink" title="如何提高效率?"></a>如何提高效率?</h2><p><img src="9c1c4f918059c695ae7814b606b654bdd3800fe60c5fa57c4c590c42f8035381.png" alt="图 1">  </p><p><strong>写入流程梳理</strong>:<br>当写入内容小于缓冲区(buf)的可用大小时,内容写入缓存区(buf)；<br>当缓冲区(buf)空间不够时，一次性将缓冲区(buf)内容写入文件,并清空缓存区(buf)；<br>当写入内容大于缓冲区(buf)空间时，将内容直接写入文件；</p><p><strong>读取流程梳理</strong>:<br>当缓冲区(buf)内容为空时，一次性从文件中读取大小等于缓冲区(buf)的内容；<br>当读取内容小于缓冲区(buf)空间时,从缓存区(buf)读取；<br>当读取内容大于缓冲区(buf)空间时，将内容从文件直接读取；</p><p><strong>总结</strong>:  避免频繁操作文件、减少访问本地磁盘次数，从而提高效率。</p><h2 id="读取-Read"><a href="#读取-Read" class="headerlink" title="读取(Read*)"></a>读取(Read*)</h2><h3 id="创建读取器"><a href="#创建读取器" class="headerlink" title="创建读取器"></a>创建读取器</h3><p><strong>创建默认缓冲大小 (NewReader)</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReader</span><span class="params">(rd io.Reader)</span></span> *Reader</span><br></pre></td></tr></table></figure><p>根据rd创建一个具有默认大小缓冲的*Reader。默认大小:4096字节</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reader := bufio.NewReader(strings.NewReader(<span class="string">&quot;hello Word&quot;</span>))</span><br><span class="line">fmt.Printf(<span class="string">&quot;默认大小:%v&quot;</span>,reader.Size())</span><br><span class="line"><span class="comment">// 输出: 默认大小:4096</span></span><br></pre></td></tr></table></figure><p><strong>创建指定缓冲大小( NewReaderSize)</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewReaderSize</span><span class="params">(rd io.Reader, size <span class="type">int</span>)</span></span> *Reader</span><br></pre></td></tr></table></figure><p>根据rd创建指定size大小缓冲的*Reader。最小大小为16字节</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">reader := bufio.NewReaderSize(strings.NewReader(<span class="string">&quot;hello Word&quot;</span>),<span class="number">40</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;大于16字节:%v\n&quot;</span>,reader.Size())</span><br><span class="line">reader2 := bufio.NewReaderSize(strings.NewReader(<span class="string">&quot;hello Word&quot;</span>),<span class="number">4</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;小于16字节:%v\n&quot;</span>,reader2.Size())</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">大于16字节:40</span></span><br><span class="line"><span class="comment">小于16字节:16</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="读取指定字节-Read"><a href="#读取指定字节-Read" class="headerlink" title="读取指定字节(Read)"></a>读取指定字节(Read)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span></span> Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>将读取数据写入p。返回写入p的字节数和错误信息。当读取到达结尾时，返回值n将为0而err将为io.EOF。</p><p>现有文件a.txt,内容如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">张三 23 北京 男</span><br><span class="line">李四 22 南京 男</span><br><span class="line">郭明 32 上海 男</span><br><span class="line">王英 18 武汉 女</span><br></pre></td></tr></table></figure><p>读取程序如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//打开一个文件</span></span><br><span class="line">file, err := os.Open(<span class="string">&quot;./a.txt&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭文件</span></span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"><span class="comment">// 创建读取器</span></span><br><span class="line">reader := bufio.NewReader(file)</span><br><span class="line"><span class="keyword">for</span>  &#123;</span><br><span class="line"><span class="comment">// 一次读取21个字节</span></span><br><span class="line">context := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">21</span>)</span><br><span class="line">_, err = reader.Read(context)</span><br><span class="line"><span class="comment">// 读取完毕，则跳出</span></span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;读取内容:%s&quot;</span>, context)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出</span></span><br><span class="line"><span class="comment">读取内容:张三 23 北京 男</span></span><br><span class="line"><span class="comment">读取内容:李四 22 南京 男</span></span><br><span class="line"><span class="comment">读取内容:郭明 32 上海 男</span></span><br><span class="line"><span class="comment">读取内容:王英 18 武汉 女</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="读取一个字节-ReadByte"><a href="#读取一个字节-ReadByte" class="headerlink" title="读取一个字节(ReadByte)"></a>读取一个字节(ReadByte)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span></span> ReadByte() (<span class="type">byte</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>每次读取一个字节返回。当读取到达结尾时，返回值n将为0而err将为io.EOF。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 基于字符串创建读取器</span></span><br><span class="line">reader := bufio.NewReader(strings.NewReader(<span class="string">&quot;Go,Word!&quot;</span>))</span><br><span class="line"><span class="keyword">for</span>  &#123;</span><br><span class="line"><span class="comment">// 一次读取1个字节</span></span><br><span class="line">readByte, err := reader.ReadByte()</span><br><span class="line"><span class="comment">// 读取完毕，则跳出</span></span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;读取内容:%s\n&quot;</span>, <span class="type">string</span>(readByte))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">读取内容:G</span></span><br><span class="line"><span class="comment">读取内容:o</span></span><br><span class="line"><span class="comment">读取内容:,</span></span><br><span class="line"><span class="comment">读取内容:W</span></span><br><span class="line"><span class="comment">读取内容:o</span></span><br><span class="line"><span class="comment">读取内容:r</span></span><br><span class="line"><span class="comment">读取内容:d</span></span><br><span class="line"><span class="comment">读取内容:!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="读取一行-ReadLine"><a href="#读取一行-ReadLine" class="headerlink" title="读取一行(ReadLine)"></a>读取一行(ReadLine)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span></span> ReadLine() (line []<span class="type">byte</span>, isPrefix <span class="type">bool</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p><code>ReadLine</code>尝试读取返回一行数据，不包括行尾标志的字节,但是有以下几个场景需要注意:</p><p>如果行太长超过了缓冲，返回值isPrefix=true,Line为行的前一部分。<br>该行剩下部分将在下一次读取中返回并且此时的isPrefix=false,<strong>即isPrefix会在行的最后一个片段时才设为false</strong>。<br>如果行内小于等于缓冲,isPrefix=false,Line为一整行的内容。<br>官方文档中推荐使用 <code>ReadBytes</code>(‘\n’)或<code>ReadString</code>(‘\n’)来代替ReadLine。</p><p><strong>当行超过了缓冲缓存时</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建字符串，每行超过16个字节</span></span><br><span class="line">str := strings.Repeat(<span class="string">&quot;Hello,Hello,Hello,Hello!\n&quot;</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 基于字符串创建一个缓冲区=16字节的读取器</span></span><br><span class="line">reader := bufio.NewReaderSize(strings.NewReader(str), <span class="number">16</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 每次读取一行</span></span><br><span class="line">line, prefix, err := reader.ReadLine()</span><br><span class="line"><span class="comment">// 读取完毕，则跳出</span></span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;line:%s isPrefix:%t \n&quot;</span>, line, prefix)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:<br><img src="100d5bb2c02b34eac47eea2aa1738aadf03ba71c8a708bc855081f988cd06d93.png" alt="图 4">  </p><p><strong>当行小于缓冲缓存时</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 每行不超过16个字节</span></span><br><span class="line">str := strings.Repeat(<span class="string">&quot;Hello Word!\n&quot;</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 基于字符串创建读取器</span></span><br><span class="line">reader := bufio.NewReaderSize(strings.NewReader(str), <span class="number">16</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 每次读取一行</span></span><br><span class="line">line, prefix, err := reader.ReadLine()</span><br><span class="line"><span class="comment">// 读取完毕，则跳出</span></span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;line:%s isPrefix:%t \n&quot;</span>, line, prefix)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:<br><img src="5d468f8e153fe27014650ee38ec32342ea7eae6a63fd65b0d802ec42a5924cbf.png" alt="图 3">  </p><h3 id="读取到指定的字符"><a href="#读取到指定的字符" class="headerlink" title="读取到指定的字符"></a>读取到指定的字符</h3><p><strong>同类方法列表</strong></p><table>    <tr>        <th>方法</th><th>无delim是否报错</th>    </tr>    <tr>        <td>ReadSlice(delim byte) (line []byte, err error)</td><td>报错(bufio: buffer full)</td>    </tr>    <tr>        <td>ReadBytes(delim byte) ([]byte, error)/td></td><td>不会</td>    </tr>    <tr>        <td>ReadString(delim byte) (string, error)</td><td>不会</td>    </tr></table><p><strong>每次读取到字符delim(包含)</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 基于字符串创建读取器</span></span><br><span class="line">reader := bufio.NewReaderSize(strings.NewReader(<span class="string">&quot;Go,PHP,Java,Python,C&quot;</span>), <span class="number">16</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line">s, err := reader.ReadString(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line"><span class="comment">// 读取完毕，则跳出</span></span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;err:%s&quot;</span>, err.Error())</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, s)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">Go,</span></span><br><span class="line"><span class="comment">PHP,</span></span><br><span class="line"><span class="comment">Java,</span></span><br><span class="line"><span class="comment">Python,</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>上述例子中C后面没有<code>,</code>,所以不会读出</p><p><strong>模拟每次读取一行</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 设置每行超过缓冲区大小</span></span><br><span class="line">repeat := strings.Repeat(<span class="string">&quot;Hello,Hello,Hello,Hello\n&quot;</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 基于字符串创建读取器</span></span><br><span class="line">reader := bufio.NewReaderSize(strings.NewReader(repeat), <span class="number">16</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line">s, err := reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment">// 读取完毕，则跳出</span></span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;err:%s&quot;</span>, err.Error())</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s&quot;</span>, s)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 输出</span></span><br><span class="line"><span class="comment">Hello,Hello,Hello,Hello</span></span><br><span class="line"><span class="comment">Hello,Hello,Hello,Hello</span></span><br><span class="line"><span class="comment">Hello,Hello,Hello,Hello</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>虽然每行超过缓冲区大小，但是依然可以整行读出</p><h3 id="每次读取前几个字节-Peek"><a href="#每次读取前几个字节-Peek" class="headerlink" title="每次读取前几个字节(Peek)"></a>每次读取前几个字节(Peek)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span></span> Peek(n <span class="type">int</span>) ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>每次读取输入流的前n个字节，<strong>且不会移动读取位置</strong>,所以当输入流不变时，每次读取都是一样的。<br>当内容小于n时，error会返回io.EOF<br>当n大于缓冲区大小时，error会返回ErrBufferFull</p><p><strong>内容小于n时</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 基于字符串创建读取器</span></span><br><span class="line">reader := bufio.NewReaderSize(strings.NewReader(<span class="string">&quot;hello&quot;</span>), <span class="number">16</span>)</span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">s, err := reader.Peek(<span class="number">16</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;结果: %s &quot;</span>, s)</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, <span class="string">&quot;已读完&quot;</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;err:%s\n&quot;</span>, err.Error())</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出-&gt; 结果: hello 已读完</span></span><br></pre></td></tr></table></figure><p><strong>当n大于缓冲区大小时</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 基于字符串创建读取器</span></span><br><span class="line">reader := bufio.NewReaderSize(strings.NewReader(<span class="string">&quot;hello&quot;</span>), <span class="number">16</span>)</span><br><span class="line"><span class="comment">// 读取</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line"><span class="comment">// 大于缓冲区大小</span></span><br><span class="line">s, err := reader.Peek(<span class="number">17</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;结果: %s &quot;</span>, s)</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s\n&quot;</span>, <span class="string">&quot;已读完&quot;</span>)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;err:%s\n&quot;</span>, err.Error())</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出-&gt; 结果: hello err:bufio: buffer full</span></span><br></pre></td></tr></table></figure><h2 id="写入-Write"><a href="#写入-Write" class="headerlink" title="写入(Write*)"></a>写入(Write*)</h2><h3 id="创建写入器"><a href="#创建写入器" class="headerlink" title="创建写入器"></a>创建写入器</h3><p><strong>创建默认缓冲大小(NewWriter)</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriter</span><span class="params">(w io.Writer)</span></span> *Writer</span><br></pre></td></tr></table></figure><p>根据w创建一个具有默认大小缓冲的*Writer。默认大小:4096字节</p><p><strong>创建指定缓冲大小(NewWriterSize)</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewWriterSize</span><span class="params">(w io.Writer, size <span class="type">int</span>)</span></span> *Writer</span><br></pre></td></tr></table></figure><h3 id="Write"><a href="#Write" class="headerlink" title="Write*"></a>Write*</h3><p><strong>方法列表</strong></p><table>    <tr>        <th>方法名</th><th>描述</th>    </tr>    <tr>        <td>Write(p []byte) (nn int, err error)</td><td>Write将p的内容写入缓冲。返回写入的字节数。如果返回值nn < len(p)，还会返回一个错误说明原因。</td>    </tr>    <tr>        <td>WriteString(s string) (int, error)</td><td>同上,只是入参变成字符串。</td>    </tr></table><p><strong>当写入内容大于缓冲区时</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">file, _ := os.OpenFile(<span class="string">&quot;./test.txt&quot;</span>, os.O_APPEND|os.O_WRONLY, os.ModePerm)</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line">reader := bufio.NewWriterSize(file, <span class="number">20</span>)</span><br><span class="line"><span class="comment">// 当写入的内容字节大于缓冲区大小时,会直接写入文件</span></span><br><span class="line">write, err := reader.Write([]<span class="type">byte</span>(<span class="string">&quot;hello,hello,hello 你好！\n&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;直接写入文件: %d\n&quot;</span>, write)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出——&gt; 直接写入文件: 28</span></span><br></pre></td></tr></table></figure><p><strong>当写入内容小于缓冲区时</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">file, _ := os.OpenFile(<span class="string">&quot;./test.txt&quot;</span>, os.O_APPEND|os.O_WRONLY, os.ModePerm)</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line">reader := bufio.NewWriterSize(file, <span class="number">20</span>)</span><br><span class="line"><span class="comment">// 当写入的内容字节小于缓冲区大小时,不会直接写入文件</span></span><br><span class="line">write, err := reader.Write([]<span class="type">byte</span>(<span class="string">&quot;\nhello,Go!&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 该函数会使缓冲区的内容，直接写入文件</span></span><br><span class="line">reader.Flush()</span><br><span class="line">fmt.Printf(<span class="string">&quot;Flush写入文件: %d\n&quot;</span>, write)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出-&gt; Flush写入文件: 10</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;bufio包实现了有缓冲的I/O。它包装一个io.Reader或io.Writer接口对象，使用这个包可以大幅提高文件读写的效率。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="GO" scheme="https://rma-shuyu.github.io/categories/GO/"/>
    
    
    <category term="go" scheme="https://rma-shuyu.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>ioutil包使用</title>
    <link href="https://rma-shuyu.github.io/2021/04/25/ioutil%E5%8C%85%E4%BD%BF%E7%94%A8/"/>
    <id>https://rma-shuyu.github.io/2021/04/25/ioutil%E5%8C%85%E4%BD%BF%E7%94%A8/</id>
    <published>2021-04-25T12:27:18.000Z</published>
    <updated>2023-01-27T12:06:26.907Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote><p>在Go语言中，io包主要声明的是对I/O操作的基本接口，而io/ioutil包则实现了对应的方法，方便我们直接使用。</p></blockquote><span id="more"></span><p><strong>方法列表</strong></p><table>    <tr>        <th>方法名</th><th>描述</th>    </tr>    <tr>        <td>NopCloser</td><td>对Reader进行封装，返回一个ReadCloser</td>    </tr>    <tr>        <td>ReadAll</td><td>对Reader进行读取，直到发生错误或者遇到EOF为止，然后返回被读取的数据</td>    </tr>    <tr>        <td>ReadFile</td><td>读取指定文件的内容，并返回</td>    </tr>    <tr>        <td>ReadDir</td><td>读取指定的目录， 并返回排序后的目录列表(根据名称排序)</td>    </tr>    <tr>        <td>TempDir</td><td>在指定目录新创建一个临时文件，以可读写的方式打开它，并返回 *os.File 指针</td>    </tr>    <tr>        <td>WriteFile</td><td>将给定的数据写入到指定文件里面</td>    </tr></table><p><strong>注意</strong><br><code>WriteFile</code>：如果文件不存在，则去创建它；<br>如果文件已经存在，则再写入之前会先清空文件中已有的内容。</p><h2 id="ReadAll"><a href="#ReadAll" class="headerlink" title="ReadAll"></a>ReadAll</h2><p><strong>方法签名</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadAll</span><span class="params">(r io.Reader)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p><code>ReadAll</code>从r读取数据直到EOF或error，返回读取内容([]byte)和错误(error)。读取成功时err返回nil。<br>因为本函数定义为读取r直到EOF，它不会将读取返回的EOF视为应报告的错误。</p><p><strong>使用</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// NewReader创建一个从s读取数据的Reader。本函数类似bytes.NewBufferString</span></span><br><span class="line">reader := strings.NewReader(<span class="string">&quot;Hello word !&quot;</span>)</span><br><span class="line">all, err := ioutil.ReadAll(reader)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s&quot;</span>,all)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出: Hello word !</span></span><br></pre></td></tr></table></figure><h2 id="ReadFile"><a href="#ReadFile" class="headerlink" title="ReadFile"></a>ReadFile</h2><p><strong>方法签名</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadFile</span><span class="params">(filename <span class="type">string</span>)</span></span> ([]<span class="type">byte</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p><code>ReadFile</code>从filename指定的文件中读取内容并返回。读取成功时err返回nil。<br>因为本函数定义为读取r直到EOF，它不会将读取返回的EOF视为应报告的错误。</p><p><strong>使用</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="comment">// 文件路径</span></span><br><span class="line">   fileName := <span class="string">&quot;./test.log&quot;</span></span><br><span class="line">   data, err := ioutil.ReadFile(fileName)</span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Printf(<span class="string">&quot;%s&quot;</span>,data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ReadDir"><a href="#ReadDir" class="headerlink" title="ReadDir"></a>ReadDir</h2><p><strong>方法签名</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ReadDir</span><span class="params">(dirname <span class="type">string</span>)</span></span> ([]os.FileInfo, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>返回dirname指定的目录的目录信息的有序列表。</p><p><strong>使用</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">dirName := <span class="string">&quot;./log&quot;</span></span><br><span class="line">dirList, err := ioutil.ReadDir(dirName)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _, info := <span class="keyword">range</span> dirList &#123;</span><br><span class="line">fmt.Println(info.Name())</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TempDir"><a href="#TempDir" class="headerlink" title="TempDir"></a>TempDir</h2><p><strong>方法签名</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TempDir</span><span class="params">(dir, pattern <span class="type">string</span>)</span></span> (name <span class="type">string</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>在dir目录里创建一个新的、使用pattern作为前缀的临时文件夹，并返回文件夹的路径。</p><p>如果dir是空字符串，TempDir使用默认用于临时文件的目录。<br>不同程序同时调用该函数会创建不同的临时目录，<br>创建的临时文件夹时在不使用时，需要删除。</p><p><strong>使用</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> pathList []<span class="type">string</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line"><span class="keyword">var</span> path <span class="type">string</span></span><br><span class="line"><span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line"><span class="keyword">switch</span> i &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="comment">// 指定目录和前缀</span></span><br><span class="line">path, err = ioutil.TempDir(<span class="string">&quot;./log&quot;</span>,<span class="string">&quot;tmp_&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="comment">// 只指定目录</span></span><br><span class="line">path, err = ioutil.TempDir(<span class="string">&quot;./log&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="comment">// 目录为空、前缀不为空</span></span><br><span class="line">path, err = ioutil.TempDir(<span class="string">&quot;&quot;</span>,<span class="string">&quot;tmp_&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="comment">// 目录和前缀都是空</span></span><br><span class="line">path, err = ioutil.TempDir(<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">pathList = <span class="built_in">append</span>(pathList, path)</span><br><span class="line">    <span class="comment">// 删除临时目录,测试时注释</span></span><br><span class="line"><span class="comment">// _ = os.RemoveAll(path)</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(pathList)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">[./log/tmp_1985114812 ./log/3136642706 /tmp/tmp_3038884210 /tmp/80588905]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="TempFile"><a href="#TempFile" class="headerlink" title="TempFile"></a>TempFile</h2><p><strong>方法签名</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TempFile</span><span class="params">(dir, pattern <span class="type">string</span>)</span></span> (f *os.File, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>在dir目录下创建一个新的、使用pattern为前缀的临时文件，以读写模式打开该文件并返回os.File指针。</p><p>如果dir是空字符串，TempFile使用默认用于临时文件的目录。<br>不同程序同时调用该函数会创建不同的临时文件。<br>创建的临时文件夹时在不使用时，需要删除。</p><p><strong>使用</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> fileList []<span class="type">string</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line"><span class="keyword">var</span> file *os.File</span><br><span class="line"><span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line"><span class="keyword">switch</span> i &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="comment">// 指定目录和前缀</span></span><br><span class="line">file, err = ioutil.TempFile(<span class="string">&quot;./log&quot;</span>, <span class="string">&quot;tmp_&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="comment">// 只指定目录</span></span><br><span class="line">file, err = ioutil.TempFile(<span class="string">&quot;./log&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="comment">// 目录为空、前缀不为空</span></span><br><span class="line">file, err = ioutil.TempFile(<span class="string">&quot;&quot;</span>, <span class="string">&quot;tmp_&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="comment">// 目录和前缀都是空</span></span><br><span class="line">file, err = ioutil.TempFile(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">fileList = <span class="built_in">append</span>(fileList, file.Name())</span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="comment">//_ = os.Remove(file.Name())</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(fileList)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">[./log/tmp_810405943 ./log/3229488309 /tmp/tmp_691615726 /tmp/1459961838]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="WriteFile"><a href="#WriteFile" class="headerlink" title="WriteFile"></a>WriteFile</h2><p><strong>方法签名</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WriteFile</span><span class="params">(filename <span class="type">string</span>, data []<span class="type">byte</span>, perm os.FileMode)</span></span> <span class="type">error</span></span><br></pre></td></tr></table></figure><p>函数向filename指定的文件中写入数据。</p><p>如果文件不存在,将按给出的权限创建文件，<br>如果文件存在,在写入数据之前清空文件。</p><p><strong>使用</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fileName := <span class="string">&quot;./test.txt&quot;</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">_ = ioutil.WriteFile(fileName, []<span class="type">byte</span>(<span class="string">&quot;Hello Word!&quot;</span>), os.ModePerm)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在Go语言中，io包主要声明的是对I/O操作的基本接口，而io/ioutil包则实现了对应的方法，方便我们直接使用。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="GO" scheme="https://rma-shuyu.github.io/categories/GO/"/>
    
    
    <category term="go" scheme="https://rma-shuyu.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>fmt包使用</title>
    <link href="https://rma-shuyu.github.io/2021/04/24/fmt%E5%8C%85%E4%BD%BF%E7%94%A8/"/>
    <id>https://rma-shuyu.github.io/2021/04/24/fmt%E5%8C%85%E4%BD%BF%E7%94%A8/</id>
    <published>2021-04-24T12:27:18.000Z</published>
    <updated>2023-01-27T12:06:26.876Z</updated>
    
    <content type="html"><![CDATA[<h2 id="输出到控制台"><a href="#输出到控制台" class="headerlink" title="输出到控制台"></a>输出到控制台</h2><h3 id="Printf"><a href="#Printf" class="headerlink" title="Printf"></a>Printf</h3><blockquote><p>Printf根据format参数生成格式化的字符串并写入标准输出。返回写入的字节数和遇到的任何错误。</p></blockquote><span id="more"></span><p><strong>format格式</strong></p><table>    <tr>        <th>动 词</th><th>功 能</th>    </tr>    <tr>        <td>%v</td><td>按值的本来值输出</td>    </tr>    <tr>        <td>%+v</td><td>在 %v 基础上，对结构体字段名和值进行展开</td>    </tr>    <tr>        <td>%#v</td><td>输出 Go 语言语法格式的值</td>    </tr>    <tr>        <td>%T</td><td>输出 Go 语言语法格式的类型和值</td>    </tr>    <tr>        <td>%%</td><td>输出 % 本体</td>    </tr>    <tr>        <td>%b</td><td>整型以二进制方式显示</td>    </tr>    <tr>        <td>%o</td><td>整型以八进制方式显示</td>    </tr>    <tr>        <td>%d</td><td>整型以十进制方式显示</td>    </tr>    <tr>        <td>%x</td><td>整型以十六进制方式显示</td>    </tr>    <tr>        <td>%X</td><td>整型以十六进制、字母大写方式显示</td>    </tr>    <tr>        <td>%U</td><td>Unicode 字符</td>    </tr>    <tr>        <td>%f</td><td>浮点数</td>    </tr>    <tr>        <td>%p</td><td>指针，十六进制方式显示</td>    </tr>    <tr>        <td>%c</td><td>数值对应的 Unicode 编码字符</td>    </tr>    <tr>        <td>%s</td><td>直接输出字符串或者[]byte</td>    </tr>    <tr>        <td>%t</td><td>输出值的 true 或 false</td>    </tr></table><p><strong>打印字符串</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">&quot;hello word&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%%s-&gt; %s \n&quot;</span>,str)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%%v-&gt; %v \n&quot;</span>,str)</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">%s-&gt; hello word </span></span><br><span class="line"><span class="comment">%v-&gt; hello word </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>打印布尔类型</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;%%t-&gt; %t \n&quot;</span>, b)</span><br></pre></td></tr></table></figure><p><strong>打印浮点型</strong></p><table>    <tr>        <th>格式</th><th>描述</th>    </tr>    <tr>        <td>%f</td><td>默认宽度，默认精度</td>    </tr>    <tr>        <td>%9f</td><td>宽度9，默认精度</td>    </tr>    <tr>        <td>%.2f</td><td>默认宽度，精度2</td>    </tr>    <tr>        <td>%9.2f</td><td>宽度9，精度2</td>    </tr>    <tr>        <td>%9.f</td><td>宽度9，精度0</td>    </tr></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">f := <span class="number">1.234567890</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;默认宽度，默认精度:%f \n&quot;</span>, f)</span><br><span class="line">fmt.Printf(<span class="string">&quot;宽度9，默认精度:%9f \n&quot;</span>, f)</span><br><span class="line">fmt.Printf(<span class="string">&quot;默认宽度，精度2:%.2f \n&quot;</span>, f)</span><br><span class="line">fmt.Printf(<span class="string">&quot;宽度9，精度2:%9.2f \n&quot;</span>, f)</span><br><span class="line">fmt.Printf(<span class="string">&quot;宽度9，精度0 :%9.f \n&quot;</span>, f)</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">默认宽度，默认精度:1.234568 </span></span><br><span class="line"><span class="comment">宽度9，默认精度: 1.234568 </span></span><br><span class="line"><span class="comment">默认宽度，精度2:1.23 </span></span><br><span class="line"><span class="comment">宽度9，精度2:     1.23 </span></span><br><span class="line"><span class="comment">宽度9，精度0 :        1 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>打印整数</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个整数变量</span></span><br><span class="line">a := <span class="number">54321</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;十进制:%d\n&quot;</span>,a)</span><br><span class="line">fmt.Printf(<span class="string">&quot;二进制:%b\n&quot;</span>,a)</span><br><span class="line">fmt.Printf(<span class="string">&quot;八进制:%o\n&quot;</span>,a)</span><br><span class="line">fmt.Printf(<span class="string">&quot;十六进制:%x\n&quot;</span>,a)</span><br><span class="line">fmt.Printf(<span class="string">&quot;十六进制,字母大写:%X\n&quot;</span>,a)</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">十进制:54321</span></span><br><span class="line"><span class="comment">二进制:1101010000110001</span></span><br><span class="line"><span class="comment">八进制:152061</span></span><br><span class="line"><span class="comment">十六进制:d431</span></span><br><span class="line"><span class="comment">十六进制,字母大写:D431</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>打印指针</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">&quot;hello&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;打印指针:%p\n&quot;</span>, &amp;str)</span><br><span class="line"><span class="comment">//输出: 打印指针:0xc000098d50</span></span><br></pre></td></tr></table></figure><p><strong>打印变量类型</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组</span></span><br><span class="line">arr := []<span class="type">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;arr类型: %T\n&quot;</span>, arr)</span><br><span class="line"><span class="comment">// 映射</span></span><br><span class="line">map1 := <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>&#123;</span><br><span class="line"><span class="string">&quot;张三&quot;</span>: <span class="number">20</span>,</span><br><span class="line"><span class="string">&quot;李四&quot;</span>: <span class="number">23</span>,</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;map1类型: %T\n&quot;</span>, map1)</span><br><span class="line"><span class="comment">// 匿名结构体</span></span><br><span class="line">fruit := <span class="keyword">struct</span> &#123;</span><br><span class="line">name  <span class="type">string</span></span><br><span class="line">price <span class="type">float64</span></span><br><span class="line">&#125;&#123;<span class="string">&quot;香蕉&quot;</span>, <span class="number">4.99</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;fruit类型: %T\n&quot;</span>, fruit)</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">arr类型: []int</span></span><br><span class="line"><span class="comment">map1类型: map[string]int</span></span><br><span class="line"><span class="comment">fruit类型: struct &#123; name string; price float64 &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>打印结构体</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个匿名结构体</span></span><br><span class="line">people := <span class="keyword">struct</span> &#123;</span><br><span class="line">name, home, school <span class="type">string</span></span><br><span class="line">&#125;&#123;<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;北京&quot;</span>, <span class="string">&quot;北京大学&quot;</span>&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, people)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%+v\n&quot;</span>, people)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%#v\n&quot;</span>, people)</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">&#123;张三 北京 北京大学&#125;</span></span><br><span class="line"><span class="comment">&#123;name:张三 home:北京 school:北京大学&#125;</span></span><br><span class="line"><span class="comment">struct &#123; name string; home string; school string &#125;&#123;name:&quot;张三&quot;, home:&quot;北京&quot;, school:&quot;北京大学&quot;&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>打印Unicode</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fmt.Printf(<span class="string">&quot;%U\n&quot;</span>, <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%c\n&quot;</span>, <span class="number">65</span>)</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">U+0041</span></span><br><span class="line"><span class="comment">A</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="Print"><a href="#Print" class="headerlink" title="Print"></a>Print</h3><p><code>Print</code>: 采用默认格式将其参数格式化并写入标准输出。如果两个相邻的参数都不是字符串，会在它们的输出之间添加空格。</p><p><strong>打印相邻的字符串</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fmt.Print(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;word&quot;</span>,<span class="string">&quot;!&quot;</span>)</span><br><span class="line">fmt.Print(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;word&quot;</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&quot;!&quot;</span>)</span><br><span class="line"><span class="comment">// 输出: helloword2 3!helloword!</span></span><br></pre></td></tr></table></figure><p>如果两个相邻的参数都不是字符串，会在它们的输出之间添加空格,注意的是,<strong>不会自动换行</strong>。</p><h3 id="Println"><a href="#Println" class="headerlink" title="Println"></a>Println</h3><p><code>Println</code>: 采用默认格式将其参数格式化并写入标准输出。总是会在相邻参数的输出之间添加空格并在输出结束后添加换行符。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;word&quot;</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&quot;!&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;word&quot;</span>,<span class="string">&quot;!&quot;</span>)</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">hello word 2 3 !</span></span><br><span class="line"><span class="comment">hello word !</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="输出到文件"><a href="#输出到文件" class="headerlink" title="输出到文件"></a>输出到文件</h2><table>    <tr>        <th>方法名</th><th>描述</th>    </tr>    <tr>        <td>Fprintln</td><td>功能和Println一样,但可以输出到文件</td>    </tr>    <tr>        <td>Fprintf</td><td>功能和Printf一样,但可以输出到文件</td>    </tr>    <tr>        <td>Fprint</td><td>功能和Print一样,但可以输出到文件</td>    </tr></table><p><strong>输出到控制台</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_, _ = fmt.Fprintln(os.Stdout, <span class="string">&quot;hello&quot;</span>,<span class="string">&quot;go&quot;</span>)</span><br><span class="line">_, _ = fmt.Fprintln(os.Stdout,  <span class="string">&quot;hello&quot;</span>,<span class="string">&quot;php&quot;</span>)</span><br><span class="line"><span class="comment">/** 输出</span></span><br><span class="line"><span class="comment">hello go</span></span><br><span class="line"><span class="comment">hello php</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>输出到文件</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开文件</span></span><br><span class="line">file, err := os.OpenFile(<span class="string">&quot;./test.log&quot;</span>, os.O_APPEND|os.O_CREATE|os.O_WRONLY, os.ModePerm)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写入文件</span></span><br><span class="line">_, err = fmt.Fprintln(file, <span class="string">&quot;hello&quot;</span>, <span class="string">&quot;word&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="生成字符串"><a href="#生成字符串" class="headerlink" title="生成字符串"></a>生成字符串</h2><table>    <tr>        <th>方法名</th><th>描述</th>    </tr>    <tr>        <td>Sprintf</td><td>同Printf一样,但是结果不输出到控制台,而是直接返回</td>    </tr>    <tr>        <td>Sprint</td><td>同Print一样,但是结果不输出到控制台,而是直接返回</td>    </tr>    <tr>        <td>Sprintln</td><td>同Println一样,但是结果不输出到控制台,而是直接返回</td>    </tr></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sprintf := fmt.Sprintf(<span class="string">&quot;水果:%s 价格:%.3f&quot;</span>, <span class="string">&quot;香蕉&quot;</span>, <span class="number">1.99</span>)</span><br><span class="line">sprint := fmt.Sprint(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;LOVE&quot;</span>, <span class="string">&quot;YOU&quot;</span>)</span><br><span class="line">sprintln := fmt.Sprintln(<span class="string">&quot;I&quot;</span>, <span class="string">&quot;LOVE&quot;</span>, <span class="string">&quot;YOU&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;Sprintf:%s\n&quot;</span>,sprintf)</span><br><span class="line">fmt.Printf(<span class="string">&quot;sprint:%s\n&quot;</span>,sprint)</span><br><span class="line">fmt.Printf(<span class="string">&quot;sprintln:%s\n&quot;</span>,sprintln)</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">Sprintf:水果:香蕉 价格:1.990</span></span><br><span class="line"><span class="comment">sprint:ILOVEYOU</span></span><br><span class="line"><span class="comment">sprintln:I LOVE YOU</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="生成错误类型"><a href="#生成错误类型" class="headerlink" title="生成错误类型"></a>生成错误类型</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回错误类型</span></span><br><span class="line">err := fmt.Errorf(<span class="string">&quot;错误信息:%s&quot;</span>, <span class="string">&quot;参数不全&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;类型:%T   内容: %v&quot;</span>,err,err)</span><br><span class="line"><span class="comment">//输出: 类型:*errors.errorString   内容: 错误信息:参数不全</span></span><br></pre></td></tr></table></figure><h2 id="接收控制台输入"><a href="#接收控制台输入" class="headerlink" title="接收控制台输入"></a>接收控制台输入</h2><p><code>Scan</code><br>接收终端输入，按照参数输入顺序赋值，参数间以空格(或换行)间隔，如果输入的参数少于接收的参数则会报错。类型不一致时也会报错。当参数输入数量不够时，换行时会继续等待输入。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">name   <span class="type">string</span></span><br><span class="line">age    <span class="type">int64</span></span><br><span class="line">isBody <span class="type">bool</span></span><br><span class="line">)</span><br><span class="line">_, err := fmt.Scan(&amp;name, &amp;age, &amp;isBody)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;name:%s age: %d isBody:%t&quot;</span>, name, age, isBody)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//启动后，依次输入：张三 22 true</span></span><br><span class="line"><span class="comment">// 输出: name:张三 age: 22 isBody:true</span></span><br></pre></td></tr></table></figure><p><code>Scanf</code><br>接收终端输入,按照format参数指定的格式接收参数.当参数输入数量不够时，换行时会直接输出.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">name   <span class="type">string</span></span><br><span class="line">age    <span class="type">int</span></span><br><span class="line">isBody <span class="type">bool</span></span><br><span class="line">)</span><br><span class="line">_, err := fmt.Scanf(<span class="string">&quot;a:%s b:%d c:%t&quot;</span>, &amp;name, &amp;age, &amp;isBody)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;name:%s age:%d isBody:%t&quot;</span>, name, age, isBody)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当输入-&gt; 张三 23 true 报错: input does not match format </span></span><br><span class="line"><span class="comment">当输入-&gt; a:张三 b:23 c:true 输出: name:张三 age:23 isBody:true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>Scanln</code><br>Scanln类似Scan，它在遇到换行时才停止扫描。最后一个数据后面必须有换行或者到达结束位置。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">name   <span class="type">string</span></span><br><span class="line">age    <span class="type">int64</span></span><br><span class="line">isBody <span class="type">bool</span></span><br><span class="line">)</span><br><span class="line">_, err := fmt.Scanln(&amp;name, &amp;age, &amp;isBody)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;name:%s age: %d isBody:%t&quot;</span>, name, age, isBody)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">当输入-&gt; 张三 23  报错: unexpected newline</span></span><br><span class="line"><span class="comment">当输入-&gt; 李四 74 true 输出: name:李四 age: 74 isBody:true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;输出到控制台&quot;&gt;&lt;a href=&quot;#输出到控制台&quot; class=&quot;headerlink&quot; title=&quot;输出到控制台&quot;&gt;&lt;/a&gt;输出到控制台&lt;/h2&gt;&lt;h3 id=&quot;Printf&quot;&gt;&lt;a href=&quot;#Printf&quot; class=&quot;headerlink&quot; title=&quot;Printf&quot;&gt;&lt;/a&gt;Printf&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Printf根据format参数生成格式化的字符串并写入标准输出。返回写入的字节数和遇到的任何错误。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="GO" scheme="https://rma-shuyu.github.io/categories/GO/"/>
    
    
    <category term="go" scheme="https://rma-shuyu.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>time包使用</title>
    <link href="https://rma-shuyu.github.io/2021/04/23/time%E5%8C%85%E4%BD%BF%E7%94%A8/"/>
    <id>https://rma-shuyu.github.io/2021/04/23/time%E5%8C%85%E4%BD%BF%E7%94%A8/</id>
    <published>2021-04-23T12:27:18.000Z</published>
    <updated>2023-01-27T12:06:26.960Z</updated>
    
    <content type="html"><![CDATA[<h2 id="获取时间"><a href="#获取时间" class="headerlink" title="获取时间"></a>获取时间</h2><h3 id="当前时间"><a href="#当前时间" class="headerlink" title="当前时间"></a>当前时间</h3><p>语法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Now() Time </span><br></pre></td></tr></table></figure><span id="more"></span><p>使用示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">unix := time.Now().Unix()</span><br><span class="line">fmt.Printf(<span class="string">&quot;当前时间戳(单位秒): %v \n&quot;</span>,unix)</span><br><span class="line">nano := time.Now().UnixNano()</span><br><span class="line">fmt.Printf(<span class="string">&quot;当前时间戳(单位纳秒): %v\n&quot;</span>,nano)</span><br><span class="line">format := time.Now().Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;当前时间(Y-m-d H:i:s): %v\n&quot;</span>,format)</span><br><span class="line">format2 := time.Now().Format(<span class="string">&quot;20060102150405&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;当前时间(YmdHis): %v\n&quot;</span>,format2)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">当前时间戳(单位秒): 1616251448 </span></span><br><span class="line"><span class="comment">当前时间戳(单位纳秒): 1616251448041163000</span></span><br><span class="line"><span class="comment">当前时间(Y-m-d H:i:s): 2021-03-20 22:44:08</span></span><br><span class="line"><span class="comment">当前时间(YmdHis): 20210320224408</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="当前年、月、日、时、分、秒、星期几"><a href="#当前年、月、日、时、分、秒、星期几" class="headerlink" title="当前年、月、日、时、分、秒、星期几"></a>当前年、月、日、时、分、秒、星期几</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">format := time.Now().Format(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;当前时间(Y-m-d H:i:s): %v\n&quot;</span>,format)</span><br><span class="line">fmt.Printf(<span class="string">&quot;当前年: %v\n&quot;</span>, time.Now().Year())</span><br><span class="line">fmt.Printf(<span class="string">&quot;当前月: %v\n&quot;</span>, time.Now().Month())</span><br><span class="line">fmt.Printf(<span class="string">&quot;当前日: %v\n&quot;</span>, time.Now().Day())</span><br><span class="line">fmt.Printf(<span class="string">&quot;当前小时: %v\n&quot;</span>, time.Now().Hour())</span><br><span class="line">fmt.Printf(<span class="string">&quot;当前分钟: %v\n&quot;</span>, time.Now().Minute())</span><br><span class="line">fmt.Printf(<span class="string">&quot;当前秒: %v\n&quot;</span>, time.Now().Second())</span><br><span class="line">fmt.Printf(<span class="string">&quot;当前星期几: %v\n&quot;</span>, time.Now().Weekday())</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">当前时间(Y-m-d H:i:s): 2021-03-21 17:32:24</span></span><br><span class="line"><span class="comment">当前年: 2021</span></span><br><span class="line"><span class="comment">当前月: March</span></span><br><span class="line"><span class="comment">当前日: 21</span></span><br><span class="line"><span class="comment">当前小时: 17</span></span><br><span class="line"><span class="comment">当前分钟: 32</span></span><br><span class="line"><span class="comment">当前秒: 24</span></span><br><span class="line"><span class="comment">当前星期几: Sunday</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="获取时分秒"><a href="#获取时分秒" class="headerlink" title="获取时分秒"></a>获取时分秒</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">hour, min, sec := now.Clock()</span><br><span class="line">fmt.Printf(<span class="string">&quot;时间:%v   hour: %v min:%v sec:%v \n&quot;</span>,now,hour,min,sec)</span><br><span class="line"><span class="comment">//时间:2021-03-22 23:18:43.245006 +0800 CST m=+0.000108086   hour: 23 min:18 sec:43</span></span><br></pre></td></tr></table></figure><h3 id="创建指定时间"><a href="#创建指定时间" class="headerlink" title="创建指定时间"></a>创建指定时间</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">date := time.Date(<span class="number">2020</span>,<span class="number">8</span>,<span class="number">23</span>,<span class="number">13</span>,<span class="number">53</span>,<span class="number">32</span>,<span class="number">0</span>,time.Local)</span><br><span class="line">fmt.Printf(<span class="string">&quot;类型: %T , %v &quot;</span>,date,date)</span><br><span class="line"><span class="comment">// 输出:类型: time.Time , 2020-08-23 13:53:32 +0800 CST </span></span><br></pre></td></tr></table></figure><h3 id="获取所属第几周"><a href="#获取所属第几周" class="headerlink" title="获取所属第几周"></a>获取所属第几周</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取当前时间是，今年的第几周</span></span><br><span class="line">week, w := time.Now().ISOWeek()</span><br><span class="line">fmt.Printf(<span class="string">&quot;year: %v w:%v \n&quot;</span>,week,w)</span><br><span class="line"><span class="comment">// year: 2021 w:12 </span></span><br></pre></td></tr></table></figure><h3 id="获取x年的第几天"><a href="#获取x年的第几天" class="headerlink" title="获取x年的第几天"></a>获取x年的第几天</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num := time.Now().YearDay()</span><br><span class="line">fmt.Printf(<span class="string">&quot;今天是今年的第 %v 天 \n&quot;</span>,num)</span><br><span class="line"><span class="comment">// 今天是今年的第 81 天 </span></span><br></pre></td></tr></table></figure><h2 id="字符串转时间"><a href="#字符串转时间" class="headerlink" title="字符串转时间"></a>字符串转时间</h2><h3 id="字符串转时间类型"><a href="#字符串转时间类型" class="headerlink" title="字符串转时间类型"></a>字符串转时间类型</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">str := <span class="string">&quot;1616319808&quot;</span></span><br><span class="line">unix, _ := strconv.ParseInt(str,<span class="number">10</span>,<span class="number">64</span>)</span><br><span class="line">format := time.Unix(unix, <span class="number">0</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;字符串时间戳-&gt; 类型:%T 值:%v \n&quot;</span>,format,format)</span><br><span class="line"><span class="comment">// 字符串时间,</span></span><br><span class="line">strDate := <span class="string">&quot;2019-04-10 12:54:03&quot;</span></span><br><span class="line"><span class="comment">// 注意layout格式需要和字符串时间格式一致</span></span><br><span class="line">location, _ := time.Parse(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>, strDate)</span><br><span class="line">fmt.Printf(<span class="string">&quot;字符串时间-&gt; 类型:%T 值:%v \n&quot;</span>,location,location)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">字符串时间戳-&gt; 类型:time.Time 值:2021-03-21 17:43:28 +0800 CST </span></span><br><span class="line"><span class="comment">字符串时间-&gt; 类型:time.Time 值:2019-04-10 12:54:03 +0000 UTC </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="格式化时间"><a href="#格式化时间" class="headerlink" title="格式化时间"></a>格式化时间</h3><p>Format根据layout指定的格式返回t代表的时间点的格式化文本表示；Format中内置了几个固定的layout常量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">ANSIC       = <span class="string">&quot;Mon Jan _2 15:04:05 2006&quot;</span></span><br><span class="line">UnixDate    = <span class="string">&quot;Mon Jan _2 15:04:05 MST 2006&quot;</span></span><br><span class="line">RubyDate    = <span class="string">&quot;Mon Jan 02 15:04:05 -0700 2006&quot;</span></span><br><span class="line">RFC822      = <span class="string">&quot;02 Jan 06 15:04 MST&quot;</span></span><br><span class="line">RFC822Z     = <span class="string">&quot;02 Jan 06 15:04 -0700&quot;</span> <span class="comment">// RFC822 with numeric zone</span></span><br><span class="line">RFC850      = <span class="string">&quot;Monday, 02-Jan-06 15:04:05 MST&quot;</span></span><br><span class="line">RFC1123     = <span class="string">&quot;Mon, 02 Jan 2006 15:04:05 MST&quot;</span></span><br><span class="line">RFC1123Z    = <span class="string">&quot;Mon, 02 Jan 2006 15:04:05 -0700&quot;</span> <span class="comment">// RFC1123 with numeric zone</span></span><br><span class="line">RFC3339     = <span class="string">&quot;2006-01-02T15:04:05Z07:00&quot;</span></span><br><span class="line">RFC3339Nano = <span class="string">&quot;2006-01-02T15:04:05.999999999Z07:00&quot;</span></span><br><span class="line">Kitchen     = <span class="string">&quot;3:04PM&quot;</span></span><br><span class="line"><span class="comment">// Handy time stamps.</span></span><br><span class="line">Stamp      = <span class="string">&quot;Jan _2 15:04:05&quot;</span></span><br><span class="line">StampMilli = <span class="string">&quot;Jan _2 15:04:05.000&quot;</span></span><br><span class="line">StampMicro = <span class="string">&quot;Jan _2 15:04:05.000000&quot;</span></span><br><span class="line">StampNano  = <span class="string">&quot;Jan _2 15:04:05.000000000&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将字符时间: 2020-09-12 14:34:10 转成 20200912143410</span></span><br><span class="line">strDate := <span class="string">&quot;2020-09-12 14:34:10&quot;</span></span><br><span class="line"><span class="comment">// 1.先转成时间类型</span></span><br><span class="line">location, _ := time.ParseInLocation(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>, strDate, time.Local)</span><br><span class="line"><span class="comment">// 2.再格式化</span></span><br><span class="line">format := location.Format(<span class="string">&quot;20060102150405&quot;</span>)</span><br><span class="line">fmt.Println(format)</span><br><span class="line"><span class="comment">// 输出:20200912143410</span></span><br></pre></td></tr></table></figure><h2 id="时间比较"><a href="#时间比较" class="headerlink" title="时间比较"></a>时间比较</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">strDate := <span class="string">&quot;2020-09-12 12:00:00&quot;</span></span><br><span class="line">strDate2 := <span class="string">&quot;2020-09-12 12:00:00&quot;</span></span><br><span class="line"><span class="comment">// 1.先转成时间类型</span></span><br><span class="line">time1, _ := time.ParseInLocation(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>, strDate, time.Local)</span><br><span class="line">time2, _ := time.ParseInLocation(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>, strDate2, time.Local)</span><br><span class="line"><span class="comment">// 2.比较 strDate2 &gt; strDate ?</span></span><br><span class="line">before := time1.Before(time2)</span><br><span class="line">fmt.Printf(<span class="string">&quot;strDate2 &gt; strDate ? %t \n&quot;</span>,before)</span><br><span class="line"><span class="comment">// 3.比较 strDate2 = strDate ?</span></span><br><span class="line">equal := time1.Equal(time2)</span><br><span class="line">fmt.Printf(<span class="string">&quot;strDate2 = strDate ? %t \n&quot;</span>,equal)</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">strDate2 &gt; strDate ? false </span></span><br><span class="line"><span class="comment">strDate2 = strDate ? true </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="时间计算"><a href="#时间计算" class="headerlink" title="时间计算"></a>时间计算</h2><p>时间相加</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">now := time.Now()</span><br><span class="line">fmt.Printf(<span class="string">&quot;现在的时间: %v \n&quot;</span>,now)</span><br><span class="line"><span class="comment">// 十分钟前</span></span><br><span class="line">duration, _ := time.ParseDuration(<span class="string">&quot;-10m&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;十分钟前: %v \n&quot;</span>, now.Add(duration))</span><br><span class="line"><span class="comment">// 一小时前</span></span><br><span class="line">duration2, _ := time.ParseDuration(<span class="string">&quot;-1h&quot;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;一小时前: %v \n&quot;</span>, now.Add(duration2))</span><br><span class="line"><span class="comment">// 一天后</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;一天后: %v \n&quot;</span>, now.AddDate(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line">fmt.Printf(<span class="string">&quot;一月后: %v \n&quot;</span>, now.AddDate(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>))</span><br><span class="line">fmt.Printf(<span class="string">&quot;一年后: %v \n&quot;</span>, now.AddDate(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">现在的时间: 2021-03-22 22:54:16.008615 +0800 CST m=+0.000092572 </span></span><br><span class="line"><span class="comment">十分钟前: 2021-03-22 22:44:16.008615 +0800 CST m=-599.999907428 </span></span><br><span class="line"><span class="comment">一小时前: 2021-03-22 21:54:16.008615 +0800 CST m=-3599.999907428 </span></span><br><span class="line"><span class="comment">一天后: 2021-03-23 22:54:16.008615 +0800 CST </span></span><br><span class="line"><span class="comment">一月后: 2021-04-22 22:54:16.008615 +0800 CST </span></span><br><span class="line"><span class="comment">一年后: 2022-03-22 22:54:16.008615 +0800 CST </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>时间相减</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">day1, _ := time.ParseInLocation(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>, <span class="string">&quot;2020-11-02 12:00:00&quot;</span>, time.Local)</span><br><span class="line">day2, _ := time.ParseInLocation(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>, <span class="string">&quot;2020-11-02 15:00:00&quot;</span>, time.Local)</span><br><span class="line">fmt.Printf(<span class="string">&quot;相差几秒: %v \n&quot;</span>,day2.Sub(day1).Seconds())</span><br><span class="line">fmt.Printf(<span class="string">&quot;相差多少分钟: %v \n&quot;</span>,day2.Sub(day1).Minutes())</span><br><span class="line">fmt.Printf(<span class="string">&quot;相差多少小时: %v \n&quot;</span>,day2.Sub(day1).Hours())</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">相差几秒: 10800 </span></span><br><span class="line"><span class="comment">相差多少分钟: 180 </span></span><br><span class="line"><span class="comment">相差多少小时: 3 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p><code>NewTicker</code>返回一个新的Ticker，该Ticker包含一个通道字段，并会每隔时间段d就向该通道发送当时的时间。<br>它会调整时间间隔或者丢弃tick信息以适应反应慢的接收者。如果d&lt;=0会panic。关闭该Ticker可以释放相关资源。</p><p>使用示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建定时器，间隔设置每秒</span></span><br><span class="line">ticker := time.NewTicker(time.Second)</span><br><span class="line"><span class="comment">// 启动一个协程，打印定时器里面的时间</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ticker *time.Ticker)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">fmt.Println(&lt;-ticker.C)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭定时器</span></span><br><span class="line">ticker.Stop()</span><br><span class="line">&#125;(ticker)</span><br><span class="line"><span class="comment">// 手动阻塞</span></span><br><span class="line">time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">2021-03-30 11:33:23.704677 +0800 CST m=+1.003656575</span></span><br><span class="line"><span class="comment">2021-03-30 11:33:24.704695 +0800 CST m=+2.003675713</span></span><br><span class="line"><span class="comment">2021-03-30 11:33:25.704271 +0800 CST m=+3.003275554</span></span><br><span class="line"><span class="comment">end</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>Tick</code>是NewTicker的封装，只提供对Ticker通道的访问。如果不需要关闭Ticker，本函数就很方便。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建定时器，间隔设置每秒</span></span><br><span class="line">chTime := time.Tick(time.Second)</span><br><span class="line"><span class="comment">// 启动一个协程，打印定时器里面的时间</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ch &lt;- <span class="keyword">chan</span> time.Time)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br><span class="line">&#125;(chTime)</span><br><span class="line"><span class="comment">// 手动阻塞</span></span><br><span class="line">time.Sleep(<span class="number">4</span> * time.Second)</span><br><span class="line">fmt.Println(<span class="string">&quot;end&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h2><p><code>NewTimer</code>创建一个Timer，它会在指定时间后，向其自身的C字段发送当时的时间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;开始时间: %v \n&quot;</span>,time.Now())</span><br><span class="line">timer := time.NewTimer(time.Second * <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 此处会阻塞，直到timer.C中有数据写入</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;timer通道里的时间: %v \n&quot;</span>, &lt;- timer.C)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">开始时间: 2021-03-30 14:27:04.966887 +0800 CST m=+0.001502710 </span></span><br><span class="line"><span class="comment">timer通道里的时间: 2021-03-30 14:27:07.970134 +0800 CST m=+3.004701898 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>After()</code>函数相当于NewTimer(d).C,如下源码:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">After</span><span class="params">(d Duration)</span></span> &lt;-<span class="keyword">chan</span> Time &#123;</span><br><span class="line"><span class="keyword">return</span> NewTimer(d).C</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 创建一个计时器,返回的是chan</span></span><br><span class="line">ch := time.After(<span class="number">5</span> * time.Second)</span><br><span class="line">fmt.Printf(<span class="string">&quot;开始时间 %v \n&quot;</span>,time.Now())</span><br><span class="line"><span class="comment">// 此处会阻塞5秒</span></span><br><span class="line">out := &lt;- ch</span><br><span class="line">fmt.Printf(<span class="string">&quot;变量out-&gt;  类型: %T 值:%v  \n&quot;</span>,out,out)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 输出</span></span><br><span class="line"><span class="comment">  开始时间 2020-12-10 11:01:07.272154 +0800 CST m=+0.000153152 </span></span><br><span class="line"><span class="comment">  变量out-&gt;  类型: time.Time 值:2020-12-10 11:01:12.273034 +0800 CST m=+5.000956630  </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;获取时间&quot;&gt;&lt;a href=&quot;#获取时间&quot; class=&quot;headerlink&quot; title=&quot;获取时间&quot;&gt;&lt;/a&gt;获取时间&lt;/h2&gt;&lt;h3 id=&quot;当前时间&quot;&gt;&lt;a href=&quot;#当前时间&quot; class=&quot;headerlink&quot; title=&quot;当前时间&quot;&gt;&lt;/a&gt;当前时间&lt;/h3&gt;&lt;p&gt;语法&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Now() Time &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="GO" scheme="https://rma-shuyu.github.io/categories/GO/"/>
    
    
    <category term="go" scheme="https://rma-shuyu.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>strconv包使用</title>
    <link href="https://rma-shuyu.github.io/2021/04/22/strconv%E5%8C%85%E4%BD%BF%E7%94%A8/"/>
    <id>https://rma-shuyu.github.io/2021/04/22/strconv%E5%8C%85%E4%BD%BF%E7%94%A8/</id>
    <published>2021-04-22T12:27:18.000Z</published>
    <updated>2023-01-27T12:06:26.957Z</updated>
    
    <content type="html"><![CDATA[<h2 id="转换成数字类型（Parse类函数）"><a href="#转换成数字类型（Parse类函数）" class="headerlink" title="转换成数字类型（Parse类函数）"></a>转换成数字类型（Parse类函数）</h2><h3 id="转换成整型-Atoi"><a href="#转换成整型-Atoi" class="headerlink" title="转换成整型(Atoi)"></a>转换成整型(Atoi)</h3><p>语法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Atoi</span><span class="params">(s <span class="type">string</span>)</span></span> (<span class="type">int</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><span id="more"></span><p>示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 将字符串转成整型</span></span><br><span class="line">s := <span class="string">&quot;666&quot;</span></span><br><span class="line">sInt, err := strconv.Atoi(s)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;将字符串:%s 转成整型:%d 类型: %T \n&quot;</span>, s, sInt, sInt)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将字符串:666 转成整型:666 类型: int</span></span><br></pre></td></tr></table></figure><h3 id="解析成整型-ParseInt"><a href="#解析成整型-ParseInt" class="headerlink" title="解析成整型(ParseInt)"></a>解析成整型(ParseInt)</h3><p>语法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseInt</span><span class="params">(s <span class="type">string</span>, base <span class="type">int</span>, bitSize <span class="type">int</span>)</span></span> (i <span class="type">int64</span>, err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p><code>base</code>:表示进制(2到36)。如果base=0,则根据字符串前缀判断,0x:表示十六进制、0:表示八进制、其他代表十进制。<br><code>bitSize</code>: 指定结果必须是不会溢出的整数类型，其值0、8、16、32、64 分别代表int、int8、int16、int32、int64</p><p>使用示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 将字符串转成int</span></span><br><span class="line">s := <span class="string">&quot;666&quot;</span></span><br><span class="line">i,err := strconv.ParseInt(s,<span class="number">10</span>,<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;类型转换失败&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;字符串%s转成int,%d 类型:%T \n&quot;</span>, s,i,i)</span><br><span class="line">  <span class="comment">// 这里会报错: 将字符串转成int8 int8的范围(-128~127)</span></span><br><span class="line">ii,err := strconv.ParseInt(s,<span class="number">10</span>,<span class="number">8</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;类型转换int8失败,值溢出&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;字符串%s转成int,%d 类型:%T &quot;</span>, s,ii,ii)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">字符串666转成int,666 类型:int64 </span></span><br><span class="line"><span class="comment">panic: 类型转换int8失败,值溢出</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">goroutine 1 [running]:</span></span><br><span class="line"><span class="comment">main.main()</span></span><br><span class="line"><span class="comment">        /Users/hui/Project/Go/src/go-basic/main.go:20 +0x2dd</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><code>ParseUint</code>与<code>ParseInt</code>类似，但是只用于无符号数字</p><h3 id="解析成浮点型-ParseFloat"><a href="#解析成浮点型-ParseFloat" class="headerlink" title="解析成浮点型(ParseFloat)"></a>解析成浮点型(ParseFloat)</h3><p>语法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseFloat</span><span class="params">(s <span class="type">string</span>, bitSize <span class="type">int</span>)</span></span> (<span class="type">float64</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>将一个字符串s解析成浮点数返回。如果字符串s符合语法规则，会返回一个最为接近s值的浮点数。精度由bitSize指定，其值32表示float32、64表示float32。</p><p>使用示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 将字符串转成int</span></span><br><span class="line">s := <span class="string">&quot;666&quot;</span></span><br><span class="line">i,err := strconv.ParseFloat(s,<span class="number">32</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;类型转换失败&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;字符串%s转成float,%f 类型:%T \n&quot;</span>, s,i,i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出:字符串666转成float,666.000000 类型:float64 </span></span><br></pre></td></tr></table></figure><h3 id="解析成布尔型-ParseBool"><a href="#解析成布尔型-ParseBool" class="headerlink" title="解析成布尔型(ParseBool)"></a>解析成布尔型(ParseBool)</h3><p>语法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseBool</span><span class="params">(str <span class="type">string</span>)</span></span> (<span class="type">bool</span>, <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>返回字符串表示的布尔值。其值如果是:1,t,T,True,TRUE,true,0,f,F,FALSE,false,F</p><table>    <tr>        <th>str值</th><th>返回结果</th>    </tr>    <tr>        <td>1,t,T,True,TRUE,true</td><td>true</td>    </tr>    <tr>        <td>0,f,F,FALSE,false,F</td><td>false</td>    </tr>    <tr>        <td>其他值</td><td>false</td>    </tr></table><p>使用示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">strSlice := []<span class="type">string</span>&#123;</span><br><span class="line"><span class="string">&quot;1&quot;</span>,<span class="string">&quot;t&quot;</span>,<span class="string">&quot;T&quot;</span>,<span class="string">&quot;True&quot;</span>,<span class="string">&quot;TRUE&quot;</span>,<span class="string">&quot;true&quot;</span>, <span class="comment">// 都为true</span></span><br><span class="line"><span class="string">&quot;0&quot;</span>,<span class="string">&quot;f&quot;</span>,<span class="string">&quot;F&quot;</span>,<span class="string">&quot;False&quot;</span>,<span class="string">&quot;FALSE&quot;</span>,<span class="string">&quot;false&quot;</span>, <span class="comment">// 都为false</span></span><br><span class="line"><span class="string">&quot;9&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;你&quot;</span>,<span class="string">&quot;+&quot;</span>,<span class="comment">// 其他值都是false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _,v :=  <span class="keyword">range</span> strSlice &#123;</span><br><span class="line">b,_ := strconv.ParseBool(v)</span><br><span class="line">fmt.Printf(<span class="string">&quot;当x = %s,返回: %t\n&quot;</span>, v,b)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 输出</span></span><br><span class="line"><span class="comment">当x = 1,返回: true</span></span><br><span class="line"><span class="comment">当x = t,返回: true</span></span><br><span class="line"><span class="comment">当x = T,返回: true</span></span><br><span class="line"><span class="comment">当x = True,返回: true</span></span><br><span class="line"><span class="comment">当x = TRUE,返回: true</span></span><br><span class="line"><span class="comment">当x = true,返回: true</span></span><br><span class="line"><span class="comment">当x = 0,返回: false</span></span><br><span class="line"><span class="comment">当x = f,返回: false</span></span><br><span class="line"><span class="comment">当x = F,返回: false</span></span><br><span class="line"><span class="comment">当x = False,返回: false</span></span><br><span class="line"><span class="comment">当x = FALSE,返回: false</span></span><br><span class="line"><span class="comment">当x = false,返回: false</span></span><br><span class="line"><span class="comment">当x = 9,返回: false</span></span><br><span class="line"><span class="comment">当x = a,返回: false</span></span><br><span class="line"><span class="comment">当x = 你,返回: false</span></span><br><span class="line"><span class="comment">当x = +,返回: false</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="转换成字符串-Format类函数"><a href="#转换成字符串-Format类函数" class="headerlink" title="转换成字符串(Format类函数)"></a>转换成字符串(Format类函数)</h2><p>Format类函数主要的功能是将其他类型格式化成字符串。</p><h3 id="int转string-Itoa"><a href="#int转string-Itoa" class="headerlink" title="int转string(Itoa)"></a>int转string(Itoa)</h3><p>Itoa源码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由源码可知，Itoa是FormatInt(int64(i), 10)的缩写。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Itoa</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> FormatInt(<span class="type">int64</span>(i), <span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i :=<span class="number">100</span></span><br><span class="line">s := strconv.Itoa(i)</span><br><span class="line">fmt.Printf(<span class="string">&quot;转换结果: 值: %s 类型: %T \n&quot;</span>, s,s)</span><br><span class="line">  <span class="comment">// 输出: 转换结果: 值: 100 类型: string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="int转string-ForamtInt"><a href="#int转string-ForamtInt" class="headerlink" title="int转string(ForamtInt)"></a>int转string(ForamtInt)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回指定基数，i的字符串表示。base取值范围 2 &lt;= base &lt;= 36</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatInt</span><span class="params">(i <span class="type">int64</span>, base <span class="type">int</span>)</span></span> <span class="type">string</span></span><br></pre></td></tr></table></figure><p>使用示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> i  <span class="type">int64</span> =<span class="number">123456</span></span><br><span class="line">s2 := strconv.FormatInt(i,<span class="number">2</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;base=2(二进制) 转换结果: 值: %s 类型: %T \n&quot;</span>, s2,s2)</span><br><span class="line">s8 := strconv.FormatInt(i,<span class="number">8</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;base=8(八进制) 转换结果: 值: %s 类型: %T \n&quot;</span>, s8,s8)</span><br><span class="line">s10 := strconv.FormatInt(i,<span class="number">10</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;base=10(十进制) 转换结果: 值: %s 类型: %T \n&quot;</span>, s10,s10)</span><br><span class="line">s16 := strconv.FormatInt(i,<span class="number">16</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;base=16(十六进制) 转换结果: 值: %s 类型: %T \n&quot;</span>, s16,s16)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">  base=2(二进制) 转换结果: 值: 11110001001000000 类型: string </span></span><br><span class="line"><span class="comment">  base=8(八进制) 转换结果: 值: 361100 类型: string </span></span><br><span class="line"><span class="comment">  base=10(十进制) 转换结果: 值: 123456 类型: string </span></span><br><span class="line"><span class="comment">  base=16(十六进制) 转换结果: 值: 1e240 类型: string </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>ForamtUint和ForamtInt使用方法一样，区别是ForamtUint:无符号，ForamtInt:有符号。</p><h3 id="Float转string-ForamtFloat"><a href="#Float转string-ForamtFloat" class="headerlink" title="Float转string(ForamtFloat)"></a>Float转string(ForamtFloat)</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">FormatFloat</span><span class="params">(f <span class="type">float64</span>, fmt <span class="type">byte</span>, prec, bitSize <span class="type">int</span>)</span></span> <span class="type">string</span></span><br><span class="line"><span class="comment">// bitSize: 表示f的来源类型（32:float32 64:float64）,会根据此进行舍入</span></span><br><span class="line"><span class="comment">// fmt: 表示格式标记,（b、e、E、f、g、G）;</span></span><br><span class="line">  <span class="comment">// 格式标记：</span></span><br><span class="line">    <span class="comment">// &#x27;b&#x27; (-ddddp±ddd，二进制指数)</span></span><br><span class="line">    <span class="comment">// &#x27;e&#x27; (-d.dddde±dd，十进制指数)</span></span><br><span class="line">    <span class="comment">// &#x27;E&#x27; (-d.ddddE±dd，十进制指数)</span></span><br><span class="line">    <span class="comment">// &#x27;f&#x27; (-ddd.dddd，没有指数)</span></span><br><span class="line">    <span class="comment">// &#x27;g&#x27; (&#x27;e&#x27;:大指数，&#x27;f&#x27;:其它情况)</span></span><br><span class="line">    <span class="comment">// &#x27;G&#x27; (&#x27;E&#x27;:大指数，&#x27;f&#x27;:其它情况)</span></span><br><span class="line">  <span class="comment">// 如果格式标记为 &#x27;e&#x27;，&#x27;E&#x27;和&#x27;f&#x27;，则 prec 表示小数点后的数字位数</span></span><br><span class="line">  <span class="comment">// 如果格式标记为 &#x27;g&#x27;，&#x27;G&#x27;，则 prec 表示总的数字位数（整数部分+小数部分）</span></span><br><span class="line"><span class="comment">// prec：精度</span></span><br></pre></td></tr></table></figure><p>使用示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := <span class="number">30.1237</span></span><br><span class="line"><span class="comment">// 如果格式标记为 &#x27;e&#x27;，&#x27;E&#x27;和&#x27;f&#x27;，则 prec 表示小数点后的数字位数</span></span><br><span class="line">s1 := strconv.FormatFloat(i,<span class="string">&#x27;f&#x27;</span>,<span class="number">4</span>,<span class="number">32</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;保留4位小数-&gt; 值: %s 类型: %T \n&quot;</span>, s1,s1)</span><br><span class="line"><span class="comment">// 如果格式标记为 &#x27;g&#x27;，&#x27;G&#x27;，则 prec 表示总的数字位数（整数部分+小数部分）</span></span><br><span class="line">s2 := strconv.FormatFloat(i,<span class="string">&#x27;g&#x27;</span>,<span class="number">4</span>,<span class="number">32</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;总长度返回4位-&gt; 值: %s 类型: %T \n&quot;</span>, s2,s2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment"> 保留4位小数-&gt; 值: 30.1237 类型: string </span></span><br><span class="line"><span class="comment"> 总长度返回4位-&gt; 值: 30.12 类型: string </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="转布尔型-FormatBool"><a href="#转布尔型-FormatBool" class="headerlink" title="转布尔型(FormatBool)"></a>转布尔型(FormatBool)</h3><p>使用示例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strconv&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 返回true字符串</span></span><br><span class="line">s1 := strconv.FormatBool(<span class="literal">true</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;返回true字符串-&gt; 值: %s 类型: %T \n&quot;</span>, s1,s1)</span><br><span class="line"><span class="comment">// 返回false字符串</span></span><br><span class="line">s2 := strconv.FormatBool(<span class="literal">false</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;返回false字符串-&gt; 值: %s 类型: %T \n&quot;</span>, s2,s2)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*输出</span></span><br><span class="line"><span class="comment">  返回true字符串-&gt; 值: true 类型: string </span></span><br><span class="line"><span class="comment">  返回false字符串-&gt; 值: false 类型: string </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;转换成数字类型（Parse类函数）&quot;&gt;&lt;a href=&quot;#转换成数字类型（Parse类函数）&quot; class=&quot;headerlink&quot; title=&quot;转换成数字类型（Parse类函数）&quot;&gt;&lt;/a&gt;转换成数字类型（Parse类函数）&lt;/h2&gt;&lt;h3 id=&quot;转换成整型-Atoi&quot;&gt;&lt;a href=&quot;#转换成整型-Atoi&quot; class=&quot;headerlink&quot; title=&quot;转换成整型(Atoi)&quot;&gt;&lt;/a&gt;转换成整型(Atoi)&lt;/h3&gt;&lt;p&gt;语法&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Atoi&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(s &lt;span class=&quot;type&quot;&gt;string&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; (&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;type&quot;&gt;error&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="GO" scheme="https://rma-shuyu.github.io/categories/GO/"/>
    
    
    <category term="go" scheme="https://rma-shuyu.github.io/tags/go/"/>
    
  </entry>
  
  <entry>
    <title>strings包使用</title>
    <link href="https://rma-shuyu.github.io/2021/04/21/strings%E5%8C%85%E4%BD%BF%E7%94%A8/"/>
    <id>https://rma-shuyu.github.io/2021/04/21/strings%E5%8C%85%E4%BD%BF%E7%94%A8/</id>
    <published>2021-04-21T12:27:18.000Z</published>
    <updated>2023-01-27T12:06:26.957Z</updated>
    
    <content type="html"><![CDATA[<h2 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找"></a>字符串查找</h2><blockquote><p>strings是Go内置的标准包,主要用于字符串查找、替换、比较等。常用方法如下:</p></blockquote><span id="more"></span><h3 id="方法列表"><a href="#方法列表" class="headerlink" title="方法列表"></a>方法列表</h3><table>    <tr>        <th>方法名</th><th>描述</th>    </tr>    <tr>        <td>Count(s, substr string)int</td><td>返回字符串s包含字符串substr的个数</td>    </tr>    <tr>        <td>Contains(s, substr string)bool</td><td>判断字符串s是否包含substr字符串</td>    </tr>    <tr>        <td>ContainsAny(s, chars string)bool</td><td>判断字符串s是否包含chars字符串中的任意一个字符</td>    </tr>    <tr>        <td>ContainsRune(s string, r rune)bool</td><td>判断字符串s是否包含unicode的码值r</td>    </tr>    <tr>        <td>LastIndex(s, substr string)int</td><td>返回字符串s中字符串substr最后一次出现的位置</td>    </tr>    <tr>        <td>IndexByte(s string, c byte)int</td><td>返回字符串s中字符c首次出现的位置</td>    </tr>    <tr>        <td>IndexRune(s string, r rune)int</td><td>返回unicode的码值r在字符串s中首次出现的位置</td>    </tr>    <tr>        <td>IndexAny(s, chars string)int</td><td>返回字符串chars中的任意一个字符unicode码值,在s中首次出现的位置</td>    </tr>    <tr>        <td>LastIndexAny(s, chars string)int</td><td>返回字符串chars中的任意一个字符unicode码值,在s中最后一次出现的位置</td>    </tr>    <tr>        <td>LastIndexByte(s string, c byte)int</td><td>返回字符串s中字符c最后一次出现的位置</td>    </tr>    <tr>        <td>HasPrefix(s, prefix string)bool</td><td>判断字符串s是否有前缀prefix</td>    </tr>    <tr>        <td>HasSuffix(s, suffix string)bool</td><td>判断字符串s是否有后缀suffix</td>    </tr>    <tr>        <td>IndexFunc(s string, f func(r rune)bool)int</td><td>返回字符串s中满足函数f(r)==true,字符首次出现的位置</td>    </tr>    <tr>        <td>LastIndexFunc(s string, f func(r rune)bool)int</td><td>返回字符串s中满足函数f(r)==true ,字符最后一次出现的位置</td>    </tr></table><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line"><span class="string">&quot;unicode&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 返回字符串s包含字符串substr的个数</span></span><br><span class="line">s := <span class="string">&quot;hello word&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;字符串:%s,o出现数量: %d\n&quot;</span>,s,strings.Count(s,<span class="string">&quot;o&quot;</span>))</span><br><span class="line"><span class="comment">// 判断字符串s是否包含substr字符串</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;字符串:%s 是否包含%s ? %t \n&quot;</span>,s,<span class="string">&quot;word&quot;</span>,strings.Contains(s,<span class="string">&quot;word&quot;</span>))</span><br><span class="line">fmt.Printf(<span class="string">&quot;字符串:%s 是否包含%s ? %t \n&quot;</span>,s,<span class="string">&quot;go&quot;</span>,strings.Contains(s,<span class="string">&quot;go&quot;</span>))</span><br><span class="line"><span class="comment">// 判断字符串s是否包含chars字符串中的任意一个字符</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;字符串:%s 是否包含%s中的任意一个字符 ? %t \n&quot;</span>,s,<span class="string">&quot;go&quot;</span>,strings.ContainsAny(s,<span class="string">&quot;go&quot;</span>))</span><br><span class="line">fmt.Printf(<span class="string">&quot;字符串:%s 是否包含%s中的任意一个字符 ? %t \n&quot;</span>,s,<span class="string">&quot;gg&quot;</span>,strings.ContainsAny(s,<span class="string">&quot;gg&quot;</span>))</span><br><span class="line"><span class="comment">// 判断字符串s是否包含unicode的码值r</span></span><br><span class="line">r := <span class="string">&#x27;w&#x27;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;字符串:%s 是否包含unicode的码值%c? %t \n&quot;</span>,s,r,strings.ContainsRune(s,r))</span><br><span class="line">fmt.Printf(<span class="string">&quot;字符串:%s 是否包含unicode的码值%d? %t \n&quot;</span>,s,<span class="number">119</span>,strings.ContainsRune(s,<span class="number">119</span>))</span><br><span class="line"><span class="comment">// 返回字符串s中字符串substr最后一次出现的位置</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;在字符串%s中,字符串%s最后一次出现的位置? %d \n&quot;</span>,s,<span class="string">&quot;o&quot;</span>,strings.LastIndex(s,<span class="string">&quot;o&quot;</span>))</span><br><span class="line"><span class="comment">// 返回字符串s中字符串substr首次出现的位置</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;在字符串%s中,字符串%s首次出现的位置? %d \n&quot;</span>,s,<span class="string">&quot;o&quot;</span>,strings.Index(s,<span class="string">&quot;o&quot;</span>))</span><br><span class="line"><span class="comment">// 返回字符串s中字符c首次出现的位置</span></span><br><span class="line"><span class="keyword">var</span> b <span class="type">byte</span> = <span class="string">&#x27;l&#x27;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;在字符串%s中,字符%c首次出现的位置? %d \n&quot;</span>,s,b,strings.IndexByte(s,b))</span><br><span class="line"><span class="comment">// 返回字符串s中字符c最后一次出现的位置</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;在字符串%s中,字符%c最后一次出现的位置? %d \n&quot;</span>,s,b,strings.LastIndexByte(s,b))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回unicode的码值r在字符串s中首次出现的位置</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;在字符串%s中,unicode的码值%d(%c)首次出现的位置? %d \n&quot;</span>,s,<span class="number">104</span>,<span class="number">104</span>,strings.IndexRune(s,<span class="number">104</span>))</span><br><span class="line"><span class="comment">// 返回字符串chars中的任意一个字符unicode码值,在s中首次出现的位置</span></span><br><span class="line">s3 := <span class="string">&quot;rd&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;返回字符串%s中的任意一个字符unicode码值(%s)首次出现的位置? %d \n&quot;</span>,s,s3,strings.LastIndexAny(s,s3))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断字符串s是否有前缀prefix</span></span><br><span class="line">a := <span class="string">&quot;VIP001&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;字符串:%s 是否有前缀%s ? %t \n&quot;</span>,a,<span class="string">&quot;vip&quot;</span>,strings.HasPrefix(a,<span class="string">&quot;vip&quot;</span>))</span><br><span class="line">fmt.Printf(<span class="string">&quot;字符串:%s 是否有前缀%s ? %t \n&quot;</span>,a,<span class="string">&quot;VIP&quot;</span>,strings.HasPrefix(a,<span class="string">&quot;VIP&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断字符串s是否有后缀suffix</span></span><br><span class="line">sn := <span class="string">&quot;K011_Mn&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;字符串:%s 是否有后缀%s ? %t \n&quot;</span>,sn,<span class="string">&quot;MN&quot;</span>,strings.HasSuffix(sn,<span class="string">&quot;MN&quot;</span>))</span><br><span class="line">fmt.Printf(<span class="string">&quot;字符串:%s 是否有后缀%s ? %t \n&quot;</span>,sn,<span class="string">&quot;Mn&quot;</span>,strings.HasSuffix(sn,<span class="string">&quot;Mn&quot;</span>))</span><br><span class="line"><span class="comment">// 返回字符串s中满足函数f(r)==true,字符首次出现的位置 (判断第一个汉字的位置)</span></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(c <span class="type">rune</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">return</span> unicode.Is(unicode.Han,c)</span><br><span class="line">&#125;</span><br><span class="line">s4 := <span class="string">&quot;go!中国人&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;字符串:%s 首次出现汉字的位置%d \n&quot;</span>,s4,strings.IndexFunc(s4,f))</span><br><span class="line">fmt.Printf(<span class="string">&quot;字符串:%s 最后一次出现汉字的位置%d \n&quot;</span>,s4,strings.LastIndexFunc(s4,f))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/** 输出</span></span><br><span class="line"><span class="comment">  字符串:hello word,o出现数量: 2</span></span><br><span class="line"><span class="comment">  字符串:hello word 是否包含word ? true </span></span><br><span class="line"><span class="comment">  字符串:hello word 是否包含go ? false </span></span><br><span class="line"><span class="comment">  字符串:hello word 是否包含go中的任意一个字符 ? true </span></span><br><span class="line"><span class="comment">  字符串:hello word 是否包含gg中的任意一个字符 ? false </span></span><br><span class="line"><span class="comment">  字符串:hello word 是否包含unicode的码值w? true </span></span><br><span class="line"><span class="comment">  字符串:hello word 是否包含unicode的码值119? true </span></span><br><span class="line"><span class="comment">  在字符串hello word中,字符串o最后一次出现的位置? 7 </span></span><br><span class="line"><span class="comment">  在字符串hello word中,字符串o首次出现的位置? 4 </span></span><br><span class="line"><span class="comment">  在字符串hello word中,字符l首次出现的位置? 2 </span></span><br><span class="line"><span class="comment">  在字符串hello word中,字符l最后一次出现的位置? 3 </span></span><br><span class="line"><span class="comment">  在字符串hello word中,unicode的码值104(h)首次出现的位置? 0 </span></span><br><span class="line"><span class="comment">  返回字符串hello word中的任意一个字符unicode码值(rd)首次出现的位置? 9 </span></span><br><span class="line"><span class="comment">  字符串:VIP001 是否有前缀vip ? false </span></span><br><span class="line"><span class="comment">  字符串:VIP001 是否有前缀VIP ? true </span></span><br><span class="line"><span class="comment">  字符串:K011_Mn 是否有后缀MN ? false </span></span><br><span class="line"><span class="comment">  字符串:K011_Mn 是否有后缀Mn ? true </span></span><br><span class="line"><span class="comment">  字符串:go!中国人 首次出现汉字的位置3 </span></span><br><span class="line"><span class="comment">  字符串:go!中国人 最后一次出现汉字的位置9 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="字符串分割"><a href="#字符串分割" class="headerlink" title="字符串分割"></a>字符串分割</h2><h3 id="方法列表-1"><a href="#方法列表-1" class="headerlink" title="方法列表"></a>方法列表</h3><table>    <tr>        <th>方法名</th><th>描述</th>    </tr>    <tr>        <td>Fields(s string)[]string</td><td>将字符串s以空白字符分割，返回切片</td>    </tr>    <tr>        <td>FieldsFunc(s string, f func(r) bool)[]string</td><td>将字符串s以满足f(r)==true的字符分割，分割后返回切片</td>    </tr>    <tr>        <td>Split(s,sep string)[]string</td><td>将字符串s以sep作为分割符进行分割，分割后字符最后去掉sep,返回切片</td>    </tr>    <tr>        <td>SplitAfter(s,sep string)[]string</td><td>将字符串s以sep作为分割符进行分割，分割后字符最后加上sep,返回切片</td>    </tr>    <tr>        <td>SplitAfterN(s,sep string, n int)[]string</td><td>将字符串s以sep作为分割符进行分割，分割后字符最后加上sep,n决定分割成切片长度</td>    </tr></table><h3 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line"><span class="string">&quot;unicode&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="string">&quot;Go! Go! 中国人!&quot;</span></span><br><span class="line"><span class="comment">// 将字符串s以空白字符分割，返回切片</span></span><br><span class="line">slice := strings.Fields(s)</span><br><span class="line">fmt.Printf(<span class="string">&quot;将字符串:【%s】以空白字符分割，返回切片:%v \n&quot;</span>, s, slice)</span><br><span class="line"><span class="comment">// 将字符串s以满足f(r)==true的字符分割，分割后返回切片。</span></span><br><span class="line"><span class="comment">// 以特殊符号分割</span></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(r <span class="type">rune</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="comment">// 不是字母，也不是数字</span></span><br><span class="line"><span class="keyword">return</span> !unicode.IsLetter(r) &amp;&amp; !unicode.IsNumber(r)</span><br><span class="line">&#125;</span><br><span class="line">ss := <span class="string">&quot;张三@19*BeiJing&amp;高中生|男(打球&quot;</span></span><br><span class="line">slice2 := strings.FieldsFunc(ss, f)</span><br><span class="line">fmt.Printf(<span class="string">&quot;将字符串:【%s】 以满足f(r)==true【不是数字和字母都是分隔符】的字符分割，返回切片:%v \n&quot;</span>, ss, slice2)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串s以sep作为分割符进行分割，分割后字符最后去掉sep</span></span><br><span class="line">s2 := <span class="string">&quot;@123@张@AB@001&quot;</span></span><br><span class="line">sep1 := <span class="string">&quot;@&quot;</span></span><br><span class="line">slic1 := strings.Split(s2, sep1)</span><br><span class="line">fmt.Printf(<span class="string">&quot;将字符串:【%s】以%s进行分割，分割后最后去掉:%s 返回切片: %v 切片长度: %d \n&quot;</span>, s2, sep1, sep1, slic1, <span class="built_in">len</span>(slic1))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串s以sep作为分割符进行分割，分割后字符最后加上sep,返回切片</span></span><br><span class="line">slic2 := strings.SplitAfter(s2, sep1)</span><br><span class="line">fmt.Printf(<span class="string">&quot;将字符串:【%s】以%s进行分割，分割后最后加上:%s 返回切片: %v 切片长度: %d \n&quot;</span>, s2, sep1, sep1, slic2, <span class="built_in">len</span>(slic2))</span><br><span class="line"><span class="comment">// 将字符串s以sep作为分割符进行分割，分割后字符最后加上sep,n决定分割成切片长度</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;将字符串:【%s】以%s进行分割，指定分割切片长度%d: %v 分割后加上%s \n&quot;</span>, s2, sep1, <span class="number">0</span>, strings.SplitAfterN(s2, sep1, <span class="number">0</span>), sep1)</span><br><span class="line">fmt.Printf(<span class="string">&quot;将字符串:【%s】以%s进行分割，指定分割切片长度%d: %v 分割后加上%s \n&quot;</span>, s2, sep1, <span class="number">1</span>, strings.SplitAfterN(s2, sep1, <span class="number">1</span>), sep1)</span><br><span class="line">fmt.Printf(<span class="string">&quot;将字符串:【%s】以%s进行分割，指定分割切片长度%d: %v 分割后加上%s \n&quot;</span>, s2, sep1, <span class="number">5</span>, strings.SplitAfterN(s2, sep1, <span class="number">5</span>), sep1)</span><br><span class="line">fmt.Printf(<span class="string">&quot;将字符串:【%s】以%s进行分割，指定分割切片长度%d: %v 分割后加上%s \n&quot;</span>, s2, sep1, <span class="number">6</span>, strings.SplitAfterN(s2, sep1, <span class="number">6</span>), sep1)</span><br><span class="line"><span class="comment">// 将字符串s以sep作为分割符进行分割，分割后字符最后去掉sep,n决定分割成切片长度</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;将字符串:【%s】以%s进行分割，指定分割切片长度%d: %v 分割后去掉%s \n&quot;</span>, s2, sep1, <span class="number">1</span>, strings.SplitN(s2, sep1, <span class="number">1</span>), sep1)</span><br><span class="line">fmt.Printf(<span class="string">&quot;将字符串:【%s】以%s进行分割，指定分割切片长度%d: %v 分割后去掉%s \n&quot;</span>, s2, sep1, <span class="number">3</span>, strings.SplitN(s2, sep1, <span class="number">3</span>), sep1)</span><br><span class="line">fmt.Printf(<span class="string">&quot;将字符串:【%s】以%s进行分割，指定分割切片长度%d: %v 分割后去掉%s \n&quot;</span>, s2, sep1, <span class="number">5</span>, strings.SplitN(s2, sep1, <span class="number">5</span>), sep1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 输出</span></span><br><span class="line"><span class="comment">将字符串:【Go! Go! 中国人!】以空白字符分割，返回切片:[Go! Go! 中国人!]</span></span><br><span class="line"><span class="comment">将字符串:【张三@19*BeiJing&amp;高中生|男(打球】 以满足f(r)==true【不是数字和字母都是分隔符】的字符分割，返回切片:[张三 19 BeiJing 高中生 男 打球]</span></span><br><span class="line"><span class="comment">将字符串:【@123@张@AB@001】以@进行分割，分割后最后去掉:@ 返回切片: [ 123 张 AB 001] 切片长度: 5</span></span><br><span class="line"><span class="comment">将字符串:【@123@张@AB@001】以@进行分割，分割后最后加上:@ 返回切片: [@ 123@ 张@ AB@ 001] 切片长度: 5</span></span><br><span class="line"><span class="comment">将字符串:【@123@张@AB@001】以@进行分割，指定分割切片长度0: [] 分割后加上@</span></span><br><span class="line"><span class="comment">将字符串:【@123@张@AB@001】以@进行分割，指定分割切片长度1: [@123@张@AB@001] 分割后加上@</span></span><br><span class="line"><span class="comment">将字符串:【@123@张@AB@001】以@进行分割，指定分割切片长度5: [@ 123@ 张@ AB@ 001] 分割后加上@</span></span><br><span class="line"><span class="comment">将字符串:【@123@张@AB@001】以@进行分割，指定分割切片长度6: [@ 123@ 张@ AB@ 001] 分割后加上@</span></span><br><span class="line"><span class="comment">将字符串:【@123@张@AB@001】以@进行分割，指定分割切片长度1: [@123@张@AB@001] 分割后去掉@</span></span><br><span class="line"><span class="comment">将字符串:【@123@张@AB@001】以@进行分割，指定分割切片长度3: [ 123 张@AB@001] 分割后去掉@</span></span><br><span class="line"><span class="comment">将字符串:【@123@张@AB@001】以@进行分割，指定分割切片长度5: [ 123 张 AB 001] 分割后去掉@</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="大小写切换"><a href="#大小写切换" class="headerlink" title="大小写切换"></a>大小写切换</h2><h3 id="方法列表-2"><a href="#方法列表-2" class="headerlink" title="方法列表"></a>方法列表</h3><table>    <tr>        <th>方法名</th><th>描述</th>    </tr>    <tr>        <td>Title(s string)string</td><td>将字符串s每个单词首字母大写</td>    </tr>    <tr>        <td>ToLower(s string)string</td><td>将字符串s转换成小写返回</td>    </tr>    <tr>        <td>ToTitle(s string)string</td><td>将字符串s转换成大写返回</td>    </tr>    <tr>        <td>ToUpper(s string)string</td><td>将字符串s转换成大写返回</td>    </tr></table><p>大部分情况下， ToUpper 与 ToTitle 返回值相同，但在处理某些unicode编码字符则不同</p><h3 id="使用示例-2"><a href="#使用示例-2" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">str := <span class="string">&quot;hello word&quot;</span></span><br><span class="line">str1 := <span class="string">&quot;HELLO WORD&quot;</span></span><br><span class="line"><span class="comment">// Title(s string) string: 每个单词首字母大写</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;Title-&gt;将字符串%s 每个单词首字母大写: %s\n&quot;</span>, str, strings.Title(str))</span><br><span class="line"><span class="comment">// ToLower(s string) string : 将字符串s转换成小写返回</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;ToLower-&gt;将字符串%s 转换成小写返回: %s\n&quot;</span>, str1, strings.ToLower(str1))</span><br><span class="line"><span class="comment">// ToTitle(s string)string: 将字符串s转换成大写返回</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;ToTitle-&gt;将字符串%s 转换成大写返回: %s\n&quot;</span>, str, strings.ToTitle(str))</span><br><span class="line"><span class="comment">// ToUpper(s string)string: 将字符串s转换成大写返回</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;ToUpper-&gt;将字符串%s 转换成大写返回: %s\n&quot;</span>, str, strings.ToUpper(str))</span><br><span class="line"></span><br><span class="line">strr := <span class="string">&quot;ǳ ǵǵǳǳǳ hello world！&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;ToTitle-&gt;将字符串%s 转换成大写返回: %s\n&quot;</span>, strr, strings.ToTitle(strr))</span><br><span class="line"><span class="comment">// ToUpper(s string)string: 将字符串s转换成大写返回</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;ToUpper-&gt;将字符串%s 转换成大写返回: %s\n&quot;</span>, strr, strings.ToUpper(strr))</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">Title-&gt;将字符串hello word 每个单词首字母大写: Hello Word</span></span><br><span class="line"><span class="comment">ToLower-&gt;将字符串HELLO WORD 转换成小写返回: hello word</span></span><br><span class="line"><span class="comment">ToTitle-&gt;将字符串hello word 转换成大写返回: HELLO WORD</span></span><br><span class="line"><span class="comment">ToUpper-&gt;将字符串hello word 转换成大写返回: HELLO WORD</span></span><br><span class="line"><span class="comment">ToTitle-&gt;将字符串ǳ ǵǵǳǳǳ hello world！ 转换成大写返回: ǲ ǴǴǲǲǲ HELLO WORLD！</span></span><br><span class="line"><span class="comment">ToUpper-&gt;将字符串ǳ ǵǵǳǳǳ hello world！ 转换成大写返回: Ǳ ǴǴǱǱǱ HELLO WORLD！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="字符串删除"><a href="#字符串删除" class="headerlink" title="字符串删除"></a>字符串删除</h2><h3 id="方法列表-3"><a href="#方法列表-3" class="headerlink" title="方法列表"></a>方法列表</h3><table>    <tr>        <th>方法名</th><th>描述</th>    </tr>    <tr>        <td>Trim(s,cutset string)string</td><td>将字符串s首尾包含在cutset中的任一字符去掉</td>    </tr>    <tr>        <td>TrimFunc(s string,f func(r)bool)string</td><td>将字符串s首尾满足函数f(r)==true的字符串去掉</td>    </tr>    <tr>        <td>TrimLeft(s,cutset string)string</td><td>将字符串s左边包含在cutset中的任一字符去掉</td>    </tr>    <tr>        <td>TrimLeftFunc(s string,f func(r)bool)string</td><td>将字符串s左边满足函数f(r)==true的字符串去掉</td>    </tr>    <tr>        <td>TrimPrefix(s,prefix string)string</td><td>将字符串s中前缀字符串prefix去掉</td>    </tr>    <tr>        <td>TrimRight(s,cutset string)string</td><td>将字符串s右边包含在cutset中的任一字符去掉</td>    </tr>    <tr>        <td>TrimRightFunc(s string, f func(r) bool)string</td><td>将字符串s右边满足函数f(r)==true的字符串去掉</td>    </tr>    <tr>        <td>TrimSpace(s string) string</td><td>将字符串首尾空白去掉</td>    </tr>    <tr>        <td>TrimSuffix(s, suffix string) string</td><td>将字符串s中后缀字符串suffix去掉</td>    </tr></table><h3 id="使用示例-3"><a href="#使用示例-3" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 将字符串首尾包含在cutset中的任一字符去掉</span></span><br><span class="line">str := <span class="string">&quot;@*test@-@124@!*&quot;</span></span><br><span class="line">cutset := <span class="string">&quot;*#@!&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;将字符串【%s】首尾包含在【%s】中的任一字符去掉,返回:【%s】\n&quot;</span>, str, cutset, strings.Trim(str, cutset))</span><br><span class="line"><span class="comment">// 将字符串首尾满足函数`f(r)==true`的字符串去掉</span></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(r <span class="type">rune</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">if</span> strings.Contains(<span class="string">&quot;*#@!&quot;</span>, <span class="type">string</span>(r)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;将字符串【%s】首尾满足函数f的字符去掉,返回:【%s】\n&quot;</span>, str, strings.TrimFunc(str, f))</span><br><span class="line"><span class="comment">// 将字符串左边包含在cutset中的任一字符去掉</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;将字符串【%s】左边包含在【%s】中的任一字符去掉,返回:【%s】\n&quot;</span>, str, cutset, strings.TrimLeft(str, cutset))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串左边满足函数`f(r)==true`的字符串去掉</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;将字符串【%s】左边满足函数f的字符去掉,返回:【%s】\n&quot;</span>, str, strings.TrimLeftFunc(str, f))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串右边包含在cutset中的任一字符去掉</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;将字符串【%s】右边包含在【%s】中的任一字符去掉,返回:【%s】\n&quot;</span>, str, cutset, strings.TrimRight(str, cutset))</span><br><span class="line">fmt.Printf(<span class="string">&quot;将字符串【%s】右边满足函数f的字符去掉,返回:【%s】\n&quot;</span>, str, strings.TrimRightFunc(str, f))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串中前缀字符串prefix去掉</span></span><br><span class="line">str1 := <span class="string">&quot;VIP00001_U&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;将字符串【%s】前缀【%s】去掉,返回:【%s】\n&quot;</span>, str1, <span class="string">&quot;VIP&quot;</span>, strings.TrimPrefix(str1, <span class="string">&quot;VIP&quot;</span>))</span><br><span class="line">fmt.Printf(<span class="string">&quot;将字符串【%s】前缀【%s】去掉,返回:【%s】\n&quot;</span>, str1, <span class="string">&quot;vip&quot;</span>, strings.TrimPrefix(str1, <span class="string">&quot;vip&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串中后缀字符串suffix去掉</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;将字符串【%s】后缀【%s】去掉,返回:【%s】\n&quot;</span>, str1, <span class="string">&quot;U&quot;</span>, strings.TrimSuffix(str1, <span class="string">&quot;U&quot;</span>))</span><br><span class="line">fmt.Printf(<span class="string">&quot;将字符串【%s】后缀【%s】去掉,返回:【%s】\n&quot;</span>, str1, <span class="string">&quot;u&quot;</span>, strings.TrimSuffix(str1, <span class="string">&quot;u&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将字符串首尾空白去掉</span></span><br><span class="line">str2 := <span class="string">&quot;  hello  word !  &quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;将字符串【%s】首尾空白去掉,返回:【%s】\n&quot;</span>, str2, strings.TrimSpace(str2))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">将字符串【@*test@-@124@!*】首尾包含在【*#@!】中的任一字符去掉,返回:【test@-@124】</span></span><br><span class="line"><span class="comment">将字符串【@*test@-@124@!*】首尾满足函数f的字符去掉,返回:【test@-@124】</span></span><br><span class="line"><span class="comment">将字符串【@*test@-@124@!*】左边包含在【*#@!】中的任一字符去掉,返回:【test@-@124@!*】</span></span><br><span class="line"><span class="comment">将字符串【@*test@-@124@!*】左边满足函数f的字符去掉,返回:【test@-@124@!*】</span></span><br><span class="line"><span class="comment">将字符串【@*test@-@124@!*】右边包含在【*#@!】中的任一字符去掉,返回:【@*test@-@124】</span></span><br><span class="line"><span class="comment">将字符串【@*test@-@124@!*】右边满足函数f的字符去掉,返回:【@*test@-@124】</span></span><br><span class="line"><span class="comment">将字符串【VIP00001_U】前缀【VIP】去掉,返回:【00001_U】</span></span><br><span class="line"><span class="comment">将字符串【VIP00001_U】前缀【vip】去掉,返回:【VIP00001_U】</span></span><br><span class="line"><span class="comment">将字符串【VIP00001_U】后缀【U】去掉,返回:【VIP00001_】</span></span><br><span class="line"><span class="comment">将字符串【VIP00001_U】后缀【u】去掉,返回:【VIP00001_U】</span></span><br><span class="line"><span class="comment">将字符串【  hello  word !  】首尾空白去掉,返回:【hello  word !】</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="字符串删除-1"><a href="#字符串删除-1" class="headerlink" title="字符串删除"></a>字符串删除</h2><h3 id="方法列表-4"><a href="#方法列表-4" class="headerlink" title="方法列表"></a>方法列表</h3><table>    <tr>        <th>方法名</th><th>描述</th>    </tr>    <tr>        <td>Join(elems []string, sep string) string</td><td>将字符串切片elems，使用sep进行拼接</td>    </tr>    <tr>        <td>Repeat(s string, count int) string</td><td>将字符串s,重复count次</td>    </tr></table><h3 id="使用示例-4"><a href="#使用示例-4" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 字符串拼接</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;字符串拼接:Join-&gt; %s\n&quot;</span>, strings.Join([]<span class="type">string</span>&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125;, <span class="string">&quot;|&quot;</span>))</span><br><span class="line"><span class="comment">// 字符串重复</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;字符串重复:Repeat-&gt; %s\n&quot;</span>, strings.Repeat(<span class="string">&quot;Go!&quot;</span>, <span class="number">10</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">字符串拼接:Join-&gt; a|b|c</span></span><br><span class="line"><span class="comment">字符串重复:Repeat-&gt; Go!Go!Go!Go!Go!Go!Go!Go!Go!Go!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h2><h3 id="方法列表-5"><a href="#方法列表-5" class="headerlink" title="方法列表"></a>方法列表</h3><table>    <tr>        <th>方法名</th><th>描述</th>    </tr>    <tr>        <td>Replace(s, old, new string, n int)string</td><td>将字符串s前n个不重叠old子串都替换为new的新字符串如果n小于0会替换所有old子串。</td>    </tr>    <tr>        <td>ReplaceAll(s, old, new string) string</td><td>将字符串s中的old子串全部替换为new的新字符串</td>    </tr></table><h3 id="使用示例-5"><a href="#使用示例-5" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 字符串替换,如果n&lt;0会替换所有old子串。</span></span><br><span class="line">s := <span class="string">&quot;a,b,c,d,e,f&quot;</span></span><br><span class="line">old := <span class="string">&quot;,&quot;</span></span><br><span class="line">newStr := <span class="string">&quot;.&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;将字符串【%s】中的前%d个【%s】替换为【%s】结果是【%s】\n&quot;</span>, s, <span class="number">2</span>, old, newStr, strings.Replace(s, old, newStr, <span class="number">2</span>))</span><br><span class="line">fmt.Printf(<span class="string">&quot;将字符串【%s】中的前%d个【%s】替换为【%s】结果是【%s】\n&quot;</span>, s, <span class="number">7</span>, old, newStr, strings.Replace(s, old, newStr, <span class="number">7</span>))</span><br><span class="line">fmt.Printf(<span class="string">&quot;将字符串【%s】中的前%d个【%s】替换为【%s】结果是【%s】\n&quot;</span>, s, <span class="number">-1</span>, old, newStr, strings.Replace(s, old, newStr, <span class="number">-1</span>))</span><br><span class="line"><span class="comment">// 字符串全部替换</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;将字符串【%s】中的【%s】全部替换为【%s】结果是【%s】\n&quot;</span>, s, old, newStr, strings.ReplaceAll(s, old, newStr))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">将字符串【a,b,c,d,e,f】中的前2个【,】替换为【.】结果是【a.b.c,d,e,f】</span></span><br><span class="line"><span class="comment">将字符串【a,b,c,d,e,f】中的前7个【,】替换为【.】结果是【a.b.c.d.e.f】</span></span><br><span class="line"><span class="comment">将字符串【a,b,c,d,e,f】中的前-1个【,】替换为【.】结果是【a.b.c.d.e.f】</span></span><br><span class="line"><span class="comment">将字符串【a,b,c,d,e,f】中的【,】全部替换为【.】结果是【a.b.c.d.e.f】</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h2><h3 id="方法列表-6"><a href="#方法列表-6" class="headerlink" title="方法列表"></a>方法列表</h3><table>    <tr>        <th>方法名</th><th>描述</th>    </tr>    <tr>        <td>Compare(a, b string) int</td><td>按字典顺序比较a和b字符串的大小</td>    </tr>    <tr>        <td>EqualFold(s, t string) bool</td><td>判断s和t两个UTF-8字符串是否相等，忽略大小写</td>    </tr></table><h3 id="使用示例-6"><a href="#使用示例-6" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;strings&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 字符串比较大小</span></span><br><span class="line">s := <span class="string">&quot;a&quot;</span></span><br><span class="line">s1 := <span class="string">&quot;c&quot;</span></span><br><span class="line">s2 := <span class="string">&quot;c&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s &gt; %s 返回 : %d \n&quot;</span>, s, s1, strings.Compare(s, s1))</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s &gt; %s 返回 : %d \n&quot;</span>, s1, s, strings.Compare(s1, s))</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s &gt; %s 返回 : %d \n&quot;</span>, s1, s2, strings.Compare(s1, s2))</span><br><span class="line"><span class="comment">// 字符串比较一致性</span></span><br><span class="line">a := <span class="string">&quot;go&quot;</span></span><br><span class="line">b := <span class="string">&quot;Go&quot;</span></span><br><span class="line">c := <span class="string">&quot;go&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%s和%s是否相等(忽略大小写)？%t \n&quot;</span>, a, b, strings.EqualFold(a, b))</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s和%s是否相等(忽略大小写)？%t \n&quot;</span>, a, c, strings.EqualFold(a, c))</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s和%s是否相等(不忽略大小写)？%t \n&quot;</span>, a, b, a == b)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%s和%s是否相等(不忽略大小写)？%t \n&quot;</span>, a, c, a == c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**输出</span></span><br><span class="line"><span class="comment">a &gt; c 返回 : -1</span></span><br><span class="line"><span class="comment">c &gt; a 返回 : 1</span></span><br><span class="line"><span class="comment">c &gt; c 返回 : 0</span></span><br><span class="line"><span class="comment">go和Go是否相等(忽略大小写)？true</span></span><br><span class="line"><span class="comment">go和go是否相等(忽略大小写)？true</span></span><br><span class="line"><span class="comment">go和Go是否相等(不忽略大小写)？false</span></span><br><span class="line"><span class="comment">go和go是否相等(不忽略大小写)？true</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;字符串查找&quot;&gt;&lt;a href=&quot;#字符串查找&quot; class=&quot;headerlink&quot; title=&quot;字符串查找&quot;&gt;&lt;/a&gt;字符串查找&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;strings是Go内置的标准包,主要用于字符串查找、替换、比较等。常用方法如下:&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="GO" scheme="https://rma-shuyu.github.io/categories/GO/"/>
    
    
    <category term="go" scheme="https://rma-shuyu.github.io/tags/go/"/>
    
  </entry>
  
</feed>
