<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rma&#39;s Blog</title>
  
  <subtitle>Stay hungry, stay foolish</subtitle>
  <link href="https://rma-shuyu.github.io/atom.xml" rel="self"/>
  
  <link href="https://rma-shuyu.github.io/"/>
  <updated>2023-07-01T09:37:27.373Z</updated>
  <id>https://rma-shuyu.github.io/</id>
  
  <author>
    <name>rma-shuyu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>libvirt with dpdk-vdpa</title>
    <link href="https://rma-shuyu.github.io/2023/03/14/libvirt-with-dpdk-vdpa/"/>
    <id>https://rma-shuyu.github.io/2023/03/14/libvirt-with-dpdk-vdpa/</id>
    <published>2023-03-14T02:05:30.000Z</published>
    <updated>2023-07-01T09:37:27.373Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OS                               : CentOS Linux release 8.4.2105</span><br><span class="line">Kernel                           : 4.18.0-305.30.1.el8.x86_64</span><br><span class="line">qemu                             : 6.2.0</span><br><span class="line">dpdk                             : 22.11.1 </span><br><span class="line">libvirt                          : 8.0.0</span><br><span class="line">设备类型                         :  net</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="dpdk-vdpa启动"><a href="#dpdk-vdpa启动" class="headerlink" title="dpdk-vdpa启动"></a>dpdk-vdpa启动</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./dpdk-vdpa -c 0x2 -n 4 --socket-mem 1024,1024 \</span><br><span class="line">            -a 0000:cc:00.1,vdpa=1  -a 0000:cc:00.2,vdpa=1  \</span><br><span class="line">                -- --iface /tmp/vdpa-socket</span><br></pre></td></tr></table></figure><h2 id="libvirt-xml配置"><a href="#libvirt-xml配置" class="headerlink" title="libvirt xml配置"></a>libvirt xml配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">domain</span> <span class="attr">type</span>=<span class="string">&quot;kvm&quot;</span> <span class="attr">xmlns:qemu</span>=<span class="string">&#x27;http://libvirt.org/schemas/domain/qemu/1.0&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>vm0<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uuid</span>&gt;</span>d37f5411-b296-11ed-8e6c-0c48c6c879e4<span class="tag">&lt;/<span class="name">uuid</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">memory</span> <span class="attr">unit</span>=<span class="string">&quot;KiB&quot;</span>&gt;</span>2097152<span class="tag">&lt;/<span class="name">memory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">memoryBacking</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hugepages</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">page</span> <span class="attr">size</span>=<span class="string">&quot;2&quot;</span> <span class="attr">unit</span>=<span class="string">&quot;M&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hugepages</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nosharepages</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">locked</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">source</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">access</span> <span class="attr">mode</span>=<span class="string">&quot;shared&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">discard</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">memoryBacking</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">vcpu</span> <span class="attr">placement</span>=<span class="string">&quot;static&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">vcpu</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">os</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">type</span> <span class="attr">arch</span>=<span class="string">&quot;x86_64&quot;</span> <span class="attr">machine</span>=<span class="string">&quot;pc-i440fx-2.1&quot;</span>&gt;</span>hvm<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">os</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cpu</span> <span class="attr">mode</span>=<span class="string">&#x27;custom&#x27;</span> <span class="attr">match</span>=<span class="string">&#x27;exact&#x27;</span> <span class="attr">check</span>=<span class="string">&#x27;full&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">model</span> <span class="attr">fallback</span>=<span class="string">&#x27;forbid&#x27;</span>&gt;</span>kvm64<span class="tag">&lt;/<span class="name">model</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">feature</span> <span class="attr">policy</span>=<span class="string">&#x27;require&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;x2apic&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">feature</span> <span class="attr">policy</span>=<span class="string">&#x27;require&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;hypervisor&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">cpu</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">features</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">acpi</span>&gt;</span><span class="tag">&lt;/<span class="name">acpi</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">features</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">clock</span> <span class="attr">offset</span>=<span class="string">&quot;utc&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">clock</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">on_poweroff</span>&gt;</span>destroy<span class="tag">&lt;/<span class="name">on_poweroff</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">on_reboot</span>&gt;</span>restart<span class="tag">&lt;/<span class="name">on_reboot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">on_crash</span>&gt;</span>destroy<span class="tag">&lt;/<span class="name">on_crash</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">devices</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">emulator</span>&gt;</span>/root/pc-bios/qemu-system-x86_64<span class="tag">&lt;/<span class="name">emulator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">disk</span> <span class="attr">device</span>=<span class="string">&quot;disk&quot;</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">bus</span>=<span class="string">&quot;ide&quot;</span> <span class="attr">dev</span>=<span class="string">&quot;hda&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">source</span> <span class="attr">file</span>=<span class="string">&quot;/mnt/store/vm0-centos8.4-8g-ext4-host-dmar.img&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">disk</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">interface</span> <span class="attr">type</span>=<span class="string">&#x27;vhostuser&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mac</span> <span class="attr">address</span>=<span class="string">&#x27;00:aa:bb:cc:dd:ee&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">source</span> <span class="attr">type</span>=<span class="string">&#x27;unix&#x27;</span> <span class="attr">path</span>=<span class="string">&#x27;/tmp/vdpa-socket0&#x27;</span> <span class="attr">mode</span>=<span class="string">&#x27;client&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">model</span> <span class="attr">type</span>=<span class="string">&#x27;virtio&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">driver</span> <span class="attr">queues</span>=<span class="string">&#x27;4&#x27;</span> <span class="attr">rx_queue_size</span>=<span class="string">&#x27;512&#x27;</span> <span class="attr">tx_queue_size</span>=<span class="string">&#x27;512&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">serial</span> <span class="attr">type</span>=<span class="string">&quot;tcp&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">source</span> <span class="attr">mode</span>=<span class="string">&quot;bind&quot;</span> <span class="attr">host</span>=<span class="string">&quot;127.0.0.1&quot;</span> <span class="attr">service</span>=<span class="string">&quot;4321&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">protocol</span> <span class="attr">type</span>=<span class="string">&quot;telnet&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">port</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">serial</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">graphics</span> <span class="attr">type</span>=<span class="string">&#x27;vnc&#x27;</span> <span class="attr">port</span>=<span class="string">&#x27;5901&#x27;</span> <span class="attr">listen</span>=<span class="string">&#x27;0.0.0.0&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listen</span> <span class="attr">type</span>=<span class="string">&#x27;address&#x27;</span> <span class="attr">address</span>=<span class="string">&#x27;0.0.0.0&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">graphics</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">devices</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">qemu:commandline</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">qemu:arg</span> <span class="attr">value</span>=<span class="string">&#x27;-L&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">qemu:arg</span> <span class="attr">value</span>=<span class="string">&#x27;/root/pc-bios&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">qemu:commandline</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="验证结果"><a href="#验证结果" class="headerlink" title="验证结果"></a>验证结果</h2><p>1、查看libvirt是否正常拉起vm</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># virsh -c qemu+tcp:///system create vm.xml</span></span><br><span class="line">Domain <span class="string">&#x27;vm0&#x27;</span> created from vm.xml</span><br><span class="line"></span><br><span class="line"><span class="comment"># virsh list</span></span><br><span class="line"> Id   Name   State</span><br><span class="line">----------------------</span><br><span class="line"> 29   vm0    running</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2、ping测试<br><img src="03e2f3d08b21dc6b24565608fdd47abc9cbe6acb6bd8286f651bb44728647ad3.png" alt="图 2">  </p><h2 id="调试问题"><a href="#调试问题" class="headerlink" title="调试问题"></a>调试问题</h2><p>使用libvirt拉起vm时，ping failed<br><img src="3d9fe6c5801dcd971f82c9826d8fd9e596c0c1edd45cd42b49d299b31abe463e.png" alt="图 1">  </p><h3 id="定位过程"><a href="#定位过程" class="headerlink" title="定位过程"></a>定位过程</h3><p>1、查看/var/log/libvirt/qemu/vm0.log日志，发现存在错误日志打印，可以看到qemu启动参数需要指定<code>memory-backend-file</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2023-06-14T01:53:51.897860Z qemu-system-x86_64: Failed initializing vhost-user memory map, consider using -object memory-backend-file share=on</span><br><span class="line">2023-06-14T01:53:51.897958Z qemu-system-x86_64: vhost_set_mem_table failed: Input/output error (5)</span><br><span class="line">2023-06-14T01:53:51.912732Z qemu-system-x86_64: unable to start vhost net: 5: falling back on userspace virtio</span><br><span class="line">2023-06-14T01:53:51.949246Z qemu-system-x86_64: Failed initializing vhost-user memory map, consider using -object memory-backend-file share=on</span><br><span class="line">2023-06-14T01:53:51.949266Z qemu-system-x86_64: vhost_set_mem_table failed: Resource temporarily unavailable (11)</span><br><span class="line">2023-06-14T01:53:51.963736Z qemu-system-x86_64: unable to start vhost net: 11: falling back on userspace virtio</span><br></pre></td></tr></table></figure><p>2、查看qemu启动进程参数，发现qemu参数指定的是<code>memory-backend-ram</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root        6394       1 50 08:23 ?        00:00:47 /root/pc-bios/qemu-system-x86_64 -name guest=vm0,debug-threads=on -S -object &#123;<span class="string">&quot;qom-type&quot;</span>:<span class="string">&quot;secret&quot;</span>,<span class="string">&quot;id&quot;</span>:<span class="string">&quot;masterKey0&quot;</span>,<span class="string">&quot;format&quot;</span>:<span class="string">&quot;raw&quot;</span>,<span class="string">&quot;file&quot;</span>:<span class="string">&quot;/var/lib/libvirt/qemu/domain-10-vm0/master-key.aes&quot;</span>&#125; -machine pc-i440fx-2.1,usb=off,dump-guest-core=off,memory-backend=pc.ram -accel kvm -cpu kvm64,x2apic=on,hypervisor=on -m 2048 -object &#123;<span class="string">&quot;qom-type&quot;</span>:<span class="string">&quot;memory-backend-ram&quot;</span>,<span class="string">&quot;id&quot;</span>:<span class="string">&quot;pc.ram&quot;</span>,<span class="string">&quot;size&quot;</span>:2147483648&#125; -overcommit mem-lock=off -smp 2,sockets=2,cores=1,threads=1 -uuid d37f5411-b296-11ed-8e6c-0c48c6c879e4 -no-user-config -nodefaults -chardev socket,<span class="built_in">id</span>=charmonitor,fd=38,server=on,<span class="built_in">wait</span>=off -mon chardev=charmonitor,<span class="built_in">id</span>=monitor,mode=control -rtc base=utc -no-shutdown -boot strict=on -device piix3-usb-uhci,<span class="built_in">id</span>=usb,bus=pci.0,addr=0x1.0x2 -blockdev &#123;<span class="string">&quot;driver&quot;</span>:<span class="string">&quot;file&quot;</span>,<span class="string">&quot;filename&quot;</span>:<span class="string">&quot;/mnt/store/vm0-centos8.4-8g-ext4-host-dmar.img&quot;</span>,<span class="string">&quot;node-name&quot;</span>:<span class="string">&quot;libvirt-1-storage&quot;</span>,<span class="string">&quot;auto-read-only&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;discard&quot;</span>:<span class="string">&quot;unmap&quot;</span>&#125; -blockdev &#123;<span class="string">&quot;node-name&quot;</span>:<span class="string">&quot;libvirt-1-format&quot;</span>,<span class="string">&quot;read-only&quot;</span>:<span class="literal">false</span>,<span class="string">&quot;driver&quot;</span>:<span class="string">&quot;raw&quot;</span>,<span class="string">&quot;file&quot;</span>:<span class="string">&quot;libvirt-1-storage&quot;</span>&#125; -device ide-hd,bus=ide.0,unit=0,drive=libvirt-1-format,<span class="built_in">id</span>=ide0-0-0,bootindex=1 -chardev socket,<span class="built_in">id</span>=charnet0,path=/tmp/vdpa-socket0 -netdev vhost-user,chardev=charnet0,queues=4,<span class="built_in">id</span>=hostnet0 -device virtio-net-pci,mq=on,vectors=10,rx_queue_size=512,tx_queue_size=512,netdev=hostnet0,<span class="built_in">id</span>=net0,mac=00:aa:bb:cc:<span class="built_in">dd</span>:ee,bus=pci.0,addr=0x3 -chardev socket,<span class="built_in">id</span>=charserial0,host=127.0.0.1,port=4321,telnet=on,server=on,<span class="built_in">wait</span>=off -device isa-serial,chardev=charserial0,<span class="built_in">id</span>=serial0 -audiodev &#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;audio1&quot;</span>,<span class="string">&quot;driver&quot;</span>:<span class="string">&quot;none&quot;</span>&#125; -vnc 0.0.0.0:0,audiodev=audio1 -device cirrus-vga,<span class="built_in">id</span>=video0,bus=pci.0,addr=0x2 -device virtio-balloon-pci,<span class="built_in">id</span>=balloon0,bus=pci.0,addr=0x4 -L /root/pc-bios -msg timestamp=on</span><br></pre></td></tr></table></figure><h3 id="根因分析"><a href="#根因分析" class="headerlink" title="根因分析"></a>根因分析</h3><p>qemu进程在ram_block初始化的时候根据memory-backend-xxx，其中xxx可以指定file、memfd、ram，<br>从而指定不同的内存申请方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">host_memory_backend_memory_complete(UserCreatable *uc, Error **errp)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (bc-&gt;alloc) &#123;</span><br><span class="line">        bc-&gt;alloc(backend, &amp;local_err);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当指定memory-backend-file<br>则bc-&gt;alloc = file_backend_memory_alloc</p><p>当指定memory-backend-ram<br>则bc-&gt;alloc = ram_backend_memory_alloc;</p><p>这两个主要的区别在于申请ram_block时，file_backend_memory_alloc会额外申请一个fd，用于前后端进程共享内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RAMBlock *<span class="title function_">qemu_ram_alloc_from_file</span><span class="params">(<span class="type">ram_addr_t</span> size, MemoryRegion *mr,</span></span><br><span class="line"><span class="params">                                   <span class="type">uint32_t</span> ram_flags, <span class="type">const</span> <span class="type">char</span> *mem_path,</span></span><br><span class="line"><span class="params">                                   <span class="type">bool</span> readonly, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    fd = file_ram_open(mem_path, memory_region_name(mr), readonly, &amp;created,</span><br><span class="line">                       errp);</span><br><span class="line">...</span><br><span class="line">    block = qemu_ram_alloc_from_fd(size, mr, ram_flags, fd, <span class="number">0</span>, readonly, errp);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MemoryRegion通过vhost-user VHOST_USER_SET_MEM_TABLE消息传递到dpdk-vdpa进程<br>如果不指定memory-backend-file，VHOST_USER_SET_MEM_TABLE消息失败，在vhost_dev_start中返回失败，不会走后续设备启动流程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vhost_dev_start</span><span class="params">(<span class="keyword">struct</span> vhost_dev *hdev, VirtIODevice *vdev)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    r = hdev-&gt;vhost_ops-&gt;vhost_set_mem_table(hdev, hdev-&gt;mem);</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        VHOST_OPS_DEBUG(<span class="string">&quot;vhost_set_mem_table failed&quot;</span>);</span><br><span class="line">        r = -errno;</span><br><span class="line">        <span class="keyword">goto</span> fail_mem;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">     r = hdev-&gt;vhost_ops-&gt;vhost_dev_start(hdev, <span class="literal">true</span>);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题修复"><a href="#问题修复" class="headerlink" title="问题修复"></a>问题修复</h3><p>libvirt xml指定memoryBacking类型为file</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">domain</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;<span class="name">memoryBacking</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hugepages</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">page</span> <span class="attr">size</span>=<span class="string">&quot;2&quot;</span> <span class="attr">unit</span>=<span class="string">&quot;M&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hugepages</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nosharepages</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">locked</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">source</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">access</span> <span class="attr">mode</span>=<span class="string">&quot;shared&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">discard</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">memoryBacking</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时再次启动vm，可以发现此时qemu进程启动参数为<code>memory-backend-file</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root       17715       1 75 23:02 ?        00:00:47 /root/pc-bios/qemu-system-x86_64 -name guest=vm0,debug-threads=on -S -object &#123;<span class="string">&quot;qom-type&quot;</span>:<span class="string">&quot;secret&quot;</span>,<span class="string">&quot;id&quot;</span>:<span class="string">&quot;masterKey0&quot;</span>,<span class="string">&quot;format&quot;</span>:<span class="string">&quot;raw&quot;</span>,<span class="string">&quot;file&quot;</span>:<span class="string">&quot;/var/lib/libvirt/qemu/domain-3-vm0/master-key.aes&quot;</span>&#125; -machine pc-i440fx-2.1,usb=off,dump-guest-core=off,mem-merge=off,memory-backend=pc.ram -accel kvm -cpu kvm64,x2apic=on,hypervisor=on -m 2048 -object &#123;<span class="string">&quot;qom-type&quot;</span>:<span class="string">&quot;memory-backend-file&quot;</span>,<span class="string">&quot;id&quot;</span>:<span class="string">&quot;pc.ram&quot;</span>,<span class="string">&quot;mem-path&quot;</span>:<span class="string">&quot;/dev/hugepages/libvirt/qemu/3-vm0&quot;</span>,<span class="string">&quot;discard-data&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;share&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;x-use-canonical-path-for-ramblock-id&quot;</span>:<span class="literal">false</span>,<span class="string">&quot;prealloc&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;size&quot;</span>:2147483648&#125; -overcommit mem-lock=on -smp 2,sockets=2,cores=1,threads=1 -uuid d37f5411-b296-11ed-8e6c-0c48c6c879e4 -no-user-config -nodefaults -chardev socket,<span class="built_in">id</span>=charmonitor,fd=39,server=on,<span class="built_in">wait</span>=off -mon chardev=charmonitor,<span class="built_in">id</span>=monitor,mode=control -rtc base=utc -no-shutdown -boot strict=on -device piix3-usb-uhci,<span class="built_in">id</span>=usb,bus=pci.0,addr=0x1.0x2 -blockdev &#123;<span class="string">&quot;driver&quot;</span>:<span class="string">&quot;file&quot;</span>,<span class="string">&quot;filename&quot;</span>:<span class="string">&quot;/mnt/store/vm0-centos8.4-8g-ext4-host-dmar.img&quot;</span>,<span class="string">&quot;node-name&quot;</span>:<span class="string">&quot;libvirt-1-storage&quot;</span>,<span class="string">&quot;auto-read-only&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;discard&quot;</span>:<span class="string">&quot;unmap&quot;</span>&#125; -blockdev &#123;<span class="string">&quot;node-name&quot;</span>:<span class="string">&quot;libvirt-1-format&quot;</span>,<span class="string">&quot;read-only&quot;</span>:<span class="literal">false</span>,<span class="string">&quot;driver&quot;</span>:<span class="string">&quot;raw&quot;</span>,<span class="string">&quot;file&quot;</span>:<span class="string">&quot;libvirt-1-storage&quot;</span>&#125; -device ide-hd,bus=ide.0,unit=0,drive=libvirt-1-format,<span class="built_in">id</span>=ide0-0-0,bootindex=1 -chardev socket,<span class="built_in">id</span>=charnet0,path=/tmp/vdpa-socket0 -netdev vhost-user,chardev=charnet0,queues=4,<span class="built_in">id</span>=hostnet0 -device virtio-net-pci,mq=on,vectors=10,rx_queue_size=512,tx_queue_size=512,netdev=hostnet0,<span class="built_in">id</span>=net0,mac=00:aa:bb:cc:<span class="built_in">dd</span>:ee,bus=pci.0,addr=0x3 -chardev socket,<span class="built_in">id</span>=charserial0,host=127.0.0.1,port=4321,telnet=on,server=on,<span class="built_in">wait</span>=off -device isa-serial,chardev=charserial0,<span class="built_in">id</span>=serial0 -audiodev &#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;audio1&quot;</span>,<span class="string">&quot;driver&quot;</span>:<span class="string">&quot;none&quot;</span>&#125; -vnc 0.0.0.0:0,audiodev=audio1 -device cirrus-vga,<span class="built_in">id</span>=video0,bus=pci.0,addr=0x2 -device virtio-balloon-pci,<span class="built_in">id</span>=balloon0,bus=pci.0,addr=0x4 -L /root/pc-bios -msg timestamp=on</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;环境信息&quot;&gt;&lt;a href=&quot;#环境信息&quot; class=&quot;headerlink&quot; title=&quot;环境信息&quot;&gt;&lt;/a&gt;环境信息&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;OS                               : CentOS Linux release 8.4.2105&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Kernel                           : 4.18.0-305.30.1.el8.x86_64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;qemu                             : 6.2.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dpdk                             : 22.11.1 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;libvirt                          : 8.0.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;设备类型                         :  net&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="虚拟化" scheme="https://rma-shuyu.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="Libvirt" scheme="https://rma-shuyu.github.io/tags/Libvirt/"/>
    
  </entry>
  
  <entry>
    <title>DPDK+OVS+QEMU前后端启动vm</title>
    <link href="https://rma-shuyu.github.io/2023/03/06/DPDK-OVS-QEMU%E5%89%8D%E5%90%8E%E7%AB%AF%E5%90%AF%E5%8A%A8vm/"/>
    <id>https://rma-shuyu.github.io/2023/03/06/DPDK-OVS-QEMU%E5%89%8D%E5%90%8E%E7%AB%AF%E5%90%AF%E5%8A%A8vm/</id>
    <published>2023-03-06T08:01:04.000Z</published>
    <updated>2023-07-29T06:46:38.891Z</updated>
    
    <content type="html"><![CDATA[<h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><ul><li><p>DPDK 22.11.1</p></li><li><p>A DPDK supported NIC</p></li></ul><p>Only required when physical ports are in use</p><span id="more"></span><ul><li>A suitable kernel</li></ul><p>On Linux Distros running kernel version &gt;= 3.0, only IOMMU needs to enabled via the grub cmdline, assuming you are using VFIO. For older kernels, ensure the kernel is built with UIO, HUGETLBFS, PROC_PAGE_MONITOR, HPET, HPET_MMAP support. If these are not present, it will be necessary to upgrade your kernel or build a custom kernel with these flags enabled.</p><h2 id="dpdk环境设置"><a href="#dpdk环境设置" class="headerlink" title="dpdk环境设置"></a>dpdk环境设置</h2><p>检查VT-d功能是否打开</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/cmdline | grep iommu=pt</span><br><span class="line"><span class="built_in">cat</span> /proc/cmdline | grep intel_iommu=on</span><br></pre></td></tr></table></figure><p>如果没有开启，那么需要修改/etc/default/grub中GRUB_CMDLINE_LINUX_DEFAULT，重新创建引导grub</p><p>设置大页，加载vfio，绑定物理网卡到vfio</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">huge_set --setup 4g</span><br><span class="line">modprobe vfio-pci</span><br><span class="line">dpdk_bind -b vfio-pci ens33f1</span><br></pre></td></tr></table></figure><p>这里的<code>huge_set</code>、<code>dpdk_bind</code>对应dpdk bin中的<code>dpdk-devbind.py</code>、<code>dpdk-hugepages.py</code></p><h2 id="ovs启动"><a href="#ovs启动" class="headerlink" title="ovs启动"></a>ovs启动</h2><ul><li>创建ovs相关目录</li><li>第一次需要创建ovsdb</li><li>启动ovsdb-server</li><li>检查db.sock是否正常创建</li><li>设置other_config为dpdk模式</li><li>启动ovs-vswitchd</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /mnt/store/ovs/images/bin</span><br><span class="line"></span><br><span class="line">dpdk_socket_mem=<span class="string">&quot;1024,0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p /var/run/openvswitch</span><br><span class="line"><span class="built_in">mkdir</span> -p /etc/openvswitch</span><br><span class="line"><span class="built_in">mkdir</span> -p /var/log/openvswitch</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ! <span class="built_in">test</span> -f /etc/openvswitch/conf.db; <span class="keyword">then</span></span><br><span class="line">./ovsdb-tool create /etc/openvswitch/conf.db /mnt/store/ovs/images/db/vswitch.ovsschema</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">./ovsdb-server /etc/openvswitch/conf.db -vconsole:emer -vsyslog:err -vfile:info --remote=punix:/var/run/openvswitch/db.sock --private-key=db:Open_vSwitch,SSL,private_key --certificate=db:Open_vSwitch,SSL,certificate --bootstrap-ca-cert=db:Open_vSwitch,SSL,ca_cert --no-chdir --log-file=/var/log/openvswitch/ovsdb-server.log --pidfile=/var/run/openvswitch/ovsdb-server.pid --detach --monitor</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [ ! -S /var/run/openvswitch/db.sock ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">sleep</span> 1</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">./ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-init=<span class="literal">true</span></span><br><span class="line">./ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-extra=<span class="string">&quot;--iova-mode=pa&quot;</span></span><br><span class="line">./ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-socket-mem=<span class="variable">$dpdk_socket_mem</span></span><br><span class="line"></span><br><span class="line">./ovs-vswitchd unix:/var/run/openvswitch/db.sock -vconsole:emer -vsyslog:err -vfile:info --mlockall --no-chdir --log-file=/var/log/openvswitch/ovs-vswitchd.log --pidfile=/var/run/openvswitch/ovs-vswitchd.pid --detach --monitor</span><br></pre></td></tr></table></figure><h2 id="ovs停止运行"><a href="#ovs停止运行" class="headerlink" title="ovs停止运行"></a>ovs停止运行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ovs-appctl -t ovs-vswitchd <span class="built_in">exit</span></span><br><span class="line">ovs-appctl -t ovsdb-server <span class="built_in">exit</span></span><br></pre></td></tr></table></figure><h2 id="ovs创建port"><a href="#ovs创建port" class="headerlink" title="ovs创建port"></a>ovs创建port</h2><ul><li>创建网桥</li><li>物理端口绑定网桥</li><li>前后端通信端口绑定网桥</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">/mnt/store/ovs/images/bin/ovs-vsctl --may-exist add-br br0 -- <span class="built_in">set</span> bridge br0 datapath_type=netdev</span><br><span class="line"></span><br><span class="line"><span class="comment"># dpdk-devargs后面跟的是dpdk绑定网卡的pci bdf号</span></span><br><span class="line">/mnt/store/ovs/images/bin/ovs-vsctl --may-exist add-port br0 phy0 -- <span class="built_in">set</span> Interface phy0 <span class="built_in">type</span>=dpdk options:dpdk-devargs=0000:24:00.1</span><br><span class="line"></span><br><span class="line">/mnt/store/ovs/images/bin/ovs-vsctl --may-exist add-port br0 vhost-user-1 -- <span class="built_in">set</span> Interface vhost-user-1 <span class="built_in">type</span>=dpdkvhostuserclient options:vhost-server-path=<span class="string">&quot;/tmp/sock0&quot;</span></span><br></pre></td></tr></table></figure><ul><li>ovs-vsctl show查看运行结果</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /mnt/store/ovs/images/bin/ovs-vsctl show</span></span><br><span class="line">90ce12f9-3e63-4fff-b615-ae7e864858db</span><br><span class="line">    Bridge br0</span><br><span class="line">        datapath_type: netdev</span><br><span class="line">        Port br0</span><br><span class="line">            Interface br0</span><br><span class="line">                <span class="built_in">type</span>: internal</span><br><span class="line">        Port vhost-user-1</span><br><span class="line">            Interface vhost-user-1</span><br><span class="line">                <span class="built_in">type</span>: dpdkvhostuserclient</span><br><span class="line">                options: &#123;vhost-server-path=<span class="string">&quot;/tmp/sock0&quot;</span>&#125;</span><br><span class="line">        Port phy0</span><br><span class="line">            Interface phy0</span><br><span class="line">                <span class="built_in">type</span>: dpdk</span><br><span class="line">                options: &#123;dpdk-devargs=<span class="string">&quot;0000:24:00.1&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="qemu启动"><a href="#qemu启动" class="headerlink" title="qemu启动"></a>qemu启动</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">ulimit</span> -l unlimited</span><br><span class="line">/root/pc-bios/qemu-system-x86_64  \</span><br><span class="line">-enable-kvm -m 2048 -cpu host \</span><br><span class="line">-hda /mnt/store/vm0-centos8.4-8g-ext4-host-dmar.img \</span><br><span class="line">-object memory-backend-file,<span class="built_in">id</span>=mem,size=2048M,mem-path=/dev/hugepages,share=on \</span><br><span class="line">-mem-prealloc \</span><br><span class="line">-numa node,memdev=mem \</span><br><span class="line">-chardev socket,<span class="built_in">id</span>=char0,path=/tmp/sock0,server=on \</span><br><span class="line">-netdev <span class="built_in">type</span>=vhost-user,<span class="built_in">id</span>=vdpa,chardev=char0,queues=4 \</span><br><span class="line">-device virtio-net-pci,mq=on,rx_queue_size=512,tx_queue_size=512,netdev=vdpa,mac=00:aa:bb:cc:<span class="built_in">dd</span>:ee,page-per-vq=on,disable-modern=on,disable-legacy=off \</span><br><span class="line">-serial telnet:127.1:4321,server,nowait \</span><br><span class="line">-monitor stdio \</span><br><span class="line">-D ./qemu-vm0.<span class="built_in">log</span> \</span><br><span class="line">-vnc :90 -L /root/pc-bios</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ping包测试"><a href="#ping包测试" class="headerlink" title="ping包测试"></a>ping包测试</h2><p>host上网桥配置ip，端口up</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig br0 192.188.1.3/24 up</span><br></pre></td></tr></table></figure><p>geust上net口配置同网段ip，端口up</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig ens3 192.188.1.2/24 up</span><br></pre></td></tr></table></figure><p>vm ping host<br><img src="212553173cc3f955da5935e31ed69460df0ad4632296146b4ae845f52fe8edde.png" alt="图 1">  </p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;先决条件&quot;&gt;&lt;a href=&quot;#先决条件&quot; class=&quot;headerlink&quot; title=&quot;先决条件&quot;&gt;&lt;/a&gt;先决条件&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;DPDK 22.11.1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A DPDK supported NIC&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Only required when physical ports are in use&lt;/p&gt;</summary>
    
    
    
    <category term="虚拟化" scheme="https://rma-shuyu.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="DPDK" scheme="https://rma-shuyu.github.io/tags/DPDK/"/>
    
    <category term="OVS" scheme="https://rma-shuyu.github.io/tags/OVS/"/>
    
    <category term="QEMU" scheme="https://rma-shuyu.github.io/tags/QEMU/"/>
    
  </entry>
  
  <entry>
    <title>VSCode使用CodeGPT</title>
    <link href="https://rma-shuyu.github.io/2023/02/10/VSCode%E4%BD%BF%E7%94%A8CodeGPT/"/>
    <id>https://rma-shuyu.github.io/2023/02/10/VSCode%E4%BD%BF%E7%94%A8CodeGPT/</id>
    <published>2023-02-10T12:48:58.000Z</published>
    <updated>2023-07-01T09:37:27.342Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>CodeGPT</code>允许我们通过官方<code>OpenAI API</code>在<code>VSCode</code>中使用<code>GPT-3</code>，使得我们可以在代码编辑器拥有了<code>ChatGPT</code>。<br>借助 <code>CodeGPT</code>，我们可以生成代码、解释代码、重构代码等等。</p><span id="more"></span><h2 id="安装和设置"><a href="#安装和设置" class="headerlink" title="安装和设置"></a>安装和设置</h2><p>打开VSCode编辑器，点击扩展，然后在搜索框中输入“Code GPT”，然后点击“安装”。<br><img src="11a74d39367434d81ee6d91b62f82591270e1597d59b0237479cd9ed18ad5c4f.png" alt="图 5">  </p><p>Code GPT安装完，进到“Settings”界面，然后找到扩展下的“Code GPT”<br>CodeGPT的设置界面如下：<br><img src="79e7618f461b768065b9fea7f62b8f19727bc3c644aa6a05a332f304007086c6.png" alt="图 4">  </p><p><img src="a551258121c4603e9a22a950ebcac95490ec3ed3132b6b65998478d96b0069e0.png" alt="图 6">  </p><p>想要让CodeGPT运行起来，需要在上图的输入框处输入<a href="https://platform.openai.com/account/api-keys">OpenAI API key</a>，API key需要到OpenAI的官网生成。<br><img src="1ec8c9b392d9b9c48adef2505b45788e26fae2b55c8e30fbd6db20885f54e342.png" alt="图 7">  </p><p><strong>使用注意</strong><br>在WSL中无法使用CodeGPT，需要在Windows端使用</p><h2 id="解释代码"><a href="#解释代码" class="headerlink" title="解释代码"></a>解释代码</h2><p>选中代码，右键点击<code>Explain CodeGPT</code><br><img src="a1f348872a247c684d3eb2ee93a9801cc1a7e5094b5b4696a572c5759883d1f5.png" alt="图 1">  </p><h2 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h2><p>在对应后缀的代码文件中描述注释，并将光标点击到文末，快捷键ctrl+shift+i<br><img src="7fef95c4a63f509a4d1ce45159b1e1a344f6ce8c991344b63d674e52fd9c108f.png" alt="图 3">  </p><h2 id="重构代码"><a href="#重构代码" class="headerlink" title="重构代码"></a>重构代码</h2><p>选中代码，右键点击<code>Refactor CodeGPT</code><br><img src="95d51eff9bcb3c7c2c3d03bc3b67ba6cb3e8f1da454757e2d083fae5c0f4c7b2.png" alt="图 2">  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重构后的代码</span></span><br><span class="line">wait_for_process() &#123;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">参数说明</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="variable">$1</span>: 进程名</span></span><br><span class="line">  </span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">输入验证</span></span><br><span class="line">  if [ $# -ne 1 ]; then</span><br><span class="line">    echo &quot;Parameters incorrect&quot;</span><br><span class="line">    exit 1</span><br><span class="line">  fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">设置超时时间</span></span><br><span class="line">  WAIT_TIMEOUT=10</span><br><span class="line"></span><br><span class="line">  for i in $(seq 1 $WAIT_TIMEOUT); do</span><br><span class="line">    # 检索进程ID</span><br><span class="line">    proc_pid=$(pidof $1)</span><br><span class="line"></span><br><span class="line">    if [ &quot;$proc_pid&quot; != &quot;&quot; ]</span><br><span class="line">    then</span><br><span class="line">      # 进程已启动，返回</span><br><span class="line">      echo &quot;$1 started&quot;</span><br><span class="line">      return</span><br><span class="line">    fi</span><br><span class="line">    </span><br><span class="line">    echo &quot;Waiting for $1 to start&quot;</span><br><span class="line">    sleep 1</span><br><span class="line">  done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">超时</span></span><br><span class="line">  echo &quot;Timeout waiting for $1 to start&quot;</span><br><span class="line">  exit 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;code&gt;CodeGPT&lt;/code&gt;允许我们通过官方&lt;code&gt;OpenAI API&lt;/code&gt;在&lt;code&gt;VSCode&lt;/code&gt;中使用&lt;code&gt;GPT-3&lt;/code&gt;，使得我们可以在代码编辑器拥有了&lt;code&gt;ChatGPT&lt;/code&gt;。&lt;br&gt;借助 &lt;code&gt;CodeGPT&lt;/code&gt;，我们可以生成代码、解释代码、重构代码等等。&lt;/p&gt;</summary>
    
    
    
    <category term="VSCODE" scheme="https://rma-shuyu.github.io/categories/VSCODE/"/>
    
    
    <category term="CodeGPT" scheme="https://rma-shuyu.github.io/tags/CodeGPT/"/>
    
  </entry>
  
  <entry>
    <title>gitstats使用介绍</title>
    <link href="https://rma-shuyu.github.io/2022/12/05/gitstats%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/"/>
    <id>https://rma-shuyu.github.io/2022/12/05/gitstats%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/</id>
    <published>2022-12-05T11:51:50.000Z</published>
    <updated>2023-01-27T12:06:26.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>进一步来讲，Gitstats它是一个git仓库分析软件，它可以检查仓库并生成历史数据的统计信息。可以帮助你查看git仓库的提交状态，根据不同维度分析计算，并自动生成数据图表。<br>官网介绍：<a href="http://gitstats.sourceforge.net/">http://gitstats.sourceforge.net/</a></p><span id="more"></span><p>当前GitStats所生成统计信息常用分为如下几类：<br><strong>常规的统计</strong>：文件总数，行数，提交量，作者数。<br><strong>活跃性</strong>：每天中每小时的、每周中每天的、每周中每小时的、每年中每月的、每年的提交量。<br><strong>作者数</strong>：列举所有的作者（提交数，第一次提交日期，最近一次的提交日期），并按月和年来划分。<br><strong>文件数</strong>：按日期划分，按扩展名名划分。<br><strong>行数</strong>：按日期划分。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//mac osx</span><br><span class="line">brew install gnuplot</span><br><span class="line">//centos linux</span><br><span class="line">yum install gnuplot</span><br><span class="line">//ubuntu linux</span><br><span class="line">apt install gnuplot</span><br></pre></td></tr></table></figure><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://github.com/hoxu/gitstats.git</span><br><span class="line"><span class="built_in">cd</span> gitstats</span><br><span class="line">./gitstats 你的项目的位置 生成统计的文件夹位置</span><br></pre></td></tr></table></figure><h2 id="展示"><a href="#展示" class="headerlink" title="展示"></a>展示</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> 生成统计的文件夹位置</span><br><span class="line">python3 -m http.server 8090</span><br></pre></td></tr></table></figure><h2 id="qemu示例"><a href="#qemu示例" class="headerlink" title="qemu示例"></a>qemu示例</h2><p>如下图所示。首先，在gitstats上提供了全局的统计数据报告，包括：</p><p><strong>报告产生时间及产生所花费的时间</strong>：如花费了710秒<br><strong>报告所覆盖的时间</strong>：如2003-02-19 to 2022-12-05<br><strong>年龄</strong>：该repo的年纪，如“7230天，其中5918天是活跃天.”<br><strong>文件数及代码</strong>：如：9256个文件，3130k行代码。<br><strong>总提交数</strong>：如：99776，平均每天13.8个<br><strong>作者数</strong>：如2160，每个作者平均提交次数46.2次。<br><img src="efbe731981191bf53d5ddccfb0d2ceddc68787753068302bb6b07ae3325161c7.png" alt="图 6">  </p><p>除此之外，还包括了：</p><ol><li>时间维度的效率分析：每天中每小时的、每周中每天的、每周中每小时的、每年中每月的、每年的提交量。<br><img src="e3f27ccfddf1d938e78059ed84dbee1e10029e531785d1c35dbd64ec9fd176e4.png" alt="图 7"><br><img src="c2af9654b130fbe357f60fc7d9b0d9f688909b0fd41cc173ed06bc9609bb03db.png" alt="图 8"><br><img src="fe0f04ea5472dac1bb45ef27504cf61e91c71154babe868b1d90ae164ffa901c.png" alt="图 9"><br><img src="d8a4aee3fe667a3fe39257feb14b177fc098d0952bfb78cf7a3139ac838adb95.png" alt="图 10"><br><img src="b04a8580c65f01373f091389a9c3a7d3138acb8aaf002e9a21a5ae8b8587acf5.png" alt="图 11"><br><img src="226d67aed51a110fa818c54b82b4e74434e727c354565bcf779b19f6ba31dd55.png" alt="图 12">  </li></ol><ol start="2"><li>提交者维度的活跃度统计：列举所有的作者（提交数，第一次提交日期，最近一次的提交日期），并按月和年来划分。<br><img src="1245268c1062710ee022fb12149e82705b29e4591c0e3aacb7fd844462b8bdaf.png" alt="图 13">  </li></ol><ol start="3"><li><p>按照文件数：按日期划分，按扩展名名划分。<br><img src="1bacc00060ca63e9f239802a91e68849e4337457d9909e0754eee5fc1664a4ee.png" alt="图 14">  </p></li><li><p>根据提交行数或提交的tag来统计。<br><img src="29853f0496e7b26c4d69af48e2d863367a2c96ee70534f89698a31e3f49b03a4.png" alt="图 15">  </p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;进一步来讲，Gitstats它是一个git仓库分析软件，它可以检查仓库并生成历史数据的统计信息。可以帮助你查看git仓库的提交状态，根据不同维度分析计算，并自动生成数据图表。&lt;br&gt;官网介绍：&lt;a href=&quot;http://gitstats.sourceforge.net/&quot;&gt;http://gitstats.sourceforge.net/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="GIT" scheme="https://rma-shuyu.github.io/categories/GIT/"/>
    
    
    <category term="git" scheme="https://rma-shuyu.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>centos8安装pprof</title>
    <link href="https://rma-shuyu.github.io/2022/11/22/centos8%E5%AE%89%E8%A3%85pprof/"/>
    <id>https://rma-shuyu.github.io/2022/11/22/centos8%E5%AE%89%E8%A3%85pprof/</id>
    <published>2022-11-22T12:24:34.000Z</published>
    <updated>2023-01-27T12:06:26.873Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这是谷歌的一个linux下性能测试的小工具。可以简单快速的发现程序的性能瓶颈。</p><span id="more"></span><h2 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /etc/*release</span></span><br><span class="line">CentOS Linux release 8.4.2105</span><br><span class="line">NAME=<span class="string">&quot;CentOS Linux&quot;</span></span><br><span class="line">VERSION=<span class="string">&quot;8&quot;</span></span><br><span class="line">ID=<span class="string">&quot;centos&quot;</span></span><br><span class="line">ID_LIKE=<span class="string">&quot;rhel fedora&quot;</span></span><br><span class="line">VERSION_ID=<span class="string">&quot;8&quot;</span></span><br><span class="line">PLATFORM_ID=<span class="string">&quot;platform:el8&quot;</span></span><br><span class="line">PRETTY_NAME=<span class="string">&quot;CentOS Linux 8&quot;</span></span><br><span class="line">ANSI_COLOR=<span class="string">&quot;0;31&quot;</span></span><br><span class="line">CPE_NAME=<span class="string">&quot;cpe:/o:centos:centos:8&quot;</span></span><br><span class="line">HOME_URL=<span class="string">&quot;https://centos.org/&quot;</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">&quot;https://bugs.centos.org/&quot;</span></span><br><span class="line">CENTOS_MANTISBT_PROJECT=<span class="string">&quot;CentOS-8&quot;</span></span><br><span class="line">CENTOS_MANTISBT_PROJECT_VERSION=<span class="string">&quot;8&quot;</span></span><br><span class="line">CentOS Linux release 8.4.2105</span><br><span class="line">CentOS Linux release 8.4.2105</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="安装编译工具"><a href="#安装编译工具" class="headerlink" title="安装编译工具"></a>安装编译工具</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc</span><br><span class="line">yum -y install gcc-c++</span><br><span class="line">yum -y install make</span><br><span class="line">yum install -y autoconf automake libtool</span><br><span class="line">yum install -y wget</span><br></pre></td></tr></table></figure><p><strong>提示</strong>：<br>安装过程中出现以下错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum -y install gcc</span></span><br><span class="line">Last metadata expiration check: 0:15:41 ago on Wed 23 Nov 2022 03:56:44 PM CST.</span><br><span class="line">Error: </span><br><span class="line"> Problem: package gcc-8.5.0-4.el8_5.x86_64 requires glibc-devel &gt;= 2.2.90-12, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libpthread.so.0, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libdl.so.2, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libm.so.6, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libresolv.so.2, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires librt.so.1, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libutil.so.1, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libBrokenLocale.so.1, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libanl.so.1, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libthread_db.so.1, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.x86_64 requires glibc = 2.28-164.el8, but none of the providers can be installed</span><br><span class="line">  - glibc-2.28-164.el8.i686 has inferior architecture</span><br><span class="line">  - cannot install both glibc-2.28-164.el8.x86_64 and glibc-2.28-203.el8.x86_64</span><br><span class="line">  - package glibc-gconv-extra-2.28-203.el8.x86_64 requires glibc(x86-64) = 2.28-203.el8, but none of the providers can be installed</span><br><span class="line">  - cannot install the best candidate <span class="keyword">for</span> the job</span><br><span class="line">  - problem with installed package glibc-gconv-extra-2.28-203.el8.x86_64</span><br><span class="line">(try to add <span class="string">&#x27;--allowerasing&#x27;</span> to <span class="built_in">command</span> line to replace conflicting packages or <span class="string">&#x27;--skip-broken&#x27;</span> to skip uninstallable packages or <span class="string">&#x27;--nobest&#x27;</span> to use not only best candidate packages)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>则执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc --allowerasing</span><br></pre></td></tr></table></figure><p>可执行文件对应的安装包查找：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum whatprovides autoreconf</span><br></pre></td></tr></table></figure><p><img src="c5dd6168b78ccf54aa38d65134cb70a21c2adb250934fcf9c448d9d29d12851c.png" alt="图 26"><br>则安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y autoconf</span><br></pre></td></tr></table></figure><h2 id="安装libunwind"><a href="#安装libunwind" class="headerlink" title="安装libunwind"></a>安装libunwind</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/libunwind/libunwind/archive/v0.99.tar.gz</span><br><span class="line">tar -xvf v0.99.tar.gz</span><br><span class="line"><span class="built_in">cd</span> libunwind-0.99</span><br><span class="line">autoreconf --force -v --install</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h2 id="安装perftools"><a href="#安装perftools" class="headerlink" title="安装perftools"></a>安装perftools</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/gperftools/gperftools/releases/download/gperftools-2.6.1/gperftools-2.6.1.tar.gz</span><br><span class="line">tar -xvf gperftools-2.6.1.tar.gz </span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h2 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h2><p><img src="e25c28feccf7bac3e0f524dec94e4a1f7f2d5db678b0fd3366351056d111b03a.png" alt="图 27">  </p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;这是谷歌的一个linux下性能测试的小工具。可以简单快速的发现程序的性能瓶颈。&lt;/p&gt;</summary>
    
    
    
    <category term="LINUX" scheme="https://rma-shuyu.github.io/categories/LINUX/"/>
    
    
    <category term="linux" scheme="https://rma-shuyu.github.io/tags/linux/"/>
    
    <category term="pprof" scheme="https://rma-shuyu.github.io/tags/pprof/"/>
    
  </entry>
  
  <entry>
    <title>base64编解码</title>
    <link href="https://rma-shuyu.github.io/2022/11/16/base64%E7%BC%96%E8%A7%A3%E7%A0%81/"/>
    <id>https://rma-shuyu.github.io/2022/11/16/base64%E7%BC%96%E8%A7%A3%E7%A0%81/</id>
    <published>2022-11-16T12:16:29.000Z</published>
    <updated>2023-01-27T12:06:26.868Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，是一种基于<strong>64个可打印字符</strong>来表示二进制数据的方法</p><span id="more"></span><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ol><li>Base64一般用于在 HTTP协议下传输二进制数据，由于 HTTP协议是文本协议，所以在HTTP协议下传输二进制数据需要将二进制数据转换为字符数据。然而直接转换是不行的。因为网络传输只能传输可打印字符，需要用Base64将不可显字符转换为可显字符</li><li>可用于将明文通过AES加密后，通过Base64将不可显的加密字符转换为可显字符</li></ol><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>base64编码表<br><img src="c617678b70d6a249a3556d4a16a4d49fbd9dc22f4be59bda0d0e52450c20be76.png" alt="图 2"> </p><p>由于base64编码是将编码前的3*8位数据，分解成4个6位的数据，所以经过base64编码后的字符串长度是4的倍数。<br>但往往我们进行编码的数据长度并不是3的倍数，这就造成了“编码”后的位数不为4的倍数，</p><p>比如Brisk共5×8=40位，以6位为一组可以分为7组，这样“编码”后就有7个字符，<br>但base64编码后的字符长度应该是4的倍数，显然这里就出问题了，那么怎么办呢？<br>前面的不可以抛弃掉，所以就只有“追加”了，所以Brisk经过base64编码后的长度应该是8个字符，而第8个编码后的字符是’=’，</p><p>再比如对单个字符a进行base64编码，由于它的长度不是3的倍数，以3个字节为一组它只能分一组，再以6位为一位它只能分两组，所以经过“编码”后它的长度是2，但base64编码后的个数应该是4的倍数，所以它的长度应该是4，所以在后面补上两个‘=’,</p><p>由于一个数求余3后有三个不同的结果，0、1、2，所以在对一个数据进行base64进行编码后它的长度为： </p><ol><li><p>当进行编码的数据长度是3的倍数时，len=strlen(str_in)/3*4;</p></li><li><p>当进行编码的数据长度不是3的倍数时，len=(strlen(str_in)/3+1)*4;</p></li></ol><p>我们以Brisk这个例子来说明一下base64编码的过程。首先我们以3个字符为一组将Brisk进行分组，Brisk被氛围两组：Bri 和 sk；然后我们取出这两个分组中每个字节的ASCII码，B:66 r:114 i:105 s:115 k:107。它们对应的二进制数为  B:01000010 r:01110010 i:01101001 s:01110011 k:01101011；</p><p>第一组，我们以6位为一组对每一个3字节分组进行再分组就变成了010000 100111 001001 101001。所对应的十进制数是16 39 9 41，对应base64表中的结果是 Q n J p；</p><p>第二组，011100 110110 101100(不够补0)，所以对应的十进制数是 28 54 44，对应base64表中的结果是 c 2 s，最终结果为QnJpc2s=（因为第二组“编码”后只有三个字节）。</p><p>解码的过程是一个逆过程，我们将经过编码后的字符按4个字符为一组，然后对照base64表得到相应的十进制数，再将其通过拆分和组合，组成3个8位数据，这个数据就是解码后的数据，下面给一个c语言实现编码和解码的代码。</p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">encode_string</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> * src, <span class="type">int</span> len,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">char</span> * dest, <span class="type">unsigned</span> <span class="type">char</span> * base64, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> one;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> two;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> thr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> fou;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ( len &gt;= <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        one = src[<span class="number">0</span>] &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        two = ( ( src[<span class="number">0</span>] &amp; <span class="number">0x03</span> ) &lt;&lt; <span class="number">4</span> ) | ( src[<span class="number">1</span>] &gt;&gt; <span class="number">4</span> );</span><br><span class="line">        thr = ( ( src[<span class="number">1</span>] &amp; <span class="number">0x0F</span> ) &lt;&lt; <span class="number">2</span> ) | ( src[<span class="number">2</span>] &gt;&gt; <span class="number">6</span> );</span><br><span class="line">        fou = src[<span class="number">2</span>] &amp; <span class="number">0x3F</span>;</span><br><span class="line"> </span><br><span class="line">        *( dest + index++ ) = base64[one];</span><br><span class="line">        *( dest + index++ ) = base64[two];</span><br><span class="line">        *( dest + index++ ) = base64[thr];</span><br><span class="line">        *( dest + index   ) = base64[fou];</span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( len == <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        one = src[<span class="number">0</span>] &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        two = ( ( src[<span class="number">0</span>] &amp; <span class="number">0x03</span>) &lt;&lt; <span class="number">4</span> ) | ( src[<span class="number">1</span>] &gt;&gt; <span class="number">4</span> );</span><br><span class="line">        thr = ( src[<span class="number">1</span>] &amp; <span class="number">0x0F</span> ) &lt;&lt; <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">        *( dest + index++ ) = base64[one];</span><br><span class="line">        *( dest + index++ ) = base64[two];</span><br><span class="line">        *( dest + index++ ) = base64[thr];</span><br><span class="line">        *( dest + index   ) = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( len == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        one = src[<span class="number">0</span>] &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        two = ( src[<span class="number">0</span>] &amp; <span class="number">0x03</span> ) &lt;&lt; <span class="number">4</span>;</span><br><span class="line"> </span><br><span class="line">        *( dest + index++ ) = base64[one];</span><br><span class="line">        *( dest + index++ ) = base64[two];</span><br><span class="line">        *( dest + index++ ) = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">        *( dest + index   ) = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;Unknow length\n&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">base64_encode</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> * src, <span class="type">int</span> src_len, <span class="type">char</span> * dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> base64[] = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( src_len &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> step = encode_string( src, src_len, (<span class="type">unsigned</span> <span class="type">char</span> *)dest, base64, index );</span><br><span class="line"> </span><br><span class="line">        index += <span class="number">4</span>;</span><br><span class="line">        src += step;</span><br><span class="line">src_len -= step;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    *( dest + index ) = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">create_array</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> * <span class="built_in">array</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( index  = <span class="number">0</span>; index &lt; <span class="number">123</span>; index += <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( index == <span class="number">0x2B</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            *( <span class="built_in">array</span> + index ) = <span class="number">0x3E</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( index == <span class="number">0x2F</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            *( <span class="built_in">array</span> + index ) = <span class="number">0x3F</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( index &gt;= <span class="number">0x30</span> &amp;&amp; index &lt;= <span class="number">0x39</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            *( <span class="built_in">array</span> + index ) = <span class="number">0x34</span> + index - <span class="number">0x30</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( index == <span class="number">0x3D</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            *( <span class="built_in">array</span> + index ) = <span class="number">0x00</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( index &gt;= <span class="number">0x41</span> &amp;&amp; index &lt;= <span class="number">0x5A</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            *( <span class="built_in">array</span> + index ) = index - <span class="number">0x41</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( index &gt;= <span class="number">0x61</span> &amp;&amp; index &lt;= <span class="number">0x7A</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            *( <span class="built_in">array</span> + index ) = <span class="number">0x1A</span> + index - <span class="number">0x61</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            *( <span class="built_in">array</span> + index ) = <span class="number">0x00</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    *( <span class="built_in">array</span> + <span class="number">123</span> ) = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">decode_string</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * src, <span class="type">unsigned</span> <span class="type">char</span> * dest, <span class="type">unsigned</span> <span class="type">char</span> * <span class="built_in">array</span>, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> step;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> one;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> two;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> thr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( src[<span class="number">3</span>] == <span class="string">&#x27;=&#x27;</span> &amp;&amp; src[<span class="number">2</span>] == <span class="string">&#x27;=&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        one = ( <span class="built_in">array</span>[src[<span class="number">0</span>]] &lt;&lt; <span class="number">2</span> ) | ( <span class="built_in">array</span>[src[<span class="number">1</span>]] &gt;&gt; <span class="number">4</span> );</span><br><span class="line">        *( dest + index ) = one;</span><br><span class="line"> </span><br><span class="line">        step = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( src[<span class="number">3</span>] == <span class="string">&#x27;=&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        one = ( <span class="built_in">array</span>[src[<span class="number">0</span>]] &lt;&lt; <span class="number">2</span> ) | ( <span class="built_in">array</span>[src[<span class="number">1</span>]] &gt;&gt; <span class="number">4</span> );</span><br><span class="line">        two = ( ( <span class="built_in">array</span>[src[<span class="number">1</span>]] &amp; <span class="number">0x0F</span> ) &lt;&lt; <span class="number">4</span> ) | ( <span class="built_in">array</span>[src[<span class="number">2</span>]] &gt;&gt; <span class="number">2</span> );</span><br><span class="line"> </span><br><span class="line">        *( dest + index++ ) = one;</span><br><span class="line">        *( dest + index   ) = two;</span><br><span class="line"> </span><br><span class="line">        step = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        one = ( <span class="built_in">array</span>[src[<span class="number">0</span>]] &lt;&lt; <span class="number">2</span> ) | ( <span class="built_in">array</span>[src[<span class="number">1</span>]] &gt;&gt; <span class="number">4</span> );</span><br><span class="line">        two = ( ( <span class="built_in">array</span>[src[<span class="number">1</span>]] &amp; <span class="number">0x0F</span> ) &lt;&lt; <span class="number">4</span> ) | ( <span class="built_in">array</span>[src[<span class="number">2</span>]] &gt;&gt; <span class="number">2</span> );</span><br><span class="line">        thr = ( <span class="built_in">array</span>[src[<span class="number">2</span>]] &lt;&lt; <span class="number">6</span> ) | <span class="built_in">array</span>[src[<span class="number">3</span>]];</span><br><span class="line"> </span><br><span class="line">        *( dest + index++ ) = one;</span><br><span class="line">        *( dest + index++ ) = two;</span><br><span class="line">        *( dest + index   ) = thr;</span><br><span class="line"> </span><br><span class="line">        step = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">base64_decode</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * src, <span class="type">unsigned</span> <span class="type">char</span> * dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> <span class="built_in">array</span>[<span class="number">124</span>];</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>( <span class="built_in">array</span>, <span class="number">0x00</span>, <span class="number">124</span> );</span><br><span class="line">    create_array( <span class="built_in">array</span> );</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> ( *src )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> step = decode_string( src, dest, <span class="built_in">array</span>, index );</span><br><span class="line"> </span><br><span class="line">        index += step;</span><br><span class="line">        src   += <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    *( dest + index ) = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>测试代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> *src_str = <span class="string">&quot;abcsjdhs123134&quot;</span>;</span><br><span class="line"><span class="type">int</span> src_str_len = <span class="built_in">strlen</span>(src_str);</span><br><span class="line"><span class="type">char</span> *out_buf = (<span class="type">char</span> *)<span class="built_in">malloc</span>(src_str_len * <span class="number">2</span>);</span><br><span class="line"><span class="type">char</span> *out_decode_buf = (<span class="type">char</span> *)<span class="built_in">malloc</span>(src_str_len * <span class="number">2</span>);</span><br><span class="line">base64_encode(src_str, src_str_len, out_buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;src_str:       %s\n&quot;</span>, src_str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;base64_encode: %s\n&quot;</span>, out_buf);</span><br><span class="line"></span><br><span class="line">base64_decode(out_buf, out_decode_buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;base64_decode: %s\n&quot;</span>, out_decode_buf);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果展示<br><img src="8106a76ff5b18e8cda5e478736125efeec53fcaf86e1744cf4fe4accaaf6a38b.png" alt="图 3">  </p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，是一种基于&lt;strong&gt;64个可打印字符&lt;/strong&gt;来表示二进制数据的方法&lt;/p&gt;</summary>
    
    
    
    <category term="BASE64" scheme="https://rma-shuyu.github.io/categories/BASE64/"/>
    
    
    <category term="BASE64" scheme="https://rma-shuyu.github.io/tags/BASE64/"/>
    
  </entry>
  
  <entry>
    <title>OpenSSL之AES用法</title>
    <link href="https://rma-shuyu.github.io/2022/11/16/OpenSSL%E4%B9%8BAES%E7%94%A8%E6%B3%95/"/>
    <id>https://rma-shuyu.github.io/2022/11/16/OpenSSL%E4%B9%8BAES%E7%94%A8%E6%B3%95/</id>
    <published>2022-11-16T11:20:44.000Z</published>
    <updated>2023-01-27T12:06:26.847Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>AES是<strong>对称</strong>加密的算法，使用128、192 和 256 位密钥，将被加密数据划分为128位（16字节）一块，然后使用某种加密模式进行加密</p><p>关键词：<br><strong>块大小</strong>：16字节<br><strong>密钥长度</strong>：AES算法下，key的长度有三种：128、192和256 bits。</p><span id="more"></span><p><strong>加密模式</strong>：AES属于块加密（Block Cipher），块加密中有CBC、ECB、CTR、OFB、CFB等几种工作模式。<br><strong>填充模式</strong>：</p><ul><li>NoPadding，数据长度不对齐时使用”\0”填充，否则不填充</li><li>PKCS7Padding，假设数据长度需要填充n(n&gt;0)个字节才对齐，那么填充n个字节，每个字节都是n;如果数据本身就已经对齐了，则填充一块长度为块大小的数据，每个字节都是块大小</li><li>PKCS5Padding，PKCS7Padding的子集，块大小固定为8字节。</li></ul><p>AES加密，如果输入是16<em>n字节，NoPadding填充的情况下，输出和输入相同；有填充的情况下，输出是16</em>（n+1）。<br>如果输入不是16字节整数倍，而是大于16<em>n小于16</em>（n+1），NoPadding填充情况下（只能是CFB和OFB模式），输出和输入长度相同；其他情况下，输出长度是16*（n+1）</p><h2 id="设置加解密接口"><a href="#设置加解密接口" class="headerlink" title="设置加解密接口"></a>设置加解密接口</h2><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><ul><li><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">AES_set_encrypt_key</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *userKey, <span class="type">const</span> <span class="type">int</span> bits,</span></span><br><span class="line"><span class="params">                        AES_KEY *key)</span>;</span><br></pre></td></tr></table></figure></li><li><p>函数作用<br>设定加密用的Key</p></li><li><p>参数说明<br><code>userKey</code>： 密钥数值；<br><code>bits</code>：密钥长度，以bit为单位，如果密钥数字是16个字节，则此参数值应为128；<br><code>key</code>： AES_KEY对象指针；<br><code>返回值</code>：<br>0: 成功<br>1: userkey，key为空<br>2: 密钥长度不是128，192，256</p></li></ul><h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><ul><li><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">AES_set_decrypt_key</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *userKey, <span class="type">const</span> <span class="type">int</span> bits,</span></span><br><span class="line"><span class="params">                        AES_KEY *key)</span>;</span><br></pre></td></tr></table></figure></li><li><p>函数作用<br>设定解密用的Key</p></li><li><p>参数说明<br><code>userKey</code>： 密钥数值；<br><code>bits</code>：密钥长度，以bit为单位，如果密钥数字是16个字节，则此参数值应为128；<br><code>key</code>： AES_KEY对象指针；<br><code>返回值</code>：<br>0: 成功<br>1: userkey，key为空<br>2: 密钥长度不是128，192，256</p></li></ul><h2 id="常用加密模式"><a href="#常用加密模式" class="headerlink" title="常用加密模式"></a>常用加密模式</h2><h3 id="CBC"><a href="#CBC" class="headerlink" title="CBC"></a>CBC</h3><ul><li><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AES_cbc_encrypt</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *in, <span class="type">unsigned</span> <span class="type">char</span> *out,</span></span><br><span class="line"><span class="params">                     <span class="type">size_t</span> length, <span class="type">const</span> AES_KEY *key,</span></span><br><span class="line"><span class="params">                     <span class="type">unsigned</span> <span class="type">char</span> *ivec, <span class="type">const</span> <span class="type">int</span> enc)</span>;</span><br></pre></td></tr></table></figure></li><li><p>函数作用：<br>AES加密/解密单个数据块（16个字节），CBC模式</p></li><li><p>参数说明：<br><code>in</code>： 需要加密/解密的数据；<br><code>out</code>： 计算后输出的数据；<br><code>length</code>： 数据长度（这里不包含初始向量数据长度）<br><code>key</code>：密钥<br><code>ivec</code>： 初始向量（一般为16字节全0）<br><code>enc</code>：<br>AES_ENCRYPT：代表加密<br>AES_DECRYPT：代表解密</p></li></ul><h3 id="ECB"><a href="#ECB" class="headerlink" title="ECB"></a>ECB</h3><ul><li><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AES_ecb_encrypt</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *in, <span class="type">unsigned</span> <span class="type">char</span> *out,</span></span><br><span class="line"><span class="params">                     <span class="type">const</span> AES_KEY *key, <span class="type">const</span> <span class="type">int</span> enc)</span>;</span><br></pre></td></tr></table></figure></li><li><p>函数作用：<br>AES加密/解密单个数据块（16个字节），ECB模式</p></li><li><p>参数说明：<br><code>in</code>: 需要加密/解密的数据；<br><code>out</code>: 计算后输出的数据；<br><code>key</code>: 密钥<br><code>enc</code>:<br>AES_ENCRYPT：代表加密<br>AES_DECRYPT：代表解密</p></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>测试代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TEST_ORG_DATA <span class="string">&quot;this is test aes data!&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">remove_padding</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buff, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">ch = buff[size - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; ch; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (buff[size - i] != buff[size - (i + <span class="number">1</span>)])</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buff[size - i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">str2hex</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *ret = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> str_len = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> sret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">ret = (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="built_in">malloc</span>(str_len / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; str_len; i += <span class="number">2</span>)</span><br><span class="line">sret = <span class="built_in">sscanf</span>(str + i, <span class="string">&quot;%2hhX&quot;</span>, &amp;ret[i/<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">if</span> (sret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">free</span>(ret);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">decode_aes128_ecb</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *encrypt_buff, <span class="type">int</span> buf_len, <span class="type">unsigned</span> <span class="type">char</span> **out)</span></span><br><span class="line">&#123;</span><br><span class="line">AES_KEY aes;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *decrypt_buff = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *key = str2hex(<span class="string">&quot;B1CFC3D787DC4511&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;aes, <span class="number">0</span>, <span class="keyword">sizeof</span>(aes));</span><br><span class="line">decrypt_buff = (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="built_in">malloc</span>((<span class="type">size_t</span>)buf_len);</span><br><span class="line"></span><br><span class="line">AES_set_decrypt_key(key, <span class="number">128</span>, &amp;aes);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; buf_len; i += AES_BLOCK_SIZE) &#123;</span><br><span class="line">AES_ecb_encrypt</span><br><span class="line">(encrypt_buff + i, decrypt_buff + i, &amp;aes, AES_DECRYPT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">remove_padding(decrypt_buff, buf_len);</span><br><span class="line"></span><br><span class="line">*out = decrypt_buff;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">encode_aes128_ecb</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> **out, <span class="type">int</span> *out_len)</span></span><br><span class="line">&#123;</span><br><span class="line">AES_KEY aes;</span><br><span class="line"><span class="type">int</span> data_len = <span class="built_in">strlen</span>(TEST_ORG_DATA);</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="type">json_error_t</span> error;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *encrypt_buff = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *decrypt_buff = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *key = str2hex(<span class="string">&quot;B1CFC3D787DC4511&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pad_len = AES_BLOCK_SIZE - (data_len % AES_BLOCK_SIZE);</span><br><span class="line">encrypt_buff = (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="built_in">malloc</span>(data_len + pad_len);</span><br><span class="line">decrypt_buff = (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="built_in">malloc</span>(data_len + pad_len);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(decrypt_buff, TEST_ORG_DATA, data_len);</span><br><span class="line"><span class="built_in">memset</span>(decrypt_buff+data_len, pad_len, pad_len);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;aes, <span class="number">0</span>, <span class="keyword">sizeof</span>(aes));</span><br><span class="line">AES_set_encrypt_key(key, <span class="number">128</span>, &amp;aes);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; data_len+pad_len; i += AES_BLOCK_SIZE) &#123;</span><br><span class="line">AES_ecb_encrypt</span><br><span class="line">(decrypt_buff + i, encrypt_buff + i, &amp;aes, AES_ENCRYPT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*out = encrypt_buff;</span><br><span class="line">*out_len = data_len+pad_len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;data before aes :\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, TEST_ORG_DATA);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *en_code = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> en_code_len;</span><br><span class="line">encode_aes128_ecb(&amp;en_code, &amp;en_code_len);</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *de_code = <span class="literal">NULL</span>;</span><br><span class="line">decode_aes128_ecb(en_code, en_code_len, &amp;de_code);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;data after aes encode and decode :\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, de_code);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试结果：<br><img src="4f8473f4df84e1e65d147bd49af24b1cf87b702462969287d002e093c7cfd2e1.png" alt="图 2">  </p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;AES是&lt;strong&gt;对称&lt;/strong&gt;加密的算法，使用128、192 和 256 位密钥，将被加密数据划分为128位（16字节）一块，然后使用某种加密模式进行加密&lt;/p&gt;
&lt;p&gt;关键词：&lt;br&gt;&lt;strong&gt;块大小&lt;/strong&gt;：16字节&lt;br&gt;&lt;strong&gt;密钥长度&lt;/strong&gt;：AES算法下，key的长度有三种：128、192和256 bits。&lt;/p&gt;</summary>
    
    
    
    <category term="OPENSSL" scheme="https://rma-shuyu.github.io/categories/OPENSSL/"/>
    
    
    <category term="AES" scheme="https://rma-shuyu.github.io/tags/AES/"/>
    
    <category term="OPENSSL" scheme="https://rma-shuyu.github.io/tags/OPENSSL/"/>
    
  </entry>
  
  <entry>
    <title>Clash配置allow lan</title>
    <link href="https://rma-shuyu.github.io/2022/07/07/Trojan%E9%85%8D%E7%BD%AEallow-lan/"/>
    <id>https://rma-shuyu.github.io/2022/07/07/Trojan%E9%85%8D%E7%BD%AEallow-lan/</id>
    <published>2022-07-07T11:55:44.000Z</published>
    <updated>2023-10-21T07:21:41.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Clash for Windows 是基于 <a href="https://github.com/Dreamacro/clash">Clash Core</a> 开发的 Windows 平台代理工具，支持 Shadowsocks(R) / V2Ray / Trojan / Socks5 / HTTP(S) 等代理协议，支持策略组及规则分流。</p><span id="more"></span><blockquote><p>下载地址： <a href="https://github.com/Fndroid/clash_for_windows_pkg/releases">Github Releases</a> </p><p>第一次使用？查看 <a href="https://docs.cfw.lbyczf.com/contents/quickstart.html">快速上手</a></p></blockquote><p>在配置好 Clash for Windows（下文略称为 CFW ）后，我们可以考虑开启 <code>Allow LAN</code> （局域网代理共享），以便处于同一局域网内的其他设备接入到本机代理环境中。这不仅可以节省在多台设备中重复部署代理软件的时间，同时也可以通过 CFW 内置的 Connections 对局域网内设备的网络情况实时地管理与监控。</p><p>具体方法如下：</p><h2 id="Clash-for-Windows-设置方法"><a href="#Clash-for-Windows-设置方法" class="headerlink" title="Clash for Windows 设置方法"></a>Clash for Windows 设置方法</h2><p>启动 CFW 后，在 General 设置中点击 General YAML 选项，将 Profile 中的 <code>allow-lan</code> 值设置为 <code>true</code> ，随后保存并关闭配置文件窗口。最终效果如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># HTTP 端口</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">7890</span></span><br><span class="line"><span class="comment"># Socks 5 端口</span></span><br><span class="line"><span class="attr">socks-port:</span> <span class="number">7891</span></span><br><span class="line"><span class="comment"># 局域网代理共享</span></span><br><span class="line"><span class="attr">allow-lan:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>此时，我们已经开启 CFW 的局域网代理共享，且可以在 General 设置中看到 Allow LAN 为启动状态。</p><p>将鼠标悬浮于 Allow LAN 选项上，可以显示此时 Windows 的内网 IP 地址。</p><p><img src="de169eeb984388932b8ac7e0974a26f80fe2795ddf4fa028bc965fd14984079f.png" alt="picture 0">  </p><p>这里需要关闭电脑端的防火墙</p><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p><strong>wsl配置proxy.sh</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">MY_PROXY_URL=&quot;http://172.19.96.1:7890&quot;</span><br><span class="line"> </span><br><span class="line">HTTP_PROXY=$MY_PROXY_URL</span><br><span class="line">HTTPS_PROXY=$MY_PROXY_URL</span><br><span class="line">FTP_PROXY=$MY_PROXY_URL</span><br><span class="line">http_proxy=$MY_PROXY_URL</span><br><span class="line">https_proxy=$MY_PROXY_URL</span><br><span class="line">ftp_proxy=$MY_PROXY_URL</span><br><span class="line"> </span><br><span class="line">export HTTP_PROXY HTTPS_PROXY FTP_PROXY http_proxy https_proxy ftp_proxy</span><br></pre></td></tr></table></figure><p>source一下proxy.sh即可开启端口代理</p><p><strong>wsl配置unproxy.sh</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line"> </span><br><span class="line">unset HTTP_PROXY HTTPS_PROXY FTP_PROXY http_proxy https_proxy ftp_proxy</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>source一下unproxy.sh即可关闭端口代理</p><p><strong>内网服务器配置proxy.sh</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">MY_PROXY_URL=&quot;http://10.20.19.191:7890&quot;</span><br><span class="line"> </span><br><span class="line">HTTP_PROXY=$MY_PROXY_URL</span><br><span class="line">HTTPS_PROXY=$MY_PROXY_URL</span><br><span class="line">FTP_PROXY=$MY_PROXY_URL</span><br><span class="line">http_proxy=$MY_PROXY_URL</span><br><span class="line">https_proxy=$MY_PROXY_URL</span><br><span class="line">ftp_proxy=$MY_PROXY_URL</span><br><span class="line"> </span><br><span class="line">export HTTP_PROXY HTTPS_PROXY FTP_PROXY http_proxy https_proxy ftp_proxy</span><br></pre></td></tr></table></figure><p>source一下proxy.sh即可开启端口代理</p><p><strong>内网服务器配置unproxy.sh</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line"> </span><br><span class="line">unset HTTP_PROXY HTTPS_PROXY FTP_PROXY http_proxy https_proxy ftp_proxy</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>source一下unproxy.sh即可关闭端口代理</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Clash for Windows 是基于 &lt;a href=&quot;https://github.com/Dreamacro/clash&quot;&gt;Clash Core&lt;/a&gt; 开发的 Windows 平台代理工具，支持 Shadowsocks(R) / V2Ray / Trojan / Socks5 / HTTP(S) 等代理协议，支持策略组及规则分流。&lt;/p&gt;</summary>
    
    
    
    <category term="Trojan" scheme="https://rma-shuyu.github.io/categories/Trojan/"/>
    
    
    <category term="Trojan" scheme="https://rma-shuyu.github.io/tags/Trojan/"/>
    
  </entry>
  
  <entry>
    <title>Trojan搭建</title>
    <link href="https://rma-shuyu.github.io/2022/07/06/Trojan%E6%90%AD%E5%BB%BA/"/>
    <id>https://rma-shuyu.github.io/2022/07/06/Trojan%E6%90%AD%E5%BB%BA/</id>
    <published>2022-07-06T11:55:44.000Z</published>
    <updated>2023-10-21T07:21:41.634Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-Trojan"><a href="#什么是-Trojan" class="headerlink" title="什么是 Trojan"></a>什么是 Trojan</h2><p>Trojan将流量伪装成用户正常访问网页时的HTTPS流量，防止流量被检测和干扰。</p><span id="more"></span><h2 id="搭建前准备"><a href="#搭建前准备" class="headerlink" title="搭建前准备"></a>搭建前准备</h2><h3 id="一台VPS服务器"><a href="#一台VPS服务器" class="headerlink" title="一台VPS服务器"></a>一台VPS服务器</h3><p>已有服务器的同学可以跳过这部分，没有服务器的同学可以先创建服务器，我使用的是<a href="https://www.itblogcn.com/vultr">Vultr</a>。</p><p><a href="https://www.itblogcn.com/vultr/t">Vultr VPS</a> 推出了 <strong>2023 年最新的限时促销活动</strong>，「新用户」注册并充值 10 美元以上，即可获得 100 美元的免费赠送金额！力度相当巨大！！ (去年仅送 $50) 用于建站、学习、自建网盘或各种网络服务等等都很实用，优势是价格低，按时计费，随时更换IP。有购买海外 <a href="https://www.itblogcn.com/vultr">VPS</a> 需求的同学就得抓紧机会了。</p><p><strong>Vultr活动地址：</strong><a href="https://www.itblogcn.com/vultr/t">https://www.itblogcn.com/vultr/t</a></p><p><strong>Vultr注册教程：</strong><a href="https://www.itblogcn.com/article/registervultr.html">注册Vultr教程和创建VPS服务器教程</a></p><p>预算充足的朋友也可以选择搬瓦工的VPS服务器，其CN2 GIA-E线路网速极快。</p><p><strong>搬瓦工注册教程(内附优惠券)：</strong><a href="https://www.itblogcn.com/article/bwg-register.html">https://www.itblogcn.com/article/bwg-register.html</a></p><p><strong>搬瓦工VPS在售列表一览：</strong><a href="https://www.itblogcn.com/bwg/index.html">https://www.itblogcn.com/bwg/index.html</a></p><p>这里也可以使用<a href="https://my.racknerd.com/cart.php?a=confproduct&i=0">racknerd</a>。</p><p><strong>racknerd注册教程：</strong><a href="https://www.vpsgo.com/racknerd-purchase-tutorial.html">https://www.vpsgo.com/racknerd-purchase-tutorial.html</a></p><p><strong>2023年便宜高性价比VPS推荐：</strong><a href="https://www.vps69.com/posts/cheap-vps">https://www.vps69.com/posts/cheap-vps</a></p><h3 id="域名申请"><a href="#域名申请" class="headerlink" title="域名申请"></a>域名申请</h3><p><strong>聚名教程：</strong><a href="https://www.juming.com/help/127.htm">https://www.juming.com/help/127.htm</a></p><p><strong>namecheap教程：</strong><a href="https://zhuanlan.zhihu.com/p/33261777">https://zhuanlan.zhihu.com/p/33261777</a></p><h3 id="端口开放"><a href="#端口开放" class="headerlink" title="端口开放"></a>端口开放</h3><p>安装前必须开放服务器的<code>80</code>和<code>443</code>端口</p><p>防火墙相关命令可阅读 ：<a href="https://www.itblogcn.com/article/vultr-centos-7-firewall.html">https://www.itblogcn.com/article/vultr-centos-7-firewall.html</a></p><h2 id="Xshell连接服务器"><a href="#Xshell连接服务器" class="headerlink" title="Xshell连接服务器"></a>Xshell连接服务器</h2><h3 id="电脑端-ssh-登录"><a href="#电脑端-ssh-登录" class="headerlink" title="电脑端 ssh 登录"></a>电脑端 ssh 登录</h3><h2 id="一键Trojan搭建"><a href="#一键Trojan搭建" class="headerlink" title="一键Trojan搭建"></a>一键Trojan搭建</h2><p>系统建议：</p><ul><li>  CentOS 7</li></ul><p>首先安装wget（Vultr VPS已安装）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y wget</span><br></pre></td></tr></table></figure><h3 id="一键安装Trojan脚本"><a href="#一键安装Trojan脚本" class="headerlink" title="一键安装Trojan脚本"></a>一键安装Trojan脚本</h3><p>输入以下命令，回车执行（<code>shift+insert</code>可粘贴）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -N --no-check-certificate -q -O trojan_install.sh &quot;https://raw.githubusercontent.com/xyz690/Trojan/master/trojan_install.sh&quot; &amp;&amp; chmod +x trojan_install.sh &amp;&amp; bash trojan_install.sh</span><br></pre></td></tr></table></figure><p>输入<code>1</code>回车</p><p><img src="https://www.itblogcn.com/wp-content/uploads/2021/03/post-1048-603ca6268a7bb.png" alt="tssh2"></p><p>输入你解析的域名，比如我解析的是<code>www.demo.com</code>，然后回车执行</p><p><img src="https://www.itblogcn.com/wp-content/uploads/2021/03/post-1048-603ca62778d41.png" alt="tssh4_edit"></p><p>如果解析不正常，可能是之前DNS解析还没生效，建议等几分钟重试。</p><p>显示一下信息代表安装成功：</p><p><img src="https://www.itblogcn.com/wp-content/uploads/2021/03/post-1048-603ca628677ed.png" alt="20210301003431"></p><h4 id="查看运行状态（执行）："><a href="#查看运行状态（执行）：" class="headerlink" title="查看运行状态（执行）："></a>查看运行状态（执行）：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status trojan.service</span><br></pre></td></tr></table></figure><p>成功运行显示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">● trojan.service - trojan</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/trojan.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: active (running) since Fri 2022-12-02 16:02:55 UTC; 37s ago</span><br><span class="line"> Main PID: 8263 (trojan)</span><br><span class="line">   CGroup: /system.slice/trojan.service</span><br><span class="line">           └─8263 /usr/src/trojan/trojan -c /usr/src/trojan/server.conf</span><br><span class="line"></span><br><span class="line">Dec 02 16:02:55 vultr.guest systemd[1]: Started trojan.</span><br><span class="line">Dec 02 16:02:55 vultr.guest trojan[8263]: Welcome to trojan 1.16.0</span><br><span class="line">Dec 02 16:02:55 vultr.guest trojan[8263]: [2022-12-02 16:02:55] [WARN] trojan service (server) started at 0.0.0.0:443</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="查看配置文件-该配置在后面链接时使用-："><a href="#查看配置文件-该配置在后面链接时使用-：" class="headerlink" title="查看配置文件(该配置在后面链接时使用)："></a>查看配置文件(该配置在后面链接时使用)：</h4><p>输入以下命令，回车执行（<code>shift+insert</code>可粘贴）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /usr/src/trojan-macos/trojan/config.json</span><br></pre></td></tr></table></figure><p>我的配置如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;run_type&quot;: &quot;client&quot;,</span><br><span class="line">    &quot;local_addr&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;local_port&quot;: 1080,</span><br><span class="line">    &quot;remote_addr&quot;: &quot;www.demo.com&quot;,</span><br><span class="line">    &quot;remote_port&quot;: 443,</span><br><span class="line">    &quot;password&quot;: [</span><br><span class="line">        &quot;ae412345&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;log_level&quot;: 1,</span><br><span class="line">    &quot;ssl&quot;: &#123;</span><br><span class="line">        &quot;verify&quot;: true,</span><br><span class="line">        &quot;verify_hostname&quot;: true,</span><br><span class="line">        &quot;cert&quot;: &quot;&quot;,</span><br><span class="line">        &quot;cipher&quot;: &quot;ECDHE-ECDSA-AES128-GCM-SHA256:...&quot;,</span><br><span class="line">        &quot;cipher_tls13&quot;: &quot;TLS_AES_128_GCM_SHA256:...&quot;,</span><br><span class="line">        &quot;sni&quot;: &quot;&quot;,</span><br><span class="line">        &quot;alpn&quot;: [</span><br><span class="line">            &quot;h2&quot;,</span><br><span class="line">            &quot;http/1.1&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;reuse_session&quot;: true,</span><br><span class="line">        &quot;session_ticket&quot;: false,</span><br><span class="line">        &quot;curves&quot;: &quot;&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;tcp&quot;: &#123;</span><br><span class="line">        &quot;no_delay&quot;: true,</span><br><span class="line">        &quot;keep_alive&quot;: true,</span><br><span class="line">        &quot;reuse_port&quot;: false,</span><br><span class="line">        &quot;fast_open&quot;: false,</span><br><span class="line">        &quot;fast_open_qlen&quot;: 20</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>请重点关注配置文件中的如下参数：</p><ol><li> <code>remote_addr</code>：服务器地址（浏览器输入这个地址能打开网页）</li><li> <code>remote_port</code>：端口</li><li> <code>password</code>：密码</li></ol><h2 id="客户端链接Trojan"><a href="#客户端链接Trojan" class="headerlink" title="客户端链接Trojan"></a>客户端链接Trojan</h2><p><strong>clash-for-windows教程：</strong><a href="https://v2xtls.org/clash-for-windows%E9%85%8D%E7%BD%AEtrojan%E6%95%99%E7%A8%8B/">https://v2xtls.org/clash-for-windows%E9%85%8D%E7%BD%AEtrojan%E6%95%99%E7%A8%8B/</a></p><p>官网下载地址：<a href="https://github.com/Fndroid/clash_for_windows_pkg/releases">https://github.com/Fndroid/clash_for_windows_pkg/releases</a></p><p>下载运行后，点击“Profiles”，点击 <a href="https://v2xtls.org/clash_template2.yaml">https://v2xtls.org/clash_template2.yaml</a> 下载模板配置文件，用记事本、VS Code、Notepad++等编辑器打开，找到trojan配置块，把 server、port、password改成你服务器的信息</p><p>把修改好的配置文件拖到clash界面中，</p><p>然后双击选中拖进来的配置文件(深色表示选中)</p><p>最后回到主界面，点击“System Proxy”，开启系统代理，点击“Start with Windows”设置开机自启</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是-Trojan&quot;&gt;&lt;a href=&quot;#什么是-Trojan&quot; class=&quot;headerlink&quot; title=&quot;什么是 Trojan&quot;&gt;&lt;/a&gt;什么是 Trojan&lt;/h2&gt;&lt;p&gt;Trojan将流量伪装成用户正常访问网页时的HTTPS流量，防止流量被检测和干扰。&lt;/p&gt;</summary>
    
    
    
    <category term="Trojan" scheme="https://rma-shuyu.github.io/categories/Trojan/"/>
    
    
    <category term="Trojan" scheme="https://rma-shuyu.github.io/tags/Trojan/"/>
    
  </entry>
  
  <entry>
    <title>libvirt新增驱动</title>
    <link href="https://rma-shuyu.github.io/2022/07/05/libvirt%E6%96%B0%E5%A2%9E%E9%A9%B1%E5%8A%A8/"/>
    <id>https://rma-shuyu.github.io/2022/07/05/libvirt%E6%96%B0%E5%A2%9E%E9%A9%B1%E5%8A%A8/</id>
    <published>2022-07-05T11:55:44.000Z</published>
    <updated>2023-10-21T07:21:41.638Z</updated>
    
    <content type="html"><![CDATA[<h2 id="libvirtd驱动"><a href="#libvirtd驱动" class="headerlink" title="libvirtd驱动"></a>libvirtd驱动</h2><p>libvirtd qemu驱动的实现基于QEMU的API和命令行工具，它可以与QEMU进行交互，以便创建、启动、停止、重启、迁移、备份和恢复虚拟机等操作。</p><span id="more"></span><h2 id="修改背景"><a href="#修改背景" class="headerlink" title="修改背景"></a>修改背景</h2><p>如果是自研的虚拟化软件，那么在使用libvirtd时，需要开发对应的app驱动。<br>admin 2.0对libvirt 进行了开发，修改了原生7.2的代码，需要删除对原有功能的形象，完成现有功能的迭代</p><ol><li>支持2.0现有功能</li><li>增加新的jmnd_driver支持，可考虑新增代码单独目录放置</li></ol><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p>原生libvirt增加jmnd_driver:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">编译meson:</span><br><span class="line"></span><br><span class="line">    meson.build：增加jmnd驱动编译</span><br><span class="line"></span><br><span class="line">    meson_options.txt: 增加jmnd驱动选项</span><br><span class="line"></span><br><span class="line">修改代码：</span><br><span class="line"></span><br><span class="line">    include/libvirt/virterror.h: 增加错误域</span><br><span class="line"></span><br><span class="line">    src/util/virerror.c: 增加错误域名</span><br><span class="line"></span><br><span class="line">    src/remote/remote_daemon.c: 增加驱动装载的执行</span><br><span class="line"></span><br><span class="line">    src/meson.build: 增加jmnd驱动编译</span><br><span class="line"></span><br><span class="line">新增驱动代码：</span><br><span class="line"></span><br><span class="line">    src/jmnd : jmnd_driver实现</span><br></pre></td></tr></table></figure><h2 id="virsh命令格式"><a href="#virsh命令格式" class="headerlink" title="virsh命令格式"></a>virsh命令格式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    virsh -c jmnd+tcp:///system [CMD]</span><br><span class="line"></span><br><span class="line">    可以将jmnd设置成默认驱动：</span><br><span class="line"></span><br><span class="line">        /usr/share/jmnd/libvirt/etc/libvirt/libvirt.conf 中：uri_default = &quot;jmnd:///system&quot;</span><br><span class="line"></span><br><span class="line">        重启libvirt</span><br><span class="line"></span><br><span class="line">        然后执行virsh [CMD]，等同于执行virsh -c jmnd+tcp:///system [CMD]</span><br><span class="line"></span><br><span class="line">远程操作：</span><br><span class="line"></span><br><span class="line">     virsh -c jmnd+tcp://10.20.25.22/system [CMD]</span><br></pre></td></tr></table></figure><h2 id="libvird-l"><a href="#libvird-l" class="headerlink" title="libvird -l"></a>libvird -l</h2><p>用于监听libvirtd.conf中的tcp_port，如果不加-l参数，则virsh只能本地访问libvirtd，添加-l参数后可以远程访问</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@node-70-20:/usr/share/jmnd/libvirt/etc/libvirt# egrep -v &quot;^#|^$&quot; *</span><br><span class="line">libvirt.conf:uri_default = &quot;jmnd:///system&quot;</span><br><span class="line">libvirtd.conf:listen_tls = 0</span><br><span class="line">libvirtd.conf:listen_tcp = 1</span><br><span class="line">libvirtd.conf:tcp_port = &quot;16509&quot;</span><br><span class="line">libvirtd.conf:log_level = 3</span><br><span class="line">libvirtd.conf:log_outputs=&quot;1:file:/var/log/libvirt/libvirtd.log&quot;</span><br><span class="line">qemu.conf:max_files = 20480</span><br></pre></td></tr></table></figure><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p>1.0和2.0可以共用libvirt</p><p>1.0用的是libvirt本身支持的qemu驱动、</p><p>2.0用的是libvirt支持的jmnd驱动</p><p>由于libvirt的jmnd驱动加载后有定时器定时连接jmnd_hypervisor，因此可以直接将jmnd驱动库删除，驱动库：/usr/share/jmnd/libvirt/lib/x86_64-linux-gnu/libvirt/connection-driver/libvirt_driver_jmnd.so</p><p>后续jmnd驱动修改代码可以直接替换这个驱动库后重启Libvirt生效</p><h2 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(gdb) bt</span><br><span class="line">#0  jmndConnectHelloWorld (conn=0x7f5ca40051c0, printout=0x7f5cd6f32960) at ../src/jmnd/jmnd_driver.c:404</span><br><span class="line">#1  0x00007f5cde7ee786 in virConnectHelloWorld (conn=&lt;optimized out&gt;, printout=printout@entry=0x7f5cd6f32960) at ../src/libvirt-domain.c:191</span><br><span class="line">#2  0x000055af32336164 in remoteDispatchConnectHelloWorld (server=0x55af33b64080, msg=0x55af33b6e1c0, ret=0x7f5ccc0039d0, rerr=0x7f5cd6f32a30, client=0x7f5ca40050c0)</span><br><span class="line">    at src/remote/remote_daemon_dispatch_stubs.h:1317</span><br><span class="line">#3  remoteDispatchConnectHelloWorldHelper (server=0x55af33b64080, client=0x7f5ca40050c0, msg=0x55af33b6e1c0, rerr=0x7f5cd6f32a30, args=0x0, ret=0x7f5ccc0039d0) at src/remote/remote_daemon_dispatch_stubs.h:1297</span><br><span class="line">#4  0x00007f5cde7877c1 in virNetServerProgramDispatchCall (msg=0x55af33b6e1c0, client=0x7f5ca40050c0, server=0x55af33b64080, prog=0x55af33b65810) at ../src/rpc/virnetserverprogram.c:428</span><br><span class="line">#5  virNetServerProgramDispatch (prog=0x55af33b65810, server=server@entry=0x55af33b64080, client=0x7f5ca40050c0, msg=0x55af33b6e1c0) at ../src/rpc/virnetserverprogram.c:302</span><br><span class="line">#6  0x00007f5cde78c712 in virNetServerProcessMsg (msg=&lt;optimized out&gt;, prog=&lt;optimized out&gt;, client=&lt;optimized out&gt;, srv=0x55af33b64080) at ../src/rpc/virnetserver.c:137</span><br><span class="line">#7  virNetServerHandleJob (jobOpaque=0x55af33b35000, opaque=0x55af33b64080) at ../src/rpc/virnetserver.c:154</span><br><span class="line">#8  0x00007f5cde6d68f0 in virThreadPoolWorker (opaque=&lt;optimized out&gt;) at ../src/util/virthreadpool.c:163</span><br><span class="line">#9  0x00007f5cde6d6027 in virThreadHelper (data=&lt;optimized out&gt;) at ../src/util/virthread.c:233</span><br><span class="line">#10 0x00007f5cdbdae1ca in start_thread () from /lib64/libpthread.so.0</span><br><span class="line">#11 0x00007f5cdd0ecd83 in clone () from /lib64/libc.so.6</span><br><span class="line">(gdb) </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;libvirtd驱动&quot;&gt;&lt;a href=&quot;#libvirtd驱动&quot; class=&quot;headerlink&quot; title=&quot;libvirtd驱动&quot;&gt;&lt;/a&gt;libvirtd驱动&lt;/h2&gt;&lt;p&gt;libvirtd qemu驱动的实现基于QEMU的API和命令行工具，它可以与QEMU进行交互，以便创建、启动、停止、重启、迁移、备份和恢复虚拟机等操作。&lt;/p&gt;</summary>
    
    
    
    <category term="LIBVIRT" scheme="https://rma-shuyu.github.io/categories/LIBVIRT/"/>
    
    
    <category term="driver" scheme="https://rma-shuyu.github.io/tags/driver/"/>
    
  </entry>
  
  <entry>
    <title>libvirtd初始化流程</title>
    <link href="https://rma-shuyu.github.io/2022/07/04/libvirtd%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/"/>
    <id>https://rma-shuyu.github.io/2022/07/04/libvirtd%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/</id>
    <published>2022-07-04T11:55:44.000Z</published>
    <updated>2023-10-21T07:21:41.637Z</updated>
    
    <content type="html"><![CDATA[<p>libvirtd daemon初始化流程比较复杂，本文对代码流程进行初步分析。</p><span id="more"></span><h2 id="总体代码流程"><a href="#总体代码流程" class="headerlink" title="总体代码流程"></a>总体代码流程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">main&#123;remote/remote_deamon.c&#125;</span><br><span class="line">|</span><br><span class="line">|--daemonConfigLoadFile&#123;读取libvirtd.conf配置项&#125;</span><br><span class="line">|</span><br><span class="line">|--Decided on pid file path &#x27;/usr/local/var/run/libvirtd.pid&#x27;</span><br><span class="line">|</span><br><span class="line">|--virDaemonUnixSocketPaths&#123;获取unix对应的socket文件名字，例如：/usr/local/var/run/libvirt/libvirt-sock&#125;</span><br><span class="line">|</span><br><span class="line">|--virDaemonForkIntoBackground&#123;如果设置-d参数的话，将启动的libvirtd进程变成后台的daemon进程&#125;</span><br><span class="line">|</span><br><span class="line">|--virPidFileAcquirePath&#123;&#x27;/usr/local/var/run/libvirtd.pid&#x27;&#125;</span><br><span class="line">|</span><br><span class="line">|--virNetDaemonNew&#123;生成的是daemon变量&#125;</span><br><span class="line">|</span><br><span class="line">|--virNetServerNew&#123;初始化的是libvirtd server变量，里面是一堆rpc-worker的线程&#125;</span><br><span class="line">|</span><br><span class="line">|--virNetDaemonAddServer&#123;把server变量放进daemon中的hash表中&#125;</span><br><span class="line">|</span><br><span class="line">|--daemonSetupSignals&#123;daemon的一些回调函数注册，例如SIGINT，SIGQUIT，SIGTERM，SIGHUP&#125;</span><br><span class="line">|</span><br><span class="line">|--daemonSetupNetworking&#123;前面已经启动线程，这里对socket进行监听和消息接收函数注册&#125;</span><br><span class="line">|</span><br><span class="line">|--daemonInitialize&#123;动态库添加，例如qemu驱动&#125;</span><br><span class="line">|</span><br><span class="line">|--daemonStateInit&#123;驱动初始化，例如qemu驱动的初始化&#125;</span><br><span class="line">|</span><br><span class="line">|--virNetServerProgramNew</span><br><span class="line">|</span><br><span class="line">|--virNetServerAddProgram(srv, qemuProgram)</span><br><span class="line">|</span><br><span class="line">|--virNetDaemonRun&#123;Run event loop&#125;</span><br></pre></td></tr></table></figure><h2 id="各个流程代码分析"><a href="#各个流程代码分析" class="headerlink" title="各个流程代码分析"></a>各个流程代码分析</h2><h3 id="子进程创建"><a href="#子进程创建" class="headerlink" title="子进程创建"></a>子进程创建</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">virDaemonForkIntoBackground&#123;如果启动libvirtd进程的时候，以-d启动，则会创建一个子进程来启动，之后在后台运行，否则libvirtd进程就会一直卡在终端界面上&#125;</span><br><span class="line">|</span><br><span class="line">|--virPipeQuiet(statuspipe)</span><br><span class="line">|</span><br><span class="line">|--fork()</span><br><span class="line">|</span><br><span class="line">|--child</span><br><span class="line">||</span><br><span class="line">||--VIR_FORCE_CLOSE(statuspipe[0])&#123;关闭读通道&#125;</span><br><span class="line">||</span><br><span class="line">||--setsid()&#123;为啥在这里设置，child后面就会关掉，为啥不在grand child中设置呢？&#125;</span><br><span class="line">||</span><br><span class="line">||--fork()&#123;继续创建进程&#125;</span><br><span class="line">||</span><br><span class="line">||--grand</span><br><span class="line">|||</span><br><span class="line">|||-statuspipe[1]&#123;返回写通道，用grand child作为daemon进程，如果初始化成功，则会向管道中写数据&#125;</span><br><span class="line">||</span><br><span class="line">||--child</span><br><span class="line">||</span><br><span class="line">||--_exit(EXIT_SUCCESS)&#123;child进程退出，但是是不是没有清理资源statuspipe[1]？&#125;</span><br><span class="line">|</span><br><span class="line">|--parent</span><br><span class="line">|</span><br><span class="line">|--VIR_FORCE_CLOSE(statuspipe[1])&#123;关闭写通道&#125;</span><br><span class="line">|</span><br><span class="line">|--waitpid(pid, &amp;exitstatus, 0)&#123;等到child退出&#125;</span><br><span class="line">|</span><br><span class="line">|--saferead(statuspipe[0], &amp;status, 1)&#123;grand child后面初始化成功之后会发送消息，但是这个是非阻塞的，难道会等待吗？&#125;</span><br><span class="line">|</span><br><span class="line">|--VIR_FORCE_CLOSE(statuspipe[0])&#123;关闭读通道&#125;</span><br><span class="line">|</span><br><span class="line">|--_exit(EXIT_SUCCESS)&#123;退出父进程&#125;</span><br><span class="line"></span><br><span class="line">virPidFileAcquirePath的目的是为了防止重复运行libvirtd进程；在该函数中会设置独占锁给pid_file；如果失败，则说明已经有libvirtd运行了，反之则将pid写入到pid_file中(pid_file=/usr/local/var/run/libvirtd.pid)</span><br><span class="line">virPidFileAcquirePath</span><br><span class="line">|</span><br><span class="line">|--open(path, O_WRONLY|O_CREAT, 0644)</span><br><span class="line">|</span><br><span class="line">|--&#123;Ensuring run dir &#x27;/usr/local/var/run/libvirt&#x27; exists&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="daemon对象创建"><a href="#daemon对象创建" class="headerlink" title="daemon对象创建"></a>daemon对象创建</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">virNetDaemonNew</span><br><span class="line">|</span><br><span class="line">|--virNetDaemonInitialize</span><br><span class="line">|</span><br><span class="line">|--dmn = virObjectLockableNew&#123;生成一个virNetDaemon对象，后续对该对象中的各个成员变量进行初始化&#125;</span><br><span class="line">|</span><br><span class="line">|--dmn-&gt;servers = virHashNew(virObjectFreeHashData)&#123;这里分配HASH表，并对哈希表进行初始化&#125;</span><br><span class="line">|</span><br><span class="line">|--virEventRegisterDefaultImpl</span><br><span class="line">|</span><br><span class="line">|--virInitialize&#123;所调用的函数只执行一次，pthread_once&#125;</span><br><span class="line">||</span><br><span class="line">||--virGlobalInit&#123;相应的driver注册&#125;</span><br><span class="line">||</span><br><span class="line">||--remoteRegister&#123;这个函数为啥没有日志打印？难道没有执行&#125;</span><br><span class="line">||</span><br><span class="line">||--virRegisterConnectDriver(&amp;connect_driver)</span><br><span class="line">||</span><br><span class="line">||--virRegisterStateDriver(&amp;state_driver)</span><br><span class="line">|</span><br><span class="line">|--virResetLastError</span><br><span class="line">|</span><br><span class="line">|--virEventGLibRegister</span><br><span class="line">|</span><br><span class="line">|--virEventGLibRegisterOnce&#123;函数只执行一次&#125;</span><br><span class="line">|</span><br><span class="line">|--virEventRegisterImpl&#123;这个是event事件相关函数句柄注册&#125;</span><br><span class="line">|</span><br><span class="line">|--removeHandleImpl=virEventGLibHandleRemove</span><br><span class="line">|--updateHandleImpl=virEventGLibHandleUpdate</span><br><span class="line">|--addHandleImpl=virEventGLibHandleAdd</span><br><span class="line">|</span><br><span class="line">|--GSource</span><br><span class="line">|--g_source_new</span><br><span class="line">|--g_source_add_poll</span><br><span class="line">|--g_source_set_callback</span><br><span class="line">|--g_source_attach</span><br></pre></td></tr></table></figure><h3 id="virNetServerNew创建"><a href="#virNetServerNew创建" class="headerlink" title="virNetServerNew创建"></a>virNetServerNew创建</h3><p>这个就是初始化一组worker pool,等待信号量，然后再调用消息处理函数处理具体的消息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">virNetServerNew&#123;这个是rpc-worker服务端的初始化函数&#125;</span><br><span class="line">|</span><br><span class="line">|--virObjectLockableNew(virNetServerClass)&#123;生成一个virNetServerPtr对象指针&#125;</span><br><span class="line">|</span><br><span class="line">|--srv-&gt;workers = virThreadPoolNewFull(virNetServerHandleJob, &quot;rpc-worker&quot;)</span><br><span class="line">||</span><br><span class="line">||--分配virThreadPoolPtr pool</span><br><span class="line">||</span><br><span class="line">||--pool-&gt;jobFunc = func=virNetServerHandleJob&#123;设置pool中的函数句柄&#125;</span><br><span class="line">||</span><br><span class="line">||--pool-&gt;jobName = name&#123;设置pool中的名字&#125;</span><br><span class="line">||</span><br><span class="line">||--pool-&gt;jobOpaque=server&#123;将server变量指针传入到pool的jobopaque指针变量中&#125;</span><br><span class="line">||</span><br><span class="line">||--virThreadPoolExpand(pool, minWorkers)&#123;如函数名称：线程池扩展函数，就是for循环创建多个线程池&#125;</span><br><span class="line">|||</span><br><span class="line">|||--data-&gt;pool = pool</span><br><span class="line">|||</span><br><span class="line">|||--virThreadCreateFull(&amp;(*workers)[i],virThreadPoolWorker,data)&#123;创建minWorkers个线程&#125;</span><br><span class="line">|||</span><br><span class="line">|||--args-&gt;func=virThreadPoolWorker</span><br><span class="line">|||</span><br><span class="line">|||--args-&gt;opaque=data</span><br><span class="line">|||</span><br><span class="line">|||--pthread_create(&amp;thread-&gt;thread, &amp;attr, virThreadHelper, args)</span><br><span class="line">|||</span><br><span class="line">|||--virThreadHelper(args)&#123;这是最终的线程函数&#125;</span><br><span class="line">|||</span><br><span class="line">|||--local = *args</span><br><span class="line">|||</span><br><span class="line">|||-local.func(local.opaque)&lt;==&gt;virThreadPoolWorker(data)</span><br><span class="line">|||</span><br><span class="line">|||--virThreadPoolWorker&#123;这个是线程的最终执行函数，里面有while循环&#125;</span><br><span class="line">|||</span><br><span class="line">|||-virMutexLock(&amp;pool-&gt;mutex)&#123;在进入while循环之前先获取锁&#125;</span><br><span class="line">|||</span><br><span class="line">|||--virCondWait(cond, &amp;pool-&gt;mutex)&#123;进入while循环之后，先解锁把cond放入等待队列中(原子动作)，获取信号之后，再加锁&#125;</span><br><span class="line">|||</span><br><span class="line">|||--pool-&gt;jobQueueDepth--&#123;队列深度减一&#125;</span><br><span class="line">|||--virMutexUnlock(&amp;pool-&gt;mutex)&#123;解锁&#125;</span><br><span class="line">|||--(pool-&gt;jobFunc)(job-&gt;data, pool-&gt;jobOpaque)&lt;===&gt;virNetServerHandleJob(server)&#123;这里是处理具体消息的函数&#125;</span><br><span class="line">|||--virMutexLock(&amp;pool-&gt;mutex)&#123;加锁，进入下一次等待&#125;</span><br><span class="line">||</span><br><span class="line">||--return pool&#123;server变量中的worker就是pool，即线程池&#125;</span><br><span class="line">|</span><br><span class="line">|--继续初始化server，这里的pool是server中的变量，同时也是线程中的变量，两边都可以使用</span><br></pre></td></tr></table></figure><h3 id="服务端创建"><a href="#服务端创建" class="headerlink" title="服务端创建"></a>服务端创建</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">daemonSetupNetworking(srv, srvAdm,config,sock_file)</span><br><span class="line">|</span><br><span class="line">|--virNetServerAddServiceActivation&#123;No activation FDs present，这个函数没啥作用，直接返回了&#125;</span><br><span class="line">|</span><br><span class="line">|--virNetServerAddServiceUNIX&#123;针对的unix的*.socket文件&#125;&#123;这里生成的是virNetServerService对象&#125;</span><br><span class="line">||</span><br><span class="line">||--virNetServerAddServiceActivation</span><br><span class="line">||</span><br><span class="line">||--virNetServerServiceNewUNIX</span><br><span class="line">|||</span><br><span class="line">|||--virNetSocketNewListenUNIX&#123;Creating new UNIX server path=&#x27;/usr/local/var/run/libvirt/libvirt-sock&#x27;&#125;</span><br><span class="line">||||</span><br><span class="line">||||--virNetSocketNew&#123;生成一个监听的套接字&#125;</span><br><span class="line">|||</span><br><span class="line">|||--virNetServerServiceNewSocket(&amp;sock)&#123;得到virNetServerServicePtr变量&#125;</span><br><span class="line">|||</span><br><span class="line">|||--virNetSocketListen(svc-&gt;socks[i], max_queued_clients)&#123;对该socket的fd进行监听&#125;</span><br><span class="line">|||</span><br><span class="line">|||--virNetSocketAddIOCallback(svc-&gt;socks[i],virNetServerServiceAccept)&#123;循环调用&#125;</span><br><span class="line">||||</span><br><span class="line">||||--sock-&gt;watch = virEventAddHandle(sock-&gt;fd,virNetSocketEventHandle)</span><br><span class="line">|||||</span><br><span class="line">|||||--virNetSocketEventHandle&#123;这里进行event—loop监听，并注册监听函数；添加之后，并没直接进入event-loop&#125;</span><br><span class="line">|||||</span><br><span class="line">|||||--virNetServerServiceAccept&#123;如果有客户端连接service，则会调用该函数&#125;</span><br><span class="line">||||</span><br><span class="line">||||--sock-&gt;func = virNetServerServiceAccept&#123;server端处理消息的回调函数&#125;</span><br><span class="line">|||</span><br><span class="line">|||--将sock中的值赋值给virNetServerServicePtr变量并返回</span><br><span class="line">||</span><br><span class="line">||--virNetServerAddService&#123;将virNetServerServicePtr变量放进virNetServerPtr变量中，virNetServer对象包含多个virNetServerService对象&#125;</span><br><span class="line">||</span><br><span class="line">||--virNetServerServiceSetDispatcher</span><br><span class="line">||</span><br><span class="line">||--svc-&gt;dispatchFunc=virNetServerDispatchNewClient&#123;注册客户端的回调函数，用于处于从Unix得到的消息&#125;</span><br><span class="line">|</span><br><span class="line">|--virNetServerAddServiceTCP(针对的是tcp的socket文件)</span><br></pre></td></tr></table></figure><p>后续如果socket套接字接收到client端发送的连接之后，经过glib的event-loop调用，会进入到此函数中创建serverclient对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">virNetServerServiceAccept&#123;server端如果接收到客户端的连接，则会调用这个回调函数进行处理创建客户端对象&#125;</span><br><span class="line">|</span><br><span class="line">|--virNetSocketAccept(sock, &amp;clientsock)</span><br><span class="line">||</span><br><span class="line">||--fd = accept(sock-&gt;fd, &amp;remoteAddr.data.sa, &amp;remoteAddr.len)</span><br><span class="line">||</span><br><span class="line">||--*clientsock = virNetSocketNew(&amp;localAddr,&amp;remoteAddr, true, fd,)&#123;这里根据得到的客户端创建新的套接字&#125;</span><br><span class="line">|</span><br><span class="line">|--svc-&gt;dispatchFunc(svc, clientsock, svc-&gt;dispatchOpaque)</span><br><span class="line">|</span><br><span class="line">|--virNetServerDispatchNewClient&#123;这个正是上面注册的回调函数&#125;</span><br><span class="line">|</span><br><span class="line">|--virNetServerClientNew&#123;分配_virNetServerClient对象，用于接收socket传来的消息&#125;</span><br><span class="line">|</span><br><span class="line">|--virNetServerAddClient(srv, client)</span><br><span class="line">|</span><br><span class="line">|--virNetServerClientInit</span><br><span class="line">||</span><br><span class="line">||--virNetServerClientRegisterEvent</span><br><span class="line">||</span><br><span class="line">||--virNetServerClientCalculateHandleMode</span><br><span class="line">||</span><br><span class="line">||--virNetSocketAddIOCallback(client-&gt;sock, virNetServerClientDispatchEvent)</span><br><span class="line">||</span><br><span class="line">||--virEventAddHandle(virNetSocketEventHandle)&#123;添加event-loop事件，对客户端的连接进行监听&#125;</span><br><span class="line">|</span><br><span class="line">|--srv-&gt;clients[srv-&gt;nclients-1] = virObjectRef(client)&#123;这里是每来一个client，则就在server中的client指针中新增一个client，释放是在后面的while循环中&#125;</span><br><span class="line">|</span><br><span class="line">|--virNetServerClientSetDispatcher(client, virNetServerDispatchNewMessage, srv)</span><br><span class="line">||</span><br><span class="line">||--client-&gt;dispatchFunc=virNetServerDispatchNewMessage&#123;server=0x55882b100880 client=0x55882b1112d0 message=0x55882b114690&#125;</span><br><span class="line">|</span><br><span class="line">|--virNetServerClientInitKeepAlive(client, srv-&gt;keepaliveInterval, srv-&gt;keepaliveCount)&#123;设置客户端与服务端之间的连接超时时间&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>client如果向该socket发送消息，则会进入到event事件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">virNetSocketEventHandle</span><br><span class="line">|</span><br><span class="line">|--virNetServerClientDispatchEvent</span><br><span class="line">|</span><br><span class="line">|--virNetServerClientDispatchWrite&#123;写&#125;</span><br><span class="line">|</span><br><span class="line">|--msg = virNetServerClientDispatchRead(client)&#123;读取消息&#125;</span><br><span class="line">|</span><br><span class="line">|--virNetServerClientDispatchMessage(client, msg)</span><br><span class="line">|</span><br><span class="line">|--client-&gt;dispatchFunc(client, msg, client-&gt;dispatchOpaque)</span><br><span class="line">|</span><br><span class="line">|--virNetServerDispatchNewMessage</span><br><span class="line">|</span><br><span class="line">|--virThreadPoolSendJob&#123;发送信号量，调用线程池去处理&#125;</span><br><span class="line">|</span><br><span class="line">|--进入到另外一个线程virNetServerHandleJob&#123;server=0x55882b100880 client=0x55882b1112d0 message=0x55882b114690 prog=0x55882b109c10&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：<br>一条消息是如何被处理的？<br>1. 在libvirtd初始化的时候，会创建一个worker-pool(线程池)，在线程池中会等待信号量，如果得到信号量则会调用消息处理函数，进行真正的消息处理；<br>2. 但是谁发送的信号量呢？这个是客户端发来的消息处理的。<br>    在初始化的时候，会针对libvirt.sock文件创建一个监听事件，如果客户端连接这个套接字文件之后，则会调用监听事件注册的回调函数。<br>3. 2中注册的回调函数，会重新建立一个客户端和服务端的连接用于接收客户端发来的消息，并对该连接(socket)进行监听，并注册监听事件。<br>4. 如果客户端发送来消息，则会调用3中注册的事件处理函数，读取socket中的消息，并发送信号量调用1中的worker-pool中的线程处理函数。<br>5. 因为线程处理进程是多个的，因此不会阻塞会并发运行。<br>6. 对于每一个客户端的连接都会新生成一个serverclient对象，并对该对象中的socket进行监听。</p><h3 id="驱动获取"><a href="#驱动获取" class="headerlink" title="驱动获取"></a>驱动获取</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">daemonInitialize</span><br><span class="line">|</span><br><span class="line">|--virDriverLoadModule(&quot;network&quot;, &quot;networkRegister&quot;, false)</span><br><span class="line">|</span><br><span class="line">|--***</span><br><span class="line">|</span><br><span class="line">|--virDriverLoadModule(&quot;qemu&quot;, &quot;qemuRegister&quot;, false)&#123;加载qemu驱动&#125;</span><br><span class="line">|</span><br><span class="line">|--virFileFindResourceFull&#123;path=/usr/local/lib/libvirt/connection-driver/libvirt_driver_qemu.so&#125;</span><br><span class="line">|</span><br><span class="line">|--virModuleLoad(path,&quot;qemuRegister&quot;,false)</span><br><span class="line">|</span><br><span class="line">|--handle=virModuleLoadFile(path)</span><br><span class="line">|</span><br><span class="line">|--virModuleLoadFunc(&quot;qemuRegister&quot;)</span><br><span class="line">||</span><br><span class="line">||--regsym = dlsym(handle, &quot;qemuRegister&quot;)</span><br><span class="line">|</span><br><span class="line">|--(*regsym)()-&gt;qemuRegister()</span><br><span class="line">|</span><br><span class="line">|--virRegisterConnectDriver</span><br><span class="line">||</span><br><span class="line">||--virConnectDriverTab[virConnectDriverTabCount]=qemuConnectDriver&#123;对应的函数句柄&#125;</span><br><span class="line">|</span><br><span class="line">|--virRegisterStateDriver</span><br><span class="line">|</span><br><span class="line">|--virStateDriverTab[virStateDriverTabCount]=qemuStateDriver&#123;qemu驱动的初始化和终止函数&#125;</span><br></pre></td></tr></table></figure><h3 id="驱动初始化"><a href="#驱动初始化" class="headerlink" title="驱动初始化"></a>驱动初始化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">daemonStateInit&#123;Initialize drivers &amp; then start accepting new clients from network&#125;</span><br><span class="line">|</span><br><span class="line">|--virThreadCreateFull&#123;thread-name=&quot;daemon-init&quot;&#125;</span><br><span class="line">|</span><br><span class="line">|--daemonRunStateInit</span><br><span class="line">|</span><br><span class="line">|--virIdentitySetCurrent</span><br><span class="line">|</span><br><span class="line">|--daemonInhibitCallback</span><br><span class="line">|</span><br><span class="line">|-virStateInitialize</span><br><span class="line">|</span><br><span class="line">|--virInitialize&#123;只初始化一次&#125;</span><br><span class="line">||</span><br><span class="line">||--virGlobalInit</span><br><span class="line">||</span><br><span class="line">||--testRegister</span><br><span class="line">||</span><br><span class="line">||--openvzRegister</span><br><span class="line">||</span><br><span class="line">||--hypervRegister</span><br><span class="line">||</span><br><span class="line">||--remoteRegister</span><br><span class="line">|</span><br><span class="line">|--virStateDriverTab[i]-&gt;stateInitialize&#123;这里是一个for循环，初始化之前注册的driver&#125;</span><br><span class="line">||</span><br><span class="line">||--qemuStateInitialize&#123;qemu_driver.c&#125;&#123;因为前面已经加载了对应的驱动函数&#125;</span><br><span class="line">|</span><br><span class="line">|--driversInitialized = true&#123;这里代表驱动的初始化已经完成&#125;</span><br><span class="line">|</span><br><span class="line">|--virNetDaemonUpdateServices(dmn, true)&#123;Only now accept clients from network&#125;</span><br><span class="line">|</span><br><span class="line">|--virHashForEach(dmn-&gt;servers, daemonServerUpdateServices, &amp;enabled)</span><br><span class="line">|</span><br><span class="line">|--daemonServerUpdateServices</span><br><span class="line">|</span><br><span class="line">|--virNetServerUpdateServices(srv, *enable)</span><br></pre></td></tr></table></figure><h3 id="event事件运行"><a href="#event事件运行" class="headerlink" title="event事件运行"></a>event事件运行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">virNetDaemonRun</span><br><span class="line">|</span><br><span class="line">|--进入while(1)循环</span><br><span class="line">|</span><br><span class="line">|--virEventRunDefaultImpl&#123;这里是运行poll去检测eventloop.handles中的每个描述符的事件，如果有事件发生就会调用回调函数去处理事件，但是未看出来&#125;</span><br><span class="line">||</span><br><span class="line">||--virEventGLibRunOnce</span><br><span class="line">||</span><br><span class="line">||--g_main_context_iteration(NULL, TRUE)&#123;该函数可以完成GMainContext的单次迭代&#125;</span><br><span class="line">|</span><br><span class="line">|</span><br><span class="line">|--virHashForEach(dmn-&gt;servers, daemonServerProcessClients, NULL)&#123;这里处理客户端，因为libvirtd也需要连接其他的libvirtd&#125;</span><br><span class="line">||</span><br><span class="line">||--for循环调用</span><br><span class="line">||</span><br><span class="line">||--daemonServerProcessClients(servers[i]-&gt;payload, servers[i]-&gt;name)</span><br><span class="line">||</span><br><span class="line">||--virNetServerProcessClients</span><br><span class="line">||</span><br><span class="line">||--判断client-&gt;wantClose 是否为true，是，则会主动关闭client</span><br><span class="line">|</span><br><span class="line">|--dmn-&gt;quit&#123;判断是否是退出&#125;</span><br><span class="line">|</span><br><span class="line">|--virThreadCreateFull(&amp;shutdownThread, true, daemonShutdownWait，&quot;daemon-shutdown&quot;)</span><br><span class="line">|</span><br><span class="line">|--daemonShutdownWait&#123;创建新的&quot;daemon-shutdown&quot;线程去处理资源&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;libvirtd daemon初始化流程比较复杂，本文对代码流程进行初步分析。&lt;/p&gt;</summary>
    
    
    
    <category term="LIBVIRT" scheme="https://rma-shuyu.github.io/categories/LIBVIRT/"/>
    
    
    <category term="libvirt" scheme="https://rma-shuyu.github.io/tags/libvirt/"/>
    
  </entry>
  
  <entry>
    <title>libvirt日志配置</title>
    <link href="https://rma-shuyu.github.io/2022/07/03/libvirt%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE/"/>
    <id>https://rma-shuyu.github.io/2022/07/03/libvirt%E6%97%A5%E5%BF%97%E9%85%8D%E7%BD%AE/</id>
    <published>2022-07-03T11:55:44.000Z</published>
    <updated>2023-10-21T07:21:41.638Z</updated>
    
    <content type="html"><![CDATA[<h3 id="libvirt配置文件详解"><a href="#libvirt配置文件详解" class="headerlink" title="libvirt配置文件详解"></a>libvirt配置文件详解</h3><h4 id="配置文件：-etc-libvirt-libvirtd-conf"><a href="#配置文件：-etc-libvirt-libvirtd-conf" class="headerlink" title="配置文件：/etc/libvirt/libvirtd.conf"></a>配置文件：/etc/libvirt/libvirtd.conf</h4><span id="more"></span><p><strong>日志控制</strong></p><p> 日志级别: 4 errors, 3 warnings, 2 information, 1 debug<br> 基本上debug级别可以记录所有日志信息<br> 注意: <br>     journald会锁定libvirt守护进行，限制日志记录级别，如果想监控debug级别日志，必须显式配置到“log_outputs”选项中，<br>     否则，只有information级别的日志会被记录。<br>     如果日志级别设置为2，则通过log_outputs获取不到1 debug级别的日志。<br>     默认情况下，不会将日志输出到journald中，也不会输出到其它地方。</p><p><code>log_level = 1</code></p><p><strong>日志过滤</strong><br> <br> 日志过滤允许对给定类别的日志选择特定日志级别。<br> 过滤格式可以是如下的一种:<br>    x:name<br>    x:+name<br>    当name字符串匹配到源文件名，比如：“remote”、“qemu”、“util/json”，“+”前缀会告诉libvirt去记录匹配名字的调用栈日志。<br>      x为匹配日志的最低级别:<br>    1: DEBUG<br>    2: INFO<br>    3: WARNING<br>    4: ERROR</p><p> 多个过滤器可以同时使用，只需要用空格隔开就行。<br> 示例如下：<br>     只从remote层获取警告和错误信息，并且从event层获取错误信息。</p><p><code>log_filters=&quot;3:remote 4:event&quot;</code></p><p><strong>日志输出</strong><br> <br> 日志输出可以是如下的几个地方：<br> 日志输出配置格式如下:<br>    x:stderr<br>      输出到标准错误输出中<br>    x:syslog:name<br>      使用自定义的name标识符，输出到系统日志<br>    x:file:file_path<br>      输出到指定路径的文件中<br>    x:journald<br>      输出到journald日志系统中<br> x代表最小的日志输出过滤级别<br>    1: DEBUG<br>    2: INFO<br>    3: WARNING<br>    4: ERROR</p><p> 可以同时定义多个输出，只需要用空格分开就行。<br> 注意：<br>     这里要保证日志级别大于等于log_level中的配置，否则无效<br> 例如：使用libvirtd标识记录WARNING以上日志信息到syslog中</p><p><code>log_outputs=&quot;3:syslog:libvirtd&quot;</code></p><p> 同时将日志记录到libvirtd.log文件和journald（可通过journalctl -u libvirtd来查看）中。</p><p><code>log_outputs=&quot;3:file:/var/log/libvirt/libvirtd.log 3:journald&quot;</code></p><h4 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h4><p>1、编辑文件 /etc/libvirt/libvirtd.conf，修改如下行，将libvirt调试日志输出到/var/log/libvirt/libvirtd.log文件中：<br>log_level=1</p><p>log_outputs=”1:file:/var/log/libvirt/libvirtd.log”</p><p>2、重启libvirtd服务使配置生效。</p><p>service libvirtd restart</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;libvirt配置文件详解&quot;&gt;&lt;a href=&quot;#libvirt配置文件详解&quot; class=&quot;headerlink&quot; title=&quot;libvirt配置文件详解&quot;&gt;&lt;/a&gt;libvirt配置文件详解&lt;/h3&gt;&lt;h4 id=&quot;配置文件：-etc-libvirt-libvirtd-conf&quot;&gt;&lt;a href=&quot;#配置文件：-etc-libvirt-libvirtd-conf&quot; class=&quot;headerlink&quot; title=&quot;配置文件：/etc/libvirt/libvirtd.conf&quot;&gt;&lt;/a&gt;配置文件：/etc/libvirt/libvirtd.conf&lt;/h4&gt;</summary>
    
    
    
    <category term="LIBVIRT" scheme="https://rma-shuyu.github.io/categories/LIBVIRT/"/>
    
    
    <category term="log" scheme="https://rma-shuyu.github.io/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>增加一个virsh命令</title>
    <link href="https://rma-shuyu.github.io/2022/07/02/%E5%A2%9E%E5%8A%A0%E4%B8%80%E4%B8%AAvirsh%E5%91%BD%E4%BB%A4/"/>
    <id>https://rma-shuyu.github.io/2022/07/02/%E5%A2%9E%E5%8A%A0%E4%B8%80%E4%B8%AAvirsh%E5%91%BD%E4%BB%A4/</id>
    <published>2022-07-02T11:55:44.000Z</published>
    <updated>2023-10-21T07:21:41.642Z</updated>
    
    <content type="html"><![CDATA[<h2 id="libvirt-简介"><a href="#libvirt-简介" class="headerlink" title="libvirt 简介"></a>libvirt 简介</h2><p>libvirt 是用于管理虚拟化平台的开源API、后台程序和管理工具。</p><span id="more"></span><p>它对上层云管平台提供一套 API 接口，libvirt 也自带了一个 virsh 工具可以用来控制虚机的生命周期，包括创建、删除、修改虚机。</p><p>本文中使用的 libvirt 版本为 7.3.0。</p><h2 id="libvirt-命令增添步骤"><a href="#libvirt-命令增添步骤" class="headerlink" title="libvirt 命令增添步骤"></a>libvirt 命令增添步骤</h2><p>目前 libvirt 已经提供了强大的 API 支持，但由于云上环境比较复杂，有时需要新定义一个 libvirt API 接口。</p><p>由于每添加一个 API 接口几乎就要添加一个新的 RPC 调用，所以添加的文件非常多。</p><p>以增添一个 <code>cmdHelloWorld</code> 为例，总共包括以下步骤：</p><ol><li> virsh 命令的添加</li><li> API 接口的添加</li><li> RPC 的添加</li></ol><p>由于添加 API 接口的步骤过长，本文先给大家介绍如何添加一个新的 virsh 命令。</p><h2 id="增添一个-virsh-命令"><a href="#增添一个-virsh-命令" class="headerlink" title="增添一个 virsh 命令"></a>增添一个 virsh 命令</h2><p>所有 virsh 命令的相应函数及其后传递的命令行参数都是在 <code>virsh-domain.c</code> 中。</p><p>virsh 命令是指 virsh 后面跟的第一个命令行参数。本文我们以 <code>virsh helloworld</code> 为例教大家如何添加一个 helloworld 命令。</p><h3 id="增添-helloworld-函数-cmdHelloWorld"><a href="#增添-helloworld-函数-cmdHelloWorld" class="headerlink" title="增添 helloworld 函数 cmdHelloWorld"></a>增添 helloworld 函数 cmdHelloWorld</h3><p>命令的响应函数是 <code>cmdHelloWorld</code>。也就是执行 <code>virsh helloworld</code> 后将调用的函数。</p><p>这个函数由 virsh 进程调用，最终调用 <code>cmdHelloWorld</code>。</p><p><code>cmdHelloWorld</code> 再调用 RPC 与计算结点的守护进程 libvirtd 交互。</p><h3 id="为-helloworld-增添新的命令行参数"><a href="#为-helloworld-增添新的命令行参数" class="headerlink" title="为 helloworld 增添新的命令行参数"></a>为 helloworld 增添新的命令行参数</h3><p><code>virsh helloworld</code> 后我们设置了以下几个命令行参数：</p><ul><li>  <code>--local</code>：表示与本地的 libvirtd 相连。</li><li>  <code>--help</code>：显示帮助信息。</li></ul><p>libvirt 描述命令行参数是用 <code>vshCmdOptDef</code> 数组表示，也就是 <code>--local</code> 要添加到 <code>vshCmdOptDef</code> 数组中。</p><p>而 <code>virsh helloworld --help</code> 要显示的信息添加到 <code>vshCmdInfo</code> 数组中。</p><h3 id="相应代码实现"><a href="#相应代码实现" class="headerlink" title="相应代码实现"></a>相应代码实现</h3><h4 id="命令行参数实现"><a href="#命令行参数实现" class="headerlink" title="命令行参数实现"></a>命令行参数实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">static const vshCmdInfo info_helloworld[] = &#123;</span><br><span class="line">    &#123;.name = &quot;help&quot;,</span><br><span class="line">     .data = N_(&quot;Print Hello World&quot;)&#125;,</span><br><span class="line">    &#123;.name = NULL&#125;</span><br><span class="line">&#125;;</span><br><span class="line">static const vshCmdOptDef opts_helloworld[] = &#123;</span><br><span class="line">    &#123;.name = &quot;local&quot;,</span><br><span class="line">     .type = VSH_OT_BOOL,</span><br><span class="line">     .help = N_(&quot;print Hello World in local.&quot;)&#125;,</span><br><span class="line">    &#123;.name = NULL&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>vshCmdOptDef opts_helloworld[]</code>：表示的是 <code>virsh helloworld</code> 后要接的两个命令行参数的描述。 <code>vshCmdInfo info_helloworld[]</code>: 是 <code>virsh helloworld --help</code> 所显示的描述打印。</p><h4 id="cmdHelloWorld-实现"><a href="#cmdHelloWorld-实现" class="headerlink" title="cmdHelloWorld 实现"></a>cmdHelloWorld 实现</h4><p>为了让示例程序最简单化，我们把virsh helloworld 的工作就是打印hello world字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static bool</span><br><span class="line">cmdHelloWorld(vshControl *ctl, const vshCmd *cmd)</span><br><span class="line">&#123;</span><br><span class="line">    bool ret = false;</span><br><span class="line">    char *buffer;</span><br><span class="line">    if (!vshCommandOptBool(cmd, &quot;local&quot;))</span><br><span class="line">        goto cleanup;</span><br><span class="line">    vshPrintExtra(ctl, _(&quot;hello, world\n&quot;));</span><br><span class="line">    ret = true;</span><br><span class="line">    cleanup:</span><br><span class="line">        return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="把-helloworld-命令添加进-vshCmdDef-domManagementCmds-中"><a href="#把-helloworld-命令添加进-vshCmdDef-domManagementCmds-中" class="headerlink" title="把 helloworld 命令添加进 vshCmdDef domManagementCmds[] 中"></a>把 helloworld 命令添加进 vshCmdDef domManagementCmds[] 中</h4><p>virsh 命令的命令行和处理函数都要注册到 <code>domManagementCmds[]</code> 中。</p><p>我们把刚刚添加的数据结构 <code>vshCmdOptDef</code>、<code>vshCmdInfo</code> 还有处理函数 <code>cmdHelloWorld</code> 添加到 <code>domManagementCmds[]</code> 中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const vshCmdDef domManagementCmds[] = &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#123;.name = &quot;helloworld&quot;,</span><br><span class="line">    .handler = cmdHelloWorld,</span><br><span class="line">    .opts = opts_helloworld,</span><br><span class="line">    .info = info_helloworld,</span><br><span class="line">    .flags = 0</span><br><span class="line">    &#125;,</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="编译、调试并运行新增的命令"><a href="#编译、调试并运行新增的命令" class="headerlink" title="编译、调试并运行新增的命令"></a>编译、调试并运行新增的命令</h3><p>centos 佩带的 libvirt 的 src.rpm 包的编译使用的是 spec 文件, 执行 <code>rpmbuild -ba libvirt.spec</code> 的时候会把配置、编译一气合成。</p><p>但当我们对自己修改的 libvirt 代码配置的时候，最好不要用 centos 的 spec 里的配置，如果按照 spec 里的配置，在启动我们的 libvirtd 的时候还要先执行 <code>systemctl stop libvirtd</code> 把系统的 libvirtd 的进程停掉。</p><p>所以下面分享一下我自己配置和调试 libvirt 的技巧。</p><h4 id="配置、编译和安装过程"><a href="#配置、编译和安装过程" class="headerlink" title="配置、编译和安装过程"></a>配置、编译和安装过程</h4><p>配置不加任何参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br></pre></td></tr></table></figure><p>编译就不用多说了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -j 50</span><br></pre></td></tr></table></figure><p>后面这步很重要，每次编译后，都要重新卸载再进行安装，否则新编译的代码可能不会出现在 libvirtd 当中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make uninstall</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h4 id="手动启动-libvirtd"><a href="#手动启动-libvirtd" class="headerlink" title="手动启动 libvirtd"></a>手动启动 libvirtd</h4><p>libvirtd 是 libvirt 的守护进程，libvirt 的 API 接口几乎都是通过 RPC 调用链接到 libvirtd。virsh 命令就像一个 client 端，libvirtd 是服务端，virsh 的执行需要依靠 libvirtd。所以我们需要把 libvirtd 手动的拉起来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./daemon/libvirtd &amp;</span><br></pre></td></tr></table></figure><h4 id="使用的virsh-文件的路径"><a href="#使用的virsh-文件的路径" class="headerlink" title="使用的virsh 文件的路径"></a>使用的virsh 文件的路径</h4><p>使用 <code>./tools/.libs/virsh</code> 命令行执行。</p><p>注意，用 gdb 跟踪时使用 <code>./tools/.libs/virsh</code>，不要使用 <code>./tools/virsh</code>，因为 <code>./tools/virsh</code> 只是个脚本。</p><h4 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h4><p>执行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># virsh helloworld --local</span><br><span class="line">hello, world</span><br></pre></td></tr></table></figure><h2 id="添加一个-API-接口"><a href="#添加一个-API-接口" class="headerlink" title="添加一个 API 接口"></a>添加一个 API 接口</h2><p>上面我们讲过了创建 libvirt API 接口的完整步骤，并且讲述了添加一个新的 virsh 命令的步骤。</p><p>但是添加的 virsh 命令并没有调用 API 接口。而真正的 virsh 命令一般都是借助 libvirt 的 API 接口来完成的。</p><p>下面就为大家介绍如何添加一个 API 接口，并且介绍 API 接口是如何通过 RPC 调用与守护进程 libvirtd 通信的。</p><h3 id="完整的-API-函数流程"><a href="#完整的-API-函数流程" class="headerlink" title="完整的 API 函数流程"></a>完整的 API 函数流程</h3><p><img src="8ce7f2070a2b17bade2e4cad7e74f0a6f903685dad6421e6b9a5485e573979b9.png" alt="picture 0">  </p><h3 id="添加-virConnectHelloWorld-函数"><a href="#添加-virConnectHelloWorld-函数" class="headerlink" title="添加 virConnectHelloWorld 函数"></a>添加 virConnectHelloWorld 函数</h3><h4 id="libvirt-domain-c"><a href="#libvirt-domain-c" class="headerlink" title="libvirt-domain.c"></a>libvirt-domain.c</h4><p>上一节中实现的 <code>cmdHelloWorld</code> 函数没有调用任何 libvirt API。</p><p>但实际上 virsh 命令都是调用 API 函数来实现功能的，同时这个文件里的函数也会给上层业务调用。</p><p>例如在云服务上创建虚机都是直接调用 <code>virDomainCreateXML</code> 函数，并不是通过 <code>virsh create aaa.xml</code> 这种方式。</p><p>下面给出 <code>cmdHelloWorld</code> 的完整实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">extern int virConnectHelloWorld(virConnectPtr dconn, char **printout);</span><br><span class="line"></span><br><span class="line">static bool</span><br><span class="line">cmdHelloWorld(vshControl *ctl, const vshCmd *cmd)</span><br><span class="line">&#123;</span><br><span class="line">    bool ret = false;</span><br><span class="line">    virshControlPtr priv = ctl-&gt;privData;</span><br><span class="line">    char *printout = NULL;</span><br><span class="line">    </span><br><span class="line">    if (!vshCommandOptBool(cmd, &quot;local&quot;))</span><br><span class="line">        goto cleanup;</span><br><span class="line"></span><br><span class="line">    if(virConnectHelloWorld(priv-&gt;conn, &amp;printout) &lt; 0) &#123;</span><br><span class="line">        vshError(ctl, _(&quot;Failed to say HelloWorld&quot;));</span><br><span class="line">        goto cleanup;</span><br><span class="line">    &#125;</span><br><span class="line">    vshPrintExtra(ctl, _(&quot;%s&quot;), printout);</span><br><span class="line">    ret = true;</span><br><span class="line">cleanup:</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="src-libvirt-public-syms"><a href="#src-libvirt-public-syms" class="headerlink" title="src/libvirt_public.syms"></a>src/libvirt_public.syms</h4><p>在 <code>virsh-domain.c</code> 中加入了 <code>virConnectHelloWorld</code> 的函数声明，但在编译过程中还是会报错。原因是要在 <code>libvirt_public.syms</code> 文件中加入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LIBVIRT_7.3.0 &#123;</span><br><span class="line">    global:</span><br><span class="line">        virConnectHelloWorld;</span><br><span class="line">&#125; LIBVIRT_7.2.0;</span><br></pre></td></tr></table></figure><h2 id="添加一个-RPC-调用"><a href="#添加一个-RPC-调用" class="headerlink" title="添加一个 RPC 调用"></a>添加一个 RPC 调用</h2><h3 id="添加-RPC-client-调用"><a href="#添加-RPC-client-调用" class="headerlink" title="添加 RPC client 调用"></a>添加 RPC client 调用</h3><p>libvirt API 完整的函数流程中是要通过 RPC 调用和 libvirtd 进行通信。</p><p>下面我们把实现完全的代码贴上:</p><p><code>virConnectHelloWorld</code> 的入参 <code>virConnectPtr dconn</code> 中的 driver 是一个很关键的字段。描述了 RPC 调用的 client 端和 server 端回调函数的声明。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct _virConnect &#123;</span><br><span class="line">    ...</span><br><span class="line">    virHypervisorDriverPtr driver;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="src-driver-hypervisor-h"><a href="#src-driver-hypervisor-h" class="headerlink" title="src/driver-hypervisor.h"></a>src/driver-hypervisor.h</h4><p>给 <code>_virHypervisorDriver</code> 加入 <code>virDrvConnectHelloWorld</code> 字段，并且添加 <code>virDrvConnectHelloWorld</code> 的定义。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef int</span><br><span class="line">(*virDrvConnectHelloWorld) (virConnectPtr conn, char **printout);</span><br><span class="line"></span><br><span class="line">struct _virHypervisorDriver &#123;</span><br><span class="line">    ...</span><br><span class="line">    virDrvConnectHelloWorld connectHelloWorld;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="src-remote-remote-driver-c"><a href="#src-remote-remote-driver-c" class="headerlink" title="src/remote/remote_driver.c"></a>src/remote/remote_driver.c</h4><p>在 <code>driver-hypervisor.h</code> 中只是给 <code>_virHypervisorDriver</code> 添加了一个字段，还需要给出 RPC 调用的实现函数。</p><p><code>virConnectHelloWorld</code> 函数作为 RPC 的 client 端的实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">static int remoteConnectHelloWorld(virConnectPtr conn, char **printout)</span><br><span class="line">&#123;</span><br><span class="line">    int rv = -1;</span><br><span class="line">    remote_connect_hello_world_ret ret;</span><br><span class="line">    struct private_data *priv = conn-&gt;privateData;</span><br><span class="line">    remoteDriverLock(priv);</span><br><span class="line">    memset(&amp;ret, 0, sizeof(ret));</span><br><span class="line">    if (call(conn, priv, 0, REMOTE_PROC_CONNECT_HELLO_WORLD,</span><br><span class="line">            (xdrproc_t) xdr_void,</span><br><span class="line">            (char *) NULL,</span><br><span class="line">            (xdrproc_t) xdr_remote_connect_hello_world_ret,</span><br><span class="line">            (char *) &amp;ret) == -1)</span><br><span class="line">        goto done;</span><br><span class="line">    if (ret.printout == NULL)</span><br><span class="line">        goto error;</span><br><span class="line">    *printout = ret.printout;</span><br><span class="line">    rv = 0;</span><br><span class="line">done:</span><br><span class="line">    remoteDriverUnlock(priv);</span><br><span class="line">    return rv;</span><br><span class="line">error:</span><br><span class="line">    rv = -1;</span><br><span class="line">    goto done;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static virHypervisorDriver hypervisor_driver = &#123;</span><br><span class="line">    ...</span><br><span class="line">    .connectHelloWorld = remoteConnectHelloWorld, /* 7.3.0 */</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>函数的开头使用了 RPC 请求的返回值结构体 <code>remote_connect_hello_world_ret</code>，这个结构体的定义是自动生成的，模板会在 <code>remote_protocol.x</code> 中给出。</p><p>call 函数中的入参 <code>REMOTE_PROC_CONNECT_HELLO_WORLD</code> 是RPC 请求调用号。也是在 <code>remote_protocol.x</code> 中添加。</p><p>最后从 <code>ret.printout</code> 取出来自 libvirtd 返回的字符串。</p><p>注意: 给 <code>hypervisor_driver-&gt;connectHelloWorld</code> 赋值时, 后面的 <code>/* 7.3.0 */</code> 版本号必须要加上不然 <code>hvsupport.pl</code> 在执行的时候会报错。</p><h4 id="src-remote-remote-protocol-x"><a href="#src-remote-remote-protocol-x" class="headerlink" title="./src/remote/remote_protocol.x"></a>./src/remote/remote_protocol.x</h4><p>增添 <code>remote_connect_hello_world_ret</code> 的模板，并且在 <code>enum remote_procedure</code> 的枚举类型中给出 RPC 号的具体数值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct remote_connect_hello_world_ret &#123;</span><br><span class="line">    remote_nonnull_string printout;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">enum remote_procedure &#123;</span><br><span class="line">    /**</span><br><span class="line">    * @generate: none</span><br><span class="line">    * @acl: connect:read</span><br><span class="line">    */</span><br><span class="line">    REMOTE_PROC_CONNECT_HELLO_WORLD = 700</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="src-rpc-gendispatch-pl"><a href="#src-rpc-gendispatch-pl" class="headerlink" title="./src/rpc/gendispatch.pl"></a>./src/rpc/gendispatch.pl</h4><p>以上几个文件会被 <code>gendispatch.pl</code> 文件解析自动生成 <code>remote_protocol.h</code>，<code>remote_protocol.c</code> 和 <code>remote_daemon_dispatch_stubs.h</code> 文件。</p><p>这个文件在运行时会检查上面内容添加是否齐全。</p><h3 id="添加-RPC-server-端调用"><a href="#添加-RPC-server-端调用" class="headerlink" title="添加 RPC server 端调用"></a>添加 RPC server 端调用</h3><p>libvirtd 充当 RPC 调用的 server 端，<code>remoteDispatchConnectHelloWorld</code> 函数是由 libvirtd 执行的，作为 server 端的响应函数。</p><h4 id="src-remote-remote-daemon-dispatch-stubs-h"><a href="#src-remote-remote-daemon-dispatch-stubs-h" class="headerlink" title="src/remote/remote_daemon_dispatch_stubs.h"></a>src/remote/remote_daemon_dispatch_stubs.h</h4><p>增添了 <code>remote_protocol.x</code> 编译后系统会自动生成 <code>remote_dispatch.h</code> 文件，并自其中自动生成 server 端 RPC 处理函数：<code>remoteDispatchConnectHelloWorldHelper</code>。</p><p>同时 <code>remote_daemon_dispatch_stubs.h</code> 中会添加 <code>remoteDispatchConnectHelloWorld</code> 函数声明。</p><p><code>remoteDispatchConnectHelloWorld</code> 函数作为 RPC server 端的响应函数需要在 <code>remote_daemon_dispatch_stubs.h</code> 中自己手动实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">static int</span><br><span class="line">remoteDispatchConnectHelloWorld(virNetServerPtr server ATTRIBUTE_UNUSED,</span><br><span class="line">                            virNetServerClientPtr client ATTRIBUTE_UNUSED,</span><br><span class="line">                            virNetMessagePtr msg ATTRIBUTE_UNUSED,</span><br><span class="line">                            virNetMessageErrorPtr rerr,</span><br><span class="line">                            remote_connect_hello_world_ret *ret)</span><br><span class="line">&#123;</span><br><span class="line">    char *printout = NULL;</span><br><span class="line">    int rv = -1;</span><br><span class="line">    struct daemonClientPrivate *priv =</span><br><span class="line">    virNetServerClientGetPrivateData(client);</span><br><span class="line">    if (!priv-&gt;conn) &#123;</span><br><span class="line">        virReportError(VIR_ERR_INTERNAL_ERROR, &quot;%s&quot;, _(&quot;connection not open&quot;));</span><br><span class="line">        goto cleanup;</span><br><span class="line">    &#125;</span><br><span class="line">    rv = virConnectHelloWorld(priv-&gt;conn, &amp;printout);</span><br><span class="line">    if(rv &lt; 0)</span><br><span class="line">        goto cleanup;</span><br><span class="line">    ret-&gt;printout = printout;</span><br><span class="line">cleanup:</span><br><span class="line">    if (rv &lt; 0)</span><br><span class="line">        virNetMessageSaveError(rerr);</span><br><span class="line">    return rv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="src-qemu-qemu-driver-c"><a href="#src-qemu-qemu-driver-c" class="headerlink" title="src/qemu/qemu_driver.c"></a>src/qemu/qemu_driver.c</h4><p>libvirtd 是 RPC 的 server 端，<code>virConnectHelloWorld</code> 采用的 <code>connectHelloWorld</code> 回调函数与 RPC clinet 端不同。</p><p>这里要新添加一个 <code>qemuConnectHelloWorld</code> 函数作为 RPC server 端的处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static int qemuConnectHelloWorld(virConnectPtr conn, char **printout)</span><br><span class="line">&#123;</span><br><span class="line">    if(VIR_STRDUP(*printout, &quot;hello, world&quot;) &lt; 0)</span><br><span class="line">        return -1;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static virHypervisorDriver qemuHypervisorDriver = &#123;</span><br><span class="line">    ...</span><br><span class="line">    .connectHelloWorld = qemuConnectHelloWorld, /* 7.3.0 */</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行结果-1"><a href="#执行结果-1" class="headerlink" title="执行结果"></a>执行结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># virsh helloworld --local</span><br><span class="line">hello, world</span><br></pre></td></tr></table></figure><p>执行结果与第 3 节一样，但不同的是这次的 “hello, world” 是 virsh 命令通过 RPC 调用从 libvirtd 守护进程中拿过来的。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;libvirt-简介&quot;&gt;&lt;a href=&quot;#libvirt-简介&quot; class=&quot;headerlink&quot; title=&quot;libvirt 简介&quot;&gt;&lt;/a&gt;libvirt 简介&lt;/h2&gt;&lt;p&gt;libvirt 是用于管理虚拟化平台的开源API、后台程序和管理工具。&lt;/p&gt;</summary>
    
    
    
    <category term="LIBVIRT" scheme="https://rma-shuyu.github.io/categories/LIBVIRT/"/>
    
    
    <category term="virsh" scheme="https://rma-shuyu.github.io/tags/virsh/"/>
    
  </entry>
  
  <entry>
    <title>systemd详解</title>
    <link href="https://rma-shuyu.github.io/2022/07/01/systemd%E8%AF%A6%E8%A7%A3/"/>
    <id>https://rma-shuyu.github.io/2022/07/01/systemd%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-07-01T10:55:44.000Z</published>
    <updated>2023-10-21T07:21:41.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、开机启动"><a href="#一、开机启动" class="headerlink" title="一、开机启动"></a>一、开机启动</h2><p>对于那些支持 Systemd 的软件，安装的时候，会自动在<code>/usr/lib/systemd/system</code>目录添加一个配置文件。</p><p>如果你想让该软件开机启动，就执行下面的命令（以<code>httpd.service</code>为例）。</p><span id="more"></span><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ sudo systemctl enable httpd</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><p>上面的命令相当于在<code>/etc/systemd/system</code>目录添加一个符号链接，指向<code>/usr/lib/systemd/system</code>里面的<code>httpd.service</code>文件。</p><p>这是因为开机时，<code>Systemd</code>只执行<code>/etc/systemd/system</code>目录里面的配置文件。这也意味着，如果把修改后的配置文件放在该目录，就可以达到覆盖原始配置的效果。</p><h2 id="二、启动服务"><a href="#二、启动服务" class="headerlink" title="二、启动服务"></a>二、启动服务</h2><p>设置开机启动以后，软件并不会立即启动，必须等到下一次开机。如果想现在就运行该软件，那么要执行<code>systemctl start</code>命令。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ sudo systemctl start httpd</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><p>执行上面的命令以后，有可能启动失败，因此要用<code>systemctl status</code>命令查看一下该服务的状态。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ sudo systemctl status httpd</span><br><span class="line"></span><br><span class="line">httpd.service - The Apache HTTP Server</span><br><span class="line">   Loaded: loaded (/usr/lib/systemd/system/httpd.service; enabled)</span><br><span class="line">   Active: active (running) since 金 2014-12-05 12:18:22 JST; 7min ago</span><br><span class="line"> Main PID: 4349 (httpd)</span><br><span class="line">   Status: &quot;Total requests: 1; Current requests/sec: 0; Current traffic:   0 B/sec&quot;</span><br><span class="line">   CGroup: /system.slice/httpd.service</span><br><span class="line">           ├─4349 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           ├─4350 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           ├─4351 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           ├─4352 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           ├─4353 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line">           └─4354 /usr/sbin/httpd -DFOREGROUND</span><br><span class="line"></span><br><span class="line">12月 05 12:18:22 localhost.localdomain systemd[1]: Starting The Apache HTTP Server...</span><br><span class="line">12月 05 12:18:22 localhost.localdomain systemd[1]: Started The Apache HTTP Server.</span><br><span class="line">12月 05 12:22:40 localhost.localdomain systemd[1]: Started The Apache HTTP Server.</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><p>上面的输出结果含义如下。</p><blockquote><ul><li>  <code>Loaded</code>行：配置文件的位置，是否设为开机启动</li><li>  <code>Active</code>行：表示正在运行</li><li>  <code>Main PID</code>行：主进程ID</li><li>  <code>Status</code>行：由应用本身（这里是 httpd ）提供的软件当前状态</li><li>  <code>CGroup</code>块：应用的所有子进程</li><li>  日志块：应用的日志</li></ul></blockquote><h2 id="三、停止服务"><a href="#三、停止服务" class="headerlink" title="三、停止服务"></a>三、停止服务</h2><p>终止正在运行的服务，需要执行<code>systemctl stop</code>命令。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ sudo systemctl stop httpd.service</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><p>有时候，该命令可能没有响应，服务停不下来。这时候就不得不”杀进程”了，向正在运行的进程发出<code>kill</code>信号。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ sudo systemctl kill httpd.service</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><p>此外，重启服务要执行<code>systemctl restart</code>命令。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ sudo systemctl restart httpd.service</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h2 id="四、读懂配置文件"><a href="#四、读懂配置文件" class="headerlink" title="四、读懂配置文件"></a>四、读懂配置文件</h2><p>一个服务怎么启动，完全由它的配置文件决定。下面就来看，配置文件有些什么内容。</p><p>前面说过，配置文件主要放在<code>/usr/lib/systemd/system</code>目录，也可能在<code>/etc/systemd/system</code>目录。找到配置文件以后，使用文本编辑器打开即可。</p><p><code>systemctl cat</code>命令可以用来查看配置文件，下面以<code>sshd.service</code>文件为例，它的作用是启动一个 SSH 服务器，供其他用户以 SSH 方式登录。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ systemctl cat sshd.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=OpenSSH server daemon</span><br><span class="line">Documentation=man:sshd(8) man:sshd_config(5)</span><br><span class="line">After=network.target sshd-keygen.service</span><br><span class="line">Wants=sshd-keygen.service</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">EnvironmentFile=/etc/sysconfig/sshd</span><br><span class="line">ExecStart=/usr/sbin/sshd -D $OPTIONS</span><br><span class="line">ExecReload=/bin/kill -HUP $MAINPID</span><br><span class="line">Type=simple</span><br><span class="line">KillMode=process</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=42s</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><p>可以看到，配置文件分成几个区块，每个区块包含若干条键值对。</p><p>下面依次解释每个区块的内容。</p><h2 id="五、-Unit-区块：启动顺序与依赖关系。"><a href="#五、-Unit-区块：启动顺序与依赖关系。" class="headerlink" title="五、 [Unit] 区块：启动顺序与依赖关系。"></a>五、 [Unit] 区块：启动顺序与依赖关系。</h2><p><code>Unit</code>区块的<code>Description</code>字段给出当前服务的简单描述，<code>Documentation</code>字段给出文档位置。</p><p>接下来的设置是启动顺序和依赖关系，这个比较重要。</p><blockquote><p><code>After</code>字段：表示如果<code>network.target</code>或<code>sshd-keygen.service</code>需要启动，那么<code>sshd.service</code>应该在它们之后启动。</p></blockquote><p>相应地，还有一个<code>Before</code>字段，定义<code>sshd.service</code>应该在哪些服务之前启动。</p><p>注意，<code>After</code>和<code>Before</code>字段只涉及启动顺序，不涉及依赖关系。</p><p>举例来说，某 Web 应用需要 postgresql 数据库储存数据。在配置文件中，它只定义要在 postgresql 之后启动，而没有定义依赖 postgresql 。上线后，由于某种原因，postgresql 需要重新启动，在停止服务期间，该 Web 应用就会无法建立数据库连接。</p><p>设置依赖关系，需要使用<code>Wants</code>字段和<code>Requires</code>字段。</p><blockquote><p><code>Wants</code>字段：表示<code>sshd.service</code>与<code>sshd-keygen.service</code>之间存在”弱依赖”关系，即如果”sshd-keygen.service”启动失败或停止运行，不影响<code>sshd.service</code>继续执行。</p></blockquote><p><code>Requires</code>字段则表示”强依赖”关系，即如果该服务启动失败或异常退出，那么<code>sshd.service</code>也必须退出。</p><p>注意，<code>Wants</code>字段与<code>Requires</code>字段只涉及依赖关系，与启动顺序无关，默认情况下是同时启动的。</p><h2 id="六、-Service-区块：启动行为"><a href="#六、-Service-区块：启动行为" class="headerlink" title="六、[Service] 区块：启动行为"></a>六、[Service] 区块：启动行为</h2><p><code>Service</code>区块定义如何启动当前服务。</p><h3 id="6-1-启动命令"><a href="#6-1-启动命令" class="headerlink" title="6.1 启动命令"></a>6.1 启动命令</h3><p>许多软件都有自己的环境参数文件，该文件可以用<code>EnvironmentFile</code>字段读取。</p><blockquote><p><code>EnvironmentFile</code>字段：指定当前服务的环境参数文件。该文件内部的<code>key=value</code>键值对，可以用<code>$key</code>的形式，在当前配置文件中获取。</p></blockquote><p>上面的例子中，sshd 的环境参数文件是<code>/etc/sysconfig/sshd</code>。</p><p>配置文件里面最重要的字段是<code>ExecStart</code>。</p><blockquote><p><code>ExecStart</code>字段：定义启动进程时执行的命令。</p></blockquote><p>上面的例子中，启动<code>sshd</code>，执行的命令是<code>/usr/sbin/sshd -D $OPTIONS</code>，其中的变量<code>$OPTIONS</code>就来自<code>EnvironmentFile</code>字段指定的环境参数文件。</p><p>与之作用相似的，还有如下这些字段。</p><blockquote><ul><li>  <code>ExecReload</code>字段：重启服务时执行的命令</li><li>  <code>ExecStop</code>字段：停止服务时执行的命令</li><li>  <code>ExecStartPre</code>字段：启动服务之前执行的命令</li><li>  <code>ExecStartPost</code>字段：启动服务之后执行的命令</li><li>  <code>ExecStopPost</code>字段：停止服务之后执行的命令</li></ul></blockquote><p>请看下面的例子。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/bin/echo execstart1</span><br><span class="line">ExecStart=</span><br><span class="line">ExecStart=/bin/echo execstart2</span><br><span class="line">ExecStartPost=/bin/echo post1</span><br><span class="line">ExecStartPost=/bin/echo post2</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><p>上面这个配置文件，第二行<code>ExecStart</code>设为空值，等于取消了第一行的设置，运行结果如下。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">execstart2</span><br><span class="line">post1</span><br><span class="line">post2</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><p>所有的启动设置之前，都可以加上一个连词号（<code>-</code>），表示”抑制错误”，即发生错误的时候，不影响其他命令的执行。比如，<code>EnvironmentFile=-/etc/sysconfig/sshd</code>（注意等号后面的那个连词号），就表示即使<code>/etc/sysconfig/sshd</code>文件不存在，也不会抛出错误。</p><h3 id="6-2-启动类型"><a href="#6-2-启动类型" class="headerlink" title="6.2 启动类型"></a>6.2 启动类型</h3><p><code>Type</code>字段定义启动类型。它可以设置的值如下。</p><blockquote><ul><li>  simple（默认值）：<code>ExecStart</code>字段启动的进程为主进程</li><li>  forking：<code>ExecStart</code>字段将以<code>fork()</code>方式启动，此时父进程将会退出，子进程将成为主进程</li><li>  oneshot：类似于<code>simple</code>，但只执行一次，Systemd 会等它执行完，才启动其他服务</li><li>  dbus：类似于<code>simple</code>，但会等待 D-Bus 信号后启动</li><li>  notify：类似于<code>simple</code>，启动结束后会发出通知信号，然后 Systemd 再启动其他服务</li><li>  idle：类似于<code>simple</code>，但是要等到其他任务都执行完，才会启动该服务。一种使用场合是为让该服务的输出，不与其他服务的输出相混合</li></ul></blockquote><p>下面是一个<code>oneshot</code>的例子，笔记本电脑启动时，要把触摸板关掉，配置文件可以这样写。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Switch-off Touchpad</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=oneshot</span><br><span class="line">ExecStart=/usr/bin/touchpad-off</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><p>上面的配置文件，启动类型设为<code>oneshot</code>，就表明这个服务只要运行一次就够了，不需要长期运行。</p><p>如果关闭以后，将来某个时候还想打开，配置文件修改如下。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Switch-off Touchpad</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=oneshot</span><br><span class="line">ExecStart=/usr/bin/touchpad-off start</span><br><span class="line">ExecStop=/usr/bin/touchpad-off stop</span><br><span class="line">RemainAfterExit=yes</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><p>上面配置文件中，<code>RemainAfterExit</code>字段设为<code>yes</code>，表示进程退出以后，服务仍然保持执行。这样的话，一旦使用<code>systemctl stop</code>命令停止服务，<code>ExecStop</code>指定的命令就会执行，从而重新开启触摸板。</p><h3 id="6-3-重启行为"><a href="#6-3-重启行为" class="headerlink" title="6.3 重启行为"></a>6.3 重启行为</h3><p><code>Service</code>区块有一些字段，定义了重启行为。</p><blockquote><p><code>KillMode</code>字段：定义 Systemd 如何停止 sshd 服务。</p></blockquote><p>上面这个例子中，将<code>KillMode</code>设为<code>process</code>，表示只停止主进程，不停止任何sshd 子进程，即子进程打开的 SSH session 仍然保持连接。这个设置不太常见，但对 sshd 很重要，否则你停止服务的时候，会连自己打开的 SSH session 一起杀掉。</p><p><code>KillMode</code>字段可以设置的值如下。</p><blockquote><ul><li>  control-group（默认值）：当前控制组里面的所有子进程，都会被杀掉</li><li>  process：只杀主进程</li><li>  mixed：主进程将收到 SIGTERM 信号，子进程收到 SIGKILL 信号</li><li>  none：没有进程会被杀掉，只是执行服务的 stop 命令。</li></ul></blockquote><p>接下来是<code>Restart</code>字段。</p><blockquote><p><code>Restart</code>字段：定义了 sshd 退出后，Systemd 的重启方式。</p></blockquote><p>上面的例子中，<code>Restart</code>设为<code>on-failure</code>，表示任何意外的失败，就将重启sshd。如果 sshd 正常停止（比如执行<code>systemctl stop</code>命令），它就不会重启。</p><p><code>Restart</code>字段可以设置的值如下。</p><blockquote><ul><li>  no（默认值）：退出后不会重启</li><li>  on-success：只有正常退出时（退出状态码为0），才会重启</li><li>  on-failure：非正常退出时（退出状态码非0），包括被信号终止和超时，才会重启</li><li>  on-abnormal：只有被信号终止和超时，才会重启</li><li>  on-abort：只有在收到没有捕捉到的信号终止时，才会重启</li><li>  on-watchdog：超时退出，才会重启</li><li>  always：不管是什么退出原因，总是重启</li></ul></blockquote><p>对于守护进程，推荐设为<code>on-failure</code>。对于那些允许发生错误退出的服务，可以设为<code>on-abnormal</code>。</p><p>最后是<code>RestartSec</code>字段。</p><blockquote><p><code>RestartSec</code>字段：表示 Systemd 重启服务之前，需要等待的秒数。上面的例子设为等待42秒。</p></blockquote><h2 id="七、-Install-区块"><a href="#七、-Install-区块" class="headerlink" title="七、[Install] 区块"></a>七、[Install] 区块</h2><p><code>Install</code>区块，定义如何安装这个配置文件，即怎样做到开机启动。</p><blockquote><p><code>WantedBy</code>字段：表示该服务所在的 Target。</p></blockquote><p><code>Target</code>的含义是服务组，表示一组服务。<code>WantedBy=multi-user.target</code>指的是，sshd 所在的 Target 是<code>multi-user.target</code>。</p><p>这个设置非常重要，因为执行<code>systemctl enable sshd.service</code>命令时，<code>sshd.service</code>的一个符号链接，就会放在<code>/etc/systemd/system</code>目录下面的<code>multi-user.target.wants</code>子目录之中。</p><p>Systemd 有默认的启动 Target。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ systemctl get-default</span><br><span class="line">multi-user.target</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><p>上面的结果表示，默认的启动 Target 是<code>multi-user.target</code>。在这个组里的所有服务，都将开机启动。这就是为什么<code>systemctl enable</code>命令能设置开机启动的原因。</p><p>使用 Target 的时候，<code>systemctl list-dependencies</code>命令和<code>systemctl isolate</code>命令也很有用。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 查看 multi-user.target 包含的所有服务</span><br><span class="line">$ systemctl list-dependencies multi-user.target</span><br><span class="line"></span><br><span class="line"># 切换到另一个 target</span><br><span class="line"># shutdown.target 就是关机状态</span><br><span class="line">$ sudo systemctl isolate shutdown.target</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><p>一般来说，常用的 Target 有两个：一个是<code>multi-user.target</code>，表示多用户命令行状态；另一个是<code>graphical.target</code>，表示图形用户状态，它依赖于<code>multi-user.target</code>。官方文档有一张非常清晰的 <a href="https://www.freedesktop.org/software/systemd/man/bootup.html#System%20Manager%20Bootup">Target 依赖关系图</a>。</p><h2 id="八、Target-的配置文件"><a href="#八、Target-的配置文件" class="headerlink" title="八、Target 的配置文件"></a>八、Target 的配置文件</h2><p>Target 也有自己的配置文件。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ systemctl cat multi-user.target</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Multi-User System</span><br><span class="line">Documentation=man:systemd.special(7)</span><br><span class="line">Requires=basic.target</span><br><span class="line">Conflicts=rescue.service rescue.target</span><br><span class="line">After=basic.target rescue.service rescue.target</span><br><span class="line">AllowIsolate=yes</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><p>注意，Target 配置文件里面没有启动命令。</p><p>上面输出结果中，主要字段含义如下。</p><blockquote><p><code>Requires</code>字段：要求<code>basic.target</code>一起运行。</p><p><code>Conflicts</code>字段：冲突字段。如果<code>rescue.service</code>或<code>rescue.target</code>正在运行，<code>multi-user.target</code>就不能运行，反之亦然。</p><p><code>After</code>：表示<code>multi-user.target</code>在<code>basic.target</code> 、 <code>rescue.service</code>、 <code>rescue.target</code>之后启动，如果它们有启动的话。</p><p><code>AllowIsolate</code>：允许使用<code>systemctl isolate</code>命令切换到<code>multi-user.target</code>。</p></blockquote><h2 id="九、修改配置文件后重启"><a href="#九、修改配置文件后重启" class="headerlink" title="九、修改配置文件后重启"></a>九、修改配置文件后重启</h2><p>修改配置文件以后，需要重新加载配置文件，然后重新启动相关服务。</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 重新加载配置文件</span><br><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line"></span><br><span class="line"># 重启相关服务</span><br><span class="line">$ sudo systemctl restart foobar</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、开机启动&quot;&gt;&lt;a href=&quot;#一、开机启动&quot; class=&quot;headerlink&quot; title=&quot;一、开机启动&quot;&gt;&lt;/a&gt;一、开机启动&lt;/h2&gt;&lt;p&gt;对于那些支持 Systemd 的软件，安装的时候，会自动在&lt;code&gt;/usr/lib/systemd/system&lt;/code&gt;目录添加一个配置文件。&lt;/p&gt;
&lt;p&gt;如果你想让该软件开机启动，就执行下面的命令（以&lt;code&gt;httpd.service&lt;/code&gt;为例）。&lt;/p&gt;</summary>
    
    
    
    <category term="LINUX" scheme="https://rma-shuyu.github.io/categories/LINUX/"/>
    
    
    <category term="systemd" scheme="https://rma-shuyu.github.io/tags/systemd/"/>
    
  </entry>
  
  <entry>
    <title>OpenStack断点调试</title>
    <link href="https://rma-shuyu.github.io/2022/06/30/OpenStack%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95/"/>
    <id>https://rma-shuyu.github.io/2022/06/30/OpenStack%E6%96%AD%E7%82%B9%E8%B0%83%E8%AF%95/</id>
    <published>2022-06-30T10:55:44.000Z</published>
    <updated>2023-10-21T07:21:41.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OpenStack断点调试方法总结"><a href="#OpenStack断点调试方法总结" class="headerlink" title="OpenStack断点调试方法总结"></a>OpenStack断点调试方法总结</h1><p>关于断点调试</p><p>断点是调试应用程序最主要的方式之一，通过设置断点，可以实现单步执行代码，检查变量的值以及跟踪调用栈，甚至修改进程的内存变量值或者运行代码，从而观察修改后的程序行为。</p><span id="more"></span><p>大多数的调试器都是通过ptrace系统调用控制和监视进程状态，通过INT 3软件中断实现断点。当我们在代码中插入一个断点时，其实就是调试器找到指令位置（编译成机器码后的位置）嵌入一个INT 3指令，进程运行时遇到INT 3指令时，操作系统就会将该进程暂停，并发送一个SIGTRAP信号，此时调试器接收到进程的停止信号，通过ptrace查看进程状态，并通过标准输入输出与用户交互，更多关于断点和调试信息实现原理可以参考国外的一篇文章How debuggers work【1】，这里只需要注意调试器是通过标准输入输出(stdin、stdout)与用户交互的。</p><p>目前主流的调试工具如gdb、jdb以及针对Python语言的pdb等。本文接下来主要介绍的是针对OpenStack的一些调试方法，这些方法不仅适用于OpenStack，其他Python程序同样适用。</p><p>02</p><p>Python调试工具介绍</p><p>Python主要使用pdb工具进行调试，用法也很简单，只要在需要打断点的位置嵌入pdb.set_trace()代码即可。</p><p>比如如下Python代码：</p><p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20211229_7fea0838-684a-11ec-9ad6-fa163eb4f6be.png"></p><p>该代码相当于在say()函数第一行嵌入了一个断点，当代码执行到该函数时，会立即停止，此时可以通过pdb执行各种指令，比如查看代码、查看变量值以及调用栈等，如下：</p><p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20211229_801f9cfa-684a-11ec-9ad6-fa163eb4f6be.png"></p><p>当然你也可以使用ipdb替换pdb，界面更友好，支持语法高亮以及命令自动补全，使用体验类似于ipython,如图2-1：</p><p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20211229_804b45a8-684a-11ec-9ad6-fa163eb4f6be.png"></p><p>图2-1 ipdb界面</p><p>或者也可以使用功能更强大的ptpdb工具，支持多屏以及更强大的命令补全，如图2-2：</p><p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20211229_808be2a2-684a-11ec-9ad6-fa163eb4f6be.png"></p><p>图2-2 ptpdb界面</p><p>最上面为pdb指令输入框，左下为代码执行位置，右下为当前调用栈。</p><p>以上三个工具的pdb指令都是一样的，基本都是pdb工具的包装，详细的使用方法可以查看官方文档【2】或者Google相关资料，这里不对pdb命令进行过多介绍。</p><p>03</p><p>OpenStack常规调试方法</p><p>OpenStack断点调试是学习OpenStack工作流程的最佳方式之一，关于OpenStack源码结构可以参考我之前的一篇文章《如何阅读OpenStack源码》【3】。我们知道OpenStack是基于Python语言开发的，因此自然可以使用如上介绍的pdb工具进行断点调试。</p><p>比如，我想了解OpenStack Nova是如何调用Libvirt Driver创建虚拟机的，只需要在nova/virt/libvirt/driver.py模块的spawn()方法打上断点：</p><p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20211229_80aa27ee-684a-11ec-9ad6-fa163eb4f6be.png"></p><p>然后停止nova-compute服务，使用命令行手动运行nova-compute:  </p><p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20211229_80ed36b0-684a-11ec-9ad6-fa163eb4f6be.png"></p><p>在另外一个终端使用nova boot命令启动虚拟机，如果有多个计算节点，为了保证能够调度到打了断点的节点，建议把其他计算节点disable掉。</p><p>此时nova-compute会在spawn()方法处停止运行，此时可以通过pdb工具查看变量、单步执行等。</p><p>对于一些支持多线程多进程的OpenStack服务，为了方便调试，我一般会把verbose选项以及debug设置为False，避免打印太多的干扰信息，并把服务的workers数调成1，防止多个线程断点同时进入导致调试错乱。</p><p>比如调试nova-api服务，我会把osapi_compute_workers配置项临时设置为1。</p><p>通过如上调试方法，基本可以完成大多数的OpenStack服务调试，但并不能覆盖全部服务，某些OpenStack服务不能直接使用pdb进行调试，比如Keystone、Swift等某些组件，此部分内容将在下一节中进行详细介绍。</p><p>04</p><p>OpenStack不能直接使用pdb调试的情况</p><p>我们前面提到能够调试的前提是终端能够与进程的stdin、stdout直接交互，对于某些不能交互的情况，则必然不能直接通过pdb进行调试。主要包括如下几种情况：</p><p><strong>4.1 进程关闭了stdin/stdout</strong></p><p>cloud-init就是最经典的案例，在cloudinit/cmd/main.py的入口函数main_init()调用了close_stdin()方法关闭stdin，如下：</p><p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20211229_8144de9c-684a-11ec-9ad6-fa163eb4f6be.png"></p><p>close_stdin()方法实现如下：</p><p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20211229_81707e4e-684a-11ec-9ad6-fa163eb4f6be.png"></p><p>相当于把stdin重定向到/dev/null了。因此当我们在cloud-init打上断点时，并不会弹出pdb调试页面，而是直接抛出异常。</p><p>比如制作镜像时经常出现cloud-init修改密码失败，于是需要断点调试，我们在cloudinit/config/cc_set_passwords.py模块的handle()方法打上断点，结果pdb直接异常退出，从/var/log/cloud-init.log中可以看到如下错误信息：</p><p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20211229_81b00262-684a-11ec-9ad6-fa163eb4f6be.png"></p><p>我们从close_stdin()以及redirect_output方法可以发现，我们可以通过设置_CLOUD_INIT_SAVE_STDIN以及_CLOUD_INIT_SAVE_STDOUT环境变量开放stdin/stdout，从而允许我们进入调试:</p><p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20211229_81dbfb42-684a-11ec-9ad6-fa163eb4f6be.png"></p><p>除了cloud-init，OpenStack Swift也类似，可以查看swift/common/utils.py模块的capture_stdio()方法，</p><p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20211229_8212cfa0-684a-11ec-9ad6-fa163eb4f6be.png"></p><p>因此account-server、container-server以及object-server均无法直接使用pdb调试。</p><p><strong>4.2 Fork多进程</strong></p><p>如果一个进程Fork了子进程，则子进程的stdin、stdout不能直接与终端交互。</p><p>最经典的场景就是OpenStack组件使用了cotyledon库而不是oslo_service库实现daemon。我们知道oslo_service使用eventlet库通过多线程实现并发，而cotyledon则使用了multiprocess库通过多进程实现并发，更多关于cotyledon的介绍可以参考官方文档【4】。</p><p>因此使用cotyledon实现的daemon服务不能通过pdb直接进行调试，比如Ceilometer的polling-agent以及Kuryr的kuryr-daemon服务等。</p><p>文章《使用pdb调试ceilometer代码》【5】提出通过实现一个新的类ForkedPdb重定向stdin的方法实现子进程调试，这种方法我本人没有尝试过，不知道是否可行。</p><p><strong>4.3 运行在Web服务器</strong></p><p>最经典的如Keystone服务以及Horizon服务，我们通常会把该服务运行在Apache服务器上，显然这种情况终端没法直接和Keystone的stdin、stdout进行交互，因此不能通过pdb直接调试。</p><p>05</p><p>如何解决不能使用pdb直接调试的问题</p><p>我们前面总结了几种不能使用pdb直接调试的情况，其根本原因就是终端无法和进程的stdin/stdout交互，因此我们解决的思路就是让终端与进程的stdin/stdout打通。</p><p>我们知道stdin以及stdout都是文件流，有没有其他的流呢？显然socket也是一种流。因此我们可以通过把stdin、stdout重定向到一个socket流中，从而实现远程调试。</p><p>定义如下方法，把stdin、stdout重定向到本地的一个TCP socket中，监听地址端口为1234:</p><p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20211229_8242db96-684a-11ec-9ad6-fa163eb4f6be.png"></p><p>当然我们也需要把pdb的stdin、stdout也重定向到该socket中，这样才能与pdb交互，用法如下：</p><p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20211229_827adbf4-684a-11ec-9ad6-fa163eb4f6be.png"></p><p>运行该程序后，使用另一个终端通过nc或者telnet连接1234端口即可进行调试，如图5-1：</p><p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20211229_82b4fece-684a-11ec-9ad6-fa163eb4f6be.png"></p><p>可见，通过这种方式可以实现远程调试，不过我们不用每次都写那么长一段代码，社区已经有实现了，只需要使用rpdb替换pdb即可进行远程调试，原理与之类似，默认监听的端口为4444。</p><p>比如调试Keystone的list_projects()方法:</p><p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20211229_82db57cc-684a-11ec-9ad6-fa163eb4f6be.png"></p><p>然后重启httpd服务，重启完毕调用project list API:</p><p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20211229_82f6af22-684a-11ec-9ad6-fa163eb4f6be.png"></p><p>如上openstack project list命令会hang住，此时通过nc或者telnet连接本地4444端口进行调试：</p><p><img src="https://oss-emcsprod-public.modb.pro/wechatSpider/modb_20211229_832673b0-684a-11ec-9ad6-fa163eb4f6be.png"></p><p>可见成功attach了pdb，此时可以像普通pdb一样进行单步调试了。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;OpenStack断点调试方法总结&quot;&gt;&lt;a href=&quot;#OpenStack断点调试方法总结&quot; class=&quot;headerlink&quot; title=&quot;OpenStack断点调试方法总结&quot;&gt;&lt;/a&gt;OpenStack断点调试方法总结&lt;/h1&gt;&lt;p&gt;关于断点调试&lt;/p&gt;
&lt;p&gt;断点是调试应用程序最主要的方式之一，通过设置断点，可以实现单步执行代码，检查变量的值以及跟踪调用栈，甚至修改进程的内存变量值或者运行代码，从而观察修改后的程序行为。&lt;/p&gt;</summary>
    
    
    
    <category term="openstack" scheme="https://rma-shuyu.github.io/categories/openstack/"/>
    
    
    <category term="pdb" scheme="https://rma-shuyu.github.io/tags/pdb/"/>
    
  </entry>
  
  <entry>
    <title>nova代码调用栈</title>
    <link href="https://rma-shuyu.github.io/2022/06/29/nova%E4%BB%A3%E7%A0%81%E8%B0%83%E7%94%A8%E6%A0%88/"/>
    <id>https://rma-shuyu.github.io/2022/06/29/nova%E4%BB%A3%E7%A0%81%E8%B0%83%E7%94%A8%E6%A0%88/</id>
    <published>2022-06-29T10:55:44.000Z</published>
    <updated>2023-10-21T07:21:41.639Z</updated>
    
    <content type="html"><![CDATA[<h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><p>dashboard或者命令行接口 restful接口create</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create                                                  # nova/api/openstack/compute/servers.py</span><br><span class="line">  _create_instance                                        # nova\compute\api.py</span><br></pre></td></tr></table></figure><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">schedule_and_build_instances                            # nova\conductor\manager.py</span><br><span class="line">  _schedule_instances                                     # nova\conductor\manager.py</span><br><span class="line">    select_destinations                             # nova\scheduler\manager.py</span><br><span class="line">  build_and_run_instance                                  # nova\compute\manager.py</span><br></pre></td></tr></table></figure><h2 id="compute"><a href="#compute" class="headerlink" title="compute"></a>compute</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">build_and_run_instance</span><br><span class="line">    _do_build_and_run_instance</span><br><span class="line">        _build_and_run_instance</span><br><span class="line">            _build_resources                            # compute/manage.py</span><br><span class="line">                _build_networks_for_instance            # compute/manage.py</span><br><span class="line">                    _allocate_network                   # computemanage.py</span><br><span class="line">                        _allocate_network_async         # compute/manage.py</span><br><span class="line">                            allocate_for_instance           # network/neutron.py</span><br><span class="line">                                _create_ports_for_instance  # network/neutron.py</span><br><span class="line">                                _update_ports_for_instance  # network/neutron.py</span><br><span class="line">                _prep_block_device                      # compute/manage.py</span><br><span class="line">                    attach_block_devices                    # virt/block_device.py</span><br><span class="line">                        DriverVolumeBlockDevice.attach      # virt/block_device.py</span><br><span class="line">                            _do_attach                      # virt/block_device.py</span><br><span class="line">                                _volume_attach              # virt/block_device.py</span><br><span class="line">                                    attachment_update       # volume/cinder.py</span><br><span class="line">                                        cinderclient        # volume/cinder.py</span><br><span class="line">                                    attach_volume           # virt/driver.py, virt/libvirt/driver.py</span><br><span class="line">                                        _connect_volume     # virt/driver.py, virt/libvirt/driver.py</span><br><span class="line">            driver.spawn                                # compute/manage.py -&gt; virt/libvirt/driver.py</span><br><span class="line">                _get_guest_xml                              # virt/libvirt/driver.py</span><br><span class="line">                    _get_guest_config                       # virt/libvirt/driver.py</span><br><span class="line">                        _get_guest_storage_config           # virt/libvirt/driver.py</span><br><span class="line">                            _connect_volume                 # virt/libvirt/driver.py</span><br><span class="line">                            _get_volume_config              # virt/libvirt/driver.py</span><br><span class="line">                                _get_volume_driver          # virt/libvirt/driver.py</span><br><span class="line">                                    vhostuser               # virt/libvirt/volume/vhostuser.py</span><br><span class="line">                    conf.to_xml                             # virt/libvirt/config.py</span><br><span class="line">                _create_guest_with_network                  # virt/libvirt/driver.py</span><br><span class="line">                    plug_vifs                               # virt/libvirt/driver.py</span><br><span class="line">                        vif_driver.plug                     # virt/libvirt/vif.py</span><br><span class="line">                            _plug_os_vif                    # virt/libvirt/vif.py</span><br><span class="line">                                os_vif.plug</span><br><span class="line">                                    vif_plug_ovs.ovs.plug</span><br><span class="line">                                        _plug_vhostuser</span><br><span class="line">                                            _create_vif_port</span><br><span class="line">                                                create_ovs_vif_port</span><br><span class="line">                                                    update_device_mtu</span><br><span class="line">                                                        _set_mtu_request</span><br><span class="line">                                                            ovsdb.db_set</span><br><span class="line">                    _create_guest</span><br><span class="line">                        libvirt_guest.Guest.create</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;入口&quot;&gt;&lt;a href=&quot;#入口&quot; class=&quot;headerlink&quot; title=&quot;入口&quot;&gt;&lt;/a&gt;入口&lt;/h2&gt;&lt;p&gt;dashboard或者命令行接口 restful接口create&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;create                                                  # nova/api/openstack/compute/servers.py&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  _create_instance                                        # nova\compute\api.py&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="openstack" scheme="https://rma-shuyu.github.io/categories/openstack/"/>
    
    
    <category term="nova" scheme="https://rma-shuyu.github.io/tags/nova/"/>
    
  </entry>
  
  <entry>
    <title>docker私有仓库</title>
    <link href="https://rma-shuyu.github.io/2022/06/28/docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/"/>
    <id>https://rma-shuyu.github.io/2022/06/28/docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/</id>
    <published>2022-06-28T12:25:15.000Z</published>
    <updated>2023-09-09T10:33:02.408Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="一、关于Registry"><a href="#一、关于Registry" class="headerlink" title="一、关于Registry"></a>一、关于Registry</h2><p>官方的Docker hub是一个用于管理公共镜像的好地方，我们可以在上面找到我们想要的镜像，也可以把我们自己的镜像推送上去。</p><span id="more"></span><p>但是有时候我们的使用场景需要我们拥有一个私有的镜像仓库用于管理我们自己的镜像。这个可以通过开源软件Registry来达成目的。</p><p> Registry在github上有两份代码：老代码库和新代码库。老代码是采用python编写的，存在pull和push的性能问题，出到0.9.1版本之后就标志为deprecated，不再继续开发。</p><p> 从2.0版本开始就到在新代码库进行开发，新代码库是采用go语言编写，修改了镜像id的生成算法、registry上镜像的保存结构，大大优化了pull和push镜像的效率。</p><p> 官方在Docker hub上提供了registry的镜像，我们可以直接使用该registry镜像来构建一个容器，搭建我们自己的私有仓库服务。</p><hr><h2 id="二、搭建Registry"><a href="#二、搭建Registry" class="headerlink" title="二、搭建Registry"></a>二、搭建Registry</h2><h4 id="首先搜索并拉取镜像"><a href="#首先搜索并拉取镜像" class="headerlink" title="首先搜索并拉取镜像"></a>首先搜索并拉取镜像</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker search registry　　　　# 建议先搜索一下，可以看一下相关的镜像，说不定哪天就有更好的镜像了</span><br><span class="line">docker pull registry　　　　# 标签可以不加，因为当前最新就是v2</span><br></pre></td></tr></table></figure><h4 id="运行一个registry容器"><a href="#运行一个registry容器" class="headerlink" title="运行一个registry容器"></a>运行一个registry容器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \\            # 后台运行</span><br><span class="line">--name registry-srv \\    # 指定容器名</span><br><span class="line">--restart=always \\        # 设置自动启动</span><br><span class="line">-p 5000:5000 \\            # 端口映射宿主机，通过宿主机地址访问</span><br><span class="line">-v /opt/zwx-registry:/var/lib/registry \\     # 把镜像存储目录挂载到本地，方便管理和持久化</span><br><span class="line">-v /opt/zwx-registry/srv-config.yml:/etc/docker/registry/config.yml \\    # 把配置文件挂载到本地，方便修改和保存</span><br><span class="line">registry</span><br></pre></td></tr></table></figure><h4 id="srv-config-yml内容如下"><a href="#srv-config-yml内容如下" class="headerlink" title="srv-config.yml内容如下"></a>srv-config.yml内容如下</h4><p>　　标红delete参数设置为true，是为了让仓库支持删除功能。默认没有这个参数，也就是不能删除仓库镜像。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">version: 0.1</span><br><span class="line">log:</span><br><span class="line">  fields:</span><br><span class="line">    service: registry</span><br><span class="line">storage:</span><br><span class="line">  **delete:</span><br><span class="line">    enabled:** **true**</span><br><span class="line">  cache:</span><br><span class="line">    blobdescriptor: inmemory</span><br><span class="line">  filesystem:</span><br><span class="line">    rootdirectory: /var/lib/registry</span><br><span class="line">http:</span><br><span class="line">  addr: :5000</span><br><span class="line">  headers:</span><br><span class="line">    X-Content-Type-Options: [nosniff]</span><br><span class="line">health:</span><br><span class="line">  storagedriver:</span><br><span class="line">    enabled: true</span><br><span class="line">    interval: 10s</span><br><span class="line">    threshold: 3</span><br></pre></td></tr></table></figure><h4 id="注册https协议（否则push安全认证过不去）"><a href="#注册https协议（否则push安全认证过不去）" class="headerlink" title="注册https协议（否则push安全认证过不去）"></a>注册https协议（否则push安全认证过不去）</h4><p>　　需要通过本地仓库下载镜像，均需要配置　　</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/docker/daemon.json　　　　　　　　# 默认无此文件，需自行添加，有则追加以下内容。</span><br><span class="line">&#123; &quot;insecure-registries&quot;:[&quot;xx.xx.xx.xx:5000&quot;] &#125;　　# 指定IP地址或域名</span><br><span class="line">systemctl daemon-reload    # 守护进程重启</span><br><span class="line">systemctl restart docker    # 重启docker服务</span><br></pre></td></tr></table></figure><h4 id="镜像上传与下载"><a href="#镜像上传与下载" class="headerlink" title="镜像上传与下载"></a>镜像上传与下载</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker push xx.xx.xx.xx:5000/nginx            # 一定要注明仓库地址，否则会报错</span><br><span class="line">docker pull xx.xx.xx.xx:5000/nginx</span><br></pre></td></tr></table></figure><h4 id="查看仓库镜像信息"><a href="#查看仓库镜像信息" class="headerlink" title="查看仓库镜像信息"></a>查看仓库镜像信息</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查看仓库镜像列表（也可以通过windows浏览器打开查看）</span><br><span class="line">curl -XGET http://xx.xx.xx.xx:5000/v2/_catalog</span><br><span class="line"></span><br><span class="line"># 查看指定应用镜像tag</span><br><span class="line">curl -XGET http://xx.xx.xx.xx:5000/v2/image_name/tags/list</span><br></pre></td></tr></table></figure><hr><h2 id="三、搭建Registry-web"><a href="#三、搭建Registry-web" class="headerlink" title="三、搭建Registry web"></a>三、搭建Registry web</h2><h4 id="首先搜索并拉取镜像-1"><a href="#首先搜索并拉取镜像-1" class="headerlink" title="首先搜索并拉取镜像"></a>首先搜索并拉取镜像</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker search docker-registry-web</span><br><span class="line">docker pull hyper/docker-registry-web　　　　# 这个镜像用的人较多</span><br></pre></td></tr></table></figure><h4 id="运行一个registry-web容器"><a href="#运行一个registry-web容器" class="headerlink" title="运行一个registry web容器"></a>运行一个registry web容器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \\            # 后台运行</span><br><span class="line">--name registry-web \\    # 指定容器名</span><br><span class="line">--restart=always \\        # 设置自动启动</span><br><span class="line">-p 8000:8080 \\            # 端口映射宿主机，通过宿主机地址访问</span><br><span class="line">-v /opt/zwx-registry/web-config.yml:/conf/config.yml \\    # 把配置文件挂载到本地，方便修改和保存</span><br><span class="line">hyper/docker-registry-web</span><br></pre></td></tr></table></figure><h4 id="web-config-yml文件内容如下"><a href="#web-config-yml文件内容如下" class="headerlink" title="web-config.yml文件内容如下"></a>web-config.yml文件内容如下</h4><p>标红readonly参数设置为false，是为了web页面可以显示删除按钮。默认是true，只读状态，没有删除按钮，只能查看。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">registry:</span><br><span class="line">  # Docker registry url</span><br><span class="line">  url: http://10.88.77.32:5000/v2</span><br><span class="line">  # Docker registry fqdn</span><br><span class="line">  name: localhost:5000</span><br><span class="line">  # To allow image delete, should be false</span><br><span class="line">  readonly: false</span><br><span class="line">  auth:</span><br><span class="line">    # Disable authentication</span><br><span class="line">    enabled: false</span><br></pre></td></tr></table></figure><h4 id="部署完成后，浏览器打开仓库UI地址即可查看到所有应用镜像"><a href="#部署完成后，浏览器打开仓库UI地址即可查看到所有应用镜像" class="headerlink" title="部署完成后，浏览器打开仓库UI地址即可查看到所有应用镜像"></a>部署完成后，浏览器打开仓库UI地址即可查看到所有应用镜像</h4><p><img src="bfcef290e0529142f4fa675f5cb3cc0d2564e07512912b699ffa9a00bf6c8a6a.png" alt="picture 0">  </p><p>选择任意应用镜像库，即可查看到该镜像的所有tag信息，每个tag后面都有个删除按钮（默认没有，配置参考config.yml）</p><p><img src="634baf7e844835348b1d5708228a67a8bdda0d92583551bb1dd6dc1d825ff527.png" alt="picture 1">  </p><hr><h2 id="四、快捷部署"><a href="#四、快捷部署" class="headerlink" title="四、快捷部署"></a>四、快捷部署</h2><p>　　集群模式可以通过docker stack快速部署registry和registry web。</p><p>　　新建配置文件srv-config.yml、web-config.yml放到指定路径，再新建docker-compose.yml文件，执行命令即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack deploy -c docker-compose.yml RGT</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3.7&#x27;　　　　　　\# docker stack 需要是3.0以上版本</span><br><span class="line">services:</span><br><span class="line">  registry-srv:　　　　　　\# 服务名</span><br><span class="line">    image: registry</span><br><span class="line">    </span><br><span class="line">    ports:　　　　　　　　　\# 映射端口</span><br><span class="line">      - 5000:5000</span><br><span class="line">      </span><br><span class="line">    volumes:　　　　　　　　\# 挂载镜像路径和配置文件，注意修改路径与实际一致</span><br><span class="line">      - /opt/zwx-registry:/var/lib/registry</span><br><span class="line">      - /opt/zwx-registry/srv-config.yml:/etc/docker/registry/config.yml</span><br><span class="line">      </span><br><span class="line">    deploy:　　　　　　　　\# 设置单任务，并约束主节点运行</span><br><span class="line">      mode: replicated</span><br><span class="line">      replicas: 1</span><br><span class="line">      placement:</span><br><span class="line">        constraints:</span><br><span class="line">          - node.role == manager</span><br><span class="line">      </span><br><span class="line">  registry-web:　　　　　　\# 服务名　　</span><br><span class="line">    image: hyper/docker-registry-web</span><br><span class="line">    </span><br><span class="line">    ports:　　　　　　　　\# 映射端口</span><br><span class="line">      - 8000:8080</span><br><span class="line">    </span><br><span class="line">    volumes:　　　　　　\# 挂载配置文件，注意修改路径与实际一致</span><br><span class="line">      - /opt/zwx-registry/web-config.yml:/conf/config.yml</span><br><span class="line">      </span><br><span class="line">    environment:</span><br><span class="line">      - REGISTRY_URL=http://registry-srv:5000/v2</span><br><span class="line">      - REGISTRY_NAME=localhost:5000</span><br><span class="line">    </span><br><span class="line">    deploy:　　　　　　　　\# 设置单任务，并约束主节点运行</span><br><span class="line">      mode: replicated</span><br><span class="line">      replicas: 1</span><br><span class="line">      placement:</span><br><span class="line">        constraints:</span><br><span class="line">          - node.role == manager  </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;一、关于Registry&quot;&gt;&lt;a href=&quot;#一、关于Registry&quot; class=&quot;headerlink&quot; title=&quot;一、关于Registry&quot;&gt;&lt;/a&gt;一、关于Registry&lt;/h2&gt;&lt;p&gt;官方的Docker hub是一个用于管理公共镜像的好地方，我们可以在上面找到我们想要的镜像，也可以把我们自己的镜像推送上去。&lt;/p&gt;</summary>
    
    
    
    <category term="DOCKER" scheme="https://rma-shuyu.github.io/categories/DOCKER/"/>
    
    
    <category term="docker" scheme="https://rma-shuyu.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker ipc设置</title>
    <link href="https://rma-shuyu.github.io/2022/06/27/docker-ipc%E8%AE%BE%E7%BD%AE/"/>
    <id>https://rma-shuyu.github.io/2022/06/27/docker-ipc%E8%AE%BE%E7%BD%AE/</id>
    <published>2022-06-27T12:25:15.000Z</published>
    <updated>2023-09-09T10:33:02.407Z</updated>
    
    <content type="html"><![CDATA[<p>官方配置文档：<a href="https://docs.docker.com/engine/reference/run/#ipc-settings---ipc">Docker run reference</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--ipc=&quot;MODE&quot;  : 设置容器的 IPC 模式</span><br></pre></td></tr></table></figure><span id="more"></span><p>可接受的值包括：</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>“”</td><td>使用Docker Daemon的默认值</td></tr><tr><td>none</td><td>拥有私有的IPC命名空间，不挂载 /dev/shm</td></tr><tr><td>private</td><td>拥有私有的IPC命名空间</td></tr><tr><td>shareable</td><td>拥有私有的IPC命名空间, 且可以共享给其他容器</td></tr><tr><td>container: &lt;_name-or-ID_&gt;</td><td>加入到其他”shareable”容器的命名空间中</td></tr><tr><td>host</td><td>使用主机系统的命名空间</td></tr></tbody></table><p>如果未指定，则使用Docker Daemon的默认值，它可以是”private”或”shareable”，具体取决于daemon的版本和配置。</p><p>IPC (POSIX/SysV IPC) 命名空间提供命名共享内存段、信号量和消息队列的隔离。</p><p>共享内存段（shared memory segments ）用于以加速进程间通信，性能超过管道或网络。 共享内存常用于科学计算和金融服务行业的数据库和定制高性能应用程序。 如果这些类型的应用程序被分解到多个容器中，可能需要共享容器的 IPC 机制，对主容器使用”shareable”模式，其他容器使用“container:<name-or- id>”模式。</name-or-></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;官方配置文档：&lt;a href=&quot;https://docs.docker.com/engine/reference/run/#ipc-settings---ipc&quot;&gt;Docker run reference&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;--ipc=&amp;quot;MODE&amp;quot;  : 设置容器的 IPC 模式&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="DOCKER" scheme="https://rma-shuyu.github.io/categories/DOCKER/"/>
    
    
    <category term="docker" scheme="https://rma-shuyu.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>nova源码阅读</title>
    <link href="https://rma-shuyu.github.io/2022/06/26/nova%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>https://rma-shuyu.github.io/2022/06/26/nova%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</id>
    <published>2022-06-26T12:25:15.000Z</published>
    <updated>2023-09-09T10:33:02.414Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-OpenStack基础"><a href="#1-OpenStack基础" class="headerlink" title="1 OpenStack基础"></a>1 OpenStack基础</h2><h2 id="1-1-OpenStack组件介绍"><a href="#1-1-OpenStack组件介绍" class="headerlink" title="1.1 OpenStack组件介绍"></a>1.1 OpenStack组件介绍</h2><p>OpenStack是一个IaaS云计算平台开源实现，其对标产品为AWS。</p><span id="more"></span><p>最开始OpenStack只有两个组件，分别为提供计算服务的Nova以及提供对象存储服务的Swift，其中Nova不仅提供计算服务，还包含了网络服务、块存储服务、镜像服务以及裸机管理服务。之后随着项目的不断发展，从Nova中根据功能拆分为多个独立的项目，如nova-volume拆分为Cinder项目提供块存储服务，nova-image拆分为Glance项目，提供镜像存储服务，nova-network则是neutron的前身，裸机管理也从Nova中分离出来为Ironic项目。最开始容器服务也是由Nova提供支持的，作为Nova的driver之一来实现，而后迁移到Heat，到现在已经独立为一个单独的项目Magnum，后来Magnum的愿景调整为主要提供容器编排服务，单纯的容器服务则由Zun项目接管。最开始OpenStack并没有认证功能，从E版开始才加入认证服务Keystone。</p><p>目前OpenStack基础服务组件如下:</p><ul><li>  Keystone：认证服务。</li><li>  Glance：镜像服务。</li><li>  Nova：计算服务。</li><li>  Cinder：块存储服务。</li><li>  Neutorn：网络服务。</li><li>  Swift：对象存储服务。</li></ul><p>E版之后，在这些核心服务之上，又不断涌现新的服务，如面板服务Horizon、编排服务Heat、数据库服务Trove、文件共享服务Manila、大数据服务Sahara、工作流服务Mistral以及前面提到的容器编排服务Magnum等，这些服务几乎都依赖于以上的基础服务。比如Sahara大数据服务会先调用Heat模板服务，Heat又会调用Nova创建虚拟机，调用Glance获取镜像，调用Cinder创建数据卷，调用Neutron创建网络等。</p><p>OpenStack服务越来越多、越来越复杂，覆盖的技术生态越来越庞大，宛如一个庞然大物，刚接触如此庞大的分布式系统，都或多或少感觉有点如”盲人摸象”的感觉。不过不必先过于绝望，好在OpenStack项目具有非常良好的设计，虽然OpenStack项目众多，组件繁杂，但几乎所有的服务骨架脉络基本是一样的，熟悉了其中一个项目的架构，深入读了其中一个项目源码，再去看其它项目可谓轻车熟路。</p><p>本文章会以Nova项目为例，一步一步剖析源码结构，希望读者阅读完之后再去看Cinder项目会是件非常轻松的事。</p><p>OpenStack所有项目都是基于Python开发，并且都是标准的Python项目，通过setuptools工具管理项目，负责Python模块的安装和分发。想知道一个项目有哪些服务组成，最直接有效的办法就是找到入口函数（main函数）在哪里，只要是标准的基于setuptools管理的项目的所有入口函数都会在项目根目录的setup.cfg文件中定义，console_scripts就是所有服务组件的入口，比如nova（Mitaka版本）的setup.cfg的console_scripts如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[entry_points]</span><br><span class="line">...</span><br><span class="line">console_scripts =</span><br><span class="line">    nova-all = nova.cmd.all:main    nova-api = nova.cmd.api:main    nova-api-metadata = nova.cmd.api_metadata:main    nova-api-os-compute = nova.cmd.api_os_compute:main    nova-cells = nova.cmd.cells:main    nova-cert = nova.cmd.cert:main    nova-compute = nova.cmd.compute:main    nova-conductor = nova.cmd.conductor:main    nova-console = nova.cmd.console:main    nova-consoleauth = nova.cmd.consoleauth:main    nova-dhcpbridge = nova.cmd.dhcpbridge:main    nova-idmapshift = nova.cmd.idmapshift:main    nova-manage = nova.cmd.manage:main    nova-network = nova.cmd.network:main    nova-novncproxy = nova.cmd.novncproxy:main    nova-rootwrap = oslo_rootwrap.cmd:main    nova-rootwrap-daemon = oslo_rootwrap.cmd:daemon    nova-scheduler = nova.cmd.scheduler:main    nova-serialproxy = nova.cmd.serialproxy:main    nova-spicehtml5proxy = nova.cmd.spicehtml5proxy:main    nova-xvpvncproxy = nova.cmd.xvpvncproxy:main</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由此可知nova项目安装后会包含21个可执行程序，其中nova-compute服务的入口函数为nova/cmd/compute.py模块的main函数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def main():</span><br><span class="line">    config.parse_args(sys.argv)</span><br><span class="line">    logging.setup(CONF, &#x27;nova&#x27;)</span><br><span class="line">    utils.monkey_patch()</span><br><span class="line">    objects.register_all()</span><br><span class="line"></span><br><span class="line">    gmr.TextGuruMeditation.setup_autorun(version)</span><br><span class="line"></span><br><span class="line">    if not CONF.conductor.use_local:</span><br><span class="line">        block_db_access()</span><br><span class="line">        objects_base.NovaObject.indirection_api = \</span><br><span class="line">            conductor_rpcapi.ConductorAPI()</span><br><span class="line">    else:</span><br><span class="line">        LOG.warning(_LW(&#x27;Conductor local mode is deprecated and will &#x27;</span><br><span class="line">                        &#x27;be removed in a subsequent release&#x27;))</span><br><span class="line"></span><br><span class="line">    server = service.Service.create(binary=&#x27;nova-compute&#x27;,</span><br><span class="line">                                    topic=CONF.compute_topic,</span><br><span class="line">                                    db_allowed=CONF.conductor.use_local)</span><br><span class="line">    service.serve(server)</span><br><span class="line">    service.wait()</span><br></pre></td></tr></table></figure><p>其它服务依次类推。</p><p>OpenStack使用Python语言开发，而Python是动态类型语言，参数类型不容易从代码中看出，因此部署一个allinone的OpenStack开发测试环境非常有必要，建议使用RDO部署：<a href="https://link.zhihu.com/?target=https://www.rdoproject.org/install/quickstart/">Packstack quickstart</a>，当然乐于折腾使用DevStack也是没有问题的。</p><p>要想深入研究源码，最有效的方式就是一步一步跟踪代码执行，因此会使用debug工具是关键技能之一。Python的debug工具有很多，为了简便起见，pdb工具就够了，你也可以尝试ipdb、ptpdb之类的调试工具。使用方法也非常简单，只要在你想设置断点的地方，嵌入以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import pdb; pdb.set_trace()</span><br></pre></td></tr></table></figure><p>然后在命令行（不能通过systemd启动）直接运行服务即可。</p><p>假如想跟踪nova创建虚拟机的过程，首先nova/api/openstack/compute/servers.py模块的create方法打上断点，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def create(self, req, body):</span><br><span class="line">    &quot;&quot;&quot;Creates a new server for a given user.&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    import pdb; pdb.set_trace() # 设置断点</span><br><span class="line">    context = req.environ[&#x27;nova.context&#x27;]</span><br><span class="line">    server_dict = body[&#x27;server&#x27;]</span><br><span class="line">    password = self._get_server_admin_password(server_dict)</span><br><span class="line">    name = common.normalize_name(server_dict[&#x27;name&#x27;])</span><br><span class="line"></span><br><span class="line">    if api_version_request.is_supported(req, min_version=&#x27;2.19&#x27;):</span><br><span class="line">        if &#x27;description&#x27; in server_dict:</span><br><span class="line">            # This is allowed to be None</span><br><span class="line">            description = server_dict[&#x27;description&#x27;]</span><br><span class="line">        else:</span><br><span class="line">            # No default description</span><br><span class="line">            description = None</span><br><span class="line">    else:</span><br><span class="line">        description = name</span><br><span class="line">    ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后注意需要通过命令行直接运行，而不能通过systemd启动:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su -c &#x27;nova-api&#x27; nova</span><br></pre></td></tr></table></figure><p>此时调用创建虚拟机API，nova-api进程就会立即弹出pdb shell，此时你可以通过s或者n命令一步一步执行代码。</p><h2 id="1-3-OpenStack项目通用骨骼脉络"><a href="#1-3-OpenStack项目通用骨骼脉络" class="headerlink" title="1.3 OpenStack项目通用骨骼脉络"></a>1.3 OpenStack项目通用骨骼脉络</h2><p>阅读源码的首要问题就是就要对代码的结构了然于胸，<strong>需要强调的是，OpenStack项目的目录结构并不是根据组件严格划分，而是根据功能划分</strong>，以Nova为例，compute目录并不是一定在nova-compute节点上运行，而主要是和compute相关(虚拟机操作相关）的功能实现，同样的，scheduler目录代码并不全在scheduler服务节点运行，但主要是和调度相关的代码。不过目录结构并不是完全没有规律，它遵循一定的套路。</p><p>通常一个服务的目录都会包含<strong>api.py、rpcapi.py、manager.py</strong>，这三个是最最重要的模块。</p><ul><li>  <strong>api.py</strong>： 通常是供其它组件调用的封装库。换句话说，该模块通常并不会由本模块调用，而是类似提供其它服务SDK。比如compute目录的api.py，通常会由nova-api服务的controller调用。</li><li>  <strong>rpcapi.py</strong>：这个是RPC请求的封装，或者说是RPC封装的client端，该模块封装了所有RPC请求调用。</li><li>  <strong>manager.py</strong>： 这个才是真正服务的功能实现，也是RPC的服务端，即处理RPC请求的入口，实现的方法和rpcapi实现的方法一一对应。</li></ul><p>比如对一个虚拟机执行关机操作的流程为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">API节点</span><br><span class="line">nova-api接收用户请求 -&gt; nova-api调用compute/api.py</span><br><span class="line">-&gt; compute/api调用compute/rpcapi.py -&gt; rpcapi.py向目标计算节点发起stop_instance()RPC请求</span><br><span class="line"></span><br><span class="line">计算节点</span><br><span class="line">收到MQ RPC消息 -&gt; 解析stop_instance()请求 -&gt; 调用compute/manager.py的callback方法stop_instance() -&gt; 调用libvirt关机虚拟机</span><br></pre></td></tr></table></figure><p>前面提到OpenStack项目的目录结构是按照功能划分的，而不是服务组件，因此并不是所有的目录都能有对应的组件。仍以Nova为例:</p><ul><li>  cmd：这是服务的启动脚本，即所有服务的main函数。看服务怎么初始化，就从这里开始。</li><li>  db: 封装数据库访问API，目前支持的driver为sqlalchemy，还包括migrate repository。</li><li>  conf：Nova的配置项声明都在这里，想看Nova配置的作用和默认值可以从这个目录入手。</li><li>  locale: 本地化处理。</li><li>  image: 封装image API，其实就是调用python-glanceclient。</li><li>  network: 封装网络服务接口，根据配置不同，可能调用nova-network或者neutron。</li><li>  volume: 封装数据卷访问接口，通常是Cinder的client封装，调用python-cinderclient。</li><li>  virt: 这是所有支持的hypervisor驱动，主流的如libvirt、xen等。</li><li>  objects: 对象模型，封装了所有实体对象的CURD操作，相对直接调用db的model更安全，并且支持版本控制。</li><li>  policies： policy校验实现。</li><li>  tests: 单元测试和功能测试代码。</li></ul><p>以上同样适用于其它服务，比如Cinder等。</p><p>另外需要了解的是，所有的API入口都是从xxx-api开始的，RESTFul API是OpenStack服务的唯一入口，也就是说，阅读源码就从api开始。而api组件也是根据实体划分的，不同的实体对应不同的controller，比如servers、flavors、keypairs等，controller的index方法对应list操作、show方法对应get操作、create创建、delete删除、update更新等。</p><p>根据进程阅读源码并不是什么好的实践，因为光理解服务如何初始化、如何通信、如何发送心跳等就不容易，各种高级封装太复杂了。我认为比较好的阅读源码方式是追踪一个任务的执行过程，比如看启动虚拟机的整个流程。因此接下来本文将以创建一台虚拟机为例，一步步分析其过程。</p><h2 id="2-创建虚拟机过程分析"><a href="#2-创建虚拟机过程分析" class="headerlink" title="2 创建虚拟机过程分析"></a>2 创建虚拟机过程分析</h2><p>这里以创建虚拟机过程为例，根据前面的总体套路，一步步跟踪其执行过程。需要注意的是，Nova支持同时创建多台虚拟机，因此在调度时需要选择多个宿主机。</p><h2 id="S1-nova-api"><a href="#S1-nova-api" class="headerlink" title="S1 nova-api"></a>S1 nova-api</h2><p>入口为<strong>nova/api/openstack/compute/servers.py</strong>的create方法，该方法检查了一堆参数以及policy后，调用compute_api的create方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">def create(self, req, body):</span><br><span class="line">    &quot;&quot;&quot;Creates a new server for a given user.&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    context = req.environ[&#x27;nova.context&#x27;]</span><br><span class="line">    server_dict = body[&#x27;server&#x27;]</span><br><span class="line">    password = self._get_server_admin_password(server_dict)</span><br><span class="line">    name = common.normalize_name(server_dict[&#x27;name&#x27;])</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    flavor_id = self._flavor_id_from_req_data(body)</span><br><span class="line">    try:</span><br><span class="line">        inst_type = flavors.get_flavor_by_flavor_id(</span><br><span class="line">                flavor_id, ctxt=context, read_deleted=&quot;no&quot;)</span><br><span class="line"></span><br><span class="line">        (instances, resv_id) = self.compute_api.create(context,</span><br><span class="line">                        inst_type,</span><br><span class="line">                        image_uuid,</span><br><span class="line">                        display_name=name,</span><br><span class="line">                        display_description=description,</span><br><span class="line">                        availability_zone=availability_zone,</span><br><span class="line">                        forced_host=host, forced_node=node,</span><br><span class="line">                        metadata=server_dict.get(&#x27;metadata&#x27;, &#123;&#125;),</span><br><span class="line">                        admin_password=password,</span><br><span class="line">                        requested_networks=requested_networks,</span><br><span class="line">                        check_server_group_quota=True,</span><br><span class="line">                        **create_kwargs)</span><br><span class="line">    except (exception.QuotaError,</span><br><span class="line">            exception.PortLimitExceeded) as error:</span><br><span class="line">        raise exc.HTTPForbidden(</span><br><span class="line">            explanation=error.format_message())</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这里的compute_api即前面说的<strong>nova/compute/api.py</strong>模块，找到该模块的create方法，该方法会创建数据库记录、检查参数等，然后调用compute_task_api的build_instances方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">self.compute_task_api.schedule_and_build_instances(</span><br><span class="line">    context,</span><br><span class="line">    build_requests=build_requests,</span><br><span class="line">    request_spec=request_specs,</span><br><span class="line">    image=boot_meta,</span><br><span class="line">    admin_password=admin_password,</span><br><span class="line">    injected_files=injected_files,</span><br><span class="line">    requested_networks=requested_networks,</span><br><span class="line">    block_device_mapping=block_device_mapping)</span><br></pre></td></tr></table></figure><p>compute_task_api即conductor的api.py。conductor的api并没有执行什么操作，直接调用了conductor_compute_rpcapi的build_instances方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def schedule_and_build_instances(self, context, build_requests,</span><br><span class="line">                                 request_spec, image,</span><br><span class="line">                                 admin_password, injected_files,</span><br><span class="line">                                 requested_networks, block_device_mapping):</span><br><span class="line">    self.conductor_compute_rpcapi.schedule_and_build_instances(</span><br><span class="line">        context, build_requests, request_spec, image,</span><br><span class="line">        admin_password, injected_files, requested_networks,</span><br><span class="line">        block_device_mapping)</span><br></pre></td></tr></table></figure><p>该方法就是conductor RPC API，即<strong>nova/conductor/rpcapi.py</strong>模块，该方法除了一堆的版本检查，剩下的就是对RPC调用的封装，代码只有两行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cctxt = self.client.prepare(version=version)</span><br><span class="line">cctxt.cast(context, &#x27;build_instances&#x27;, **kw)</span><br></pre></td></tr></table></figure><p>其中cast表示异步调用，build_instances是远程调用的方法，kw是传递的参数。参数是字典类型，没有复杂对象结构，因此不需要特别的序列化操作。</p><p>截至到现在，虽然目录由api-&gt;compute-&gt;conductor，但仍在nova-api进程中运行，直到cast方法执行，该方法由于是异步调用，因此nova-api任务完成，此时会响应用户请求，虚拟机状态为building。</p><h2 id="S2-nova-conductor"><a href="#S2-nova-conductor" class="headerlink" title="S2 nova-conductor"></a>S2 nova-conductor</h2><p>由于是向nova-conductor发起的RPC调用，而前面说了接收端肯定是manager.py，因此进程跳到nova-conductor服务，入口为nova/conductor/manager.py的build_instances方法，该方法首先调用了_schedule_instances方法，该方法调用了scheduler_client的select_destinations方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def _schedule_instances(self, context, request_spec, filter_properties):</span><br><span class="line">    scheduler_utils.setup_instance_group(context, request_spec,</span><br><span class="line">                                         filter_properties)</span><br><span class="line">    # TODO(sbauza): Hydrate here the object until we modify the</span><br><span class="line">    # scheduler.utils methods to directly use the RequestSpec object</span><br><span class="line">    spec_obj = objects.RequestSpec.from_primitives(</span><br><span class="line">        context, request_spec, filter_properties)</span><br><span class="line">    hosts = self.scheduler_client.select_destinations(context, spec_obj)</span><br><span class="line">    return hosts</span><br></pre></td></tr></table></figure><p>scheduler_client和compute_api以及compute_task_api都是一样对服务的client SDK调用，不过scheduler没有api.py，而是有个单独的client目录，实现在client目录的__init__.py，这里仅仅是调用query.py下的SchedulerQueryClient的select_destinations实现，然后又很直接地调用了scheduler_rpcapi的select_destinations方法，终于又到了RPC调用环节。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def _schedule_instances(self, context, request_spec, filter_properties):</span><br><span class="line">    scheduler_utils.setup_instance_group(context, request_spec,</span><br><span class="line">                                         filter_properties)</span><br><span class="line">    # TODO(sbauza): Hydrate here the object until we modify the</span><br><span class="line">    # scheduler.utils methods to directly use the RequestSpec object</span><br><span class="line">    spec_obj = objects.RequestSpec.from_primitives(</span><br><span class="line">        context, request_spec, filter_properties)</span><br><span class="line">    hosts = self.scheduler_client.select_destinations(context, spec_obj)</span><br><span class="line">    return hosts</span><br></pre></td></tr></table></figure><p>毫无疑问，RPC封装同样是在scheduler的rpcapi中实现。该方法RPC调用代码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return cctxt.call(ctxt, &#x27;select_destinations&#x27;, **msg_args)</span><br></pre></td></tr></table></figure><p>注意这里调用的call方法，即同步RPC调用，此时nova-conductor并不会退出，而是堵塞等待直到nova-scheduler返回。因此当前状态为nova-conductor为blocked状态，等待nova-scheduler返回，nova-scheduler接管任务。</p><h2 id="S3-nova-scheduler"><a href="#S3-nova-scheduler" class="headerlink" title="S3 nova-scheduler"></a>S3 nova-scheduler</h2><p>同理找到scheduler的manager.py模块的select_destinations方法，该方法会调用driver方法，这里的driver其实就是调度算法实现，通常用的比较多的就是Filter Scheduler算法，对应filter_scheduler.py模块，该模块首先通过host_manager拿到所有的计算节点信息，然后通过filters过滤掉不满足条件的计算节点，剩下的节点通过weigh方法计算权值，最后选择权值高的作为候选计算节点返回。最后nova-scheduler返回调度结果的hosts集合，任务结束，返回到nova-conductor服务。</p><h2 id="S4-nova-condutor"><a href="#S4-nova-condutor" class="headerlink" title="S4 nova-condutor"></a>S4 nova-condutor</h2><p>回到scheduler/manager.py的build_instances方法，nova-conductor等待nova-scheduler返回后，拿到调度的计算节点列表。因为可能同时启动多个虚拟机，因此循环调用了compute_rpcapi的build_and_run_instance方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">for (instance, host) in six.moves.zip(instances, hosts):</span><br><span class="line">    instance.availability_zone = (</span><br><span class="line">        availability_zones.get_host_availability_zone(context,</span><br><span class="line">                                                      host[&#x27;host&#x27;]))</span><br><span class="line">    try:</span><br><span class="line">        # NOTE(danms): This saves the az change above, refreshes our</span><br><span class="line">        # instance, and tells us if it has been deleted underneath us</span><br><span class="line">        instance.save()</span><br><span class="line">    except (exception.InstanceNotFound,</span><br><span class="line">            exception.InstanceInfoCacheNotFound):</span><br><span class="line">        LOG.debug(&#x27;Instance deleted during build&#x27;, instance=instance)</span><br><span class="line">        continue</span><br><span class="line">    ...</span><br><span class="line">    self.compute_rpcapi.build_and_run_instance(context,</span><br><span class="line">            instance=instance, host=host[&#x27;host&#x27;], image=image,</span><br><span class="line">            request_spec=request_spec,</span><br><span class="line">            filter_properties=local_filter_props,</span><br><span class="line">            admin_password=admin_password,</span><br><span class="line">            injected_files=injected_files,</span><br><span class="line">            requested_networks=requested_networks,</span><br><span class="line">            security_groups=security_groups,</span><br><span class="line">            block_device_mapping=bdms, node=host[&#x27;nodename&#x27;],</span><br><span class="line">            limits=host[&#x27;limits&#x27;])</span><br></pre></td></tr></table></figure><p>看到xxxrpc立即想到对应的代码位置，位于compute/rpcapi模块，该方法向nova-compute发起RPC请求:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cctxt.cast(ctxt, &#x27;build_and_run_instance&#x27;, ...)</span><br></pre></td></tr></table></figure><p>由于是cast调用，因此发起的是异步RPC，因此nova-conductor任务结束，紧接着终于轮到nova-compute登场了。</p><h2 id="S5-nova-compute"><a href="#S5-nova-compute" class="headerlink" title="S5 nova-compute"></a>S5 nova-compute</h2><p>到了nova-compute服务，入口为compute/manager.py，找到build_and_run_instance方法，该方法调用了driver的spawn方法，这里的driver就是各种hypervisor的实现，所有实现的driver都在virt目录下，入口为driver.py，比如libvirt driver实现对应为virt/libvirt/driver.py，找到spawn方法，该方法拉取镜像创建根磁盘、生成xml文件、define domain，启动domain等。最后虚拟机完成创建。nova-compute服务结束。</p><h2 id="3-一张图总结"><a href="#3-一张图总结" class="headerlink" title="3 一张图总结"></a>3 一张图总结</h2><p>以上是创建虚拟机的各个服务的交互过程以及调用关系，略去了很多细节。需要注意的是，所有的数据库操作，比如instance.save（）以及update()操作，如果配置use_local为false，则会向nova-conductor发起RPC调用，由nova-conductor代理完成数据库更新，而不是直接由nova-compute更新数据库，这里的RPC调用过程在以上的分析中省略了。</p><p>整个流程用一张图表示为:</p><p><img src="https://pic3.zhimg.com/v2-7df2beb26c8ef40411501294164da086_r.jpg"></p><p>如果你对OpenStack的其它服务以及操作流程感兴趣，可以参考我的<a href="https://link.zhihu.com/?target=https://github.com/int32bit/openstack-workflow">openstack-workflow</a>项目, 这个项目是我本人在学习过程中记录，绘制成序列图，上图就是其中一个实例。项目地址为: <a href="https://link.zhihu.com/?target=https://github.com/int32bit/openstack-workflow">https://github.com/int32bit/openstack-workflow</a>。</p><p>本文转自 <a href="https://zhuanlan.zhihu.com/p/28959724">https://zhuanlan.zhihu.com/p/28959724</a>，如有侵权，请联系删除。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-OpenStack基础&quot;&gt;&lt;a href=&quot;#1-OpenStack基础&quot; class=&quot;headerlink&quot; title=&quot;1 OpenStack基础&quot;&gt;&lt;/a&gt;1 OpenStack基础&lt;/h2&gt;&lt;h2 id=&quot;1-1-OpenStack组件介绍&quot;&gt;&lt;a href=&quot;#1-1-OpenStack组件介绍&quot; class=&quot;headerlink&quot; title=&quot;1.1 OpenStack组件介绍&quot;&gt;&lt;/a&gt;1.1 OpenStack组件介绍&lt;/h2&gt;&lt;p&gt;OpenStack是一个IaaS云计算平台开源实现，其对标产品为AWS。&lt;/p&gt;</summary>
    
    
    
    <category term="openstack" scheme="https://rma-shuyu.github.io/categories/openstack/"/>
    
    
    <category term="nova" scheme="https://rma-shuyu.github.io/tags/nova/"/>
    
  </entry>
  
  <entry>
    <title>nova架构及源码分析</title>
    <link href="https://rma-shuyu.github.io/2022/06/25/nova%E6%9E%B6%E6%9E%84%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://rma-shuyu.github.io/2022/06/25/nova%E6%9E%B6%E6%9E%84%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2022-06-25T12:25:15.000Z</published>
    <updated>2023-09-09T10:33:02.413Z</updated>
    
    <content type="html"><![CDATA[<h1 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a><a href="about:blank#%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84" title="整体架构"></a>整体架构</h1><ul><li>  nova 和其他组件之间的交互使用 HTTP 请求</li><li>  内部组件之间使用 <a href="https://github.com/openstack/oslo.messaging">oslo_messaging</a> 库实现 RPC 调用，这里还涉及消息队列 RabbitMQ ，遵循 AMQP 协议</li><li>  大部分 nova 组件都可以运行在多个服务器上，然后使用一个管理器监听 RPC 消息</li><li>  而 nova-compute 是运行在计算主机上的单进程，用于管理计算资源</li><li>nova 内部组件共享本地数据库，通过对象层访问，确保兼容性和安全性<ul><li>  nova-compute 访问数据库由 nova-conductor 代理<span id="more"></span><img src="https://i.loli.net/2021/06/06/K51XMdUyPrRmupT.png"></li></ul></li></ul><p>当用户发起一个新的请求时，该请求会先在 nova-api 中处理。nova-api 会对请求进行一系列检查，包括请求是否合法，配额是否足够等；当检查用过后，nova-api 就会为该请求分配一个唯一的虚拟机 ID ，并在数据库中新建对应的项来记录虚拟机的状态；然后，nova-api 会将请求发送给 nova-conductor 处理。</p><p>nova-conductor 主要管理服务之间的通信并进行任务处理。它在接收到请求之后，会为 nova-scheduler 创建一个 RequestSpec 对象用来包装与调度相关的所有请求信息，然后调用 nova-scheduler 服务的 select_destination 接口。</p><p>nova-scheduler 通过接收到的 RequestSpec 对象，首先将 RequestSpec 对象转换成 ResourceRequest 对象，并将该对象发送给 Placement 进行一次预筛选，然后会根据数据库中最新的系统状态做出调度决定，并告诉 nova-conductor 把该请求调度到合适的计算节点上。</p><p>nova-conductor 在得知调度决定后，会把请求发送给对应的 nova-compute 服务。</p><p>每个 nova-compute 服务都有独立的资源监视器（Resource Tracker）用来监视本地主机的资源使用情况。当计算节点接收到请求时，资源监视器能够检查主机是否有足够的资源。</p><ul><li>  如果对应的资源足够，nova-compute 就会允许在当前主机中启动所要求的虚拟机，并在数据库中更新虚拟机状态，同时将最新的主机资源情况更新到数据库</li><li>  如果当前主机不符合请求的资源要求，nova-compute 会拒绝启动虚拟机，并将请求重新发给 nova-conductor 服务，重试整个调度过程</li></ul><p><img src="https://i.loli.net/2021/06/06/DizGwcpYRQhWKqS.jpg"></p><h2 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a><a href="about:blank#%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86" title="组成部分"></a>组成部分</h2><ol><li>nova-api 接受和响应用户的计算 API 调用</li><li>nova-api-metadata 接受来自实例的元数据请求 <a href="https://docs.openstack.org/nova/latest/admin/metadata-service.html">Metadata service</a></li><li>nova-compute 通过 hypervisor API 创建和终止虚拟机实例的守护进程。例如 KVM/QEMU 的 libvirt、VMware 的 VMwareAPI 。 运行在它所管理的 hypervisor 机器上，管理与虚拟机管理程序和虚拟机的通信。</li><li>nova-scheduler 从消息队列中获取虚拟机实例请求，并决定在哪个服务器上运行。</li><li>nova-conductor 处理需要协调的请求（构建/调整）、充当数据库代理或处理对象转换。用于连接 nova-api、nova-scheduler、nova-compute 服务。</li><li>nova-novncproxy 协调 nova-compute 服务和数据库之间的交互。避免 nova-compute 直接访问数据库，为了提供更好的 API 兼容性。建议不要部署在 nova-compute 服务所在的节点上。</li><li>nova-spicehtml5proxy 提供通过 SPICE 连接访问运行实例的代理，支持基于浏览器的 HTML5 客户端。</li><li>The queue 在守护进程之间传递消息的中央消息队列，通常使用 RabbitMQ 。</li><li>SQL database 存储云基础设施的大多数构建时和运行时状态，包括：可用的实例类型、在使用的实例、可用的网络、项目。</li></ol><h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a><a href="about:blank#RPC" title="RPC"></a>RPC</h1><p>消息代理（RabbitMQ AMQP broker）允许 nova 内部组件以低耦合的方式进行通信，建立在发布/订阅（publish/subscribe）模式上</p><ul><li>  解耦客户端和服务端</li><li>  同步客户端和服务端</li><li>  平衡远程调用</li></ul><p>nova 使用 AMQP 中的直连（direct）、扇型（fanout）、主题（topic）交换；</p><p>nova 使用适配器类（adapter）将消息封装和解封从而调用函数，实现了两种 RPC 调用</p><ul><li>  <code>rpc.call</code>：请求 + 响应，api 作为消费者（consumer）</li><li>  <code>rpc.cast</code>：单向，api 作为发布者（publisher）</li></ul><p>每个 nova 服务在初始化时创建两个队列</p><ul><li>  接受路由键 <code>NODE-TYPE.NODE-ID</code>（例如，<code>compute.hostname</code>）：nova-api 需要重定向到特定节点</li><li>  接受路由键 <code>NODE-TYPE</code>（例如，<code>compute</code>）：</li></ul><p><img src="https://i.loli.net/2021/06/06/ZvNb61tfPTlF9or.png"></p><p>每个 nova 内部组件都连接到消息代理，根据不同的作用，把消息队列作为：</p><ul><li>  调用者（Invoker）：nova-api、nova-scheduler；通过 <code>rpc.call</code> 和 <code>rpc.cast</code> 向消息队列发送消息</li><li>  工作者（Worker）：nova-compute；从消息队列接收消息，根据 <code>rpc.call</code> 进行响应</li></ul><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a><a href="about:blank#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5" title="相关概念"></a>相关概念</h2><p><strong>主题发布者（Topic Publisher）</strong></p><p>执行 <code>rpc.call</code> 或 <code>rpc.cast</code> 操作将实例化一个主题发布者，用于将消息发送到消息队列。每个发布者总是连接到相同的主题交换机（topic-based exchange）；生命周期仅限于消息传递。</p><p><strong>直连消费者（Direct Consumer）</strong></p><p>执行 <code>rpc.call</code> 操作将实例化一个直连消费者，用于从消息队列接收响应消息。每个消费者连接到唯一的直连交换机（direct-based exchange）；生命周期仅限于消息传递。</p><p><strong>主题消费者（Topic Consumer）</strong></p><p>当工作者被实例化后将实例化一个主题消费者，并存在于工作者的整个生命周期；主题消费者用于从消息队列接收消息，并调用工作者定义的操作。主题消费者通过共享/排他队列（shared/exclusive queue）连接到相同的主体交换机。每个工作者都有两个主题消费者，一个处理 <code>rpc.cast</code> ，连接到交换键是 <code>topic</code> 的共享队列；另一个处理 <code>rpc.call</code> ，连接到交换键是 <code>topic.host</code> 的独立队列。</p><p><strong>直连发布者（Direct Publisher）</strong></p><p>执行 <code>rpc.call</code> 操作将实例化一个直连发布者，用于返回请求/响应操作所需的消息，连接到直连交换机。</p><p><strong>主题交换机（Topic Exchange）</strong></p><p>存在于虚拟机上下文中的路由表；类型（主题/直连）决定了路由策略；对于 nova 中的每个主题，消息代理节点只有一个主题交换机。</p><p><strong>直连交换机（Direct Exchange）</strong></p><p>在 <code>rpc.call</code> 操作中创建的路由表，消息代理节点的生命周期中有许多该实例，对应每个 <code>rpc.call</code> 调用。</p><p><strong>队列元素（Queue Element）</strong></p><p>消息桶，消息一直保存在队列中，直到消费者（主题/直连）连接到队列获取消息。队列可以是共享的也可以是独立的；路由键是 <code>topic</code> 的队列在相同类型的工作者中共享。</p><h2 id="rpc-call"><a href="#rpc-call" class="headerlink" title="rpc.call"></a><a href="about:blank#rpc-call" title="rpc.call"></a>rpc.call</h2><ol><li>实例化主题发布者，将请求发送到消息队列；在发布操作之前，实例化直连消费者等待响应信息</li><li>一旦消息被交换器分派（dispatch），它就会被路由键（例如，<code>topic.host</code>）指定的主题消费者获取，并传递给负责该任务的工作者</li><li>任务完成后，将分配一个直连发布者将响应消息发送到消息队列</li><li>一旦消息被交换器分派，它就会被路由键（例如，<code>msg_id</code>）指定的直连消费者获取，并传递给调用者</li></ol><p><img src="https://i.loli.net/2021/06/06/ApK1vCySXhQE3mW.png"></p><h2 id="rpc-cast"><a href="#rpc-cast" class="headerlink" title="rpc.cast"></a><a href="about:blank#rpc-cast" title="rpc.cast"></a>rpc.cast</h2><ol><li>实例化主题发布者，将请求发送到消息队列</li><li>一旦消息被交换器分派（dispatch），它就会被路由键（例如，<code>topic</code>）指定的主题消费者获取，并传递给负责该任务的工作者</li></ol><p><img src="https://i.loli.net/2021/06/06/3nUaoMlKdHg9BQv.png"></p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a><a href="about:blank#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90" title="源码分析"></a>源码分析</h1><p>从 github 下载 Victoria 版本的 Nova 源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/openstack/nova.git --branch stable/victoria --single-branch</span><br></pre></td></tr></table></figure><p>nova/ 文件夹下的目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">accelerator/    # Cyborg 加速器</span><br><span class="line">api/            # Nova API 服务</span><br><span class="line">cmd/            # 各个 Nova 服务的入口程序</span><br><span class="line">compute/        # Nova Compute 服务</span><br><span class="line">conductor/      # Nova Conductor 服务</span><br><span class="line">conf/           # 所有的配置选项</span><br><span class="line">console/        # nova-console 服务</span><br><span class="line">db/             # 封装数据库操作</span><br><span class="line">hacking/        # 编码规范检查</span><br><span class="line">image/          # 封装镜像操作，Glance 接口抽象</span><br><span class="line">keymgr/         # 密钥管理器实现</span><br><span class="line">locale/         # 国际化相关文件</span><br><span class="line">network/        # nova-network 服务</span><br><span class="line">notifications/  # 通知相关功能</span><br><span class="line">objects/        # 封装实体对象的 CURD 操作</span><br><span class="line">pci/            # PCI/SR-IOV 支持</span><br><span class="line">policies/       # 所有 Policy 的默认规则</span><br><span class="line">privsep/        # oslo_privsep 相关</span><br><span class="line">scheduler/      # Nova Scheduler 服务</span><br><span class="line">servicegroup/   # 成员服务（membership），服务组</span><br><span class="line">storage/        # Ceph 存储支持</span><br><span class="line">tests/          # 单元测试</span><br><span class="line">virt/           # 支持的 hypervisor 驱动</span><br><span class="line">volume/         # 封装卷访问接口，Cinder 接口抽象</span><br></pre></td></tr></table></figure><p>nova/ 文件夹下的 python 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">__init__.py</span><br><span class="line">availability_zones.py   # 区域设置的工具函数</span><br><span class="line">baserpc.py              # 基础 RPC 客户端/服务端实现</span><br><span class="line">block_device.py         # 块设备映射</span><br><span class="line">cache_utils.py          # oslo_cache 封装</span><br><span class="line">config.py               # 解析命令行参数</span><br><span class="line">context.py              # 贯穿 Nova 的所有请求的上下文</span><br><span class="line">crypto.py               # 包装标准加密数据元素</span><br><span class="line">debugger.py             # pydev 调试</span><br><span class="line">exception.py            # 基础异常类</span><br><span class="line">exception_wrapper.py    # 封装异常类</span><br><span class="line">filters.py              # 基础过滤器</span><br><span class="line">i18n.py                 # 集成 oslo_i18n</span><br><span class="line">loadables.py            # 可加载类</span><br><span class="line">manager.py              # 基础 Manager 类</span><br><span class="line">middleware.py           # 更新 oslo_middleware 的默认配置选项</span><br><span class="line">monkey_patch.py         # eventlet 猴子补丁</span><br><span class="line">policy.py               # 策略引擎</span><br><span class="line">profiler.py             # 调用 OSProfiler</span><br><span class="line">quota.py                # 每个项目的资源配额</span><br><span class="line">rpc.py                  # RPC 操作相关的工具函数</span><br><span class="line">safe_utils.py           # 不会导致循环导入的工具函数</span><br><span class="line">service.py              # 通用节点基类，用于在主机上运行的所有工作者</span><br><span class="line">service_auth.py         # 身份认证插件</span><br><span class="line">test.py                 # 单元测试基础类</span><br><span class="line">utils.py                # 工具函数</span><br><span class="line">version.py              # 版本号管理</span><br><span class="line">weights.py              # 权重插件</span><br><span class="line">wsgi.py                 # 管理 WSGI 应用的服务器类</span><br></pre></td></tr></table></figure><p>setup.cfg 配置文件，<code>[entry_points]</code> 小节指定了 nova 各个组件入口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">console_scripts =</span><br><span class="line">    nova-api = nova.cmd.api:main</span><br><span class="line">    nova-api-metadata = nova.cmd.api_metadata:main</span><br><span class="line">    nova-api-os-compute = nova.cmd.api_os_compute:main</span><br><span class="line">    nova-compute = nova.cmd.compute:main</span><br><span class="line">    nova-conductor = nova.cmd.conductor:main</span><br><span class="line">    nova-manage = nova.cmd.manage:main</span><br><span class="line">    nova-novncproxy = nova.cmd.novncproxy:main</span><br><span class="line">    nova-policy = nova.cmd.policy:main</span><br><span class="line">    nova-rootwrap = oslo_rootwrap.cmd:main</span><br><span class="line">    nova-rootwrap-daemon = oslo_rootwrap.cmd:daemon</span><br><span class="line">    nova-scheduler = nova.cmd.scheduler:main</span><br><span class="line">    nova-serialproxy = nova.cmd.serialproxy:main</span><br><span class="line">    nova-spicehtml5proxy = nova.cmd.spicehtml5proxy:main</span><br><span class="line">    nova-status = nova.cmd.status:main</span><br><span class="line">wsgi_scripts =</span><br><span class="line">    nova-api-wsgi = nova.api.openstack.compute.wsgi:init_application</span><br><span class="line">    nova-metadata-wsgi = nova.api.metadata.wsgi:init_application</span><br></pre></td></tr></table></figure><h2 id="nova-api"><a href="#nova-api" class="headerlink" title="nova-api"></a><a href="about:blank#nova-api" title="nova-api"></a>nova-api</h2><p>nova-api 对外提供 RESTful API，没有对内的 RPC 。</p><p>nova/api/ 目录结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__init__.py</span><br><span class="line">auth.py             # 身份认证中间件</span><br><span class="line">compute_req_id.py   # x-compute-request-id 中间件（oslo_middleware）</span><br><span class="line">metadata/           # Metadata API</span><br><span class="line">openstack/          # Nova v2.1 API</span><br><span class="line">validation/         # 请求体验证</span><br><span class="line">wsgi.py             # WSGI 原语（请求、应用、中间件、路由、加载器）</span><br></pre></td></tr></table></figure><p>openstack 目录中包含 WSGI 基础架构的代码，一些 WSGI 中间件，以及如何解析请求与分发请求的核心代码。</p><p>nova/api/openstack/compute/ 包含 Controller 实现，Resource 对象将 API 映射到相应的 Controller 方法上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">__init__.py</span><br><span class="line">api_version_request.py  # 版本验证</span><br><span class="line">auth.py                 # noauth 中间件</span><br><span class="line">common.py               # 信息查询的工具函数</span><br><span class="line">compute/                # 每个 API 的入口点</span><br><span class="line">identity.py             # 验证项目是否存在</span><br><span class="line">requestlog.py           # 请求日志中间件</span><br><span class="line">urlmap.py               # url 映射</span><br><span class="line">versioned_method.py     # 版本信息</span><br><span class="line">wsgi.py                 # WSGI 相关抽象类</span><br><span class="line">wsgi_app.py             # WSGI 应用程序初始化方法</span><br></pre></td></tr></table></figure><h3 id="API-请求路由"><a href="#API-请求路由" class="headerlink" title="API 请求路由"></a><a href="about:blank#API-%E8%AF%B7%E6%B1%82%E8%B7%AF%E7%94%B1" title="API 请求路由"></a>API 请求路由</h3><p>nova-api 读取 etc/nova/api-paste.ini 并加载 WSGI 程序，最终 API 入口点都位于 nova.api.openstack.compute 中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[composite:osapi_compute]</span><br><span class="line">use = call:nova.api.openstack.urlmap:urlmap_factory</span><br><span class="line">/: oscomputeversions                # version API</span><br><span class="line">/v2: oscomputeversion_legacy_v2     # v2 API</span><br><span class="line">/v2.1: oscomputeversion_v2          # v2.1 API</span><br><span class="line"># v21 is an exactly feature match for v2, except it has more stringent</span><br><span class="line"># input validation on the wsgi surface (prevents fuzzing early on the</span><br><span class="line"># API). It also provides new features via API microversions which are</span><br><span class="line"># opt into for clients. Unaware clients will receive the same frozen</span><br><span class="line"># v2 API feature set, but with some relaxed validation</span><br><span class="line">/v2/+: openstack_compute_api_v21_legacy_v2_compatible</span><br><span class="line">/v2.1/+: openstack_compute_api_v21</span><br><span class="line"></span><br><span class="line">[composite:openstack_compute_api_v21]</span><br><span class="line">use = call:nova.api.auth:pipeline_factory_v21       # 加载中间件</span><br><span class="line">keystone = cors http_proxy_to_wsgi compute_req_id faultwrap request_log sizelimit osprofiler bees_profiler authtoken keystonecontext osapi_compute_app_v21</span><br><span class="line"># DEPRECATED: The [api]auth_strategy conf option is deprecated and will be</span><br><span class="line"># removed in a subsequent release, whereupon this pipeline will be unreachable.</span><br><span class="line">noauth2 = cors http_proxy_to_wsgi compute_req_id faultwrap request_log sizelimit osprofiler bees_profiler noauth2 osapi_compute_app_v21</span><br><span class="line"></span><br><span class="line">[app:osapi_compute_app_v21]</span><br><span class="line">paste.app_factory = nova.api.openstack.compute:APIRouterV21.factory  # 入口</span><br></pre></td></tr></table></figure><p>nova/api/openstack/compute/routes.py 中的 APIRouterV21 主要用来完成路由规则的创建，其中 ROUTE_LIST 保存了 URL 与 Controller 之间的映射关系。</p><p>APIRouterV21 基于 ROUTE_LIST，使用 Routes 模块作为 URL 映射的工具，将各个模块所实现的 API 对应的 URL 注册到 mapper 中，并把每个资源都封装成 nova.api.openstack.wsgi.Resource 对象，当解析 URL 请求时，可以通过 URL 映射找到 API 对应的 Resource 对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># Router 类对 WSGI routes 模块进行了简单的封装</span><br><span class="line">class APIRouterV21(base_wsgi.Router):</span><br><span class="line">    &quot;&quot;&quot;Routes requests on the OpenStack API to the appropriate controller</span><br><span class="line">    and method. The URL mapping based on the plain list `ROUTE_LIST` is built</span><br><span class="line">    at here.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def __init__(self, custom_routes=None):</span><br><span class="line">        &quot;&quot;&quot;:param custom_routes: the additional routes can be added by this</span><br><span class="line">               parameter. This parameter is used to test on some fake routes</span><br><span class="line">               primarily.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        super(APIRouterV21, self).__init__(nova.api.openstack.ProjectMapper())</span><br><span class="line"></span><br><span class="line">        if custom_routes is None:</span><br><span class="line">            custom_routes = tuple()</span><br><span class="line"></span><br><span class="line">        for path, methods in ROUTE_LIST + custom_routes:</span><br><span class="line">            # NOTE(alex_xu): The variable &#x27;methods&#x27; is a dict in normal, since</span><br><span class="line">            # the dict includes all the methods supported in the path. But</span><br><span class="line">            # if the variable &#x27;method&#x27; is a string, it means a redirection.</span><br><span class="line">            # For example, the request to the &#x27;&#x27; will be redirect to the &#x27;/&#x27; in</span><br><span class="line">            # the Nova API. To indicate that, using the target path instead of</span><br><span class="line">            # a dict. The route entry just writes as &quot;(&#x27;&#x27;, &#x27;/)&quot;.</span><br><span class="line">            if isinstance(methods, six.string_types):</span><br><span class="line">                self.map.redirect(path, methods)</span><br><span class="line">                continue</span><br><span class="line"></span><br><span class="line">            for method, controller_info in methods.items():</span><br><span class="line">                # TODO(alex_xu): In the end, I want to create single controller</span><br><span class="line">                # instance instead of create controller instance for each</span><br><span class="line">                # route.</span><br><span class="line">                controller = controller_info[0]()</span><br><span class="line">                action = controller_info[1]</span><br><span class="line">                self.map.create_route(path, method, controller, action)</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def factory(cls, global_config, **local_config):</span><br><span class="line">        &quot;&quot;&quot;Simple paste factory, :class:`nova.wsgi.Router` doesn&#x27;t have one.&quot;&quot;&quot;</span><br><span class="line">        return cls()</span><br></pre></td></tr></table></figure><p>nova/api/wsgi.py 解析 URL 映射，通过 _dispatch 回调，调用 Resource 对象的 _<em>call</em>_ 方法，最终通过请求调用 API 对应的模块中的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"># 路由</span><br><span class="line">class Router(object):</span><br><span class="line">    &quot;&quot;&quot;WSGI middleware that maps incoming requests to WSGI apps.&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, mapper):</span><br><span class="line">        &quot;&quot;&quot;Create a router for the given routes.Mapper.</span><br><span class="line"></span><br><span class="line">        Each route in `mapper` must specify a &#x27;controller&#x27;, which is a</span><br><span class="line">        WSGI app to call.  You&#x27;ll probably want to specify an &#x27;action&#x27; as</span><br><span class="line">        well and have your controller be an object that can route</span><br><span class="line">        the request to the action-specific method.</span><br><span class="line"></span><br><span class="line">        Examples:</span><br><span class="line">          mapper = routes.Mapper()</span><br><span class="line">          sc = ServerController()</span><br><span class="line"></span><br><span class="line">          # Explicit mapping of one route to a controller+action</span><br><span class="line">          mapper.connect(None, &#x27;/svrlist&#x27;, controller=sc, action=&#x27;list&#x27;)</span><br><span class="line"></span><br><span class="line">          # Actions are all implicitly defined</span><br><span class="line">          mapper.resource(&#x27;server&#x27;, &#x27;servers&#x27;, controller=sc)</span><br><span class="line"></span><br><span class="line">          # Pointing to an arbitrary WSGI app.  You can specify the</span><br><span class="line">          # &#123;path_info:.*&#125; parameter so the target app can be handed just that</span><br><span class="line">          # section of the URL.</span><br><span class="line">          mapper.connect(None, &#x27;/v1.0/&#123;path_info:.*&#125;&#x27;, controller=BlogApp())</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.map = mapper</span><br><span class="line">        # 使用 routes 模块关联 mapper 和 _dispatch</span><br><span class="line">        # routes.middleware.RoutesMiddleware 设置 environ 信息</span><br><span class="line">        self._router = routes.middleware.RoutesMiddleware(self._dispatch,</span><br><span class="line">                                                          self.map)</span><br><span class="line"></span><br><span class="line">    @webob.dec.wsgify(RequestClass=Request)</span><br><span class="line">    def __call__(self, req):</span><br><span class="line">        &quot;&quot;&quot;Route the incoming request to a controller based on self.map.</span><br><span class="line"></span><br><span class="line">        If no match, return a 404.</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 根据 mapper 将请求路由到 WSGI 应用（资源）</span><br><span class="line">        # 每个资源会在 __call__ 方法中根据 HTTP 请求的 URL 路由到对应 Controller 上的方法（Action）</span><br><span class="line">        return self._router</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    @webob.dec.wsgify(RequestClass=Request)</span><br><span class="line">    def _dispatch(req):</span><br><span class="line">        &quot;&quot;&quot;Dispatch the request to the appropriate controller.</span><br><span class="line"></span><br><span class="line">        Called by self._router after matching the incoming request to a route</span><br><span class="line">        and putting the information into req.environ.  Either returns 404</span><br><span class="line">        or the routed WSGI app&#x27;s response.</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 根据 HTTP 请求的 environ 信息找到 URL 对应的 Controller</span><br><span class="line">        match = req.environ[&#x27;wsgiorg.routing_args&#x27;][1]</span><br><span class="line">        if not match:</span><br><span class="line">            return webob.exc.HTTPNotFound()</span><br><span class="line">        app = match[&#x27;controller&#x27;]</span><br><span class="line">        return app</span><br></pre></td></tr></table></figure><h3 id="API-实现"><a href="#API-实现" class="headerlink" title="API 实现"></a><a href="about:blank#API-%E5%AE%9E%E7%8E%B0" title="API 实现"></a>API 实现</h3><p>nova/api/openstack/compute/ 目录包含每个 API 对应的 Controller 实现，Resource 对象将请求的 API 映射到相应的 Controller 方法上。</p><p>以 keypairs.py （密钥对管理扩展）为例，公共方法包含 create、delete、show、index，多个实现对应不同的 Microversion（使用 <code>@wsgi.Controller.api_version</code> 装饰器）</p><ul><li>  <code>@wsgi.expected_errors</code>：API 允许的错误返回码</li><li>  <code>@validation.query_schema</code>：请求对应的 json schema</li><li>  <code>@wsgi.response</code>：API 请求正常返回码</li><li>  <code>@wsgi.action</code>：注册 action</li></ul><p>Microversion 用于实现兼容性。</p><p>nova/api/openstack/compute/schemas 包含允许的 json schema，表示接受的键值对及其类型。</p><p>通过方法接口可以得到 webob.Request 对象，从 Request 对象中可以获取其他请求参数，用于执行对应的操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class KeypairController(wsgi.Controller):</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;Keypair API controller for the OpenStack API.&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    _view_builder_class = keypairs_view.ViewBuilder</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        super(KeypairController, self).__init__()</span><br><span class="line">        self.api = compute_api.KeypairAPI()</span><br><span class="line"></span><br><span class="line">    @wsgi.Controller.api_version(&quot;2.10&quot;)</span><br><span class="line">    @wsgi.response(201)</span><br><span class="line">    @wsgi.expected_errors((400, 403, 409))</span><br><span class="line">    @validation.schema(keypairs.create_v210)</span><br><span class="line">    def create(self, req, body):</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    @wsgi.Controller.api_version(&quot;2.2&quot;, &quot;2.9&quot;)  # noqa</span><br><span class="line">    @wsgi.response(201)</span><br><span class="line">    @wsgi.expected_errors((400, 403, 409))</span><br><span class="line">    @validation.schema(keypairs.create_v22)</span><br><span class="line">    def create(self, req, body):  # noqa</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><h2 id="nova-conductor"><a href="#nova-conductor" class="headerlink" title="nova-conductor"></a><a href="about:blank#nova-conductor" title="nova-conductor"></a>nova-conductor</h2><p>使用 RPC 的子组件通常包含以下文件：</p><ul><li>  api.py 对 RPC 接口进行封装，类似提供 SDK</li><li>  rpcapi.py 暴露给其他内部组件的 RPC 接口，RPC 客户端</li><li>  manager.py 处理 RPC API 调用</li></ul><p>nova-compute 访问数据库的操作都要由 nova-conductor 代理，用 nova/conductor/manager.py 的 ConductorManager 类完成，出于安全性考虑，nova-conductor 和 nova-compute 不能部署在同一服务器上。</p><p>nova/objects 定义了 nova object，封装数据库 CURD 操作，每个类对应数据库中的一张表。</p><h2 id="nova-scheduler"><a href="#nova-scheduler" class="headerlink" title="nova-scheduler"></a><a href="about:blank#nova-scheduler" title="nova-scheduler"></a>nova-scheduler</h2><p>nova-scheduler 执行调度决策，nova-compute 收集并更新主机数据，实时写入数据库（周期任务）。</p><p>nova/scheduler/filters 包含所有的过滤器实现，用于过滤不符合条件的主机；nova/scheduler/weights 包含所有的权重实现，用于计算权重并排序。</p><h1 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a><a href="about:blank#%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B" title="启动流程"></a>启动流程</h1><p><strong>nova-api</strong> 启动入口 <code>nova.cmd.api:main</code></p><ul><li>  <a href="https://docs.openstack.org/nova/queens/reference/gmr.html">Guru Meditation Reports</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">def main():</span><br><span class="line">    config.parse_args(sys.argv) # 解析参数</span><br><span class="line">    logging.setup(CONF, &quot;nova&quot;) # 设置日志</span><br><span class="line">    objects.register_all()      # 注册 nova object</span><br><span class="line">    gmr_opts.set_defaults(CONF) # 设置 oslo_reports</span><br><span class="line">    if &#x27;osapi_compute&#x27; in CONF.enabled_apis:</span><br><span class="line">        # NOTE(mriedem): This is needed for caching the nova-compute service</span><br><span class="line">        # version.</span><br><span class="line">        objects.Service.enable_min_version_cache()</span><br><span class="line">    log = logging.getLogger(__name__)</span><br><span class="line"></span><br><span class="line">    # 生成报告的机制 Guru Meditation Report (GMR)</span><br><span class="line">    gmr.TextGuruMeditation.setup_autorun(version, conf=CONF)</span><br><span class="line"></span><br><span class="line">    # oslo_service.ProcessLauncher</span><br><span class="line">    launcher = service.process_launcher()</span><br><span class="line">    started = 0</span><br><span class="line">    # 根据 paste-ini 文件创建 WSGI 应用</span><br><span class="line">    for api in CONF.enabled_apis:</span><br><span class="line">        should_use_ssl = api in CONF.enabled_ssl_apis</span><br><span class="line">        try:</span><br><span class="line">            # nova.service.WSGIService 初始化 WSGI 程序</span><br><span class="line">            server = service.WSGIService(api, use_ssl=should_use_ssl)</span><br><span class="line">            # oslo_service.ProcessLauncher 创建子进程启动服务</span><br><span class="line">            launcher.launch_service(server, workers=server.workers or 1)</span><br><span class="line">            started += 1</span><br><span class="line">        except exception.PasteAppNotFound as ex:</span><br><span class="line">            log.warning(&quot;%s. ``enabled_apis`` includes bad values. &quot;</span><br><span class="line">                        &quot;Fix to remove this warning.&quot;, ex)</span><br><span class="line"></span><br><span class="line">    if started == 0:</span><br><span class="line">        log.error(&#x27;No APIs were started. &#x27;</span><br><span class="line">                  &#x27;Check the enabled_apis config option.&#x27;)</span><br><span class="line">        sys.exit(1)</span><br><span class="line"></span><br><span class="line">    # 等待子进程终止</span><br><span class="line">    launcher.wait()</span><br></pre></td></tr></table></figure><p>nova.service.WSGIService 的初始化函数实例化 nova.wsgi.Server ，启动函数实际调用了 nova.wsgi.Server 的 start 方法。</p><p>其中的 self._socket 使用 <code>eventlet.listen</code> 创建，最后使用 utils 中封装的 spawn 函数启动 WSGI 程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Server(service.ServiceBase):</span><br><span class="line">    &quot;&quot;&quot;Server class to manage a WSGI server, serving a WSGI application.&quot;&quot;&quot;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    def start(self):</span><br><span class="line">        &quot;&quot;&quot;Start serving a WSGI application.</span><br><span class="line"></span><br><span class="line">        :returns: None</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # The server socket object will be closed after server exits,</span><br><span class="line">        # but the underlying file descriptor will remain open, and will</span><br><span class="line">        # give bad file descriptor error. So duplicating the socket object,</span><br><span class="line">        # to keep file descriptor usable.</span><br><span class="line"></span><br><span class="line">        dup_socket = self._socket.dup()</span><br><span class="line">        dup_socket.setsockopt(socket.SOL_SOCKET,</span><br><span class="line">                              socket.SO_REUSEADDR, 1)</span><br><span class="line">        # sockets can hang around forever without keepalive</span><br><span class="line">        dup_socket.setsockopt(socket.SOL_SOCKET,</span><br><span class="line">                              socket.SO_KEEPALIVE, 1)</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        self._server = utils.spawn(**wsgi_kwargs)</span><br></pre></td></tr></table></figure><p><strong>nova-conductor</strong> 启动入口 <code>nova.cmd.conductor:main</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def main():</span><br><span class="line">    config.parse_args(sys.argv)</span><br><span class="line">    logging.setup(CONF, &quot;nova&quot;)</span><br><span class="line">    objects.register_all()</span><br><span class="line">    gmr_opts.set_defaults(CONF)</span><br><span class="line">    objects.Service.enable_min_version_cache()</span><br><span class="line"></span><br><span class="line">    gmr.TextGuruMeditation.setup_autorun(version, conf=CONF)</span><br><span class="line"></span><br><span class="line">    # nova.service.Service 实例化 Service 对象</span><br><span class="line">    server = service.Service.create(binary=&#x27;nova-conductor&#x27;,</span><br><span class="line">                                    topic=rpcapi.RPC_TOPIC)</span><br><span class="line">    workers = CONF.conductor.workers or processutils.get_worker_count()</span><br><span class="line">    # oslo_service.launch 创建 launcher</span><br><span class="line">    service.serve(server, workers=workers)</span><br><span class="line">    # 调用 launcher.wait 等待子进程终止</span><br><span class="line">    service.wait()</span><br></pre></td></tr></table></figure><p>nova.service.Service 初始化函数接受 manager 对象，通过监听消息队列启用 RPC 服务；设置定期任务报告状态，并写入数据库。</p><ul><li>  nova-compute</li><li>  nova-conductor</li><li>  nova-scheduler</li></ul><p>RPC 服务启动时创建 rpc_client 用于发送消息，创建 rpc_server 用于接收消息，分派执行。</p><p><strong>1. rpc_client</strong></p><p>nova/cmd/conductor.py 实际创建 Service 实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server = service.Service.create(binary=&#x27;nova-conductor&#x27;,</span><br><span class="line">                                topic=rpcapi.RPC_TOPIC)</span><br></pre></td></tr></table></figure><p>nova/service.py 初始化函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 创建 _driver</span><br><span class="line">self.servicegroup_api = servicegroup.API()</span><br><span class="line"></span><br><span class="line"># 动态导入 manager 类</span><br><span class="line">manager_class = importutils.import_class(self.manager_class_name)</span><br><span class="line"></span><br><span class="line">if objects_base.NovaObject.indirection_api:</span><br><span class="line">    # 创建 RPCClient</span><br><span class="line">    conductor_api = conductor.API()</span><br><span class="line">    # 等待 nova-conductor 启动</span><br><span class="line">    conductor_api.wait_until_ready(context.get_admin_context())</span><br></pre></td></tr></table></figure><p>nova/servicegroup/api.py 创建 _driver</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">driver_class = _driver_name_class_mapping[CONF.servicegroup_driver]</span><br><span class="line">self._driver = importutils.import_object(driver_class,</span><br><span class="line">                                         *args, **kwargs)</span><br></pre></td></tr></table></figure><p>nova/conductor/api.py 实际调用 rpcapi.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def __init__(self):</span><br><span class="line">    self.conductor_rpcapi = rpcapi.ConductorAPI()</span><br><span class="line">    self.base_rpcapi = baserpc.BaseAPI(topic=rpcapi.RPC_TOPIC)</span><br></pre></td></tr></table></figure><p>nova/conductor/rpcapi.py 设置 rpc_client</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def __init__(self):</span><br><span class="line">    super(ConductorAPI, self).__init__()</span><br><span class="line">    target = messaging.Target(topic=RPC_TOPIC, version=&#x27;3.0&#x27;)</span><br><span class="line">    version_cap = self.VERSION_ALIASES.get(CONF.upgrade_levels.conductor,</span><br><span class="line">                                           CONF.upgrade_levels.conductor)</span><br><span class="line">    serializer = objects_base.NovaObjectSerializer()</span><br><span class="line">    # rpc client</span><br><span class="line">    self.client = rpc.get_client(target,</span><br><span class="line">                                 version_cap=version_cap,</span><br><span class="line">                                 serializer=serializer)</span><br></pre></td></tr></table></figure><p>nova/baserpc.py 设置 rpc_client</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def __init__(self, topic):</span><br><span class="line">    super(BaseAPI, self).__init__()</span><br><span class="line">    target = messaging.Target(topic=topic,</span><br><span class="line">                              namespace=_NAMESPACE,</span><br><span class="line">                              version=&#x27;1.0&#x27;)</span><br><span class="line">    version_cap = self.VERSION_ALIASES.get(CONF.upgrade_levels.baseapi,</span><br><span class="line">                                           CONF.upgrade_levels.baseapi)</span><br><span class="line">    self.client = rpc.get_client(target, version_cap=version_cap)</span><br></pre></td></tr></table></figure><p><strong>2. rpc_server</strong></p><p>nova/cmd/conductor.py 使用 Service 实例启动服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># oslo_service.launch 创建 launcher</span><br><span class="line">service.serve(server, workers=workers)</span><br><span class="line"># 调用 launcher.wait 等待子进程终止</span><br><span class="line">service.wait()</span><br></pre></td></tr></table></figure><p>nova/service.py 实际调用 <a href="https://github.com/openstack/oslo.service">oslo_service</a> 的 launch 函数，创建绿色线程（greenthread）或进程，最终调用 Service 实例的 start 方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def serve(server, workers=None):</span><br><span class="line">    global _launcher</span><br><span class="line">    if _launcher:</span><br><span class="line">        raise RuntimeError(_(&#x27;serve() can only be called once&#x27;))</span><br><span class="line"></span><br><span class="line">    _launcher = service.launch(CONF, server, workers=workers,</span><br><span class="line">                               restart_method=&#x27;mutate&#x27;)</span><br></pre></td></tr></table></figure><p>nova/service.py Service 实例的 start 方法创建 rpc_server 和 dispatcher；设置周期任务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 创建 rpc server 以及 dispatcher</span><br><span class="line">self.rpcserver = rpc.get_server(target, endpoints, serializer)</span><br><span class="line">self.rpcserver.start()</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">if self.periodic_enable:</span><br><span class="line">    if self.periodic_fuzzy_delay:</span><br><span class="line">        initial_delay = random.randint(0, self.periodic_fuzzy_delay)</span><br><span class="line">    else:</span><br><span class="line">        initial_delay = None</span><br><span class="line"></span><br><span class="line">    self.tg.add_dynamic_timer(self.periodic_tasks,</span><br><span class="line">                             initial_delay=initial_delay,</span><br><span class="line">                             periodic_interval_max=</span><br><span class="line">                                self.periodic_interval_max)</span><br></pre></td></tr></table></figure><p>收到消息后主要由 <a href="https://github.com/openstack/oslo.messaging">oslo_messaging</a> 进行解析和处理，核心是 oslo_messaging/rpc/dispatcher.py</p><p>incoming 是 AMQP 消息格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">def dispatch(self, incoming):</span><br><span class="line">    &quot;&quot;&quot;Dispatch an RPC message to the appropriate endpoint method.</span><br><span class="line"></span><br><span class="line">    :param incoming: incoming message</span><br><span class="line">    :type incoming: IncomingMessage</span><br><span class="line">    :raises: NoSuchMethod, UnsupportedVersion</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    message = incoming.message</span><br><span class="line">    ctxt = incoming.ctxt</span><br><span class="line"></span><br><span class="line">    method = message.get(&#x27;method&#x27;)</span><br><span class="line">    args = message.get(&#x27;args&#x27;, &#123;&#125;)</span><br><span class="line">    namespace = message.get(&#x27;namespace&#x27;)</span><br><span class="line">    version = message.get(&#x27;version&#x27;, &#x27;1.0&#x27;)</span><br><span class="line"></span><br><span class="line">    # NOTE(danms): This event and watchdog thread are used to send</span><br><span class="line">    # call-monitoring heartbeats for this message while the call</span><br><span class="line">    # is executing if it runs for some time. The thread will wait</span><br><span class="line">    # for the event to be signaled, which we do explicitly below</span><br><span class="line">    # after dispatching the method call.</span><br><span class="line">    completion_event = eventletutils.Event()</span><br><span class="line">    watchdog_thread = threading.Thread(target=self._watchdog,</span><br><span class="line">                                       args=(completion_event, incoming))</span><br><span class="line">    if incoming.client_timeout:</span><br><span class="line">        # NOTE(danms): The client provided a timeout, so we start</span><br><span class="line">        # the watchdog thread. If the client is old or didn&#x27;t send</span><br><span class="line">        # a timeout, we just never start the watchdog thread.</span><br><span class="line">        watchdog_thread.start()</span><br><span class="line"></span><br><span class="line">    found_compatible = False</span><br><span class="line">    for endpoint in self.endpoints:</span><br><span class="line">        target = getattr(endpoint, &#x27;target&#x27;, None)</span><br><span class="line">        if not target:</span><br><span class="line">            target = self._default_target</span><br><span class="line"></span><br><span class="line">        if not (self._is_namespace(target, namespace) and</span><br><span class="line">                self._is_compatible(target, version)):</span><br><span class="line">            continue</span><br><span class="line"></span><br><span class="line">        if hasattr(endpoint, method):</span><br><span class="line">            if self.access_policy.is_allowed(endpoint, method):</span><br><span class="line">                try:</span><br><span class="line">                    # 分派，调用函数</span><br><span class="line">                    return self._do_dispatch(endpoint, method, ctxt, args)</span><br><span class="line">                finally:</span><br><span class="line">                    completion_event.set()</span><br><span class="line">                    if incoming.client_timeout:</span><br><span class="line">                        watchdog_thread.join()</span><br><span class="line"></span><br><span class="line">        found_compatible = True</span><br><span class="line"></span><br><span class="line">    if found_compatible:</span><br><span class="line">        raise NoSuchMethod(method)</span><br><span class="line">    else:</span><br><span class="line">        raise UnsupportedVersion(version, method=method)</span><br></pre></td></tr></table></figure><p>oslo_messaging/rpc/dispatcher.py 调用函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def _do_dispatch(self, endpoint, method, ctxt, args):</span><br><span class="line">    ctxt = self.serializer.deserialize_context(ctxt)</span><br><span class="line">    new_args = dict()</span><br><span class="line">    for argname, arg in args.items():</span><br><span class="line">        new_args[argname] = self.serializer.deserialize_entity(ctxt, arg)</span><br><span class="line">    func = getattr(endpoint, method)</span><br><span class="line">    result = func(ctxt, **new_args)</span><br><span class="line">    return self.serializer.serialize_entity(ctxt, result)</span><br></pre></td></tr></table></figure><p>发送消息的实现都在 nova/conductor/rpcapi.py 中，cctxt.call 同步调用，cctxt.cast 异步调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def object_class_action_versions(self, context, objname, objmethod,</span><br><span class="line">                                 object_versions, args, kwargs):</span><br><span class="line">    cctxt = self.client.prepare()</span><br><span class="line">    return cctxt.call(context, &#x27;object_class_action_versions&#x27;,</span><br><span class="line">                      objname=objname, objmethod=objmethod,</span><br><span class="line">                      object_versions=object_versions,</span><br><span class="line">                      args=args, kwargs=kwargs)</span><br><span class="line"></span><br><span class="line">def cache_images(self, ctxt, aggregate, image_ids):</span><br><span class="line">    version = &#x27;1.21&#x27;</span><br><span class="line">    if not self.client.can_send_version(version):</span><br><span class="line">        raise exception.NovaException(&#x27;Conductor RPC version pin does not &#x27;</span><br><span class="line">                                      &#x27;allow cache_images() to be called&#x27;)</span><br><span class="line">    cctxt = self.client.prepare(version=version)</span><br><span class="line">    cctxt.cast(ctxt, &#x27;cache_images&#x27;, aggregate=aggregate,</span><br><span class="line">               image_ids=image_ids)</span><br></pre></td></tr></table></figure><p>由 oslo_messaging/rpc/client.py 实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">def cast(self, ctxt, method, **kwargs):</span><br><span class="line">    &quot;&quot;&quot;Invoke a method and return immediately. See RPCClient.cast().&quot;&quot;&quot;</span><br><span class="line">    msg = self._make_message(ctxt, method, kwargs)</span><br><span class="line">    msg_ctxt = self.serializer.serialize_context(ctxt)</span><br><span class="line"></span><br><span class="line">    self._check_version_cap(msg.get(&#x27;version&#x27;))</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        self.transport._send(self.target, msg_ctxt, msg,</span><br><span class="line">                             retry=self.retry,</span><br><span class="line">                             transport_options=self.transport_options)</span><br><span class="line">    except driver_base.TransportDriverError as ex:</span><br><span class="line">        raise ClientSendError(self.target, ex)</span><br><span class="line"></span><br><span class="line">def call(self, ctxt, method, **kwargs):</span><br><span class="line">    &quot;&quot;&quot;Invoke a method and wait for a reply. See RPCClient.call().&quot;&quot;&quot;</span><br><span class="line">    if self.target.fanout:</span><br><span class="line">        raise exceptions.InvalidTarget(&#x27;A call cannot be used with fanout&#x27;,</span><br><span class="line">                                       self.target)</span><br><span class="line"></span><br><span class="line">    msg = self._make_message(ctxt, method, kwargs)</span><br><span class="line">    msg_ctxt = self.serializer.serialize_context(ctxt)</span><br><span class="line"></span><br><span class="line">    timeout = self.timeout</span><br><span class="line">    if self.timeout is None:</span><br><span class="line">        timeout = self.conf.rpc_response_timeout</span><br><span class="line"></span><br><span class="line">    cm_timeout = self.call_monitor_timeout</span><br><span class="line"></span><br><span class="line">    self._check_version_cap(msg.get(&#x27;version&#x27;))</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        result = \</span><br><span class="line">            self.transport._send(self.target, msg_ctxt, msg,</span><br><span class="line">                                 wait_for_reply=True, timeout=timeout,</span><br><span class="line">                                 call_monitor_timeout=cm_timeout,</span><br><span class="line">                                 retry=self.retry,</span><br><span class="line">                                 transport_options=self.transport_options)</span><br><span class="line">    except driver_base.TransportDriverError as ex:</span><br><span class="line">        raise ClientSendError(self.target, ex)</span><br><span class="line"></span><br><span class="line">    return self.serializer.deserialize_entity(ctxt, result)</span><br></pre></td></tr></table></figure><p>关于周期任务，nova/scheduler/manager.py 中使用 <code>@periodic_task.periodic_task</code> 装饰的方法将会被周期调用，从 scheduler 的调试日志可以看到周期任务的运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">********************************************************************* log_opt_values /home/jck/.local/lib/python3.6/site-packages/oslo_config/cfg.py:2591</span><br><span class="line">2021-05-18 05:53:17.030 3501 DEBUG oslo_service.periodic_task [req-66b43add-49c7-4f33-8f6b-1e33cb9f0123 - - - - -] Running periodic task SchedulerManager._run_periodic_tasks run_periodic_tasks /home/jck/.local/lib/python3.6/site-packages/oslo_service/periodic_task.py:211</span><br><span class="line">2021-05-18 05:53:39.072 3500 DEBUG oslo_service.periodic_task [req-8436b3e2-96d1-4f15-8ae8-b596cee05536 - - - - -] Running periodic task SchedulerManager._run_periodic_tasks run_periodic_tasks /home/jck/.local/lib/python3.6/site-packages/oslo_service/periodic_task.py:211</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>对应于 nova/scheduler/manager.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@periodic_task.periodic_task(spacing=CONF.scheduler.periodic_task_interval,</span><br><span class="line">                             run_immediately=True)</span><br><span class="line">def _run_periodic_tasks(self, context):</span><br><span class="line">    self.driver.run_periodic_tasks(context)</span><br></pre></td></tr></table></figure><p>执行周期任务的有 nova-scheduler 和 nova-compute ，主要功能是计算节点 nova-compute 上报资源信息，nova-scheduler 读取数据库，更新资源信息缓存。</p><h1 id="参阅"><a href="#参阅" class="headerlink" title="参阅"></a><a href="about:blank#%E5%8F%82%E9%98%85" title="参阅"></a>参阅</h1><ul><li>  <a href="https://docs.openstack.org/nova/latest/user/architecture.html">Nova System Architecture</a></li><li>  <a href="https://docs.openstack.org/nova/latest/install/get-started-compute.html">Compute service overview</a></li><li>  <a href="https://docs.openstack.org/nova/latest/reference/rpc.html">AMQP and Nova</a></li><li>  <a href="https://docs.openstack.org/nova/latest/reference/scheduling.html">Scheduling</a></li><li>  <a href="https://docs.openstack.org/nova/latest/user/cellsv2-layout.html">Cells Layout (v2)</a></li><li>  <a href="https://www.rabbitmq.com/tutorials/amqp-concepts.html">AMQP 0-9-1 Model Explained</a></li><li>  <a href="https://rabbitmq.mr-ping.com/AMQP/AMQP_0-9-1_Model_Explained.html">AMQP 0-9-1 简介</a></li><li>  <a href="https://docs.openstack.org/nova/latest/admin/metadata-service.html">Metadata service</a></li><li>  <a href="https://docs.openstack.org/nova/queens/reference/gmr.html">Guru Meditation Reports</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;整体架构&quot;&gt;&lt;a href=&quot;#整体架构&quot; class=&quot;headerlink&quot; title=&quot;整体架构&quot;&gt;&lt;/a&gt;&lt;a href=&quot;about:blank#%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84&quot; title=&quot;整体架构&quot;&gt;&lt;/a&gt;整体架构&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;  nova 和其他组件之间的交互使用 HTTP 请求&lt;/li&gt;
&lt;li&gt;  内部组件之间使用 &lt;a href=&quot;https://github.com/openstack/oslo.messaging&quot;&gt;oslo_messaging&lt;/a&gt; 库实现 RPC 调用，这里还涉及消息队列 RabbitMQ ，遵循 AMQP 协议&lt;/li&gt;
&lt;li&gt;  大部分 nova 组件都可以运行在多个服务器上，然后使用一个管理器监听 RPC 消息&lt;/li&gt;
&lt;li&gt;  而 nova-compute 是运行在计算主机上的单进程，用于管理计算资源&lt;/li&gt;
&lt;li&gt;nova 内部组件共享本地数据库，通过对象层访问，确保兼容性和安全性&lt;ul&gt;
&lt;li&gt;  nova-compute 访问数据库由 nova-conductor 代理&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="openstack" scheme="https://rma-shuyu.github.io/categories/openstack/"/>
    
    
    <category term="nova" scheme="https://rma-shuyu.github.io/tags/nova/"/>
    
  </entry>
  
</feed>
