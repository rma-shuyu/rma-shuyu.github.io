<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rma&#39;s Blog</title>
  
  <subtitle>Stay hungry, stay foolish</subtitle>
  <link href="https://rma-shuyu.github.io/atom.xml" rel="self"/>
  
  <link href="https://rma-shuyu.github.io/"/>
  <updated>2023-07-01T09:37:27.373Z</updated>
  <id>https://rma-shuyu.github.io/</id>
  
  <author>
    <name>rma-shuyu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>libvirt with dpdk-vdpa</title>
    <link href="https://rma-shuyu.github.io/2023/03/14/libvirt-with-dpdk-vdpa/"/>
    <id>https://rma-shuyu.github.io/2023/03/14/libvirt-with-dpdk-vdpa/</id>
    <published>2023-03-14T02:05:30.000Z</published>
    <updated>2023-07-01T09:37:27.373Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OS                               : CentOS Linux release 8.4.2105</span><br><span class="line">Kernel                           : 4.18.0-305.30.1.el8.x86_64</span><br><span class="line">qemu                             : 6.2.0</span><br><span class="line">dpdk                             : 22.11.1 </span><br><span class="line">libvirt                          : 8.0.0</span><br><span class="line">设备类型                         :  net</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="dpdk-vdpa启动"><a href="#dpdk-vdpa启动" class="headerlink" title="dpdk-vdpa启动"></a>dpdk-vdpa启动</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./dpdk-vdpa -c 0x2 -n 4 --socket-mem 1024,1024 \</span><br><span class="line">            -a 0000:cc:00.1,vdpa=1  -a 0000:cc:00.2,vdpa=1  \</span><br><span class="line">                -- --iface /tmp/vdpa-socket</span><br></pre></td></tr></table></figure><h2 id="libvirt-xml配置"><a href="#libvirt-xml配置" class="headerlink" title="libvirt xml配置"></a>libvirt xml配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">domain</span> <span class="attr">type</span>=<span class="string">&quot;kvm&quot;</span> <span class="attr">xmlns:qemu</span>=<span class="string">&#x27;http://libvirt.org/schemas/domain/qemu/1.0&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>vm0<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uuid</span>&gt;</span>d37f5411-b296-11ed-8e6c-0c48c6c879e4<span class="tag">&lt;/<span class="name">uuid</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">memory</span> <span class="attr">unit</span>=<span class="string">&quot;KiB&quot;</span>&gt;</span>2097152<span class="tag">&lt;/<span class="name">memory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">memoryBacking</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hugepages</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">page</span> <span class="attr">size</span>=<span class="string">&quot;2&quot;</span> <span class="attr">unit</span>=<span class="string">&quot;M&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hugepages</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nosharepages</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">locked</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">source</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">access</span> <span class="attr">mode</span>=<span class="string">&quot;shared&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">discard</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">memoryBacking</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">vcpu</span> <span class="attr">placement</span>=<span class="string">&quot;static&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">vcpu</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">os</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">type</span> <span class="attr">arch</span>=<span class="string">&quot;x86_64&quot;</span> <span class="attr">machine</span>=<span class="string">&quot;pc-i440fx-2.1&quot;</span>&gt;</span>hvm<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">os</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cpu</span> <span class="attr">mode</span>=<span class="string">&#x27;custom&#x27;</span> <span class="attr">match</span>=<span class="string">&#x27;exact&#x27;</span> <span class="attr">check</span>=<span class="string">&#x27;full&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">model</span> <span class="attr">fallback</span>=<span class="string">&#x27;forbid&#x27;</span>&gt;</span>kvm64<span class="tag">&lt;/<span class="name">model</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">feature</span> <span class="attr">policy</span>=<span class="string">&#x27;require&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;x2apic&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">feature</span> <span class="attr">policy</span>=<span class="string">&#x27;require&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;hypervisor&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">cpu</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">features</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">acpi</span>&gt;</span><span class="tag">&lt;/<span class="name">acpi</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">features</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">clock</span> <span class="attr">offset</span>=<span class="string">&quot;utc&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">clock</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">on_poweroff</span>&gt;</span>destroy<span class="tag">&lt;/<span class="name">on_poweroff</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">on_reboot</span>&gt;</span>restart<span class="tag">&lt;/<span class="name">on_reboot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">on_crash</span>&gt;</span>destroy<span class="tag">&lt;/<span class="name">on_crash</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">devices</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">emulator</span>&gt;</span>/root/pc-bios/qemu-system-x86_64<span class="tag">&lt;/<span class="name">emulator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">disk</span> <span class="attr">device</span>=<span class="string">&quot;disk&quot;</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">bus</span>=<span class="string">&quot;ide&quot;</span> <span class="attr">dev</span>=<span class="string">&quot;hda&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">source</span> <span class="attr">file</span>=<span class="string">&quot;/mnt/store/vm0-centos8.4-8g-ext4-host-dmar.img&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">disk</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">interface</span> <span class="attr">type</span>=<span class="string">&#x27;vhostuser&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mac</span> <span class="attr">address</span>=<span class="string">&#x27;00:aa:bb:cc:dd:ee&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">source</span> <span class="attr">type</span>=<span class="string">&#x27;unix&#x27;</span> <span class="attr">path</span>=<span class="string">&#x27;/tmp/vdpa-socket0&#x27;</span> <span class="attr">mode</span>=<span class="string">&#x27;client&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">model</span> <span class="attr">type</span>=<span class="string">&#x27;virtio&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">driver</span> <span class="attr">queues</span>=<span class="string">&#x27;4&#x27;</span> <span class="attr">rx_queue_size</span>=<span class="string">&#x27;512&#x27;</span> <span class="attr">tx_queue_size</span>=<span class="string">&#x27;512&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">serial</span> <span class="attr">type</span>=<span class="string">&quot;tcp&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">source</span> <span class="attr">mode</span>=<span class="string">&quot;bind&quot;</span> <span class="attr">host</span>=<span class="string">&quot;127.0.0.1&quot;</span> <span class="attr">service</span>=<span class="string">&quot;4321&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">protocol</span> <span class="attr">type</span>=<span class="string">&quot;telnet&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">port</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">serial</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">graphics</span> <span class="attr">type</span>=<span class="string">&#x27;vnc&#x27;</span> <span class="attr">port</span>=<span class="string">&#x27;5901&#x27;</span> <span class="attr">listen</span>=<span class="string">&#x27;0.0.0.0&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listen</span> <span class="attr">type</span>=<span class="string">&#x27;address&#x27;</span> <span class="attr">address</span>=<span class="string">&#x27;0.0.0.0&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">graphics</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">devices</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">qemu:commandline</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">qemu:arg</span> <span class="attr">value</span>=<span class="string">&#x27;-L&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">qemu:arg</span> <span class="attr">value</span>=<span class="string">&#x27;/root/pc-bios&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">qemu:commandline</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="验证结果"><a href="#验证结果" class="headerlink" title="验证结果"></a>验证结果</h2><p>1、查看libvirt是否正常拉起vm</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># virsh -c qemu+tcp:///system create vm.xml</span></span><br><span class="line">Domain <span class="string">&#x27;vm0&#x27;</span> created from vm.xml</span><br><span class="line"></span><br><span class="line"><span class="comment"># virsh list</span></span><br><span class="line"> Id   Name   State</span><br><span class="line">----------------------</span><br><span class="line"> 29   vm0    running</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2、ping测试<br><img src="03e2f3d08b21dc6b24565608fdd47abc9cbe6acb6bd8286f651bb44728647ad3.png" alt="图 2">  </p><h2 id="调试问题"><a href="#调试问题" class="headerlink" title="调试问题"></a>调试问题</h2><p>使用libvirt拉起vm时，ping failed<br><img src="3d9fe6c5801dcd971f82c9826d8fd9e596c0c1edd45cd42b49d299b31abe463e.png" alt="图 1">  </p><h3 id="定位过程"><a href="#定位过程" class="headerlink" title="定位过程"></a>定位过程</h3><p>1、查看/var/log/libvirt/qemu/vm0.log日志，发现存在错误日志打印，可以看到qemu启动参数需要指定<code>memory-backend-file</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2023-06-14T01:53:51.897860Z qemu-system-x86_64: Failed initializing vhost-user memory map, consider using -object memory-backend-file share=on</span><br><span class="line">2023-06-14T01:53:51.897958Z qemu-system-x86_64: vhost_set_mem_table failed: Input/output error (5)</span><br><span class="line">2023-06-14T01:53:51.912732Z qemu-system-x86_64: unable to start vhost net: 5: falling back on userspace virtio</span><br><span class="line">2023-06-14T01:53:51.949246Z qemu-system-x86_64: Failed initializing vhost-user memory map, consider using -object memory-backend-file share=on</span><br><span class="line">2023-06-14T01:53:51.949266Z qemu-system-x86_64: vhost_set_mem_table failed: Resource temporarily unavailable (11)</span><br><span class="line">2023-06-14T01:53:51.963736Z qemu-system-x86_64: unable to start vhost net: 11: falling back on userspace virtio</span><br></pre></td></tr></table></figure><p>2、查看qemu启动进程参数，发现qemu参数指定的是<code>memory-backend-ram</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root        6394       1 50 08:23 ?        00:00:47 /root/pc-bios/qemu-system-x86_64 -name guest=vm0,debug-threads=on -S -object &#123;<span class="string">&quot;qom-type&quot;</span>:<span class="string">&quot;secret&quot;</span>,<span class="string">&quot;id&quot;</span>:<span class="string">&quot;masterKey0&quot;</span>,<span class="string">&quot;format&quot;</span>:<span class="string">&quot;raw&quot;</span>,<span class="string">&quot;file&quot;</span>:<span class="string">&quot;/var/lib/libvirt/qemu/domain-10-vm0/master-key.aes&quot;</span>&#125; -machine pc-i440fx-2.1,usb=off,dump-guest-core=off,memory-backend=pc.ram -accel kvm -cpu kvm64,x2apic=on,hypervisor=on -m 2048 -object &#123;<span class="string">&quot;qom-type&quot;</span>:<span class="string">&quot;memory-backend-ram&quot;</span>,<span class="string">&quot;id&quot;</span>:<span class="string">&quot;pc.ram&quot;</span>,<span class="string">&quot;size&quot;</span>:2147483648&#125; -overcommit mem-lock=off -smp 2,sockets=2,cores=1,threads=1 -uuid d37f5411-b296-11ed-8e6c-0c48c6c879e4 -no-user-config -nodefaults -chardev socket,<span class="built_in">id</span>=charmonitor,fd=38,server=on,<span class="built_in">wait</span>=off -mon chardev=charmonitor,<span class="built_in">id</span>=monitor,mode=control -rtc base=utc -no-shutdown -boot strict=on -device piix3-usb-uhci,<span class="built_in">id</span>=usb,bus=pci.0,addr=0x1.0x2 -blockdev &#123;<span class="string">&quot;driver&quot;</span>:<span class="string">&quot;file&quot;</span>,<span class="string">&quot;filename&quot;</span>:<span class="string">&quot;/mnt/store/vm0-centos8.4-8g-ext4-host-dmar.img&quot;</span>,<span class="string">&quot;node-name&quot;</span>:<span class="string">&quot;libvirt-1-storage&quot;</span>,<span class="string">&quot;auto-read-only&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;discard&quot;</span>:<span class="string">&quot;unmap&quot;</span>&#125; -blockdev &#123;<span class="string">&quot;node-name&quot;</span>:<span class="string">&quot;libvirt-1-format&quot;</span>,<span class="string">&quot;read-only&quot;</span>:<span class="literal">false</span>,<span class="string">&quot;driver&quot;</span>:<span class="string">&quot;raw&quot;</span>,<span class="string">&quot;file&quot;</span>:<span class="string">&quot;libvirt-1-storage&quot;</span>&#125; -device ide-hd,bus=ide.0,unit=0,drive=libvirt-1-format,<span class="built_in">id</span>=ide0-0-0,bootindex=1 -chardev socket,<span class="built_in">id</span>=charnet0,path=/tmp/vdpa-socket0 -netdev vhost-user,chardev=charnet0,queues=4,<span class="built_in">id</span>=hostnet0 -device virtio-net-pci,mq=on,vectors=10,rx_queue_size=512,tx_queue_size=512,netdev=hostnet0,<span class="built_in">id</span>=net0,mac=00:aa:bb:cc:<span class="built_in">dd</span>:ee,bus=pci.0,addr=0x3 -chardev socket,<span class="built_in">id</span>=charserial0,host=127.0.0.1,port=4321,telnet=on,server=on,<span class="built_in">wait</span>=off -device isa-serial,chardev=charserial0,<span class="built_in">id</span>=serial0 -audiodev &#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;audio1&quot;</span>,<span class="string">&quot;driver&quot;</span>:<span class="string">&quot;none&quot;</span>&#125; -vnc 0.0.0.0:0,audiodev=audio1 -device cirrus-vga,<span class="built_in">id</span>=video0,bus=pci.0,addr=0x2 -device virtio-balloon-pci,<span class="built_in">id</span>=balloon0,bus=pci.0,addr=0x4 -L /root/pc-bios -msg timestamp=on</span><br></pre></td></tr></table></figure><h3 id="根因分析"><a href="#根因分析" class="headerlink" title="根因分析"></a>根因分析</h3><p>qemu进程在ram_block初始化的时候根据memory-backend-xxx，其中xxx可以指定file、memfd、ram，<br>从而指定不同的内存申请方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">host_memory_backend_memory_complete(UserCreatable *uc, Error **errp)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (bc-&gt;alloc) &#123;</span><br><span class="line">        bc-&gt;alloc(backend, &amp;local_err);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当指定memory-backend-file<br>则bc-&gt;alloc = file_backend_memory_alloc</p><p>当指定memory-backend-ram<br>则bc-&gt;alloc = ram_backend_memory_alloc;</p><p>这两个主要的区别在于申请ram_block时，file_backend_memory_alloc会额外申请一个fd，用于前后端进程共享内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RAMBlock *<span class="title function_">qemu_ram_alloc_from_file</span><span class="params">(<span class="type">ram_addr_t</span> size, MemoryRegion *mr,</span></span><br><span class="line"><span class="params">                                   <span class="type">uint32_t</span> ram_flags, <span class="type">const</span> <span class="type">char</span> *mem_path,</span></span><br><span class="line"><span class="params">                                   <span class="type">bool</span> readonly, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    fd = file_ram_open(mem_path, memory_region_name(mr), readonly, &amp;created,</span><br><span class="line">                       errp);</span><br><span class="line">...</span><br><span class="line">    block = qemu_ram_alloc_from_fd(size, mr, ram_flags, fd, <span class="number">0</span>, readonly, errp);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MemoryRegion通过vhost-user VHOST_USER_SET_MEM_TABLE消息传递到dpdk-vdpa进程<br>如果不指定memory-backend-file，VHOST_USER_SET_MEM_TABLE消息失败，在vhost_dev_start中返回失败，不会走后续设备启动流程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vhost_dev_start</span><span class="params">(<span class="keyword">struct</span> vhost_dev *hdev, VirtIODevice *vdev)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    r = hdev-&gt;vhost_ops-&gt;vhost_set_mem_table(hdev, hdev-&gt;mem);</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        VHOST_OPS_DEBUG(<span class="string">&quot;vhost_set_mem_table failed&quot;</span>);</span><br><span class="line">        r = -errno;</span><br><span class="line">        <span class="keyword">goto</span> fail_mem;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">     r = hdev-&gt;vhost_ops-&gt;vhost_dev_start(hdev, <span class="literal">true</span>);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题修复"><a href="#问题修复" class="headerlink" title="问题修复"></a>问题修复</h3><p>libvirt xml指定memoryBacking类型为file</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">domain</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;<span class="name">memoryBacking</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hugepages</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">page</span> <span class="attr">size</span>=<span class="string">&quot;2&quot;</span> <span class="attr">unit</span>=<span class="string">&quot;M&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hugepages</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nosharepages</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">locked</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">source</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">access</span> <span class="attr">mode</span>=<span class="string">&quot;shared&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">discard</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">memoryBacking</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时再次启动vm，可以发现此时qemu进程启动参数为<code>memory-backend-file</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root       17715       1 75 23:02 ?        00:00:47 /root/pc-bios/qemu-system-x86_64 -name guest=vm0,debug-threads=on -S -object &#123;<span class="string">&quot;qom-type&quot;</span>:<span class="string">&quot;secret&quot;</span>,<span class="string">&quot;id&quot;</span>:<span class="string">&quot;masterKey0&quot;</span>,<span class="string">&quot;format&quot;</span>:<span class="string">&quot;raw&quot;</span>,<span class="string">&quot;file&quot;</span>:<span class="string">&quot;/var/lib/libvirt/qemu/domain-3-vm0/master-key.aes&quot;</span>&#125; -machine pc-i440fx-2.1,usb=off,dump-guest-core=off,mem-merge=off,memory-backend=pc.ram -accel kvm -cpu kvm64,x2apic=on,hypervisor=on -m 2048 -object &#123;<span class="string">&quot;qom-type&quot;</span>:<span class="string">&quot;memory-backend-file&quot;</span>,<span class="string">&quot;id&quot;</span>:<span class="string">&quot;pc.ram&quot;</span>,<span class="string">&quot;mem-path&quot;</span>:<span class="string">&quot;/dev/hugepages/libvirt/qemu/3-vm0&quot;</span>,<span class="string">&quot;discard-data&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;share&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;x-use-canonical-path-for-ramblock-id&quot;</span>:<span class="literal">false</span>,<span class="string">&quot;prealloc&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;size&quot;</span>:2147483648&#125; -overcommit mem-lock=on -smp 2,sockets=2,cores=1,threads=1 -uuid d37f5411-b296-11ed-8e6c-0c48c6c879e4 -no-user-config -nodefaults -chardev socket,<span class="built_in">id</span>=charmonitor,fd=39,server=on,<span class="built_in">wait</span>=off -mon chardev=charmonitor,<span class="built_in">id</span>=monitor,mode=control -rtc base=utc -no-shutdown -boot strict=on -device piix3-usb-uhci,<span class="built_in">id</span>=usb,bus=pci.0,addr=0x1.0x2 -blockdev &#123;<span class="string">&quot;driver&quot;</span>:<span class="string">&quot;file&quot;</span>,<span class="string">&quot;filename&quot;</span>:<span class="string">&quot;/mnt/store/vm0-centos8.4-8g-ext4-host-dmar.img&quot;</span>,<span class="string">&quot;node-name&quot;</span>:<span class="string">&quot;libvirt-1-storage&quot;</span>,<span class="string">&quot;auto-read-only&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;discard&quot;</span>:<span class="string">&quot;unmap&quot;</span>&#125; -blockdev &#123;<span class="string">&quot;node-name&quot;</span>:<span class="string">&quot;libvirt-1-format&quot;</span>,<span class="string">&quot;read-only&quot;</span>:<span class="literal">false</span>,<span class="string">&quot;driver&quot;</span>:<span class="string">&quot;raw&quot;</span>,<span class="string">&quot;file&quot;</span>:<span class="string">&quot;libvirt-1-storage&quot;</span>&#125; -device ide-hd,bus=ide.0,unit=0,drive=libvirt-1-format,<span class="built_in">id</span>=ide0-0-0,bootindex=1 -chardev socket,<span class="built_in">id</span>=charnet0,path=/tmp/vdpa-socket0 -netdev vhost-user,chardev=charnet0,queues=4,<span class="built_in">id</span>=hostnet0 -device virtio-net-pci,mq=on,vectors=10,rx_queue_size=512,tx_queue_size=512,netdev=hostnet0,<span class="built_in">id</span>=net0,mac=00:aa:bb:cc:<span class="built_in">dd</span>:ee,bus=pci.0,addr=0x3 -chardev socket,<span class="built_in">id</span>=charserial0,host=127.0.0.1,port=4321,telnet=on,server=on,<span class="built_in">wait</span>=off -device isa-serial,chardev=charserial0,<span class="built_in">id</span>=serial0 -audiodev &#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;audio1&quot;</span>,<span class="string">&quot;driver&quot;</span>:<span class="string">&quot;none&quot;</span>&#125; -vnc 0.0.0.0:0,audiodev=audio1 -device cirrus-vga,<span class="built_in">id</span>=video0,bus=pci.0,addr=0x2 -device virtio-balloon-pci,<span class="built_in">id</span>=balloon0,bus=pci.0,addr=0x4 -L /root/pc-bios -msg timestamp=on</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;环境信息&quot;&gt;&lt;a href=&quot;#环境信息&quot; class=&quot;headerlink&quot; title=&quot;环境信息&quot;&gt;&lt;/a&gt;环境信息&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;OS                               : CentOS Linux release 8.4.2105&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Kernel                           : 4.18.0-305.30.1.el8.x86_64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;qemu                             : 6.2.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dpdk                             : 22.11.1 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;libvirt                          : 8.0.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;设备类型                         :  net&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="虚拟化" scheme="https://rma-shuyu.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="Libvirt" scheme="https://rma-shuyu.github.io/tags/Libvirt/"/>
    
  </entry>
  
  <entry>
    <title>DPDK+OVS+QEMU前后端启动vm</title>
    <link href="https://rma-shuyu.github.io/2023/03/06/DPDK-OVS-QEMU%E5%89%8D%E5%90%8E%E7%AB%AF%E5%90%AF%E5%8A%A8vm/"/>
    <id>https://rma-shuyu.github.io/2023/03/06/DPDK-OVS-QEMU%E5%89%8D%E5%90%8E%E7%AB%AF%E5%90%AF%E5%8A%A8vm/</id>
    <published>2023-03-06T08:01:04.000Z</published>
    <updated>2023-07-29T06:46:38.891Z</updated>
    
    <content type="html"><![CDATA[<h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><ul><li><p>DPDK 22.11.1</p></li><li><p>A DPDK supported NIC</p></li></ul><p>Only required when physical ports are in use</p><span id="more"></span><ul><li>A suitable kernel</li></ul><p>On Linux Distros running kernel version &gt;= 3.0, only IOMMU needs to enabled via the grub cmdline, assuming you are using VFIO. For older kernels, ensure the kernel is built with UIO, HUGETLBFS, PROC_PAGE_MONITOR, HPET, HPET_MMAP support. If these are not present, it will be necessary to upgrade your kernel or build a custom kernel with these flags enabled.</p><h2 id="dpdk环境设置"><a href="#dpdk环境设置" class="headerlink" title="dpdk环境设置"></a>dpdk环境设置</h2><p>检查VT-d功能是否打开</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/cmdline | grep iommu=pt</span><br><span class="line"><span class="built_in">cat</span> /proc/cmdline | grep intel_iommu=on</span><br></pre></td></tr></table></figure><p>如果没有开启，那么需要修改/etc/default/grub中GRUB_CMDLINE_LINUX_DEFAULT，重新创建引导grub</p><p>设置大页，加载vfio，绑定物理网卡到vfio</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">huge_set --setup 4g</span><br><span class="line">modprobe vfio-pci</span><br><span class="line">dpdk_bind -b vfio-pci ens33f1</span><br></pre></td></tr></table></figure><p>这里的<code>huge_set</code>、<code>dpdk_bind</code>对应dpdk bin中的<code>dpdk-devbind.py</code>、<code>dpdk-hugepages.py</code></p><h2 id="ovs启动"><a href="#ovs启动" class="headerlink" title="ovs启动"></a>ovs启动</h2><ul><li>创建ovs相关目录</li><li>第一次需要创建ovsdb</li><li>启动ovsdb-server</li><li>检查db.sock是否正常创建</li><li>设置other_config为dpdk模式</li><li>启动ovs-vswitchd</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /mnt/store/ovs/images/bin</span><br><span class="line"></span><br><span class="line">dpdk_socket_mem=<span class="string">&quot;1024,0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p /var/run/openvswitch</span><br><span class="line"><span class="built_in">mkdir</span> -p /etc/openvswitch</span><br><span class="line"><span class="built_in">mkdir</span> -p /var/log/openvswitch</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ! <span class="built_in">test</span> -f /etc/openvswitch/conf.db; <span class="keyword">then</span></span><br><span class="line">./ovsdb-tool create /etc/openvswitch/conf.db /mnt/store/ovs/images/db/vswitch.ovsschema</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">./ovsdb-server /etc/openvswitch/conf.db -vconsole:emer -vsyslog:err -vfile:info --remote=punix:/var/run/openvswitch/db.sock --private-key=db:Open_vSwitch,SSL,private_key --certificate=db:Open_vSwitch,SSL,certificate --bootstrap-ca-cert=db:Open_vSwitch,SSL,ca_cert --no-chdir --log-file=/var/log/openvswitch/ovsdb-server.log --pidfile=/var/run/openvswitch/ovsdb-server.pid --detach --monitor</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [ ! -S /var/run/openvswitch/db.sock ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">sleep</span> 1</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">./ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-init=<span class="literal">true</span></span><br><span class="line">./ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-extra=<span class="string">&quot;--iova-mode=pa&quot;</span></span><br><span class="line">./ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-socket-mem=<span class="variable">$dpdk_socket_mem</span></span><br><span class="line"></span><br><span class="line">./ovs-vswitchd unix:/var/run/openvswitch/db.sock -vconsole:emer -vsyslog:err -vfile:info --mlockall --no-chdir --log-file=/var/log/openvswitch/ovs-vswitchd.log --pidfile=/var/run/openvswitch/ovs-vswitchd.pid --detach --monitor</span><br></pre></td></tr></table></figure><h2 id="ovs停止运行"><a href="#ovs停止运行" class="headerlink" title="ovs停止运行"></a>ovs停止运行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ovs-appctl -t ovs-vswitchd <span class="built_in">exit</span></span><br><span class="line">ovs-appctl -t ovsdb-server <span class="built_in">exit</span></span><br></pre></td></tr></table></figure><h2 id="ovs创建port"><a href="#ovs创建port" class="headerlink" title="ovs创建port"></a>ovs创建port</h2><ul><li>创建网桥</li><li>物理端口绑定网桥</li><li>前后端通信端口绑定网桥</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">/mnt/store/ovs/images/bin/ovs-vsctl --may-exist add-br br0 -- <span class="built_in">set</span> bridge br0 datapath_type=netdev</span><br><span class="line"></span><br><span class="line"><span class="comment"># dpdk-devargs后面跟的是dpdk绑定网卡的pci bdf号</span></span><br><span class="line">/mnt/store/ovs/images/bin/ovs-vsctl --may-exist add-port br0 phy0 -- <span class="built_in">set</span> Interface phy0 <span class="built_in">type</span>=dpdk options:dpdk-devargs=0000:24:00.1</span><br><span class="line"></span><br><span class="line">/mnt/store/ovs/images/bin/ovs-vsctl --may-exist add-port br0 vhost-user-1 -- <span class="built_in">set</span> Interface vhost-user-1 <span class="built_in">type</span>=dpdkvhostuserclient options:vhost-server-path=<span class="string">&quot;/tmp/sock0&quot;</span></span><br></pre></td></tr></table></figure><ul><li>ovs-vsctl show查看运行结果</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /mnt/store/ovs/images/bin/ovs-vsctl show</span></span><br><span class="line">90ce12f9-3e63-4fff-b615-ae7e864858db</span><br><span class="line">    Bridge br0</span><br><span class="line">        datapath_type: netdev</span><br><span class="line">        Port br0</span><br><span class="line">            Interface br0</span><br><span class="line">                <span class="built_in">type</span>: internal</span><br><span class="line">        Port vhost-user-1</span><br><span class="line">            Interface vhost-user-1</span><br><span class="line">                <span class="built_in">type</span>: dpdkvhostuserclient</span><br><span class="line">                options: &#123;vhost-server-path=<span class="string">&quot;/tmp/sock0&quot;</span>&#125;</span><br><span class="line">        Port phy0</span><br><span class="line">            Interface phy0</span><br><span class="line">                <span class="built_in">type</span>: dpdk</span><br><span class="line">                options: &#123;dpdk-devargs=<span class="string">&quot;0000:24:00.1&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="qemu启动"><a href="#qemu启动" class="headerlink" title="qemu启动"></a>qemu启动</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">ulimit</span> -l unlimited</span><br><span class="line">/root/pc-bios/qemu-system-x86_64  \</span><br><span class="line">-enable-kvm -m 2048 -cpu host \</span><br><span class="line">-hda /mnt/store/vm0-centos8.4-8g-ext4-host-dmar.img \</span><br><span class="line">-object memory-backend-file,<span class="built_in">id</span>=mem,size=2048M,mem-path=/dev/hugepages,share=on \</span><br><span class="line">-mem-prealloc \</span><br><span class="line">-numa node,memdev=mem \</span><br><span class="line">-chardev socket,<span class="built_in">id</span>=char0,path=/tmp/sock0,server=on \</span><br><span class="line">-netdev <span class="built_in">type</span>=vhost-user,<span class="built_in">id</span>=vdpa,chardev=char0,queues=4 \</span><br><span class="line">-device virtio-net-pci,mq=on,rx_queue_size=512,tx_queue_size=512,netdev=vdpa,mac=00:aa:bb:cc:<span class="built_in">dd</span>:ee,page-per-vq=on,disable-modern=on,disable-legacy=off \</span><br><span class="line">-serial telnet:127.1:4321,server,nowait \</span><br><span class="line">-monitor stdio \</span><br><span class="line">-D ./qemu-vm0.<span class="built_in">log</span> \</span><br><span class="line">-vnc :90 -L /root/pc-bios</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ping包测试"><a href="#ping包测试" class="headerlink" title="ping包测试"></a>ping包测试</h2><p>host上网桥配置ip，端口up</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig br0 192.188.1.3/24 up</span><br></pre></td></tr></table></figure><p>geust上net口配置同网段ip，端口up</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig ens3 192.188.1.2/24 up</span><br></pre></td></tr></table></figure><p>vm ping host<br><img src="212553173cc3f955da5935e31ed69460df0ad4632296146b4ae845f52fe8edde.png" alt="图 1">  </p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;先决条件&quot;&gt;&lt;a href=&quot;#先决条件&quot; class=&quot;headerlink&quot; title=&quot;先决条件&quot;&gt;&lt;/a&gt;先决条件&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;DPDK 22.11.1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A DPDK supported NIC&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Only required when physical ports are in use&lt;/p&gt;</summary>
    
    
    
    <category term="虚拟化" scheme="https://rma-shuyu.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="DPDK" scheme="https://rma-shuyu.github.io/tags/DPDK/"/>
    
    <category term="OVS" scheme="https://rma-shuyu.github.io/tags/OVS/"/>
    
    <category term="QEMU" scheme="https://rma-shuyu.github.io/tags/QEMU/"/>
    
  </entry>
  
  <entry>
    <title>VSCode使用CodeGPT</title>
    <link href="https://rma-shuyu.github.io/2023/02/10/VSCode%E4%BD%BF%E7%94%A8CodeGPT/"/>
    <id>https://rma-shuyu.github.io/2023/02/10/VSCode%E4%BD%BF%E7%94%A8CodeGPT/</id>
    <published>2023-02-10T12:48:58.000Z</published>
    <updated>2023-07-01T09:37:27.342Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>CodeGPT</code>允许我们通过官方<code>OpenAI API</code>在<code>VSCode</code>中使用<code>GPT-3</code>，使得我们可以在代码编辑器拥有了<code>ChatGPT</code>。<br>借助 <code>CodeGPT</code>，我们可以生成代码、解释代码、重构代码等等。</p><span id="more"></span><h2 id="安装和设置"><a href="#安装和设置" class="headerlink" title="安装和设置"></a>安装和设置</h2><p>打开VSCode编辑器，点击扩展，然后在搜索框中输入“Code GPT”，然后点击“安装”。<br><img src="11a74d39367434d81ee6d91b62f82591270e1597d59b0237479cd9ed18ad5c4f.png" alt="图 5">  </p><p>Code GPT安装完，进到“Settings”界面，然后找到扩展下的“Code GPT”<br>CodeGPT的设置界面如下：<br><img src="79e7618f461b768065b9fea7f62b8f19727bc3c644aa6a05a332f304007086c6.png" alt="图 4">  </p><p><img src="a551258121c4603e9a22a950ebcac95490ec3ed3132b6b65998478d96b0069e0.png" alt="图 6">  </p><p>想要让CodeGPT运行起来，需要在上图的输入框处输入<a href="https://platform.openai.com/account/api-keys">OpenAI API key</a>，API key需要到OpenAI的官网生成。<br><img src="1ec8c9b392d9b9c48adef2505b45788e26fae2b55c8e30fbd6db20885f54e342.png" alt="图 7">  </p><p><strong>使用注意</strong><br>在WSL中无法使用CodeGPT，需要在Windows端使用</p><h2 id="解释代码"><a href="#解释代码" class="headerlink" title="解释代码"></a>解释代码</h2><p>选中代码，右键点击<code>Explain CodeGPT</code><br><img src="a1f348872a247c684d3eb2ee93a9801cc1a7e5094b5b4696a572c5759883d1f5.png" alt="图 1">  </p><h2 id="生成代码"><a href="#生成代码" class="headerlink" title="生成代码"></a>生成代码</h2><p>在对应后缀的代码文件中描述注释，并将光标点击到文末，快捷键ctrl+shift+i<br><img src="7fef95c4a63f509a4d1ce45159b1e1a344f6ce8c991344b63d674e52fd9c108f.png" alt="图 3">  </p><h2 id="重构代码"><a href="#重构代码" class="headerlink" title="重构代码"></a>重构代码</h2><p>选中代码，右键点击<code>Refactor CodeGPT</code><br><img src="95d51eff9bcb3c7c2c3d03bc3b67ba6cb3e8f1da454757e2d083fae5c0f4c7b2.png" alt="图 2">  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重构后的代码</span></span><br><span class="line">wait_for_process() &#123;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">参数说明</span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash"><span class="variable">$1</span>: 进程名</span></span><br><span class="line">  </span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">输入验证</span></span><br><span class="line">  if [ $# -ne 1 ]; then</span><br><span class="line">    echo &quot;Parameters incorrect&quot;</span><br><span class="line">    exit 1</span><br><span class="line">  fi</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">设置超时时间</span></span><br><span class="line">  WAIT_TIMEOUT=10</span><br><span class="line"></span><br><span class="line">  for i in $(seq 1 $WAIT_TIMEOUT); do</span><br><span class="line">    # 检索进程ID</span><br><span class="line">    proc_pid=$(pidof $1)</span><br><span class="line"></span><br><span class="line">    if [ &quot;$proc_pid&quot; != &quot;&quot; ]</span><br><span class="line">    then</span><br><span class="line">      # 进程已启动，返回</span><br><span class="line">      echo &quot;$1 started&quot;</span><br><span class="line">      return</span><br><span class="line">    fi</span><br><span class="line">    </span><br><span class="line">    echo &quot;Waiting for $1 to start&quot;</span><br><span class="line">    sleep 1</span><br><span class="line">  done</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">  # </span><span class="language-bash">超时</span></span><br><span class="line">  echo &quot;Timeout waiting for $1 to start&quot;</span><br><span class="line">  exit 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;code&gt;CodeGPT&lt;/code&gt;允许我们通过官方&lt;code&gt;OpenAI API&lt;/code&gt;在&lt;code&gt;VSCode&lt;/code&gt;中使用&lt;code&gt;GPT-3&lt;/code&gt;，使得我们可以在代码编辑器拥有了&lt;code&gt;ChatGPT&lt;/code&gt;。&lt;br&gt;借助 &lt;code&gt;CodeGPT&lt;/code&gt;，我们可以生成代码、解释代码、重构代码等等。&lt;/p&gt;</summary>
    
    
    
    <category term="VSCODE" scheme="https://rma-shuyu.github.io/categories/VSCODE/"/>
    
    
    <category term="CodeGPT" scheme="https://rma-shuyu.github.io/tags/CodeGPT/"/>
    
  </entry>
  
  <entry>
    <title>gitstats使用介绍</title>
    <link href="https://rma-shuyu.github.io/2022/12/05/gitstats%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/"/>
    <id>https://rma-shuyu.github.io/2022/12/05/gitstats%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/</id>
    <published>2022-12-05T11:51:50.000Z</published>
    <updated>2023-01-27T12:06:26.878Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>进一步来讲，Gitstats它是一个git仓库分析软件，它可以检查仓库并生成历史数据的统计信息。可以帮助你查看git仓库的提交状态，根据不同维度分析计算，并自动生成数据图表。<br>官网介绍：<a href="http://gitstats.sourceforge.net/">http://gitstats.sourceforge.net/</a></p><span id="more"></span><p>当前GitStats所生成统计信息常用分为如下几类：<br><strong>常规的统计</strong>：文件总数，行数，提交量，作者数。<br><strong>活跃性</strong>：每天中每小时的、每周中每天的、每周中每小时的、每年中每月的、每年的提交量。<br><strong>作者数</strong>：列举所有的作者（提交数，第一次提交日期，最近一次的提交日期），并按月和年来划分。<br><strong>文件数</strong>：按日期划分，按扩展名名划分。<br><strong>行数</strong>：按日期划分。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//mac osx</span><br><span class="line">brew install gnuplot</span><br><span class="line">//centos linux</span><br><span class="line">yum install gnuplot</span><br><span class="line">//ubuntu linux</span><br><span class="line">apt install gnuplot</span><br></pre></td></tr></table></figure><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git://github.com/hoxu/gitstats.git</span><br><span class="line"><span class="built_in">cd</span> gitstats</span><br><span class="line">./gitstats 你的项目的位置 生成统计的文件夹位置</span><br></pre></td></tr></table></figure><h2 id="展示"><a href="#展示" class="headerlink" title="展示"></a>展示</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> 生成统计的文件夹位置</span><br><span class="line">python3 -m http.server 8090</span><br></pre></td></tr></table></figure><h2 id="qemu示例"><a href="#qemu示例" class="headerlink" title="qemu示例"></a>qemu示例</h2><p>如下图所示。首先，在gitstats上提供了全局的统计数据报告，包括：</p><p><strong>报告产生时间及产生所花费的时间</strong>：如花费了710秒<br><strong>报告所覆盖的时间</strong>：如2003-02-19 to 2022-12-05<br><strong>年龄</strong>：该repo的年纪，如“7230天，其中5918天是活跃天.”<br><strong>文件数及代码</strong>：如：9256个文件，3130k行代码。<br><strong>总提交数</strong>：如：99776，平均每天13.8个<br><strong>作者数</strong>：如2160，每个作者平均提交次数46.2次。<br><img src="efbe731981191bf53d5ddccfb0d2ceddc68787753068302bb6b07ae3325161c7.png" alt="图 6">  </p><p>除此之外，还包括了：</p><ol><li>时间维度的效率分析：每天中每小时的、每周中每天的、每周中每小时的、每年中每月的、每年的提交量。<br><img src="e3f27ccfddf1d938e78059ed84dbee1e10029e531785d1c35dbd64ec9fd176e4.png" alt="图 7"><br><img src="c2af9654b130fbe357f60fc7d9b0d9f688909b0fd41cc173ed06bc9609bb03db.png" alt="图 8"><br><img src="fe0f04ea5472dac1bb45ef27504cf61e91c71154babe868b1d90ae164ffa901c.png" alt="图 9"><br><img src="d8a4aee3fe667a3fe39257feb14b177fc098d0952bfb78cf7a3139ac838adb95.png" alt="图 10"><br><img src="b04a8580c65f01373f091389a9c3a7d3138acb8aaf002e9a21a5ae8b8587acf5.png" alt="图 11"><br><img src="226d67aed51a110fa818c54b82b4e74434e727c354565bcf779b19f6ba31dd55.png" alt="图 12">  </li></ol><ol start="2"><li>提交者维度的活跃度统计：列举所有的作者（提交数，第一次提交日期，最近一次的提交日期），并按月和年来划分。<br><img src="1245268c1062710ee022fb12149e82705b29e4591c0e3aacb7fd844462b8bdaf.png" alt="图 13">  </li></ol><ol start="3"><li><p>按照文件数：按日期划分，按扩展名名划分。<br><img src="1bacc00060ca63e9f239802a91e68849e4337457d9909e0754eee5fc1664a4ee.png" alt="图 14">  </p></li><li><p>根据提交行数或提交的tag来统计。<br><img src="29853f0496e7b26c4d69af48e2d863367a2c96ee70534f89698a31e3f49b03a4.png" alt="图 15">  </p></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;进一步来讲，Gitstats它是一个git仓库分析软件，它可以检查仓库并生成历史数据的统计信息。可以帮助你查看git仓库的提交状态，根据不同维度分析计算，并自动生成数据图表。&lt;br&gt;官网介绍：&lt;a href=&quot;http://gitstats.sourceforge.net/&quot;&gt;http://gitstats.sourceforge.net/&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="GIT" scheme="https://rma-shuyu.github.io/categories/GIT/"/>
    
    
    <category term="git" scheme="https://rma-shuyu.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>centos8安装pprof</title>
    <link href="https://rma-shuyu.github.io/2022/11/22/centos8%E5%AE%89%E8%A3%85pprof/"/>
    <id>https://rma-shuyu.github.io/2022/11/22/centos8%E5%AE%89%E8%A3%85pprof/</id>
    <published>2022-11-22T12:24:34.000Z</published>
    <updated>2023-01-27T12:06:26.873Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这是谷歌的一个linux下性能测试的小工具。可以简单快速的发现程序的性能瓶颈。</p><span id="more"></span><h2 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /etc/*release</span></span><br><span class="line">CentOS Linux release 8.4.2105</span><br><span class="line">NAME=<span class="string">&quot;CentOS Linux&quot;</span></span><br><span class="line">VERSION=<span class="string">&quot;8&quot;</span></span><br><span class="line">ID=<span class="string">&quot;centos&quot;</span></span><br><span class="line">ID_LIKE=<span class="string">&quot;rhel fedora&quot;</span></span><br><span class="line">VERSION_ID=<span class="string">&quot;8&quot;</span></span><br><span class="line">PLATFORM_ID=<span class="string">&quot;platform:el8&quot;</span></span><br><span class="line">PRETTY_NAME=<span class="string">&quot;CentOS Linux 8&quot;</span></span><br><span class="line">ANSI_COLOR=<span class="string">&quot;0;31&quot;</span></span><br><span class="line">CPE_NAME=<span class="string">&quot;cpe:/o:centos:centos:8&quot;</span></span><br><span class="line">HOME_URL=<span class="string">&quot;https://centos.org/&quot;</span></span><br><span class="line">BUG_REPORT_URL=<span class="string">&quot;https://bugs.centos.org/&quot;</span></span><br><span class="line">CENTOS_MANTISBT_PROJECT=<span class="string">&quot;CentOS-8&quot;</span></span><br><span class="line">CENTOS_MANTISBT_PROJECT_VERSION=<span class="string">&quot;8&quot;</span></span><br><span class="line">CentOS Linux release 8.4.2105</span><br><span class="line">CentOS Linux release 8.4.2105</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="安装编译工具"><a href="#安装编译工具" class="headerlink" title="安装编译工具"></a>安装编译工具</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc</span><br><span class="line">yum -y install gcc-c++</span><br><span class="line">yum -y install make</span><br><span class="line">yum install -y autoconf automake libtool</span><br><span class="line">yum install -y wget</span><br></pre></td></tr></table></figure><p><strong>提示</strong>：<br>安装过程中出现以下错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># yum -y install gcc</span></span><br><span class="line">Last metadata expiration check: 0:15:41 ago on Wed 23 Nov 2022 03:56:44 PM CST.</span><br><span class="line">Error: </span><br><span class="line"> Problem: package gcc-8.5.0-4.el8_5.x86_64 requires glibc-devel &gt;= 2.2.90-12, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libpthread.so.0, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libdl.so.2, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libm.so.6, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libresolv.so.2, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires librt.so.1, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libutil.so.1, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libBrokenLocale.so.1, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libanl.so.1, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.i686 requires libthread_db.so.1, but none of the providers can be installed</span><br><span class="line">  - package glibc-devel-2.28-164.el8.x86_64 requires glibc = 2.28-164.el8, but none of the providers can be installed</span><br><span class="line">  - glibc-2.28-164.el8.i686 has inferior architecture</span><br><span class="line">  - cannot install both glibc-2.28-164.el8.x86_64 and glibc-2.28-203.el8.x86_64</span><br><span class="line">  - package glibc-gconv-extra-2.28-203.el8.x86_64 requires glibc(x86-64) = 2.28-203.el8, but none of the providers can be installed</span><br><span class="line">  - cannot install the best candidate <span class="keyword">for</span> the job</span><br><span class="line">  - problem with installed package glibc-gconv-extra-2.28-203.el8.x86_64</span><br><span class="line">(try to add <span class="string">&#x27;--allowerasing&#x27;</span> to <span class="built_in">command</span> line to replace conflicting packages or <span class="string">&#x27;--skip-broken&#x27;</span> to skip uninstallable packages or <span class="string">&#x27;--nobest&#x27;</span> to use not only best candidate packages)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>则执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc --allowerasing</span><br></pre></td></tr></table></figure><p>可执行文件对应的安装包查找：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum whatprovides autoreconf</span><br></pre></td></tr></table></figure><p><img src="c5dd6168b78ccf54aa38d65134cb70a21c2adb250934fcf9c448d9d29d12851c.png" alt="图 26"><br>则安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y autoconf</span><br></pre></td></tr></table></figure><h2 id="安装libunwind"><a href="#安装libunwind" class="headerlink" title="安装libunwind"></a>安装libunwind</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/libunwind/libunwind/archive/v0.99.tar.gz</span><br><span class="line">tar -xvf v0.99.tar.gz</span><br><span class="line"><span class="built_in">cd</span> libunwind-0.99</span><br><span class="line">autoreconf --force -v --install</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h2 id="安装perftools"><a href="#安装perftools" class="headerlink" title="安装perftools"></a>安装perftools</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/gperftools/gperftools/releases/download/gperftools-2.6.1/gperftools-2.6.1.tar.gz</span><br><span class="line">tar -xvf gperftools-2.6.1.tar.gz </span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h2 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h2><p><img src="e25c28feccf7bac3e0f524dec94e4a1f7f2d5db678b0fd3366351056d111b03a.png" alt="图 27">  </p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;这是谷歌的一个linux下性能测试的小工具。可以简单快速的发现程序的性能瓶颈。&lt;/p&gt;</summary>
    
    
    
    <category term="LINUX" scheme="https://rma-shuyu.github.io/categories/LINUX/"/>
    
    
    <category term="linux" scheme="https://rma-shuyu.github.io/tags/linux/"/>
    
    <category term="pprof" scheme="https://rma-shuyu.github.io/tags/pprof/"/>
    
  </entry>
  
  <entry>
    <title>base64编解码</title>
    <link href="https://rma-shuyu.github.io/2022/11/16/base64%E7%BC%96%E8%A7%A3%E7%A0%81/"/>
    <id>https://rma-shuyu.github.io/2022/11/16/base64%E7%BC%96%E8%A7%A3%E7%A0%81/</id>
    <published>2022-11-16T12:16:29.000Z</published>
    <updated>2023-01-27T12:06:26.868Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，是一种基于<strong>64个可打印字符</strong>来表示二进制数据的方法</p><span id="more"></span><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ol><li>Base64一般用于在 HTTP协议下传输二进制数据，由于 HTTP协议是文本协议，所以在HTTP协议下传输二进制数据需要将二进制数据转换为字符数据。然而直接转换是不行的。因为网络传输只能传输可打印字符，需要用Base64将不可显字符转换为可显字符</li><li>可用于将明文通过AES加密后，通过Base64将不可显的加密字符转换为可显字符</li></ol><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>base64编码表<br><img src="c617678b70d6a249a3556d4a16a4d49fbd9dc22f4be59bda0d0e52450c20be76.png" alt="图 2"> </p><p>由于base64编码是将编码前的3*8位数据，分解成4个6位的数据，所以经过base64编码后的字符串长度是4的倍数。<br>但往往我们进行编码的数据长度并不是3的倍数，这就造成了“编码”后的位数不为4的倍数，</p><p>比如Brisk共5×8=40位，以6位为一组可以分为7组，这样“编码”后就有7个字符，<br>但base64编码后的字符长度应该是4的倍数，显然这里就出问题了，那么怎么办呢？<br>前面的不可以抛弃掉，所以就只有“追加”了，所以Brisk经过base64编码后的长度应该是8个字符，而第8个编码后的字符是’=’，</p><p>再比如对单个字符a进行base64编码，由于它的长度不是3的倍数，以3个字节为一组它只能分一组，再以6位为一位它只能分两组，所以经过“编码”后它的长度是2，但base64编码后的个数应该是4的倍数，所以它的长度应该是4，所以在后面补上两个‘=’,</p><p>由于一个数求余3后有三个不同的结果，0、1、2，所以在对一个数据进行base64进行编码后它的长度为： </p><ol><li><p>当进行编码的数据长度是3的倍数时，len=strlen(str_in)/3*4;</p></li><li><p>当进行编码的数据长度不是3的倍数时，len=(strlen(str_in)/3+1)*4;</p></li></ol><p>我们以Brisk这个例子来说明一下base64编码的过程。首先我们以3个字符为一组将Brisk进行分组，Brisk被氛围两组：Bri 和 sk；然后我们取出这两个分组中每个字节的ASCII码，B:66 r:114 i:105 s:115 k:107。它们对应的二进制数为  B:01000010 r:01110010 i:01101001 s:01110011 k:01101011；</p><p>第一组，我们以6位为一组对每一个3字节分组进行再分组就变成了010000 100111 001001 101001。所对应的十进制数是16 39 9 41，对应base64表中的结果是 Q n J p；</p><p>第二组，011100 110110 101100(不够补0)，所以对应的十进制数是 28 54 44，对应base64表中的结果是 c 2 s，最终结果为QnJpc2s=（因为第二组“编码”后只有三个字节）。</p><p>解码的过程是一个逆过程，我们将经过编码后的字符按4个字符为一组，然后对照base64表得到相应的十进制数，再将其通过拆分和组合，组成3个8位数据，这个数据就是解码后的数据，下面给一个c语言实现编码和解码的代码。</p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">encode_string</span><span class="params">(</span></span><br><span class="line"><span class="params"><span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> * src, <span class="type">int</span> len,</span></span><br><span class="line"><span class="params"><span class="type">unsigned</span> <span class="type">char</span> * dest, <span class="type">unsigned</span> <span class="type">char</span> * base64, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> one;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> two;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> thr;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> fou;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ( len &gt;= <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        one = src[<span class="number">0</span>] &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        two = ( ( src[<span class="number">0</span>] &amp; <span class="number">0x03</span> ) &lt;&lt; <span class="number">4</span> ) | ( src[<span class="number">1</span>] &gt;&gt; <span class="number">4</span> );</span><br><span class="line">        thr = ( ( src[<span class="number">1</span>] &amp; <span class="number">0x0F</span> ) &lt;&lt; <span class="number">2</span> ) | ( src[<span class="number">2</span>] &gt;&gt; <span class="number">6</span> );</span><br><span class="line">        fou = src[<span class="number">2</span>] &amp; <span class="number">0x3F</span>;</span><br><span class="line"> </span><br><span class="line">        *( dest + index++ ) = base64[one];</span><br><span class="line">        *( dest + index++ ) = base64[two];</span><br><span class="line">        *( dest + index++ ) = base64[thr];</span><br><span class="line">        *( dest + index   ) = base64[fou];</span><br><span class="line"><span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( len == <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        one = src[<span class="number">0</span>] &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        two = ( ( src[<span class="number">0</span>] &amp; <span class="number">0x03</span>) &lt;&lt; <span class="number">4</span> ) | ( src[<span class="number">1</span>] &gt;&gt; <span class="number">4</span> );</span><br><span class="line">        thr = ( src[<span class="number">1</span>] &amp; <span class="number">0x0F</span> ) &lt;&lt; <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line">        *( dest + index++ ) = base64[one];</span><br><span class="line">        *( dest + index++ ) = base64[two];</span><br><span class="line">        *( dest + index++ ) = base64[thr];</span><br><span class="line">        *( dest + index   ) = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( len == <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        one = src[<span class="number">0</span>] &gt;&gt; <span class="number">2</span>;</span><br><span class="line">        two = ( src[<span class="number">0</span>] &amp; <span class="number">0x03</span> ) &lt;&lt; <span class="number">4</span>;</span><br><span class="line"> </span><br><span class="line">        *( dest + index++ ) = base64[one];</span><br><span class="line">        *( dest + index++ ) = base64[two];</span><br><span class="line">        *( dest + index++ ) = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">        *( dest + index   ) = <span class="string">&#x27;=&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;Unknow length\n&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">base64_encode</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> * src, <span class="type">int</span> src_len, <span class="type">char</span> * dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> base64[] = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&quot;</span>;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( src_len &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> step = encode_string( src, src_len, (<span class="type">unsigned</span> <span class="type">char</span> *)dest, base64, index );</span><br><span class="line"> </span><br><span class="line">        index += <span class="number">4</span>;</span><br><span class="line">        src += step;</span><br><span class="line">src_len -= step;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    *( dest + index ) = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="解码"><a href="#解码" class="headerlink" title="解码"></a>解码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">create_array</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> * <span class="built_in">array</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> index  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( index  = <span class="number">0</span>; index &lt; <span class="number">123</span>; index += <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( index == <span class="number">0x2B</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            *( <span class="built_in">array</span> + index ) = <span class="number">0x3E</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( index == <span class="number">0x2F</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            *( <span class="built_in">array</span> + index ) = <span class="number">0x3F</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( index &gt;= <span class="number">0x30</span> &amp;&amp; index &lt;= <span class="number">0x39</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            *( <span class="built_in">array</span> + index ) = <span class="number">0x34</span> + index - <span class="number">0x30</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( index == <span class="number">0x3D</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            *( <span class="built_in">array</span> + index ) = <span class="number">0x00</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( index &gt;= <span class="number">0x41</span> &amp;&amp; index &lt;= <span class="number">0x5A</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            *( <span class="built_in">array</span> + index ) = index - <span class="number">0x41</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( index &gt;= <span class="number">0x61</span> &amp;&amp; index &lt;= <span class="number">0x7A</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            *( <span class="built_in">array</span> + index ) = <span class="number">0x1A</span> + index - <span class="number">0x61</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            *( <span class="built_in">array</span> + index ) = <span class="number">0x00</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    *( <span class="built_in">array</span> + <span class="number">123</span> ) = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">decode_string</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * src, <span class="type">unsigned</span> <span class="type">char</span> * dest, <span class="type">unsigned</span> <span class="type">char</span> * <span class="built_in">array</span>, <span class="type">int</span> index)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> step;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> one;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> two;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> thr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( src[<span class="number">3</span>] == <span class="string">&#x27;=&#x27;</span> &amp;&amp; src[<span class="number">2</span>] == <span class="string">&#x27;=&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        one = ( <span class="built_in">array</span>[src[<span class="number">0</span>]] &lt;&lt; <span class="number">2</span> ) | ( <span class="built_in">array</span>[src[<span class="number">1</span>]] &gt;&gt; <span class="number">4</span> );</span><br><span class="line">        *( dest + index ) = one;</span><br><span class="line"> </span><br><span class="line">        step = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( src[<span class="number">3</span>] == <span class="string">&#x27;=&#x27;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        one = ( <span class="built_in">array</span>[src[<span class="number">0</span>]] &lt;&lt; <span class="number">2</span> ) | ( <span class="built_in">array</span>[src[<span class="number">1</span>]] &gt;&gt; <span class="number">4</span> );</span><br><span class="line">        two = ( ( <span class="built_in">array</span>[src[<span class="number">1</span>]] &amp; <span class="number">0x0F</span> ) &lt;&lt; <span class="number">4</span> ) | ( <span class="built_in">array</span>[src[<span class="number">2</span>]] &gt;&gt; <span class="number">2</span> );</span><br><span class="line"> </span><br><span class="line">        *( dest + index++ ) = one;</span><br><span class="line">        *( dest + index   ) = two;</span><br><span class="line"> </span><br><span class="line">        step = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        one = ( <span class="built_in">array</span>[src[<span class="number">0</span>]] &lt;&lt; <span class="number">2</span> ) | ( <span class="built_in">array</span>[src[<span class="number">1</span>]] &gt;&gt; <span class="number">4</span> );</span><br><span class="line">        two = ( ( <span class="built_in">array</span>[src[<span class="number">1</span>]] &amp; <span class="number">0x0F</span> ) &lt;&lt; <span class="number">4</span> ) | ( <span class="built_in">array</span>[src[<span class="number">2</span>]] &gt;&gt; <span class="number">2</span> );</span><br><span class="line">        thr = ( <span class="built_in">array</span>[src[<span class="number">2</span>]] &lt;&lt; <span class="number">6</span> ) | <span class="built_in">array</span>[src[<span class="number">3</span>]];</span><br><span class="line"> </span><br><span class="line">        *( dest + index++ ) = one;</span><br><span class="line">        *( dest + index++ ) = two;</span><br><span class="line">        *( dest + index   ) = thr;</span><br><span class="line"> </span><br><span class="line">        step = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">base64_decode</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * src, <span class="type">unsigned</span> <span class="type">char</span> * dest)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> <span class="built_in">array</span>[<span class="number">124</span>];</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>( <span class="built_in">array</span>, <span class="number">0x00</span>, <span class="number">124</span> );</span><br><span class="line">    create_array( <span class="built_in">array</span> );</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> ( *src )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> step = decode_string( src, dest, <span class="built_in">array</span>, index );</span><br><span class="line"> </span><br><span class="line">        index += step;</span><br><span class="line">        src   += <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    *( dest + index ) = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>测试代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> *src_str = <span class="string">&quot;abcsjdhs123134&quot;</span>;</span><br><span class="line"><span class="type">int</span> src_str_len = <span class="built_in">strlen</span>(src_str);</span><br><span class="line"><span class="type">char</span> *out_buf = (<span class="type">char</span> *)<span class="built_in">malloc</span>(src_str_len * <span class="number">2</span>);</span><br><span class="line"><span class="type">char</span> *out_decode_buf = (<span class="type">char</span> *)<span class="built_in">malloc</span>(src_str_len * <span class="number">2</span>);</span><br><span class="line">base64_encode(src_str, src_str_len, out_buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;src_str:       %s\n&quot;</span>, src_str);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;base64_encode: %s\n&quot;</span>, out_buf);</span><br><span class="line"></span><br><span class="line">base64_decode(out_buf, out_decode_buf);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;base64_decode: %s\n&quot;</span>, out_decode_buf);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果展示<br><img src="8106a76ff5b18e8cda5e478736125efeec53fcaf86e1744cf4fe4accaaf6a38b.png" alt="图 3">  </p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，是一种基于&lt;strong&gt;64个可打印字符&lt;/strong&gt;来表示二进制数据的方法&lt;/p&gt;</summary>
    
    
    
    <category term="BASE64" scheme="https://rma-shuyu.github.io/categories/BASE64/"/>
    
    
    <category term="BASE64" scheme="https://rma-shuyu.github.io/tags/BASE64/"/>
    
  </entry>
  
  <entry>
    <title>OpenSSL之AES用法</title>
    <link href="https://rma-shuyu.github.io/2022/11/16/OpenSSL%E4%B9%8BAES%E7%94%A8%E6%B3%95/"/>
    <id>https://rma-shuyu.github.io/2022/11/16/OpenSSL%E4%B9%8BAES%E7%94%A8%E6%B3%95/</id>
    <published>2022-11-16T11:20:44.000Z</published>
    <updated>2023-01-27T12:06:26.847Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>AES是<strong>对称</strong>加密的算法，使用128、192 和 256 位密钥，将被加密数据划分为128位（16字节）一块，然后使用某种加密模式进行加密</p><p>关键词：<br><strong>块大小</strong>：16字节<br><strong>密钥长度</strong>：AES算法下，key的长度有三种：128、192和256 bits。</p><span id="more"></span><p><strong>加密模式</strong>：AES属于块加密（Block Cipher），块加密中有CBC、ECB、CTR、OFB、CFB等几种工作模式。<br><strong>填充模式</strong>：</p><ul><li>NoPadding，数据长度不对齐时使用”\0”填充，否则不填充</li><li>PKCS7Padding，假设数据长度需要填充n(n&gt;0)个字节才对齐，那么填充n个字节，每个字节都是n;如果数据本身就已经对齐了，则填充一块长度为块大小的数据，每个字节都是块大小</li><li>PKCS5Padding，PKCS7Padding的子集，块大小固定为8字节。</li></ul><p>AES加密，如果输入是16<em>n字节，NoPadding填充的情况下，输出和输入相同；有填充的情况下，输出是16</em>（n+1）。<br>如果输入不是16字节整数倍，而是大于16<em>n小于16</em>（n+1），NoPadding填充情况下（只能是CFB和OFB模式），输出和输入长度相同；其他情况下，输出长度是16*（n+1）</p><h2 id="设置加解密接口"><a href="#设置加解密接口" class="headerlink" title="设置加解密接口"></a>设置加解密接口</h2><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><ul><li><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">AES_set_encrypt_key</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *userKey, <span class="type">const</span> <span class="type">int</span> bits,</span></span><br><span class="line"><span class="params">                        AES_KEY *key)</span>;</span><br></pre></td></tr></table></figure></li><li><p>函数作用<br>设定加密用的Key</p></li><li><p>参数说明<br><code>userKey</code>： 密钥数值；<br><code>bits</code>：密钥长度，以bit为单位，如果密钥数字是16个字节，则此参数值应为128；<br><code>key</code>： AES_KEY对象指针；<br><code>返回值</code>：<br>0: 成功<br>1: userkey，key为空<br>2: 密钥长度不是128，192，256</p></li></ul><h3 id="解密"><a href="#解密" class="headerlink" title="解密"></a>解密</h3><ul><li><p>函数原型</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">AES_set_decrypt_key</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *userKey, <span class="type">const</span> <span class="type">int</span> bits,</span></span><br><span class="line"><span class="params">                        AES_KEY *key)</span>;</span><br></pre></td></tr></table></figure></li><li><p>函数作用<br>设定解密用的Key</p></li><li><p>参数说明<br><code>userKey</code>： 密钥数值；<br><code>bits</code>：密钥长度，以bit为单位，如果密钥数字是16个字节，则此参数值应为128；<br><code>key</code>： AES_KEY对象指针；<br><code>返回值</code>：<br>0: 成功<br>1: userkey，key为空<br>2: 密钥长度不是128，192，256</p></li></ul><h2 id="常用加密模式"><a href="#常用加密模式" class="headerlink" title="常用加密模式"></a>常用加密模式</h2><h3 id="CBC"><a href="#CBC" class="headerlink" title="CBC"></a>CBC</h3><ul><li><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AES_cbc_encrypt</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *in, <span class="type">unsigned</span> <span class="type">char</span> *out,</span></span><br><span class="line"><span class="params">                     <span class="type">size_t</span> length, <span class="type">const</span> AES_KEY *key,</span></span><br><span class="line"><span class="params">                     <span class="type">unsigned</span> <span class="type">char</span> *ivec, <span class="type">const</span> <span class="type">int</span> enc)</span>;</span><br></pre></td></tr></table></figure></li><li><p>函数作用：<br>AES加密/解密单个数据块（16个字节），CBC模式</p></li><li><p>参数说明：<br><code>in</code>： 需要加密/解密的数据；<br><code>out</code>： 计算后输出的数据；<br><code>length</code>： 数据长度（这里不包含初始向量数据长度）<br><code>key</code>：密钥<br><code>ivec</code>： 初始向量（一般为16字节全0）<br><code>enc</code>：<br>AES_ENCRYPT：代表加密<br>AES_DECRYPT：代表解密</p></li></ul><h3 id="ECB"><a href="#ECB" class="headerlink" title="ECB"></a>ECB</h3><ul><li><p>函数原型：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AES_ecb_encrypt</span><span class="params">(<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *in, <span class="type">unsigned</span> <span class="type">char</span> *out,</span></span><br><span class="line"><span class="params">                     <span class="type">const</span> AES_KEY *key, <span class="type">const</span> <span class="type">int</span> enc)</span>;</span><br></pre></td></tr></table></figure></li><li><p>函数作用：<br>AES加密/解密单个数据块（16个字节），ECB模式</p></li><li><p>参数说明：<br><code>in</code>: 需要加密/解密的数据；<br><code>out</code>: 计算后输出的数据；<br><code>key</code>: 密钥<br><code>enc</code>:<br>AES_ENCRYPT：代表加密<br>AES_DECRYPT：代表解密</p></li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>测试代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TEST_ORG_DATA <span class="string">&quot;this is test aes data!&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">remove_padding</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buff, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">ch = buff[size - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; ch; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (buff[size - i] != buff[size - (i + <span class="number">1</span>)])</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">buff[size - i] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> *<span class="title function_">str2hex</span><span class="params">(<span class="type">char</span> *str)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *ret = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> str_len = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> sret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">ret = (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="built_in">malloc</span>(str_len / <span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; str_len; i += <span class="number">2</span>)</span><br><span class="line">sret = <span class="built_in">sscanf</span>(str + i, <span class="string">&quot;%2hhX&quot;</span>, &amp;ret[i/<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">if</span> (sret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">free</span>(ret);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">decode_aes128_ecb</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *encrypt_buff, <span class="type">int</span> buf_len, <span class="type">unsigned</span> <span class="type">char</span> **out)</span></span><br><span class="line">&#123;</span><br><span class="line">AES_KEY aes;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *decrypt_buff = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *key = str2hex(<span class="string">&quot;B1CFC3D787DC4511&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;aes, <span class="number">0</span>, <span class="keyword">sizeof</span>(aes));</span><br><span class="line">decrypt_buff = (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="built_in">malloc</span>((<span class="type">size_t</span>)buf_len);</span><br><span class="line"></span><br><span class="line">AES_set_decrypt_key(key, <span class="number">128</span>, &amp;aes);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; buf_len; i += AES_BLOCK_SIZE) &#123;</span><br><span class="line">AES_ecb_encrypt</span><br><span class="line">(encrypt_buff + i, decrypt_buff + i, &amp;aes, AES_DECRYPT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">remove_padding(decrypt_buff, buf_len);</span><br><span class="line"></span><br><span class="line">*out = decrypt_buff;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">encode_aes128_ecb</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> **out, <span class="type">int</span> *out_len)</span></span><br><span class="line">&#123;</span><br><span class="line">AES_KEY aes;</span><br><span class="line"><span class="type">int</span> data_len = <span class="built_in">strlen</span>(TEST_ORG_DATA);</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="type">json_error_t</span> error;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *encrypt_buff = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *decrypt_buff = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *key = str2hex(<span class="string">&quot;B1CFC3D787DC4511&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> pad_len = AES_BLOCK_SIZE - (data_len % AES_BLOCK_SIZE);</span><br><span class="line">encrypt_buff = (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="built_in">malloc</span>(data_len + pad_len);</span><br><span class="line">decrypt_buff = (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="built_in">malloc</span>(data_len + pad_len);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memcpy</span>(decrypt_buff, TEST_ORG_DATA, data_len);</span><br><span class="line"><span class="built_in">memset</span>(decrypt_buff+data_len, pad_len, pad_len);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;aes, <span class="number">0</span>, <span class="keyword">sizeof</span>(aes));</span><br><span class="line">AES_set_encrypt_key(key, <span class="number">128</span>, &amp;aes);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; data_len+pad_len; i += AES_BLOCK_SIZE) &#123;</span><br><span class="line">AES_ecb_encrypt</span><br><span class="line">(decrypt_buff + i, encrypt_buff + i, &amp;aes, AES_ENCRYPT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">*out = encrypt_buff;</span><br><span class="line">*out_len = data_len+pad_len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;data before aes :\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, TEST_ORG_DATA);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *en_code = <span class="literal">NULL</span>;</span><br><span class="line"><span class="type">int</span> en_code_len;</span><br><span class="line">encode_aes128_ecb(&amp;en_code, &amp;en_code_len);</span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *de_code = <span class="literal">NULL</span>;</span><br><span class="line">decode_aes128_ecb(en_code, en_code_len, &amp;de_code);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;data after aes encode and decode :\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, de_code);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试结果：<br><img src="4f8473f4df84e1e65d147bd49af24b1cf87b702462969287d002e093c7cfd2e1.png" alt="图 2">  </p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;AES是&lt;strong&gt;对称&lt;/strong&gt;加密的算法，使用128、192 和 256 位密钥，将被加密数据划分为128位（16字节）一块，然后使用某种加密模式进行加密&lt;/p&gt;
&lt;p&gt;关键词：&lt;br&gt;&lt;strong&gt;块大小&lt;/strong&gt;：16字节&lt;br&gt;&lt;strong&gt;密钥长度&lt;/strong&gt;：AES算法下，key的长度有三种：128、192和256 bits。&lt;/p&gt;</summary>
    
    
    
    <category term="OPENSSL" scheme="https://rma-shuyu.github.io/categories/OPENSSL/"/>
    
    
    <category term="AES" scheme="https://rma-shuyu.github.io/tags/AES/"/>
    
    <category term="OPENSSL" scheme="https://rma-shuyu.github.io/tags/OPENSSL/"/>
    
  </entry>
  
  <entry>
    <title>docker私有仓库</title>
    <link href="https://rma-shuyu.github.io/2022/06/28/docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/"/>
    <id>https://rma-shuyu.github.io/2022/06/28/docker%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93/</id>
    <published>2022-06-28T12:25:15.000Z</published>
    <updated>2023-09-09T10:33:02.408Z</updated>
    
    <content type="html"><![CDATA[<hr><h2 id="一、关于Registry"><a href="#一、关于Registry" class="headerlink" title="一、关于Registry"></a>一、关于Registry</h2><p>官方的Docker hub是一个用于管理公共镜像的好地方，我们可以在上面找到我们想要的镜像，也可以把我们自己的镜像推送上去。</p><span id="more"></span><p>但是有时候我们的使用场景需要我们拥有一个私有的镜像仓库用于管理我们自己的镜像。这个可以通过开源软件Registry来达成目的。</p><p> Registry在github上有两份代码：老代码库和新代码库。老代码是采用python编写的，存在pull和push的性能问题，出到0.9.1版本之后就标志为deprecated，不再继续开发。</p><p> 从2.0版本开始就到在新代码库进行开发，新代码库是采用go语言编写，修改了镜像id的生成算法、registry上镜像的保存结构，大大优化了pull和push镜像的效率。</p><p> 官方在Docker hub上提供了registry的镜像，我们可以直接使用该registry镜像来构建一个容器，搭建我们自己的私有仓库服务。</p><hr><h2 id="二、搭建Registry"><a href="#二、搭建Registry" class="headerlink" title="二、搭建Registry"></a>二、搭建Registry</h2><h4 id="首先搜索并拉取镜像"><a href="#首先搜索并拉取镜像" class="headerlink" title="首先搜索并拉取镜像"></a>首先搜索并拉取镜像</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker search registry　　　　# 建议先搜索一下，可以看一下相关的镜像，说不定哪天就有更好的镜像了</span><br><span class="line">docker pull registry　　　　# 标签可以不加，因为当前最新就是v2</span><br></pre></td></tr></table></figure><h4 id="运行一个registry容器"><a href="#运行一个registry容器" class="headerlink" title="运行一个registry容器"></a>运行一个registry容器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \\            # 后台运行</span><br><span class="line">--name registry-srv \\    # 指定容器名</span><br><span class="line">--restart=always \\        # 设置自动启动</span><br><span class="line">-p 5000:5000 \\            # 端口映射宿主机，通过宿主机地址访问</span><br><span class="line">-v /opt/zwx-registry:/var/lib/registry \\     # 把镜像存储目录挂载到本地，方便管理和持久化</span><br><span class="line">-v /opt/zwx-registry/srv-config.yml:/etc/docker/registry/config.yml \\    # 把配置文件挂载到本地，方便修改和保存</span><br><span class="line">registry</span><br></pre></td></tr></table></figure><h4 id="srv-config-yml内容如下"><a href="#srv-config-yml内容如下" class="headerlink" title="srv-config.yml内容如下"></a>srv-config.yml内容如下</h4><p>　　标红delete参数设置为true，是为了让仓库支持删除功能。默认没有这个参数，也就是不能删除仓库镜像。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">version: 0.1</span><br><span class="line">log:</span><br><span class="line">  fields:</span><br><span class="line">    service: registry</span><br><span class="line">storage:</span><br><span class="line">  **delete:</span><br><span class="line">    enabled:** **true**</span><br><span class="line">  cache:</span><br><span class="line">    blobdescriptor: inmemory</span><br><span class="line">  filesystem:</span><br><span class="line">    rootdirectory: /var/lib/registry</span><br><span class="line">http:</span><br><span class="line">  addr: :5000</span><br><span class="line">  headers:</span><br><span class="line">    X-Content-Type-Options: [nosniff]</span><br><span class="line">health:</span><br><span class="line">  storagedriver:</span><br><span class="line">    enabled: true</span><br><span class="line">    interval: 10s</span><br><span class="line">    threshold: 3</span><br></pre></td></tr></table></figure><h4 id="注册https协议（否则push安全认证过不去）"><a href="#注册https协议（否则push安全认证过不去）" class="headerlink" title="注册https协议（否则push安全认证过不去）"></a>注册https协议（否则push安全认证过不去）</h4><p>　　需要通过本地仓库下载镜像，均需要配置　　</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/docker/daemon.json　　　　　　　　# 默认无此文件，需自行添加，有则追加以下内容。</span><br><span class="line">&#123; &quot;insecure-registries&quot;:[&quot;xx.xx.xx.xx:5000&quot;] &#125;　　# 指定IP地址或域名</span><br><span class="line">systemctl daemon-reload    # 守护进程重启</span><br><span class="line">systemctl restart docker    # 重启docker服务</span><br></pre></td></tr></table></figure><h4 id="镜像上传与下载"><a href="#镜像上传与下载" class="headerlink" title="镜像上传与下载"></a>镜像上传与下载</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker push xx.xx.xx.xx:5000/nginx            # 一定要注明仓库地址，否则会报错</span><br><span class="line">docker pull xx.xx.xx.xx:5000/nginx</span><br></pre></td></tr></table></figure><h4 id="查看仓库镜像信息"><a href="#查看仓库镜像信息" class="headerlink" title="查看仓库镜像信息"></a>查看仓库镜像信息</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查看仓库镜像列表（也可以通过windows浏览器打开查看）</span><br><span class="line">curl -XGET http://xx.xx.xx.xx:5000/v2/_catalog</span><br><span class="line"></span><br><span class="line"># 查看指定应用镜像tag</span><br><span class="line">curl -XGET http://xx.xx.xx.xx:5000/v2/image_name/tags/list</span><br></pre></td></tr></table></figure><hr><h2 id="三、搭建Registry-web"><a href="#三、搭建Registry-web" class="headerlink" title="三、搭建Registry web"></a>三、搭建Registry web</h2><h4 id="首先搜索并拉取镜像-1"><a href="#首先搜索并拉取镜像-1" class="headerlink" title="首先搜索并拉取镜像"></a>首先搜索并拉取镜像</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker search docker-registry-web</span><br><span class="line">docker pull hyper/docker-registry-web　　　　# 这个镜像用的人较多</span><br></pre></td></tr></table></figure><h4 id="运行一个registry-web容器"><a href="#运行一个registry-web容器" class="headerlink" title="运行一个registry web容器"></a>运行一个registry web容器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d \\            # 后台运行</span><br><span class="line">--name registry-web \\    # 指定容器名</span><br><span class="line">--restart=always \\        # 设置自动启动</span><br><span class="line">-p 8000:8080 \\            # 端口映射宿主机，通过宿主机地址访问</span><br><span class="line">-v /opt/zwx-registry/web-config.yml:/conf/config.yml \\    # 把配置文件挂载到本地，方便修改和保存</span><br><span class="line">hyper/docker-registry-web</span><br></pre></td></tr></table></figure><h4 id="web-config-yml文件内容如下"><a href="#web-config-yml文件内容如下" class="headerlink" title="web-config.yml文件内容如下"></a>web-config.yml文件内容如下</h4><p>标红readonly参数设置为false，是为了web页面可以显示删除按钮。默认是true，只读状态，没有删除按钮，只能查看。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">registry:</span><br><span class="line">  # Docker registry url</span><br><span class="line">  url: http://10.88.77.32:5000/v2</span><br><span class="line">  # Docker registry fqdn</span><br><span class="line">  name: localhost:5000</span><br><span class="line">  # To allow image delete, should be false</span><br><span class="line">  readonly: false</span><br><span class="line">  auth:</span><br><span class="line">    # Disable authentication</span><br><span class="line">    enabled: false</span><br></pre></td></tr></table></figure><h4 id="部署完成后，浏览器打开仓库UI地址即可查看到所有应用镜像"><a href="#部署完成后，浏览器打开仓库UI地址即可查看到所有应用镜像" class="headerlink" title="部署完成后，浏览器打开仓库UI地址即可查看到所有应用镜像"></a>部署完成后，浏览器打开仓库UI地址即可查看到所有应用镜像</h4><p><img src="bfcef290e0529142f4fa675f5cb3cc0d2564e07512912b699ffa9a00bf6c8a6a.png" alt="picture 0">  </p><p>选择任意应用镜像库，即可查看到该镜像的所有tag信息，每个tag后面都有个删除按钮（默认没有，配置参考config.yml）</p><p><img src="634baf7e844835348b1d5708228a67a8bdda0d92583551bb1dd6dc1d825ff527.png" alt="picture 1">  </p><hr><h2 id="四、快捷部署"><a href="#四、快捷部署" class="headerlink" title="四、快捷部署"></a>四、快捷部署</h2><p>　　集群模式可以通过docker stack快速部署registry和registry web。</p><p>　　新建配置文件srv-config.yml、web-config.yml放到指定路径，再新建docker-compose.yml文件，执行命令即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack deploy -c docker-compose.yml RGT</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;3.7&#x27;　　　　　　\# docker stack 需要是3.0以上版本</span><br><span class="line">services:</span><br><span class="line">  registry-srv:　　　　　　\# 服务名</span><br><span class="line">    image: registry</span><br><span class="line">    </span><br><span class="line">    ports:　　　　　　　　　\# 映射端口</span><br><span class="line">      - 5000:5000</span><br><span class="line">      </span><br><span class="line">    volumes:　　　　　　　　\# 挂载镜像路径和配置文件，注意修改路径与实际一致</span><br><span class="line">      - /opt/zwx-registry:/var/lib/registry</span><br><span class="line">      - /opt/zwx-registry/srv-config.yml:/etc/docker/registry/config.yml</span><br><span class="line">      </span><br><span class="line">    deploy:　　　　　　　　\# 设置单任务，并约束主节点运行</span><br><span class="line">      mode: replicated</span><br><span class="line">      replicas: 1</span><br><span class="line">      placement:</span><br><span class="line">        constraints:</span><br><span class="line">          - node.role == manager</span><br><span class="line">      </span><br><span class="line">  registry-web:　　　　　　\# 服务名　　</span><br><span class="line">    image: hyper/docker-registry-web</span><br><span class="line">    </span><br><span class="line">    ports:　　　　　　　　\# 映射端口</span><br><span class="line">      - 8000:8080</span><br><span class="line">    </span><br><span class="line">    volumes:　　　　　　\# 挂载配置文件，注意修改路径与实际一致</span><br><span class="line">      - /opt/zwx-registry/web-config.yml:/conf/config.yml</span><br><span class="line">      </span><br><span class="line">    environment:</span><br><span class="line">      - REGISTRY_URL=http://registry-srv:5000/v2</span><br><span class="line">      - REGISTRY_NAME=localhost:5000</span><br><span class="line">    </span><br><span class="line">    deploy:　　　　　　　　\# 设置单任务，并约束主节点运行</span><br><span class="line">      mode: replicated</span><br><span class="line">      replicas: 1</span><br><span class="line">      placement:</span><br><span class="line">        constraints:</span><br><span class="line">          - node.role == manager  </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h2 id=&quot;一、关于Registry&quot;&gt;&lt;a href=&quot;#一、关于Registry&quot; class=&quot;headerlink&quot; title=&quot;一、关于Registry&quot;&gt;&lt;/a&gt;一、关于Registry&lt;/h2&gt;&lt;p&gt;官方的Docker hub是一个用于管理公共镜像的好地方，我们可以在上面找到我们想要的镜像，也可以把我们自己的镜像推送上去。&lt;/p&gt;</summary>
    
    
    
    <category term="DOCKER" scheme="https://rma-shuyu.github.io/categories/DOCKER/"/>
    
    
    <category term="docker" scheme="https://rma-shuyu.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker ipc设置</title>
    <link href="https://rma-shuyu.github.io/2022/06/27/docker-ipc%E8%AE%BE%E7%BD%AE/"/>
    <id>https://rma-shuyu.github.io/2022/06/27/docker-ipc%E8%AE%BE%E7%BD%AE/</id>
    <published>2022-06-27T12:25:15.000Z</published>
    <updated>2023-09-09T10:33:02.407Z</updated>
    
    <content type="html"><![CDATA[<p>官方配置文档：<a href="https://docs.docker.com/engine/reference/run/#ipc-settings---ipc">Docker run reference</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--ipc=&quot;MODE&quot;  : 设置容器的 IPC 模式</span><br></pre></td></tr></table></figure><span id="more"></span><p>可接受的值包括：</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>“”</td><td>使用Docker Daemon的默认值</td></tr><tr><td>none</td><td>拥有私有的IPC命名空间，不挂载 /dev/shm</td></tr><tr><td>private</td><td>拥有私有的IPC命名空间</td></tr><tr><td>shareable</td><td>拥有私有的IPC命名空间, 且可以共享给其他容器</td></tr><tr><td>container: &lt;_name-or-ID_&gt;</td><td>加入到其他”shareable”容器的命名空间中</td></tr><tr><td>host</td><td>使用主机系统的命名空间</td></tr></tbody></table><p>如果未指定，则使用Docker Daemon的默认值，它可以是”private”或”shareable”，具体取决于daemon的版本和配置。</p><p>IPC (POSIX/SysV IPC) 命名空间提供命名共享内存段、信号量和消息队列的隔离。</p><p>共享内存段（shared memory segments ）用于以加速进程间通信，性能超过管道或网络。 共享内存常用于科学计算和金融服务行业的数据库和定制高性能应用程序。 如果这些类型的应用程序被分解到多个容器中，可能需要共享容器的 IPC 机制，对主容器使用”shareable”模式，其他容器使用“container:<name-or- id>”模式。</name-or-></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;官方配置文档：&lt;a href=&quot;https://docs.docker.com/engine/reference/run/#ipc-settings---ipc&quot;&gt;Docker run reference&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;--ipc=&amp;quot;MODE&amp;quot;  : 设置容器的 IPC 模式&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="DOCKER" scheme="https://rma-shuyu.github.io/categories/DOCKER/"/>
    
    
    <category term="docker" scheme="https://rma-shuyu.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>nova源码阅读</title>
    <link href="https://rma-shuyu.github.io/2022/06/26/nova%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>https://rma-shuyu.github.io/2022/06/26/nova%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/</id>
    <published>2022-06-26T12:25:15.000Z</published>
    <updated>2023-09-09T10:33:02.414Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-OpenStack基础"><a href="#1-OpenStack基础" class="headerlink" title="1 OpenStack基础"></a>1 OpenStack基础</h2><h2 id="1-1-OpenStack组件介绍"><a href="#1-1-OpenStack组件介绍" class="headerlink" title="1.1 OpenStack组件介绍"></a>1.1 OpenStack组件介绍</h2><p>OpenStack是一个IaaS云计算平台开源实现，其对标产品为AWS。</p><span id="more"></span><p>最开始OpenStack只有两个组件，分别为提供计算服务的Nova以及提供对象存储服务的Swift，其中Nova不仅提供计算服务，还包含了网络服务、块存储服务、镜像服务以及裸机管理服务。之后随着项目的不断发展，从Nova中根据功能拆分为多个独立的项目，如nova-volume拆分为Cinder项目提供块存储服务，nova-image拆分为Glance项目，提供镜像存储服务，nova-network则是neutron的前身，裸机管理也从Nova中分离出来为Ironic项目。最开始容器服务也是由Nova提供支持的，作为Nova的driver之一来实现，而后迁移到Heat，到现在已经独立为一个单独的项目Magnum，后来Magnum的愿景调整为主要提供容器编排服务，单纯的容器服务则由Zun项目接管。最开始OpenStack并没有认证功能，从E版开始才加入认证服务Keystone。</p><p>目前OpenStack基础服务组件如下:</p><ul><li>  Keystone：认证服务。</li><li>  Glance：镜像服务。</li><li>  Nova：计算服务。</li><li>  Cinder：块存储服务。</li><li>  Neutorn：网络服务。</li><li>  Swift：对象存储服务。</li></ul><p>E版之后，在这些核心服务之上，又不断涌现新的服务，如面板服务Horizon、编排服务Heat、数据库服务Trove、文件共享服务Manila、大数据服务Sahara、工作流服务Mistral以及前面提到的容器编排服务Magnum等，这些服务几乎都依赖于以上的基础服务。比如Sahara大数据服务会先调用Heat模板服务，Heat又会调用Nova创建虚拟机，调用Glance获取镜像，调用Cinder创建数据卷，调用Neutron创建网络等。</p><p>OpenStack服务越来越多、越来越复杂，覆盖的技术生态越来越庞大，宛如一个庞然大物，刚接触如此庞大的分布式系统，都或多或少感觉有点如”盲人摸象”的感觉。不过不必先过于绝望，好在OpenStack项目具有非常良好的设计，虽然OpenStack项目众多，组件繁杂，但几乎所有的服务骨架脉络基本是一样的，熟悉了其中一个项目的架构，深入读了其中一个项目源码，再去看其它项目可谓轻车熟路。</p><p>本文章会以Nova项目为例，一步一步剖析源码结构，希望读者阅读完之后再去看Cinder项目会是件非常轻松的事。</p><p>OpenStack所有项目都是基于Python开发，并且都是标准的Python项目，通过setuptools工具管理项目，负责Python模块的安装和分发。想知道一个项目有哪些服务组成，最直接有效的办法就是找到入口函数（main函数）在哪里，只要是标准的基于setuptools管理的项目的所有入口函数都会在项目根目录的setup.cfg文件中定义，console_scripts就是所有服务组件的入口，比如nova（Mitaka版本）的setup.cfg的console_scripts如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[entry_points]</span><br><span class="line">...</span><br><span class="line">console_scripts =</span><br><span class="line">    nova-all = nova.cmd.all:main    nova-api = nova.cmd.api:main    nova-api-metadata = nova.cmd.api_metadata:main    nova-api-os-compute = nova.cmd.api_os_compute:main    nova-cells = nova.cmd.cells:main    nova-cert = nova.cmd.cert:main    nova-compute = nova.cmd.compute:main    nova-conductor = nova.cmd.conductor:main    nova-console = nova.cmd.console:main    nova-consoleauth = nova.cmd.consoleauth:main    nova-dhcpbridge = nova.cmd.dhcpbridge:main    nova-idmapshift = nova.cmd.idmapshift:main    nova-manage = nova.cmd.manage:main    nova-network = nova.cmd.network:main    nova-novncproxy = nova.cmd.novncproxy:main    nova-rootwrap = oslo_rootwrap.cmd:main    nova-rootwrap-daemon = oslo_rootwrap.cmd:daemon    nova-scheduler = nova.cmd.scheduler:main    nova-serialproxy = nova.cmd.serialproxy:main    nova-spicehtml5proxy = nova.cmd.spicehtml5proxy:main    nova-xvpvncproxy = nova.cmd.xvpvncproxy:main</span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>由此可知nova项目安装后会包含21个可执行程序，其中nova-compute服务的入口函数为nova/cmd/compute.py模块的main函数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def main():</span><br><span class="line">    config.parse_args(sys.argv)</span><br><span class="line">    logging.setup(CONF, &#x27;nova&#x27;)</span><br><span class="line">    utils.monkey_patch()</span><br><span class="line">    objects.register_all()</span><br><span class="line"></span><br><span class="line">    gmr.TextGuruMeditation.setup_autorun(version)</span><br><span class="line"></span><br><span class="line">    if not CONF.conductor.use_local:</span><br><span class="line">        block_db_access()</span><br><span class="line">        objects_base.NovaObject.indirection_api = \</span><br><span class="line">            conductor_rpcapi.ConductorAPI()</span><br><span class="line">    else:</span><br><span class="line">        LOG.warning(_LW(&#x27;Conductor local mode is deprecated and will &#x27;</span><br><span class="line">                        &#x27;be removed in a subsequent release&#x27;))</span><br><span class="line"></span><br><span class="line">    server = service.Service.create(binary=&#x27;nova-compute&#x27;,</span><br><span class="line">                                    topic=CONF.compute_topic,</span><br><span class="line">                                    db_allowed=CONF.conductor.use_local)</span><br><span class="line">    service.serve(server)</span><br><span class="line">    service.wait()</span><br></pre></td></tr></table></figure><p>其它服务依次类推。</p><p>OpenStack使用Python语言开发，而Python是动态类型语言，参数类型不容易从代码中看出，因此部署一个allinone的OpenStack开发测试环境非常有必要，建议使用RDO部署：<a href="https://link.zhihu.com/?target=https://www.rdoproject.org/install/quickstart/">Packstack quickstart</a>，当然乐于折腾使用DevStack也是没有问题的。</p><p>要想深入研究源码，最有效的方式就是一步一步跟踪代码执行，因此会使用debug工具是关键技能之一。Python的debug工具有很多，为了简便起见，pdb工具就够了，你也可以尝试ipdb、ptpdb之类的调试工具。使用方法也非常简单，只要在你想设置断点的地方，嵌入以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import pdb; pdb.set_trace()</span><br></pre></td></tr></table></figure><p>然后在命令行（不能通过systemd启动）直接运行服务即可。</p><p>假如想跟踪nova创建虚拟机的过程，首先nova/api/openstack/compute/servers.py模块的create方法打上断点，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">def create(self, req, body):</span><br><span class="line">    &quot;&quot;&quot;Creates a new server for a given user.&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    import pdb; pdb.set_trace() # 设置断点</span><br><span class="line">    context = req.environ[&#x27;nova.context&#x27;]</span><br><span class="line">    server_dict = body[&#x27;server&#x27;]</span><br><span class="line">    password = self._get_server_admin_password(server_dict)</span><br><span class="line">    name = common.normalize_name(server_dict[&#x27;name&#x27;])</span><br><span class="line"></span><br><span class="line">    if api_version_request.is_supported(req, min_version=&#x27;2.19&#x27;):</span><br><span class="line">        if &#x27;description&#x27; in server_dict:</span><br><span class="line">            # This is allowed to be None</span><br><span class="line">            description = server_dict[&#x27;description&#x27;]</span><br><span class="line">        else:</span><br><span class="line">            # No default description</span><br><span class="line">            description = None</span><br><span class="line">    else:</span><br><span class="line">        description = name</span><br><span class="line">    ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后注意需要通过命令行直接运行，而不能通过systemd启动:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su -c &#x27;nova-api&#x27; nova</span><br></pre></td></tr></table></figure><p>此时调用创建虚拟机API，nova-api进程就会立即弹出pdb shell，此时你可以通过s或者n命令一步一步执行代码。</p><h2 id="1-3-OpenStack项目通用骨骼脉络"><a href="#1-3-OpenStack项目通用骨骼脉络" class="headerlink" title="1.3 OpenStack项目通用骨骼脉络"></a>1.3 OpenStack项目通用骨骼脉络</h2><p>阅读源码的首要问题就是就要对代码的结构了然于胸，<strong>需要强调的是，OpenStack项目的目录结构并不是根据组件严格划分，而是根据功能划分</strong>，以Nova为例，compute目录并不是一定在nova-compute节点上运行，而主要是和compute相关(虚拟机操作相关）的功能实现，同样的，scheduler目录代码并不全在scheduler服务节点运行，但主要是和调度相关的代码。不过目录结构并不是完全没有规律，它遵循一定的套路。</p><p>通常一个服务的目录都会包含<strong>api.py、rpcapi.py、manager.py</strong>，这三个是最最重要的模块。</p><ul><li>  <strong>api.py</strong>： 通常是供其它组件调用的封装库。换句话说，该模块通常并不会由本模块调用，而是类似提供其它服务SDK。比如compute目录的api.py，通常会由nova-api服务的controller调用。</li><li>  <strong>rpcapi.py</strong>：这个是RPC请求的封装，或者说是RPC封装的client端，该模块封装了所有RPC请求调用。</li><li>  <strong>manager.py</strong>： 这个才是真正服务的功能实现，也是RPC的服务端，即处理RPC请求的入口，实现的方法和rpcapi实现的方法一一对应。</li></ul><p>比如对一个虚拟机执行关机操作的流程为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">API节点</span><br><span class="line">nova-api接收用户请求 -&gt; nova-api调用compute/api.py</span><br><span class="line">-&gt; compute/api调用compute/rpcapi.py -&gt; rpcapi.py向目标计算节点发起stop_instance()RPC请求</span><br><span class="line"></span><br><span class="line">计算节点</span><br><span class="line">收到MQ RPC消息 -&gt; 解析stop_instance()请求 -&gt; 调用compute/manager.py的callback方法stop_instance() -&gt; 调用libvirt关机虚拟机</span><br></pre></td></tr></table></figure><p>前面提到OpenStack项目的目录结构是按照功能划分的，而不是服务组件，因此并不是所有的目录都能有对应的组件。仍以Nova为例:</p><ul><li>  cmd：这是服务的启动脚本，即所有服务的main函数。看服务怎么初始化，就从这里开始。</li><li>  db: 封装数据库访问API，目前支持的driver为sqlalchemy，还包括migrate repository。</li><li>  conf：Nova的配置项声明都在这里，想看Nova配置的作用和默认值可以从这个目录入手。</li><li>  locale: 本地化处理。</li><li>  image: 封装image API，其实就是调用python-glanceclient。</li><li>  network: 封装网络服务接口，根据配置不同，可能调用nova-network或者neutron。</li><li>  volume: 封装数据卷访问接口，通常是Cinder的client封装，调用python-cinderclient。</li><li>  virt: 这是所有支持的hypervisor驱动，主流的如libvirt、xen等。</li><li>  objects: 对象模型，封装了所有实体对象的CURD操作，相对直接调用db的model更安全，并且支持版本控制。</li><li>  policies： policy校验实现。</li><li>  tests: 单元测试和功能测试代码。</li></ul><p>以上同样适用于其它服务，比如Cinder等。</p><p>另外需要了解的是，所有的API入口都是从xxx-api开始的，RESTFul API是OpenStack服务的唯一入口，也就是说，阅读源码就从api开始。而api组件也是根据实体划分的，不同的实体对应不同的controller，比如servers、flavors、keypairs等，controller的index方法对应list操作、show方法对应get操作、create创建、delete删除、update更新等。</p><p>根据进程阅读源码并不是什么好的实践，因为光理解服务如何初始化、如何通信、如何发送心跳等就不容易，各种高级封装太复杂了。我认为比较好的阅读源码方式是追踪一个任务的执行过程，比如看启动虚拟机的整个流程。因此接下来本文将以创建一台虚拟机为例，一步步分析其过程。</p><h2 id="2-创建虚拟机过程分析"><a href="#2-创建虚拟机过程分析" class="headerlink" title="2 创建虚拟机过程分析"></a>2 创建虚拟机过程分析</h2><p>这里以创建虚拟机过程为例，根据前面的总体套路，一步步跟踪其执行过程。需要注意的是，Nova支持同时创建多台虚拟机，因此在调度时需要选择多个宿主机。</p><h2 id="S1-nova-api"><a href="#S1-nova-api" class="headerlink" title="S1 nova-api"></a>S1 nova-api</h2><p>入口为<strong>nova/api/openstack/compute/servers.py</strong>的create方法，该方法检查了一堆参数以及policy后，调用compute_api的create方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">def create(self, req, body):</span><br><span class="line">    &quot;&quot;&quot;Creates a new server for a given user.&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    context = req.environ[&#x27;nova.context&#x27;]</span><br><span class="line">    server_dict = body[&#x27;server&#x27;]</span><br><span class="line">    password = self._get_server_admin_password(server_dict)</span><br><span class="line">    name = common.normalize_name(server_dict[&#x27;name&#x27;])</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    flavor_id = self._flavor_id_from_req_data(body)</span><br><span class="line">    try:</span><br><span class="line">        inst_type = flavors.get_flavor_by_flavor_id(</span><br><span class="line">                flavor_id, ctxt=context, read_deleted=&quot;no&quot;)</span><br><span class="line"></span><br><span class="line">        (instances, resv_id) = self.compute_api.create(context,</span><br><span class="line">                        inst_type,</span><br><span class="line">                        image_uuid,</span><br><span class="line">                        display_name=name,</span><br><span class="line">                        display_description=description,</span><br><span class="line">                        availability_zone=availability_zone,</span><br><span class="line">                        forced_host=host, forced_node=node,</span><br><span class="line">                        metadata=server_dict.get(&#x27;metadata&#x27;, &#123;&#125;),</span><br><span class="line">                        admin_password=password,</span><br><span class="line">                        requested_networks=requested_networks,</span><br><span class="line">                        check_server_group_quota=True,</span><br><span class="line">                        **create_kwargs)</span><br><span class="line">    except (exception.QuotaError,</span><br><span class="line">            exception.PortLimitExceeded) as error:</span><br><span class="line">        raise exc.HTTPForbidden(</span><br><span class="line">            explanation=error.format_message())</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>这里的compute_api即前面说的<strong>nova/compute/api.py</strong>模块，找到该模块的create方法，该方法会创建数据库记录、检查参数等，然后调用compute_task_api的build_instances方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">self.compute_task_api.schedule_and_build_instances(</span><br><span class="line">    context,</span><br><span class="line">    build_requests=build_requests,</span><br><span class="line">    request_spec=request_specs,</span><br><span class="line">    image=boot_meta,</span><br><span class="line">    admin_password=admin_password,</span><br><span class="line">    injected_files=injected_files,</span><br><span class="line">    requested_networks=requested_networks,</span><br><span class="line">    block_device_mapping=block_device_mapping)</span><br></pre></td></tr></table></figure><p>compute_task_api即conductor的api.py。conductor的api并没有执行什么操作，直接调用了conductor_compute_rpcapi的build_instances方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def schedule_and_build_instances(self, context, build_requests,</span><br><span class="line">                                 request_spec, image,</span><br><span class="line">                                 admin_password, injected_files,</span><br><span class="line">                                 requested_networks, block_device_mapping):</span><br><span class="line">    self.conductor_compute_rpcapi.schedule_and_build_instances(</span><br><span class="line">        context, build_requests, request_spec, image,</span><br><span class="line">        admin_password, injected_files, requested_networks,</span><br><span class="line">        block_device_mapping)</span><br></pre></td></tr></table></figure><p>该方法就是conductor RPC API，即<strong>nova/conductor/rpcapi.py</strong>模块，该方法除了一堆的版本检查，剩下的就是对RPC调用的封装，代码只有两行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cctxt = self.client.prepare(version=version)</span><br><span class="line">cctxt.cast(context, &#x27;build_instances&#x27;, **kw)</span><br></pre></td></tr></table></figure><p>其中cast表示异步调用，build_instances是远程调用的方法，kw是传递的参数。参数是字典类型，没有复杂对象结构，因此不需要特别的序列化操作。</p><p>截至到现在，虽然目录由api-&gt;compute-&gt;conductor，但仍在nova-api进程中运行，直到cast方法执行，该方法由于是异步调用，因此nova-api任务完成，此时会响应用户请求，虚拟机状态为building。</p><h2 id="S2-nova-conductor"><a href="#S2-nova-conductor" class="headerlink" title="S2 nova-conductor"></a>S2 nova-conductor</h2><p>由于是向nova-conductor发起的RPC调用，而前面说了接收端肯定是manager.py，因此进程跳到nova-conductor服务，入口为nova/conductor/manager.py的build_instances方法，该方法首先调用了_schedule_instances方法，该方法调用了scheduler_client的select_destinations方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def _schedule_instances(self, context, request_spec, filter_properties):</span><br><span class="line">    scheduler_utils.setup_instance_group(context, request_spec,</span><br><span class="line">                                         filter_properties)</span><br><span class="line">    # TODO(sbauza): Hydrate here the object until we modify the</span><br><span class="line">    # scheduler.utils methods to directly use the RequestSpec object</span><br><span class="line">    spec_obj = objects.RequestSpec.from_primitives(</span><br><span class="line">        context, request_spec, filter_properties)</span><br><span class="line">    hosts = self.scheduler_client.select_destinations(context, spec_obj)</span><br><span class="line">    return hosts</span><br></pre></td></tr></table></figure><p>scheduler_client和compute_api以及compute_task_api都是一样对服务的client SDK调用，不过scheduler没有api.py，而是有个单独的client目录，实现在client目录的__init__.py，这里仅仅是调用query.py下的SchedulerQueryClient的select_destinations实现，然后又很直接地调用了scheduler_rpcapi的select_destinations方法，终于又到了RPC调用环节。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def _schedule_instances(self, context, request_spec, filter_properties):</span><br><span class="line">    scheduler_utils.setup_instance_group(context, request_spec,</span><br><span class="line">                                         filter_properties)</span><br><span class="line">    # TODO(sbauza): Hydrate here the object until we modify the</span><br><span class="line">    # scheduler.utils methods to directly use the RequestSpec object</span><br><span class="line">    spec_obj = objects.RequestSpec.from_primitives(</span><br><span class="line">        context, request_spec, filter_properties)</span><br><span class="line">    hosts = self.scheduler_client.select_destinations(context, spec_obj)</span><br><span class="line">    return hosts</span><br></pre></td></tr></table></figure><p>毫无疑问，RPC封装同样是在scheduler的rpcapi中实现。该方法RPC调用代码如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return cctxt.call(ctxt, &#x27;select_destinations&#x27;, **msg_args)</span><br></pre></td></tr></table></figure><p>注意这里调用的call方法，即同步RPC调用，此时nova-conductor并不会退出，而是堵塞等待直到nova-scheduler返回。因此当前状态为nova-conductor为blocked状态，等待nova-scheduler返回，nova-scheduler接管任务。</p><h2 id="S3-nova-scheduler"><a href="#S3-nova-scheduler" class="headerlink" title="S3 nova-scheduler"></a>S3 nova-scheduler</h2><p>同理找到scheduler的manager.py模块的select_destinations方法，该方法会调用driver方法，这里的driver其实就是调度算法实现，通常用的比较多的就是Filter Scheduler算法，对应filter_scheduler.py模块，该模块首先通过host_manager拿到所有的计算节点信息，然后通过filters过滤掉不满足条件的计算节点，剩下的节点通过weigh方法计算权值，最后选择权值高的作为候选计算节点返回。最后nova-scheduler返回调度结果的hosts集合，任务结束，返回到nova-conductor服务。</p><h2 id="S4-nova-condutor"><a href="#S4-nova-condutor" class="headerlink" title="S4 nova-condutor"></a>S4 nova-condutor</h2><p>回到scheduler/manager.py的build_instances方法，nova-conductor等待nova-scheduler返回后，拿到调度的计算节点列表。因为可能同时启动多个虚拟机，因此循环调用了compute_rpcapi的build_and_run_instance方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">for (instance, host) in six.moves.zip(instances, hosts):</span><br><span class="line">    instance.availability_zone = (</span><br><span class="line">        availability_zones.get_host_availability_zone(context,</span><br><span class="line">                                                      host[&#x27;host&#x27;]))</span><br><span class="line">    try:</span><br><span class="line">        # NOTE(danms): This saves the az change above, refreshes our</span><br><span class="line">        # instance, and tells us if it has been deleted underneath us</span><br><span class="line">        instance.save()</span><br><span class="line">    except (exception.InstanceNotFound,</span><br><span class="line">            exception.InstanceInfoCacheNotFound):</span><br><span class="line">        LOG.debug(&#x27;Instance deleted during build&#x27;, instance=instance)</span><br><span class="line">        continue</span><br><span class="line">    ...</span><br><span class="line">    self.compute_rpcapi.build_and_run_instance(context,</span><br><span class="line">            instance=instance, host=host[&#x27;host&#x27;], image=image,</span><br><span class="line">            request_spec=request_spec,</span><br><span class="line">            filter_properties=local_filter_props,</span><br><span class="line">            admin_password=admin_password,</span><br><span class="line">            injected_files=injected_files,</span><br><span class="line">            requested_networks=requested_networks,</span><br><span class="line">            security_groups=security_groups,</span><br><span class="line">            block_device_mapping=bdms, node=host[&#x27;nodename&#x27;],</span><br><span class="line">            limits=host[&#x27;limits&#x27;])</span><br></pre></td></tr></table></figure><p>看到xxxrpc立即想到对应的代码位置，位于compute/rpcapi模块，该方法向nova-compute发起RPC请求:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cctxt.cast(ctxt, &#x27;build_and_run_instance&#x27;, ...)</span><br></pre></td></tr></table></figure><p>由于是cast调用，因此发起的是异步RPC，因此nova-conductor任务结束，紧接着终于轮到nova-compute登场了。</p><h2 id="S5-nova-compute"><a href="#S5-nova-compute" class="headerlink" title="S5 nova-compute"></a>S5 nova-compute</h2><p>到了nova-compute服务，入口为compute/manager.py，找到build_and_run_instance方法，该方法调用了driver的spawn方法，这里的driver就是各种hypervisor的实现，所有实现的driver都在virt目录下，入口为driver.py，比如libvirt driver实现对应为virt/libvirt/driver.py，找到spawn方法，该方法拉取镜像创建根磁盘、生成xml文件、define domain，启动domain等。最后虚拟机完成创建。nova-compute服务结束。</p><h2 id="3-一张图总结"><a href="#3-一张图总结" class="headerlink" title="3 一张图总结"></a>3 一张图总结</h2><p>以上是创建虚拟机的各个服务的交互过程以及调用关系，略去了很多细节。需要注意的是，所有的数据库操作，比如instance.save（）以及update()操作，如果配置use_local为false，则会向nova-conductor发起RPC调用，由nova-conductor代理完成数据库更新，而不是直接由nova-compute更新数据库，这里的RPC调用过程在以上的分析中省略了。</p><p>整个流程用一张图表示为:</p><p><img src="https://pic3.zhimg.com/v2-7df2beb26c8ef40411501294164da086_r.jpg"></p><p>如果你对OpenStack的其它服务以及操作流程感兴趣，可以参考我的<a href="https://link.zhihu.com/?target=https://github.com/int32bit/openstack-workflow">openstack-workflow</a>项目, 这个项目是我本人在学习过程中记录，绘制成序列图，上图就是其中一个实例。项目地址为: <a href="https://link.zhihu.com/?target=https://github.com/int32bit/openstack-workflow">https://github.com/int32bit/openstack-workflow</a>。</p><p>本文转自 <a href="https://zhuanlan.zhihu.com/p/28959724">https://zhuanlan.zhihu.com/p/28959724</a>，如有侵权，请联系删除。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;1-OpenStack基础&quot;&gt;&lt;a href=&quot;#1-OpenStack基础&quot; class=&quot;headerlink&quot; title=&quot;1 OpenStack基础&quot;&gt;&lt;/a&gt;1 OpenStack基础&lt;/h2&gt;&lt;h2 id=&quot;1-1-OpenStack组件介绍&quot;&gt;&lt;a href=&quot;#1-1-OpenStack组件介绍&quot; class=&quot;headerlink&quot; title=&quot;1.1 OpenStack组件介绍&quot;&gt;&lt;/a&gt;1.1 OpenStack组件介绍&lt;/h2&gt;&lt;p&gt;OpenStack是一个IaaS云计算平台开源实现，其对标产品为AWS。&lt;/p&gt;</summary>
    
    
    
    <category term="openstack" scheme="https://rma-shuyu.github.io/categories/openstack/"/>
    
    
    <category term="nova" scheme="https://rma-shuyu.github.io/tags/nova/"/>
    
  </entry>
  
  <entry>
    <title>nova架构及源码分析</title>
    <link href="https://rma-shuyu.github.io/2022/06/25/nova%E6%9E%B6%E6%9E%84%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://rma-shuyu.github.io/2022/06/25/nova%E6%9E%B6%E6%9E%84%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2022-06-25T12:25:15.000Z</published>
    <updated>2023-09-09T10:33:02.413Z</updated>
    
    <content type="html"><![CDATA[<h1 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a><a href="about:blank#%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84" title="整体架构"></a>整体架构</h1><ul><li>  nova 和其他组件之间的交互使用 HTTP 请求</li><li>  内部组件之间使用 <a href="https://github.com/openstack/oslo.messaging">oslo_messaging</a> 库实现 RPC 调用，这里还涉及消息队列 RabbitMQ ，遵循 AMQP 协议</li><li>  大部分 nova 组件都可以运行在多个服务器上，然后使用一个管理器监听 RPC 消息</li><li>  而 nova-compute 是运行在计算主机上的单进程，用于管理计算资源</li><li>nova 内部组件共享本地数据库，通过对象层访问，确保兼容性和安全性<ul><li>  nova-compute 访问数据库由 nova-conductor 代理<span id="more"></span><img src="https://i.loli.net/2021/06/06/K51XMdUyPrRmupT.png"></li></ul></li></ul><p>当用户发起一个新的请求时，该请求会先在 nova-api 中处理。nova-api 会对请求进行一系列检查，包括请求是否合法，配额是否足够等；当检查用过后，nova-api 就会为该请求分配一个唯一的虚拟机 ID ，并在数据库中新建对应的项来记录虚拟机的状态；然后，nova-api 会将请求发送给 nova-conductor 处理。</p><p>nova-conductor 主要管理服务之间的通信并进行任务处理。它在接收到请求之后，会为 nova-scheduler 创建一个 RequestSpec 对象用来包装与调度相关的所有请求信息，然后调用 nova-scheduler 服务的 select_destination 接口。</p><p>nova-scheduler 通过接收到的 RequestSpec 对象，首先将 RequestSpec 对象转换成 ResourceRequest 对象，并将该对象发送给 Placement 进行一次预筛选，然后会根据数据库中最新的系统状态做出调度决定，并告诉 nova-conductor 把该请求调度到合适的计算节点上。</p><p>nova-conductor 在得知调度决定后，会把请求发送给对应的 nova-compute 服务。</p><p>每个 nova-compute 服务都有独立的资源监视器（Resource Tracker）用来监视本地主机的资源使用情况。当计算节点接收到请求时，资源监视器能够检查主机是否有足够的资源。</p><ul><li>  如果对应的资源足够，nova-compute 就会允许在当前主机中启动所要求的虚拟机，并在数据库中更新虚拟机状态，同时将最新的主机资源情况更新到数据库</li><li>  如果当前主机不符合请求的资源要求，nova-compute 会拒绝启动虚拟机，并将请求重新发给 nova-conductor 服务，重试整个调度过程</li></ul><p><img src="https://i.loli.net/2021/06/06/DizGwcpYRQhWKqS.jpg"></p><h2 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a><a href="about:blank#%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86" title="组成部分"></a>组成部分</h2><ol><li>nova-api 接受和响应用户的计算 API 调用</li><li>nova-api-metadata 接受来自实例的元数据请求 <a href="https://docs.openstack.org/nova/latest/admin/metadata-service.html">Metadata service</a></li><li>nova-compute 通过 hypervisor API 创建和终止虚拟机实例的守护进程。例如 KVM/QEMU 的 libvirt、VMware 的 VMwareAPI 。 运行在它所管理的 hypervisor 机器上，管理与虚拟机管理程序和虚拟机的通信。</li><li>nova-scheduler 从消息队列中获取虚拟机实例请求，并决定在哪个服务器上运行。</li><li>nova-conductor 处理需要协调的请求（构建/调整）、充当数据库代理或处理对象转换。用于连接 nova-api、nova-scheduler、nova-compute 服务。</li><li>nova-novncproxy 协调 nova-compute 服务和数据库之间的交互。避免 nova-compute 直接访问数据库，为了提供更好的 API 兼容性。建议不要部署在 nova-compute 服务所在的节点上。</li><li>nova-spicehtml5proxy 提供通过 SPICE 连接访问运行实例的代理，支持基于浏览器的 HTML5 客户端。</li><li>The queue 在守护进程之间传递消息的中央消息队列，通常使用 RabbitMQ 。</li><li>SQL database 存储云基础设施的大多数构建时和运行时状态，包括：可用的实例类型、在使用的实例、可用的网络、项目。</li></ol><h1 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a><a href="about:blank#RPC" title="RPC"></a>RPC</h1><p>消息代理（RabbitMQ AMQP broker）允许 nova 内部组件以低耦合的方式进行通信，建立在发布/订阅（publish/subscribe）模式上</p><ul><li>  解耦客户端和服务端</li><li>  同步客户端和服务端</li><li>  平衡远程调用</li></ul><p>nova 使用 AMQP 中的直连（direct）、扇型（fanout）、主题（topic）交换；</p><p>nova 使用适配器类（adapter）将消息封装和解封从而调用函数，实现了两种 RPC 调用</p><ul><li>  <code>rpc.call</code>：请求 + 响应，api 作为消费者（consumer）</li><li>  <code>rpc.cast</code>：单向，api 作为发布者（publisher）</li></ul><p>每个 nova 服务在初始化时创建两个队列</p><ul><li>  接受路由键 <code>NODE-TYPE.NODE-ID</code>（例如，<code>compute.hostname</code>）：nova-api 需要重定向到特定节点</li><li>  接受路由键 <code>NODE-TYPE</code>（例如，<code>compute</code>）：</li></ul><p><img src="https://i.loli.net/2021/06/06/ZvNb61tfPTlF9or.png"></p><p>每个 nova 内部组件都连接到消息代理，根据不同的作用，把消息队列作为：</p><ul><li>  调用者（Invoker）：nova-api、nova-scheduler；通过 <code>rpc.call</code> 和 <code>rpc.cast</code> 向消息队列发送消息</li><li>  工作者（Worker）：nova-compute；从消息队列接收消息，根据 <code>rpc.call</code> 进行响应</li></ul><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a><a href="about:blank#%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5" title="相关概念"></a>相关概念</h2><p><strong>主题发布者（Topic Publisher）</strong></p><p>执行 <code>rpc.call</code> 或 <code>rpc.cast</code> 操作将实例化一个主题发布者，用于将消息发送到消息队列。每个发布者总是连接到相同的主题交换机（topic-based exchange）；生命周期仅限于消息传递。</p><p><strong>直连消费者（Direct Consumer）</strong></p><p>执行 <code>rpc.call</code> 操作将实例化一个直连消费者，用于从消息队列接收响应消息。每个消费者连接到唯一的直连交换机（direct-based exchange）；生命周期仅限于消息传递。</p><p><strong>主题消费者（Topic Consumer）</strong></p><p>当工作者被实例化后将实例化一个主题消费者，并存在于工作者的整个生命周期；主题消费者用于从消息队列接收消息，并调用工作者定义的操作。主题消费者通过共享/排他队列（shared/exclusive queue）连接到相同的主体交换机。每个工作者都有两个主题消费者，一个处理 <code>rpc.cast</code> ，连接到交换键是 <code>topic</code> 的共享队列；另一个处理 <code>rpc.call</code> ，连接到交换键是 <code>topic.host</code> 的独立队列。</p><p><strong>直连发布者（Direct Publisher）</strong></p><p>执行 <code>rpc.call</code> 操作将实例化一个直连发布者，用于返回请求/响应操作所需的消息，连接到直连交换机。</p><p><strong>主题交换机（Topic Exchange）</strong></p><p>存在于虚拟机上下文中的路由表；类型（主题/直连）决定了路由策略；对于 nova 中的每个主题，消息代理节点只有一个主题交换机。</p><p><strong>直连交换机（Direct Exchange）</strong></p><p>在 <code>rpc.call</code> 操作中创建的路由表，消息代理节点的生命周期中有许多该实例，对应每个 <code>rpc.call</code> 调用。</p><p><strong>队列元素（Queue Element）</strong></p><p>消息桶，消息一直保存在队列中，直到消费者（主题/直连）连接到队列获取消息。队列可以是共享的也可以是独立的；路由键是 <code>topic</code> 的队列在相同类型的工作者中共享。</p><h2 id="rpc-call"><a href="#rpc-call" class="headerlink" title="rpc.call"></a><a href="about:blank#rpc-call" title="rpc.call"></a>rpc.call</h2><ol><li>实例化主题发布者，将请求发送到消息队列；在发布操作之前，实例化直连消费者等待响应信息</li><li>一旦消息被交换器分派（dispatch），它就会被路由键（例如，<code>topic.host</code>）指定的主题消费者获取，并传递给负责该任务的工作者</li><li>任务完成后，将分配一个直连发布者将响应消息发送到消息队列</li><li>一旦消息被交换器分派，它就会被路由键（例如，<code>msg_id</code>）指定的直连消费者获取，并传递给调用者</li></ol><p><img src="https://i.loli.net/2021/06/06/ApK1vCySXhQE3mW.png"></p><h2 id="rpc-cast"><a href="#rpc-cast" class="headerlink" title="rpc.cast"></a><a href="about:blank#rpc-cast" title="rpc.cast"></a>rpc.cast</h2><ol><li>实例化主题发布者，将请求发送到消息队列</li><li>一旦消息被交换器分派（dispatch），它就会被路由键（例如，<code>topic</code>）指定的主题消费者获取，并传递给负责该任务的工作者</li></ol><p><img src="https://i.loli.net/2021/06/06/3nUaoMlKdHg9BQv.png"></p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a><a href="about:blank#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90" title="源码分析"></a>源码分析</h1><p>从 github 下载 Victoria 版本的 Nova 源码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/openstack/nova.git --branch stable/victoria --single-branch</span><br></pre></td></tr></table></figure><p>nova/ 文件夹下的目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">accelerator/    # Cyborg 加速器</span><br><span class="line">api/            # Nova API 服务</span><br><span class="line">cmd/            # 各个 Nova 服务的入口程序</span><br><span class="line">compute/        # Nova Compute 服务</span><br><span class="line">conductor/      # Nova Conductor 服务</span><br><span class="line">conf/           # 所有的配置选项</span><br><span class="line">console/        # nova-console 服务</span><br><span class="line">db/             # 封装数据库操作</span><br><span class="line">hacking/        # 编码规范检查</span><br><span class="line">image/          # 封装镜像操作，Glance 接口抽象</span><br><span class="line">keymgr/         # 密钥管理器实现</span><br><span class="line">locale/         # 国际化相关文件</span><br><span class="line">network/        # nova-network 服务</span><br><span class="line">notifications/  # 通知相关功能</span><br><span class="line">objects/        # 封装实体对象的 CURD 操作</span><br><span class="line">pci/            # PCI/SR-IOV 支持</span><br><span class="line">policies/       # 所有 Policy 的默认规则</span><br><span class="line">privsep/        # oslo_privsep 相关</span><br><span class="line">scheduler/      # Nova Scheduler 服务</span><br><span class="line">servicegroup/   # 成员服务（membership），服务组</span><br><span class="line">storage/        # Ceph 存储支持</span><br><span class="line">tests/          # 单元测试</span><br><span class="line">virt/           # 支持的 hypervisor 驱动</span><br><span class="line">volume/         # 封装卷访问接口，Cinder 接口抽象</span><br></pre></td></tr></table></figure><p>nova/ 文件夹下的 python 文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">__init__.py</span><br><span class="line">availability_zones.py   # 区域设置的工具函数</span><br><span class="line">baserpc.py              # 基础 RPC 客户端/服务端实现</span><br><span class="line">block_device.py         # 块设备映射</span><br><span class="line">cache_utils.py          # oslo_cache 封装</span><br><span class="line">config.py               # 解析命令行参数</span><br><span class="line">context.py              # 贯穿 Nova 的所有请求的上下文</span><br><span class="line">crypto.py               # 包装标准加密数据元素</span><br><span class="line">debugger.py             # pydev 调试</span><br><span class="line">exception.py            # 基础异常类</span><br><span class="line">exception_wrapper.py    # 封装异常类</span><br><span class="line">filters.py              # 基础过滤器</span><br><span class="line">i18n.py                 # 集成 oslo_i18n</span><br><span class="line">loadables.py            # 可加载类</span><br><span class="line">manager.py              # 基础 Manager 类</span><br><span class="line">middleware.py           # 更新 oslo_middleware 的默认配置选项</span><br><span class="line">monkey_patch.py         # eventlet 猴子补丁</span><br><span class="line">policy.py               # 策略引擎</span><br><span class="line">profiler.py             # 调用 OSProfiler</span><br><span class="line">quota.py                # 每个项目的资源配额</span><br><span class="line">rpc.py                  # RPC 操作相关的工具函数</span><br><span class="line">safe_utils.py           # 不会导致循环导入的工具函数</span><br><span class="line">service.py              # 通用节点基类，用于在主机上运行的所有工作者</span><br><span class="line">service_auth.py         # 身份认证插件</span><br><span class="line">test.py                 # 单元测试基础类</span><br><span class="line">utils.py                # 工具函数</span><br><span class="line">version.py              # 版本号管理</span><br><span class="line">weights.py              # 权重插件</span><br><span class="line">wsgi.py                 # 管理 WSGI 应用的服务器类</span><br></pre></td></tr></table></figure><p>setup.cfg 配置文件，<code>[entry_points]</code> 小节指定了 nova 各个组件入口</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">console_scripts =</span><br><span class="line">    nova-api = nova.cmd.api:main</span><br><span class="line">    nova-api-metadata = nova.cmd.api_metadata:main</span><br><span class="line">    nova-api-os-compute = nova.cmd.api_os_compute:main</span><br><span class="line">    nova-compute = nova.cmd.compute:main</span><br><span class="line">    nova-conductor = nova.cmd.conductor:main</span><br><span class="line">    nova-manage = nova.cmd.manage:main</span><br><span class="line">    nova-novncproxy = nova.cmd.novncproxy:main</span><br><span class="line">    nova-policy = nova.cmd.policy:main</span><br><span class="line">    nova-rootwrap = oslo_rootwrap.cmd:main</span><br><span class="line">    nova-rootwrap-daemon = oslo_rootwrap.cmd:daemon</span><br><span class="line">    nova-scheduler = nova.cmd.scheduler:main</span><br><span class="line">    nova-serialproxy = nova.cmd.serialproxy:main</span><br><span class="line">    nova-spicehtml5proxy = nova.cmd.spicehtml5proxy:main</span><br><span class="line">    nova-status = nova.cmd.status:main</span><br><span class="line">wsgi_scripts =</span><br><span class="line">    nova-api-wsgi = nova.api.openstack.compute.wsgi:init_application</span><br><span class="line">    nova-metadata-wsgi = nova.api.metadata.wsgi:init_application</span><br></pre></td></tr></table></figure><h2 id="nova-api"><a href="#nova-api" class="headerlink" title="nova-api"></a><a href="about:blank#nova-api" title="nova-api"></a>nova-api</h2><p>nova-api 对外提供 RESTful API，没有对内的 RPC 。</p><p>nova/api/ 目录结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">__init__.py</span><br><span class="line">auth.py             # 身份认证中间件</span><br><span class="line">compute_req_id.py   # x-compute-request-id 中间件（oslo_middleware）</span><br><span class="line">metadata/           # Metadata API</span><br><span class="line">openstack/          # Nova v2.1 API</span><br><span class="line">validation/         # 请求体验证</span><br><span class="line">wsgi.py             # WSGI 原语（请求、应用、中间件、路由、加载器）</span><br></pre></td></tr></table></figure><p>openstack 目录中包含 WSGI 基础架构的代码，一些 WSGI 中间件，以及如何解析请求与分发请求的核心代码。</p><p>nova/api/openstack/compute/ 包含 Controller 实现，Resource 对象将 API 映射到相应的 Controller 方法上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">__init__.py</span><br><span class="line">api_version_request.py  # 版本验证</span><br><span class="line">auth.py                 # noauth 中间件</span><br><span class="line">common.py               # 信息查询的工具函数</span><br><span class="line">compute/                # 每个 API 的入口点</span><br><span class="line">identity.py             # 验证项目是否存在</span><br><span class="line">requestlog.py           # 请求日志中间件</span><br><span class="line">urlmap.py               # url 映射</span><br><span class="line">versioned_method.py     # 版本信息</span><br><span class="line">wsgi.py                 # WSGI 相关抽象类</span><br><span class="line">wsgi_app.py             # WSGI 应用程序初始化方法</span><br></pre></td></tr></table></figure><h3 id="API-请求路由"><a href="#API-请求路由" class="headerlink" title="API 请求路由"></a><a href="about:blank#API-%E8%AF%B7%E6%B1%82%E8%B7%AF%E7%94%B1" title="API 请求路由"></a>API 请求路由</h3><p>nova-api 读取 etc/nova/api-paste.ini 并加载 WSGI 程序，最终 API 入口点都位于 nova.api.openstack.compute 中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[composite:osapi_compute]</span><br><span class="line">use = call:nova.api.openstack.urlmap:urlmap_factory</span><br><span class="line">/: oscomputeversions                # version API</span><br><span class="line">/v2: oscomputeversion_legacy_v2     # v2 API</span><br><span class="line">/v2.1: oscomputeversion_v2          # v2.1 API</span><br><span class="line"># v21 is an exactly feature match for v2, except it has more stringent</span><br><span class="line"># input validation on the wsgi surface (prevents fuzzing early on the</span><br><span class="line"># API). It also provides new features via API microversions which are</span><br><span class="line"># opt into for clients. Unaware clients will receive the same frozen</span><br><span class="line"># v2 API feature set, but with some relaxed validation</span><br><span class="line">/v2/+: openstack_compute_api_v21_legacy_v2_compatible</span><br><span class="line">/v2.1/+: openstack_compute_api_v21</span><br><span class="line"></span><br><span class="line">[composite:openstack_compute_api_v21]</span><br><span class="line">use = call:nova.api.auth:pipeline_factory_v21       # 加载中间件</span><br><span class="line">keystone = cors http_proxy_to_wsgi compute_req_id faultwrap request_log sizelimit osprofiler bees_profiler authtoken keystonecontext osapi_compute_app_v21</span><br><span class="line"># DEPRECATED: The [api]auth_strategy conf option is deprecated and will be</span><br><span class="line"># removed in a subsequent release, whereupon this pipeline will be unreachable.</span><br><span class="line">noauth2 = cors http_proxy_to_wsgi compute_req_id faultwrap request_log sizelimit osprofiler bees_profiler noauth2 osapi_compute_app_v21</span><br><span class="line"></span><br><span class="line">[app:osapi_compute_app_v21]</span><br><span class="line">paste.app_factory = nova.api.openstack.compute:APIRouterV21.factory  # 入口</span><br></pre></td></tr></table></figure><p>nova/api/openstack/compute/routes.py 中的 APIRouterV21 主要用来完成路由规则的创建，其中 ROUTE_LIST 保存了 URL 与 Controller 之间的映射关系。</p><p>APIRouterV21 基于 ROUTE_LIST，使用 Routes 模块作为 URL 映射的工具，将各个模块所实现的 API 对应的 URL 注册到 mapper 中，并把每个资源都封装成 nova.api.openstack.wsgi.Resource 对象，当解析 URL 请求时，可以通过 URL 映射找到 API 对应的 Resource 对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># Router 类对 WSGI routes 模块进行了简单的封装</span><br><span class="line">class APIRouterV21(base_wsgi.Router):</span><br><span class="line">    &quot;&quot;&quot;Routes requests on the OpenStack API to the appropriate controller</span><br><span class="line">    and method. The URL mapping based on the plain list `ROUTE_LIST` is built</span><br><span class="line">    at here.</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def __init__(self, custom_routes=None):</span><br><span class="line">        &quot;&quot;&quot;:param custom_routes: the additional routes can be added by this</span><br><span class="line">               parameter. This parameter is used to test on some fake routes</span><br><span class="line">               primarily.</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        super(APIRouterV21, self).__init__(nova.api.openstack.ProjectMapper())</span><br><span class="line"></span><br><span class="line">        if custom_routes is None:</span><br><span class="line">            custom_routes = tuple()</span><br><span class="line"></span><br><span class="line">        for path, methods in ROUTE_LIST + custom_routes:</span><br><span class="line">            # NOTE(alex_xu): The variable &#x27;methods&#x27; is a dict in normal, since</span><br><span class="line">            # the dict includes all the methods supported in the path. But</span><br><span class="line">            # if the variable &#x27;method&#x27; is a string, it means a redirection.</span><br><span class="line">            # For example, the request to the &#x27;&#x27; will be redirect to the &#x27;/&#x27; in</span><br><span class="line">            # the Nova API. To indicate that, using the target path instead of</span><br><span class="line">            # a dict. The route entry just writes as &quot;(&#x27;&#x27;, &#x27;/)&quot;.</span><br><span class="line">            if isinstance(methods, six.string_types):</span><br><span class="line">                self.map.redirect(path, methods)</span><br><span class="line">                continue</span><br><span class="line"></span><br><span class="line">            for method, controller_info in methods.items():</span><br><span class="line">                # TODO(alex_xu): In the end, I want to create single controller</span><br><span class="line">                # instance instead of create controller instance for each</span><br><span class="line">                # route.</span><br><span class="line">                controller = controller_info[0]()</span><br><span class="line">                action = controller_info[1]</span><br><span class="line">                self.map.create_route(path, method, controller, action)</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def factory(cls, global_config, **local_config):</span><br><span class="line">        &quot;&quot;&quot;Simple paste factory, :class:`nova.wsgi.Router` doesn&#x27;t have one.&quot;&quot;&quot;</span><br><span class="line">        return cls()</span><br></pre></td></tr></table></figure><p>nova/api/wsgi.py 解析 URL 映射，通过 _dispatch 回调，调用 Resource 对象的 _<em>call</em>_ 方法，最终通过请求调用 API 对应的模块中的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"># 路由</span><br><span class="line">class Router(object):</span><br><span class="line">    &quot;&quot;&quot;WSGI middleware that maps incoming requests to WSGI apps.&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, mapper):</span><br><span class="line">        &quot;&quot;&quot;Create a router for the given routes.Mapper.</span><br><span class="line"></span><br><span class="line">        Each route in `mapper` must specify a &#x27;controller&#x27;, which is a</span><br><span class="line">        WSGI app to call.  You&#x27;ll probably want to specify an &#x27;action&#x27; as</span><br><span class="line">        well and have your controller be an object that can route</span><br><span class="line">        the request to the action-specific method.</span><br><span class="line"></span><br><span class="line">        Examples:</span><br><span class="line">          mapper = routes.Mapper()</span><br><span class="line">          sc = ServerController()</span><br><span class="line"></span><br><span class="line">          # Explicit mapping of one route to a controller+action</span><br><span class="line">          mapper.connect(None, &#x27;/svrlist&#x27;, controller=sc, action=&#x27;list&#x27;)</span><br><span class="line"></span><br><span class="line">          # Actions are all implicitly defined</span><br><span class="line">          mapper.resource(&#x27;server&#x27;, &#x27;servers&#x27;, controller=sc)</span><br><span class="line"></span><br><span class="line">          # Pointing to an arbitrary WSGI app.  You can specify the</span><br><span class="line">          # &#123;path_info:.*&#125; parameter so the target app can be handed just that</span><br><span class="line">          # section of the URL.</span><br><span class="line">          mapper.connect(None, &#x27;/v1.0/&#123;path_info:.*&#125;&#x27;, controller=BlogApp())</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.map = mapper</span><br><span class="line">        # 使用 routes 模块关联 mapper 和 _dispatch</span><br><span class="line">        # routes.middleware.RoutesMiddleware 设置 environ 信息</span><br><span class="line">        self._router = routes.middleware.RoutesMiddleware(self._dispatch,</span><br><span class="line">                                                          self.map)</span><br><span class="line"></span><br><span class="line">    @webob.dec.wsgify(RequestClass=Request)</span><br><span class="line">    def __call__(self, req):</span><br><span class="line">        &quot;&quot;&quot;Route the incoming request to a controller based on self.map.</span><br><span class="line"></span><br><span class="line">        If no match, return a 404.</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 根据 mapper 将请求路由到 WSGI 应用（资源）</span><br><span class="line">        # 每个资源会在 __call__ 方法中根据 HTTP 请求的 URL 路由到对应 Controller 上的方法（Action）</span><br><span class="line">        return self._router</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    @webob.dec.wsgify(RequestClass=Request)</span><br><span class="line">    def _dispatch(req):</span><br><span class="line">        &quot;&quot;&quot;Dispatch the request to the appropriate controller.</span><br><span class="line"></span><br><span class="line">        Called by self._router after matching the incoming request to a route</span><br><span class="line">        and putting the information into req.environ.  Either returns 404</span><br><span class="line">        or the routed WSGI app&#x27;s response.</span><br><span class="line"></span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # 根据 HTTP 请求的 environ 信息找到 URL 对应的 Controller</span><br><span class="line">        match = req.environ[&#x27;wsgiorg.routing_args&#x27;][1]</span><br><span class="line">        if not match:</span><br><span class="line">            return webob.exc.HTTPNotFound()</span><br><span class="line">        app = match[&#x27;controller&#x27;]</span><br><span class="line">        return app</span><br></pre></td></tr></table></figure><h3 id="API-实现"><a href="#API-实现" class="headerlink" title="API 实现"></a><a href="about:blank#API-%E5%AE%9E%E7%8E%B0" title="API 实现"></a>API 实现</h3><p>nova/api/openstack/compute/ 目录包含每个 API 对应的 Controller 实现，Resource 对象将请求的 API 映射到相应的 Controller 方法上。</p><p>以 keypairs.py （密钥对管理扩展）为例，公共方法包含 create、delete、show、index，多个实现对应不同的 Microversion（使用 <code>@wsgi.Controller.api_version</code> 装饰器）</p><ul><li>  <code>@wsgi.expected_errors</code>：API 允许的错误返回码</li><li>  <code>@validation.query_schema</code>：请求对应的 json schema</li><li>  <code>@wsgi.response</code>：API 请求正常返回码</li><li>  <code>@wsgi.action</code>：注册 action</li></ul><p>Microversion 用于实现兼容性。</p><p>nova/api/openstack/compute/schemas 包含允许的 json schema，表示接受的键值对及其类型。</p><p>通过方法接口可以得到 webob.Request 对象，从 Request 对象中可以获取其他请求参数，用于执行对应的操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class KeypairController(wsgi.Controller):</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;Keypair API controller for the OpenStack API.&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    _view_builder_class = keypairs_view.ViewBuilder</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        super(KeypairController, self).__init__()</span><br><span class="line">        self.api = compute_api.KeypairAPI()</span><br><span class="line"></span><br><span class="line">    @wsgi.Controller.api_version(&quot;2.10&quot;)</span><br><span class="line">    @wsgi.response(201)</span><br><span class="line">    @wsgi.expected_errors((400, 403, 409))</span><br><span class="line">    @validation.schema(keypairs.create_v210)</span><br><span class="line">    def create(self, req, body):</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">    @wsgi.Controller.api_version(&quot;2.2&quot;, &quot;2.9&quot;)  # noqa</span><br><span class="line">    @wsgi.response(201)</span><br><span class="line">    @wsgi.expected_errors((400, 403, 409))</span><br><span class="line">    @validation.schema(keypairs.create_v22)</span><br><span class="line">    def create(self, req, body):  # noqa</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><h2 id="nova-conductor"><a href="#nova-conductor" class="headerlink" title="nova-conductor"></a><a href="about:blank#nova-conductor" title="nova-conductor"></a>nova-conductor</h2><p>使用 RPC 的子组件通常包含以下文件：</p><ul><li>  api.py 对 RPC 接口进行封装，类似提供 SDK</li><li>  rpcapi.py 暴露给其他内部组件的 RPC 接口，RPC 客户端</li><li>  manager.py 处理 RPC API 调用</li></ul><p>nova-compute 访问数据库的操作都要由 nova-conductor 代理，用 nova/conductor/manager.py 的 ConductorManager 类完成，出于安全性考虑，nova-conductor 和 nova-compute 不能部署在同一服务器上。</p><p>nova/objects 定义了 nova object，封装数据库 CURD 操作，每个类对应数据库中的一张表。</p><h2 id="nova-scheduler"><a href="#nova-scheduler" class="headerlink" title="nova-scheduler"></a><a href="about:blank#nova-scheduler" title="nova-scheduler"></a>nova-scheduler</h2><p>nova-scheduler 执行调度决策，nova-compute 收集并更新主机数据，实时写入数据库（周期任务）。</p><p>nova/scheduler/filters 包含所有的过滤器实现，用于过滤不符合条件的主机；nova/scheduler/weights 包含所有的权重实现，用于计算权重并排序。</p><h1 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a><a href="about:blank#%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B" title="启动流程"></a>启动流程</h1><p><strong>nova-api</strong> 启动入口 <code>nova.cmd.api:main</code></p><ul><li>  <a href="https://docs.openstack.org/nova/queens/reference/gmr.html">Guru Meditation Reports</a></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">def main():</span><br><span class="line">    config.parse_args(sys.argv) # 解析参数</span><br><span class="line">    logging.setup(CONF, &quot;nova&quot;) # 设置日志</span><br><span class="line">    objects.register_all()      # 注册 nova object</span><br><span class="line">    gmr_opts.set_defaults(CONF) # 设置 oslo_reports</span><br><span class="line">    if &#x27;osapi_compute&#x27; in CONF.enabled_apis:</span><br><span class="line">        # NOTE(mriedem): This is needed for caching the nova-compute service</span><br><span class="line">        # version.</span><br><span class="line">        objects.Service.enable_min_version_cache()</span><br><span class="line">    log = logging.getLogger(__name__)</span><br><span class="line"></span><br><span class="line">    # 生成报告的机制 Guru Meditation Report (GMR)</span><br><span class="line">    gmr.TextGuruMeditation.setup_autorun(version, conf=CONF)</span><br><span class="line"></span><br><span class="line">    # oslo_service.ProcessLauncher</span><br><span class="line">    launcher = service.process_launcher()</span><br><span class="line">    started = 0</span><br><span class="line">    # 根据 paste-ini 文件创建 WSGI 应用</span><br><span class="line">    for api in CONF.enabled_apis:</span><br><span class="line">        should_use_ssl = api in CONF.enabled_ssl_apis</span><br><span class="line">        try:</span><br><span class="line">            # nova.service.WSGIService 初始化 WSGI 程序</span><br><span class="line">            server = service.WSGIService(api, use_ssl=should_use_ssl)</span><br><span class="line">            # oslo_service.ProcessLauncher 创建子进程启动服务</span><br><span class="line">            launcher.launch_service(server, workers=server.workers or 1)</span><br><span class="line">            started += 1</span><br><span class="line">        except exception.PasteAppNotFound as ex:</span><br><span class="line">            log.warning(&quot;%s. ``enabled_apis`` includes bad values. &quot;</span><br><span class="line">                        &quot;Fix to remove this warning.&quot;, ex)</span><br><span class="line"></span><br><span class="line">    if started == 0:</span><br><span class="line">        log.error(&#x27;No APIs were started. &#x27;</span><br><span class="line">                  &#x27;Check the enabled_apis config option.&#x27;)</span><br><span class="line">        sys.exit(1)</span><br><span class="line"></span><br><span class="line">    # 等待子进程终止</span><br><span class="line">    launcher.wait()</span><br></pre></td></tr></table></figure><p>nova.service.WSGIService 的初始化函数实例化 nova.wsgi.Server ，启动函数实际调用了 nova.wsgi.Server 的 start 方法。</p><p>其中的 self._socket 使用 <code>eventlet.listen</code> 创建，最后使用 utils 中封装的 spawn 函数启动 WSGI 程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Server(service.ServiceBase):</span><br><span class="line">    &quot;&quot;&quot;Server class to manage a WSGI server, serving a WSGI application.&quot;&quot;&quot;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    def start(self):</span><br><span class="line">        &quot;&quot;&quot;Start serving a WSGI application.</span><br><span class="line"></span><br><span class="line">        :returns: None</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        # The server socket object will be closed after server exits,</span><br><span class="line">        # but the underlying file descriptor will remain open, and will</span><br><span class="line">        # give bad file descriptor error. So duplicating the socket object,</span><br><span class="line">        # to keep file descriptor usable.</span><br><span class="line"></span><br><span class="line">        dup_socket = self._socket.dup()</span><br><span class="line">        dup_socket.setsockopt(socket.SOL_SOCKET,</span><br><span class="line">                              socket.SO_REUSEADDR, 1)</span><br><span class="line">        # sockets can hang around forever without keepalive</span><br><span class="line">        dup_socket.setsockopt(socket.SOL_SOCKET,</span><br><span class="line">                              socket.SO_KEEPALIVE, 1)</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        self._server = utils.spawn(**wsgi_kwargs)</span><br></pre></td></tr></table></figure><p><strong>nova-conductor</strong> 启动入口 <code>nova.cmd.conductor:main</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">def main():</span><br><span class="line">    config.parse_args(sys.argv)</span><br><span class="line">    logging.setup(CONF, &quot;nova&quot;)</span><br><span class="line">    objects.register_all()</span><br><span class="line">    gmr_opts.set_defaults(CONF)</span><br><span class="line">    objects.Service.enable_min_version_cache()</span><br><span class="line"></span><br><span class="line">    gmr.TextGuruMeditation.setup_autorun(version, conf=CONF)</span><br><span class="line"></span><br><span class="line">    # nova.service.Service 实例化 Service 对象</span><br><span class="line">    server = service.Service.create(binary=&#x27;nova-conductor&#x27;,</span><br><span class="line">                                    topic=rpcapi.RPC_TOPIC)</span><br><span class="line">    workers = CONF.conductor.workers or processutils.get_worker_count()</span><br><span class="line">    # oslo_service.launch 创建 launcher</span><br><span class="line">    service.serve(server, workers=workers)</span><br><span class="line">    # 调用 launcher.wait 等待子进程终止</span><br><span class="line">    service.wait()</span><br></pre></td></tr></table></figure><p>nova.service.Service 初始化函数接受 manager 对象，通过监听消息队列启用 RPC 服务；设置定期任务报告状态，并写入数据库。</p><ul><li>  nova-compute</li><li>  nova-conductor</li><li>  nova-scheduler</li></ul><p>RPC 服务启动时创建 rpc_client 用于发送消息，创建 rpc_server 用于接收消息，分派执行。</p><p><strong>1. rpc_client</strong></p><p>nova/cmd/conductor.py 实际创建 Service 实例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server = service.Service.create(binary=&#x27;nova-conductor&#x27;,</span><br><span class="line">                                topic=rpcapi.RPC_TOPIC)</span><br></pre></td></tr></table></figure><p>nova/service.py 初始化函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 创建 _driver</span><br><span class="line">self.servicegroup_api = servicegroup.API()</span><br><span class="line"></span><br><span class="line"># 动态导入 manager 类</span><br><span class="line">manager_class = importutils.import_class(self.manager_class_name)</span><br><span class="line"></span><br><span class="line">if objects_base.NovaObject.indirection_api:</span><br><span class="line">    # 创建 RPCClient</span><br><span class="line">    conductor_api = conductor.API()</span><br><span class="line">    # 等待 nova-conductor 启动</span><br><span class="line">    conductor_api.wait_until_ready(context.get_admin_context())</span><br></pre></td></tr></table></figure><p>nova/servicegroup/api.py 创建 _driver</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">driver_class = _driver_name_class_mapping[CONF.servicegroup_driver]</span><br><span class="line">self._driver = importutils.import_object(driver_class,</span><br><span class="line">                                         *args, **kwargs)</span><br></pre></td></tr></table></figure><p>nova/conductor/api.py 实际调用 rpcapi.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def __init__(self):</span><br><span class="line">    self.conductor_rpcapi = rpcapi.ConductorAPI()</span><br><span class="line">    self.base_rpcapi = baserpc.BaseAPI(topic=rpcapi.RPC_TOPIC)</span><br></pre></td></tr></table></figure><p>nova/conductor/rpcapi.py 设置 rpc_client</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def __init__(self):</span><br><span class="line">    super(ConductorAPI, self).__init__()</span><br><span class="line">    target = messaging.Target(topic=RPC_TOPIC, version=&#x27;3.0&#x27;)</span><br><span class="line">    version_cap = self.VERSION_ALIASES.get(CONF.upgrade_levels.conductor,</span><br><span class="line">                                           CONF.upgrade_levels.conductor)</span><br><span class="line">    serializer = objects_base.NovaObjectSerializer()</span><br><span class="line">    # rpc client</span><br><span class="line">    self.client = rpc.get_client(target,</span><br><span class="line">                                 version_cap=version_cap,</span><br><span class="line">                                 serializer=serializer)</span><br></pre></td></tr></table></figure><p>nova/baserpc.py 设置 rpc_client</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def __init__(self, topic):</span><br><span class="line">    super(BaseAPI, self).__init__()</span><br><span class="line">    target = messaging.Target(topic=topic,</span><br><span class="line">                              namespace=_NAMESPACE,</span><br><span class="line">                              version=&#x27;1.0&#x27;)</span><br><span class="line">    version_cap = self.VERSION_ALIASES.get(CONF.upgrade_levels.baseapi,</span><br><span class="line">                                           CONF.upgrade_levels.baseapi)</span><br><span class="line">    self.client = rpc.get_client(target, version_cap=version_cap)</span><br></pre></td></tr></table></figure><p><strong>2. rpc_server</strong></p><p>nova/cmd/conductor.py 使用 Service 实例启动服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># oslo_service.launch 创建 launcher</span><br><span class="line">service.serve(server, workers=workers)</span><br><span class="line"># 调用 launcher.wait 等待子进程终止</span><br><span class="line">service.wait()</span><br></pre></td></tr></table></figure><p>nova/service.py 实际调用 <a href="https://github.com/openstack/oslo.service">oslo_service</a> 的 launch 函数，创建绿色线程（greenthread）或进程，最终调用 Service 实例的 start 方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def serve(server, workers=None):</span><br><span class="line">    global _launcher</span><br><span class="line">    if _launcher:</span><br><span class="line">        raise RuntimeError(_(&#x27;serve() can only be called once&#x27;))</span><br><span class="line"></span><br><span class="line">    _launcher = service.launch(CONF, server, workers=workers,</span><br><span class="line">                               restart_method=&#x27;mutate&#x27;)</span><br></pre></td></tr></table></figure><p>nova/service.py Service 实例的 start 方法创建 rpc_server 和 dispatcher；设置周期任务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 创建 rpc server 以及 dispatcher</span><br><span class="line">self.rpcserver = rpc.get_server(target, endpoints, serializer)</span><br><span class="line">self.rpcserver.start()</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">if self.periodic_enable:</span><br><span class="line">    if self.periodic_fuzzy_delay:</span><br><span class="line">        initial_delay = random.randint(0, self.periodic_fuzzy_delay)</span><br><span class="line">    else:</span><br><span class="line">        initial_delay = None</span><br><span class="line"></span><br><span class="line">    self.tg.add_dynamic_timer(self.periodic_tasks,</span><br><span class="line">                             initial_delay=initial_delay,</span><br><span class="line">                             periodic_interval_max=</span><br><span class="line">                                self.periodic_interval_max)</span><br></pre></td></tr></table></figure><p>收到消息后主要由 <a href="https://github.com/openstack/oslo.messaging">oslo_messaging</a> 进行解析和处理，核心是 oslo_messaging/rpc/dispatcher.py</p><p>incoming 是 AMQP 消息格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">def dispatch(self, incoming):</span><br><span class="line">    &quot;&quot;&quot;Dispatch an RPC message to the appropriate endpoint method.</span><br><span class="line"></span><br><span class="line">    :param incoming: incoming message</span><br><span class="line">    :type incoming: IncomingMessage</span><br><span class="line">    :raises: NoSuchMethod, UnsupportedVersion</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    message = incoming.message</span><br><span class="line">    ctxt = incoming.ctxt</span><br><span class="line"></span><br><span class="line">    method = message.get(&#x27;method&#x27;)</span><br><span class="line">    args = message.get(&#x27;args&#x27;, &#123;&#125;)</span><br><span class="line">    namespace = message.get(&#x27;namespace&#x27;)</span><br><span class="line">    version = message.get(&#x27;version&#x27;, &#x27;1.0&#x27;)</span><br><span class="line"></span><br><span class="line">    # NOTE(danms): This event and watchdog thread are used to send</span><br><span class="line">    # call-monitoring heartbeats for this message while the call</span><br><span class="line">    # is executing if it runs for some time. The thread will wait</span><br><span class="line">    # for the event to be signaled, which we do explicitly below</span><br><span class="line">    # after dispatching the method call.</span><br><span class="line">    completion_event = eventletutils.Event()</span><br><span class="line">    watchdog_thread = threading.Thread(target=self._watchdog,</span><br><span class="line">                                       args=(completion_event, incoming))</span><br><span class="line">    if incoming.client_timeout:</span><br><span class="line">        # NOTE(danms): The client provided a timeout, so we start</span><br><span class="line">        # the watchdog thread. If the client is old or didn&#x27;t send</span><br><span class="line">        # a timeout, we just never start the watchdog thread.</span><br><span class="line">        watchdog_thread.start()</span><br><span class="line"></span><br><span class="line">    found_compatible = False</span><br><span class="line">    for endpoint in self.endpoints:</span><br><span class="line">        target = getattr(endpoint, &#x27;target&#x27;, None)</span><br><span class="line">        if not target:</span><br><span class="line">            target = self._default_target</span><br><span class="line"></span><br><span class="line">        if not (self._is_namespace(target, namespace) and</span><br><span class="line">                self._is_compatible(target, version)):</span><br><span class="line">            continue</span><br><span class="line"></span><br><span class="line">        if hasattr(endpoint, method):</span><br><span class="line">            if self.access_policy.is_allowed(endpoint, method):</span><br><span class="line">                try:</span><br><span class="line">                    # 分派，调用函数</span><br><span class="line">                    return self._do_dispatch(endpoint, method, ctxt, args)</span><br><span class="line">                finally:</span><br><span class="line">                    completion_event.set()</span><br><span class="line">                    if incoming.client_timeout:</span><br><span class="line">                        watchdog_thread.join()</span><br><span class="line"></span><br><span class="line">        found_compatible = True</span><br><span class="line"></span><br><span class="line">    if found_compatible:</span><br><span class="line">        raise NoSuchMethod(method)</span><br><span class="line">    else:</span><br><span class="line">        raise UnsupportedVersion(version, method=method)</span><br></pre></td></tr></table></figure><p>oslo_messaging/rpc/dispatcher.py 调用函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def _do_dispatch(self, endpoint, method, ctxt, args):</span><br><span class="line">    ctxt = self.serializer.deserialize_context(ctxt)</span><br><span class="line">    new_args = dict()</span><br><span class="line">    for argname, arg in args.items():</span><br><span class="line">        new_args[argname] = self.serializer.deserialize_entity(ctxt, arg)</span><br><span class="line">    func = getattr(endpoint, method)</span><br><span class="line">    result = func(ctxt, **new_args)</span><br><span class="line">    return self.serializer.serialize_entity(ctxt, result)</span><br></pre></td></tr></table></figure><p>发送消息的实现都在 nova/conductor/rpcapi.py 中，cctxt.call 同步调用，cctxt.cast 异步调用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">def object_class_action_versions(self, context, objname, objmethod,</span><br><span class="line">                                 object_versions, args, kwargs):</span><br><span class="line">    cctxt = self.client.prepare()</span><br><span class="line">    return cctxt.call(context, &#x27;object_class_action_versions&#x27;,</span><br><span class="line">                      objname=objname, objmethod=objmethod,</span><br><span class="line">                      object_versions=object_versions,</span><br><span class="line">                      args=args, kwargs=kwargs)</span><br><span class="line"></span><br><span class="line">def cache_images(self, ctxt, aggregate, image_ids):</span><br><span class="line">    version = &#x27;1.21&#x27;</span><br><span class="line">    if not self.client.can_send_version(version):</span><br><span class="line">        raise exception.NovaException(&#x27;Conductor RPC version pin does not &#x27;</span><br><span class="line">                                      &#x27;allow cache_images() to be called&#x27;)</span><br><span class="line">    cctxt = self.client.prepare(version=version)</span><br><span class="line">    cctxt.cast(ctxt, &#x27;cache_images&#x27;, aggregate=aggregate,</span><br><span class="line">               image_ids=image_ids)</span><br></pre></td></tr></table></figure><p>由 oslo_messaging/rpc/client.py 实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">def cast(self, ctxt, method, **kwargs):</span><br><span class="line">    &quot;&quot;&quot;Invoke a method and return immediately. See RPCClient.cast().&quot;&quot;&quot;</span><br><span class="line">    msg = self._make_message(ctxt, method, kwargs)</span><br><span class="line">    msg_ctxt = self.serializer.serialize_context(ctxt)</span><br><span class="line"></span><br><span class="line">    self._check_version_cap(msg.get(&#x27;version&#x27;))</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        self.transport._send(self.target, msg_ctxt, msg,</span><br><span class="line">                             retry=self.retry,</span><br><span class="line">                             transport_options=self.transport_options)</span><br><span class="line">    except driver_base.TransportDriverError as ex:</span><br><span class="line">        raise ClientSendError(self.target, ex)</span><br><span class="line"></span><br><span class="line">def call(self, ctxt, method, **kwargs):</span><br><span class="line">    &quot;&quot;&quot;Invoke a method and wait for a reply. See RPCClient.call().&quot;&quot;&quot;</span><br><span class="line">    if self.target.fanout:</span><br><span class="line">        raise exceptions.InvalidTarget(&#x27;A call cannot be used with fanout&#x27;,</span><br><span class="line">                                       self.target)</span><br><span class="line"></span><br><span class="line">    msg = self._make_message(ctxt, method, kwargs)</span><br><span class="line">    msg_ctxt = self.serializer.serialize_context(ctxt)</span><br><span class="line"></span><br><span class="line">    timeout = self.timeout</span><br><span class="line">    if self.timeout is None:</span><br><span class="line">        timeout = self.conf.rpc_response_timeout</span><br><span class="line"></span><br><span class="line">    cm_timeout = self.call_monitor_timeout</span><br><span class="line"></span><br><span class="line">    self._check_version_cap(msg.get(&#x27;version&#x27;))</span><br><span class="line"></span><br><span class="line">    try:</span><br><span class="line">        result = \</span><br><span class="line">            self.transport._send(self.target, msg_ctxt, msg,</span><br><span class="line">                                 wait_for_reply=True, timeout=timeout,</span><br><span class="line">                                 call_monitor_timeout=cm_timeout,</span><br><span class="line">                                 retry=self.retry,</span><br><span class="line">                                 transport_options=self.transport_options)</span><br><span class="line">    except driver_base.TransportDriverError as ex:</span><br><span class="line">        raise ClientSendError(self.target, ex)</span><br><span class="line"></span><br><span class="line">    return self.serializer.deserialize_entity(ctxt, result)</span><br></pre></td></tr></table></figure><p>关于周期任务，nova/scheduler/manager.py 中使用 <code>@periodic_task.periodic_task</code> 装饰的方法将会被周期调用，从 scheduler 的调试日志可以看到周期任务的运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">********************************************************************* log_opt_values /home/jck/.local/lib/python3.6/site-packages/oslo_config/cfg.py:2591</span><br><span class="line">2021-05-18 05:53:17.030 3501 DEBUG oslo_service.periodic_task [req-66b43add-49c7-4f33-8f6b-1e33cb9f0123 - - - - -] Running periodic task SchedulerManager._run_periodic_tasks run_periodic_tasks /home/jck/.local/lib/python3.6/site-packages/oslo_service/periodic_task.py:211</span><br><span class="line">2021-05-18 05:53:39.072 3500 DEBUG oslo_service.periodic_task [req-8436b3e2-96d1-4f15-8ae8-b596cee05536 - - - - -] Running periodic task SchedulerManager._run_periodic_tasks run_periodic_tasks /home/jck/.local/lib/python3.6/site-packages/oslo_service/periodic_task.py:211</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>对应于 nova/scheduler/manager.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@periodic_task.periodic_task(spacing=CONF.scheduler.periodic_task_interval,</span><br><span class="line">                             run_immediately=True)</span><br><span class="line">def _run_periodic_tasks(self, context):</span><br><span class="line">    self.driver.run_periodic_tasks(context)</span><br></pre></td></tr></table></figure><p>执行周期任务的有 nova-scheduler 和 nova-compute ，主要功能是计算节点 nova-compute 上报资源信息，nova-scheduler 读取数据库，更新资源信息缓存。</p><h1 id="参阅"><a href="#参阅" class="headerlink" title="参阅"></a><a href="about:blank#%E5%8F%82%E9%98%85" title="参阅"></a>参阅</h1><ul><li>  <a href="https://docs.openstack.org/nova/latest/user/architecture.html">Nova System Architecture</a></li><li>  <a href="https://docs.openstack.org/nova/latest/install/get-started-compute.html">Compute service overview</a></li><li>  <a href="https://docs.openstack.org/nova/latest/reference/rpc.html">AMQP and Nova</a></li><li>  <a href="https://docs.openstack.org/nova/latest/reference/scheduling.html">Scheduling</a></li><li>  <a href="https://docs.openstack.org/nova/latest/user/cellsv2-layout.html">Cells Layout (v2)</a></li><li>  <a href="https://www.rabbitmq.com/tutorials/amqp-concepts.html">AMQP 0-9-1 Model Explained</a></li><li>  <a href="https://rabbitmq.mr-ping.com/AMQP/AMQP_0-9-1_Model_Explained.html">AMQP 0-9-1 简介</a></li><li>  <a href="https://docs.openstack.org/nova/latest/admin/metadata-service.html">Metadata service</a></li><li>  <a href="https://docs.openstack.org/nova/queens/reference/gmr.html">Guru Meditation Reports</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;整体架构&quot;&gt;&lt;a href=&quot;#整体架构&quot; class=&quot;headerlink&quot; title=&quot;整体架构&quot;&gt;&lt;/a&gt;&lt;a href=&quot;about:blank#%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84&quot; title=&quot;整体架构&quot;&gt;&lt;/a&gt;整体架构&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;  nova 和其他组件之间的交互使用 HTTP 请求&lt;/li&gt;
&lt;li&gt;  内部组件之间使用 &lt;a href=&quot;https://github.com/openstack/oslo.messaging&quot;&gt;oslo_messaging&lt;/a&gt; 库实现 RPC 调用，这里还涉及消息队列 RabbitMQ ，遵循 AMQP 协议&lt;/li&gt;
&lt;li&gt;  大部分 nova 组件都可以运行在多个服务器上，然后使用一个管理器监听 RPC 消息&lt;/li&gt;
&lt;li&gt;  而 nova-compute 是运行在计算主机上的单进程，用于管理计算资源&lt;/li&gt;
&lt;li&gt;nova 内部组件共享本地数据库，通过对象层访问，确保兼容性和安全性&lt;ul&gt;
&lt;li&gt;  nova-compute 访问数据库由 nova-conductor 代理&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="openstack" scheme="https://rma-shuyu.github.io/categories/openstack/"/>
    
    
    <category term="nova" scheme="https://rma-shuyu.github.io/tags/nova/"/>
    
  </entry>
  
  <entry>
    <title>Docker run 命令参数</title>
    <link href="https://rma-shuyu.github.io/2022/06/24/Docker-run-%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0/"/>
    <id>https://rma-shuyu.github.io/2022/06/24/Docker-run-%E5%91%BD%E4%BB%A4%E5%8F%82%E6%95%B0/</id>
    <published>2022-06-24T12:25:15.000Z</published>
    <updated>2023-09-09T10:33:02.402Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker-run-命令参数及使用"><a href="#Docker-run-命令参数及使用" class="headerlink" title="Docker run 命令参数及使用"></a>Docker run 命令参数及使用</h2><h3 id="Docker-run-：创建一个新的容器并运行一个命令"><a href="#Docker-run-：创建一个新的容器并运行一个命令" class="headerlink" title="Docker run ：创建一个新的容器并运行一个命令"></a>Docker run ：创建一个新的容器并运行一个命令</h3><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run [OPTIONS] IMAGE [COMMAND] [ARG...]  </span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="OPTIONS说明："><a href="#OPTIONS说明：" class="headerlink" title="OPTIONS说明："></a>OPTIONS说明：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# docker run --help  </span><br><span class="line">  </span><br><span class="line">Usage:  docker run [OPTIONS] IMAGE [COMMAND] [ARG...]  </span><br><span class="line">  </span><br><span class="line">Run a command in a new container  </span><br><span class="line">  </span><br><span class="line">  -a, --attach=[]                 Attach to STDIN, STDOUT or STDERR  </span><br><span class="line">  --add-host=[]                   Add a custom host-to-IP mapping (host:ip)  </span><br><span class="line">  --blkio-weight=0                Block IO (relative weight), between 10 and 1000  </span><br><span class="line">  --cpu-shares=0                  CPU shares (relative weight)  </span><br><span class="line">  --cap-add=[]                    Add Linux capabilities  </span><br><span class="line">  --cap-drop=[]                   Drop Linux capabilities  </span><br><span class="line">  --cgroup-parent=                Optional parent cgroup for the container  </span><br><span class="line">  --cidfile=                      Write the container ID to the file  </span><br><span class="line">  --cpu-period=0                  Limit CPU CFS (Completely Fair Scheduler) period  </span><br><span class="line">  --cpu-quota=0                   Limit CPU CFS (Completely Fair Scheduler) quota  </span><br><span class="line">  --cpuset-cpus=                  CPUs in which to allow execution (0-3, 0,1)  </span><br><span class="line">  --cpuset-mems=                  MEMs in which to allow execution (0-3, 0,1)  </span><br><span class="line">  -d, --detach=false            Run container in background and print container ID(后台运行)  </span><br><span class="line">  --device=[]                     Add a host device to the container  </span><br><span class="line">  --disable-content-trust=true    Skip image verification  </span><br><span class="line">  --dns=[]                        Set custom DNS servers  </span><br><span class="line">  --dns-opt=[]                    Set DNS options  </span><br><span class="line">  --dns-search=[]                 Set custom DNS search domains  </span><br><span class="line">  -e, --env=[]                    Set environment variables(设置环境变量)  </span><br><span class="line">  --entrypoint=                   Overwrite the default ENTRYPOINT of the image  </span><br><span class="line">  --env-file=[]                   Read in a file of environment variables  </span><br><span class="line">  --expose=[]                     Expose a port or a range of ports  </span><br><span class="line">  --group-add=[]                  Add additional groups to join  </span><br><span class="line">  -h, --hostname=                 Container host name  </span><br><span class="line">  --help=false                    Print usage  </span><br><span class="line"> -i, --interactive=false         Keep STDIN open even if not attached(保持容器运行)  </span><br><span class="line">  --ipc=                          IPC namespace to use  </span><br><span class="line">  --kernel-memory=                Kernel memory limit  </span><br><span class="line">  -l, --label=[]                  Set meta data on a container  </span><br><span class="line">  --label-file=[]                 Read in a line delimited file of labels  </span><br><span class="line"> --link=[]                       Add link to another container(容器之间的通讯)  </span><br><span class="line">  --log-driver=                   Logging driver for container  </span><br><span class="line">  --log-opt=[]                    Log driver options  </span><br><span class="line">  --lxc-conf=[]                   Add custom lxc options  </span><br><span class="line">  -m, --memory=                   Memory limit  </span><br><span class="line">  --mac-address=                  Container MAC address (e.g. 92:d0:c6:0a:29:33)  </span><br><span class="line">  --memory-reservation=           Memory soft limit  </span><br><span class="line">  --memory-swap=                  Total memory (memory + swap), &#x27;-1&#x27; to disable swap  </span><br><span class="line">  --memory-swappiness=-1          Tuning container memory swappiness (0 to 100)  </span><br><span class="line"> --name=                         Assign a name to the container(指定容器名称)  </span><br><span class="line">  --net=default                   Set the Network for the container  </span><br><span class="line">  --oom-kill-disable=false        Disable OOM Killer  </span><br><span class="line">  -P, --publish-all=false         Publish all exposed ports to random ports  </span><br><span class="line"> -p, --publish=[]                Publish a container&#x27;s port(s) to the host(端口映射 80:8080)  </span><br><span class="line">  --pid=                          PID namespace to use  </span><br><span class="line">  --privileged=false              Give extended privileges to this container  </span><br><span class="line">  --read-only=false               Mount the container&#x27;s root filesystem as read only  </span><br><span class="line">  --restart=no                    Restart policy to apply when a container exits  </span><br><span class="line">  --rm=false                      Automatically remove the container when it exits  </span><br><span class="line">  --security-opt=[]               Security Options  </span><br><span class="line">  --shm-size=                     Size of /dev/shm, default value is 64MB  </span><br><span class="line">  --sig-proxy=true                Proxy received signals to the process  </span><br><span class="line">  --stop-signal=SIGTERM           Signal to stop a container, SIGTERM by default  </span><br><span class="line">  -t, --tty=false                 Allocate a pseudo-TTY  </span><br><span class="line">  -u, --user=                     Username or UID (format: &lt;name|uid&gt;[:&lt;group|gid&gt;])  </span><br><span class="line">  --ulimit=[]                     Ulimit options  </span><br><span class="line">  --uts=                          UTS namespace to use  </span><br><span class="line"> -v, --volume=[]                 Bind mount a volume(挂载目录 /root:/opt/temp)  </span><br><span class="line">  --volume-driver=                Optional volume driver for the container  </span><br><span class="line">  --volumes-from=[]               Mount volumes from the specified container(s)  </span><br><span class="line">  -w, --workdir=                  Working directory inside the container  </span><br></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h5 id="使用docker镜像nginx-latest以后台模式启动一个容器-并将容器命名为mynginx。"><a href="#使用docker镜像nginx-latest以后台模式启动一个容器-并将容器命名为mynginx。" class="headerlink" title="使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx。"></a>使用docker镜像nginx:latest以后台模式启动一个容器,并将容器命名为mynginx。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mynginx -d nginx:latest  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="使用镜像nginx-latest以后台模式启动一个容器-并将容器的80端口映射到主机随机端口。"><a href="#使用镜像nginx-latest以后台模式启动一个容器-并将容器的80端口映射到主机随机端口。" class="headerlink" title="使用镜像nginx:latest以后台模式启动一个容器,并将容器的80端口映射到主机随机端口。"></a>使用镜像nginx:latest以后台模式启动一个容器,并将容器的80端口映射到主机随机端口。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -P -d nginx:latest  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="使用镜像nginx-latest以后台模式启动一个容器-将容器的80端口映射到主机的80端口-主机的目录-data映射到容器的-data。"><a href="#使用镜像nginx-latest以后台模式启动一个容器-将容器的80端口映射到主机的80端口-主机的目录-data映射到容器的-data。" class="headerlink" title="使用镜像nginx:latest以后台模式启动一个容器,将容器的80端口映射到主机的80端口,主机的目录/data映射到容器的/data。"></a>使用镜像nginx:latest以后台模式启动一个容器,将容器的80端口映射到主机的80端口,主机的目录/data映射到容器的/data。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 80:80 -v /data:/data -d nginx:latest  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="使用镜像nginx-latest以交互模式启动一个容器-在容器内执行-bin-bash命令。"><a href="#使用镜像nginx-latest以交互模式启动一个容器-在容器内执行-bin-bash命令。" class="headerlink" title="使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。"></a>使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">runoob@runoob:~$ docker run -it nginx:latest /bin/bash  </span><br><span class="line">root@b8573233d675:/#   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Usage: docker run [OPTIONS] IMAGE [COMMAND] [ARG...]    </span><br><span class="line">  </span><br><span class="line">  -d, --detach=false         指定容器运行于前台还是后台，默认为false     </span><br><span class="line">  -i, --interactive=false   打开STDIN，用于控制台交互    </span><br><span class="line">  -t, --tty=false            分配tty设备，该可以支持终端登录，默认为false    </span><br><span class="line">  -u, --user=&quot;&quot;              指定容器的用户    </span><br><span class="line">  -a, --attach=[]            登录容器（必须是以docker run -d启动的容器）  </span><br><span class="line">  -w, --workdir=&quot;&quot;           指定容器的工作目录   </span><br><span class="line">  -c, --cpu-shares=0        设置容器CPU权重，在CPU共享场景使用    </span><br><span class="line">  -e, --env=[]               指定环境变量，容器中可以使用该环境变量    </span><br><span class="line">  -m, --memory=&quot;&quot;            指定容器的内存上限    </span><br><span class="line">  -P, --publish-all=false    指定容器暴露的端口    </span><br><span class="line">  -p, --publish=[]           指定容器暴露的端口   </span><br><span class="line">  -h, --hostname=&quot;&quot;          指定容器的主机名    </span><br><span class="line">  -v, --volume=[]            给容器挂载存储卷，挂载到容器的某个目录    </span><br><span class="line">  --volumes-from=[]          给容器挂载其他容器上的卷，挂载到容器的某个目录  </span><br><span class="line">  --cap-add=[]               添加权限，权限清单详见：http://linux.die.net/man/7/capabilities    </span><br><span class="line">  --cap-drop=[]              删除权限，权限清单详见：http://linux.die.net/man/7/capabilities    </span><br><span class="line">  --cidfile=&quot;&quot;               运行容器后，在指定文件中写入容器PID值，一种典型的监控系统用法    </span><br><span class="line">  --cpuset=&quot;&quot;                设置容器可以使用哪些CPU，此参数可以用来容器独占CPU    </span><br><span class="line">  --device=[]                添加主机设备给容器，相当于设备直通    </span><br><span class="line">  --dns=[]                   指定容器的dns服务器    </span><br><span class="line">  --dns-search=[]            指定容器的dns搜索域名，写入到容器的/etc/resolv.conf文件    </span><br><span class="line">  --entrypoint=&quot;&quot;            覆盖image的入口点    </span><br><span class="line">  --env-file=[]              指定环境变量文件，文件格式为每行一个环境变量    </span><br><span class="line">  --expose=[]                指定容器暴露的端口，即修改镜像的暴露端口    </span><br><span class="line">  --link=[]                  指定容器间的关联，使用其他容器的IP、env等信息    </span><br><span class="line">  --lxc-conf=[]              指定容器的配置文件，只有在指定--exec-driver=lxc时使用    </span><br><span class="line">  --name=&quot;&quot;                  指定容器名字，后续可以通过名字进行容器管理，links特性需要使用名字    </span><br><span class="line">  --net=&quot;bridge&quot;             容器网络设置:  </span><br><span class="line">                                bridge 使用docker daemon指定的网桥       </span><br><span class="line">                                host    //容器使用主机的网络    </span><br><span class="line">                                container:NAME_or_ID  &gt;//使用其他容器的网路，共享IP和PORT等网络资源    </span><br><span class="line">                                none 容器使用自己的网络（类似--net=bridge），但是不进行配置   </span><br><span class="line">  --privileged=false         指定容器是否为特权容器，特权容器拥有所有的capabilities    </span><br><span class="line">  --restart=&quot;no&quot;             指定容器停止后的重启策略:  </span><br><span class="line">                                no：容器退出时不重启    </span><br><span class="line">                                on-failure：容器故障退出（返回值非零）时重启   </span><br><span class="line">                                always：容器退出时总是重启    </span><br><span class="line">  --rm=false                 指定容器停止后自动删除容器(不支持以docker run -d启动的容器)    </span><br><span class="line">  --sig-proxy=true           设置由代理接受并处理信号，但是SIGCHLD、SIGSTOP和SIGKILL不能被代理    </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Docker-run-命令参数及使用&quot;&gt;&lt;a href=&quot;#Docker-run-命令参数及使用&quot; class=&quot;headerlink&quot; title=&quot;Docker run 命令参数及使用&quot;&gt;&lt;/a&gt;Docker run 命令参数及使用&lt;/h2&gt;&lt;h3 id=&quot;Docker-run-：创建一个新的容器并运行一个命令&quot;&gt;&lt;a href=&quot;#Docker-run-：创建一个新的容器并运行一个命令&quot; class=&quot;headerlink&quot; title=&quot;Docker run ：创建一个新的容器并运行一个命令&quot;&gt;&lt;/a&gt;Docker run ：创建一个新的容器并运行一个命令&lt;/h3&gt;&lt;h2 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker run [OPTIONS] IMAGE [COMMAND] [ARG...]  &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="DOCKER" scheme="https://rma-shuyu.github.io/categories/DOCKER/"/>
    
    
    <category term="docker" scheme="https://rma-shuyu.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker save&amp;&amp;load</title>
    <link href="https://rma-shuyu.github.io/2022/06/24/docker-save-load/"/>
    <id>https://rma-shuyu.github.io/2022/06/24/docker-save-load/</id>
    <published>2022-06-24T12:25:15.000Z</published>
    <updated>2023-09-09T10:33:02.407Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker将镜像导出到本地，上传至内网服务器上"><a href="#docker将镜像导出到本地，上传至内网服务器上" class="headerlink" title="docker将镜像导出到本地，上传至内网服务器上"></a>docker将镜像导出到本地，上传至内网服务器上</h2><p>背景：在企业中往往出现了内网不能和外网相通，不能使用docker pull命令来拉取镜像，这个时候我们就可以考虑在有所需镜像的服务器上导出镜像，再将其上传到内网服务器上。</p><span id="more"></span><p>有两种方法，一种是通过容器，一种是通过镜像，其实本质是一样的，容器的实质就是镜像</p><p>首先，需要提交现有容器<br>查看容器名，关闭容器，commit容器为新的镜像</p><p>docker commit 容器id或者容器名称 IMAGE的名称</p><p>root@compute:/home/rma# docker ps<br>CONTAINER ID   IMAGE        COMMAND        CREATED       STATUS       PORTS     NAMES<br>6684513da8ac   compute:v1   “/sbin/init”   2 years ago   Up 2 years             jmnd_compute<br>root@compute:/home/rma# docker stop jmnd_compute<br>jmnd_compute</p><p>root@compute:/home/rma# docker commit jmnd_compute compute:v2</p><h2 id="方法一：通过容器"><a href="#方法一：通过容器" class="headerlink" title="方法一：通过容器"></a>方法一：通过容器</h2><blockquote><p>docker save用于导出镜像到文件，包含镜像元数据和历史信息；<br>docker export用于将当前容器状态导出至文件，类似快照，所以不包含元数据及历史信息，体积更小，此外从容器快照导入时也可以重新指定标签和元数据信息；</p></blockquote><p>1 首先使用docker ps -a 查看本机上的所有容器</p><blockquote><p>docker ps -a</p></blockquote><p>2 导出镜像<br>使用docker export命令根据容器id将镜像导成一个文件</p><blockquote><p>docker export 容器id &gt; image.tar</p></blockquote><p>3 导入镜像<br>使用docker import命令将这个镜像导进来</p><blockquote><p>docker import 容器名 &lt; image.tar</p></blockquote><p>4 通过docker images 命令查看镜像是否导入</p><blockquote><p>docker images</p></blockquote><h2 id="方法二：通过镜像"><a href="#方法二：通过镜像" class="headerlink" title="方法二：通过镜像"></a>方法二：通过镜像</h2><p>1 通过docker image查看本机上的所有镜像</p><blockquote><p>docker images</p></blockquote><p>2 导出镜像<br>找到要上传的镜像的id,使用docker save命令将镜像保存为一个文件</p><blockquote><p>docker save 镜像id &gt; image.tar</p></blockquote><p>上面命令执行之后，我们便可以通过ls命令在当前目录下发现image.tar<br>3 导入镜像<br>docker save 可以将多个image打包成一个文件</p><blockquote><p>docker save -o image.tar 镜像1 镜像2</p></blockquote><p>4 通过docker load载入镜像</p><blockquote><p>docker load &lt; image.tar</p></blockquote><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><h3 id="文件大小不同"><a href="#文件大小不同" class="headerlink" title="文件大小不同"></a>文件大小不同</h3><blockquote><p>export 导出的镜像文件体积小于 save 保存的镜像</p></blockquote><h3 id="是否可以对镜像重命名"><a href="#是否可以对镜像重命名" class="headerlink" title="是否可以对镜像重命名"></a>是否可以对镜像重命名</h3><blockquote><p>docker import 可以为镜像指定新名称<br>docker load 不能对载入的镜像重命名</p></blockquote><h3 id="是否可以同时将多个镜像打包到一个文件中"><a href="#是否可以同时将多个镜像打包到一个文件中" class="headerlink" title="是否可以同时将多个镜像打包到一个文件中"></a>是否可以同时将多个镜像打包到一个文件中</h3><blockquote><p>docker export 不支持<br>docker save 支持</p></blockquote><h3 id="是否包含镜像历史"><a href="#是否包含镜像历史" class="headerlink" title="是否包含镜像历史"></a>是否包含镜像历史</h3><blockquote><p>export 导出（import 导入）是根据容器拿到的镜像，再导入时会丢失镜像所有的历史记录和元数据信息（即仅保存容器当时的快照状态），所以无法进行回滚操作。</p><p>而 save 保存（load 加载）的镜像，没有丢失镜像的历史，可以回滚到之前的层（layer）</p></blockquote><h3 id="应用场景不同"><a href="#应用场景不同" class="headerlink" title="应用场景不同"></a>应用场景不同</h3><blockquote><p>docker export 的应用场景：主要用来制作基础镜像，比如我们从一个 ubuntu 镜像启动一个容器，然后安装一些软件和进行一些设置后，使用 docker export 保存为一个基础镜像。然后，把这个镜像分发给其他人使用，比如作为基础的开发环境。</p><p>docker save 的应用场景：如果我们的应用是使用 docker-compose.yml 编排的多个镜像组合，但我们要部署的客户服务器并不能连外网。这时就可以使用 docker save 将用到的镜像打个包，然后拷贝到客户服务器上使用 docker load 载入。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;docker将镜像导出到本地，上传至内网服务器上&quot;&gt;&lt;a href=&quot;#docker将镜像导出到本地，上传至内网服务器上&quot; class=&quot;headerlink&quot; title=&quot;docker将镜像导出到本地，上传至内网服务器上&quot;&gt;&lt;/a&gt;docker将镜像导出到本地，上传至内网服务器上&lt;/h2&gt;&lt;p&gt;背景：在企业中往往出现了内网不能和外网相通，不能使用docker pull命令来拉取镜像，这个时候我们就可以考虑在有所需镜像的服务器上导出镜像，再将其上传到内网服务器上。&lt;/p&gt;</summary>
    
    
    
    <category term="DOCKER" scheme="https://rma-shuyu.github.io/categories/DOCKER/"/>
    
    
    <category term="docker" scheme="https://rma-shuyu.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Linux Kdump</title>
    <link href="https://rma-shuyu.github.io/2022/06/23/Linux-Kdump/"/>
    <id>https://rma-shuyu.github.io/2022/06/23/Linux-Kdump/</id>
    <published>2022-06-23T12:25:15.000Z</published>
    <updated>2023-09-09T10:33:02.404Z</updated>
    
    <content type="html"><![CDATA[<p>在ubuntu/debian系统下可以直接通过apt命令进行安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install linux-crashdump               </span><br></pre></td></tr></table></figure><span id="more"></span><p>详细的安装过程如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install linux-crashdump </span><br><span class="line">正在读取软件包列表... </span><br><span class="line">完成 正在分析软件包的依赖关系树        </span><br><span class="line">正在读取状态信息... 完成        </span><br><span class="line">下列软件包是自动安装的并且现在不需要了：  </span><br><span class="line"> linux-hwe-5.4-headers-5.4.0-47 linux-hwe-5.4-headers-5.4.0-52 </span><br><span class="line">使用&#x27;sudo apt autoremove&#x27;来卸载它(它们)。 </span><br><span class="line">将会同时安装下列软件：  </span><br><span class="line"> crash kdump-tools kexec-tools makedumpfile </span><br><span class="line">下列【新】软件包将被安装：   </span><br><span class="line">crash kdump-tools kexec-tools linux-crashdump makedumpfile </span><br><span class="line">升级了 0 个软件包，新安装了 5 个软件包，要卸载 0 个软件包，有 68 个软件包未被升级。 </span><br><span class="line">需要下载 3,050 kB 的归档。 </span><br><span class="line">解压缩后会消耗 9,700 kB 的额外空间。 </span><br><span class="line">您希望继续执行吗？ [Y/n]     =======&gt; Y</span><br></pre></td></tr></table></figure><p>弹出的字符界面框都选择是</p><p>如果不小心点到否，可以使用以下命令对配置进行重置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ dpkg-reconfigure kexec-tools </span><br><span class="line">$ dpkg-reconfigure kdump-tools               </span><br></pre></td></tr></table></figure><p>或者手动编译下面的文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">修改/etc/default/kexec文件：</span><br><span class="line"># Load a kexec kernel (true/false) </span><br><span class="line">LOAD_KEXEC=true               </span><br><span class="line">修改/etc/default/kdump-tools文件：</span><br><span class="line">USE_KDUMP=1               </span><br></pre></td></tr></table></figure><p>安装完重启后，通过kdump-config show可以看到以下信息，说明配置有问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ kdump-config show</span><br><span class="line">DUMP_MODE:        kdump</span><br><span class="line">USE_KDUMP:        1</span><br><span class="line">KDUMP_SYSCTL:     kernel.panic_on_oops=1</span><br><span class="line">KDUMP_COREDIR:    /var/crash</span><br><span class="line">crashkernel addr: 0x</span><br><span class="line">   /var/lib/kdump/vmlinuz: broken symbolic link to /boot/vmlinu?-5.4.18debug</span><br><span class="line">kdump initrd: </span><br><span class="line">   /var/lib/kdump/initrd.img: broken symbolic link to /var/lib/kdump/initrd.img-5.4.18debug</span><br><span class="line">current state:    Not ready to kdump</span><br><span class="line"></span><br><span class="line">kexec command:</span><br><span class="line">  /sbin/kexec -p --command-line=&quot;BOOT_IMAGE=/vmlinuz-5.4.18-19-generic root=UUID=6af7820e-7eb9-4d42-a5d6-afb3c7783308 ro quiet splash loglevel=0 resume=UUID=e358413a-5177-4f46-a1fa-dbabc1819a59 audit=0 security=none reset_devices systemd.unit=kdump-tools-dump.service nr_cpus=1 irqpoll nousb ata_piix.prefer_ms_hyperv=0&quot; --initrd=/var/lib/kdump/initrd.img /var/lib/kdump/vmlinuz           </span><br></pre></td></tr></table></figure><p>上面出现问题的原因是/boot下的vmlinuz和initrd.img文件名和内核编译时配置的文件名不一致，将vmlinuz-5.4.18-debug和initrd.img-5.4.18-debug分别改为vmlinuz-5.4.18debug、initrd.img-5.4.18debug后，重新通过sudo systemctl restart kdump-tools或者sudo /etc/init.d/kdump-tools restart就可以了。</p><p>也可以通过dmesg命令查看到相关的crash字样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~$ dmesg | grep crash</span><br><span class="line">[    0.000000] Command line: BOOT_IMAGE=/vmlinuz-5.4.18debug root=UUID=6af7820e-7eb9-4d42-a5d6-afb3c7783308 ro quiet splash crashkernel=512M-:192M loglevel=0 resume=UUID=e358413a-5177-4f46-a1fa-dbabc1819a59 audit=0 security=none</span><br><span class="line">[    0.009110] Reserving 192MB of memory at 1872MB for crashkernel (System RAM: 8074MB)</span><br><span class="line">[    0.028159] Kernel command line: BOOT_IMAGE=/vmlinuz-5.4.18debug root=UUID=6af7820e-7eb9-4d42-a5d6-afb3c7783308 ro quiet splash crashkernel=512M-:192M loglevel=0 resume=UUID=e358413a-5177-4f46-a1fa-dbabc1819a59 audit=0 security=none            </span><br></pre></td></tr></table></figure><p>如果显示信息如下，则说明安装成功了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">~$ kdump-config show</span><br><span class="line">DUMP_MODE:        kdump</span><br><span class="line">USE_KDUMP:        1</span><br><span class="line">KDUMP_SYSCTL:     kernel.panic_on_oops=1</span><br><span class="line">KDUMP_COREDIR:    /var/crash</span><br><span class="line">crashkernel addr: 0x</span><br><span class="line">   /var/lib/kdump/vmlinuz: symbolic link to /boot/vmlinuz-5.4.18debug</span><br><span class="line">kdump initrd: </span><br><span class="line">   /var/lib/kdump/initrd.img: symbolic link to /var/lib/kdump/initrd.img-5.4.18debug</span><br><span class="line">current state:    ready to kdump</span><br><span class="line"></span><br><span class="line">kexec command:</span><br><span class="line">  /sbin/kexec -p --command-line=&quot;BOOT_IMAGE=/vmlinuz-5.4.18debug root=UUID=6af7820e-7eb9-4d42-a5d6-afb3c7783308 ro quiet splash loglevel=0 resume=UUID=e358413a-5177-4f46-a1fa-dbabc1819a59 audit=0 security=none reset_devices systemd.unit=kdump-tools-dump.service nr_cpus=1 irqpoll nousb ata_piix.prefer_ms_hyperv=0&quot; --initrd=/var/lib/kdump/initrd.img /var/lib/kdump/vmlinuz              </span><br></pre></td></tr></table></figure><p>在grub.cfg中搜索crash可以看到以下信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~$ cat /boot/grub/grub.cfg | grep crash</span><br><span class="line">        linux/vmlinuz-5.4.18-19-generic root=UUID=6af7820e-7eb9-4d42-a5d6-afb3c7783308 ro  quiet splash crashkernel=512M-:192M loglevel=0 resume=UUID=e358413a-5177-4f46-a1fa-dbabc1819a59 audit=0 security=none</span><br><span class="line">linux   /vmlinuz-5.4.18-19-generic root=UUID=6af7820e-7eb9-4d42-a5d6-afb3c7783308 rw  quiet splash crashkernel=512M-:192M loglevel=0 resume=UUID=e358413a-5177-4f46-a1fa-dbabc1819a59 audit=0 security=none selinux=0 backup</span><br><span class="line">linux   /vmlinuz-5.4.18-19-generic root=UUID=6af7820e-7eb9-4d42-a5d6-afb3c7783308 rw  quiet splash crashkernel=512M-:192M loglevel=0 resume=UUID=e358413a-5177-4f46-a1fa-dbabc1819a59 audit=0 security=none selinux=0 restore</span><br><span class="line">        linux/vmlinuz-5.4.18-19-generic root=UUID=6af7820e-7eb9-4d42-a5d6-afb3c7783308 ro  quiet splash crashkernel=512M-:192M loglevel=0 resume=UUID=e358413a-5177-4f46-a1fa-dbabc1819a59 audit=0 security=none</span><br><span class="line">linux/vmlinuz-5.4.18-debug root=UUID=6af7820e-7eb9-4d42-a5d6-afb3c7783308 ro  quiet splash crashkernel=512M-:192M loglevel=0 resume=UUID=e358413a-5177-4f46-a1fa-dbabc1819a59 audit=0 security=none             </span><br></pre></td></tr></table></figure><p>内核debuginfo或者dbgsym可以参考网上教程安装。</p><p>可以通过如下格式启动crash命令进行相关调试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crash &lt;debug kernel&gt; &lt;crash dump&gt;                </span><br></pre></td></tr></table></figure><p>debug-kernel的路径如果装了debuginfo，可能是在/usr/lib/debug/lib/modules/$(uname -r)/vmlinux或者/usr/lib/debug/boot/vmlinux目录下，注意/boot下的vmlinuz文件是压缩过的bzImage格式文件，然后调试使用的vmlinuz文件是没有经过压缩的文件。如果是自己编译的内核源码，则vmlinuz在编译完后会出现在linux内核源码编译路径根目录下。</p><p>kdump-tools服务正常启动后，可以通过以下操作触发panic，测试kdump：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jsy@jsy-PC:~$ sysctl -n kernel.sysrq</span><br><span class="line">176</span><br><span class="line">#等价于以下命令</span><br><span class="line">jsy@jsy-PC:~$ cat /proc/sys/kernel/sysrq</span><br><span class="line">176</span><br><span class="line">$ sudo sysctl -w kernel.sysrq=1</span><br><span class="line">$ sudo sh -c &quot;echo c &gt; /proc/sysrq-trigger&quot;</span><br><span class="line">#或者在root用户下</span><br><span class="line"># echo 1 &gt; /proc/sys/kernel/sysrq        # --&gt; 只要内核没有挂掉，响应任何操作 </span><br><span class="line"># echo c &gt; /proc/sysrq-trigger  # --&gt; 认为造成os crash          </span><br></pre></td></tr></table></figure><p>然后重启后，通过crash命令可以看到如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">root@jsy-PC:/home/jsy# ls /usr/src/linux-headers-5.4.18-debug/vmlinux</span><br><span class="line">/usr/src/linux-headers-5.4.18-debug/vmlinux</span><br><span class="line">root@jsy-PC:/home/jsy# ls /var/crash/</span><br><span class="line">202104261059/ kdump_lock    kexec_cmd     </span><br><span class="line">root@jsy-PC:/home/jsy# ls /var/crash/202104261059/</span><br><span class="line">dmesg.202104261059  dump.202104261059</span><br><span class="line">root@jsy-PC:/home/jsy# crash /usr/src/linux-headers-5.4.18-debug/vmlinux /var/crash/202104261059/dump.202104261059 </span><br><span class="line"></span><br><span class="line">crash 7.2.8</span><br><span class="line">Copyright (C) 2002-2020  Red Hat, Inc.</span><br><span class="line">Copyright (C) 2004, 2005, 2006, 2010  IBM Corporation</span><br><span class="line">Copyright (C) 1999-2006  Hewlett-Packard Co</span><br><span class="line">Copyright (C) 2005, 2006, 2011, 2012  Fujitsu Limited</span><br><span class="line">Copyright (C) 2006, 2007  VA Linux Systems Japan K.K.</span><br><span class="line">Copyright (C) 2005, 2011  NEC Corporation</span><br><span class="line">Copyright (C) 1999, 2002, 2007  Silicon Graphics, Inc.</span><br><span class="line">Copyright (C) 1999, 2000, 2001, 2002  Mission Critical Linux, Inc.</span><br><span class="line">This program is free software, covered by the GNU General Public License,</span><br><span class="line">and you are welcome to change it and/or distribute copies of it under</span><br><span class="line">certain conditions.  Enter &quot;help copying&quot; to see the conditions.</span><br><span class="line">This program has absolutely no warranty.  Enter &quot;help warranty&quot; for details.</span><br><span class="line"> </span><br><span class="line">GNU gdb (GDB) 7.6</span><br><span class="line">Copyright (C) 2013 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br><span class="line">and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;x86_64-unknown-linux-gnu&quot;...</span><br><span class="line"></span><br><span class="line">WARNING: kernel relocated [830MB]: patching 113662 gdb minimal_symbol values</span><br><span class="line"></span><br><span class="line">      KERNEL: /usr/src/linux-headers-5.4.18-debug/vmlinux              </span><br><span class="line">    DUMPFILE: /var/crash/202104261059/dump.202104261059  [PARTIAL DUMP]</span><br><span class="line">        CPUS: 12</span><br><span class="line">        DATE: Mon Apr 26 10:59:19 2021</span><br><span class="line">      UPTIME: 00:19:31</span><br><span class="line">LOAD AVERAGE: 0.70, 2.00, 3.72</span><br><span class="line">       TASKS: 1070</span><br><span class="line">    NODENAME: jsy-PC</span><br><span class="line">     RELEASE: 5.4.18debug</span><br><span class="line">     VERSION: #1 SMP Mon Apr 19 09:50:53 CST 2021</span><br><span class="line">     MACHINE: x86_64  (3200 Mhz)</span><br><span class="line">      MEMORY: 7.9 GB</span><br><span class="line">       PANIC: &quot;Kernel panic - not syncing: sysrq triggered crash&quot;</span><br><span class="line">         PID: 3162</span><br><span class="line">     COMMAND: &quot;bash&quot;</span><br><span class="line">        TASK: ffff95428bf58000  [THREAD_INFO: ffff95428bf58000]</span><br><span class="line">         CPU: 8</span><br><span class="line">       STATE: TASK_RUNNING (PANIC)</span><br><span class="line"></span><br><span class="line">KERNEL:系统崩溃时运行的 kernel 文件</span><br><span class="line">DUMPFILE:内核转储文件</span><br><span class="line">CPUS: 所在机器的 CPU 数量</span><br><span class="line">DATE: 系统崩溃的时间</span><br><span class="line">TASKS:系统崩溃时内存中的任务数</span><br><span class="line">NODENAME:崩溃的系统主机名</span><br><span class="line">RELEASE:和 VERSION: 内核版本号</span><br><span class="line">MACHINE:CPU 架构</span><br><span class="line">MEMORY:崩溃主机的物理内存  </span><br><span class="line">bt 查看异常时的堆栈</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;在ubuntu/debian系统下可以直接通过apt命令进行安装：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ sudo apt install linux-crashdump               &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="LINUX" scheme="https://rma-shuyu.github.io/categories/LINUX/"/>
    
    
    <category term="Kdump" scheme="https://rma-shuyu.github.io/tags/Kdump/"/>
    
  </entry>
  
  <entry>
    <title>Virtio协议概述</title>
    <link href="https://rma-shuyu.github.io/2022/06/22/Virtio%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0/"/>
    <id>https://rma-shuyu.github.io/2022/06/22/Virtio%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0/</id>
    <published>2022-06-22T12:25:15.000Z</published>
    <updated>2023-09-09T10:33:02.406Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Virtio"><a href="#Virtio" class="headerlink" title="Virtio "></a>Virtio </h2><p>半虚拟化设备(Virtio Device)在当前云计算虚拟化场景下已经得到了非常广泛的应用， 并且现在也有越来越多的物理设备也开始支持Virtio协议，即所谓的<code>Virtio Offload</code>， </p><span id="more"></span><p>通过将virtio协议卸载到硬件上（例如virtio-net网卡卸载，virtio-scsi卸载）让物理机和虚拟机都能够获得加速体验。 本文中我们来重点了解一下virtio技术中的一些关键点，方便我们加深对半虚拟化的理解。 本文适合对IO虚拟化有一定了解的人群阅读，本文的目的是对想要了解virtio内部机制的读者提供帮助。</p><p>在开始了解virtio之前，我们先思考一下几个相关问题：</p><ul><li>  virtio设备有哪几种呈现方式?</li><li>  virtio-pci设备的配置空间都有哪些内容？</li><li>  virtio前端和后端基于共享内存机制进行通信，它是凭什么可以做到无锁的？</li><li>  virtio机制中有那几个关键的数据结构？virtio配置接口存放在哪里？virtio是如何工作的？</li><li>  virtio前后端是如何进行通信的？irqfd和ioeventfd是什么回事儿？在virtio前后端通信中是怎么用到的？</li><li>  virtio设备支持MSIx，在qemu/kvm中具体是怎么实现对MSIx的模拟呢？</li><li>  virtio modern相对于virtio legay多了哪些新特性？</li></ul><h2 id="0-简单了解一下Virtio-Spec协议"><a href="#0-简单了解一下Virtio-Spec协议" class="headerlink" title="0. 简单了解一下Virtio Spec协议 "></a>0. 简单了解一下Virtio Spec协议 </h2><p>virtio协议标准最早由IBM提出，virtio作为一套标准协议现在有专门的技术委员会进行管理， 具体的标准可以访问<a href="http://docs.oasis-open.org/virtio/virtio/v1.0/virtio-v1.0.html"><code>virtio</code>官网</a>， 开发者可以向技术委员会提供新的virtio设备提案（<code>RFC</code>），经过委员会通过后可以增加新的virtio设备类型。</p><p>组成一个virtio设备的四要素包括： **设备状态域，<code>feature bits</code>，设备配置空间，一个或者多个<code>virtqueue</code>**。 其中设备状态域包含6种状态：</p><ul><li>  ACKNOWLEDGE（1）：GuestOS发现了这个设备，并且认为这是一个有效的virtio设备；</li><li>  DRIVER (2) : GuestOS知道该如何驱动这个设备；</li><li>  FAILED (128) : GuestOS无法正常驱动这个设备，Something is wriong；</li><li>  FEATURES_OK (8) : GuestOS认识所有的feature，并且feature协商一完成；</li><li>  DRIVER_OK (4) : 驱动加载完成，设备可以投入使用了；</li><li>  DEVICE_NEEDS_RESET (64) ：设备触发了错误，需要重置才能继续工作。</li></ul><p><code>feature bits</code>用来标志设备支持那个特性，其中bit0-bit23是特定设备可以使用的<code>feature bits</code>， bit24-bit37预给队列和feature协商机制，bit38以上保留给未来其他用途。 例如：对于virtio-net设备而言，feature bit0表示网卡设备支持checksum校验。 <code>VIRTIO_F_VERSION_1</code>这个feature bit用来表示设备是否支持virtio 1.0 spec标准。</p><p>在virtio协议中，所有的设备都使用virtqueue来进行数据的传输。 <strong>每个设备可以有0个或者多个virtqueue，每个virtqueue占用2个或者更多个4K的物理页</strong>。 virtqueue有<code>Split Virtqueues</code>和<code>Packed Virtqueues</code>两种模式， 在<code>Split virtqueues</code>模式下virtqueue被分成若干个部分， 每个部分都是前端驱动或者后端单向可写的（不能两端同时写）。 每个virtqueue都有一个16bit的queue size参数，表示队列的总长度。 每个virtqueue由3个部分组成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+-------------------+--------------------------------+-----------------------+</span><br><span class="line">| Descriptor Table  |   Available Ring  (padding)    |       Used Ring       |</span><br><span class="line">+-------------------+--------------------------------+-----------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>  Descriptor Table：存放IO传输请求信息；</li><li>  Available Ring：记录了Descriptor Table表中的哪些项被更新了，前端Driver可写但后端只读；</li><li>  Used Ring：记录Descriptor Table表中哪些请求已经被提交到硬件，前端Driver只读但后端可写。</li></ul><p>整个virtio协议中设备IO请求的工作机制可以简单地概括为：</p><ol><li> 前端驱动将IO请求放到<code>Descriptor Table</code>中，然后将索引更新到<code>Available Ring</code>中，然后kick后端去取数据；</li><li> 后端取出IO请求进行处理，然后结果刷新到<code>Descriptor Table</code>中再更新<code>Used Ring</code>，然后发送中断notify前端。</li></ol><p>从virtio协议可以了解到<strong>virtio设备支持3种设备呈现模式</strong>：</p><ul><li>  Virtio Over PCI BUS，依旧遵循PCI规范，挂在到PCI总线上，作为virtio-pci设备呈现；</li><li>  Virtio Over MMIO，部分不支持PCI协议的虚拟化平台可以使用这种工作模式，直接挂载到系统总线上；</li><li>  Virtio Over Channel I/O：主要用在s390平台上，virtio-ccw使用这种基于channel I/O的机制。</li></ul><p>其中，Virtio Over PCI BUS的使用比较广泛，作为PCI设备需按照规范要通过PCI配置空间来向操作系统报告设备支持的特性集合， 这样操作系统才知道这是一个什么类型的virtio设备，并调用对应的前端驱动和这个设备进行握手，进而将设备驱动起来。 QEMU会给virtio设备模拟PCI配置空间，对于virtio设备来说PCI Vendor ID固定为0x1AF4， PCI Device ID 为 0x1000到0x107F之间的是virtio设备。 同时，在不支持PCI协议的虚拟化平台上，virtio设备也可以直接通过MMIO进行呈现， virtio-spec 4.2 <a href="https://docs.oasis-open.org/virtio/virtio/v1.1/csprd01/virtio-v1.1-csprd01.html#x1-1440002">Virtio Over MMIO</a>有针对virtio-mmio设备呈现方式的详细描述，mmio相关信息可以直接通过内核参数报告给Linux操作系统。 本文主要基于virtio-pci展开讨论。</p><p>前面提到virtio设备有<code>feature bits</code>，<code>virtqueue</code>等四要素，那么在virtio-pci模式下是如何呈现的呢？ 从virtio spec来看，老的virtio协议和新的virtio协议在这一块有很大改动。 virtio legacy（virtio 0.95）协议规定，对应的配置数据结构（virtio common configuration structure） 应该存放在设备的BAR0里面，我们称之为<code>virtio legay interface</code>，其结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">                      virtio legacy ==&gt; Mapped into PCI BAR0 </span><br><span class="line">+------------------------------------------------------------------+ </span><br><span class="line">|                    Host Feature Bits[0:31]                       | </span><br><span class="line">+------------------------------------------------------------------+</span><br><span class="line">|                    Guest Feature Bits[0:31]                      |</span><br><span class="line">+------------------------------------------------------------------+</span><br><span class="line">|                    Virtqueue Address PFN                         |</span><br><span class="line">+---------------------------------+--------------------------------+</span><br><span class="line">|           Queue Select          |           Queue Size           |</span><br><span class="line">+----------------+----------------+--------------------------------+</span><br><span class="line">|   ISR Status   | Device Stat    |           Queue Notify         |</span><br><span class="line">+----------------+----------------+--------------------------------+</span><br><span class="line">|       MSI Config Vector         |         MSI Queue Vector       |</span><br><span class="line">+---------------------------------+--------------------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于新的<code>virtio modern</code>，协议将配置结构划分为5种类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">/* Common configuration */ </span><br><span class="line">#define VIRTIO_PCI_CAP_COMMON_CFG        1 </span><br><span class="line">/* Notifications */ </span><br><span class="line">#define VIRTIO_PCI_CAP_NOTIFY_CFG        2</span><br><span class="line">/* ISR Status */ </span><br><span class="line">#define VIRTIO_PCI_CAP_ISR_CFG           3 </span><br><span class="line">/* Device specific configuration */ </span><br><span class="line">#define VIRTIO_PCI_CAP_DEVICE_CFG        4 </span><br><span class="line">/* PCI configuration access */ </span><br><span class="line">#define VIRTIO_PCI_CAP_PCI_CFG           5 </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上的每种配置结构是直接映射到virtio设备的BAR空间内，那么如何指定每种配置结构的位置呢？ 答案是通过<code>PCI Capability list</code>方式去指定，这和物理PCI设备是一样的，体现了virtio-pci的协议兼容性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">struct virtio_pci_cap &#123; </span><br><span class="line">        u8 cap_vndr;    /* Generic PCI field: PCI_CAP_ID_VNDR */ </span><br><span class="line">        u8 cap_next;    /* Generic PCI field: next ptr. */ </span><br><span class="line">        u8 cap_len;     /* Generic PCI field: capability length */ </span><br><span class="line">        u8 cfg_type;    /* Identifies the structure. */ </span><br><span class="line">        u8 bar;         /* Where to find it. */ </span><br><span class="line">        u8 padding[3];  /* Pad to full dword. */ </span><br><span class="line">        le32 offset;    /* Offset within bar. */ </span><br><span class="line">        le32 length;    /* Length of the structure, in bytes. */ </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>只是略微不同的是，virtio-pci的Capability有一个统一的结构， 其中<code>cfg_type</code>表示Cap的类型，bar表示这个配置结构被映射到的BAR空间号。 这样每个配置结构都可以通过BAR空间直接访问，或者通过PCI配置空间的<code>VIRTIO_PCI_CAP_PCI_CFG</code>域进行访问。 每个Cap的具体结构定义可以参考virtio spec 4.1.4.3小节。</p><h1 id="1-前后端数据共享"><a href="#1-前后端数据共享" class="headerlink" title="1. 前后端数据共享"></a>1. 前后端数据共享</h1><p>传统的纯模拟设备在工作的时候，会触发频繁的陷入陷出， 而且IO请求的内容要进行多次拷贝传递，严重影响了设备的IO性能。 virtio为了提升设备的IO性能，采用了共享内存机制， _<strong>前端驱动会提前申请好一段物理地址空间用来存放IO请求，然后将这段地址的GPA告诉QEMU</strong>_。 前端驱动在下发IO请求后，QEMU可以直接从共享内存中取出请求，然后将完成后的结果又直接写到虚拟机对应地址上去。 <strong>整个过程中可以做到直投直取，省去了不必要的数据拷贝开销</strong>。</p><p><strong><code>Virtqueue</code>是整个virtio方案的灵魂所在</strong>。每个virtqueue都包含3张表， <code>Descriptor Table</code>存放了IO请求描述符，<code>Available Ring</code>记录了当前哪些描述符是可用的， <code>Used Ring</code>记录了哪些描述符已经被后端使用了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">       +------------------------------------+</span><br><span class="line">       |       virtio  guest driver         |</span><br><span class="line">       +-----------------+------------------+</span><br><span class="line">         /               |              ^</span><br><span class="line">        /                |               \</span><br><span class="line">       put            update             get</span><br><span class="line">      /                  |                 \</span><br><span class="line">     V                   V                  \</span><br><span class="line">+----------+      +------------+        +----------+</span><br><span class="line">|          |      |            |        |          |</span><br><span class="line">+----------+      +------------+        +----------+</span><br><span class="line">| available|      | descriptor |        |   used   |</span><br><span class="line">|   ring   |      |   table    |        |   ring   |</span><br><span class="line">+----------+      +------------+        +----------+</span><br><span class="line">|          |      |            |        |          |</span><br><span class="line">+----------+      +------------+        +----------+</span><br><span class="line">|          |      |            |        |          |</span><br><span class="line">+----------+      +------------+        +----------+</span><br><span class="line">     \                   ^                   ^</span><br><span class="line">      \                  |                  /</span><br><span class="line">      get             update              put</span><br><span class="line">        \                |                /</span><br><span class="line">         V               |               /</span><br><span class="line">        +----------------+-------------------+</span><br><span class="line">        |   virtio host backend          |</span><br><span class="line">        +------------------------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>Desriptor Table</code>中存放的是一个一个的<code>virtq_desc</code>元素，每个<code>virq_desc</code>元素占用16个字节。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+-----------------------------------------------------------+</span><br><span class="line">|                        addr/gpa [0:63]                    |</span><br><span class="line">+-------------------------+-----------------+---------------+</span><br><span class="line">|         len [0:31]      |  flags [0:15]   |  next [0:15]  |</span><br><span class="line">+-------------------------+-----------------+---------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中，addr占用64bit存放了单个IO请求的GPA地址信息，例如addr可能表示某个DMA buffer的起始地址。 len占用32bit表示IO请求的长度，flags的取值有3种， <code>VIRTQ_DESC_F_NEXT</code>表示这个IO请求和下一个<code>virtq_desc</code>描述的是连续的， <code>IRTQ_DESC_F_WRITE</code>表示这段buffer是write only的， <code>VIRTQ_DESC_F_INDIRECT</code>表示这段buffer里面放的内容是另外一组buffer的<code>virtq_desc</code>（相当于重定向）， next是指向下一个<code>virtq_desc</code>的索引号（前提是<code>VIRTQ_DESC_F_NEXT</code> &amp; flags）。</p><p><code>Available Ring</code>是前端驱动用来告知后端那些IO buffer是的请求需要处理，每个Ring中包含一个<code>virtq_avail</code>占用8个字节。 其中，flags取值为<code>VIRTQ_AVAIL_F_NO_INTERRUPT</code>时表示前端驱动告诉后端： “当你消耗完一个IO buffer的时候，不要立刻给我发中断”（防止中断过多影响效率）。 idx表示下次前端驱动要放置<code>Descriptor Entry</code>的地方。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+--------------+-------------+--------------+---------------------+</span><br><span class="line">| flags [0:15] |  idx [0:15] |  ring[0:15]  |  used_event [0:15]  |</span><br><span class="line">+--------------+-------------+--------------+---------------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Used Ring结构稍微不一样，flags的值如果为<code>VIRTIO_F_EVENT_IDX</code>并且前后端协商<code>VIRTIO_F_EVENT_IDX</code> feature成功, 那么Guest会将used ring index放在available ring的末尾，告诉后端说： “Hi 小老弟，当你处理完这个请求的时候，给我发个中断通知我一下”， 同时host也会将avail_event index放到used ring的末尾，告诉guest说： “Hi 老兄，记得把这个idx的请求kick给我哈”。 <code>VIRTIO_F_EVENT_IDX</code>对virtio通知/中断有一定的优化，在某些场景下能够提升IO性能。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/* The Guest publishes the used index for which it expects an interrupt</span><br><span class="line"> * at the end of the avail ring. Host should ignore the avail-&gt;flags field. */</span><br><span class="line">/* The Host publishes the avail index for which it expects a kick</span><br><span class="line"> * at the end of the used ring. Guest should ignore the used-&gt;flags field. */</span><br><span class="line"> </span><br><span class="line">struct virtq_used &#123; </span><br><span class="line">#define VIRTQ_USED_F_NO_NOTIFY  1 </span><br><span class="line">        le16 flags; </span><br><span class="line">        le16 idx; </span><br><span class="line">        struct virtq_used_elem ring[ /* Queue Size */]; </span><br><span class="line">        le16 avail_event; /* Only if VIRTIO_F_EVENT_IDX */ </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line">/* le32 is used here for ids for padding reasons. */ </span><br><span class="line">struct virtq_used_elem &#123; </span><br><span class="line">        /* Index of start of used descriptor chain. */ </span><br><span class="line">        le32 id; </span><br><span class="line">        /* Total length of the descriptor chain which was used (written to) */ </span><br><span class="line">        le32 len; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>原理就到这里，后面会以virtio网卡为例进行详细流程说明。</p><h2 id="2-前后端通信机制（irqfd-与-ioeventfd）"><a href="#2-前后端通信机制（irqfd-与-ioeventfd）" class="headerlink" title="2. 前后端通信机制（irqfd 与 ioeventfd）"></a>2. 前后端通信机制（irqfd 与 ioeventfd）</h2><p>共享内存方式解决了传统设备IO过程中内存拷贝带来的性能损耗问题，除此之外前端驱动和后端驱动的通信问题也是有可以改进的地方。 Virtio前后端通信概括起来只有两个方向，即GuestOS通知QEMU和QEMU通知GuestOS。 当前端驱动准备好IO buffer之后，需要通知后端（QEMU），告诉后端： “小老弟，我有一波IO请求已经准备好了，你帮我处理一下”。 前端通知出去后，就可以等待IO结果了（操作系统可以进行一次调度），这时候vCPU可以去干点其他的事情。 后端收到消息后开始处理IO请求，当IO请求处理完成之后，后端就通过中断机制通知GuestOS： “老哥，你的IO给你处理好了，你来取一下”。 前后端通信机制如下图所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+-------------+                +-------------+</span><br><span class="line">|             |                |             |</span><br><span class="line">|             |                |             |</span><br><span class="line">|   GuestOS   |                |     QEMU    |</span><br><span class="line">|             |                |             |</span><br><span class="line">|             |                |             |</span><br><span class="line">+---+---------+                +----+--------+</span><br><span class="line">    |     ^                         |    ^</span><br><span class="line">    |     |                         |    |</span><br><span class="line">+---|-----|-------------------------|----|---+</span><br><span class="line">|   |     |                irqfd    |    |   |</span><br><span class="line">|   |     +-------------------------+    |   |</span><br><span class="line">|   |  ioeventfd                         |   |</span><br><span class="line">|   +------------------------------------+   |</span><br><span class="line">|                   KVM                      |</span><br><span class="line">+--------------------------------------------+</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>前端驱动通知后端比较简单，QEMU设置一段特定的MMIO地址空间，前端驱动访问这段MMIO触发VMExit， 退出到KVM后利用<code>ioeventfd</code>机制通知到用户态的QEMU，QEMU主循环（main_loop poll） 检测到ioeventfd事件后调用callback进行处理。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">前端驱动通知后端：</span><br><span class="line">内核流程mark一下，PCI设备驱动流程这个后面可以学习一下，先扫描PCI bus发现是virtio设备再扫描virtio-bus。</span><br><span class="line">worker_thread --&gt; process_one_work --&gt; pciehp_power_thread --&gt; pciehp_enable_slot --&gt; </span><br><span class="line">pciehp_configure_device --&gt; pci_bus_add_devices --&gt; pci_bus_add_device --&gt; device_attach --&gt; </span><br><span class="line">__device_attach --&gt; bus_for_each_drv --&gt; __device_attach_driver --&gt; driver_probe_device --&gt; </span><br><span class="line">pci_device_probe --&gt; local_pci_probe --&gt; virtio_pci_probe --&gt; register_virtio_device --&gt; </span><br><span class="line">device_register --&gt; device_add --&gt; bus_probe_device --&gt; device_initial_probe </span><br><span class="line">--&gt; __device_attach --&gt; bus_for_each_drv --&gt; __device_attach_driver --&gt;</span><br><span class="line">driver_probe_device --&gt; virtio_dev_probe --&gt; virtnet_probe (网卡设备驱动加载的入口)</span><br><span class="line">static int virtnet_probe(struct virtio_device *vdev) </span><br><span class="line">&#123;</span><br><span class="line">    ......</span><br><span class="line">    virtio_device_ready(vdev);</span><br><span class="line">&#125;</span><br><span class="line">/**</span><br><span class="line"> * virtio_device_ready - enable vq use in probe function</span><br><span class="line"> * @vdev: the device</span><br><span class="line"> *</span><br><span class="line"> * Driver must call this to use vqs in the probe function.</span><br><span class="line"> *</span><br><span class="line"> * Note: vqs are enabled automatically after probe returns.</span><br><span class="line"> */</span><br><span class="line">static inline</span><br><span class="line">void virtio_device_ready(struct virtio_device *dev)</span><br><span class="line">&#123;</span><br><span class="line">        unsigned status = dev-&gt;config-&gt;get_status(dev);</span><br><span class="line">        BUG_ON(status &amp; VIRTIO_CONFIG_S_DRIVER_OK);</span><br><span class="line">        dev-&gt;config-&gt;set_status(dev, status | VIRTIO_CONFIG_S_DRIVER_OK);</span><br><span class="line">&#125;</span><br><span class="line"># QEMU/KVM后端的处理流程如下：</span><br><span class="line"># 前端驱动写Status位，val &amp; VIRTIO_CONFIG_S_DRIVER_OK，这时候前端驱动已经ready</span><br><span class="line">virtio_pci_config_write  --&gt; virtio_ioport_write --&gt; virtio_pci_start_ioeventfd</span><br><span class="line">--&gt; virtio_bus_set_host_notifier --&gt; virtio_bus_start_ioeventfd --&gt; virtio_device_start_ioeventfd_impl</span><br><span class="line">--&gt; virtio_bus_set_host_notifier</span><br><span class="line">    --&gt; virtio_pci_ioeventfd_assign</span><br><span class="line">        --&gt; memory_region_add_eventfd</span><br><span class="line">            --&gt; memory_region_transaction_commit</span><br><span class="line">              --&gt; address_space_update_ioeventfds</span><br><span class="line">                --&gt; address_space_add_del_ioeventfds</span><br><span class="line">                  --&gt; kvm_io_ioeventfd_add/vhost_eventfd_add</span><br><span class="line">                    --&gt; kvm_set_ioeventfd_pio</span><br><span class="line">                      --&gt; kvm_vm_ioctl(kvm_state, KVM_IOEVENTFD, &amp;kick)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其实，这就是QEMU的<code>Fast MMIO</code>实现机制。 我们可以看到，QEMU会为每个设备MMIO对应的MemoryRegion注册一个ioeventfd。 最后调用了一个KVM_IOEVENTFD ioctl到KVM内核里面，而在KVM内核中会将MMIO对应的（gpa,len,eventfd）信息会注册到KVM_FAST_MMIO_BUS上。 这样当Guest访问MMIO地址范围退出后（触发<code>EPT Misconfig</code>），KVM会查询一下访问的GPA是否落在某段MMIO地址空间range内部， 如果是的话就直接写eventfd告知QEMU，QEMU就会从coalesced mmio ring page中取MMIO请求 （注：pio page和 mmio page是QEMU和KVM内核之间的共享内存页，已经提前mmap好了）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#kvm内核代码virt/kvm/eventfd.c中</span><br><span class="line">kvm_vm_ioctl(KVM_IOEVENTFD)</span><br><span class="line">  --&gt; kvm_ioeventfd</span><br><span class="line">    --&gt; kvm_assign_ioeventfd</span><br><span class="line">      --&gt; kvm_assign_ioeventfd_idx</span><br><span class="line"># MMIO处理流程中（handle_ept_misconfig）最后会调用到ioeventfd_write通知QEMU。</span><br><span class="line">/* MMIO/PIO writes trigger an event if the addr/val match */</span><br><span class="line">static int</span><br><span class="line">ioeventfd_write(struct kvm_vcpu *vcpu, struct kvm_io_device *this, gpa_t addr,</span><br><span class="line">                int len, const void *val)</span><br><span class="line">&#123;</span><br><span class="line">        struct _ioeventfd *p = to_ioeventfd(this);</span><br><span class="line">        if (!ioeventfd_in_range(p, addr, len, val))</span><br><span class="line">                return -EOPNOTSUPP;</span><br><span class="line">        eventfd_signal(p-&gt;eventfd, 1);</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不了解<code>MMIO</code>是如何模拟的童鞋，可以结合本站的文章<a href="https://kernelgo.org/mmio.html"><code>MMIO</code>模拟实现分析</a>去了解一下， 如果还是不懂的可以在文章下面评论。</p><p><strong>后端通知前端，是通过中断的方式</strong>，QEMU/KVM中有一套完整的中断模拟实现框架，</p><p>如果对QEMU/KVM中断模拟不熟悉的童鞋， 建议阅读一下这篇文章：<a href="https://www.binss.me/blog/qemu-note-of-interrupt/"><code>QEMU学习笔记-中断</code></a>。 对于virtio-pci设备，可以通过Cap呈现MSIx给虚拟机，这样在前端驱动加载的时候就会尝试去使能MSIx中断， 后端在这个时候建立起MSIx通道。</p><p>前端驱动加载(probe)的过程中，会去初始化<code>virtqueue</code>，这个时候会去申请MSIx中断并注册中断处理函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">virtnet_probe</span><br><span class="line">  --&gt; init_vqs</span><br><span class="line">    --&gt; virtnet_find_vqs</span><br><span class="line">      --&gt; vi-&gt;vdev-&gt;config-&gt;find_vqs [vp_modern_find_vqs]</span><br><span class="line">        --&gt; vp_find_vqs</span><br><span class="line">          --&gt; vp_find_vqs_msix // 为每virtqueue申请一个MSIx中断，通常收发各一个队列</span><br><span class="line">            --&gt; vp_request_msix_vectors // 主要的MSIx中断申请逻辑都在这个函数里面</span><br><span class="line">              --&gt; pci_alloc_irq_vectors_affinity // 申请MSIx中断描述符(__pci_enable_msix_range)</span><br><span class="line">                --&gt; request_irq  // 注册中断处理函数</span><br><span class="line">               </span><br><span class="line">       // virtio-net网卡至少申请了3个MSIx中断：</span><br><span class="line">                // 一个是configuration change中断（配置空间发生变化后，QEMU通知前端）</span><br><span class="line">                // 发送队列1个MSIx中断，接收队列1MSIx中断</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在QEMU/KVM这一侧，开始模拟MSIx中断，具体流程大致如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">virtio_pci_config_write</span><br><span class="line">  --&gt; virtio_ioport_write</span><br><span class="line">    --&gt; virtio_set_status</span><br><span class="line">      --&gt; virtio_net_vhost_status</span><br><span class="line">        --&gt; vhost_net_start</span><br><span class="line">          --&gt; virtio_pci_set_guest_notifiers</span><br><span class="line">            --&gt; kvm_virtio_pci_vector_use </span><br><span class="line">              |--&gt; kvm_irqchip_add_msi_route //更新中断路由表</span><br><span class="line">              |--&gt; kvm_virtio_pci_irqfd_use  //使能MSI中断</span><br><span class="line">                 --&gt; kvm_irqchip_add_irqfd_notifier_gsi</span><br><span class="line">                   --&gt; kvm_irqchip_assign_irqfd</span><br><span class="line">                  </span><br><span class="line"># 申请MSIx中断的时候，会为MSIx分配一个gsi，并为这个gsi绑定一个irqfd，然后调用ioctl KVM_IRQFD注册到内核中。               </span><br><span class="line">static int kvm_irqchip_assign_irqfd(KVMState *s, int fd, int rfd, int virq,</span><br><span class="line">                                    bool assign)</span><br><span class="line">&#123;</span><br><span class="line">    struct kvm_irqfd irqfd = &#123;</span><br><span class="line">        .fd = fd,</span><br><span class="line">        .gsi = virq,</span><br><span class="line">        .flags = assign ? 0 : KVM_IRQFD_FLAG_DEASSIGN,</span><br><span class="line">    &#125;;</span><br><span class="line">    if (rfd != -1) &#123;</span><br><span class="line">        irqfd.flags |= KVM_IRQFD_FLAG_RESAMPLE;</span><br><span class="line">        irqfd.resamplefd = rfd;</span><br><span class="line">    &#125;</span><br><span class="line">    if (!kvm_irqfds_enabled()) &#123;</span><br><span class="line">        return -ENOSYS;</span><br><span class="line">    &#125;</span><br><span class="line">    return kvm_vm_ioctl(s, KVM_IRQFD, &amp;irqfd);</span><br><span class="line">&#125;</span><br><span class="line"># KVM内核代码virt/kvm/eventfd.c</span><br><span class="line">kvm_vm_ioctl(s, KVM_IRQFD, &amp;irqfd)</span><br><span class="line">  --&gt; kvm_irqfd_assign</span><br><span class="line">    --&gt; vfs_poll(f.file, &amp;irqfd-&gt;pt) // 在内核中poll这个irqfd</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>从上面的流程可以看出，<strong>QEMU/KVM使用<code>irqfd</code>机制来模拟MSIx中断</strong>， 即设备申请MSIx中断的时候会为MSIx分配一个gsi（这个时候会刷新irq routing table）， 并为这个gsi绑定一个<code>irqfd</code>，最后在内核中去<code>poll</code>这个<code>irqfd</code>。 当QEMU处理完IO之后，就写MSIx对应的irqfd，给前端注入一个MSIx中断，告知前端我已经处理好IO了你可以来取结果了。</p><p>例如，virtio-scsi从前端取出IO请求后会取做DMA操作（DMA是异步的，QEMU协程中负责处理）。 当DMA完成后QEMU需要告知前端IO请求已完成（Complete），那么怎么去投递这个MSIx中断呢？ 答案是调用<code>virtio_notify_irqfd</code>注入一个MSIx中断。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#0  0x00005604798d569b in virtio_notify_irqfd (vdev=0x56047d12d670, vq=0x7fab10006110) at  hw/virtio/virtio.c:1684</span><br><span class="line">#1  0x00005604798adea4 in virtio_scsi_complete_req (req=0x56047d09fa70) at  hw/scsi/virtio-scsi.c:76</span><br><span class="line">#2  0x00005604798aecfb in virtio_scsi_complete_cmd_req (req=0x56047d09fa70) at  hw/scsi/virtio-scsi.c:468</span><br><span class="line">#3  0x00005604798aee9d in virtio_scsi_command_complete (r=0x56047ccb0be0, status=0, resid=0) at  hw/scsi/virtio-scsi.c:495</span><br><span class="line">#4  0x0000560479b397cf in scsi_req_complete (req=0x56047ccb0be0, status=0) at hw/scsi/scsi-bus.c:1404</span><br><span class="line">#5  0x0000560479b2b503 in scsi_dma_complete_noio (r=0x56047ccb0be0, ret=0) at hw/scsi/scsi-disk.c:279</span><br><span class="line">#6  0x0000560479b2b610 in scsi_dma_complete (opaque=0x56047ccb0be0, ret=0) at hw/scsi/scsi-disk.c:300</span><br><span class="line">#7  0x00005604799b89e3 in dma_complete (dbs=0x56047c6e9ab0, ret=0) at dma-helpers.c:118</span><br><span class="line">#8  0x00005604799b8a90 in dma_blk_cb (opaque=0x56047c6e9ab0, ret=0) at dma-helpers.c:136</span><br><span class="line">#9  0x0000560479cf5220 in blk_aio_complete (acb=0x56047cd77d40) at block/block-backend.c:1327</span><br><span class="line">#10 0x0000560479cf5470 in blk_aio_read_entry (opaque=0x56047cd77d40) at block/block-backend.c:1387</span><br><span class="line">#11 0x0000560479df49c4 in coroutine_trampoline (i0=2095821104, i1=22020) at util/coroutine-ucontext.c:115</span><br><span class="line">#12 0x00007fab214d82c0 in __start_context () at /usr/lib64/libc.so.6</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在<code>virtio_notify_irqfd</code> 函数中，会去写<code>irqfd</code>，给内核发送一个信号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void virtio_notify_irqfd(VirtIODevice *vdev, VirtQueue *vq)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">     /*</span><br><span class="line">     * virtio spec 1.0 says ISR bit 0 should be ignored with MSI, but</span><br><span class="line">     * windows drivers included in virtio-win 1.8.0 (circa 2015) are</span><br><span class="line">     * incorrectly polling this bit during crashdump and hibernation</span><br><span class="line">     * in MSI mode, causing a hang if this bit is never updated.</span><br><span class="line">     * Recent releases of Windows do not really shut down, but rather</span><br><span class="line">     * log out and hibernate to make the next startup faster.  Hence,</span><br><span class="line">     * this manifested as a more serious hang during shutdown with</span><br><span class="line">     *</span><br><span class="line">     * Next driver release from 2016 fixed this problem, so working around it</span><br><span class="line">     * is not a must, but it&#x27;s easy to do so let&#x27;s do it here.</span><br><span class="line">     *</span><br><span class="line">     * Note: it&#x27;s safe to update ISR from any thread as it was switched</span><br><span class="line">     * to an atomic operation.</span><br><span class="line">     */</span><br><span class="line">    virtio_set_isr(vq-&gt;vdev, 0x1);</span><br><span class="line">    event_notifier_set(&amp;vq-&gt;guest_notifier);   //写vq-&gt;guest_notifier，即irqfd</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>QEMU写了这个<code>irqfd</code>后，KVM内核模块中的irqfd poll就收到一个<code>POLL_IN</code>事件，然后将MSIx中断自动投递给对应的LAPIC。 大致流程是：<code>POLL_IN</code> -&gt; <code>kvm_arch_set_irq_inatomic</code> -&gt; <code>kvm_set_msi_irq</code>, <code>kvm_irq_delivery_to_apic_fast</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">static int</span><br><span class="line">irqfd_wakeup(wait_queue_entry_t *wait, unsigned mode, int sync, void *key)</span><br><span class="line">&#123;</span><br><span class="line">        if (flags &amp; EPOLLIN) &#123;</span><br><span class="line">                idx = srcu_read_lock(&amp;kvm-&gt;irq_srcu);</span><br><span class="line">                do &#123;</span><br><span class="line">                        seq = read_seqcount_begin(&amp;irqfd-&gt;irq_entry_sc);</span><br><span class="line">                        irq = irqfd-&gt;irq_entry;</span><br><span class="line">                &#125; while (read_seqcount_retry(&amp;irqfd-&gt;irq_entry_sc, seq));</span><br><span class="line">                /* An event has been signaled, inject an interrupt */</span><br><span class="line">                if (kvm_arch_set_irq_inatomic(&amp;irq, kvm,</span><br><span class="line">                                             KVM_USERSPACE_IRQ_SOURCE_ID, 1,</span><br><span class="line">                                             false) == -EWOULDBLOCK)</span><br><span class="line">                        schedule_work(&amp;irqfd-&gt;inject);</span><br><span class="line">                srcu_read_unlock(&amp;kvm-&gt;irq_srcu, idx);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里还有一点没有想明白，结合代码和调试来看，virtio-blk/virtio-scsi的msi中断走irqfd机制， 但是virtio-net（不开启vhost的情况下）不走irqfd，而是直接调用<code>virtio_notify</code>/<code>virtio_pci_notify</code>， 最后通过KVM的ioctl投递中断？ 从代码路径上来看，后者明显路径更长，谁知道原因告诉我一下!!!。 <a href="https://patchwork.kernel.org/patch/9531577/">https://patchwork.kernel.org/patch/9531577/</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Once in virtio_notify_irqfd, once in virtio_queue_guest_notifier_read.</span><br><span class="line">Unfortunately, for virtio-blk + MSI + KVM + old Windows drivers we need the one in virtio_notify_irqfd.</span><br><span class="line">For virtio-net + vhost + INTx we need the one in virtio_queue_guest_notifier_read. </span><br><span class="line">这显然路径更长啊。 </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Ok，到这里virtio前后端通信机制已经明了，最后一个小节我们以virtio-net为例，梳理一下virtio中的部分核心代码流程。</p><h2 id="3-virtio核心代码分析，以virtio-net为例"><a href="#3-virtio核心代码分析，以virtio-net为例" class="headerlink" title="3. virtio核心代码分析，以virtio-net为例 "></a>3. virtio核心代码分析，以virtio-net为例 </h2><p>这里我们已virtio-net网卡为例，在没有使用vhost的情况下（网卡后端收发包都走QEMU处理）， 后端收发包走vhost的情况下有些不同，后面单独分析。</p><h3 id="3-1-前后端握手流程"><a href="#3-1-前后端握手流程" class="headerlink" title="3.1 前后端握手流程"></a>3.1 前后端握手流程</h3><p>QEM模拟PCI设备对GuestOS进行呈现，设备驱动加载的时候尝试去初始化设备。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"># 先在PCI总线上调用probe设备，调用了virtio_pci_probe，然后再virtio-bus上调用virtio_dev_probe</span><br><span class="line"># virtio_dev_probe最后调用到virtnet_probe</span><br><span class="line">pci_device_probe --&gt; local_pci_probe --&gt; virtio_pci_probe --&gt; register_virtio_device --&gt; </span><br><span class="line">device_register --&gt; device_add --&gt; bus_probe_device --&gt; device_initial_probe </span><br><span class="line">--&gt; __device_attach --&gt; bus_for_each_drv --&gt; __device_attach_driver --&gt; driver_probe_device --&gt; </span><br><span class="line">virtio_dev_probe --&gt; virtnet_probe</span><br><span class="line"># 在virtio_pci_probe里先尝试以virtio modern方式读取设备配置数据结构，如果失败则尝试virio legacy方式。</span><br><span class="line"># 对于virtio legacy，我们前面提到了virtio legacy协议规定设备的配置数据结构放在PCI BAR0里面。</span><br><span class="line">/* the PCI probing function */</span><br><span class="line">int virtio_pci_legacy_probe(struct virtio_pci_device *vp_dev)</span><br><span class="line">&#123;</span><br><span class="line">        rc = pci_request_region(pci_dev, 0, &quot;virtio-pci-legacy&quot;);  //将设备的BAR0映射到物理地址空间</span><br><span class="line">        vp_dev-&gt;ioaddr = pci_iomap(pci_dev, 0, 0);   //获得BAR0的内核地址</span><br><span class="line">&#125;</span><br><span class="line">#对于virtio modern，通过capability方式报告配置数据结构的位置，配置数据结构有5种类型。</span><br><span class="line">int virtio_pci_modern_probe(struct virtio_pci_device *vp_dev)</span><br><span class="line">&#123;</span><br><span class="line">        /* check for a common config: if not, use legacy mode (bar 0). */</span><br><span class="line">        common = virtio_pci_find_capability(pci_dev, VIRTIO_PCI_CAP_COMMON_CFG,</span><br><span class="line">                                            IORESOURCE_IO | IORESOURCE_MEM,</span><br><span class="line">                                            &amp;vp_dev-&gt;modern_bars);</span><br><span class="line">        /* If common is there, these should be too... */</span><br><span class="line">        isr = virtio_pci_find_capability(pci_dev, VIRTIO_PCI_CAP_ISR_CFG,</span><br><span class="line">                                         IORESOURCE_IO | IORESOURCE_MEM,</span><br><span class="line">                                         &amp;vp_dev-&gt;modern_bars);</span><br><span class="line">        notify = virtio_pci_find_capability(pci_dev, VIRTIO_PCI_CAP_NOTIFY_CFG,</span><br><span class="line">                                            IORESOURCE_IO | IORESOURCE_MEM,</span><br><span class="line">                                            &amp;vp_dev-&gt;modern_bars);</span><br><span class="line">                                            </span><br><span class="line">        /* Device capability is only mandatory for devices that have</span><br><span class="line">        * device-specific configuration.</span><br><span class="line">        */</span><br><span class="line">        device = virtio_pci_find_capability(pci_dev, VIRTIO_PCI_CAP_DEVICE_CFG,</span><br><span class="line">                                            IORESOURCE_IO | IORESOURCE_MEM,</span><br><span class="line">                                            &amp;vp_dev-&gt;modern_bars);</span><br><span class="line">        err = pci_request_selected_regions(pci_dev, vp_dev-&gt;modern_bars,</span><br><span class="line">                                            &quot;virtio-pci-modern&quot;);</span><br><span class="line">                                        sizeof(struct virtio_pci_common_cfg), 4,</span><br><span class="line">                                        0, sizeof(struct virtio_pci_common_cfg),</span><br><span class="line">                                        NULL);</span><br><span class="line">        // 将配virtio置结构所在的BAR空间MAP到内核地址空间里                                </span><br><span class="line">        vp_dev-&gt;common = map_capability(pci_dev, common,</span><br><span class="line">                                        sizeof(struct virtio_pci_common_cfg), 4,</span><br><span class="line">                                        0, sizeof(struct virtio_pci_common_cfg),</span><br><span class="line">                                        NULL);</span><br><span class="line">        ......                              </span><br><span class="line">&#125;</span><br><span class="line"># 接着来到virtio_dev_probe里面看下：</span><br><span class="line">static int virtio_dev_probe(struct device *_d)</span><br><span class="line">&#123;</span><br><span class="line">        /* We have a driver! */</span><br><span class="line">        virtio_add_status(dev, VIRTIO_CONFIG_S_DRIVER);     // 更新status bit，这里要写配置数据结构</span><br><span class="line">        /* Figure out what features the device supports. */</span><br><span class="line">        device_features = dev-&gt;config-&gt;get_features(dev);   // 查询后端支持哪些feature bits</span><br><span class="line">        </span><br><span class="line">        // feature set协商，取交集</span><br><span class="line">        err = virtio_finalize_features(dev); </span><br><span class="line">        </span><br><span class="line">        // 调用特定virtio设备的驱动程序probe，例如: virtnet_probe, virtblk_probe</span><br><span class="line">        err = drv-&gt;probe(dev); </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再看下<code>virtnet_probe</code>里面的一些关键的流程，这里包含了virtio-net网卡前端初始化的主要逻辑。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static int virtnet_probe(struct virtio_device *vdev)</span><br><span class="line">&#123;</span><br><span class="line">       // check后端是否支持多队列，并按情况创建队列</span><br><span class="line">       /* Allocate ourselves a network device with room for our info */</span><br><span class="line">        dev = alloc_etherdev_mq(sizeof(struct virtnet_info), max_queue_pairs);</span><br><span class="line">        </span><br><span class="line">        // 定义一个网络设备并配置一些属性，例如MAC地址</span><br><span class="line">        dev-&gt;ethtool_ops = &amp;virtnet_ethtool_ops;</span><br><span class="line">       SET_NETDEV_DEV(dev, &amp;vdev-&gt;dev);</span><br><span class="line"> </span><br><span class="line">        // 初始化virtqueue</span><br><span class="line">        err = init_vqs(vi);</span><br><span class="line">        </span><br><span class="line">        // 注册一个网络设备</span><br><span class="line">        err = register_netdev(dev);</span><br><span class="line">        </span><br><span class="line">        // 写状态位DRIVER_OK，告诉后端，前端已经ready</span><br><span class="line">        virtio_device_ready(vdev);</span><br><span class="line">        </span><br><span class="line">        // 将网卡up起来</span><br><span class="line">        netif_carrier_on(dev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中关键的流程是<code>init_vqs</code>，在<code>vp_find_vqs_msix</code>流程中会尝试去申请MSIx中断，这里前面已经有分析过了。 其中，”configuration changed” 中断服务程序<code>vp_config_changed</code>， virtqueue队列的中断服务程序是 <code>vp_vring_interrupt</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">init_vqs --&gt; virtnet_find_vqs --&gt; vi-&gt;vdev-&gt;config-&gt;find_vqs --&gt; vp_modern_find_vqs</span><br><span class="line">--&gt; vp_find_vqs --&gt; vp_find_vqs_msix</span><br><span class="line">static int vp_find_vqs_msix(struct virtio_device *vdev, unsigned nvqs,</span><br><span class="line">struct virtqueue *vqs[], vq_callback_t *callbacks[],</span><br><span class="line">const char * const names[], bool per_vq_vectors,</span><br><span class="line">const bool *ctx,</span><br><span class="line">struct irq_affinity *desc)</span><br><span class="line">&#123;</span><br><span class="line">        /* 为configuration change申请MSIx中断 */</span><br><span class="line">err = vp_request_msix_vectors(vdev, nvectors, per_vq_vectors,</span><br><span class="line">      per_vq_vectors ? desc : NULL);</span><br><span class="line">        for (i = 0; i &lt; nvqs; ++i) &#123;</span><br><span class="line"> // 创建队列 --&gt; vring_create_virtqueue --&gt; vring_create_virtqueue_split --&gt; vring_alloc_queue</span><br><span class="line">         vqs[i] = vp_setup_vq(vdev, queue_idx++, callbacks[i], names[i],</span><br><span class="line">                                ctx ? ctx[i] : false,</span><br><span class="line">                                msix_vec);</span><br><span class="line">// 每个队列申请一个MSIx中断</span><br><span class="line">                err = request_irq(pci_irq_vector(vp_dev-&gt;pci_dev, msix_vec),</span><br><span class="line">                                  vring_interrupt, 0,</span><br><span class="line">                                  vp_dev-&gt;msix_names[msix_vec],</span><br><span class="line">                                  vqs[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>vp_setup_vq</code>流程再往下走就开始分配共享内存页，至此建立起共享内存通信通道。 值得注意的是一路传下来的callbacks参数其实传入了发送队列和接收队列的回调处理函数， 好家伙，从<code>virtnet_find_vqs</code>一路传递到了<code>__vring_new_virtqueue</code>中最终赋值给了<code>vq-&gt;vq.callback</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">static struct virtqueue *vring_create_virtqueue_split(</span><br><span class="line">        unsigned int index,</span><br><span class="line">        unsigned int num,</span><br><span class="line">        unsigned int vring_align,</span><br><span class="line">        struct virtio_device *vdev,</span><br><span class="line">        bool weak_barriers,</span><br><span class="line">        bool may_reduce_num,</span><br><span class="line">        bool context,</span><br><span class="line">        bool (*notify)(struct virtqueue *),</span><br><span class="line">        void (*callback)(struct virtqueue *),</span><br><span class="line">        const char *name)</span><br><span class="line">&#123;</span><br><span class="line">       /* TODO: allocate each queue chunk individually */</span><br><span class="line">        for (; num &amp;&amp; vring_size(num, vring_align) &gt; PAGE_SIZE; num /= 2) &#123;</span><br><span class="line">// 申请物理页，地址赋值给queue</span><br><span class="line">                queue = vring_alloc_queue(vdev, vring_size(num, vring_align),</span><br><span class="line">                                          &amp;dma_addr,</span><br><span class="line">                                          GFP_KERNEL|__GFP_NOWARN|__GFP_ZERO);</span><br><span class="line">        &#125;</span><br><span class="line">        queue_size_in_bytes = vring_size(num, vring_align);</span><br><span class="line">        vring_init(&amp;vring, num, queue, vring_align); // 确定 descriptor table, available ring, used ring的位置。</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们看下如果<code>virtqueue</code>队列如果收到MSIx中断消息后，会调用哪个<code>hook</code>来处理？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">irqreturn_t vring_interrupt(int irq, void *_vq)</span><br><span class="line">&#123;</span><br><span class="line">        struct vring_virtqueue *vq = to_vvq(_vq);</span><br><span class="line">        if (!more_used(vq)) &#123;</span><br><span class="line">                pr_debug(&quot;virtqueue interrupt with no work for %p\n&quot;, vq);</span><br><span class="line">                return IRQ_NONE;</span><br><span class="line">        &#125;</span><br><span class="line">        if (unlikely(vq-&gt;broken))</span><br><span class="line">                return IRQ_HANDLED;</span><br><span class="line">        pr_debug(&quot;virtqueue callback for %p (%p)\n&quot;, vq, vq-&gt;vq.callback);</span><br><span class="line">        if (vq-&gt;vq.callback)</span><br><span class="line">                vq-&gt;vq.callback(&amp;vq-&gt;vq);</span><br><span class="line">        return IRQ_HANDLED;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(vring_interrupt);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不难想到中断服务程序里面会调用队列上的callback。 我们再回过头来看下<code>virtnet_find_vqs</code>，原来接受队列的回调函数是<code>skb_recv_done</code>，发送队列的回调函数是<code>skb_xmit_done</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">static int virtnet_find_vqs(struct virtnet_info *vi)</span><br><span class="line">&#123;</span><br><span class="line">       /* Allocate/initialize parameters for send/receive virtqueues */</span><br><span class="line">        for (i = 0; i &lt; vi-&gt;max_queue_pairs; i++) &#123;</span><br><span class="line">callbacks[rxq2vq(i)] = skb_recv_done;</span><br><span class="line">callbacks[txq2vq(i)] = skb_xmit_done;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>OK，这个小节就到这里。Are you clear ?</p><h3 id="3-2-virtio-net网卡收发在virtqueue上的实现"><a href="#3-2-virtio-net网卡收发在virtqueue上的实现" class="headerlink" title="3.2 virtio-net网卡收发在virtqueue上的实现"></a>3.2 virtio-net网卡收发在virtqueue上的实现</h3><p>这里以virtio-net为例（非vhost-net模式）来分析一下网卡收发报文在virtio协议上的具体实现。 virtio-net模式下网卡收发包的流程为：</p><ul><li>  收包：Hardware =&gt; Host Kernel =&gt; Qemu =&gt; Guest</li><li>  发包：Guest =&gt; Host Kernel =&gt; Qemu =&gt; Host Kernel =&gt; Hardware</li></ul><h4 id="3-2-1-virtio-net网卡发包"><a href="#3-2-1-virtio-net网卡发包" class="headerlink" title="3.2.1 virtio-net网卡发包"></a>3.2.1 virtio-net网卡发包</h4><p>前面我们看到virtio-net设备初始化的时候会创建一个<code>net_device</code>设备： <code>virtnet_probe</code> -&gt; <code>alloc_etherdev_mq</code>注册了<code>netdev_ops</code> = <code>&amp;virtnet_netdev</code>， 这里<code>virtnet_netdev</code>是网卡驱动的回调函数集合（收发包和参数设置）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">static const struct net_device_ops netdev_ops = &#123;</span><br><span class="line">        .ndo_open               = rio_open,</span><br><span class="line">        .ndo_start_xmit = start_xmit,</span><br><span class="line">        .ndo_stop               = rio_close,</span><br><span class="line">        .ndo_get_stats          = get_stats,</span><br><span class="line">        .ndo_validate_addr      = eth_validate_addr,</span><br><span class="line">        .ndo_set_mac_address    = eth_mac_addr,</span><br><span class="line">        .ndo_set_rx_mode        = set_multicast,</span><br><span class="line">        .ndo_do_ioctl           = rio_ioctl,</span><br><span class="line">        .ndo_tx_timeout         = rio_tx_timeout,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>网卡发包的时候调用<code>ndo_start_xmit</code>，将TCP/IP上层协议栈扔下来的数据发送出去。 对应到virtio网卡的回调函数就是<code>start_xmit</code>，从代码看就是将skb发送到virtqueue中， 然后调用virtqueue_kick通知qemu后端将数据包发送出去。</p><p>Guest内核里面的virtio-net驱动发包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">内核驱动 virtio_net.c</span><br><span class="line">start_xmit</span><br><span class="line">// 将skb放到virtqueue队列中</span><br><span class="line"> -&gt; xmit_skb -&gt; sg_init_table,virtqueue_add_outbuf -&gt; virtqueue_add</span><br><span class="line">// kick通知qemu后端去取</span><br><span class="line">virtqueue_kick_prepare &amp;&amp; virtqueue_notify </span><br><span class="line">// kick次数加1</span><br><span class="line">sq-&gt;stats.kicks++</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Guest Kick后端从KVM中VMExit出来退出到Qemu用户态（走的是ioeventfd）由Qemu去将数据发送出去。 大致调用的流程是： <code>virtio_queue_host_notifier_read</code> -&gt; <code>virtio_net_handle_tx_bh</code> -&gt; <code>virtio_net_flush_tx</code> -&gt; <code>virtqueue_pop</code>拿到发包(skb) -&gt; <code>qemu_sendv_packet_async</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Qemu代码virtio-net相关代码:</span><br><span class="line">virtio_queue_host_notifier_read -&gt; virtio_queue_notify_vq</span><br><span class="line">    -&gt; vq-&gt;handle_output -&gt; virtio_net_handle_tx_bh 队列注册的时候，回注册回调函数</span><br><span class="line">        -&gt; qemu_bh_schedule -&gt; virtio_net_tx_bh</span><br><span class="line">            -&gt; virtio_net_flush_tx</span><br><span class="line">        -&gt; virtqueue_pop</span><br><span class="line">-&gt; qemu_sendv_packet_async // 报文放到发送队列上，写tap设备的fd去发包</span><br><span class="line">    -&gt; tap_receive_iov -&gt; tap_write_packet</span><br><span class="line">    </span><br><span class="line">// 最后调用 tap_write_packet 把数据包发给tap设备投递出去</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-2-2-virtio-net网卡收包"><a href="#3-2-2-virtio-net网卡收包" class="headerlink" title="3.2.2 virtio-net网卡收包"></a>3.2.2 virtio-net网卡收包</h4><p>网卡收包的时候，tap设备先收到报文，对应的virtio-net网卡tap设备fd变为可读， Qemu主循环收到POLL_IN事件调用回调函数收包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tap_send -&gt; qemu_send_packet_async -&gt; qemu_send_packet_async_with_flags</span><br><span class="line">    -&gt; qemu_net_queue_send</span><br><span class="line">        -&gt; qemu_net_queue_deliver</span><br><span class="line">    -&gt; qemu_deliver_packet_iov</span><br><span class="line">        -&gt; nc_sendv_compat</span><br><span class="line">    -&gt; virtio_net_receive</span><br><span class="line">        -&gt; virtio_net_receive_rcu</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>virtio-net网卡收报最终调用了<code>virtio_net_receive_rcu</code>， 和发包类似都是调用<code>virtqueue_pop</code>从前端获取virtqueue element， 将报文数据填充到vring中然后<code>virtio_notify</code>注入中断通知前端驱动取结果。</p><p>这里不得不吐槽一下，为啥收包函数取名要叫<code>tap_send</code>。</p><h2 id="4-参考文献"><a href="#4-参考文献" class="headerlink" title="4. 参考文献 "></a>4. 参考文献 </h2><ol><li> <a href="https://docs.oasis-open.org/virtio/virtio/v1.1/csprd01/virtio-v1.1-csprd01.html">virtio spec v1.1</a></li><li> <a href="https://ozlabs.org/~rusty/virtio-spec/virtio-paper.pdf">Towards a De-Facto Standard For Virtual</a></li><li> <a href="https://github.com/qemu/qemu/blob/master/hw/net/virtio-net.c">https://github.com/qemu/qemu/blob/master/hw/net/virtio-net.c</a></li><li> <a href="https://github.com/torvalds/linux/blob/master/drivers/net/virtio/_net.c">https://github.com/torvalds/linux/blob/master/drivers/net/virtio\_net.c</a></li></ol>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Virtio&quot;&gt;&lt;a href=&quot;#Virtio&quot; class=&quot;headerlink&quot; title=&quot;Virtio &quot;&gt;&lt;/a&gt;Virtio &lt;/h2&gt;&lt;p&gt;半虚拟化设备(Virtio Device)在当前云计算虚拟化场景下已经得到了非常广泛的应用， 并且现在也有越来越多的物理设备也开始支持Virtio协议，即所谓的&lt;code&gt;Virtio Offload&lt;/code&gt;， &lt;/p&gt;</summary>
    
    
    
    <category term="虚拟化" scheme="https://rma-shuyu.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="Virtio" scheme="https://rma-shuyu.github.io/tags/Virtio/"/>
    
  </entry>
  
  <entry>
    <title>runlevel设置</title>
    <link href="https://rma-shuyu.github.io/2022/06/21/runlevel%E8%AE%BE%E7%BD%AE/"/>
    <id>https://rma-shuyu.github.io/2022/06/21/runlevel%E8%AE%BE%E7%BD%AE/</id>
    <published>2022-06-21T12:25:15.000Z</published>
    <updated>2023-09-09T10:33:02.415Z</updated>
    
    <content type="html"><![CDATA[<h1 id="runlevel"><a href="#runlevel" class="headerlink" title="runlevel"></a>runlevel</h1><ul><li>  linux操作系统自从开始启动至启动完毕需要经历几个不同的阶段，这几个阶段就叫做runlevel</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;Runlevels&quot; are an obsolete way to start and stop groups of services used in SysV init. </span><br></pre></td></tr></table></figure><span id="more"></span><p>使用runlevel查看当前系统运行的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">u20@u20:~$ runlevel --help</span><br><span class="line">runlevel [OPTIONS...]</span><br><span class="line"></span><br><span class="line">Prints the previous and current runlevel of the init system.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">     --help      Show this help</span><br><span class="line"></span><br><span class="line">See the runlevel(8) man page for details.</span><br><span class="line"></span><br><span class="line">Mapping between runlevels and systemd targets</span><br><span class="line">       ┌─────────┬───────────────────┐</span><br><span class="line">       │Runlevel │ Target            │</span><br><span class="line">       ├─────────┼───────────────────┤</span><br><span class="line">       │0        │ poweroff.target   │</span><br><span class="line">       ├─────────┼───────────────────┤</span><br><span class="line">       │1        │ rescue.target     │</span><br><span class="line">       ├─────────┼───────────────────┤</span><br><span class="line">       │2, 3, 4  │ multi-user.target │</span><br><span class="line">       ├─────────┼───────────────────┤</span><br><span class="line">       │5        │ graphical.target  │</span><br><span class="line">       ├─────────┼───────────────────┤</span><br><span class="line">       │6        │ reboot.target     │</span><br><span class="line">       ├─────────┼───────────────────┤</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul><li>0 停机</li><li>1 单用户模式</li><li>2 多用户，没有 NFS</li><li>3 完全多用户模式 （命令行）</li><li>4 没有用到</li><li>5 图形界面</li><li>6 重新启动</li><li>S s Single user mode<br>  用到最多的时3和5还有0</li><li>系统默认安装后，若有图形界面则，默认进入 level 5</li><li>level 3 是最常用的命令行模式</li><li>关机时为level 0</li><li>更改密码或修复系统用到单用户模式level 0</li></ul><h1 id="init"><a href="#init" class="headerlink" title="init"></a>init</h1><ul><li>  init命令是Linux下的进程初始化工具，init进程是所有Linux进程的父进程，它的进程号为1。init命令是Linux操作系统中不可缺少的程序之一，init进程是Linux内核引导运行的，是系统中的第一个进程。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemd, init - systemd system and service manager</span><br></pre></td></tr></table></figure><h2 id="使用init切换用户模式"><a href="#使用init切换用户模式" class="headerlink" title="使用init切换用户模式"></a>使用init切换用户模式</h2><ul><li>  init 0 执行关机动作，需root权限</li><li>  init 3 切换至命令行界面</li><li>  init 5 切换至图形界面</li><li>  init -s 切换至单用户模式</li></ul><h2 id="设置Linux启动时的runlevel"><a href="#设置Linux启动时的runlevel" class="headerlink" title="设置Linux启动时的runlevel"></a>设置Linux启动时的runlevel</h2><ul><li>  CentOS</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[22:09:38 root@C8-3-55 ~]#cat /etc/inittab</span><br><span class="line"># inittab is no longer used.</span><br><span class="line">#</span><br><span class="line"># ADDING CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM.</span><br><span class="line">#</span><br><span class="line"># Ctrl-Alt-Delete is handled by /usr/lib/systemd/system/ctrl-alt-del.target</span><br><span class="line">#</span><br><span class="line"># systemd uses &#x27;targets&#x27; instead of runlevels. By default, there are two main targets:</span><br><span class="line">#</span><br><span class="line"># multi-user.target: analogous to runlevel 3</span><br><span class="line"># graphical.target: analogous to runlevel 5</span><br><span class="line">#</span><br><span class="line"># To view current default target, run:</span><br><span class="line"># systemctl get-default</span><br><span class="line">#</span><br><span class="line"># To set a default target, run:</span><br><span class="line"># systemctl set-default TARGET.target</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>  Ubuntu</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">u20@u20:~$ cat /run/utmp</span><br><span class="line">~~~reboot5.4.0-42-generic&#123;?Y`35~~~runlevel5.4.0-42-genericGY`®7¤tty1tty1tty1LOGIN¤?Y`=¶pts/0ts/0u2010.0.0.1W@Y`^® </span><br><span class="line">Epts/1ts/1u2010.0.0.1x@Y`</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面那个就是看看，配置文件在哪我暂时没找到，等找到了再发过来。</p><ul><li>  设置开机命令行</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable multi-user.target</span><br><span class="line">sudo systemctl set-default multi-user.target</span><br><span class="line">或者</span><br><span class="line">sudo systemctl set-default runlevel3.target</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>-设置开机图形</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl enable graphical.target</span><br><span class="line">sudo systemctl set-default graphical.target</span><br><span class="line">或者</span><br><span class="line">sudo systemctl set-default graphical.target</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Ubuntu-20-04-设置开机启动由图形界面改为直接进命令行"><a href="#Ubuntu-20-04-设置开机启动由图形界面改为直接进命令行" class="headerlink" title="Ubuntu 20.04 设置开机启动由图形界面改为直接进命令行"></a>Ubuntu 20.04 设置开机启动由图形界面改为直接进命令行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">u20@u20:~$ cat /etc/init/lightdm.conf </span><br><span class="line">cat: /etc/init/lightdm.conf: No such file or directory</span><br><span class="line">u20@u20:~$ sudo systemctl enable multi-user.target</span><br><span class="line">[sudo] password for u20: </span><br><span class="line">The unit files have no installation config (WantedBy=, RequiredBy=, Also=,</span><br><span class="line">Alias= settings in the [Install] section, and DefaultInstance= for template</span><br><span class="line">units). This means they are not meant to be enabled using systemctl.</span><br><span class="line"> </span><br><span class="line">Possible reasons for having this kind of units are:</span><br><span class="line">• A unit may be statically enabled by being symlinked from another unit&#x27;s</span><br><span class="line">  .wants/ or .requires/ directory.</span><br><span class="line">• A unit&#x27;s purpose may be to act as a helper for some other unit which has</span><br><span class="line">  a requirement dependency on it.</span><br><span class="line">• A unit may be started when needed via activation (socket, path, timer,</span><br><span class="line">  D-Bus, udev, scripted systemctl call, ...).</span><br><span class="line">• In case of template units, the unit is meant to be enabled with some</span><br><span class="line">  instance name specified.</span><br><span class="line">u20@u20:~$ sudo systemctl set-default multi-user.target</span><br><span class="line">Created symlink /etc/systemd/system/default.target → /lib/systemd/system/multi-user.target. ##实际上是更改了软链接</span><br><span class="line">u20@u20:~$ runlevel</span><br><span class="line">N 3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>经过实验发现，Ubuntu 20启动runlevel修改方式并不保存在配置文件中，而是通过更改软连接的方式实现了启动runlevel的修改。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;runlevel&quot;&gt;&lt;a href=&quot;#runlevel&quot; class=&quot;headerlink&quot; title=&quot;runlevel&quot;&gt;&lt;/a&gt;runlevel&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;  linux操作系统自从开始启动至启动完毕需要经历几个不同的阶段，这几个阶段就叫做runlevel&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;quot;Runlevels&amp;quot; are an obsolete way to start and stop groups of services used in SysV init. &lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="LINUX" scheme="https://rma-shuyu.github.io/categories/LINUX/"/>
    
    
    <category term="runlevel" scheme="https://rma-shuyu.github.io/tags/runlevel/"/>
    
  </entry>
  
  <entry>
    <title>ip netns</title>
    <link href="https://rma-shuyu.github.io/2022/06/20/ip-netns/"/>
    <id>https://rma-shuyu.github.io/2022/06/20/ip-netns/</id>
    <published>2022-06-20T12:25:15.000Z</published>
    <updated>2023-09-09T10:33:02.411Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、命令介绍"><a href="#一、命令介绍" class="headerlink" title="一、命令介绍"></a>一、命令介绍</h2><p>  ip netns 命令是用来管理 <strong>网络命名空间</strong> 的，网络命名空间可以实现 <strong>网络隔离</strong>。每个网络命名空间都提供了一个完全独立的网络协议栈，包括网络设备接口、IPV4 和 IPV6 协议栈、IP路由表、防火墙规则、端口、sockets 等。像 docker 就是利用 Linux 的网络命名空间来实现容器网络的隔离。</p><span id="more"></span><table><thead><tr><th>用法</th><th>含义</th></tr></thead><tbody><tr><td>ip netns list</td><td>列出网络命名空间。此命令显示的是 “/var/run/netns” 中的所有网络命名空间。</td></tr><tr><td>ip netns add NAME</td><td>添加网络命名空间</td></tr><tr><td>ip [-all] netns delete [NAME]</td><td>删除网络命名空间</td></tr><tr><td>ip [-all] netns exec [NAME] cmd …</td><td>在指定的网络命名空间中执行命令</td></tr><tr><td>ip netns set NAME NETNSID</td><td>给网络命名空间分配id</td></tr><tr><td>ip netns identify [PID]</td><td>查看进程的网络命名空间</td></tr><tr><td>ip netns monitor</td><td>监控对网络命名空间的操作</td></tr><tr><td>ip netns pids NAME</td><td>查找使用此网络命名空间并将其作为主要网络命名空间的进程。此命令会从 /proc 目录中遍历。</td></tr></tbody></table><h2 id="二、示例演示"><a href="#二、示例演示" class="headerlink" title="二、示例演示"></a>二、示例演示</h2><p>添加并列出network namespace，随后删除所有的network namespace。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@cp:~# ip netns add test1</span><br><span class="line">root@cp:~# ip netns add test2</span><br><span class="line">root@cp:~# ip netns ls</span><br><span class="line">test2</span><br><span class="line">test1</span><br><span class="line">root@cp:~# ip -all netns del</span><br><span class="line">root@cp:~# ip netns ls</span><br></pre></td></tr></table></figure><p>创建的网络命名空间是可以在 /var/run/netns 路径下看到。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@cp:~# cd /var/run/netns/</span><br><span class="line">root@cp:/var/run/netns# ls</span><br><span class="line">test1  test2</span><br></pre></td></tr></table></figure><p>使用 exec 命令在网络命名空间中执行命令，查看 test1 的网卡信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@cp:~# ip netns exec test1 ip a</span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br></pre></td></tr></table></figure><p>网络命名空间除了网络是虚拟的以外，文件系统完全和当前系统共享，也就是说所有本地可以使用的命令都可以在网络命名空间中使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@cp:~# ip netns exec test1 ls</span><br><span class="line">app  backup.tar  cp1  perf.data  registry_latest.tar  test  test_0.1.tar  test-bind  ubuntu-test.tar</span><br><span class="line">root@cp:~# ip netns exec test1 pwd</span><br><span class="line">/root</span><br></pre></td></tr></table></figure><p>进入网络命名空间可以用 exec 执行 bash 即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@cp:~# ip netns exec test1 bash</span><br><span class="line">root@cp:~# ip a</span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br></pre></td></tr></table></figure><p>–all 选项可以在所有网络命名空间中执行命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@cp:~# ip -all netns exec ip a</span><br><span class="line"></span><br><span class="line">netns: test2</span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line"></span><br><span class="line">netns: test1</span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br></pre></td></tr></table></figure><p> <br>  使用 ip netns set NAME NETNSID 给网络命名空间分配ID。该ID仅在当前网络命名空间中有效，如果指定了关键字“ auto”，则将会自动选择一个可用的nsid。内核将在某些 netlink 消息中使用此ID，如果在内核需要时未分配ID，则它将由内核自动分配。注意 ID 分配后，将无法更改。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@cp:~# ip netns add cp</span><br><span class="line">root@cp:~# ip netns </span><br><span class="line">cp</span><br><span class="line">root@cp:~# ip netns set cp 6</span><br><span class="line">root@cp:~# ip netns </span><br><span class="line">cp (id: 6)</span><br></pre></td></tr></table></figure><p> <br>使用 ip netns monitor 监控网络命名空间的添加和删除事件，只能监控添加和删除。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@cp:~# ip netns del cp</span><br><span class="line">root@cp:~# ip netns add cp</span><br></pre></td></tr></table></figure><p>另一个终端同步反馈的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@cp:~# ip netns monitor</span><br><span class="line">delete cp</span><br><span class="line">add cp</span><br></pre></td></tr></table></figure><p> <br>  以下两个示例以 docker 容器为例，在没做一些设置前，使用 ip netns 命令是无法管理分配给 docker 容器的网络命名空间，至于如何使用 ip netns 命令管理分配给容器的网络命名空间，下面扩展中有介绍到。在做下面示例时请先做好以下设置。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@cp:~# docker run -itd --name test centos</span><br><span class="line">7ec02643b32d1c53b39126f6d603b72a402597d938ddef35e7bdb4076763c68f</span><br><span class="line">root@cp:~# ip netns list    # 查看为空</span><br><span class="line">root@cp:~# </span><br><span class="line">root@cp:~# ln -s /proc/11421/ns/net /var/run/netns/test</span><br><span class="line">root@cp:~# ip netns list</span><br><span class="line">test (id: 0)</span><br></pre></td></tr></table></figure><p>  使用 ip netns identify 命令查看容器 test 的网络命名空间。使用 ip netns pids 命令查找使用该网络命名空间的进程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@cp:~# ip netns identify 11421</span><br><span class="line">test</span><br><span class="line">root@cp:~# ip netns pids test</span><br><span class="line">11421</span><br></pre></td></tr></table></figure><h2 id="三、扩展"><a href="#三、扩展" class="headerlink" title="三、扩展"></a>三、扩展</h2><h3 id="1、网络命名空间的连接"><a href="#1、网络命名空间的连接" class="headerlink" title="1、网络命名空间的连接"></a>1、网络命名空间的连接</h3><p>  创建一对 veth pair 虚拟网络设备接口，然后将其分别分配给两个网络命名空间，去连接两个网络命名空间。<br>  注：veth-pair 是一对的虚拟网络设备接口，它都是成对出现的，所以它常常充当着一个桥梁，我们可以用它实现 “网络命名空间之间的连接”、“Docker 容器之间的连接” 、“Docker 容器和网桥间的连接” 等等。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">root@cp:~# ip link add name net1 type veth peer name net2</span><br><span class="line">root@cp:~# ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens33: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000</span><br><span class="line">    link/ether 00:0c:29:a9:42:0e brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 192.168.18.25/24 brd 192.168.18.255 scope global noprefixroute ens33</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::c75c:21df:8db2:598e/64 scope link noprefixroute </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">3: docker0: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state DOWN group default </span><br><span class="line">    link/ether 02:42:2c:d7:37:17 brd ff:ff:ff:ff:ff:ff</span><br><span class="line">    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::42:2cff:fed7:3717/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">19: net2@net1: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/ether e2:3c:d5:80:93:3c brd ff:ff:ff:ff:ff:ff</span><br><span class="line">20: net1@net2: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/ether f2:f1:b8:34:4a:9a brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure><p>将两个虚拟接口迁移到对应的网络命名空间里。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@cp:~# ip link set net1 netns test1</span><br><span class="line">root@cp:~# ip link set net2 netns test2</span><br><span class="line">root@cp:~# ip -all netns exec ip a</span><br><span class="line"></span><br><span class="line">netns: test2</span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">19: net2@if20: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/ether e2:3c:d5:80:93:3c brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line"></span><br><span class="line">netns: test1</span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">20: net1@if19: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/ether f2:f1:b8:34:4a:9a brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br></pre></td></tr></table></figure><p>给两块网卡设置ip并启动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">root@cp:~# ip netns exec test1 ip addr add local 192.168.100.1/24 dev net1</span><br><span class="line">root@cp:~# ip netns exec test2 ip addr add local 192.168.100.2/24 dev net2</span><br><span class="line">root@cp:~# ip netns exec test1 ifconfig net2 up</span><br><span class="line">root@cp:~# ip netns exec test2 ifconfig net2 up</span><br><span class="line">root@cp:~# ip -all netns exec ip a</span><br><span class="line"></span><br><span class="line">netns: test2</span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">19: net2@if20: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000</span><br><span class="line">    link/ether e2:3c:d5:80:93:3c brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 192.168.100.2/24 scope global net2</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::e03c:d5ff:fe80:933c/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line"></span><br><span class="line">netns: test1</span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">20: net1@if19: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default qlen 1000</span><br><span class="line">    link/ether f2:f1:b8:34:4a:9a brd ff:ff:ff:ff:ff:ff link-netnsid 1</span><br><span class="line">    inet 192.168.100.1/24 scope global net1</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::f0f1:b8ff:fe34:4a9a/64 scope link </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure><p>ping 测试通信</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@cp:~# ip netns exec test1 ping 192.168.100.2</span><br><span class="line">PING 192.168.100.2 (192.168.100.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 192.168.100.2: icmp_seq=1 ttl=64 time=0.275 ms</span><br><span class="line">64 bytes from 192.168.100.2: icmp_seq=2 ttl=64 time=0.047 ms</span><br><span class="line">64 bytes from 192.168.100.2: icmp_seq=3 ttl=64 time=0.043 ms</span><br><span class="line">^C</span><br><span class="line">--- 192.168.100.2 ping statistics ---</span><br><span class="line">3 packets transmitted, 3 received, 0% packet loss, time 2008ms</span><br><span class="line">rtt min/avg/max/mdev = 0.043/0.121/0.275/0.109 ms</span><br></pre></td></tr></table></figure><h3 id="2、关于docker网络命名空间的问题"><a href="#2、关于docker网络命名空间的问题" class="headerlink" title="2、关于docker网络命名空间的问题"></a>2、关于docker网络命名空间的问题</h3><p>  当 docker 容器被创建出来后，你会发现使用 ip netns 命令无法看到容器对应的网络命名空间。这是因为 ip netns 命令是从 /var/run/netns 文件夹中读取内容的，而 docker 容器的网络命名空间不是在 /var/run/netns 下，而是位于 /proc/[pid]/ns/net。想要使用 ip netns 命令去管理 docker 容器的网络命名空间，就需要将它的网络命名空间显示在 /var/run/netns 目录下，那就要先找到容器的网络命名空间在哪里，然后做一个软链接即可。</p><p>首先查询容器的PID。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@cp:~# docker inspect --format &#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27; web</span><br><span class="line">4775</span><br></pre></td></tr></table></figure><p>然后创建软链接，建议指定在 /var/run/netns/ 中的名字，因为每个容器都是net。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@cp:~# ln -s /proc/4775/ns/net /var/run/netns/web</span><br><span class="line">root@cp:~# ip netns ls</span><br><span class="line">web (id: 0)</span><br><span class="line">test2 (id: 2)</span><br><span class="line">test1 (id: 1)</span><br></pre></td></tr></table></figure><p>此时就可以用 ip netns 命令去管理 docker 容器的网络命名空间了。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;一、命令介绍&quot;&gt;&lt;a href=&quot;#一、命令介绍&quot; class=&quot;headerlink&quot; title=&quot;一、命令介绍&quot;&gt;&lt;/a&gt;一、命令介绍&lt;/h2&gt;&lt;p&gt;  ip netns 命令是用来管理 &lt;strong&gt;网络命名空间&lt;/strong&gt; 的，网络命名空间可以实现 &lt;strong&gt;网络隔离&lt;/strong&gt;。每个网络命名空间都提供了一个完全独立的网络协议栈，包括网络设备接口、IPV4 和 IPV6 协议栈、IP路由表、防火墙规则、端口、sockets 等。像 docker 就是利用 Linux 的网络命名空间来实现容器网络的隔离。&lt;/p&gt;</summary>
    
    
    
    <category term="LINUX" scheme="https://rma-shuyu.github.io/categories/LINUX/"/>
    
    
    <category term="netns" scheme="https://rma-shuyu.github.io/tags/netns/"/>
    
  </entry>
  
  <entry>
    <title>Linux Bridge 详解</title>
    <link href="https://rma-shuyu.github.io/2022/06/19/Linux-Bridge-%E8%AF%A6%E8%A7%A3/"/>
    <id>https://rma-shuyu.github.io/2022/06/19/Linux-Bridge-%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-06-19T12:25:15.000Z</published>
    <updated>2023-09-09T10:33:02.403Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux-Bridge-详解"><a href="#Linux-Bridge-详解" class="headerlink" title="Linux Bridge 详解"></a><strong>Linux Bridge 详解</strong></h2><p>Linux Bridge（网桥）是用纯软件实现的虚拟交换机，有着和物理交换机相同的功能，例如二层交换，MAC地址学习等。因此我们可以把tun/tap，veth pair等设备绑定到网桥上，就像是把设备连接到物理交换机上一样。此外它和veth pair、tun/tap一样，也是一种虚拟网络设备，具有虚拟设备的所有特性，例如配置IP，MAC地址等。</p><span id="more"></span><p>Linux Bridge通常是搭配KVM、docker等虚拟化技术一起使用的，用于构建虚拟网络，因为此教程不涉及虚拟化技术，我们就使用前面学习过的netns来模拟虚拟设备。</p><h2 id="如何使用Linux-Bridge？"><a href="#如何使用Linux-Bridge？" class="headerlink" title="如何使用Linux Bridge？"></a><strong>如何使用Linux Bridge？</strong></h2><p>操作网桥有多种方式，在这里我们介绍一下通过<strong>bridge-utils</strong>来操作，由于它不是Linux系统自带的工具，因此需要我们手动来安装它。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># centos</span><br><span class="line">yum install -y bridge-utils</span><br><span class="line"># ubuntu</span><br><span class="line">apt-get install -y bridge-utils</span><br></pre></td></tr></table></figure><p>使用<code>brctl help</code>查看使用帮助</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">never heard of command [help]</span><br><span class="line">Usage: brctl [commands]</span><br><span class="line">commands:</span><br><span class="line"> addbr      &lt;bridge&gt;  add bridge</span><br><span class="line"> delbr      &lt;bridge&gt;  delete bridge</span><br><span class="line"> addif      &lt;bridge&gt; &lt;device&gt; add interface to bridge</span><br><span class="line"> delif      &lt;bridge&gt; &lt;device&gt; delete interface from bridge</span><br><span class="line"> hairpin    &lt;bridge&gt; &lt;port&gt; &#123;on|off&#125; turn hairpin on/off</span><br><span class="line"> setageing  &lt;bridge&gt; &lt;time&gt;  set ageing time</span><br><span class="line"> setbridgeprio &lt;bridge&gt; &lt;prio&gt;  set bridge priority</span><br><span class="line"> setfd      &lt;bridge&gt; &lt;time&gt;  set bridge forward delay</span><br><span class="line"> sethello   &lt;bridge&gt; &lt;time&gt;  set hello time</span><br><span class="line"> setmaxage  &lt;bridge&gt; &lt;time&gt;  set max message age</span><br><span class="line"> setpathcost &lt;bridge&gt; &lt;port&gt; &lt;cost&gt; set path cost</span><br><span class="line"> setportprio &lt;bridge&gt; &lt;port&gt; &lt;prio&gt; set port priority</span><br><span class="line"> show       [ &lt;bridge&gt; ]  show a list of bridges</span><br><span class="line"> showmacs   &lt;bridge&gt;  show a list of mac addrs</span><br><span class="line"> showstp    &lt;bridge&gt;  show bridge stp info</span><br><span class="line"> stp        &lt;bridge&gt; &#123;on|off&#125; turn stp on/off</span><br></pre></td></tr></table></figure><p>常用命令如</p><p>新建一个网桥：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brctl addbr &lt;bridge&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>添加一个设备（例如<code>eth0</code>）到网桥：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brctl addif &lt;bridge&gt; eth0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>显示当前存在的网桥及其所连接的网络端口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brctl show</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>启动网桥：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip link set &lt;bridge&gt; up</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>删除网桥，需要先关闭它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip link set &lt;bridge&gt; down</span><br><span class="line">brctl delbr &lt;bridge&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>或者使用<code>ip link del</code> 命令直接删除网桥</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip link del &lt;bridge&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>增加Linux Bridge时会自动增加一个同名虚拟网卡在宿主机器上，因此我们可以通过<code>ip link</code>命令操作这个虚拟网卡，实际上也就是操作网桥，并且只有当这个虚拟网卡状态处于<strong>up</strong>的时候，网桥才会转发数据。  </p></blockquote><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a><strong>实验</strong></h2><p>Linux Bridge最主要的功能就是二层交换，是对现实世界二层交换机的模拟，网络拓扑如下图：</p><p><img src="3405a1b5caedb3c915729a35ce3117f963d3d53169d477d00249421f55aa6e70.png" alt="图 1">  </p><p>我们建立了一个网桥，三个netns，三对veth pair，分别一端在netns中，另一端连接在网桥上，为了简化拓扑，我去除了netns中的tap设备，将IP直接配置在veth上。</p><blockquote><p>veth设备不仅仅可以可以充当“网线”，同时它也可以当作虚拟网卡来使用。  </p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"># 添加网桥</span><br><span class="line">brctl addbr br0</span><br><span class="line"># 启动网桥</span><br><span class="line">ip link set br0 up</span><br><span class="line"># 配置网桥ip</span><br><span class="line">ip addr add 10.0.0.1/24 dev br0</span><br><span class="line"></span><br><span class="line"># 新增三个netns</span><br><span class="line">ip netns add ns0</span><br><span class="line">ip netns add ns1</span><br><span class="line">ip netns add ns2</span><br><span class="line"></span><br><span class="line"># 新增两对veth</span><br><span class="line">ip link add veth0-ns type veth peer name veth0-br</span><br><span class="line">ip link add veth1-ns type veth peer name veth1-br</span><br><span class="line">ip link add veth2-ns type veth peer name veth2-br</span><br><span class="line"></span><br><span class="line"># 将veth的一端移动到netns中</span><br><span class="line">ip link set veth0-ns netns ns0</span><br><span class="line">ip link set veth1-ns netns ns1</span><br><span class="line">ip link set veth2-ns netns ns2</span><br><span class="line"></span><br><span class="line"># 将netns中的本地环回和veth启动并配置IP，设置网关为br0地址</span><br><span class="line">ip netns exec ns0 ip link set lo up</span><br><span class="line">ip netns exec ns0 ip link set veth0-ns up</span><br><span class="line">ip netns exec ns0 ip addr add 10.0.0.1/24 dev veth0-ns</span><br><span class="line">ip netns exec ns0 ip route add default via 10.0.0.10</span><br><span class="line"></span><br><span class="line">ip netns exec ns1 ip link set lo up</span><br><span class="line">ip netns exec ns1 ip link set veth1-ns up</span><br><span class="line">ip netns exec ns1 ip addr add 10.0.0.2/24 dev veth1-ns</span><br><span class="line">ip netns exec ns1 ip route add default via 10.0.0.10</span><br><span class="line"></span><br><span class="line">ip netns exec ns2 ip link set lo up</span><br><span class="line">ip netns exec ns2 ip link set veth2-ns up</span><br><span class="line">ip netns exec ns2 ip addr add 10.0.0.3/24 dev veth2-ns</span><br><span class="line">ip netns exec ns2 ip route add default via 10.0.0.10</span><br><span class="line"></span><br><span class="line"># 将veth的另一端启动并挂载到网桥上</span><br><span class="line">ip link set veth0-br up</span><br><span class="line">ip link set veth1-br up</span><br><span class="line">ip link set veth2-br up</span><br><span class="line">brctl addif br0 veth0-br</span><br><span class="line">brctl addif br0 veth1-br</span><br><span class="line">brctl addif br0 veth2-br</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一般linux会把bridge的fowrding禁用，所以还需要进行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -A FORWARD -i br0 -j ACCEPT</span><br></pre></td></tr></table></figure><p>测试网络连通性</p><p>使用<code>ip netns exec ns0 ping 10.0.0.10</code>在命名空间ns0中测试与网桥br0的10.0.0.10的网络连通性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PING 10.0.0.10 (10.0.0.10) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.0.0.10: icmp_seq=1 ttl=64 time=0.066 ms</span><br><span class="line">64 bytes from 10.0.0.10: icmp_seq=2 ttl=64 time=0.035 ms</span><br><span class="line">64 bytes from 10.0.0.10: icmp_seq=3 ttl=64 time=0.059 ms</span><br><span class="line">64 bytes from 10.0.0.10: icmp_seq=4 ttl=64 time=0.023 ms</span><br><span class="line">64 bytes from 10.0.0.10: icmp_seq=5 ttl=64 time=0.021 ms</span><br><span class="line">^C</span><br><span class="line">--- 10.0.0.10 ping statistics ---</span><br><span class="line">5 packets transmitted, 5 received, 0% packet loss, time 4103ms</span><br><span class="line">rtt min/avg/max/mdev = 0.021/0.040/0.066/0.020 ms</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用<code>ip netns exec ns0 ping 10.0.0.2</code>在命名空间ns0中测试与ns1的10.0.0.2的网络连通性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PING 10.0.0.2 (10.0.0.2) 56(84) bytes of data.</span><br><span class="line">64 bytes from 10.0.0.2: icmp_seq=1 ttl=64 time=0.032 ms</span><br><span class="line">64 bytes from 10.0.0.2: icmp_seq=2 ttl=64 time=0.058 ms</span><br><span class="line">64 bytes from 10.0.0.2: icmp_seq=3 ttl=64 time=0.052 ms</span><br><span class="line">64 bytes from 10.0.0.2: icmp_seq=4 ttl=64 time=0.044 ms</span><br><span class="line">^C</span><br><span class="line">--- 10.0.0.2 ping statistics ---</span><br><span class="line">4 packets transmitted, 4 received, 0% packet loss, time 54ms</span><br><span class="line">rtt min/avg/max/mdev = 0.032/0.046/0.058/0.011 ms</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Linux-Bridge-详解&quot;&gt;&lt;a href=&quot;#Linux-Bridge-详解&quot; class=&quot;headerlink&quot; title=&quot;Linux Bridge 详解&quot;&gt;&lt;/a&gt;&lt;strong&gt;Linux Bridge 详解&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;Linux Bridge（网桥）是用纯软件实现的虚拟交换机，有着和物理交换机相同的功能，例如二层交换，MAC地址学习等。因此我们可以把tun/tap，veth pair等设备绑定到网桥上，就像是把设备连接到物理交换机上一样。此外它和veth pair、tun/tap一样，也是一种虚拟网络设备，具有虚拟设备的所有特性，例如配置IP，MAC地址等。&lt;/p&gt;</summary>
    
    
    
    <category term="LINUX" scheme="https://rma-shuyu.github.io/categories/LINUX/"/>
    
    
    <category term="Bridge" scheme="https://rma-shuyu.github.io/tags/Bridge/"/>
    
  </entry>
  
  <entry>
    <title>brctl命令简介</title>
    <link href="https://rma-shuyu.github.io/2022/06/18/brctl%E5%91%BD%E4%BB%A4%E7%AE%80%E4%BB%8B/"/>
    <id>https://rma-shuyu.github.io/2022/06/18/brctl%E5%91%BD%E4%BB%A4%E7%AE%80%E4%BB%8B/</id>
    <published>2022-06-18T12:25:15.000Z</published>
    <updated>2023-09-09T10:33:02.407Z</updated>
    
    <content type="html"><![CDATA[<h2 id="命令安装"><a href="#命令安装" class="headerlink" title="命令安装"></a>命令安装</h2><p>Centos系统</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install bridge-utils</span><br></pre></td></tr></table></figure><span id="more"></span><p>Ubuntu系统</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get  install bridge-utils</span><br></pre></td></tr></table></figure><h2 id="命令介绍"><a href="#命令介绍" class="headerlink" title="命令介绍"></a>命令介绍</h2><table><thead><tr><th>参数</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>addbr <code>&lt;bridge&gt;</code></td><td>创建网桥</td><td>brctl addbr br10</td></tr><tr><td>delbr <code>&lt;bridge&gt;</code></td><td>删除网桥</td><td>brctl delbr br10</td></tr><tr><td>addif <code>&lt;bridge&gt;</code> <code>&lt;device&gt;</code></td><td>将网卡接口接入网桥</td><td>brctl addif br10 eth0</td></tr><tr><td>delif <code>&lt;bridge&gt;</code> <code>&lt;device&gt;</code></td><td>删除网桥接入的网卡接口</td><td>brctl delif br10 eth0</td></tr><tr><td>show <code>&lt;bridge&gt;</code></td><td>查询网桥信息</td><td>brctl show br10</td></tr><tr><td>stp <code>&lt;bridge&gt;</code> <code>&#123;on\off&#125;</code></td><td>启用禁用 STP</td><td>brctl stp br10 off/on</td></tr><tr><td>showstp <code>&lt;bridge&gt;</code></td><td>查看网桥 STP 信息</td><td>brctl showstp br10</td></tr><tr><td>setfd <code>&lt;bridge&gt;</code> <code>&lt;time&gt;</code></td><td>设置网桥延迟</td><td>brctl setfd br10 10</td></tr><tr><td>showmacs <code>&lt;bridge&gt;</code></td><td>查看 mac 信息</td><td>brctl showmacs br10</td></tr></tbody></table><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>添加网桥 <code>br0</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brctl addbr br0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>设置<code>br0</code>可用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig br0 192.168.100.1 netmask 255.255.255.0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>显示所有的网桥信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brctl show</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>显示网桥<code>br0</code>的信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brctl show br0</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="brctl常用命令"><a href="#brctl常用命令" class="headerlink" title="brctl常用命令"></a>brctl常用命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">brctl addbr br1             #创建网桥</span><br><span class="line">brctl addif br1 enp4s0      #为网桥添加物理接口</span><br><span class="line">brctl delbr br1             #删除网桥</span><br><span class="line">brctl delif br1 enp4s0      #删除网桥接口</span><br><span class="line">brctl show                  #显示网桥列表信息</span><br><span class="line">brctl show br1              #显示网桥br1的信息</span><br><span class="line">brctl showmacs br1          #显示网桥的MAC地址信息</span><br><span class="line">brctl showstp br1           #显示网桥的stp信息</span><br><span class="line">brctl stp br-test on|off    #开|关stp</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>brctl命令范式，可以通过对应英文参数，执行需要的命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# brctl</span><br><span class="line">Usage: brctl [commands]</span><br><span class="line">commands:</span><br><span class="line">        addbr           &lt;bridge&gt;                add bridge</span><br><span class="line">        delbr           &lt;bridge&gt;                delete bridge</span><br><span class="line">        addif           &lt;bridge&gt; &lt;device&gt;       add interface to bridge</span><br><span class="line">        delif           &lt;bridge&gt; &lt;device&gt;       delete interface from bridge</span><br><span class="line">        hairpin         &lt;bridge&gt; &lt;port&gt; &#123;on|off&#125;        turn hairpin on/off</span><br><span class="line">        setageing       &lt;bridge&gt; &lt;time&gt;         set ageing time</span><br><span class="line">        setbridgeprio   &lt;bridge&gt; &lt;prio&gt;         set bridge priority</span><br><span class="line">        setfd           &lt;bridge&gt; &lt;time&gt;         set bridge forward delay</span><br><span class="line">        sethello        &lt;bridge&gt; &lt;time&gt;         set hello time</span><br><span class="line">        setmaxage       &lt;bridge&gt; &lt;time&gt;         set max message age</span><br><span class="line">        setpathcost     &lt;bridge&gt; &lt;port&gt; &lt;cost&gt;  set path cost</span><br><span class="line">        setportprio     &lt;bridge&gt; &lt;port&gt; &lt;prio&gt;  set port priority</span><br><span class="line">        show            [ &lt;bridge&gt; ]            show a list of bridges</span><br><span class="line">        showmacs        &lt;bridge&gt;                show a list of mac addrs</span><br><span class="line">        showstp         &lt;bridge&gt;                show bridge stp info</span><br><span class="line">        stp             &lt;bridge&gt; &#123;on|off&#125;       turn stp on/off</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>brctl场景使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">brctl addbr bridge</span><br><span class="line">brctl addif bridge eth0</span><br><span class="line">brctl addif bridge ath0</span><br><span class="line">ifconfig eth0 0.0.0.0</span><br><span class="line">// 将有线和无线都设置为192.168.1.*网段，即可通过网上邻居进行访问</span><br><span class="line">ifconfig bridge 192.168.1.0 netmask 255.255.255.0 up</span><br><span class="line">// 添加iptables -t nat -A POSTROUTING -o ath0 -j SNAT --to 192.168.2.173</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;命令安装&quot;&gt;&lt;a href=&quot;#命令安装&quot; class=&quot;headerlink&quot; title=&quot;命令安装&quot;&gt;&lt;/a&gt;命令安装&lt;/h2&gt;&lt;p&gt;Centos系统&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;yum install bridge-utils&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="LINUX" scheme="https://rma-shuyu.github.io/categories/LINUX/"/>
    
    
    <category term="brctl" scheme="https://rma-shuyu.github.io/tags/brctl/"/>
    
  </entry>
  
  <entry>
    <title>Linux Namespace</title>
    <link href="https://rma-shuyu.github.io/2022/06/17/Linux-Namespace/"/>
    <id>https://rma-shuyu.github.io/2022/06/17/Linux-Namespace/</id>
    <published>2022-06-17T12:25:15.000Z</published>
    <updated>2023-09-09T10:33:02.405Z</updated>
    
    <content type="html"><![CDATA[<p><code>Linux Namespace</code> 是 Linux 提供的一种内核级别环境隔离的方法。</p><span id="more"></span><p>Linux Namespace 将全局系统资源封装在一个抽象中，从而使 namespace 内的进程认为自己具有独立的资源实例。这项技术本来没有掀起多大的波澜，是容器技术的崛起让他重新引起了大家的注意。</p><p>Linux Namespace 有如下 6 个种类：</p><table><thead><tr><th><strong>分类</strong></th><th><strong>系统调用参数</strong></th><th><strong>相关内核版本</strong></th></tr></thead><tbody><tr><td>Mount namespaces</td><td>CLONE_NEWNS</td><td><a href="http://lwn.net/2001/0301/a/namespaces.php3">Linux 2.4.19</a></td></tr><tr><td>UTS namespaces</td><td>CLONE_NEWUTS</td><td><a href="http://lwn.net/Articles/179345/">Linux 2.6.19</a></td></tr><tr><td>IPC namespaces</td><td>CLONE_NEWIPC</td><td><a href="http://lwn.net/Articles/187274/">Linux 2.6.19</a></td></tr><tr><td>PID namespaces</td><td>CLONE_NEWPID</td><td><a href="http://lwn.net/Articles/259217/">Linux 2.6.24</a></td></tr><tr><td>Network namespaces</td><td>CLONE_NEWNET</td><td><a href="http://lwn.net/Articles/219794/">始于Linux 2.6.24 完成于 Linux 2.6.29</a></td></tr><tr><td>User namespaces</td><td>CLONE_NEWUSER</td><td><a href="http://lwn.net/Articles/528078/">始于 Linux 2.6.23 完成于 Linux 3.8</a></td></tr></tbody></table><p>namespace 的 API 由三个系统调用和一系列 <code>/proc</code> 文件组成，本文将会详细介绍这些系统调用和 <code>/proc</code> 文件。为了指定要操作的 namespace 类型，需要在系统调用的 flag 中通过常量 <code>CLONE_NEW*</code> 指定（包括 <code>CLONE_NEWIPC</code>，<code>CLONE_NEWNS</code>， <code>CLONE_NEWNET</code>，<code>CLONE_NEWPID</code>，<code>CLONE_NEWUSER</code> 和 <code>CLONE_NEWUTS</code>），可以指定多个常量，通过 **|**（位或）操作来实现。</p><p>简单描述一下三个系统调用的功能：</p><ul><li>  <strong>clone()</strong> : 实现线程的系统调用，用来创建一个新的进程，并可以通过设计上述系统调用参数达到隔离的目的。</li><li>  <strong>unshare()</strong> : 使某进程脱离某个 namespace。</li><li>  <strong>setns()</strong> : 把某进程加入到某个 namespace。</li></ul><p>具体的实现原理请往下看。</p><h2 id="1-clone"><a href="#1-clone" class="headerlink" title="1. clone()"></a>1. clone()</h2><hr><p><code>clone()</code> 的原型如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int clone(int (*child_func)(void *), void *child_stack, int flags, void *arg);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>  <strong>child_func</strong> : 传入子进程运行的程序主函数。</li><li>  <strong>child_stack</strong> : 传入子进程使用的栈空间。</li><li>  <strong>flags</strong> : 表示使用哪些 <code>CLONE_*</code> 标志位。</li><li>  <strong>args</strong> : 用于传入用户参数。</li></ul><p><code>clone()</code> 与 <code>fork()</code> 类似，都相当于把当前进程复制了一份，但 <code>clone()</code> 可以更细粒度地控制与子进程共享的资源（其实就是通过 flags 来控制），包括虚拟内存、打开的文件描述符和信号量等等。一旦指定了标志位 <code>CLONE_NEW*</code>，相对应类型的 namespace 就会被创建，新创建的进程也会成为该 namespace 中的一员。</p><p>clone() 的原型并不是最底层的系统调用，而是封装过的，真正的系统调用内核实现函数为 <code>do_fork()</code>，形式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">long do_fork(unsigned long clone_flags,</span><br><span class="line">      unsigned long stack_start,</span><br><span class="line">      unsigned long stack_size,</span><br><span class="line">      int __user *parent_tidptr,</span><br><span class="line">      int __user *child_tidptr)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中 <code>clone_flags</code> 可以赋值为上面提到的标志。</p><p>下面来看一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">/* demo_uts_namespaces.c</span><br><span class="line">   Copyright 2013, Michael Kerrisk   Licensed under GNU General Public License v2 or later</span><br><span class="line">   Demonstrate the operation of UTS namespaces.</span><br><span class="line">*/</span><br><span class="line">#define _GNU_SOURCE</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;sys/utsname.h&gt;</span><br><span class="line">#include &lt;sched.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">/* A simple error-handling function: print an error message based</span><br><span class="line">   on the value in &#x27;errno&#x27; and terminate the calling process */</span><br><span class="line">#define errExit(msg)                \</span><br><span class="line">do                          \</span><br><span class="line">&#123;                           \</span><br><span class="line">perror(msg);        \</span><br><span class="line">exit(EXIT_FAILURE); \</span><br><span class="line">&#125; while (0)</span><br><span class="line">static int /* Start function for cloned child */</span><br><span class="line">childFunc(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">struct utsname uts;</span><br><span class="line">/* 在新的 UTS namespace 中修改主机名 */</span><br><span class="line">if (sethostname(arg, strlen(arg)) == -1)</span><br><span class="line">errExit(&quot;sethostname&quot;);</span><br><span class="line">/* 获取并显示主机名 */</span><br><span class="line">if (uname(&amp;uts) == -1)</span><br><span class="line">errExit(&quot;uname&quot;);</span><br><span class="line">printf(&quot;uts.nodename in child:  %s\n&quot;, uts.nodename);</span><br><span class="line">/* Keep the namespace open for a while, by sleeping.       This allows some experimentation--for example, another       process might join the namespace. */</span><br><span class="line">sleep(100);</span><br><span class="line">return 0; /* Terminates child */</span><br><span class="line">&#125;</span><br><span class="line">/* 定义一个给 clone 用的栈，栈大小1M */</span><br><span class="line">#define STACK_SIZE (1024 * 1024)</span><br><span class="line">static char child_stack[STACK_SIZE];</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">pid_t child_pid;</span><br><span class="line">struct utsname uts;</span><br><span class="line">if (argc &lt; 2)</span><br><span class="line">&#123;</span><br><span class="line">fprintf(stderr, &quot;Usage: %s &lt;child-hostname&gt;\n&quot;, argv[0]);</span><br><span class="line">exit(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">/* 调用 clone 函数创建一个新的 UTS namespace，其中传出一个函数，还有一个栈空间（为什么传尾指针，因为栈是反着的）;       新的进程将在用户定义的函数 childFunc() 中执行 */</span><br><span class="line">child_pid = clone(childFunc, child_stack + STACK_SIZE, CLONE_NEWUTS | SIGCHLD, argv[1]);</span><br><span class="line">if (child_pid == -1)</span><br><span class="line">errExit(&quot;clone&quot;);</span><br><span class="line">printf(&quot;PID of child created by clone() is %ld\n&quot;, (long)child_pid);</span><br><span class="line">/* Parent falls through to here */</span><br><span class="line">sleep(1); /* 给子进程预留一定的时间来改变主机名 */</span><br><span class="line">/* 显示当前 UTS namespace 中的主机名，和       子进程所在的 UTS namespace 中的主机名不同 */</span><br><span class="line">if (uname(&amp;uts) == -1)</span><br><span class="line">errExit(&quot;uname&quot;);</span><br><span class="line">printf(&quot;uts.nodename in parent: %s\n&quot;, uts.nodename);</span><br><span class="line">if (waitpid(child_pid, NULL, 0) == -1) /* 等待子进程结束 */</span><br><span class="line">errExit(&quot;waitpid&quot;);</span><br><span class="line">printf(&quot;child has terminated\n&quot;);</span><br><span class="line">exit(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该程序通过标志位 <code>CLONE_NEWUTS</code> 调用 <code>clone()</code> 函数创建一个 UTS namespace。UTS namespace 隔离了两个系统标识符 — <strong>主机名</strong>和 <strong>NIS 域名</strong> —它们分别通过 <code>sethostname()</code> 和 <code>setdomainname()</code> 这两个系统调用来设置，并通过系统调用 <code>uname()</code> 来获取。</p><p>下面将对程序中的一些关键部分进行解读（为了简单起见，我们将省略其中的错误检查）。</p><p>程序运行时后面需要跟上一个命令行参数，它将会创建一个在新的 UTS namespace 中执行的子进程，该子进程会在新的 UTS namespace 中将主机名改为命令行参数中提供的值。</p><p>主程序的第一个关键部分是通过系统调用 <code>clone()</code> 来创建子进程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">child_pid = clone(childFunc, </span><br><span class="line">                  child_stack + STACK_SIZE,   /* Points to start of                                                 downwardly growing stack */                  CLONE_NEWUTS | SIGCHLD, argv[1]);</span><br><span class="line">printf(&quot;PID of child created by clone() is %ld\n&quot;, (long) child_pid);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>子进程将会在用户定义的函数 <code>childFunc()</code> 中开始执行，该函数将会接收 <code>clone()</code> 最后的参数（argv[1]）作为自己的参数，并且标志位包含了 <code>CLONE_NEWUTS</code>，所以子进程会在新创建的 UTS namespace 中执行。</p><p>接下来主进程睡眠一段时间，让子进程能够有时间更改其 UTS namespace 中的主机名。然后调用 <code>uname()</code> 来检索当前 UTS namespace 中的主机名，并显示该主机名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sleep(1);           /* Give child time to change its hostname */</span><br><span class="line">uname(&amp;uts);</span><br><span class="line">printf(&quot;uts.nodename in parent: %s\n&quot;, uts.nodename);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>与此同时，由 <code>clone()</code> 创建的子进程执行的函数 <code>childFunc()</code> 首先将主机名改为命令行参数中提供的值，然后检索并显示修改后的主机名：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sethostname(arg, strlen(arg);</span><br><span class="line">    </span><br><span class="line">uname(&amp;uts);</span><br><span class="line">printf(&quot;uts.nodename in child:  %s\n&quot;, uts.nodename);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>子进程退出之前也睡眠了一段时间，这样可以防止新的 UTS namespace 不会被关闭，让我们能够有机会进行后续的实验。</p><p>执行程序，观察父进程和子进程是否处于不同的 UTS namespace 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ su                   # 需要特权才能创建 UTS namespace</span><br><span class="line">Password: </span><br><span class="line"># uname -n</span><br><span class="line">antero</span><br><span class="line"># ./demo_uts_namespaces bizarro</span><br><span class="line">PID of child created by clone() is 27514</span><br><span class="line">uts.nodename in child:  bizarro</span><br><span class="line">uts.nodename in parent: antero</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>除了 User namespace 之外，创建其他的 namespace 都需要特权，更确切地说，是需要相应的 <code>Linux Capabilities</code>，即 <code>CAP_SYS_ADMIN</code>。这样就可以避免设置了 SUID（Set User ID on execution）的程序因为主机名不同而做出一些愚蠢的行为。</p><h2 id="2-proc-文件"><a href="#2-proc-文件" class="headerlink" title="2. proc 文件"></a>2. proc 文件</h2><hr><p>每个进程都有一个 <code>/proc/PID/ns</code> 目录，其下面的文件依次表示每个 namespace, 例如 user 就表示 user namespace。从 3.8 版本的内核开始，该目录下的每个文件都是一个特殊的符号链接，链接指向 <code>$namespace:[$namespace-inode-number]</code>，前半部份为 namespace 的名称，后半部份的数字表示这个 namespace 的句柄号。句柄号用来对进程所关联的 namespace 执行某些操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l /proc/$$/ns         # $$ 表示当前所在的 shell 的 PID</span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx. 1 mtk mtk 0 Jan  8 04:12 ipc -&gt; ipc:[4026531839]</span><br><span class="line">lrwxrwxrwx. 1 mtk mtk 0 Jan  8 04:12 mnt -&gt; mnt:[4026531840]</span><br><span class="line">lrwxrwxrwx. 1 mtk mtk 0 Jan  8 04:12 net -&gt; net:[4026531956]</span><br><span class="line">lrwxrwxrwx. 1 mtk mtk 0 Jan  8 04:12 pid -&gt; pid:[4026531836]</span><br><span class="line">lrwxrwxrwx. 1 mtk mtk 0 Jan  8 04:12 user -&gt; user:[4026531837]</span><br><span class="line">lrwxrwxrwx. 1 mtk mtk 0 Jan  8 04:12 uts -&gt; uts:[4026531838]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这些符号链接的用途之一是用来<strong>确认两个不同的进程是否处于同一 namespace 中</strong>。如果两个进程指向的 namespace inode number 相同，就说明他们在同一个 namespace 下，否则就在不同的 namespace 下。这些符号链接指向的文件比较特殊，不能直接访问，事实上指向的文件存放在被称为 <code>nsfs</code> 的文件系统中，该文件系统用户不可见，可以使用系统调用 <a href="http://man7.org/linux/man-pages/man2/stat.2.html">stat()</a> 在返回的结构体的 <code>st_ino</code> 字段中获取 inode number。在 shell 终端中可以用命令（实际上就是调用了 stat()）看到指向文件的 inode 信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ stat -L /proc/$$/ns/net</span><br><span class="line">  File: /proc/3232/ns/net  Size: 0         Blocks: 0          IO Block: 4096   regular empty file</span><br><span class="line">Device: 4h/4dInode: 4026531956  Links: 1</span><br><span class="line">Access: (0444/-r--r--r--)  Uid: (    0/    root)   Gid: (    0/    root)</span><br><span class="line">Access: 2020-01-17 15:45:23.783304900 +0800</span><br><span class="line">Modify: 2020-01-17 15:45:23.783304900 +0800</span><br><span class="line">Change: 2020-01-17 15:45:23.783304900 +0800</span><br><span class="line"> Birth: -</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>除了上述用途之外，这些符号链接还有其他的用途，<strong>如果我们打开了其中一个文件，那么只要与该文件相关联的文件描述符处于打开状态，即使该 namespace 中的所有进程都终止了，该 namespace 依然不会被删除</strong>。通过 bind mount 将符号链接挂载到系统的其他位置，也可以获得相同的效果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ touch ~/uts</span><br><span class="line">$ mount --bind /proc/27514/ns/uts ~/uts</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-setns"><a href="#3-setns" class="headerlink" title="3. setns()"></a>3. setns()</h2><hr><p>加入一个已经存在的 namespace 可以通过系统调用 <code>setns()</code> 来完成。它的原型如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int setns(int fd, int nstype);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>更确切的说法是：<code>setns()</code> 将调用的进程与特定类型 namespace 的一个实例分离，并将该进程与该类型 namespace 的另一个实例重新关联。</p><ul><li>  <code>fd</code> 表示要加入的 namespace 的文件描述符，可以通过打开其中一个符号链接来获取，也可以通过打开 bind mount 到其中一个链接的文件来获取。</li><li>  <code>nstype</code> 让调用者可以去检查 fd 指向的 namespace 类型，值可以设置为前文提到的常量 <code>CLONE_NEW*</code>，填 <code>0</code> 表示不检查。如果调用者已经明确知道自己要加入了 namespace 类型，或者不关心 namespace 类型，就可以使用该参数来自动校验。</li></ul><p>结合 <code>setns()</code> 和 <code>execve()</code> 可以实现一个简单但非常有用的功能：将某个进程加入某个特定的 namespace，然后在该 namespace 中执行命令。直接来看例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">/* ns_exec.c</span><br><span class="line">   Copyright 2013, Michael Kerrisk   Licensed under GNU General Public License v2 or later</span><br><span class="line">   Join a namespace and execute a command in the namespace</span><br><span class="line">*/</span><br><span class="line">#define _GNU_SOURCE</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;sched.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">/* A simple error-handling function: print an error message based</span><br><span class="line">   on the value in &#x27;errno&#x27; and terminate the calling process */</span><br><span class="line">#define errExit(msg)                \</span><br><span class="line">do                          \</span><br><span class="line">&#123;                           \</span><br><span class="line">perror(msg);        \</span><br><span class="line">exit(EXIT_FAILURE); \</span><br><span class="line">&#125; while (0)</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">int fd;</span><br><span class="line">if (argc &lt; 3)</span><br><span class="line">&#123;</span><br><span class="line">fprintf(stderr, &quot;%s /proc/PID/ns/FILE cmd [arg...]\n&quot;, argv[0]);</span><br><span class="line">exit(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">fd = open(argv[1], O_RDONLY); /* 获取想要加入的 namespace 的文件描述符 */</span><br><span class="line">if (fd == -1)</span><br><span class="line">errExit(&quot;open&quot;);</span><br><span class="line">if (setns(fd, 0) == -1) /* 加入该 namespace */</span><br><span class="line">errExit(&quot;setns&quot;);</span><br><span class="line">execvp(argv[2], &amp;argv[2]); /* 在加入的 namespace 中执行相应的命令 */</span><br><span class="line">errExit(&quot;execvp&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该程序运行需要两个或两个以上的命令行参数，第一个参数表示特定的 namespace 符号链接的路径（或者 bind mount 到这些符号链接的文件路径）；第二个参数表示要在该符号链接相对应的 namespace 中执行的程序名称，以及执行这个程序所需的命令行参数。关键步骤如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fd = open(argv[1], O_RDONLY);   /* 获取想要加入的 namespace 的文件描述符 */</span><br><span class="line">setns(fd, 0);                   /* 加入该 namespace */</span><br><span class="line">execvp(argv[2], &amp;argv[2]);      /* 在加入的 namespace 中执行相应的命令 */</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还记得我们之前已经通过 bind mount 将 <code>demo_uts_namespaces</code> 创建的 UTS namespace 挂载到 <code>~/uts</code> 中了吗？可以将本例中的程序与之结合，让新进程可以在该 UTS namespace 中执行 shell：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./ns_exec ~/uts /bin/bash     # ~/uts 被 bind mount 到了 /proc/27514/ns/uts    My PID is: 28788</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>验证新的 shell 是否与 <code>demo_uts_namespaces</code> 创建的子进程处于同一个 UTS namespace：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ hostname</span><br><span class="line">bizarro</span><br><span class="line">$ readlink /proc/27514/ns/uts</span><br><span class="line">uts:[4026532338]</span><br><span class="line">$ readlink /proc/$$/ns/uts      # $$ 表示当前 shell 的 PID</span><br><span class="line">uts:[4026532338]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在早期的内核版本中，不能使用 <code>setns()</code> 来加入 mount namespace、PID namespace 和 user namespace，从 3.8 版本的内核开始，<code>setns()</code> 支持加入所有的 namespace。</p><p>util-linux 包里提供了<code>nsenter</code> 命令，其提供了一种方式将新创建的进程运行在指定的 namespace 里面，它的实现很简单，就是通过命令行（-t 参数）指定要进入的 namespace 的符号链接，然后利用 <code>setns()</code> 将当前的进程放到指定的 namespace 里面，再调用 <code>clone()</code> 运行指定的执行文件。我们可以用 <code>strace</code> 来看看它的运行情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># strace nsenter -t 27242 -i -m -n -p -u /bin/bash</span><br><span class="line">execve(&quot;/usr/bin/nsenter&quot;, [&quot;nsenter&quot;, &quot;-t&quot;, &quot;27242&quot;, &quot;-i&quot;, &quot;-m&quot;, &quot;-n&quot;, &quot;-p&quot;, &quot;-u&quot;, &quot;/bin/bash&quot;], [/* 21 vars */]) = 0</span><br><span class="line">…………</span><br><span class="line">…………</span><br><span class="line">open(&quot;/proc/27242/ns/ipc&quot;, O_RDONLY)    = 3</span><br><span class="line">open(&quot;/proc/27242/ns/uts&quot;, O_RDONLY)    = 4</span><br><span class="line">open(&quot;/proc/27242/ns/net&quot;, O_RDONLY)    = 5</span><br><span class="line">open(&quot;/proc/27242/ns/pid&quot;, O_RDONLY)    = 6</span><br><span class="line">open(&quot;/proc/27242/ns/mnt&quot;, O_RDONLY)    = 7</span><br><span class="line">setns(3, CLONE_NEWIPC)                  = 0</span><br><span class="line">close(3)                                = 0</span><br><span class="line">setns(4, CLONE_NEWUTS)                  = 0</span><br><span class="line">close(4)                                = 0</span><br><span class="line">setns(5, CLONE_NEWNET)                  = 0</span><br><span class="line">close(5)                                = 0</span><br><span class="line">setns(6, CLONE_NEWPID)                  = 0</span><br><span class="line">close(6)                                = 0</span><br><span class="line">setns(7, CLONE_NEWNS)                   = 0</span><br><span class="line">close(7)                                = 0</span><br><span class="line">clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0x7f4deb1faad0) = 4968</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-unshare"><a href="#4-unshare" class="headerlink" title="4. unshare()"></a>4. unshare()</h2><hr><p>最后一个要介绍的系统调用是 <code>unshare()</code>，它的原型如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int unshare(int flags);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>unshare()</code> 与 <code>clone()</code> 类似，但它运行在原先的进程上，不需要创建一个新进程，即：先通过指定的 flags 参数 <code>CLONE_NEW*</code> 创建一个新的 namespace，然后将调用者加入该 namespace。最后实现的效果其实就是将调用者从当前的 namespace 分离，然后加入一个新的 namespace。</p><p>Linux 中自带的 <code>unshare</code> 命令，就是通过 unshare() 系统调用实现的，使用方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ unshare [options] program [arguments]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>options</code> 指定要创建的 namespace 类型。</p><p>unshare 命令的主要实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* 通过提供的命令行参数初始化 &#x27;flags&#x27; */</span><br><span class="line">unshare(flags);</span><br><span class="line">/* Now execute &#x27;program&#x27; with &#x27;arguments&#x27;; &#x27;optind&#x27; is the index</span><br><span class="line">   of the next command-line argument after options */</span><br><span class="line">execvp(argv[optind], &amp;argv[optind]);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>unshare 命令的完整实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">/* unshare.c</span><br><span class="line">   Copyright 2013, Michael Kerrisk   Licensed under GNU General Public License v2 or later</span><br><span class="line">   A simple implementation of the unshare(1) command: unshare   namespaces and execute a command.</span><br><span class="line">*/</span><br><span class="line">#define _GNU_SOURCE</span><br><span class="line">#include &lt;sched.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">/* A simple error-handling function: print an error message based</span><br><span class="line">   on the value in &#x27;errno&#x27; and terminate the calling process */</span><br><span class="line">#define errExit(msg)                \</span><br><span class="line">do                          \</span><br><span class="line">&#123;                           \</span><br><span class="line">perror(msg);        \</span><br><span class="line">exit(EXIT_FAILURE); \</span><br><span class="line">&#125; while (0)</span><br><span class="line">static void</span><br><span class="line">usage(char *pname)</span><br><span class="line">&#123;</span><br><span class="line">fprintf(stderr, &quot;Usage: %s [options] program [arg...]\n&quot;, pname);</span><br><span class="line">fprintf(stderr, &quot;Options can be:\n&quot;);</span><br><span class="line">fprintf(stderr, &quot;    -i   unshare IPC namespace\n&quot;);</span><br><span class="line">fprintf(stderr, &quot;    -m   unshare mount namespace\n&quot;);</span><br><span class="line">fprintf(stderr, &quot;    -n   unshare network namespace\n&quot;);</span><br><span class="line">fprintf(stderr, &quot;    -p   unshare PID namespace\n&quot;);</span><br><span class="line">fprintf(stderr, &quot;    -u   unshare UTS namespace\n&quot;);</span><br><span class="line">fprintf(stderr, &quot;    -U   unshare user namespace\n&quot;);</span><br><span class="line">exit(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">int flags, opt;</span><br><span class="line">flags = 0;</span><br><span class="line">while ((opt = getopt(argc, argv, &quot;imnpuU&quot;)) != -1)</span><br><span class="line">&#123;</span><br><span class="line">switch (opt)</span><br><span class="line">&#123;</span><br><span class="line">case &#x27;i&#x27;:</span><br><span class="line">flags |= CLONE_NEWIPC;</span><br><span class="line">break;</span><br><span class="line">case &#x27;m&#x27;:</span><br><span class="line">flags |= CLONE_NEWNS;</span><br><span class="line">break;</span><br><span class="line">case &#x27;n&#x27;:</span><br><span class="line">flags |= CLONE_NEWNET;</span><br><span class="line">break;</span><br><span class="line">case &#x27;p&#x27;:</span><br><span class="line">flags |= CLONE_NEWPID;</span><br><span class="line">break;</span><br><span class="line">case &#x27;u&#x27;:</span><br><span class="line">flags |= CLONE_NEWUTS;</span><br><span class="line">break;</span><br><span class="line">case &#x27;U&#x27;:</span><br><span class="line">flags |= CLONE_NEWUSER;</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">usage(argv[0]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (optind &gt;= argc)</span><br><span class="line">usage(argv[0]);</span><br><span class="line">if (unshare(flags) == -1)</span><br><span class="line">errExit(&quot;unshare&quot;);</span><br><span class="line">execvp(argv[optind], &amp;argv[optind]);</span><br><span class="line">errExit(&quot;execvp&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>下面我们执行 <code>unshare.c</code> 程序在一个新的 mount namespace 中执行 shell：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ echo $$                             # 显示当前 shell 的 PID</span><br><span class="line">8490</span><br><span class="line">$ cat /proc/8490/mounts | grep mq     # 显示当前 namespace 中的某个挂载点</span><br><span class="line">mqueue /dev/mqueue mqueue rw,seclabel,relatime 0 0</span><br><span class="line">$ readlink /proc/8490/ns/mnt          # 显示当前 namespace 的 ID </span><br><span class="line">mnt:[4026531840]</span><br><span class="line">$ ./unshare -m /bin/bash              # 在新创建的 mount namespace 中执行新的 shell</span><br><span class="line">$ readlink /proc/$$/ns/mnt            # 显示新 namespace 的 ID </span><br><span class="line">mnt:[4026532325]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对比两个 <code>readlink</code> 命令的输出，可以知道两个shell 处于不同的 mount namespace 中。改变新的 namespace 中的某个挂载点，然后观察两个 namespace 的挂载点是否有变化：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ umount /dev/mqueue                  # 移除新 namespace 中的挂载点</span><br><span class="line">$ cat /proc/$$/mounts | grep mq       # 检查是否生效</span><br><span class="line">$ cat /proc/8490/mounts | grep mq     # 查看原来的 namespace 中的挂载点是否依然存在?</span><br><span class="line">mqueue /dev/mqueue mqueue rw,seclabel,relatime 0 0</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看出，新的 namespace 中的挂载点 <code>/dev/mqueue</code> 已经消失了，但在原来的 namespace 中依然存在。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;Linux Namespace&lt;/code&gt; 是 Linux 提供的一种内核级别环境隔离的方法。&lt;/p&gt;</summary>
    
    
    
    <category term="LINUX" scheme="https://rma-shuyu.github.io/categories/LINUX/"/>
    
    
    <category term="Namespace" scheme="https://rma-shuyu.github.io/tags/Namespace/"/>
    
  </entry>
  
</feed>
