<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>rma&#39;s Blog</title>
  
  <subtitle>Stay hungry, stay foolish</subtitle>
  <link href="https://rma-shuyu.github.io/atom.xml" rel="self"/>
  
  <link href="https://rma-shuyu.github.io/"/>
  <updated>2024-06-22T07:34:15.324Z</updated>
  <id>https://rma-shuyu.github.io/</id>
  
  <author>
    <name>rma-shuyu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux中修改终端登录欢迎界面</title>
    <link href="https://rma-shuyu.github.io/2024/06/07/Linux%E4%B8%AD%E4%BF%AE%E6%94%B9%E7%BB%88%E7%AB%AF%E7%99%BB%E5%BD%95%E6%AC%A2%E8%BF%8E%E7%95%8C%E9%9D%A2/"/>
    <id>https://rma-shuyu.github.io/2024/06/07/Linux%E4%B8%AD%E4%BF%AE%E6%94%B9%E7%BB%88%E7%AB%AF%E7%99%BB%E5%BD%95%E6%AC%A2%E8%BF%8E%E7%95%8C%E9%9D%A2/</id>
    <published>2024-06-07T03:42:50.000Z</published>
    <updated>2024-06-22T07:34:15.324Z</updated>
    
    <content type="html"><![CDATA[<h3 id="终端登陆前欢迎界面"><a href="#终端登陆前欢迎界面" class="headerlink" title="终端登陆前欢迎界面"></a>终端登陆前欢迎界面</h3><ul><li>  修改/etc/issue</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cat /etc/issue</span><br><span class="line">Authorized users only. All activities may be monitored and reported.</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="远程终端登录后欢迎信息"><a href="#远程终端登录后欢迎信息" class="headerlink" title="远程终端登录后欢迎信息"></a>远程终端登录后欢迎信息</h3><h4 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h4><ul><li>  修改/etc/motd</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># cat /etc/motd</span><br><span class="line"></span><br><span class="line">Authorized users only. All activities may be monitored and reported.</span><br></pre></td></tr></table></figure><h4 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h4><ul><li>  Ubuntu中没有/etc/motd</li><li>  相关欢迎信息存储在/etc/update-mod.d/中的文件中</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># ll /etc/update-motd.d/</span><br><span class="line">total 20</span><br><span class="line">-rwxr-xr-x. 1 root root  222 May 24  2023 00-logo</span><br><span class="line">-rwxr-xr-x. 1 root root  309 May 24  2023 10-banner</span><br><span class="line">-rwxr-xr-x. 1 root root  745 May 24  2023 20-sysinfo</span><br><span class="line">-rwxr-xr-x. 1 root root  495 May 24  2023 30-support</span><br><span class="line">-rwxr-xr-x. 1 root root 1454 May 24  2023 99-updates</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>  00-logo</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">[root@bclinux-corsica update-motd.d]# cat 00-logo </span><br><span class="line">#!/bin/sh</span><br><span class="line">#</span><br><span class="line">#</span><br><span class="line">#    00-logo - BCLinux logo</span><br><span class="line">#    Copyright (c) 2016 China Mobile</span><br><span class="line">#</span><br><span class="line">#    Authors: Haishuang Yan &lt;yanhaishuang@cmss.chinamobile.com&gt;</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">[ -f /etc/bigcloud/welcome/logo ] &amp;&amp;  /bin/cat /etc/bigcloud/welcome/logo</span><br><span class="line"># cat /etc/bigcloud/welcome/logo</span><br><span class="line"> ____  _        ____ _                 _</span><br><span class="line">| __ )(_) __ _ / ___| | ___  _   _  __| |</span><br><span class="line">|  _ \| |/ _` | |   | |/ _ \| | | |/ _` |</span><br><span class="line">| |_) | | (_| | |___| | (_) | |_| | (_| |</span><br><span class="line">|____/|_|\__, |\____|_|\___/ \__,_|\__,_|</span><br><span class="line">         |___/</span><br><span class="line"></span><br><span class="line"> _____       _                       _            _     _</span><br><span class="line">| ____|_ __ | |_ ___ _ __ _ __  _ __(_)___  ___  | |   (_)_ __  _   ___  __</span><br><span class="line">|  _| | &#x27;_ \| __/ _ \ &#x27;__| &#x27;_ \| &#x27;__| / __|/ _ \ | |   | | &#x27;_ \| | | \ \/ /</span><br><span class="line">| |___| | | | ||  __/ |  | |_) | |  | \__ \  __/ | |___| | | | | |_| |&gt;  &lt;</span><br><span class="line">|_____|_| |_|\__\___|_|  | .__/|_|  |_|___/\___| |_____|_|_| |_|\__,_/_/\_\</span><br><span class="line">                         |_|</span><br><span class="line"></span><br><span class="line"> _____             _____       _              ____   ____      _  ___     _   _   _ </span><br><span class="line">|  ___|__  _ __   | ____|_   _| | ___ _ __   |___ \ |___ \    / |/ _ \   | | | | / |</span><br><span class="line">| |_ / _ \| &#x27;__|  |  _| | | | | |/ _ \ &#x27;__|    __) |  __) |   | | | | |  | | | | | |</span><br><span class="line">|  _| (_) | |     | |__ | |_| | |  __/ |      / __/| / __/| _ | | |_| |  | |_| | | |</span><br><span class="line">|_|  \___/|_|     |_____|\__,_|_|\___|_|     |_____||_____|(_)|_|\___/    \__,_| |_|</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>  10-banner</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#</span><br><span class="line">#    10-banner - generate the banner information</span><br><span class="line">#    Copyright (c) 2016 China Mobile</span><br><span class="line">#</span><br><span class="line">#    Authors: Haishuang Yan &lt;yanhaishuang@cmss.chinamobile.com&gt;</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">printf &quot;\n&quot;</span><br><span class="line">printf &quot;Welcome to %s (%s %s %s)\n\n&quot;  &quot;BigCloud Enterprise Linux For Euler 22.10U1&quot; &quot;$(uname -o)&quot; &quot;$(uname -r)&quot; &quot;$(uname -m)&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>  20-sysinfo</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#</span><br><span class="line">#    20-sysinfo - generate the system information</span><br><span class="line">#    Copyright (c) 2016 China Mobile</span><br><span class="line">#</span><br><span class="line">#    Authors: Haishuang Yan &lt;yanhaishuang@cmss.chinamobile.com&gt;</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">printf &quot;System information as of %s\n&quot; &quot;$(/bin/date)&quot;</span><br><span class="line">printf &quot;\n&quot;</span><br><span class="line">printf &quot;  * System CPU load:\t%-20s&quot;   &quot;$(cat /proc/loadavg | cut -d&#x27; &#x27; -f1-3)&quot;</span><br><span class="line">printf &quot;  * System   uptime:\t%-20s\n&quot; &quot;$(uptime | cut -d&#x27;,&#x27; -f1)&quot;</span><br><span class="line">printf &quot;  * Active sessions:\t%-20s&quot;  &quot;$(w | tail -n +3 | wc -l)&quot;</span><br><span class="line">printf &quot;  * Memory    usage:\t %s / %s MB\n&quot; \</span><br><span class="line">         $(cat /proc/meminfo | grep MemFree | awk &#123;&#x27;print int($2/1000)&#x27;&#125;) \</span><br><span class="line">                $(cat /proc/meminfo | grep MemTotal | awk &#123;&#x27;print int($2/1000)&#x27;&#125;)</span><br><span class="line">printf &quot;  * Processes count:\t%s\n&quot;  &quot;$(cat /proc/loadavg | cut -d&#x27;/&#x27; -f2| cut -d&#x27; &#x27; -f1)&quot;</span><br><span class="line">  </span><br></pre></td></tr></table></figure><ul><li>  30-support</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#</span><br><span class="line">#    30-support - generate the support information</span><br><span class="line">#    Copyright (c) 2016 China Mobile</span><br><span class="line">#</span><br><span class="line">#    Authors: Haishuang Yan &lt;yanhaishuang@cmss.chinamobile.com&gt;</span><br><span class="line">#</span><br><span class="line">FORUM=&quot;https://ecloud.10086.cn/api/query/developer/user/home.html&quot;</span><br><span class="line"></span><br><span class="line">printf &quot;\n&quot;</span><br><span class="line">#printf &quot;  * Documentation:\n\t%s\n&quot;   &quot;$DOCS&quot;</span><br><span class="line">#printf &quot;  * Get Support  :\n\t%s\n&quot;   &quot;$SUPPORT&quot;</span><br><span class="line">#printf &quot;  * Ask Questions:\n\t%s\n&quot;   &quot;$FORUM&quot;</span><br><span class="line">printf &quot;  * Contact US   :\n\t%s\n&quot;   &quot;MAIL : 4001100865@cmss.chinamobile.com / TEL : 4001-10086-5&quot;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>  99-updates</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#</span><br><span class="line">#    30-updates - generate the updates information</span><br><span class="line">#    Copyright (c) 2016 China Mobile</span><br><span class="line">#</span><br><span class="line">#    Authors: Haishuang Yan &lt;yanhaishuang@cmss.chinamobile.com&gt;</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">#printf &quot;\n&quot;</span><br><span class="line">#UPDATES_COUNT=$(yum check-update --quiet | grep -v &quot;^$&quot; | wc -l)</span><br><span class="line">#UPDATES_SECURITY=$(yum check-update --security --quiet | grep -v &quot;^$&quot; | wc -l)</span><br><span class="line">#if [[ $UPDATES_COUNT -gt 0 ]]; then</span><br><span class="line">#    printf &quot;%s packages can be updated.\n&quot; $&#123;UPDATES_COUNT&#125;</span><br><span class="line">#    printf &quot;%s updates are security updates.\n&quot; $&#123;UPDATES_SECURITY&#125;</span><br><span class="line">#    printf &quot;type &#x27;yum check-update --security&#x27; to see details.\n&quot;</span><br><span class="line">#fi</span><br><span class="line"></span><br><span class="line">[ ! -d /etc/bigcloud/security ] &amp;&amp; mkdir -p /etc/bigcloud/security</span><br><span class="line"></span><br><span class="line">updates=/etc/bigcloud/security/updates</span><br><span class="line">check_security_updates() &#123;</span><br><span class="line">/usr/bin/check-security-updates &gt; /tmp/security_updates</span><br><span class="line">if [ $? -eq 0 ]; then</span><br><span class="line">cp /tmp/security_updates &quot;$updates&quot;</span><br><span class="line">rm -rf /tmp/security_updates</span><br><span class="line">fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if [ -f &quot;$updates&quot; ]; then</span><br><span class="line">        # Updates exists, see if it&#x27;s expired</span><br><span class="line">        now=$(date +%s)</span><br><span class="line">        lastrun=$(stat -c %Y &quot;$updates&quot;) 2&gt;/dev/null || lastrun=0</span><br><span class="line">        expiration=$(expr $lastrun + 86400)</span><br><span class="line">        if [ $now -ge $expiration ]; then</span><br><span class="line">                # Older than 1 day old, so update in the background</span><br><span class="line">                check_security_updates &amp;</span><br><span class="line">        elif [ -s &quot;$updates&quot; ]; then</span><br><span class="line">                # Less than 1 day old, and non-empty, so display now</span><br><span class="line">                cat &quot;$updates&quot;</span><br><span class="line">        fi</span><br><span class="line">else</span><br><span class="line">        # No cache at all, so update in the background</span><br><span class="line">check_security_updates &amp;</span><br><span class="line">fi</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>  新建欢迎脚本</li><li>  在00-header文件末尾添加cat /etc/update-motd.d/welcom-test</li><li>  然后执行：run-parts /etc/update-motd.d/</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;终端登陆前欢迎界面&quot;&gt;&lt;a href=&quot;#终端登陆前欢迎界面&quot; class=&quot;headerlink&quot; title=&quot;终端登陆前欢迎界面&quot;&gt;&lt;/a&gt;终端登陆前欢迎界面&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;  修改/etc/issue&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;# cat /etc/issue&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Authorized users only. All activities may be monitored and reported.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="LINUX" scheme="https://rma-shuyu.github.io/categories/LINUX/"/>
    
    
    <category term="linux" scheme="https://rma-shuyu.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>rm回收站</title>
    <link href="https://rma-shuyu.github.io/2024/06/03/rm%E5%9B%9E%E6%94%B6%E7%AB%99/"/>
    <id>https://rma-shuyu.github.io/2024/06/03/rm%E5%9B%9E%E6%94%B6%E7%AB%99/</id>
    <published>2024-06-03T03:34:45.000Z</published>
    <updated>2024-06-22T07:34:15.404Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一个方案就是重定向 rm 命令以嫁接为 mv 命令，相当于给 Linux 系统定制了一个回收站。</p></blockquote><span id="more"></span><p>实现方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">### 重定义rm命令 ### </span><br><span class="line"> </span><br><span class="line"># 定义回收站目录 </span><br><span class="line">trash_path=&#x27;/local/.trash&#x27;</span><br><span class="line"> </span><br><span class="line"># 判断 $trash_path 定义的文件是否存在，如果不存在，那么就创建 $trash_path.</span><br><span class="line">if [ ! -d $trash_path ]; then</span><br><span class="line">        mkdir -p $trash_path</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># 定义别名：使用 rm 就调用 trash </span><br><span class="line">alias rm=trash </span><br><span class="line"> </span><br><span class="line"># 使用 rl 就调用 &#x27;ls $trash_path&#x27;</span><br><span class="line">alias rl=&#x27;ls $trash_path&#x27;</span><br><span class="line"> </span><br><span class="line"># 使用 unrm 就调用 restorefile，需要在删除目录的父目录下执行 </span><br><span class="line">alias unrm=restorefile</span><br><span class="line"> </span><br><span class="line"># 使用 rmtrash 就调用 claearteash </span><br><span class="line">alias rmtrash=cleartrash</span><br><span class="line"> </span><br><span class="line"># 恢复文件的函数 </span><br><span class="line">restorefile() &#123;</span><br><span class="line">        mv -i $trash_path/$@ ./</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"># 删除文件的函数 </span><br><span class="line">trash() &#123;</span><br><span class="line">        mv $@ $trash_path/</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"># 清空回收站的函数 </span><br><span class="line">cleartrash() &#123;</span><br><span class="line">        read -p &quot;Are you sure about emptying the recycle bin?[y/n]&quot; confirm</span><br><span class="line">        [ $confirm == &#x27;y&#x27; ] || [ $confirm == &#x27;Y&#x27; ] &amp;&amp; /bin/rm -rf $trash_path/*</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后将上述脚本写入 /etc/profile，并立即执行命令 source /etc/profile 即刻生效。</p><p>这个脚本定义了几个命令：</p><ul><li>  rl：查看回收站下的文件。</li><li>  unrm 文件名或目录：恢复到当前的路径下。</li><li>  rmtrash：清空回收站，不过会友好提示。</li></ul><p>执行 rm 不会真正删除，而是使用 mv 移动到我们指定的回收站。实在真的想删除可以 /bin/rm 来进行删除。</p><p>另外，需要注意的是，之前 rm 指令的一些参数可能不再使用，因为 rm 现在其实是 mv 了。</p><p>使用示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># touch hoxistest </span><br><span class="line"># touch 1 </span><br><span class="line"># mkdir haha </span><br><span class="line"># ls </span><br><span class="line">1 haha hoxistest </span><br><span class="line"># rm 1 </span><br><span class="line"># ls </span><br><span class="line">haha hoxistest </span><br><span class="line"> </span><br><span class="line"># 查看回收站文件 </span><br><span class="line"># rl </span><br><span class="line">1 myftp1 </span><br><span class="line"> </span><br><span class="line"># 恢复已删除文件 </span><br><span class="line"># unrm 1 </span><br><span class="line">[root@CESHI\-CLM-10\-254\-4\-48 test\]# ls </span><br><span class="line">1 haha hoxistest </span><br><span class="line"> </span><br><span class="line"># rm haha/ </span><br><span class="line"># rm hoxistest </span><br><span class="line"># rl </span><br><span class="line">haha hoxistest </span><br><span class="line"> </span><br><span class="line"># 情况回收站 </span><br><span class="line"># rmtrash </span><br><span class="line">确定要清空回收站吗?\[y/n\]y </span><br><span class="line"># rl </span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;一个方案就是重定向 rm 命令以嫁接为 mv 命令，相当于给 Linux 系统定制了一个回收站。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="LINUX" scheme="https://rma-shuyu.github.io/categories/LINUX/"/>
    
    
    <category term="trash" scheme="https://rma-shuyu.github.io/tags/trash/"/>
    
  </entry>
  
  <entry>
    <title>ovs命令汇总</title>
    <link href="https://rma-shuyu.github.io/2024/05/24/ovs%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/"/>
    <id>https://rma-shuyu.github.io/2024/05/24/ovs%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/</id>
    <published>2024-05-24T10:09:54.000Z</published>
    <updated>2024-06-22T07:34:15.388Z</updated>
    
    <content type="html"><![CDATA[<h3 id="设备类"><a href="#设备类" class="headerlink" title="设备类"></a>设备类</h3><p><strong>查看当前ovs接管设备</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ovs-vsctl show</span><br></pre></td></tr></table></figure><span id="more"></span><p><strong>添加pccu端口</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ovs-vsctl add-port br-ext dpdk0 -- <span class="built_in">set</span> Interface dpdk0 <span class="built_in">type</span>=dpdk options:dpdk-devargs=0000:01:00.1 options:n_txq=8 options:n_rxq=8 options:n_rxq_desc=2048 options:n_txq_desc=2048 ofport_request=1</span><br></pre></td></tr></table></figure><h3 id="流表类"><a href="#流表类" class="headerlink" title="流表类"></a>流表类</h3><h4 id="流表配置"><a href="#流表配置" class="headerlink" title="流表配置"></a>流表配置</h4><p>通适配置，比如：端口net7 ↔ 端口dpdk0</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ovs-ofctl add-flow br-ext in_port=dpdk0,action=output:net7</span><br><span class="line">ovs-ofctl add-flow br-ext in_port=net7,action=output:dpdk0</span><br></pre></td></tr></table></figure><p>精确配置，比如：匹配mac，ip等报文特征</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##匹配源mac</span></span><br><span class="line">ovs-ofctl add-flow br-ext in_port=net0,dl_src=52:54:00:00:96:85,action=output:dpdk0</span><br><span class="line">ovs-ofctl add-flow br-ext in_port=dpdk0,dl_src=04:02:03:04:05:01,action=output:net0</span><br><span class="line"></span><br><span class="line"><span class="comment">##匹配目的mac</span></span><br><span class="line">ovs-ofctl add-flow br-ext in_port=net0,dl_dst=52:54:00:00:96:85,action=output:dpdk0</span><br><span class="line">ovs-ofctl add-flow br-ext in_port=dpdk0,dl_dst=04:02:03:04:05:01,action=output:net0</span><br><span class="line"></span><br><span class="line"><span class="comment">##匹配源mac+源IP+目的IP</span></span><br><span class="line">ovs-ofctl add-flow br-ext in_port=net7,dl_src=52:54:00:00:96:92,nw_src=7.7.7.3/32,nw_dst=7.7.7.2/32,action=output:dpdk0</span><br></pre></td></tr></table></figure><h4 id="常用匹配字段"><a href="#常用匹配字段" class="headerlink" title="常用匹配字段"></a>常用匹配字段</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##数据包入口</span></span><br><span class="line">in_port =&lt;port&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">##数据包源mac/目的mac</span></span><br><span class="line">dl_src/dl_dst=&lt;mac&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">##数据包源IP/目的IP</span></span><br><span class="line">nw_src/nw_dst=&lt;ip&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">##以太网协议类型</span></span><br><span class="line">dl_type=&lt;0xxxx&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">##nw_proto和dl_type字段协同使用，匹配协议</span></span><br><span class="line">nw_proto=&lt;num&gt;</span><br></pre></td></tr></table></figure><p><strong>常用协议方式如下</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ip</span><br><span class="line">dl_type=0x0800</span><br><span class="line"></span><br><span class="line">ipv6</span><br><span class="line">dl_type=0x86dd</span><br><span class="line"></span><br><span class="line">icmp</span><br><span class="line">dl_type=0x0800,nw_proto=1</span><br><span class="line"></span><br><span class="line">tcp</span><br><span class="line">dl_type=0x0800,nw_proto=6</span><br><span class="line"></span><br><span class="line">udp</span><br><span class="line">dl_type=0x0800,nw_proto=17</span><br><span class="line"></span><br><span class="line">arp</span><br><span class="line">dl_type=0x0806</span><br><span class="line"></span><br><span class="line">rarp</span><br><span class="line">dl_type=0x8035</span><br></pre></td></tr></table></figure><p><strong>匹配数据包vlan</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dl_vlan=&lt;vlan&gt;</span><br></pre></td></tr></table></figure><h4 id="动作执行字段"><a href="#动作执行字段" class="headerlink" title="动作执行字段"></a>动作执行字段</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##数据包从port接口发送</span></span><br><span class="line">output:port</span><br><span class="line"></span><br><span class="line"><span class="comment">##正常上送协议栈处理</span></span><br><span class="line">normal</span><br><span class="line"></span><br><span class="line"><span class="comment">##丢弃数据包</span></span><br><span class="line">drop</span><br><span class="line"></span><br><span class="line"><span class="comment">##转发到其他所有接口</span></span><br><span class="line">all</span><br></pre></td></tr></table></figure><h4 id="查看流表"><a href="#查看流表" class="headerlink" title="查看流表"></a>查看流表</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ovs-ofctl dump-flows br-ext</span><br></pre></td></tr></table></figure><h4 id="删除流表"><a href="#删除流表" class="headerlink" title="删除流表"></a>删除流表</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##删除br-ext下所有流表</span></span><br><span class="line">ovs-ofctl del-flows br-ext</span><br><span class="line"></span><br><span class="line"><span class="comment">##删除br-ext下 inport为dpdk0的流表，即删除匹配项对应流表</span></span><br><span class="line">ovs-ofctl del-flows br-ext in_port=dpdk0</span><br></pre></td></tr></table></figure><h3 id="统计类"><a href="#统计类" class="headerlink" title="统计类"></a>统计类</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##查看当前配置流表匹配情况</span></span><br><span class="line">ovs-ofctl dump-flows br-ext</span><br><span class="line"></span><br><span class="line"><span class="comment">##查看流表</span></span><br><span class="line">ovs-appctl bridge/dump-flows  --offload-stats br-ext</span><br><span class="line"></span><br><span class="line"><span class="comment">##查看网桥br-ext各端口收发包统计</span></span><br><span class="line">ovs-ofctl dump-ports br-ext</span><br><span class="line"></span><br><span class="line"><span class="comment">##查看流表报文统计(packets:11为慢速路径统计,dpe_packets:11为快速路径统计)</span></span><br><span class="line">ovs-appctl dpctl/dump-flows --names</span><br><span class="line"></span><br><span class="line"><span class="comment">##查看流表报文详细统计</span></span><br><span class="line">ovs-appctl dpctl/dump-flows -m</span><br><span class="line"></span><br><span class="line"><span class="comment">##查看卸载快表(关注字段offloaded:yes)</span></span><br><span class="line">ovs-appctl dpctl/dump-flows -m |grep <span class="built_in">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##清除快表</span></span><br><span class="line">ovs-appctl revalidator/purge</span><br><span class="line"></span><br><span class="line"><span class="comment">##查看dpdk0端口详细信息</span></span><br><span class="line">ovs-vsctl list interface dpdk0</span><br><span class="line"></span><br><span class="line"><span class="comment">##查看dpdk0端口计数</span></span><br><span class="line">ovs-vsctl get interface dpdk0 statistics</span><br></pre></td></tr></table></figure><h3 id="日志类"><a href="#日志类" class="headerlink" title="日志类"></a>日志类</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##放开ovs打印</span></span><br><span class="line">ovs-appctl vlog/disable-rate-limit</span><br><span class="line">ovs-appctl vlog/set netdev_offload_dpdk</span><br><span class="line">ovs-appctl vlog/set dpif_netdev</span><br><span class="line">ovs-appctl vlog/set conntrack</span><br><span class="line"></span><br><span class="line"><span class="comment">##查看ovs包含模块列表</span></span><br><span class="line">ovs-appctl vlog/list</span><br><span class="line"></span><br><span class="line"><span class="comment">##设置所有模块打印级别</span></span><br><span class="line">ovs-appctl vlog/set file:dbg</span><br><span class="line"></span><br><span class="line"><span class="comment">##设置netdev_dpdk模块打印级别</span></span><br><span class="line">ovs-appctl vlog/set netdev_dpdk:file:dbg</span><br><span class="line"></span><br><span class="line"><span class="comment">##查看jmnd log日志</span></span><br><span class="line">ovs-appctl vlog/set dpdk</span><br><span class="line">ovs-appctl dpdk/log-set lib.eal:debug pmd.net.jmnd.*:debug</span><br><span class="line"></span><br><span class="line"><span class="comment">##rxq绑核</span></span><br><span class="line"> ovs-vsctl <span class="built_in">set</span> Interface bm_hostnet0 other_config:pmd-rxq-affinity=0:2,1:3 //rxq:cpu</span><br></pre></td></tr></table></figure><p>通路测试，前后端对应接口寻找方法如下：</p><ul><li>前端virtio-net口，可通过ethtool -i ensX命令查看设备bdf</li><li>后端登录诊断(ssh <a href="mailto:&#x72;&#111;&#x6f;&#116;&#x40;&#49;&#x32;&#x37;&#x2e;&#49;">&#x72;&#111;&#x6f;&#116;&#x40;&#49;&#x32;&#x37;&#x2e;&#49;</a> -p 60000)，进入msg_cmd模式，敲device list，可查看当前系统所有设备bdf，<br>即bdf可唯一对应前端一个设备</li><li>通过ovs-vsctl show查看当前ovs接管设备，可通过比对接口参数(主要通过iface=/tmp/sock0)，唯一可对应到上述第二步的一个设备，<br>即virtio_net口&lt;—&gt;ovs接口唯一确定</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;设备类&quot;&gt;&lt;a href=&quot;#设备类&quot; class=&quot;headerlink&quot; title=&quot;设备类&quot;&gt;&lt;/a&gt;设备类&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;查看当前ovs接管设备&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ovs-vsctl show&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="LINUX" scheme="https://rma-shuyu.github.io/categories/LINUX/"/>
    
    
    <category term="ovs" scheme="https://rma-shuyu.github.io/tags/ovs/"/>
    
  </entry>
  
  <entry>
    <title>iperf使用</title>
    <link href="https://rma-shuyu.github.io/2024/05/24/iperf%E4%BD%BF%E7%94%A8/"/>
    <id>https://rma-shuyu.github.io/2024/05/24/iperf%E4%BD%BF%E7%94%A8/</id>
    <published>2024-05-24T09:41:51.000Z</published>
    <updated>2024-06-22T07:34:15.373Z</updated>
    
    <content type="html"><![CDATA[<h3 id="iperf3测试命令"><a href="#iperf3测试命令" class="headerlink" title="iperf3测试命令"></a>iperf3测试命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@xx:# iperf3 --help</span><br><span class="line">Usage: iperf3 [-s|-c host] [options]</span><br><span class="line">       iperf3 [-h|--help] [-v|--version]</span><br></pre></td></tr></table></figure><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">Server or Client:</span><br><span class="line">  -p, --port      #         server port to listen on/connect to</span><br><span class="line">  -f, --format   [kmgtKMGT] format to report: Kbits, Mbits, Gbits, Tbits</span><br><span class="line">  -i, --interval  #         seconds between periodic throughput reports</span><br><span class="line">  -F, --file name           xmit/recv the specified file</span><br><span class="line">  -A, --affinity n/n,m      set CPU affinity</span><br><span class="line">  -B, --bind      &lt;host&gt;    bind to the interface associated with the address &lt;host&gt;</span><br><span class="line">  -V, --verbose             more detailed output</span><br><span class="line">  -J, --json                output in JSON format</span><br><span class="line">  --logfile f               send output to a log file</span><br><span class="line">  --forceflush              force flushing output at every interval</span><br><span class="line">  -d, --debug               emit debugging output</span><br><span class="line">  -v, --version             show version information and quit</span><br><span class="line">  -h, --help                show this message and quit</span><br><span class="line">Server specific:</span><br><span class="line">  -s, --server              run in server mode</span><br><span class="line">  -D, --daemon             run the server as a daemon</span><br><span class="line">  -I, --pidfile file        write PID file</span><br><span class="line">  -1, --one-off             handle one client connection then exit</span><br><span class="line">  --rsa-private-key-path    path to the RSA private key used to decrypt</span><br><span class="line">                            authentication credentials</span><br><span class="line">  --authorized-users-path   path to the configuration file containing user</span><br><span class="line">                            credentials</span><br><span class="line">Client specific:</span><br><span class="line">  -c, --client    &lt;host&gt;    run in client mode, connecting to &lt;host&gt;</span><br><span class="line">  --sctp              use SCTP rather than TCP</span><br><span class="line">  -X, --xbind &lt;name&gt;        bind SCTP association to links</span><br><span class="line">  --nstreams      #         number of SCTP streams</span><br><span class="line">  -u, --udp                 use UDP rather than TCP</span><br><span class="line">  --connect-timeout #       timeout for control connection setup (ms)</span><br><span class="line">  -b, --bitrate #[KMG][/#]  target bitrate in bits/sec (0 for unlimited)</span><br><span class="line">                            (default 1 Mbit/sec for UDP, unlimited for TCP)</span><br><span class="line">                            (optional slash and packet count for burst mode)</span><br><span class="line">  --pacing-timer #[KMG]     set the timing for pacing, in microseconds (default 1000)</span><br><span class="line">  --fq-rate #[KMG]          enable fair-queuing based socket pacing in</span><br><span class="line">                            bits/sec (Linux only)</span><br><span class="line">  -t, --time      #         time in seconds to transmit for (default 10 secs)</span><br><span class="line">  -n, --bytes     #[KMG]    number of bytes to transmit (instead of -t)</span><br><span class="line">  -k, --blockcount #[KMG]   number of blocks (packets) to transmit (instead of -t or -n)</span><br><span class="line">  -l, --length    #[KMG]    length of buffer to read or write</span><br><span class="line">                            (default 128 KB for TCP, dynamic or 1460 for UDP)</span><br><span class="line">  --cport         &lt;port&gt;    bind to a specific client port (TCP and UDP, default: ephemeral port)</span><br><span class="line">  -P, --parallel  #         number of parallel client streams to run</span><br><span class="line">  -R, --reverse             run in reverse mode (server sends, client receives)</span><br><span class="line">  --bidir                   run in bidirectional mode.</span><br><span class="line">                            Client and server send and receive data.</span><br><span class="line">  -w, --window    #[KMG]    set window size / socket buffer size</span><br><span class="line">  -C, --congestion &lt;algo&gt;   set TCP congestion control algorithm (Linux and FreeBSD only)</span><br><span class="line">  -M, --set-mss   #         set TCP/SCTP maximum segment size (MTU - 40 bytes)</span><br><span class="line">  -N, --no-delay            set TCP/SCTP no delay, disabling Nagle&#x27;s Algorithm</span><br><span class="line">  -4, --version4            only use IPv4</span><br><span class="line">  -6, --version6            only use IPv6</span><br><span class="line">  -S, --tos N               set the IP type of service, 0-255.</span><br><span class="line">                            The usual prefixes for octal and hex can be used,</span><br><span class="line">                            i.e. 52, 064 and 0x34 all specify the same value.</span><br><span class="line">  --dscp N or --dscp val    set the IP dscp value, either 0-63 or symbolic.</span><br><span class="line">                            Numeric values can be specified in decimal,</span><br><span class="line">                            octal and hex (see --tos above).</span><br><span class="line">  -L, --flowlabel N         set the IPv6 flow label (only supported on Linux)</span><br><span class="line">  -Z, --zerocopy            use a &#x27;zero copy&#x27; method of sending data</span><br><span class="line">  -O, --omit N              omit the first n seconds</span><br><span class="line">  -T, --title str           prefix every output line with this string</span><br><span class="line">  --extra-data str          data string to include in client and server JSON</span><br><span class="line">  --get-server-output       get results from server</span><br><span class="line">  --udp-counters-64bit      use 64-bit counters in UDP test packets</span><br><span class="line">  --repeating-payload       use repeating pattern in payload, instead of</span><br><span class="line">                            randomized payload (like in iperf2)</span><br><span class="line">  --username                username for authentication</span><br><span class="line">  --rsa-public-key-path     path to the RSA public key used to encrypt</span><br><span class="line">                            authentication credentials</span><br><span class="line"> </span><br><span class="line">[KMG] indicates options that support a K/M/G suffix for kilo-, mega-, or giga-</span><br><span class="line"> </span><br><span class="line">iperf3 homepage at: https://software.es.net/iperf/</span><br><span class="line">Report bugs to:     https://github.com/esnet/iperf</span><br></pre></td></tr></table></figure><h4 id="iperf3测试命令示例"><a href="#iperf3测试命令示例" class="headerlink" title="iperf3测试命令示例"></a>iperf3测试命令示例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">##iperf server端(-s 启动server模式；-p 指定server端口号；-A指定绑核；-D后台运行)</span><br><span class="line">iperf3 -s -p 15000 -A 2 -D</span><br><span class="line"> </span><br><span class="line">##iperf clinet端(-c 启动client模式，后面紧跟连接的server端ip；-p 指定server端连接端口号；--cport指定client端源端口号；-P启动线程数；-t测试时间；-M 指定mss长度，udp测试使用-l指定)</span><br><span class="line">iperf3 -c 1.1.1.2 -p 15000 --cport 15000 -A 10 -P 1 -t 36000 -M 100 &gt; /dev/null &amp;</span><br></pre></td></tr></table></figure><h4 id="iperf3-结果分析"><a href="#iperf3-结果分析" class="headerlink" title="iperf3 结果分析"></a>iperf3 结果分析</h4><p><strong>udp测试结果分析</strong><br><img src="61e11abd927b51232fd4749d8b8ce5c063339a0a13fd30c04be54590b047f97d.png" alt="picture 1">  </p><ul><li>第一列 Interval：测试的时长</li><li>第二列 Transfer：在 Interval 时长里，传输的数据量</li><li>第三列 Bitrate：传输速率</li><li>第四列 Jitter：网络抖动，连续发送数据包时延差值的平均值，越小说明网络质量越好</li><li>第五列 Lost/Total Datagrams：丢失的数据包与发送的总数据包</li></ul><p><strong>tcp测试结果分析</strong><br><img src="5f7e502ff8046d757127e1c76a688191d165baf6035cc3099ee0b93e21d6f548.png" alt="picture 2">  </p><ul><li>第一列 Interval：测试的时长</li><li>第二列 Transfer：在 Interval 时长里，传输的数据量</li><li>第三列 Bitrate：传输速率</li><li>第四列 Retr：报文重传次数</li><li>第五列 Cwnd：拥塞窗口</li></ul><p><strong>性能数据统计</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sar -n ALL 1 1000 | egrep &quot;eno2|IFACE&quot;</span><br></pre></td></tr></table></figure><p><img src="8262bbc3838949d6197075f923f71883a20eaf644efe428283a901f340f41fbf.png" alt="picture 3">  </p><ul><li>IFACE：本地网卡接口的名称</li><li>rxpck/s：每秒钟接受的数据包</li><li>txpck/s：每秒钟发送的数据包</li><li>rxKB/s：每秒钟接受的数据包大小，单位为KB</li><li>txKB/s：每秒钟发送的数据包大小，单位为KB</li><li>rxcmp/s：每秒钟接受的压缩数据包</li><li>txcmp/s：每秒钟发送的压缩数据包</li><li>rxmcst/s：每秒钟接收的多播数据包</li></ul><h3 id="iperf3性能调优"><a href="#iperf3性能调优" class="headerlink" title="iperf3性能调优"></a>iperf3性能调优</h3><h4 id="网卡设置"><a href="#网卡设置" class="headerlink" title="网卡设置"></a>网卡设置</h4><p><strong>RX队列大小设置</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ethtool -g ens6 ##查看队列深度</span><br><span class="line"></span><br><span class="line">ethtool -G ens6 rx 4096 ##修改队列深度</span><br></pre></td></tr></table></figure><p><img src="91aa41ea41f64434997ff6f6b6171978da16f0861e10968c48b2a18f7fc64102.png" alt="picture 4">  </p><p>根据需要修改队列深度等信息，例如：修改为8192队列深度实例 (版本路径/usr/share/jmnd/single/auto/xml/interface_module.xml)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;interface type=&#x27;vhostuser&#x27;&gt;</span><br><span class="line">        &lt;mac address=&#x27;&#123;INTERFACE_MAC&#125;&#x27;/&gt;</span><br><span class="line">      &lt;model type=&#x27;&#123;VIRTIO&#125;&#x27;/&gt;</span><br><span class="line">      &lt;driver queues=&#x27;&#123;INTERFACE_QUEUES&#125;&#x27; mq=&#x27;&#123;MQ_EN&#125;&#x27;  packed=&#x27;on&#x27; rx_queue_size=&#x27;8192&#x27; tx_queue_size=&#x27;8192&#x27;/&gt;</span><br><span class="line">      &lt;source type=&#x27;unix&#x27; path=&#x27;&#123;INTERFACE_NAME&#125;&#x27; mode=&#x27;server&#x27;/&gt;</span><br><span class="line">&lt;/interface&gt;</span><br></pre></td></tr></table></figure><p><strong>RX队列数量设置</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ethtool -l ens6 ##查看队列数</span><br><span class="line"></span><br><span class="line">ethtool -L eth0 rx 8 ##将RX queue数量都设置为8</span><br><span class="line"></span><br><span class="line">ethtool -L eth0 combined 8 ##将RX queue和TX queue 数量都设置为8</span><br></pre></td></tr></table></figure><p><img src="4702bd070e7e31a961b062edd5a102c9aa92c934ac0666487a3186519fe4dea0.png" alt="picture 5">  </p><p>根据需要修改队列数目等信息，例如：修改为32 qp_num (版本路径/usr/share/jmnd/single/auto/config/base_config.json)</p><p><strong>offload配置</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ethtool -K eth1 tso on</span><br><span class="line"></span><br><span class="line">ethtool -K eth1 gro on</span><br></pre></td></tr></table></figure><h4 id="pcie链路速率"><a href="#pcie链路速率" class="headerlink" title="pcie链路速率"></a>pcie链路速率</h4><p>lspci -tv<br><img src="9389779ec336b5e5a888f9d9e29a75c02f48c81e2498b931def056b4ba583a59.png" alt="picture 6">  </p><p>lspci -s 3c:01.0 -vvv ##确认pcie链路协商Gen5 X16模式<br><img src="9090347a15d0d6d2a1e78684745b644839107d1d4c3f2d888890f027f3d75731.png" alt="picture 7">  </p><h4 id="cpu亲核性"><a href="#cpu亲核性" class="headerlink" title="cpu亲核性"></a>cpu亲核性</h4><p>查询numa node<br><img src="fab2771f845bd245f79ec46b7c7e795f7aa75ff4d74451f3988d280a59adca43.png" alt="picture 8">  </p><p>lspci -s 47:00.0 -vvv | grep NUMA<br><img src="b0903ba3f571c9a3af287cfa659ab974026b310717208d2b788d6c0382581ee0.png" alt="picture 9">  </p><p>lscpu | grep NUMA<br><img src="7fe9154566eb5bef83784bf999bbc9450613120dbbc51982fabcfbcb1f16fb6e.png" alt="picture 10">  </p><h4 id="pcie-MPS-amp-MRRS"><a href="#pcie-MPS-amp-MRRS" class="headerlink" title="pcie MPS &amp; MRRS"></a>pcie MPS &amp; MRRS</h4><p><img src="45ed931416bb15b3e982fb3269fab046982f9a0ab3fbe6f5fe880d8c99bbb823.png" alt="picture 11">  </p><h4 id="cpu设置为高性能模式"><a href="#cpu设置为高性能模式" class="headerlink" title="cpu设置为高性能模式"></a>cpu设置为高性能模式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpupower frequency-set -g performance</span><br></pre></td></tr></table></figure><h4 id="协议栈优化"><a href="#协议栈优化" class="headerlink" title="协议栈优化"></a>协议栈优化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">##修改内核套接字接受缓存区默认的大小</span><br><span class="line">echo 2147483647 &gt;/proc/sys/net/core/rmem_default</span><br><span class="line">##修改内核套接字接受缓存区最大值</span><br><span class="line">echo 2147483647 &gt;/proc/sys/net/core/rmem_max</span><br><span class="line">##关闭内核看门狗</span><br><span class="line">echo 0 &gt; /proc/sys/kernel/watchdog</span><br><span class="line">##设置 watchdog_thresh参数来定义发现softlockup以后系统panic的时间</span><br><span class="line">echo 0 &gt; /proc/sys/kernel/watchdog_thresh</span><br></pre></td></tr></table></figure><h4 id="XPS绑核"><a href="#XPS绑核" class="headerlink" title="XPS绑核"></a>XPS绑核</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#下指令是将指定net的全队列取消绑定在所有cpu上</span><br><span class="line">find /sys/class/net/ens14/queues/tx-* -type f -name &quot;xps_cpus&quot; -exec sh -c &#x27;echo &quot;ffffffff,ffffffff,ffffffff,ffffffff,ffffffff,ffffffff&quot; &gt;&gt; &#123;&#125;&#x27; \;</span><br><span class="line"></span><br><span class="line">#如需队列绑定指定CPU,如ens14的tx-0队列绑定cpu96：</span><br><span class="line">echo &quot;00000000,00000000,00000001,00000000,00000000,00000000&quot; &gt; /sys/class/net/ens14/queues/tx-0/xps_cpus</span><br></pre></td></tr></table></figure><h4 id="RPS绑核"><a href="#RPS绑核" class="headerlink" title="RPS绑核"></a>RPS绑核</h4><p>rps绑核方式和xps类似，文件名 有所差异：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;00000000,00000000,00000001,00000000,00000000,00000000&quot; &gt; /sys/class/net/ens14/queues/rx-0/rps_cpus</span><br></pre></td></tr></table></figure><h4 id="中断绑核"><a href="#中断绑核" class="headerlink" title="中断绑核"></a>中断绑核</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/interrupts | grep virtio1 | grep output ##查找中断号，output表示tx队列中断，input表示rx队列中断，config表示配置中断</span><br></pre></td></tr></table></figure><p><img src="7787f79c6d5f071e4623aa3cfc95bbaa5e7ac3672a1a7aea70e5ece9a3787583.png" alt="picture 12">  </p><p>第一列为中断号，后续18列分别对应cpu 0 - cpu 17中断处理个数(查看cpu方式见上) ，最后一列为中断名称(output表示tx队列中断，input表示rx队列中断，config表示配置中断)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $cpu_id &gt; /proc/irq/$interrupts/smp_affinity_list ##设置中断绑核</span><br></pre></td></tr></table></figure><h4 id="RFS配置"><a href="#RFS配置" class="headerlink" title="RFS配置"></a>RFS配置</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo 32768 &gt; /proc/sys/net/core/rps_sock_flow_entries</span><br><span class="line"></span><br><span class="line">echo 1024 &gt; /sys/class/net/ens$i/queues/rx-&lt;n&gt;/rps_flow_cnt ## rps_sock flow_entries = rps_flow_cnt * N；其中，N为队列数量，每个设备是独立的。</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;iperf3测试命令&quot;&gt;&lt;a href=&quot;#iperf3测试命令&quot; class=&quot;headerlink&quot; title=&quot;iperf3测试命令&quot;&gt;&lt;/a&gt;iperf3测试命令&lt;/h3&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;root@xx:# iperf3 --help&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Usage: iperf3 [-s|-c host] [options]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       iperf3 [-h|--help] [-v|--version]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="LINUX" scheme="https://rma-shuyu.github.io/categories/LINUX/"/>
    
    
    <category term="iperf" scheme="https://rma-shuyu.github.io/tags/iperf/"/>
    
  </entry>
  
  <entry>
    <title>rpm 软件包安装位置</title>
    <link href="https://rma-shuyu.github.io/2024/05/13/rpm-%E8%BD%AF%E4%BB%B6%E5%8C%85%E5%AE%89%E8%A3%85%E4%BD%8D%E7%BD%AE/"/>
    <id>https://rma-shuyu.github.io/2024/05/13/rpm-%E8%BD%AF%E4%BB%B6%E5%8C%85%E5%AE%89%E8%A3%85%E4%BD%8D%E7%BD%AE/</id>
    <published>2024-05-13T07:46:51.000Z</published>
    <updated>2024-06-22T07:34:15.404Z</updated>
    
    <content type="html"><![CDATA[<h3 id="rpm-软件包安装位置"><a href="#rpm-软件包安装位置" class="headerlink" title="rpm 软件包安装位置"></a>rpm 软件包安装位置</h3><p>想要查看 rpm 软件包安装目录，需要先知道 rpm 软件包全名，然后使用<code>rpm -ql [pakageName]</code>命令，就能输出安装目录。</p><span id="more"></span><h3 id="rpm-软件包全名"><a href="#rpm-软件包全名" class="headerlink" title="rpm 软件包全名"></a>rpm 软件包全名</h3><p>以安装 nodejs 为例，并使用<code>rpm -qa|grep nodejs</code>查找 rpm 软件包全名。</p><ol><li>安装 nodejs 软件。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@centos ~]# yum install nodejs</span><br></pre></td></tr></table></figure></li><li>查找 rpm 软件包全名。 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># nodejs 版本</span><br><span class="line">[root@centos ~]# node -v</span><br><span class="line">v6.17.1</span><br><span class="line"># rpm 包全名</span><br><span class="line">[root[@centos] ~]# rpm -qa|grep nodejs</span><br><span class="line">nodejs-6.17.1-1.el7.x86_64</span><br></pre></td></tr></table></figure></li></ol><h3 id="rpm-软件包安装目录"><a href="#rpm-软件包安装目录" class="headerlink" title="rpm 软件包安装目录"></a>rpm 软件包安装目录</h3><p>使用<code>rpm -ql [pakageName]</code>查找输出安装目录。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@centos ~]# rpm -ql nodejs-6.17.1-1.el7.x86_64</span><br><span class="line">/usr/bin/node</span><br><span class="line">/usr/lib/dtrace</span><br><span class="line">/usr/lib/dtrace/node.d</span><br><span class="line">/usr/lib/node_modules</span><br><span class="line">/usr/lib/rpm/fileattrs/nodejs_native.attr</span><br><span class="line">/usr/lib/rpm/nodejs_native.req</span><br><span class="line">/usr/share/doc/nodejs-6.17.1</span><br><span class="line">/usr/share/doc/nodejs-6.17.1/AUTHORS</span><br><span class="line">/usr/share/doc/nodejs-6.17.1/CHANGELOG.md</span><br><span class="line">/usr/share/doc/nodejs-6.17.1/COLLABORATOR_GUIDE.md</span><br><span class="line">/usr/share/doc/nodejs-6.17.1/GOVERNANCE.md</span><br><span class="line">/usr/share/doc/nodejs-6.17.1/README.md</span><br><span class="line">/usr/share/licenses/nodejs-6.17.1</span><br><span class="line">/usr/share/licenses/nodejs-6.17.1/LICENSE</span><br><span class="line">/usr/share/man/man1/node.1.gz</span><br><span class="line">/usr/share/node</span><br><span class="line">/usr/share/systemtap</span><br><span class="line">/usr/share/systemtap/tapset</span><br><span class="line">/usr/share/systemtap/tapset/node.stp</span><br></pre></td></tr></table></figure><p>到此，已获取 nodejs 安装目录。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;rpm-软件包安装位置&quot;&gt;&lt;a href=&quot;#rpm-软件包安装位置&quot; class=&quot;headerlink&quot; title=&quot;rpm 软件包安装位置&quot;&gt;&lt;/a&gt;rpm 软件包安装位置&lt;/h3&gt;&lt;p&gt;想要查看 rpm 软件包安装目录，需要先知道 rpm 软件包全名，然后使用&lt;code&gt;rpm -ql [pakageName]&lt;/code&gt;命令，就能输出安装目录。&lt;/p&gt;</summary>
    
    
    
    <category term="LINUX" scheme="https://rma-shuyu.github.io/categories/LINUX/"/>
    
    
    <category term="rpm" scheme="https://rma-shuyu.github.io/tags/rpm/"/>
    
  </entry>
  
  <entry>
    <title>Dockerfile 指令详解</title>
    <link href="https://rma-shuyu.github.io/2024/04/26/Dockerfile-%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/"/>
    <id>https://rma-shuyu.github.io/2024/04/26/Dockerfile-%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/</id>
    <published>2024-04-26T08:47:17.000Z</published>
    <updated>2024-06-22T07:34:15.319Z</updated>
    
    <content type="html"><![CDATA[<h3 id="FROM-指定基础镜像"><a href="#FROM-指定基础镜像" class="headerlink" title="FROM 指定基础镜像"></a>FROM 指定基础镜像</h3><p><code>FROM</code> 指令用于指定其后构建新镜像所使用的基础镜像。<code>FROM </code>指令必是 <code>Dockerfile</code> 文件中的首条命令，启动构建流程后，<code>Docker</code> 将会基于该镜像构建新镜像，<code>FROM</code> 后的命令也会基于这个基础镜像。</p><span id="more"></span><p>FROM语法格式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM &lt;image&gt;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM &lt;image&gt;:&lt;tag&gt;</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM &lt;image&gt;:&lt;digest&gt;</span><br></pre></td></tr></table></figure><p>通过 FROM 指定的镜像，可以是任何有效的基础镜像。FROM 有以下限制：</p><ul><li>  FROM 必须 是 Dockerfile 中第一条非注释命令</li><li>  在一个 Dockerfile 文件中创建多个镜像时，FROM 可以多次出现。只需在每个新命令 FROM 之前，记录提交上次的镜像 ID。</li><li>  tag 或 digest 是可选的，如果不使用这两个值时，会使用 latest 版本的基础镜像</li></ul><h3 id="RUN-执行命令"><a href="#RUN-执行命令" class="headerlink" title="RUN 执行命令"></a>RUN 执行命令</h3><p>在镜像的构建过程中执行特定的命令，并生成一个中间镜像。格式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#shell格式</span><br><span class="line">RUN &lt;command&gt;</span><br><span class="line">#exec格式</span><br><span class="line">RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>  RUN 命令将在当前 image 中执行任意合法命令并提交执行结果。命令执行提交后，就会自动执行 Dockerfile 中的下一个指令。</li><li>  层级 RUN 指令和生成提交是符合 Docker 核心理念的做法。它允许像版本控制那样，在任意一个点，对 image 镜像进行定制化构建。</li><li>  RUN 指令创建的中间镜像会被缓存，并会在下次构建中使用。如果不想使用这些缓存镜像，可以在构建时指定 <code>--no-cache</code> 参数，如：<code>docker build --no-cache</code>。</li></ul><h3 id="COPY-复制文件"><a href="#COPY-复制文件" class="headerlink" title="COPY 复制文件"></a>COPY 复制文件</h3><p>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">COPY &lt;源路径&gt;... &lt;目标路径&gt;</span><br><span class="line">COPY [&quot;&lt;源路径1&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>和 RUN 指令一样，也有两种格式，一种类似于命令行，一种类似于函数调用。COPY 指令将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的<code>&lt;目标路径&gt;</code>位置。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COPY package.json /usr/src/app/</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>&lt;源路径&gt;</code>可以是多个，甚至可以是通配符，其通配符规则要满足 Go 的 filepath.Match 规则，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">COPY hom* /mydir/</span><br><span class="line">COPY hom?.txt /mydir/</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>&lt;目标路径&gt;</code>可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用 WORKDIR 指令来指定）。目标路径不需要事先创建，如果目录不存在会在复制文件前先行创建缺失目录。</p><p>此外，还需要注意一点，使用 COPY 指令，源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。这个特性对于镜像定制很有用。特别是构建相关文件都在使用 Git 进行管理的时候。</p><h3 id="ADD-更高级的复制文件"><a href="#ADD-更高级的复制文件" class="headerlink" title="ADD 更高级的复制文件"></a>ADD 更高级的复制文件</h3><p>ADD 指令和 COPY 的格式和性质基本一致。但是在 COPY 基础上增加了一些功能。比如<code>&lt;源路径&gt;</code>可以是一个 URL，这种情况下，Docker 引擎会试图去下载这个链接的文件放到<code>&lt;目标路径&gt;</code>去，并且会将tar包解压。</p><p>在构建镜像时，复制上下文中的文件到镜像内，格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ADD &lt;源路径&gt;... &lt;目标路径&gt;</span><br><span class="line">ADD [&quot;&lt;源路径&gt;&quot;,... &quot;&lt;目标路径&gt;&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>注意</strong><br>如果 docker 发现文件内容被改变，则接下来的指令都不会再使用缓存。关于复制文件时需要处理的/，基本跟正常的 copy 一致</p><h3 id="ENV-设置环境变量"><a href="#ENV-设置环境变量" class="headerlink" title="ENV 设置环境变量"></a>ENV 设置环境变量</h3><p>格式有两种：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ENV &lt;key&gt; &lt;value&gt;</span><br><span class="line">ENV &lt;key1&gt;=&lt;value1&gt; &lt;key2&gt;=&lt;value2&gt;...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个指令很简单，就是设置环境变量而已，无论是后面的其它指令，如 RUN，还是运行时的应用，都可以直接使用这里定义的环境变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ENV VERSION=1.0 DEBUG=on \</span><br><span class="line">    NAME=&quot;Happy Feet&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个例子中演示了如何换行，以及对含有空格的值用双引号括起来的办法，这和 Shell 下的行为是一致的。</p><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p>为构建的镜像设置监听端口，使容器在运行时监听。格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE &lt;port&gt; [&lt;port&gt;...]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>EXPOSE 指令并不会让容器监听 host 的端口，如果需要，需要在 docker run 时使用 <code>-p</code>、<code>-P</code> 参数来发布容器端口到 host 的某个端口上。</p><h3 id="VOLUME-定义匿名卷"><a href="#VOLUME-定义匿名卷" class="headerlink" title="VOLUME 定义匿名卷"></a>VOLUME 定义匿名卷</h3><p>VOLUME用于创建挂载点，即向基于所构建镜像创始的容器添加卷：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [&quot;/data&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一个卷可以存在于一个或多个容器的指定目录，该目录可以绕过联合文件系统，并具有以下功能：</p><ul><li>  卷可以容器间共享和重用</li><li>  容器并不一定要和其它容器共享卷</li><li>  修改卷后会立即生效</li><li>  对卷的修改不会对镜像产生影响</li><li>  卷会一直存在，直到没有任何容器在使用它</li></ul><p>VOLUME 让我们可以将源代码、数据或其它内容添加到镜像中，而又不并提交到镜像中，并使我们可以多个容器间共享这些内容。</p><h3 id="WORKDIR-指定工作目录"><a href="#WORKDIR-指定工作目录" class="headerlink" title="WORKDIR 指定工作目录"></a>WORKDIR 指定工作目录</h3><p>WORKDIR用于在容器内设置一个工作目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /path/to/workdir</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过WORKDIR设置工作目录后，Dockerfile 中其后的命令 RUN、CMD、ENTRYPOINT、ADD、COPY 等命令都会在该目录下执行。<br>如，使用WORKDIR设置工作目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WORKDIR /a</span><br><span class="line">WORKDIR b</span><br><span class="line">WORKDIR c</span><br><span class="line">RUN pwd</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在以上示例中，pwd 最终将会在 <code>/a/b/c</code> 目录中执行。在使用 docker run 运行容器时，可以通过<code>-w</code>参数覆盖构建时所设置的工作目录。</p><h3 id="USER-指定当前用户"><a href="#USER-指定当前用户" class="headerlink" title="USER 指定当前用户"></a>USER 指定当前用户</h3><p>USER 用于指定运行镜像所使用的用户：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">USER daemon</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用USER指定用户时，可以使用用户名、UID 或 GID，或是两者的组合。以下都是合法的指定试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">USER user</span><br><span class="line">USER user:group</span><br><span class="line">USER uid</span><br><span class="line">USER uid:gid</span><br><span class="line">USER user:gid</span><br><span class="line">USER uid:group</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用USER指定用户后，Dockerfile 中其后的命令 RUN、CMD、ENTRYPOINT 都将使用该用户。镜像构建完成后，通过 docker run 运行容器时，可以通过 <code>-u</code> 参数来覆盖所指定的用户。</p><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><p>CMD用于指定在容器启动时所要执行的命令。CMD 有以下三种格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</span><br><span class="line">CMD [&quot;param1&quot;,&quot;param2&quot;]</span><br><span class="line">CMD command param1 param2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>省略可执行文件的 exec 格式，这种写法使 CMD 中的参数当做 ENTRYPOINT 的默认参数，此时 ENTRYPOINT 也应该是 exec 格式，具体与 ENTRYPOINT 的组合使用，参考 ENTRYPOINT。</p><p><strong>注意</strong><br>与 RUN 指令的区别：RUN 在构建的时候执行，并生成一个新的镜像，CMD 在容器运行的时候执行，在构建时不进行任何操作。</p><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><p>ENTRYPOINT 用于给容器配置一个可执行程序。也就是说，每次使用镜像创建容器时，通过 ENTRYPOINT 指定的程序都会被设置为默认程序。ENTRYPOINT 有以下两种形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</span><br><span class="line">ENTRYPOINT command param1 param2</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ENTRYPOINT 与 CMD 非常类似，不同的是通过<code>docker run</code>执行的命令不会覆盖 ENTRYPOINT，而<code>docker run</code>命令中指定的任何参数，都会被当做参数再次传递给 ENTRYPOINT。Dockerfile 中只允许有一个 ENTRYPOINT 命令，多指定时会覆盖前面的设置，而只执行最后的 ENTRYPOINT 指令。</p><p><code>docker run</code>运行容器时指定的参数都会被传递给 ENTRYPOINT ，且会覆盖 CMD 命令指定的参数。如，执行<code>docker run &lt;image&gt; -d</code>时，-d 参数将被传递给入口点。</p><p>也可以通过<code>docker run --entrypoint</code>重写 ENTRYPOINT 入口点。如：可以像下面这样指定一个容器执行程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;/usr/bin/nginx&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>完整构建代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Version: 0.0.3</span><br><span class="line">FROM ubuntu:16.04</span><br><span class="line">MAINTAINER 何民三 &quot;cn.liuht@gmail.com&quot;</span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get install -y nginx</span><br><span class="line">RUN echo &#x27;Hello World, 我是个容器&#x27; \ </span><br><span class="line">   &gt; /var/www/html/index.html</span><br><span class="line">ENTRYPOINT [&quot;/usr/sbin/nginx&quot;]</span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用docker build构建镜像，并将镜像指定为 itbilu/test：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build -t=&quot;itbilu/test&quot; .</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>构建完成后，使用itbilu/test启动一个容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -i -t  itbilu/test -g &quot;daemon off;&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在运行容器时，我们使用了 <code>-g &quot;daemon off;&quot;</code>，这个参数将会被传递给 ENTRYPOINT，最终在容器中执行的命令为 <code>/usr/sbin/nginx -g &quot;daemon off;&quot;</code>。</p><h3 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h3><p>LABEL用于为镜像添加元数据，元数以键值对的形式指定：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用LABEL指定元数据时，一条LABEL指定可以指定一或多条元数据，指定多条元数据时不同元数据之间通过空格分隔。推荐将所有的元数据通过一条LABEL指令指定，以免生成过多的中间镜像。<br>如，通过LABEL指定一些元数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LABEL version=&quot;1.0&quot; description=&quot;这是一个Web服务器&quot; by=&quot;IT笔录&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>指定后可以通过docker inspect查看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker inspect itbilu/test</span><br><span class="line">&quot;Labels&quot;: &#123;</span><br><span class="line">    &quot;version&quot;: &quot;1.0&quot;,</span><br><span class="line">    &quot;description&quot;: &quot;这是一个Web服务器&quot;,</span><br><span class="line">    &quot;by&quot;: &quot;IT笔录&quot;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h3><p>ARG用于指定传递给构建运行时的变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ARG &lt;name&gt;[=&lt;default value&gt;]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如，通过ARG指定两个变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ARG site</span><br><span class="line">ARG build_user=IT笔录</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上我们指定了 site 和 build_user 两个变量，其中 build_user 指定了默认值。在使用 docker build 构建镜像时，可以通过 <code>--build-arg &lt;varname&gt;=&lt;value&gt;</code> 参数来指定或重设置这些变量的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker build --build-arg site=itiblu.com -t itbilu/test .</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样我们构建了 itbilu/test 镜像，其中site会被设置为 itbilu.com，由于没有指定 build_user，其值将是默认值 IT 笔录。</p><h3 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h3><p>ONBUILD用于设置镜像触发器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ONBUILD [INSTRUCTION]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当所构建的镜像被用做其它镜像的基础镜像，该镜像中的触发器将会被钥触发。<br>如，当镜像被使用时，可能需要做一些处理：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[...]</span><br><span class="line">ONBUILD ADD . /app/src</span><br><span class="line">ONBUILD RUN /usr/local/bin/python-build --dir /app/src</span><br><span class="line">[...]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="STOPSIGNAL"><a href="#STOPSIGNAL" class="headerlink" title="STOPSIGNAL"></a>STOPSIGNAL</h3><p>STOPSIGNAL用于设置停止容器所要发送的系统调用信号：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">STOPSIGNAL signal</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所使用的信号必须是内核系统调用表中的合法的值，如：SIGKILL。</p><h3 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a>SHELL</h3><p>SHELL用于设置执行命令（shell式）所使用的的默认 shell 类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHELL [&quot;executable&quot;, &quot;parameters&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>SHELL在Windows环境下比较有用，Windows 下通常会有 cmd 和 powershell 两种 shell，可能还会有 sh。这时就可以通过 SHELL 来指定所使用的 shell 类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">FROM microsoft/windowsservercore</span><br><span class="line"></span><br><span class="line"># Executed as cmd /S /C echo default</span><br><span class="line">RUN echo default</span><br><span class="line"></span><br><span class="line"># Executed as cmd /S /C powershell -command Write-Host default</span><br><span class="line">RUN powershell -command Write-Host default</span><br><span class="line"></span><br><span class="line"># Executed as powershell -command Write-Host hello</span><br><span class="line">SHELL [&quot;powershell&quot;, &quot;-command&quot;]</span><br><span class="line">RUN Write-Host hello</span><br><span class="line"></span><br><span class="line"># Executed as cmd /S /C echo hello</span><br><span class="line">SHELL [&quot;cmd&quot;, &quot;/S&quot;&quot;, &quot;/C&quot;]</span><br><span class="line">RUN echo hello</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Dockerfile-示例"><a href="#Dockerfile-示例" class="headerlink" title="Dockerfile 示例"></a>Dockerfile 示例</h3><p><strong>构建Nginx运行环境</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"># 指定基础镜像</span><br><span class="line">FROM sameersbn/ubuntu:14.04.20161014</span><br><span class="line"></span><br><span class="line"># 维护者信息</span><br><span class="line">MAINTAINER sameer@damagehead.com</span><br><span class="line"></span><br><span class="line"># 设置环境</span><br><span class="line">ENV RTMP_VERSION=1.1.10 \</span><br><span class="line">    NPS_VERSION=1.11.33.4 \</span><br><span class="line">    LIBAV_VERSION=11.8 \</span><br><span class="line">    NGINX_VERSION=1.10.1 \</span><br><span class="line">    NGINX_USER=www-data \</span><br><span class="line">    NGINX_SITECONF_DIR=/etc/nginx/sites-enabled \</span><br><span class="line">    NGINX_LOG_DIR=/var/log/nginx \</span><br><span class="line">    NGINX_TEMP_DIR=/var/lib/nginx \</span><br><span class="line">    NGINX_SETUP_DIR=/var/cache/nginx</span><br><span class="line"></span><br><span class="line"># 设置构建时变量，镜像建立完成后就失效</span><br><span class="line">ARG BUILD_LIBAV=false</span><br><span class="line">ARG WITH_DEBUG=false</span><br><span class="line">ARG WITH_PAGESPEED=true</span><br><span class="line">ARG WITH_RTMP=true</span><br><span class="line"></span><br><span class="line"># 复制本地文件到容器目录中</span><br><span class="line">COPY setup/ $&#123;NGINX_SETUP_DIR&#125;/</span><br><span class="line">RUN bash $&#123;NGINX_SETUP_DIR&#125;/install.sh</span><br><span class="line"></span><br><span class="line"># 复制本地配置文件到容器目录中</span><br><span class="line">COPY nginx.conf /etc/nginx/nginx.conf</span><br><span class="line">COPY entrypoint.sh /sbin/entrypoint.sh</span><br><span class="line"></span><br><span class="line"># 运行指令</span><br><span class="line">RUN chmod 755 /sbin/entrypoint.sh</span><br><span class="line"></span><br><span class="line"># 允许指定的端口</span><br><span class="line">EXPOSE 80/tcp 443/tcp 1935/tcp</span><br><span class="line"></span><br><span class="line"># 指定网站目录挂载点</span><br><span class="line">VOLUME [&quot;$&#123;NGINX_SITECONF_DIR&#125;&quot;]</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [&quot;/sbin/entrypoint.sh&quot;]</span><br><span class="line">CMD [&quot;/usr/sbin/nginx&quot;]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>构建tomcat 环境</strong></p><p>Dockerfile文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"># 指定基于的基础镜像</span><br><span class="line">FROM ubuntu:13.10  </span><br><span class="line"></span><br><span class="line"># 维护者信息</span><br><span class="line">MAINTAINER zhangjiayang &quot;zhangjiayang@sczq.com.cn&quot;  </span><br><span class="line">  </span><br><span class="line"># 镜像的指令操作</span><br><span class="line"># 获取APT更新的资源列表</span><br><span class="line">RUN echo &quot;deb http://archive.ubuntu.com/ubuntu precise main universe&quot;&gt; /etc/apt/sources.list</span><br><span class="line"># 更新软件</span><br><span class="line">RUN apt-get update  </span><br><span class="line">  </span><br><span class="line"># Install curl  </span><br><span class="line">RUN apt-get -y install curl  </span><br><span class="line">  </span><br><span class="line"># Install JDK 7  </span><br><span class="line">RUN cd /tmp &amp;&amp;  curl -L &#x27;http://download.oracle.com/otn-pub/java/jdk/7u65-b17/jdk-7u65-linux-x64.tar.gz&#x27; -H &#x27;Cookie: oraclelicense=accept-securebackup-cookie; gpw_e24=Dockerfile&#x27; | tar -xz  </span><br><span class="line">RUN mkdir -p /usr/lib/jvm  </span><br><span class="line">RUN mv /tmp/jdk1.7.0_65/ /usr/lib/jvm/java-7-oracle/  </span><br><span class="line">  </span><br><span class="line"># Set Oracle JDK 7 as default Java  </span><br><span class="line">RUN update-alternatives --install /usr/bin/java java /usr/lib/jvm/java-7-oracle/bin/java 300     </span><br><span class="line">RUN update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/java-7-oracle/bin/javac 300     </span><br><span class="line"></span><br><span class="line"># 设置系统环境</span><br><span class="line">ENV JAVA_HOME /usr/lib/jvm/java-7-oracle/  </span><br><span class="line">  </span><br><span class="line"># Install tomcat7  </span><br><span class="line">RUN cd /tmp &amp;&amp; curl -L &#x27;http://archive.apache.org/dist/tomcat/tomcat-7/v7.0.8/bin/apache-tomcat-7.0.8.tar.gz&#x27; | tar -xz  </span><br><span class="line">RUN mv /tmp/apache-tomcat-7.0.8/ /opt/tomcat7/  </span><br><span class="line">  </span><br><span class="line">ENV CATALINA_HOME /opt/tomcat7  </span><br><span class="line">ENV PATH $PATH:$CATALINA_HOME/bin  </span><br><span class="line"></span><br><span class="line"># 复件tomcat7.sh到容器中的目录 </span><br><span class="line">ADD tomcat7.sh /etc/init.d/tomcat7  </span><br><span class="line">RUN chmod 755 /etc/init.d/tomcat7  </span><br><span class="line">  </span><br><span class="line"># Expose ports.  指定暴露的端口</span><br><span class="line">EXPOSE 8080  </span><br><span class="line">  </span><br><span class="line"># Define default command.  </span><br><span class="line">ENTRYPOINT service tomcat7 start &amp;&amp; tail -f /opt/tomcat7/logs/catalina.out</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>tomcat7.sh</code>命令文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/lib/jvm/java-7-oracle/  </span><br><span class="line">export TOMCAT_HOME=/opt/tomcat7  </span><br><span class="line">  </span><br><span class="line">case $1 in  </span><br><span class="line">start)  </span><br><span class="line">  sh $TOMCAT_HOME/bin/startup.sh  </span><br><span class="line">;;  </span><br><span class="line">stop)  </span><br><span class="line">  sh $TOMCAT_HOME/bin/shutdown.sh  </span><br><span class="line">;;  </span><br><span class="line">restart)  </span><br><span class="line">  sh $TOMCAT_HOME/bin/shutdown.sh  </span><br><span class="line">  sh $TOMCAT_HOME/bin/startup.sh  </span><br><span class="line">;;  </span><br><span class="line">esac  </span><br><span class="line">exit 0</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="原则与建议"><a href="#原则与建议" class="headerlink" title="原则与建议"></a>原则与建议</h3><ul><li>  容器轻量化。从镜像中产生的容器应该尽量轻量化，能在足够短的时间内停止、销毁、重新生成并替换原来的容器。</li><li>  使用 <code>.gitignore</code>。在大部分情况下，Dockerfile 会和构建所需的文件放在同一个目录中，为了提高构建的性能，应该使用 <code>.gitignore</code> 来过滤掉不需要的文件和目录。</li><li>  为了减少镜像的大小，减少依赖，仅安装需要的软件包。</li><li>  一个容器只做一件事。解耦复杂的应用，分成多个容器，而不是所有东西都放在一个容器内运行。如一个 Python Web 应用，可能需要 Server、DB、Cache、MQ、Log 等几个容器。一个更加极端的说法：One process per container。</li><li>  减少镜像的图层。不要多个 Label、ENV 等标签。</li><li>  对续行的参数按照字母表排序，特别是使用<code>apt-get install -y</code>安装包的时候。</li><li>  使用构建缓存。如果不想使用缓存，可以在构建的时候使用参数<code>--no-cache=true</code>来强制重新生成中间镜像。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.docker.com/engine/reference/builder/#usage">Dockerfile reference</a><br><a href="https://www.jianshu.com/p/cbce69c7a52f">使用Dockerfile构建Docker镜像</a><br><a href="https://itbilu.com/linux/docker/VyhM5wPuz.html">Docker镜像构建文件Dockerfile及相关命令介绍</a><br><a href="https://github.com/qianlei90/Blog/issues/35">深入Dockerfile（一）: 语法指南</a><br><a href="https://yeasy.gitbooks.io/docker_practice/content/">Docker — 从入门到实践</a></p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;FROM-指定基础镜像&quot;&gt;&lt;a href=&quot;#FROM-指定基础镜像&quot; class=&quot;headerlink&quot; title=&quot;FROM 指定基础镜像&quot;&gt;&lt;/a&gt;FROM 指定基础镜像&lt;/h3&gt;&lt;p&gt;&lt;code&gt;FROM&lt;/code&gt; 指令用于指定其后构建新镜像所使用的基础镜像。&lt;code&gt;FROM &lt;/code&gt;指令必是 &lt;code&gt;Dockerfile&lt;/code&gt; 文件中的首条命令，启动构建流程后，&lt;code&gt;Docker&lt;/code&gt; 将会基于该镜像构建新镜像，&lt;code&gt;FROM&lt;/code&gt; 后的命令也会基于这个基础镜像。&lt;/p&gt;</summary>
    
    
    
    <category term="DOCKER" scheme="https://rma-shuyu.github.io/categories/DOCKER/"/>
    
    
    <category term="docker" scheme="https://rma-shuyu.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker龙蜥镜像制作</title>
    <link href="https://rma-shuyu.github.io/2024/04/24/docker%E9%BE%99%E8%9C%A5%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/"/>
    <id>https://rma-shuyu.github.io/2024/04/24/docker%E9%BE%99%E8%9C%A5%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/</id>
    <published>2024-04-24T03:33:42.000Z</published>
    <updated>2024-06-22T07:34:15.357Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Anolis-OS安装docker"><a href="#Anolis-OS安装docker" class="headerlink" title="Anolis OS安装docker"></a>Anolis OS安装docker</h3><p>系统版本：Anolis OS release 8.6 (Centos8)</p><h4 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove docker  docker-common docker-selinux docker-engine</span><br></pre></td></tr></table></figure><span id="more"></span><h4 id="设置安装环境"><a href="#设置安装环境" class="headerlink" title="设置安装环境"></a>设置安装环境</h4><p>安装依赖，并设置docker源(中央仓库或阿里源均可)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yum install -y yum-utils device-mapper-persistent-data lvm2</span><br><span class="line"></span><br><span class="line">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo </span><br><span class="line"></span><br><span class="line">#安装containerd的时候提示有冲突的软件包，根据提示，后面加上--allowerasing&#x27; 来替换冲突的软件包</span><br><span class="line">yum -y install containerd --allowerasing</span><br></pre></td></tr></table></figure><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>查看可用版本,并选择合适版本安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum list docker-ce --showduplicates | sort -r</span><br><span class="line">yum -y install docker-ce-24.0.1-1.el8</span><br></pre></td></tr></table></figure><h4 id="启动和添加自启动"><a href="#启动和添加自启动" class="headerlink" title="启动和添加自启动"></a>启动和添加自启动</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 查看版本</span><br><span class="line">docker version</span><br><span class="line"></span><br><span class="line"># 启动</span><br><span class="line">systemctl start docker</span><br><span class="line"># 设置开机自启动</span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><h3 id="版本镜像制作"><a href="#版本镜像制作" class="headerlink" title="版本镜像制作"></a>版本镜像制作</h3><h4 id="基础镜像拉取"><a href="#基础镜像拉取" class="headerlink" title="基础镜像拉取"></a>基础镜像拉取</h4><p>dockerhub生成Access Tokens</p><p><img src="2d578415edef21bbb04fafd686a06ee8d1230c8ad0c64f587c50549be05cc402.png" alt="picture 0">  </p><p>dockerd配置网络，docker login登录，拉取龙蜥官方镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull openanolis/anolisos:8.6-aarch64</span><br></pre></td></tr></table></figure><h4 id="Dockerfile制作版本镜像"><a href="#Dockerfile制作版本镜像" class="headerlink" title="Dockerfile制作版本镜像"></a>Dockerfile制作版本镜像</h4><p>拉取版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -u alps-ci:Jaguar@123 -O &quot;https://jfrog1.jaguarmicro.com/artifactory/corsica-sw-generic-local/snapshot/full-version/corsica_dpu_dev/anolis/202404212359/202404212359_jmnd.tar.gz&quot;</span><br></pre></td></tr></table></figure><p>基于openanolis/anolisos:8.6-aarch64编译版本镜像</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t anolisos-jmnd:0421 .</span><br></pre></td></tr></table></figure><p>参考Dockerfile如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FROM openanolis/anolisos:8.6-aarch64</span><br><span class="line"></span><br><span class="line">RUN https_proxy=xxxx http_proxy=xxxxx yum install -y python3 jansson jansson-devel libatomic libmlx5 librdmacm yajl-devel libaio-devel libiscsi-devel librados-devel librbd-devel &amp;&amp; \</span><br><span class="line">    yum clean all</span><br><span class="line"></span><br><span class="line">ADD 202404212359_jmnd.tar.gz /usr/share</span><br><span class="line">ADD libmhu.so /usr/lib</span><br><span class="line">ADD libmhu.so /usr/lib64</span><br><span class="line"></span><br><span class="line">WORKDIR /usr/share/jmnd</span><br></pre></td></tr></table></figure><h4 id="rpm包方式安装的镜像"><a href="#rpm包方式安装的镜像" class="headerlink" title="rpm包方式安装的镜像"></a>rpm包方式安装的镜像</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># cat Dockerfile</span><br><span class="line">FROM openanolis/anolisos:8.6-aarch64</span><br><span class="line"></span><br><span class="line">ADD libmhu.so /usr/lib</span><br><span class="line">ADD libmhu.so /usr/lib64</span><br><span class="line">ADD corsica-jmnd-202405082300-debug.aarch64.rpm /</span><br><span class="line">RUN sed -i &#x27;s/mirrors.openanolis.cn/mirrors.jaguarmicro.com/&#x27; /etc/yum.repos.d/AnolisOS-* &amp;&amp; \</span><br><span class="line">    yum update -y &amp;&amp; \</span><br><span class="line">    yum install -y python3 jansson jansson-devel libatomic libmlx5 librdmacm yajl-devel libaio-devel libiscsi-devel librados-devel librbd-devel pciutils openssh-clients &amp;&amp; \</span><br><span class="line">    yum clean all &amp;&amp; \</span><br><span class="line">    rpm -i corsica-jmnd-202405082300-debug.aarch64.rpm --nodeps --force &amp;&amp; rm -f corsica-jmnd-202405082300-debug.aarch64.rpm &amp;&amp; ln -sf /usr/share/jmnd/jm_launcher/jm-ctl /usr/bin/jm-ctl</span><br><span class="line">RUN ssh-keygen -t rsa -N &#x27;&#x27; -f /root/.ssh/id_rsa -q</span><br><span class="line">WORKDIR /usr/share/jmnd</span><br></pre></td></tr></table></figure><p>运行容器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --rm --privileged=true --net=host --ipc=shareable -v /data:/data --shm-size 4G anolisos-jmnd:0421 bash</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Anolis-OS安装docker&quot;&gt;&lt;a href=&quot;#Anolis-OS安装docker&quot; class=&quot;headerlink&quot; title=&quot;Anolis OS安装docker&quot;&gt;&lt;/a&gt;Anolis OS安装docker&lt;/h3&gt;&lt;p&gt;系统版本：Anolis OS release 8.6 (Centos8)&lt;/p&gt;
&lt;h4 id=&quot;卸载旧版本&quot;&gt;&lt;a href=&quot;#卸载旧版本&quot; class=&quot;headerlink&quot; title=&quot;卸载旧版本&quot;&gt;&lt;/a&gt;卸载旧版本&lt;/h4&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;yum remove docker  docker-common docker-selinux docker-engine&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="DOCKER" scheme="https://rma-shuyu.github.io/categories/DOCKER/"/>
    
    
    <category term="docker" scheme="https://rma-shuyu.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>性能测试Lmbench</title>
    <link href="https://rma-shuyu.github.io/2024/04/02/Lmbench-%E7%AE%80%E4%BB%8B/"/>
    <id>https://rma-shuyu.github.io/2024/04/02/Lmbench-%E7%AE%80%E4%BB%8B/</id>
    <published>2024-04-02T07:09:17.000Z</published>
    <updated>2024-06-22T07:34:15.326Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lmbench-简介"><a href="#Lmbench-简介" class="headerlink" title="Lmbench 简介"></a>Lmbench 简介</h2><p><code>Lmbench</code>是个用于评价系统综合性能的多平台开源benchmark，能够测试包括文档读写、内存操作、进程创建销毁开销、网络等性能。</p><span id="more"></span><h2 id="下载和安装"><a href="#下载和安装" class="headerlink" title="下载和安装"></a>下载和安装</h2><p>官网地址：<a href="http://www.bitmover.com/lmbench/">http://www.bitmover.com/lmbench/</a><br>下载连接：<a href="https://download.csdn.net/download/qq_36393978/86261418">lmbench-3.0</a></p><p>或者<br>链接：<a href="https://pan.baidu.com/s/1GJ7iOSTYQa4THAjjiD4TXQ">https://pan.baidu.com/s/1GJ7iOSTYQa4THAjjiD4TXQ</a><br>提取码：jayn</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imaginemiracle:Downloads$ unzip lmbench-3.0-a9.zip</span><br></pre></td></tr></table></figure><p>需要注意的是，目前解压出的 <code>lmbench</code> 中所有文件都不可被执行，当直接执行 <code>make</code> 编译后将会看到类似有 <code>Permission denied</code> 等一系列错误。</p><p>这里首先需要更改所有文件的权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">imaginemiracle:Downloads$ sudo chmod 777 -R lmbench-3.0-a9/</span><br></pre></td></tr></table></figure><p>进入 <code>lmbench</code> 目录，其目录结构如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">imaginemiracle:Downloads$ cd lmbench-3.0-a9/</span><br><span class="line">imaginemiracle:lmbench-3.0-a9$ ls</span><br><span class="line">ACKNOWLEDGEMENTS  CHANGES    COPYING    doc              Makefile  results  src</span><br><span class="line">bin               ChangeSet  COPYING-2  hbench-REBUTTAL  README    scripts</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="使用-Lmbench-测试"><a href="#使用-Lmbench-测试" class="headerlink" title="使用 Lmbench 测试"></a>使用 Lmbench 测试</h2><p>可能存在测试结果显示不全问题，需要修改getsummary 文件<br>vim scripts/getsummary</p><p>添加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (/^\[mount:/) &#123;</span><br><span class="line">        next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="e4284b7b8c1922f3d26f6eac03c5988bf4e91b65dabc8082f5730502e9bb6eee.png" alt="picture 0">  </p><p>cp config.guess lmbench-3.0-a9/scripts/gnu-os 修正gnu-os参数，解决arm系统适配问题<br>config.guess文件网盘下载自带有</p><p>执行 <code>make results</code>，执行后将会有以下选项提示需要设置：</p><ul><li>  <strong>MULTIPLE COPIES：</strong> 同时运行并行测试，对应生成结果中的 <code>scal load</code> 项；</li><li>  <strong>Job placement selection:</strong> 作业调度控制方法，默认选 <code>1</code>，表示允许作业调度；</li><li>  <strong>Options to control job placement:</strong> 默认选 <code>1</code>；</li><li>  <strong>Memory:</strong> 设置为大于 <code>4</code> 倍的 <code>cache size</code>，该值越大结果越精确，同时运行时间越长；</li><li>  <strong>SUBSET:</strong> 要运行的子集，包含 <code>ALL / HARWARE / OS / DEVELOPMENT</code>，默认选 <code>all</code>；</li><li>  <strong>FASTMEM、SLOWFS、DISKS、REMOTE…</strong> 等选项，均保持默认即可。</li><li>  <strong>Mail results:</strong> 选<code>no</code>。</li></ul><p>设置完成后测试程序开始运行，需要注意运行时间较久，需耐心等待，或先做其他事情至少 <code>10 min</code> 后再看。</p><h2 id="查看结果"><a href="#查看结果" class="headerlink" title="查看结果"></a>查看结果</h2><p>执行 <code>make see</code> 查看运行结果，若只出现两行命令，显示运行结果输出到了 <code>summary.out</code> 文件中，则直接查看该文件即可。<code>cat ./results/summary.out</code>。<br>将会看到如下输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line">make[1]: Entering directory &#x27;/home/tmp/lmbench-3.0-a9/results&#x27;</span><br><span class="line"></span><br><span class="line">                 L M B E N C H  3 . 0   S U M M A R Y</span><br><span class="line">                 ------------------------------------</span><br><span class="line">                 (Alpha software, do not distribute)</span><br><span class="line"></span><br><span class="line">Basic system parameters</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">Host                 OS Description              Mhz  tlb  cache  mem   scal</span><br><span class="line">                                                     pages line   par   load</span><br><span class="line">                                                           bytes  </span><br><span class="line">--------- ------------- ----------------------- ---- ----- ----- ------ ----</span><br><span class="line">k8s-69-22 Linux 5.4.0-1        x86_64-linux-gnu 1499                       1</span><br><span class="line">k8s-69-22 Linux 5.4.0-1        x86_64-linux-gnu 1499                       1</span><br><span class="line">k8s-69-22 Linux 5.4.0-1        x86_64-linux-gnu 2892                       1</span><br><span class="line"></span><br><span class="line">Processor, Processes - times in microseconds - smaller is better</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">Host                 OS  Mhz null null      open slct sig  sig  fork exec sh  </span><br><span class="line">                             call  I/O stat clos TCP  inst hndl proc proc proc</span><br><span class="line">--------- ------------- ---- ---- ---- ---- ---- ---- ---- ---- ---- ---- ----</span><br><span class="line">k8s-69-22 Linux 5.4.0-1 1499 0.08 0.16 0.52 1.13 2.71 0.16 1.09 369. 1016 3659</span><br><span class="line">k8s-69-22 Linux 5.4.0-1 1499 0.08 0.16 0.53 1.18 2.75 0.17 1.13 355. 992. 3567</span><br><span class="line">k8s-69-22 Linux 5.4.0-1 2892 0.08 0.16 0.53 1.14 2.67 0.18 1.09 134. 315. 1057</span><br><span class="line"></span><br><span class="line">Basic integer operations - times in nanoseconds - smaller is better</span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line">Host                 OS  intgr intgr  intgr  intgr  intgr  </span><br><span class="line">                          bit   add    mul    div    mod   </span><br><span class="line">--------- ------------- ------ ------ ------ ------ ------ </span><br><span class="line">k8s-69-22 Linux 5.4.0-1 0.2400 0.1700        9.4000 9.6100</span><br><span class="line">k8s-69-22 Linux 5.4.0-1 0.2400 0.1700        9.3600 9.5900</span><br><span class="line">k8s-69-22 Linux 5.4.0-1 0.2300 0.1700        9.3600 9.5300</span><br><span class="line"></span><br><span class="line">Basic uint64 operations - times in nanoseconds - smaller is better</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">Host                 OS int64  int64  int64  int64  int64  </span><br><span class="line">                         bit    add    mul    div    mod   </span><br><span class="line">--------- ------------- ------ ------ ------ ------ ------ </span><br><span class="line">k8s-69-22 Linux 5.4.0-1  0.240        0.0100   14.8   14.3</span><br><span class="line">k8s-69-22 Linux 5.4.0-1  0.230        0.0100   14.7   14.3</span><br><span class="line">k8s-69-22 Linux 5.4.0-1  0.230        0.0100   14.7   14.2</span><br><span class="line"></span><br><span class="line">Basic float operations - times in nanoseconds - smaller is better</span><br><span class="line">-----------------------------------------------------------------</span><br><span class="line">Host                 OS  float  float  float  float</span><br><span class="line">                         add    mul    div    bogo</span><br><span class="line">--------- ------------- ------ ------ ------ ------ </span><br><span class="line">k8s-69-22 Linux 5.4.0-1 1.3800 1.3900 4.9800 1.0400</span><br><span class="line">k8s-69-22 Linux 5.4.0-1 1.3900 1.3900 4.0300 1.0400</span><br><span class="line">k8s-69-22 Linux 5.4.0-1 1.3800 1.3800 4.0400 1.0700</span><br><span class="line"></span><br><span class="line">Basic double operations - times in nanoseconds - smaller is better</span><br><span class="line">------------------------------------------------------------------</span><br><span class="line">Host                 OS  double double double double</span><br><span class="line">                         add    mul    div    bogo</span><br><span class="line">--------- ------------- ------  ------ ------ ------ </span><br><span class="line">k8s-69-22 Linux 5.4.0-1 1.3900 1.3800 5.0300 1.3900</span><br><span class="line">k8s-69-22 Linux 5.4.0-1 1.3800 1.3900 5.1900 1.7400</span><br><span class="line">k8s-69-22 Linux 5.4.0-1 1.3800 1.4300 4.9700 1.3800</span><br><span class="line"></span><br><span class="line">Context switching - times in microseconds - smaller is better</span><br><span class="line">-------------------------------------------------------------------------</span><br><span class="line">Host                 OS  2p/0K 2p/16K 2p/64K 8p/16K 8p/64K 16p/16K 16p/64K</span><br><span class="line">                         ctxsw  ctxsw  ctxsw ctxsw  ctxsw   ctxsw   ctxsw</span><br><span class="line">--------- ------------- ------ ------ ------ ------ ------ ------- -------</span><br><span class="line">k8s-69-22 Linux 5.4.0-1 8.7700   10.3   15.2   14.7   18.5    15.1    20.4</span><br><span class="line">k8s-69-22 Linux 5.4.0-1 8.7400 9.0100   17.1   15.0   19.4    14.8    19.7</span><br><span class="line">k8s-69-22 Linux 5.4.0-1 3.7400 3.7600 3.8800 3.7800 3.7500 3.83000 3.85000</span><br><span class="line"></span><br><span class="line">*Local* Communication latencies in microseconds - smaller is better</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">Host                 OS 2p/0K  Pipe AF     UDP  RPC/   TCP  RPC/ TCP</span><br><span class="line">                        ctxsw       UNIX         UDP         TCP conn</span><br><span class="line">--------- ------------- ----- ----- ---- ----- ----- ----- ----- ----</span><br><span class="line">k8s-69-22 Linux 5.4.0-1 8.770 9.096 8.35  14.8  17.7 1.562  21.2  28.</span><br><span class="line">k8s-69-22 Linux 5.4.0-1 8.740 8.745 8.09  20.1  17.7 1.536  25.1  25.</span><br><span class="line">k8s-69-22 Linux 5.4.0-1 3.740 8.483 8.02  14.1  16.0 1.520  19.2  24.</span><br><span class="line"></span><br><span class="line">*Remote* Communication latencies in microseconds - smaller is better</span><br><span class="line">---------------------------------------------------------------------</span><br><span class="line">Host                 OS   UDP  RPC/  TCP   RPC/ TCP</span><br><span class="line">                               UDP         TCP  conn</span><br><span class="line">--------- ------------- ----- ----- ----- ----- ----</span><br><span class="line">k8s-69-22 Linux 5.4.0-1                             </span><br><span class="line">k8s-69-22 Linux 5.4.0-1                             </span><br><span class="line">k8s-69-22 Linux 5.4.0-1                             </span><br><span class="line"></span><br><span class="line">File &amp; VM system latencies in microseconds - smaller is better</span><br><span class="line">-------------------------------------------------------------------------------</span><br><span class="line">Host                 OS   0K File      10K File     Mmap    Prot   Page   100fd</span><br><span class="line">                        Create Delete Create Delete Latency Fault  Fault  selct</span><br><span class="line">--------- ------------- ------ ------ ------ ------ ------- ----- ------- -----</span><br><span class="line">k8s-69-22 Linux 5.4.0-1 7.1240 4.9842   13.4 7.2740  8008.0 0.555 0.30410 1.062</span><br><span class="line">k8s-69-22 Linux 5.4.0-1 6.8406 4.9554   14.0 7.5449  3876.0 0.506 0.22400 1.068</span><br><span class="line">k8s-69-22 Linux 5.4.0-1 6.4733 4.9461   13.8 7.4176  3863.0 0.566 0.26380 1.061</span><br><span class="line"></span><br><span class="line">*Local* Communication bandwidths in MB/s - bigger is better</span><br><span class="line">-----------------------------------------------------------------------------</span><br><span class="line">Host                OS  Pipe AF    TCP  File   Mmap  Bcopy  Bcopy  Mem   Mem</span><br><span class="line">                             UNIX      reread reread (libc) (hand) read write</span><br><span class="line">--------- ------------- ---- ---- ---- ------ ------ ------ ------ ---- -----</span><br><span class="line">k8s-69-22 Linux 5.4.0-1 2607 4094 5411 5060.1 8378.1 7506.2 4224.4 7763 6201.</span><br><span class="line">k8s-69-22 Linux 5.4.0-1 2775 4045 3911 4961.8 8167.1 7112.0 4479.9 8039 6618.</span><br><span class="line">k8s-69-22 Linux 5.4.0-1 2963 4073 3997 4178.8 7734.7 7262.5 4160.1 8644 7132.</span><br><span class="line"></span><br><span class="line">Memory latencies in nanoseconds - smaller is better</span><br><span class="line">    (WARNING - may not be correct, check graphs)</span><br><span class="line">------------------------------------------------------------------------------</span><br><span class="line">Host                 OS   Mhz   L1 $   L2 $    Main mem    Rand mem    Guesses</span><br><span class="line">--------- -------------   ---   ----   ----    --------    --------    -------</span><br><span class="line">k8s-69-22 Linux 5.4.0-1  1499 1.3840 4.8430        21.3       113.2</span><br><span class="line">k8s-69-22 Linux 5.4.0-1  1499 1.3840 4.8430        20.7       106.4</span><br><span class="line">k8s-69-22 Linux 5.4.0-1  2892 1.3840 4.8440        21.1       109.3</span><br><span class="line">make[1]: Leaving directory &#x27;/home/tmp/lmbench-3.0-a9/results&#x27;</span><br></pre></td></tr></table></figure><h3 id="系统基本信息"><a href="#系统基本信息" class="headerlink" title="系统基本信息"></a>系统基本信息</h3><p>输出结果中开始显示系统的基本参数信息。<br><img src="8550509a293cfd68b64a3475aaf98b166b9c3910ca4c1a425206a140f688b97d.png" alt="picture 2">  </p><p>其中：</p><ul><li>  <strong>tlb:</strong> 表示转换后备缓存的页面数；</li><li>  <strong>cache line bytes:</strong> 高速缓存行字节数</li><li>  <strong>mem par:</strong> 存储器分层并行化；</li><li>  <strong>scal load:</strong> 并行执行的 <code>Lmbench</code> 数目。</li></ul><h3 id="处理器-Processor-性能"><a href="#处理器-Processor-性能" class="headerlink" title="处理器 Processor 性能"></a>处理器 Processor 性能</h3><p>如下输出结果单位均为 <code>us</code>，数值越小表示性能越好。<br><img src="0cfa0da0ec8dd39b3f4437067ef41ba683974f33c31c7665d364cae30b963b6c.png" alt="picture 3">  </p><ul><li>  <strong>null call:</strong> 执行 <code>getppid</code> 需要的时间；</li><li>  <strong>null I/O:</strong> 从 <code>/dev/zero</code> 读取一个字节的时长 <code>t1</code>，写一个字节到 <code>/dev/null</code> 的时长 <code>t2</code>，<code>t1、t2</code> 取平均值即为该项结果；</li><li>  <strong>stat:</strong> <code>stat</code> 一个文件（即得到一个文件的信息）所需时长；</li><li>  <strong>open clos:</strong> <code>open</code> 一个文件接着再 <code>close</code> 掉该文件一共所用时间（不包含读目录和节点的时间）；</li><li>  <strong>slct TCP:</strong> 通过 <code>TCP</code> 网络连接选择 <code>100</code> 个文件描述符所消耗的时间；</li><li>  <strong>sig inst:</strong> <code>install signal</code> 所耗时长；</li><li>  <strong>sig hndl:</strong> <code>handler signal</code> 所耗时长；</li><li>  <strong>fork proc:</strong> <code>fork</code> 一个完全相同的 <code>process</code>，并把原来的 <code>process</code> 关掉一共所消耗的时间；</li><li>  <strong>exec proc:</strong> 模拟一个 <code>shell</code> 进程的工作过程：<code>fork</code> 一个新进程执行新命令消耗的时间。</li><li>  <strong>sh proc:</strong> <code>fork</code> 一个进程，同时询问系统 <code>shell</code> 来找到并运行一个新程序所用时间。</li></ul><h3 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h3><p>如下输出结果单位均为 <code>ns</code>，数值越小表示性能越好。</p><p><strong>(1) 整型计算</strong></p><p><img src="f9fe19b7de0a4c60dae1ff83d7c992d26e09a7a134e1317fe3a0d4ccdf618acc.png" alt="picture 4">  </p><p><strong>(2) 无符号整型计算</strong></p><p><img src="94a0e44074d17ece6a76729d47c8adb9c48909cb10f2d9e9336b93cf8eaa7075.png" alt="picture 5">  </p><p><strong>(3) 浮点型计算</strong></p><p><img src="fa112ccd3c58934e89f54504b1389aa06278dc1a34c54d5af92e97827f428cd0.png" alt="picture 6">  </p><p><strong>(4) 双精度浮点型计算</strong></p><p><img src="eb17eea21a2edede1a93f90d30fb294e9fbc09ccaa4732b879f5bbbf7134b2de.png" alt="picture 7">  </p><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><p>如下输出结果单位均为 <code>us</code>，数值越小表示性能越好。</p><p><img src="9f0e3d3cda656a90c65be7fda2f82d02113e6674ab74958d55e690df4890f39d.png" alt="picture 8">  </p><p>多个进程用 <code>unix pipe</code> 环连接起来，每个进程从自己的管道中读取 <code>token</code>，执行任务，然后将 <code>token</code> 写给下一个进程。</p><p><code>context swithing</code> 时间包括：切换进程的时间，加上恢复进程所有状态所用的时间（包含恢复 <code>cache</code> 状态）。</p><ul><li>  <strong>2p/0k:</strong> 每个进程的 <code>size</code> 为 <code>0</code>（不执行任何任务），进程数为 <code>2</code> 时上下文切换所消耗的时间；</li><li>  <strong>2p/16k:</strong> 每个进程 <code>size</code> 为 <code>16K</code>（执行任务），进程数为 <code>2</code> 时上下文切换所消耗的时间；</li></ul><p>之后的测试项以此类推。</p><h3 id="本地通讯时延"><a href="#本地通讯时延" class="headerlink" title="本地通讯时延"></a>本地通讯时延</h3><p>如下输出结果单位均为 <code>us</code>，数值越小表示性能越好。</p><p><img src="d1a4365d0719ce781e8c89d2440fb41c88f7ecabfb06b117f7e8773580e4efaf.png" alt="picture 9">  </p><ul><li>  <strong>2p/0k:</strong> 每个进程的 <code>size</code> 为 <code>0</code>（不执行任何任务），进程数为 <code>2</code> 时上下文切换所消耗的时间；</li><li>  <strong>Pipe:</strong> 即所谓的 <code>hot potato</code> 测试，两个没有具体任务的进程之间使用 <code>pipe</code> 通信，一个 <code>token</code> 在两个进程间来回传递，传递一个来回所消耗时长的平均值；</li><li>  <strong>AF UNIX:</strong> 同 <code>Pipe</code> 测试项，但进程间通信使用的是 <code>socket</code> 通信；</li><li>  <strong>UDP:</strong> 同 <code>Pipe</code> 测试项，但进程间通信使用的是 <code>UDP/IP</code> 通信；</li><li>  <strong>RPC/UDP:</strong> 同 <code>Pipe</code> 测试项，但进程间通信使用的是 <code>sun RPC</code> 通信，默认情况下，<code>RPC</code> 采用 <code>UDP</code> 协议传输；</li><li>  <strong>TCP:</strong> 同 <code>Pipe</code> 测试项，但进程间通信使用的是 <code>TCP/IP</code> 通信；</li><li>  <strong>RPC/TCP:</strong> 同 <code>Pipe</code> 测试项，但进程间通信使用的是 <code>sun RPC</code> 通信，指定 <code>RPC</code> 采用 <code>TCP</code> 协议传输；</li><li>  <strong>TCP conn:</strong> 创建 <code>socket</code> 描述符和建立连接所用时间。</li></ul><h3 id="文件、内存延时"><a href="#文件、内存延时" class="headerlink" title="文件、内存延时"></a>文件、内存延时</h3><p>如下输出结果单位均为 <code>us</code>，数值越小表示性能越好。</p><p><img src="6cbbd3bb69d25d38de85931ba1f11ec45855134bc883722d30234dd8d7679a7c.png" alt="picture 10">  </p><ul><li>  <strong>0K File Create:</strong> <code>0K</code> 文件创建所用时间；</li><li>  <strong>0K File Delete:</strong> <code>0K</code> 文件删除所用时间；</li><li>  <strong>10K File Create:</strong> <code>10K</code> 文件创建所用时间；</li><li>  <strong>10K File Delete:</strong> <code>10K</code> 文件删除所用时间；</li><li>  <strong>Mmap Latency:</strong> 将指定文件的开头 <code>n</code> 个字节 <code>mmap</code> 到内存，然后 <code>unmap</code>，并记录每次 <code>mmap</code> 和 <code>unmap</code> 共消耗的时间，去每次消耗时间的最大值；</li><li>  <strong>Port Fault:</strong> 保护页延时时间；</li><li>  <strong>Page Faule:</strong> 缺页延时时间；</li><li>  <strong>100fd selct:</strong> 对 <code>100</code> 个文件描述符配置 <code>select</code> 的时间。</li></ul><h3 id="本地通信带宽"><a href="#本地通信带宽" class="headerlink" title="本地通信带宽"></a>本地通信带宽</h3><p>如下输出结果单位均为 <code>MB/s</code>，数值越大表示性能越好。</p><p><img src="b80e04ed533208d79e6c7fb78d5799ab29173ad6f5189172840c4bb8d6b904bc.png" alt="picture 11">  </p><ul><li>  <strong>Pipe:</strong> 在两个进程建立 <code>pipe</code>，<code>pipe</code> 的每个 <code>chunk</code> 为 <code>64K</code>，通过该管道移动 <code>50MB</code> 数据所消耗的时间；</li><li>  <strong>AF UNIX:</strong> 两个进程之间建立 <code>unix stream socket</code> 连接，每个 <code>chunk</code> 为 <code>64K</code>，通过该 <code>socket</code> 传输 <code>10MB</code> 数据所用的时间；</li><li>  <strong>TCP:</strong> 同 <code>Pipe</code> 测试项，但进程间使用 <code>TCP/IP socket</code> 通信，传输数据量为 <code>3MB</code>；</li><li>  <strong>File reread:</strong> 读文件并将其汇总一起所用的时间；</li><li>  <strong>Mmap reread:</strong> 将文件 <code>mmap</code> 到内存中，从内存中读文件并将其汇总一起所用时间；</li><li>  <strong>Bcopy(libc):</strong> <code>do bw_mem $i bcopy</code>，从指定内存区域拷贝指定数量的字节内容到另一个指定内存区域的速度；</li><li>  <strong>Bcopy(hand):</strong> <code>do bw_mem %i fcp</code>，把数据从磁盘的一个位置拷贝到另一个位置所用的时间；</li><li>  <strong>Mem read:</strong> <code>bw_mem $i frd</code>，累加数组中的整数值，测试把数据读入 <code>processor</code> 的带宽；</li><li>  <strong>Mem write:</strong> <code>do bw_mem $i fwr</code>，把整数数组的每个成员设置为 <code>1</code>，测试写数据到内存的带宽。</li></ul><h3 id="内存操作延时"><a href="#内存操作延时" class="headerlink" title="内存操作延时"></a>内存操作延时</h3><p>如下输出结果单位均为 <code>ns</code>，数值越小表示性能越好。</p><p><img src="519df4da78a1a5fe20be94155a3bef88f10881afc24cb64b5a182c72247e3dbb.png" alt="picture 12">  </p><p>本地测试执行 <code>lat_mem_rd</code>，将整数数组中每第 <code>4</code> 个元素的值累加起来；测试的是读数据到 <code>processor</code> 的带宽。</p><ul><li>  <strong>L1：</strong> 缓存1</li><li>  <strong>L2：</strong> 缓存2</li><li>  <strong>Main Mem：</strong> 连续内存</li><li>  <strong>Rand Mem：</strong> 内存随机访问延时</li><li><strong>Guesses:</strong><br>  假如 <code>L1</code> 和 <code>L2</code> 近似，会显示 <code>“No L1 cache?”</code><br>  假如 <code>L2</code> 和 <code>Main Mem</code> 近似，会显示 <code>“No L2 cache?”</code></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Lmbench-简介&quot;&gt;&lt;a href=&quot;#Lmbench-简介&quot; class=&quot;headerlink&quot; title=&quot;Lmbench 简介&quot;&gt;&lt;/a&gt;Lmbench 简介&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Lmbench&lt;/code&gt;是个用于评价系统综合性能的多平台开源benchmark，能够测试包括文档读写、内存操作、进程创建销毁开销、网络等性能。&lt;/p&gt;</summary>
    
    
    
    <category term="LINUX" scheme="https://rma-shuyu.github.io/categories/LINUX/"/>
    
    
    <category term="LINUX" scheme="https://rma-shuyu.github.io/tags/LINUX/"/>
    
  </entry>
  
  <entry>
    <title>setcap提权</title>
    <link href="https://rma-shuyu.github.io/2024/02/27/setcap%E6%8F%90%E6%9D%83/"/>
    <id>https://rma-shuyu.github.io/2024/02/27/setcap%E6%8F%90%E6%9D%83/</id>
    <published>2024-02-27T07:15:21.000Z</published>
    <updated>2024-06-22T07:34:15.404Z</updated>
    
    <content type="html"><![CDATA[<h3 id="setcap-命令"><a href="#setcap-命令" class="headerlink" title="setcap 命令"></a>setcap 命令</h3><p><strong>setcap</strong>（英文全拼：set capabilities）是在 Linux 系统中用于设置特殊权限的命令工具。它允许普通用户在执行特定程序时获得一些超过其正常权限的能力。具体来说，<code>setcap</code> 命令允许用户向可执行文件或动态链接库（共享对象）设置特殊的能力。这些能力使得程序能够执行某些通常需要超级用户权限才能完成的操作，例如绑定低于 1024 端口、访问摄像头、修改网络设置等。</p><span id="more"></span><p>通过使用 <code>setcap</code> 命令，用户不需要将整个程序以 root 身份运行，而只需为其设置所需的能力即可。这提供了更加灵活和安全的权限控制方式，同时避免了用户以超级用户身份运行程序带来的潜在风险。需要注意的是，<code>setcap</code> 命令需要以超级用户（root）身份执行，因为设置特殊能力是一个需要特权的操作。使用时应当慎重，确保仅将特定的能力赋予可信任的程序。</p><p><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setcap [-q] [-v] [-n &lt;rootid&gt;] (-r|-|&lt;caps&gt;) &lt;filename&gt;  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>选项</strong>：</p><ul><li>  <code>-q</code>：以简洁方式输出。</li><li>  <code>-v</code>：用于验证指定的功能当前是否与该文件关联（v 是 verify 的意思）。如果提供了 <code>-v</code> 和 <code>-n</code>，则还会验证 <code>-n &lt;rootid&gt;</code> 参数。</li><li>  <code>-n &lt;rootid&gt;</code>：设置仅在具有此 rootid 所有者的命名空间中使用的文件功能。</li><li>  <code>-r</code>：从文件中删除功能集。请注意，设置空功能集与删除它不同，空集可用于保证文件不会以特权执行。</li><li>  <code>-</code>：从标准输入读取功能。在这种情况下，功能集以空行终止。</li></ul><p><strong>参数</strong>：</p><ul><li>  <code>caps</code>：功能集。详细参考下面说明。</li><li>  <code>filename</code>：文件名称。</li></ul><h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><p>Linux 内核从 2.2 版本开始，就增加了 Capabilities 的概念与机制，并随着版本升高逐步得到改进。在 Linux 中，root 权限被分割为以下 29 种能力：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">CAP_CHOWN            # 修改文件属主的权限  </span><br><span class="line">CAP_DAC_OVERRIDE     # 忽略文件的 DAC 访问限制  </span><br><span class="line">CAP_DAC_READ_SEARCH  # 忽略文件读及目录搜索的 DAC 访问限制  </span><br><span class="line">CAP_FOWNER           # 忽略文件属主 ID 必须和进程用户 ID 相匹配的限制  </span><br><span class="line">CAP_FSETID           # 允许设置文件的 setuid 位  </span><br><span class="line">CAP_KILL             # 允许对不属于自己的进程发送信号  </span><br><span class="line">CAP_SETGID           # 允许改变进程的组 ID  </span><br><span class="line">CAP_SETUID           # 允许改变进程的用户 ID  </span><br><span class="line">CAP_SETPCAP          # 允许向其他进程转移能力以及删除其他进程的能力  </span><br><span class="line">CAP_LINUX_IMMUTABLE  # 允许修改文件的 IMMUTABLE 和 APPEND 属性标志  </span><br><span class="line">CAP_NET_BIND_SERVICE # 允许绑定到小于 1024 的端口  </span><br><span class="line">CAP_NET_BROADCAST    # 允许网络广播和多播访问  </span><br><span class="line">CAP_NET_ADMIN        # 允许执行网络管理任务  </span><br><span class="line">CAP_NET_RAW          # 允许使用原始套接字  </span><br><span class="line">CAP_IPC_LOCK         # 允许锁定共享内存片段  </span><br><span class="line">CAP_IPC_OWNER        # 忽略 IPC 所有权检查  </span><br><span class="line">CAP_SYS_MODULE       # 允许插入和删除内核模块  </span><br><span class="line">CAP_SYS_RAWIO        # 允许直接访问 /devport,/dev/mem,/dev/kmem 及原始块设备  </span><br><span class="line">CAP_SYS_CHROOT       # 允许使用 chroot() 系统调用  </span><br><span class="line">CAP_SYS_PTRACE       # 允许跟踪任何进程  </span><br><span class="line">CAP_SYS_PACCT        # 允许执行进程的 BSD 式审计  </span><br><span class="line">CAP_SYS_ADMIN        # 允许执行系统管理任务，如加载或卸载文件系统、设置磁盘配额等  </span><br><span class="line">CAP_SYS_BOOT         # 允许重新启动系统  </span><br><span class="line">CAP_SYS_NICE         # 允许提升优先级及设置其他进程的优先级  </span><br><span class="line">CAP_SYS_RESOURCE     # 忽略资源限制  </span><br><span class="line">CAP_SYS_TIME         # 允许改变系统时钟  </span><br><span class="line">CAP_SYS_TTY_CONFIG   # 允许配置 TTY 设备  </span><br><span class="line">CAP_MKNOD            # 允许使用 mknod() 系统调用  </span><br><span class="line">CAP_LEASE            # 允许修改文件锁的 FL_LEASE 标志  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用 <code>setcap</code> 命令可以分割 root 用户的特权，即将 root 的特权分割成不同的能力，每种能力代表一定的特权操作。例如，能力 <code>CAP_SYS_MODULE</code> 表示用户能够加载（或卸载）内核模块的特权操作，而 <code>CAP_SETUID</code> 表示用户能够修改进程用户身份的特权操作。在 Capbilities 中系统将根据进程拥有的能力来进行特权操作的访问控制。</p><p>在 Capilities 中，只有进程和可执行文件才具有能力，每个进程拥有三组能力集，分别称为 cap_effective、cap_inheritable、cap_permitted（分别简记为：<code>pE</code>、<code>pI</code>、<code>pP</code>），其中：</p><ul><li>  cap_permitted 表示进程所拥有的最大能力集；</li><li>  cap_effective 表示进程当前可用的能力集，可以看做是 cap_permitted 的一个子集；</li><li>  cap_inheitable 则表示进程可以传递给其子进程的能力集。</li></ul><p>系统根据进程的 cap_effective 能力集进行访问控制，cap_effective 为 cap_permitted 的子集，进程可以通过取消 cap_effective 中的某些能力来放弃进程的一些特权。</p><p>可执行文件也拥有三组能力集，对应于进程的三组能力集，分别称为 cap_effective、cap_allowed 和 cap_forced（分别简记为 <code>fE</code>、<code>fI</code>、<code>fP</code>），其中：</p><ul><li>  cap_allowed 表示程序运行时可从原进程的 cap_inheritable 中集成的能力集；</li><li>  cap_forced 表示运行文件时必须拥有才能完成其服务的能力集；</li><li>  cap_effective 则表示文件开始运行时可以使用的能力。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>安装 Wireshark 的时候，有一步是给 dumpcap 读网卡的权限，使得普通用户也可以使用 Wireshark 进行抓包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo setcap &#x27;CAP_NET_RAW+eip CAP_NET_ADMIN+eip&#x27; /usr/sbin/dumpcap  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>给可执行文件 /bin/ping 加上 “cap_net_admin,cap_net_raw+ep” 权限，普通用户即可使用 ping：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo setcap &#x27;cap_net_admin,cap_net_raw+ep&#x27; /bin/ping  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>给 nginx 加上使用 1024 以内端口的权限（无需 root 权限）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo setcap &#x27;cap_net_bind_service=+eip&#x27; /usr/sbin/nginx  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>清除 nginx 可执行文件附加的权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo setcap -r nginx  </span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;setcap-命令&quot;&gt;&lt;a href=&quot;#setcap-命令&quot; class=&quot;headerlink&quot; title=&quot;setcap 命令&quot;&gt;&lt;/a&gt;setcap 命令&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;setcap&lt;/strong&gt;（英文全拼：set capabilities）是在 Linux 系统中用于设置特殊权限的命令工具。它允许普通用户在执行特定程序时获得一些超过其正常权限的能力。具体来说，&lt;code&gt;setcap&lt;/code&gt; 命令允许用户向可执行文件或动态链接库（共享对象）设置特殊的能力。这些能力使得程序能够执行某些通常需要超级用户权限才能完成的操作，例如绑定低于 1024 端口、访问摄像头、修改网络设置等。&lt;/p&gt;</summary>
    
    
    
    <category term="LINUX" scheme="https://rma-shuyu.github.io/categories/LINUX/"/>
    
    
    <category term="setcap" scheme="https://rma-shuyu.github.io/tags/setcap/"/>
    
  </entry>
  
  <entry>
    <title>nvme pf直通vm</title>
    <link href="https://rma-shuyu.github.io/2024/02/04/nvme-pf%E7%9B%B4%E9%80%9Avm/"/>
    <id>https://rma-shuyu.github.io/2024/02/04/nvme-pf%E7%9B%B4%E9%80%9Avm/</id>
    <published>2024-02-04T02:47:37.000Z</published>
    <updated>2024-06-22T07:34:15.388Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>查看设备的是否是pf，当前驱动</p></blockquote><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@jaguar-2288H-V7:/data# lspci -s 41:00.0 -v</span><br><span class="line">41:00.0 Non-Volatile memory controller: Device 1f53:1a00 (prog-if 02 [NVM Express])</span><br><span class="line">        Subsystem: Device 1f53:1a00</span><br><span class="line">        Physical Slot: 3-1</span><br><span class="line">        Flags: bus master, fast devsel, latency 0, NUMA node 0</span><br><span class="line">        Memory at d3fffc00000 (64-bit, prefetchable) [size=8K]</span><br><span class="line">        Memory at d3fffc02000 (64-bit, prefetchable) [size=4K]</span><br><span class="line">        Capabilities: [88] Power Management version 3</span><br><span class="line">        Capabilities: [4c] Express Endpoint, MSI 00</span><br><span class="line">        Capabilities: [40] MSI-X: Enable+ Count=3 Masked-</span><br><span class="line">        Kernel driver in use: nvme</span><br><span class="line">        Kernel modules: nvme</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">root@jaguar-2288H-V7:/data# lspci -s 41:00.0 -vv</span><br><span class="line">41:00.0 Non-Volatile memory controller: Device 1f53:1a00 (prog-if 02 [NVM Express])</span><br><span class="line">        Subsystem: Device 1f53:1a00</span><br><span class="line">        Physical Slot: 3-1</span><br><span class="line">        Control: I/O+ Mem+ BusMaster+ SpecCycle- MemWINV- VGASnoop- ParErr- Stepping- SERR- FastB2B- DisINTx+</span><br><span class="line">        Status: Cap+ 66MHz- UDF- FastB2B- ParErr- DEVSEL=fast &gt;TAbort- &lt;TAbort- &lt;MAbort- &gt;SERR- &lt;PERR- INTx-</span><br><span class="line">        Latency: 0, Cache Line Size: 32 bytes</span><br><span class="line">        NUMA node: 0</span><br><span class="line">        Region 0: Memory at d3fffc00000 (64-bit, prefetchable) [size=8K]</span><br><span class="line">        Region 2: Memory at d3fffc02000 (64-bit, prefetchable) [size=4K]</span><br><span class="line">        Capabilities: [88] Power Management version 3</span><br><span class="line">                Flags: PMEClk- DSI- D1- D2- AuxCurrent=0mA PME(D0-,D1-,D2-,D3hot-,D3cold-)</span><br><span class="line">                Status: D0 NoSoftRst+ PME-Enable- DSel=0 DScale=0 PME-</span><br><span class="line">        Capabilities: [4c] Express (v2) Endpoint, MSI 00</span><br><span class="line">                DevCap: MaxPayload 512 bytes, PhantFunc 0, Latency L0s &lt;64ns, L1 &lt;1us</span><br><span class="line">                        ExtTag+ AttnBtn- AttnInd- PwrInd- RBE+ FLReset+ SlotPowerLimit 0.000W</span><br><span class="line">                DevCtl: CorrErr- NonFatalErr- FatalErr- UnsupReq-</span><br><span class="line">                        RlxdOrd+ ExtTag+ PhantFunc- AuxPwr- NoSnoop- FLReset-</span><br><span class="line">                        MaxPayload 256 bytes, MaxReadReq 4096 bytes</span><br><span class="line">                DevSta: CorrErr- NonFatalErr- FatalErr- UnsupReq- AuxPwr- TransPend-</span><br><span class="line">                LnkCap: Port #0, Speed 32GT/s, Width x16, ASPM L0s, Exit Latency L0s &lt;64ns</span><br><span class="line">                        ClockPM- Surprise- LLActRep+ BwNot+ ASPMOptComp-</span><br><span class="line">                LnkCtl: ASPM Disabled; RCB 64 bytes Disabled- CommClk-</span><br><span class="line">                        ExtSynch- ClockPM- AutWidDis- BWInt- AutBWInt-</span><br><span class="line">                LnkSta: Speed 32GT/s (ok), Width x16 (ok)</span><br><span class="line">                        TrErr- Train- SlotClk- DLActive- BWMgmt- ABWMgmt-</span><br><span class="line">                DevCap2: Completion Timeout: Range ABCD, TimeoutDis+, NROPrPrP-, LTR-</span><br><span class="line">                         10BitTagComp+, 10BitTagReq+, OBFF Not Supported, ExtFmt-, EETLPPrefix-</span><br><span class="line">                         EmergencyPowerReduction Not Supported, EmergencyPowerReductionInit-</span><br><span class="line">                         FRS-, TPHComp-, ExtTPHComp-</span><br><span class="line">                         AtomicOpsCap: 32bit- 64bit- 128bitCAS-</span><br><span class="line">                DevCtl2: Completion Timeout: 50us to 50ms, TimeoutDis-, LTR-, OBFF Disabled</span><br><span class="line">                         AtomicOpsCtl: ReqEn-</span><br><span class="line">                LnkCtl2: Target Link Speed: 32GT/s, EnterCompliance- SpeedDis-</span><br><span class="line">                         Transmit Margin: Normal Operating Range, EnterModifiedCompliance- ComplianceSOS-</span><br><span class="line">                         Compliance De-emphasis: -6dB</span><br><span class="line">                LnkSta2: Current De-emphasis Level: -6dB, EqualizationComplete+, EqualizationPhase1+</span><br><span class="line">                         EqualizationPhase2+, EqualizationPhase3+, LinkEqualizationRequest-</span><br><span class="line">        Capabilities: [40] MSI-X: Enable+ Count=3 Masked-</span><br><span class="line">                Vector table: BAR=2 offset=00000000</span><br><span class="line">                PBA: BAR=2 offset=00000c00</span><br><span class="line">        Kernel driver in use: nvme</span><br><span class="line">        Kernel modules: nvme</span><br></pre></td></tr></table></figure><p>libvirt xml</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">#cat nvme.xml </span><br><span class="line">&lt;domain type=&#x27;kvm&#x27; id=&#x27;1&#x27; xmlns:qemu=&#x27;http://libvirt.org/schemas/domain/qemu/1.0&#x27;&gt;</span><br><span class="line">        &lt;name&gt;vm_nvme&lt;/name&gt;</span><br><span class="line">        &lt;uuid&gt;0ba4f4d0-9a80-447e-a64c-e9c0d6c39ed8&lt;/uuid&gt;</span><br><span class="line">        &lt;memory unit=&#x27;KiB&#x27;&gt;4194304&lt;/memory&gt;</span><br><span class="line">        &lt;currentMemory unit=&#x27;KiB&#x27;&gt;4194304&lt;/currentMemory&gt;</span><br><span class="line">        &lt;vcpu placement=&#x27;static&#x27;&gt;10&lt;/vcpu&gt;</span><br><span class="line">        &lt;resource&gt;</span><br><span class="line">                &lt;partition&gt;/machine&lt;/partition&gt;</span><br><span class="line">        &lt;/resource&gt;</span><br><span class="line">        &lt;os&gt;</span><br><span class="line">                &lt;type arch=&#x27;x86_64&#x27; machine=&#x27;pc-i440fx-2.1&#x27;&gt;hvm&lt;/type&gt;</span><br><span class="line">                &lt;boot dev=&#x27;hd&#x27;/&gt;</span><br><span class="line">        &lt;/os&gt;</span><br><span class="line">        &lt;features&gt;</span><br><span class="line">                &lt;acpi/&gt;</span><br><span class="line">        &lt;/features&gt;</span><br><span class="line">        &lt;cpu mode=&#x27;custom&#x27; match=&#x27;exact&#x27; check=&#x27;full&#x27;&gt;</span><br><span class="line">                &lt;model fallback=&#x27;forbid&#x27;&gt;kvm64&lt;/model&gt;</span><br><span class="line">                &lt;feature policy=&#x27;require&#x27; name=&#x27;x2apic&#x27;/&gt;</span><br><span class="line">                &lt;feature policy=&#x27;require&#x27; name=&#x27;hypervisor&#x27;/&gt;</span><br><span class="line">        &lt;/cpu&gt;</span><br><span class="line">        &lt;clock offset=&#x27;utc&#x27;/&gt;</span><br><span class="line">        &lt;on_poweroff&gt;destroy&lt;/on_poweroff&gt;</span><br><span class="line">        &lt;on_reboot&gt;restart&lt;/on_reboot&gt;</span><br><span class="line">        &lt;on_crash&gt;destroy&lt;/on_crash&gt;</span><br><span class="line">        &lt;devices&gt;</span><br><span class="line">                &lt;emulator&gt;/root/pc-bios/qemu-system-x86_64&lt;/emulator&gt;</span><br><span class="line">                &lt;disk type=&#x27;file&#x27; device=&#x27;disk&#x27;&gt;</span><br><span class="line">                        &lt;driver name=&#x27;qemu&#x27; type=&#x27;raw&#x27;/&gt;</span><br><span class="line">                        &lt;source file=&#x27;/data/centos8.3-8g-ext4-host_vm2.img&#x27; index=&#x27;1&#x27;/&gt;</span><br><span class="line">                        &lt;backingStore/&gt;</span><br><span class="line">                        &lt;target dev=&#x27;hda&#x27; bus=&#x27;ide&#x27;/&gt;</span><br><span class="line">                        &lt;alias name=&#x27;ide0-0-0&#x27;/&gt;</span><br><span class="line">                        &lt;address type=&#x27;drive&#x27; controller=&#x27;0&#x27; bus=&#x27;0&#x27; target=&#x27;0&#x27; unit=&#x27;0&#x27;/&gt;</span><br><span class="line">                &lt;/disk&gt;</span><br><span class="line">                &lt;controller type=&#x27;pci&#x27; index=&#x27;0&#x27; model=&#x27;pci-root&#x27;&gt;</span><br><span class="line">                        &lt;alias name=&#x27;pci.0&#x27;/&gt;</span><br><span class="line">                &lt;/controller&gt;</span><br><span class="line">                &lt;controller type=&#x27;usb&#x27; index=&#x27;0&#x27; model=&#x27;piix3-uhci&#x27;&gt;</span><br><span class="line">                        &lt;alias name=&#x27;usb&#x27;/&gt;</span><br><span class="line">                        &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x01&#x27; function=&#x27;0x2&#x27;/&gt;</span><br><span class="line">                &lt;/controller&gt;</span><br><span class="line">                &lt;controller type=&#x27;ide&#x27; index=&#x27;0&#x27;&gt;</span><br><span class="line">                        &lt;alias name=&#x27;ide&#x27;/&gt;</span><br><span class="line">                        &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x01&#x27; function=&#x27;0x1&#x27;/&gt;</span><br><span class="line">                &lt;/controller&gt;</span><br><span class="line">                &lt;input type=&#x27;mouse&#x27; bus=&#x27;ps2&#x27;&gt;</span><br><span class="line">                        &lt;alias name=&#x27;input0&#x27;/&gt;</span><br><span class="line">                &lt;/input&gt;</span><br><span class="line">                &lt;input type=&#x27;keyboard&#x27; bus=&#x27;ps2&#x27;&gt;</span><br><span class="line">                        &lt;alias name=&#x27;input1&#x27;/&gt;</span><br><span class="line">                &lt;/input&gt;</span><br><span class="line">                &lt;graphics type=&#x27;vnc&#x27; port=&#x27;5900&#x27; autoport=&#x27;yes&#x27; listen=&#x27;0.0.0.0&#x27;&gt;</span><br><span class="line">                        &lt;listen type=&#x27;address&#x27; address=&#x27;0.0.0.0&#x27;/&gt;</span><br><span class="line">                &lt;/graphics&gt;</span><br><span class="line">                &lt;video&gt;</span><br><span class="line">                        &lt;model type=&#x27;cirrus&#x27; vram=&#x27;16384&#x27; heads=&#x27;1&#x27; primary=&#x27;yes&#x27;/&gt;</span><br><span class="line">                        &lt;alias name=&#x27;video0&#x27;/&gt;</span><br><span class="line">                        &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x02&#x27; function=&#x27;0x0&#x27;/&gt;</span><br><span class="line">                &lt;/video&gt;</span><br><span class="line">                &lt;hostdev mode=&#x27;subsystem&#x27; type=&#x27;pci&#x27; managed=&#x27;yes&#x27;&gt;</span><br><span class="line">                        &lt;driver name=&#x27;vfio&#x27;/&gt;</span><br><span class="line">                        &lt;source&gt;</span><br><span class="line">                                &lt;address domain=&#x27;0x0000&#x27; bus=&#x27;0x41&#x27; slot=&#x27;0x00&#x27; function=&#x27;0x0&#x27;/&gt;</span><br><span class="line">                        &lt;/source&gt;</span><br><span class="line">                        &lt;alias name=&#x27;hostdev0&#x27;/&gt;</span><br><span class="line">                        &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x0a&#x27; function=&#x27;0x0&#x27;/&gt;</span><br><span class="line">                &lt;/hostdev&gt;</span><br><span class="line">                &lt;memballoon model=&#x27;virtio&#x27;&gt;</span><br><span class="line">                        &lt;alias name=&#x27;balloon0&#x27;/&gt;</span><br><span class="line">                        &lt;address type=&#x27;pci&#x27; domain=&#x27;0x0000&#x27; bus=&#x27;0x00&#x27; slot=&#x27;0x03&#x27; function=&#x27;0x0&#x27;/&gt;</span><br><span class="line">                &lt;/memballoon&gt;</span><br><span class="line">        &lt;/devices&gt;</span><br><span class="line">        &lt;seclabel type=&#x27;dynamic&#x27; model=&#x27;dac&#x27; relabel=&#x27;yes&#x27;&gt;</span><br><span class="line">                &lt;label&gt;+0:+0&lt;/label&gt;</span><br><span class="line">                &lt;imagelabel&gt;+0:+0&lt;/imagelabel&gt;</span><br><span class="line">        &lt;/seclabel&gt;</span><br><span class="line">        &lt;qemu:commandline&gt;</span><br><span class="line">                &lt;qemu:arg value=&#x27;-L&#x27;/&gt;</span><br><span class="line">                &lt;qemu:arg value=&#x27;/root/pc-bios&#x27;/&gt;</span><br><span class="line">        &lt;/qemu:commandline&gt;</span><br><span class="line">&lt;/domain&gt;</span><br></pre></td></tr></table></figure><p>这里<hostdev>设置managed=’yes’会将该设备从nvme驱动卸载绑定到指定驱动vfio</hostdev></p><p>执行<br>virsh create /data/nvme.xml<br>Domain ‘vm_nvme’ created from /data/nvme.xml</p><p>root@jaguar-2288H-V7:/data# virsh list<br> Id   Name      State</p><hr><p> 1    vm_nvme   running</p><p>root@jaguar-2288H-V7:/data# ps -ef | grep qemu<br>root        4654       1 99 22:03 ?        00:00:22 /root/pc-bios/qemu-system-x86_64 -name guest=vm_nvme,debug-threads=on -S -object {“qom-type”:”secret”,”id”:”masterKey0”,”format”:”raw”,”file”:”/var/local/lib/libvirt/qemu/domain-1-vm_nvme/master-key.aes”} -machine pc-i440fx-2.1,usb=off,dump-guest-core=off,memory-backend=pc.ram -accel kvm -cpu kvm64,x2apic=on,hypervisor=on -m 4096 -object {“qom-type”:”memory-backend-ram”,”id”:”pc.ram”,”size”:4294967296} -overcommit mem-lock=off -smp 10,sockets=10,cores=1,threads=1 -uuid 0ba4f4d0-9a80-447e-a64c-e9c0d6c39ed8 -no-user-config -nodefaults -chardev socket,id=charmonitor,fd=24,server=on,wait=off -mon chardev=charmonitor,id=monitor,mode=control -rtc base=utc -no-shutdown -boot strict=on -device {“driver”:”piix3-usb-uhci”,”id”:”usb”,”bus”:”pci.0”,”addr”:”0x1.0x2”} -blockdev {“driver”:”file”,”filename”:”/data/centos8.3-8g-ext4-host_vm2.img”,”node-name”:”libvirt-1-storage”,”auto-read-only”:true,”discard”:”unmap”} -blockdev {“node-name”:”libvirt-1-format”,”read-only”:false,”driver”:”raw”,”file”:”libvirt-1-storage”} -device {“driver”:”ide-hd”,”bus”:”ide.0”,”unit”:0,”drive”:”libvirt-1-format”,”id”:”ide0-0-0”,”bootindex”:1} -audiodev {“id”:”audio1”,”driver”:”none”} -vnc 0.0.0.0:0,audiodev=audio1 -device {“driver”:”cirrus-vga”,”id”:”video0”,”bus”:”pci.0”,”addr”:”0x2”} -device {“driver”:”vfio-pci”,”host”:”0000:41:00.0”,”id”:”hostdev0”,”bus”:”pci.0”,”addr”:”0xa”} -device {“driver”:”virtio-balloon-pci”,”id”:”balloon0”,”bus”:”pci.0”,”addr”:”0x3”} -L /root/pc-bios -msg timestamp=on<br>root        4685    3954  0 22:03 pts/0    00:00:00 grep –color=auto qemu<br>root@jaguar-2288H-V7:/data# </p><p>打开vnc，查看前端驱动类型</p><p><img src="../../images/e5a8ffb582c5b2516c61b44f27271b401e93ee600a583472f4cc703f20f001f1.png" alt="picture 0">  </p><p>查看nvme的fio配置<br><img src="../../images/42fbb6a61912b1489b5c1b8eb6a2e486c5e412c27698443e1e2e940c70c4a81c.png" alt="picture 1">  </p><p><strong>x86_64</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/root/qemu-system-x86_64 -name guest=vm,debug-threads=on \</span><br><span class="line">-drive if=virtio,file=/data/centos8.3-8g-ext4-host_vm2.img -daemonize \</span><br><span class="line">-machine pc-i440fx-2.1,usb=off,dump-guest-core=off -accel kvm -cpu kvm64 -m 2048 \</span><br><span class="line">-overcommit mem-lock=off -smp 2,sockets=2,cores=1,threads=1 \</span><br><span class="line">-uuid 8c6ebff0-eb21-11eb-a2af-0c48c6c88118 -no-user-config -nodefaults \</span><br><span class="line">-rtc base=utc -no-shutdown -boot strict=on \</span><br><span class="line">-device piix3-usb-uhci,id=usb,bus=pci.0,addr=0x1.0x2 \</span><br><span class="line">-device cirrus-vga,id=video0,bus=pci.0,addr=0x2 \</span><br><span class="line">-device vfio-pci,host=0000:8c:00.0,id=hostdev1,bus=pci.0,addr=0xc \</span><br><span class="line">-device virtio-balloon-pci,id=balloon0,bus=pci.0,addr=0x3 \</span><br><span class="line">-L /root/pc-bios \</span><br><span class="line">-vnc :1 \</span><br><span class="line">-msg timestamp=on</span><br></pre></td></tr></table></figure><p><strong>aarch64</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/rma/qemu_620/install_dir/bin/qemu-system-aarch64 -name vm0 -machine virt,accel=kvm,usb=off \</span><br><span class="line">-cpu host -m 2048 -smp 2,sockets=1,cores=2,threads=1 \</span><br><span class="line">-boot menu=on \</span><br><span class="line">-hda centos8.6_arm.img \</span><br><span class="line">-device vfio-pci,host=8b:00.1,id=hostdev0,addr=0x9 \</span><br><span class="line">-device vfio-pci,host=8c:00.1,id=hostdev1,addr=0x10 \</span><br><span class="line">-bios /usr/share/qemu-efi-aarch64/QEMU_EFI.fd \</span><br><span class="line">-vnc :50 \</span><br><span class="line">-monitor stdio</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;查看设备的是否是pf，当前驱动&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="LINUX" scheme="https://rma-shuyu.github.io/categories/LINUX/"/>
    
    
    <category term="linux" scheme="https://rma-shuyu.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>manifest管理repo</title>
    <link href="https://rma-shuyu.github.io/2024/01/04/manifest%E7%AE%A1%E7%90%86repo/"/>
    <id>https://rma-shuyu.github.io/2024/01/04/manifest%E7%AE%A1%E7%90%86repo/</id>
    <published>2024-01-04T09:53:36.000Z</published>
    <updated>2024-06-22T07:34:15.373Z</updated>
    
    <content type="html"><![CDATA[<h3 id="repo是什么？"><a href="#repo是什么？" class="headerlink" title="repo是什么？"></a>repo是什么？</h3><p>repo是Google开发的用于管理Android版本库的一个工具，repo是使用Python对git进行了一定的封装，并不是用于取代git，它简化了对多个Git版本库的管理。用repo管理的版本库都需要使用git命令来进行操作。<strong>因此，使用repo工具之前，请先确保已经安装git。</strong></p><span id="more"></span><h3 id="为什么要用repo？"><a href="#为什么要用repo？" class="headerlink" title="为什么要用repo？"></a>为什么要用repo？</h3><p>项目模块化/组件化之后各模块也作为独立的 Git 仓库从主项目里剥离了出去，各模块各自管理自己的版本。Android<a href="https://so.csdn.net/so/search?q=%E6%BA%90%E7%A0%81&spm=1001.2101.3001.7020">源码</a>引用了很多开源项目，每一个子项目都是一个Git仓库，每个Git仓库都有很多分支版本，为了方便统一管理各个子项目的Git仓库，需要一个上层工具批量进行处理，因此repo诞生。<br>repo也会建立一个Git仓库，用来记录当前Android版本下各个子项目的Git仓库分别处于哪一个分支，这个仓库通常叫做：manifest仓库(清单库)。</p><h3 id="repo下载安装"><a href="#repo下载安装" class="headerlink" title="repo下载安装"></a>repo下载安装</h3><p>下载地址：<a href="https://mirrors.tuna.tsinghua.edu.cn/git/git-repo">https://mirrors.tuna.tsinghua.edu.cn/git/git-repo</a> ，将下载下来的文件命名为repo，放在PATH环境变量所包含的目录下面，例如可以放在<code>/usr/local/bin</code>目录下（后面介绍均以放在<code>/usr/local/bin</code>目录下为例）。</p><p>或者，直接使用curl命令下载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo &gt; /usr/local/bin/repo</span><br></pre></td></tr></table></figure><p>最后，修改repo文件的执行权限：<code>chmod 777 /usr/local/bin/repo</code>。</p><h3 id="repo命令介绍"><a href="#repo命令介绍" class="headerlink" title="repo命令介绍"></a>repo命令介绍</h3><p><strong>repo init</strong><br><code>u</code>：指定一个URL，其连接到一个manifest仓库<br><code>m</code>：在manifest仓库中选择一个xml文件，如果未选择，默认指向default.xml<br><code>b</code>：选择一个maniest仓库中的一个特殊的分支<br>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repo init -u git@github.com:rma0227/manifest.git -b main -m my_manifest.xml</span><br></pre></td></tr></table></figure><p>my_manifest.xml:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;manifest&gt;</span><br><span class="line">  &lt;remote name=&quot;jansson&quot; fetch=&quot;https://github.com/akheron/&quot;/&gt;</span><br><span class="line">  &lt;remote name=&quot;json-c&quot; fetch=&quot;https://github.com/json-c/&quot;/&gt;</span><br><span class="line">  &lt;remote name=&quot;yajl&quot; fetch=&quot;https://github.com/lloyd/&quot;/&gt;</span><br><span class="line">  &lt;remote name=&quot;cjson&quot; fetch=&quot;https://github.com/DaveGamble/&quot;/&gt;</span><br><span class="line">  &lt;remote name=&quot;yyjson&quot; fetch=&quot;https://github.com/ibireme/&quot;/&gt;</span><br><span class="line"></span><br><span class="line">  &lt;default revision=&quot;refs/heads/master&quot; sync-j=&quot;4&quot;/&gt;</span><br><span class="line">  &lt;project remote=&quot;jansson&quot; path=&quot;jansson&quot; name=&quot;jansson.git&quot; /&gt;</span><br><span class="line">  &lt;project remote=&quot;json-c&quot; path=&quot;json-c&quot; name=&quot;json-c.git&quot; /&gt;</span><br><span class="line">  &lt;project remote=&quot;yajl&quot; path=&quot;yajl&quot; name=&quot;yajl.git&quot; /&gt;</span><br><span class="line">  &lt;project remote=&quot;cjson&quot; path=&quot;cjson&quot; name=&quot;cJSON.git&quot; /&gt;</span><br><span class="line">  &lt;project remote=&quot;yyjson&quot; path=&quot;yyjson&quot; name=&quot;yyjson.git&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;/manifest&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意，此处命令中 -b main 是指manifest.git 这个repo的branch，可以根据自己的manifest.git的信息，进行设置</p><p><strong>repo sync</strong><br>下载manifest中指定xml设置的repo仓库，如上例中的my_manifest.xml所配置的repo信息。执行完sync命令后，每个project的HEAD指向xml配置的该project revision分支的头节点。</p><p><strong>repo start</strong><br>将本地代码切换到指定分支，注意：此处branch name仅仅是本地的，不和远端branch name关联，这个和git checkout 命令不同</p><p>整体命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">repo init -u git@github.com:rma0227/manifest.git -b main -m my_manifest.xml</span><br><span class="line"></span><br><span class="line">repo sync</span><br><span class="line"></span><br><span class="line">repo start master --all</span><br></pre></td></tr></table></figure><h3 id="manifest-xml简介"><a href="#manifest-xml简介" class="headerlink" title="manifest xml简介"></a>manifest xml简介</h3><p><strong>remote元素</strong><br>设置远程git服务器的属性，包括下面的属性：</p><p><code>name</code>: 远程git服务器的名字，直接用于git fetch, git remote 等操作<br><code>alias</code>: 远程git服务器的别名，如果指定了，则会覆盖name的设定。在一个manifest中， name不能重名，但alias可以重名。<br><code>fetch</code>: 所有projects的git URL 前缀<br>一个manifest文件中可以配置多个remote元素，用于配置不同的project默认下载指向。</p><p><strong>default元素</strong><br>设定所有projects的默认属性值，如果在project元素里没有指定一个属性，则使用default元素的属性值。</p><p><code>remote</code>: 之前定义的某一个remote元素中name属性值，用于指定使用哪一个远程git服务器。<br><code>revision</code>: git分支的名字，例如master或者refs/heads/master<br><code>sync_j</code>: 在repo sync中默认并行的数目。<br><code>sync_c</code>: 如果设置为true，则只同步指定的分支(revision 属性指定)，而不是所有的ref内容。<br><code>sync_s</code>: 如果设置为true，则会同步git的子项目</p><p><strong>project元素</strong><br>指定一个需要clone的git仓库。</p><p><code>name</code>: 唯一的名字标识project，同时也用于生成git仓库的URL。格式如下：<br>      ${remote_fetch}/${project_name}<br><code>path</code>: 可选的路径。指定git clone出来的代码存放在本地的子目录。如果没有指定，则以name作为子目录名。<br><code>remote</code>: 指定之前在某个remote元素中的name。<br><code>revision</code>: 指定需要获取的git提交点，可以是master, refs/heads/master, tag或者SHA-1值。如果不设置的话，默认下载当前project，当前分支上的最新代码。</p><p>示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;manifest&gt;</span><br><span class="line">  &lt;remote name=&quot;corsica&quot; fetch=&quot;ssh://git@bit.jaguarmicro.com:7999/jsc/&quot;/&gt;    -----remote元素，定义remote name 对应的git 仓库地址</span><br><span class="line">  &lt;remote name=&quot;cloud&quot; fetch=&quot;ssh://git@bit.jaguarmicro.com:7999/jac/&quot;/&gt;</span><br><span class="line">  &lt;remote name=&quot;jsw&quot; fetch=&quot;ssh://git@bit.jaguarmicro.com:7999/jag/&quot; /&gt;</span><br><span class="line">  &lt;remote name=&quot;infra&quot; fetch=&quot;ssh://git@bit.jaguarmicro.com:7999/jsi/&quot; /&gt;</span><br><span class="line">  &lt;remote name=&quot;kernel&quot; fetch=&quot;ssh://git@bit.jaguarmicro.com:7999/jsk/&quot; /&gt;</span><br><span class="line">  &lt;remote name=&quot;sim&quot; fetch=&quot;ssh://git@bit.jaguarmicro.com:7999/jsim/&quot; /&gt;</span><br><span class="line">   </span><br><span class="line">  &lt;default remote=&quot;corsica&quot; revision=&quot;refs/heads/corsica_dpu_dev&quot; sync-j=&quot;4&quot;/&gt;  -----default元素，定义了默认的remote name 、branch分支、repo sync并行数目</span><br><span class="line">   </span><br><span class="line">  &lt;!-- Platform Zone --&gt;</span><br><span class="line">  &lt;project remote=&quot;corsica&quot; path=&quot;jmnd-dpu-corsica&quot; name=&quot;jmnd-dpu-corsica.git&quot; groups=&quot;drsm&quot;/&gt;  ----project元素</span><br><span class="line">  &lt;project remote=&quot;corsica&quot; path=&quot;jmnd-dpu-corsica/drsm&quot; name=&quot;corsica-drsm.git&quot; groups=&quot;drsm&quot; /&gt;</span><br><span class="line">  &lt;project remote=&quot;corsica&quot; path=&quot;jmnd-dpu-corsica/drsm/dral-soc&quot; name=&quot;dral-soc.git&quot; groups=&quot;drsm&quot; /&gt;</span><br><span class="line">  &lt;project remote=&quot;corsica&quot; path=&quot;jmnd-dpu-corsica/drsm/dral-soc/io_mgr&quot; name=&quot;soc-io-mgr.git&quot; groups=&quot;drsm&quot; /&gt;</span><br><span class="line">  &lt;project remote=&quot;corsica&quot; path=&quot;jmnd-dpu-corsica/drsm/dral-soc/resource_mgr&quot; name=&quot;soc-res-mgr.git&quot; groups=&quot;drsm&quot; /&gt;</span><br><span class="line">  &lt;project remote=&quot;cloud&quot; path=&quot;jmnd-dpu-corsica/drsm/ovs&quot; name=&quot;ovs.git&quot; groups=&quot;drsm&quot; /&gt;</span><br><span class="line">  &lt;project remote=&quot;cloud&quot; path=&quot;jmnd-dpu-corsica/drsm/spdk&quot; name=&quot;spdk.git&quot; groups=&quot;drsm&quot; /&gt;</span><br><span class="line">  &lt;project remote=&quot;infra&quot; path=&quot;jmnd-dpu-corsica/drsm/admin&quot; name=&quot;jmnd-hypervisor.git&quot; groups=&quot;drsm&quot; /&gt;</span><br><span class="line">  &lt;project remote=&quot;infra&quot; path=&quot;jmnd-dpu-corsica/drsm/oprom&quot; name=&quot;oprom.git&quot; groups=&quot;drsm&quot; /&gt;</span><br><span class="line">  &lt;project remote=&quot;infra&quot; path=&quot;jmnd-dpu-corsica/drsm/tools/univer-tools&quot; name=&quot;univer-tools.git&quot; groups=&quot;drsm&quot; /&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;project remote=&quot;jsw&quot; path=&quot;jmnd-dpu-corsica/rdma&quot; name=&quot;rdma-corsica.git&quot; groups=&quot;rmda&quot;/&gt;</span><br><span class="line">  &lt;project remote=&quot;jsw&quot; path=&quot;jmnd-dpu-corsica/rdma/ci&quot; name=&quot;ci.git&quot; revision=&quot;refs/heads/rdma-dev&quot; groups=&quot;rmda&quot;/&gt;</span><br><span class="line">  &lt;project remote=&quot;jsw&quot; path=&quot;jmnd-dpu-corsica/rdma/rdma-core&quot; name=&quot;rdma-core.git&quot; revision=&quot;refs/heads/rdma-dev&quot; groups=&quot;rmda&quot;/&gt;</span><br><span class="line">  &lt;project remote=&quot;corsica&quot; path=&quot;jmnd-dpu-corsica/rdma/rpe_header&quot; name=&quot;chip-headers.git&quot; groups=&quot;rmda&quot;/&gt;</span><br><span class="line">  &lt;project remote=&quot;kernel&quot; path=&quot;jmnd-dpu-corsica/rdma/kernel&quot; name=&quot;kernel-linux-5.10-back.git&quot; revision=&quot;refs/heads/rdma-dev&quot; groups=&quot;rmda&quot;/&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;project remote=&quot;jsw&quot; path=&quot;jmnd-dpu-corsica/p4/p4c&quot; name=&quot;p4c.git&quot; groups=&quot;p4&quot;/&gt;</span><br><span class="line">  &lt;project remote=&quot;jsw&quot; path=&quot;jmnd-dpu-corsica/p4/common&quot; name=&quot;p4-common.git&quot; groups=&quot;p4&quot;/&gt;</span><br><span class="line">  &lt;project remote=&quot;jsw&quot; path=&quot;jmnd-dpu-corsica/p4/riscv-gnu-toolchain&quot; name=&quot;riscv-gnu-toolchain.git&quot; groups=&quot;p4&quot;/&gt;</span><br><span class="line">  &lt;project remote=&quot;jsw&quot; path=&quot;jmnd-dpu-corsica/p4/p4-ci-test&quot; name=&quot;p4-ci-test.git&quot; revision=&quot;refs/heads/master&quot; groups=&quot;p4&quot;/&gt;</span><br><span class="line">   </span><br><span class="line">  &lt;project remote=&quot;sim&quot; path=&quot;jmnd-dpu-corsica/sim/imu&quot; name=&quot;corsica-sim-imu.git&quot; groups=&quot;sim&quot;/&gt;</span><br><span class="line">  &lt;project remote=&quot;sim&quot; path=&quot;jmnd-dpu-corsica/sim/dpe&quot; name=&quot;corsica-sim-dpe.git&quot; groups=&quot;sim&quot;/&gt;</span><br><span class="line">  &lt;project remote=&quot;sim&quot; path=&quot;jmnd-dpu-corsica/sim/qemu&quot; name=&quot;corsica-sim-qemu.git&quot; groups=&quot;sim&quot;/&gt;</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><h4 id="建立自己的manifest仓库"><a href="#建立自己的manifest仓库" class="headerlink" title="建立自己的manifest仓库"></a>建立自己的manifest仓库</h4><p>可以参考下面脚本修改（自己没有权限的repo，一定要从xml中删除）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;manifest&gt;</span><br><span class="line">  &lt;remote name=&quot;corsica&quot; fetch=&quot;ssh://git@bit.jaguarmicro.com:7999/jsc/&quot;/&gt;</span><br><span class="line">  &lt;!-- define private remote name by your name --&gt;</span><br><span class="line">  &lt;remote name=&quot;pri&quot; fetch=&quot;ssh://git@bit.jaguarmicro.com:7999/~qiulei.xu&quot;/&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;default remote=&quot;corsica&quot; revision=&quot;refs/heads/corsica_dpu_dev&quot; sync-j=&quot;4&quot;/&gt;</span><br><span class="line"> </span><br><span class="line">  &lt;!-- Platform Zone --&gt;</span><br><span class="line">  &lt;project remote=&quot;corsica&quot; path=&quot;dral-soc&quot; name=&quot;dral-soc.git&quot;/&gt;</span><br><span class="line">  &lt;!-- project remote=&quot;corsica&quot; path=&quot;dral-soc/resource_mgr&quot; name=&quot;soc-res-mgr.git&quot; --/&gt;</span><br><span class="line">  &lt;!-- If you use a private library, replace the previous one with the following configuration  --&gt;</span><br><span class="line">  &lt;project remote=&quot;pri&quot; path=&quot;dral-soc/resource_mgr&quot; name=&quot;soc-res-mgr.git&quot; &gt;     --------此处代码从自己个人库中下</span><br><span class="line">  &lt;project remote=&quot;corsica&quot; path=&quot;dral-soc/ext-lib&quot; name=&quot;ext-lib.git&quot;/&gt;</span><br><span class="line">  &lt;project remote=&quot;corsica&quot; path=&quot;dral-soc/libdpu_soc/msg&quot; name=&quot;dpu-soc-msg.git&quot; /&gt;</span><br><span class="line">  &lt;project remote=&quot;corsica&quot; path=&quot;dral-soc/libdpu_soc/include/platform/corsica/chip-headers&quot; name=&quot;chip-headers.git&quot; revision=&quot;refs/heads/corsica_dpu_dev_B300&quot;/&gt;</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure><h4 id="执行repo命令下载代码"><a href="#执行repo命令下载代码" class="headerlink" title="执行repo命令下载代码"></a>执行repo命令下载代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">repo init -u ssh://git@bit.jaguarmicro.com:7999/xxxx/manifest.git -b corsica_dpu_dev -m dral_soc.xml（确保这个xml里的所有repo你都有权限，没有权限的project需要删掉）</span><br><span class="line">repo sync</span><br><span class="line">repo start corsica_dpu_dev --all</span><br></pre></td></tr></table></figure><h4 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h4><p>下载代码修改验证后，如需提交，到path目录下，例如修改了上面的dral-soc.git repo中的代码，则进入dral-soc目录，执行如下操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add</span><br><span class="line">git commit</span><br><span class="line">git push corsica(remote name) HEAD:corsica_dpu_dev(branch name for remote)</span><br></pre></td></tr></table></figure><p>注意：push命令，需要指定远端仓库名称（remote name），远端代码分支名称，远端仓库和分支名称可以通过git branch -a查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@jm222:dral-soc# git branch -a</span><br><span class="line">* local_corsica_dev</span><br><span class="line">  remotes/corsica/corsica_dpu_dev</span><br><span class="line">  remotes/corsica/corsica_pt_B300</span><br><span class="line">  remotes/m/corsica_dpu_dev -&gt; corsica/corsica_dpu_dev  -------此信息提供了remote name:corsica, branch:corsica_dpu_dev</span><br></pre></td></tr></table></figure><p>如果本地分支名称和xml中配置的远端分支名称相同，可以简化git push命令，直接调用git push就可以提交代码</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;repo是什么？&quot;&gt;&lt;a href=&quot;#repo是什么？&quot; class=&quot;headerlink&quot; title=&quot;repo是什么？&quot;&gt;&lt;/a&gt;repo是什么？&lt;/h3&gt;&lt;p&gt;repo是Google开发的用于管理Android版本库的一个工具，repo是使用Python对git进行了一定的封装，并不是用于取代git，它简化了对多个Git版本库的管理。用repo管理的版本库都需要使用git命令来进行操作。&lt;strong&gt;因此，使用repo工具之前，请先确保已经安装git。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="GIT" scheme="https://rma-shuyu.github.io/categories/GIT/"/>
    
    
    <category term="manifest" scheme="https://rma-shuyu.github.io/tags/manifest/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下rust安装配置</title>
    <link href="https://rma-shuyu.github.io/2024/01/03/Ubuntu%E4%B8%8Brust%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <id>https://rma-shuyu.github.io/2024/01/03/Ubuntu%E4%B8%8Brust%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</id>
    <published>2024-01-03T09:41:06.000Z</published>
    <updated>2024-06-22T07:34:15.326Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装rust"><a href="#安装rust" class="headerlink" title="安装rust"></a>安装rust</h3><blockquote><p>安装curl</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install curl</span><br></pre></td></tr></table></figure><blockquote><p>安装rust</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://sh.rustup.rs -sSf | sh</span><br></pre></td></tr></table></figure><span id="more"></span><blockquote><p>​选择1默认安装</p></blockquote><blockquote><p>环境变量生效</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source $HOME/.cargo/env</span><br></pre></td></tr></table></figure><blockquote><p>查看版本</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rustc -V</span><br></pre></td></tr></table></figure><h3 id="rust-analyzer加载时间过长"><a href="#rust-analyzer加载时间过长" class="headerlink" title="rust-analyzer加载时间过长"></a>rust-analyzer加载时间过长</h3><p>开发环境:<br>vscode+rust-analyzer</p><p>问题：<br>vscode一直卡在<code>fetching metadata</code>阶段。</p><p>方法:<br>运行<code>cargo metadata</code>,发现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Blocking waiting for file lock on package cache</span><br></pre></td></tr></table></figure><p>运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf ~/.cargo/.package-cache</span><br></pre></td></tr></table></figure><p>删除cargo的缓存，而后再运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo metadata</span><br></pre></td></tr></table></figure><h3 id="Cargo-build失败解决办法"><a href="#Cargo-build失败解决办法" class="headerlink" title="Cargo build失败解决办法"></a>Cargo build失败解决办法</h3><p><strong>现象</strong><br>cargo build 时下载失败, 提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">error: failed to download from `https://crates-io.proxy.ustclug.org/api/v1/crates/actix-codec/0.3.0/download`</span><br><span class="line"></span><br><span class="line">Caused by:  </span><br><span class="line">[56] Failure when receiving data from the peer (Received HTTP code 500 from proxy after CONNECT)</span><br></pre></td></tr></table></figure><p><strong>解决</strong><br>vim ~/.cargo/config</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># 放到 `$HOME/.cargo/config` 文件中</span><br><span class="line">[source.crates-io]</span><br><span class="line">registry = &quot;https://github.com/rust-lang/crates.io-index&quot;</span><br><span class="line"></span><br><span class="line"># 替换成你偏好的镜像源</span><br><span class="line">replace-with = &#x27;sjtu&#x27;</span><br><span class="line">#replace-with = &#x27;ustc&#x27;</span><br><span class="line"></span><br><span class="line"># 清华大学</span><br><span class="line">[source.tuna]</span><br><span class="line">registry = &quot;https://mirrors.tuna.tsinghua.edu.cn/git/crates.io-index.git&quot;</span><br><span class="line"></span><br><span class="line"># 中国科学技术大学</span><br><span class="line">[source.ustc]</span><br><span class="line">registry = &quot;git://mirrors.ustc.edu.cn/crates.io-index&quot;</span><br><span class="line"></span><br><span class="line"># 上海交通大学</span><br><span class="line">[source.sjtu]</span><br><span class="line">registry = &quot;https://mirrors.sjtug.sjtu.edu.cn/git/crates.io-index&quot;</span><br><span class="line"></span><br><span class="line"># rustcc社区</span><br><span class="line">[source.rustcc]</span><br><span class="line">registry = &quot;git://crates.rustcc.cn/crates.io-index&quot;</span><br><span class="line"></span><br><span class="line">[net]</span><br><span class="line">git-fetch-with-cli=true</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>变为上海交通大学的源，最重要的是 最后net的参数，设置为从git拉取。git不会被墙。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;安装rust&quot;&gt;&lt;a href=&quot;#安装rust&quot; class=&quot;headerlink&quot; title=&quot;安装rust&quot;&gt;&lt;/a&gt;安装rust&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;安装curl&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo apt install curl&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;安装rust&lt;/p&gt;
&lt;/blockquote&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;curl https://sh.rustup.rs -sSf | sh&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="rust" scheme="https://rma-shuyu.github.io/categories/rust/"/>
    
    
    <category term="rust" scheme="https://rma-shuyu.github.io/tags/rust/"/>
    
  </entry>
  
  <entry>
    <title>DOCA 开发容器</title>
    <link href="https://rma-shuyu.github.io/2023/04/08/DOCA-%E5%BC%80%E5%8F%91%E5%AE%B9%E5%99%A8/"/>
    <id>https://rma-shuyu.github.io/2023/04/08/DOCA-%E5%BC%80%E5%8F%91%E5%AE%B9%E5%99%A8/</id>
    <published>2023-04-08T12:50:20.000Z</published>
    <updated>2024-06-22T07:34:15.315Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前提准备"><a href="#前提准备" class="headerlink" title="前提准备"></a>前提准备</h2><blockquote><p>Note: 运行 <code>DOCA</code> 的<code>Linux Docker</code> 容器所需的最低 <code>Docker</code> 引擎版本为 <code>19.03</code>。  </p></blockquote><span id="more"></span><ul><li><p>  在主机系统上，从<a href="https://www.docker.com/">https://www.docker.com/</a>下载您的组织所需的 Docker 软件类型（企业版、桌面版或其他）。</p></li><li><p>或者，从<a href="https://get.docker.com/">https://get.docker.com/</a> 下载安装脚本，并使用类似于以下内容的命令在主机系统上安装DRIVE OS Docker：</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -qO- https://get.docker.com/ | $&#123;SHELL&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="NVIDIA-GPU-云访问"><a href="#NVIDIA-GPU-云访问" class="headerlink" title="NVIDIA GPU 云访问"></a>NVIDIA GPU 云访问</h2><p>为了访问<a href="http://ngc.nvidia.com/">NVIDIA GPU Cloud (NGC)</a>，需要一个<a href="http://developer.nvidia.com/">NVIDIA 开发者帐户</a>。请先注册一个帐户并申请开发者计划的会员资格，然后再继续。</p><h2 id="登录-NVIDIA-GPU-云"><a href="#登录-NVIDIA-GPU-云" class="headerlink" title="登录 NVIDIA GPU 云"></a>登录 NVIDIA GPU 云</h2><blockquote><p>注意：请确保您已收到 NGC 激活电子邮件并成功激活您的 NGC 组织和 NGC 团队，然后再继续。   </p></blockquote><ul><li>在主机系统上，使用您的 NVIDIA 开发人员凭据登录 NGC(<a href="https://ngc.nvidia.com/">https://ngc.nvidia.com</a>) 。</li><li> 登录后，选择页面右上角“用户”菜单下的“设置”以生成 API 密钥来提取 Docker 映像。</li></ul><p><img src="b194e5d858b239bf7cc779ee840a29867f4751ad27b8f3def18c5fc572ed63eb.png" alt="picture 0">  </p><p>使用参考<br>    <a href="https://docs.nvidia.com/ngc/ngc-overview/index.html#generating-api-key">https://docs.nvidia.com/ngc/ngc-overview/index.html#generating-api-key</a></p><ul><li><p>登录 NGC 容器注册表.</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker login nvcr.io</span><br></pre></td></tr></table></figure></li><li><p>当提示您输入用户名时，请输入以下文本:</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$oauthtoken</span><br></pre></td></tr></table></figure><p>  用户$oauthtoken名是一个特殊的用户名，表示您将使用 API 密钥进行身份验证，而不是用户名和密码。</p></li><li><p>当提示输入密码时，输入您的 NGC API 密钥，如下例所示:</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Username: $oauthtoken </span><br><span class="line">Password: _my-api-key_</span><br><span class="line">## 或者</span><br><span class="line">docker login  nvcr.io  -u &#x27;$oauthtoken&#x27; -p _my-api-key_</span><br></pre></td></tr></table></figure><p>  有关登录方法的更多信息，请参阅<a href="https://docs.docker.com/engine/reference/commandline/login/">Docker 登录文档</a>。</p></li><li><p>拉取镜像:</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull nvcr.io/nvidia/doca/doca:1.5.0-devel</span><br></pre></td></tr></table></figure></li><li><p>运行:</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm --privileged multiarch/qemu-user-static --reset --persistent yes</span><br><span class="line"></span><br><span class="line">docker run --name doca_dev -itd nvcr.io/nvidia/doca/doca:1.5.0-devel bash</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前提准备&quot;&gt;&lt;a href=&quot;#前提准备&quot; class=&quot;headerlink&quot; title=&quot;前提准备&quot;&gt;&lt;/a&gt;前提准备&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Note: 运行 &lt;code&gt;DOCA&lt;/code&gt; 的&lt;code&gt;Linux Docker&lt;/code&gt; 容器所需的最低 &lt;code&gt;Docker&lt;/code&gt; 引擎版本为 &lt;code&gt;19.03&lt;/code&gt;。  &lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="DOCA" scheme="https://rma-shuyu.github.io/categories/DOCA/"/>
    
    
    <category term="DOCA" scheme="https://rma-shuyu.github.io/tags/DOCA/"/>
    
  </entry>
  
  <entry>
    <title>cloud-hypervisor</title>
    <link href="https://rma-shuyu.github.io/2023/04/08/cloud-hypervisor/"/>
    <id>https://rma-shuyu.github.io/2023/04/08/cloud-hypervisor/</id>
    <published>2023-04-08T12:50:20.000Z</published>
    <updated>2024-06-22T07:34:15.341Z</updated>
    
    <content type="html"><![CDATA[<h3 id="cloud-hypervisor-单独启动，带一个net设备"><a href="#cloud-hypervisor-单独启动，带一个net设备" class="headerlink" title="cloud-hypervisor 单独启动，带一个net设备"></a>cloud-hypervisor 单独启动，带一个net设备</h3><p>内核版本：4.18.0+（不同版本的cloud-hypervisor对内核的最低版本有要求，不匹配cloud-hypervisor无法运行）</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"># 下载cloud-hypervisor最新版本（static版本，无需动态库依赖）</span><br><span class="line">wget https://github.com/cloud-hypervisor/cloud-hypervisor/releases/download/v22.0/cloud-hypervisor-static</span><br><span class="line">mv cloud-hypervisor-static  cloud-hypervisor</span><br><span class="line">setcap cap_net_admin+ep ./cloud-hypervisor</span><br><span class="line">chmod +x cloud-hypervisor</span><br><span class="line"> </span><br><span class="line"># 下载 Ubuntu 云镜像，使用 qemu-img 转换其格式</span><br><span class="line">wget https://cloud-images.ubuntu.com/focal/current/focal-server-cloudimg-amd64.img</span><br><span class="line">qemu-img convert -p -f qcow2 -O raw focal-server-cloudimg-amd64.img focal-server-cloudimg-amd64.raw</span><br><span class="line"> </span><br><span class="line"># 下载虚拟化管理程序的固件</span><br><span class="line">wget https://github.com/cloud-hypervisor/rust-hypervisor-firmware/releases/download/0.4.2/hypervisor-fw</span><br><span class="line"> </span><br><span class="line"># 拉取cloud-hypervisor仓库</span><br><span class="line">git clone https://github.com/cloud-hypervisor/cloud-hypervisor</span><br><span class="line">cd cloud-hypervisor</span><br><span class="line"> </span><br><span class="line"># 拷贝cloud init脚本并执行(该脚本会会生成init镜像到/tmp/ubuntu-cloudinit.img，将用户名密码初始化为cloud/cloud123等)</span><br><span class="line">cp scripts/create-cloud-init.sh create-cloud-init.sh</span><br><span class="line">chmod +x create-cloud-init.sh</span><br><span class="line">./create-cloud-init.sh</span><br><span class="line"> </span><br><span class="line"># 启动cloud-hypervisor（后端虚机创建，前端加载好vfio驱动）</span><br><span class="line">./cloud-hypervisor \</span><br><span class="line">    --kernel ./hypervisor-fw \</span><br><span class="line">    --disk path=focal-server-cloudimg-amd64.raw path=/tmp/ubuntu-cloudinit.img \</span><br><span class="line">    --cpus boot=4 \</span><br><span class="line">    --memory size=1024M \</span><br><span class="line">    --device path=/sys/bus/pci/devices/0000:b8:00.1</span><br><span class="line"> </span><br><span class="line"># 虚拟机中一开始看不到网卡，需手动加载驱动</span><br><span class="line">echo virtio-pci &gt; /sys/bus/pci/devices/0000\:00\:04.0/driver_override</span><br><span class="line">echo 0000:00:04.0 &gt; /sys/bus/pci/drivers_probe</span><br><span class="line"> </span><br><span class="line"># 驱动加载完成可看到设备</span><br><span class="line">root@cloud:/home/cloud# ip a</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 ::1/128 scope host</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">2: ens4: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/ether 52:54:00:00:23:49 brd ff:ff:ff:ff:ff:ff</span><br></pre></td></tr></table></figure><h3 id="安装kata和containerd，测试启动默认安全容器"><a href="#安装kata和containerd，测试启动默认安全容器" class="headerlink" title="安装kata和containerd，测试启动默认安全容器"></a>安装kata和containerd，测试启动默认安全容器</h3><p>参考此文档 <a href="https://github.com/containerd/containerd/blob/main/docs/getting-started.md%EF%BC%8C%E5%85%88%E5%AE%89%E8%A3%85%E5%A5%BDcontainerd">https://github.com/containerd/containerd/blob/main/docs/getting-started.md，先安装好containerd</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"># 下载kata安装包</span><br><span class="line">wget https://github.com/kata-containers/kata-containers/releases/download/3.2.0/kata-static-3.2.0-amd64.tar.xz</span><br><span class="line"> </span><br><span class="line"># 解压安装</span><br><span class="line">mv kata-static-3.2.0-amd64.tar.xz /</span><br><span class="line">cd /</span><br><span class="line">xz -d &lt; kata-static-3.2.0-amd64.tar.xz | tar -xvf -</span><br><span class="line">export PATH=$PATH:/opt/kata/bin</span><br><span class="line"> </span><br><span class="line"># 创建符号链接，否则后续containerd会找不到containerd-shim-kata-v2</span><br><span class="line">ln -s /opt/kata/bin/containerd-shim-kata-v2 /usr/local/bin/containerd-shim-kata-v2</span><br><span class="line"> </span><br><span class="line"># 生成containerd默认配置</span><br><span class="line">containerd config default &gt; /etc/containerd/config.toml</span><br><span class="line"> </span><br><span class="line"># 修改以下内容（containerd默认采用runc，改为kata）</span><br><span class="line">[plugins]</span><br><span class="line">  [plugins.&quot;io.containerd.grpc.v1.cri&quot;]</span><br><span class="line">    [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd]</span><br><span class="line">      default_runtime_name = &quot;kata&quot;</span><br><span class="line">      [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes]</span><br><span class="line">        [plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.kata]</span><br><span class="line">          runtime_type = &quot;io.containerd.kata.v2&quot;</span><br><span class="line"> </span><br><span class="line"># 重启containerd服务</span><br><span class="line">systemctl restart containerd.service</span><br><span class="line"> </span><br><span class="line"># 测试busybox容器</span><br><span class="line">image=&quot;docker.io/library/busybox:latest&quot;</span><br><span class="line">ctr image pull &quot;$image&quot;</span><br><span class="line">ctr run --runtime &quot;io.containerd.kata.v2&quot; --rm -t &quot;$image&quot; test-kata sh</span><br><span class="line"> </span><br><span class="line"># 容器中查看内核版本，跟host不同</span><br><span class="line">/ # uname -a</span><br><span class="line">Linux localhost 6.1.38 #1 SMP Mon Oct 23 18:02:47 UTC 2023 x86_64 GNU/Linux</span><br><span class="line"> </span><br><span class="line"># ps看到，kata默认使用qemu起的虚拟机</span><br><span class="line">ps aux|grep kata</span><br><span class="line">root        5768  0.0  0.0 1857428 36320 pts/0   Sl+  17:17   0:00 ctr run --runtime io.containerd.kata.v2 --rm -t docker.io/library/busybox:latest test-kata sh</span><br><span class="line">root        5788  0.1  0.0 1421180 33536 ?       Sl   17:17   0:00 /opt/kata/bin/containerd-shim-kata-v2 -namespace default -address /run/containerd/containerd.sock -publish-binary /usr/local/bin/containerd -id test-kata</span><br><span class="line">root        5797  0.0  0.0   2612  1916 ?        S    17:17   0:00 /opt/kata/libexec/virtiofsd --syslog --cache=auto --shared-dir=/run/kata-containers/shared/sandboxes/test-kata/shared --fd=3 --thread-pool-size=1 --announce-submounts</span><br><span class="line">root        5798  1.2  0.2 2675292 194512 ?      Sl   17:17   0:00 /opt/kata/bin/qemu-system-x86_64 -name sandbox-test-kata -uuid c39b09f2-135a-49d7-b1ee-721239c9cd42 -machine q35,accel=kvm,nvdimm=on -cpu host,pmu=off -qmp unix:fd=3,server=on,wait=off -m 2048M,slots=10,maxmem=64555M -device pci-bridge,bus=pcie.0,id=pci-bridge-0,chassis_nr=1,shpc=off,addr=2,io-reserve=4k,mem-reserve=1m,pref64-reserve=1m -device virtio-serial-pci,disable-modern=false,id=serial0 -device virtconsole,chardev=charconsole0,id=console0 -chardev socket,id=charconsole0,path=/run/vc/vm/test-kata/console.sock,server=on,wait=off -device nvdimm,id=nv0,memdev=mem0,unarmed=on -object memory-backend-file,id=mem0,mem-path=/opt/kata/share/kata-containers/kata-ubuntu-latest.image,size=268435456,readonly=on -device virtio-scsi-pci,id=scsi0,disable-modern=false -object rng-random,id=rng0,filename=/dev/urandom -device virtio-rng-pci,rng=rng0 -device vhost-vsock-pci,disable-modern=false,vhostfd=4,id=vsock-3367298568,guest-cid=3367298568 -chardev socket,id=char-50717c87b57f1a65,path=/run/vc/vm/test-kata/vhost-fs.sock -device vhost-user-fs-pci,chardev=char-50717c87b57f1a65,tag=kataShared,queue-size=1024 -rtc base=utc,driftfix=slew,clock=host -global kvm-pit.lost_tick_policy=discard -vga none -no-user-config -nodefaults -nographic --no-reboot -object memory-backend-file,id=dimm1,size=2048M,mem-path=/dev/shm,share=on -numa node,memdev=dimm1 -kernel /opt/kata/share/kata-containers/vmlinux-6.1.38-114 -append tsc=reliable no_timer_check rcupdate.rcu_expedited=1 i8042.direct=1 i8042.dumbkbd=1 i8042.nopnp=1 i8042.noaux=1 noreplace-smp reboot=k cryptomgr.notests net.ifnames=0 pci=lastbus=0 root=/dev/pmem0p1 rootflags=dax,data=ordered,errors=remount-ro ro rootfstype=ext4 console=hvc0 console=hvc1 quiet systemd.show_status=false panic=1 nr_cpus=80 selinux=0 systemd.unit=kata-containers.target systemd.mask=systemd-networkd.service systemd.mask=systemd-networkd.socket scsi_mod.scan=none -pidfile /run/vc/vm/test-kata/pid -smp 1,cores=1,threads=1,sockets=80,maxcpus=80</span><br><span class="line">root        5800  0.0  0.0 2106012 5136 ?        Sl   17:17   0:00 /opt/kata/libexec/virtiofsd --syslog --cache=auto --shared-dir=/run/kata-containers/shared/sandboxes/test-kata/shared --fd=3 --thread-pool-size=1 --announce-submounts</span><br><span class="line">root        5857  0.0  0.0 229088  1044 pts/1    S+   17:18   0:00 grep --color=auto kata</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;cloud-hypervisor-单独启动，带一个net设备&quot;&gt;&lt;a href=&quot;#cloud-hypervisor-单独启动，带一个net设备&quot; class=&quot;headerlink&quot; title=&quot;cloud-hypervisor 单独启动，带一个net设备&quot;&gt;&lt;/a&gt;cloud-hypervisor 单独启动，带一个net设备&lt;/h3&gt;&lt;p&gt;内核版本：4.18.0+（不同版本的cloud-hypervisor对内核的最低版本有要求，不匹配cloud-hypervisor无法运行）&lt;/p&gt;</summary>
    
    
    
    <category term="cloud-hypervisor" scheme="https://rma-shuyu.github.io/categories/cloud-hypervisor/"/>
    
    
    <category term="cloud-hypervisor" scheme="https://rma-shuyu.github.io/tags/cloud-hypervisor/"/>
    
    <category term="kata" scheme="https://rma-shuyu.github.io/tags/kata/"/>
    
  </entry>
  
  <entry>
    <title>右值引用</title>
    <link href="https://rma-shuyu.github.io/2023/03/27/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
    <id>https://rma-shuyu.github.io/2023/03/27/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/</id>
    <published>2023-03-27T12:47:17.000Z</published>
    <updated>2024-06-22T07:34:15.442Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是左值、右值"><a href="#什么是左值、右值" class="headerlink" title="什么是左值、右值"></a>什么是左值、右值</h3><p>首先不考虑引用以减少干扰，可以从2个角度判断：左值<strong>可以取地址、位于等号左边</strong>；而右值<strong>没法取地址，位于等号右边</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int a = 5;</span><br></pre></td></tr></table></figure><ul><li>  a可以通过 &amp; 取地址，位于等号左边，所以a是左值。</li><li>  5位于等号右边，5没法通过 &amp; 取地址，所以5是个右值。<span id="more"></span></li></ul><p>再举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">struct A &#123;</span><br><span class="line">    A(int a = 0) &#123;</span><br><span class="line">        a_ = a;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    int a_;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">A a = A();</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>  同样的，a可以通过 &amp; 取地址，位于等号左边，所以a是左值。</li><li>  A()是个临时值，没法通过 &amp; 取地址，位于等号右边，所以A()是个右值。</li></ul><p>可见左右值的概念很清晰，有地址的变量就是左值，没有地址的字面值、临时值就是右值。</p><h3 id="什么是左值引用、右值引用"><a href="#什么是左值引用、右值引用" class="headerlink" title="什么是左值引用、右值引用"></a>什么是左值引用、右值引用</h3><p>引用本质是别名，可以通过引用修改变量的值，传参时传引用可以避免拷贝，其实现原理和指针类似。 个人认为，引用出现的本意是为了降低C语言指针的使用难度，但现在指针+左右值引用共同存在，反而大大增加了学习和理解成本。</p><h3 id="左值引用"><a href="#左值引用" class="headerlink" title="左值引用"></a>左值引用</h3><p>左值引用大家都很熟悉，<strong>能指向左值，不能指向右值的就是左值引用</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int a = 5;</span><br><span class="line">int &amp;ref_a = a; // 左值引用指向左值，编译通过</span><br><span class="line">int &amp;ref_a = 5; // 左值引用指向了右值，会编译失败</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>引用是变量的别名，由于右值没有地址，没法被修改，所以左值引用无法指向右值。</strong></p><p>但是，const左值引用是可以指向右值的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int &amp;ref_a = 5;  // 编译通过</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>const左值引用不会修改指向值，因此可以指向右值，这也是为什么要使用<code>const &amp;</code>作为函数参数的原因之一，如<code>std::vector</code>的<code>push_back</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void push_back (const value_type&amp; val);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果没有<code>const</code>，<code>vec.push_back(5)</code>这样的代码就无法编译通过了。</p><h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>再看下右值引用，右值引用的标志是<code>&amp;&amp;</code>，顾名思义，右值引用专门为右值而生，<strong>可以指向右值，不能指向左值</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int &amp;&amp;ref_a_right = 5; // ok</span><br><span class="line"> </span><br><span class="line">int a = 5;</span><br><span class="line">int &amp;&amp;ref_a_left = a; // 编译不过，右值引用不可以指向左值</span><br><span class="line"> </span><br><span class="line">ref_a_right = 6; // 右值引用的用途：可以修改右值</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="对左右值引用本质的讨论"><a href="#对左右值引用本质的讨论" class="headerlink" title="对左右值引用本质的讨论"></a>对左右值引用本质的讨论</h3><p>下边的论述比较复杂，也是本文的核心，对理解这些概念非常重要。</p><h4 id="右值引用有办法指向左值吗？"><a href="#右值引用有办法指向左值吗？" class="headerlink" title="右值引用有办法指向左值吗？"></a>右值引用有办法指向左值吗？</h4><p>有办法，<code>std::move</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a = 5; // a是个左值</span><br><span class="line">int &amp;ref_a_left = a; // 左值引用指向左值</span><br><span class="line">int &amp;&amp;ref_a_right = std::move(a); // 通过std::move将左值转化为右值，可以被右值引用指向</span><br><span class="line"> </span><br><span class="line">cout &lt;&lt; a; // 打印结果：5</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上边的代码里，看上去是左值a通过std::move移动到了右值ref_a_right中，那是不是a里边就没有值了？并不是，打印出a的值仍然是5。</p><p><code>std::move</code>是一个非常有迷惑性的函数，不理解左右值概念的人们往往以为它能把一个变量里的内容移动到另一个变量，<strong>但事实上std::move移动不了什么，唯一的功能是把左值强制转化为右值</strong>，让右值引用可以指向左值。其实现等同于一个类型转换：<code>static_cast&lt;T&amp;&amp;&gt;(lvalue)</code>。 所以，<strong>单纯的std::move(xxx)不会有性能提升</strong>，std::move的使用场景在第三章会讲。</p><p>同样的，右值引用能指向右值，本质上也是把右值提升为一个左值，并定义一个右值引用通过std::move指向该左值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int &amp;&amp;ref_a = 5;</span><br><span class="line">ref_a = 6; </span><br><span class="line"> </span><br><span class="line">等同于以下代码：</span><br><span class="line"> </span><br><span class="line">int temp = 5;</span><br><span class="line">int &amp;&amp;ref_a = std::move(temp);</span><br><span class="line">ref_a = 6;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="左值引用、右值引用本身是左值还是右值？"><a href="#左值引用、右值引用本身是左值还是右值？" class="headerlink" title="左值引用、右值引用本身是左值还是右值？"></a>左值引用、右值引用本身是左值还是右值？</h4><p><strong>被声明出来的左、右值引用都是左值</strong>。 因为被声明出的左右值引用是有地址的，也位于等号左边。仔细看下边代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 形参是个右值引用</span><br><span class="line">void change(int&amp;&amp; right_value) &#123;</span><br><span class="line">    right_value = 8;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main() &#123;</span><br><span class="line">    int a = 5; // a是个左值</span><br><span class="line">    int &amp;ref_a_left = a; // ref_a_left是个左值引用</span><br><span class="line">    int &amp;&amp;ref_a_right = std::move(a); // ref_a_right是个右值引用</span><br><span class="line"> </span><br><span class="line">    change(a); // 编译不过，a是左值，change参数要求右值</span><br><span class="line">    change(ref_a_left); // 编译不过，左值引用ref_a_left本身也是个左值</span><br><span class="line">    change(ref_a_right); // 编译不过，右值引用ref_a_right本身也是个左值</span><br><span class="line">     </span><br><span class="line">    change(std::move(a)); // 编译通过</span><br><span class="line">    change(std::move(ref_a_right)); // 编译通过</span><br><span class="line">    change(std::move(ref_a_left)); // 编译通过</span><br><span class="line"> </span><br><span class="line">    change(5); // 当然可以直接接右值，编译通过</span><br><span class="line">     </span><br><span class="line">    cout &lt;&lt; &amp;a &lt;&lt; &#x27; &#x27;;</span><br><span class="line">    cout &lt;&lt; &amp;ref_a_left &lt;&lt; &#x27; &#x27;;</span><br><span class="line">    cout &lt;&lt; &amp;ref_a_right;</span><br><span class="line">    // 打印这三个左值的地址，都是一样的</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看完后你可能有个问题，std::move会返回一个右值引用<code>int &amp;&amp;</code>，它是左值还是右值呢？ 从表达式<code>int &amp;&amp;ref = std::move(a)</code>来看，右值引用<code>ref</code>指向的必须是右值，所以move返回的<code>int &amp;&amp;</code>是个右值。所以右值引用既可能是左值，又可能是右值吗？ 确实如此：<strong>右值引用既可以是左值也可以是右值，如果有名称则为左值，否则是右值</strong>。</p><p>或者说：<strong>作为函数返回值的 &amp;&amp; 是右值，直接声明出来的 &amp;&amp; 是左值</strong>。 这同样也符合第一章对左值，右值的判定方式：其实引用和普通变量是一样的，<code>int &amp;&amp;ref = std::move(a)</code>和 <code>int a = 5</code>没有什么区别，等号左边就是左值，右边就是右值。</p><p>最后，从上述分析中我们得到如下结论：</p><ol><li> <strong>从性能上讲，左右值引用没有区别，传参使用左右值引用都可以避免拷贝。</strong></li><li> <strong>右值引用可以直接指向右值，也可以通过std::move指向左值；而左值引用只能指向左值(const左值引用也能指向右值)。</strong></li><li> <strong>作为函数形参时，右值引用更灵活。虽然const左值引用也可以做到左右值都接受，但它无法修改，有一定局限性。</strong></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void f(const int&amp; n) &#123;</span><br><span class="line">    n += 1; // 编译失败，const左值引用不能修改指向变量</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void f2(int &amp;&amp; n) &#123;</span><br><span class="line">    n += 1; // ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    f(5);</span><br><span class="line">    f2(5);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="右值引用和std-move的应用场景"><a href="#右值引用和std-move的应用场景" class="headerlink" title="右值引用和std::move的应用场景"></a>右值引用和std::move的应用场景</h3><p>按上文分析，<code>std::move</code>只是类型转换工具，不会对性能有好处；右值引用在作为函数形参时更具灵活性，看上去还是挺鸡肋的。他们有什么实际应用场景吗？</p><h4 id="实现移动语义"><a href="#实现移动语义" class="headerlink" title="实现移动语义"></a>实现移动语义</h4><p>在实际场景中，右值引用和std::move被广泛用于在STL和自定义类中<strong>实现移动语义，避免拷贝，从而提升程序性能</strong>。 在没有右值引用之前，一个简单的数组类通常实现如下，有<code>构造函数</code>、<code>拷贝构造函数</code>、<code>赋值运算符重载</code>、<code>析构函数</code>等。深拷贝/浅拷贝在此不做讲解。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">class Array &#123;</span><br><span class="line">public:</span><br><span class="line">    Array(int size) : size_(size) &#123;</span><br><span class="line">        data = new int[size_];</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    // 深拷贝构造</span><br><span class="line">    Array(const Array&amp; temp_array) &#123;</span><br><span class="line">        size_ = temp_array.size_;</span><br><span class="line">        data_ = new int[size_];</span><br><span class="line">        for (int i = 0; i &lt; size_; i ++) &#123;</span><br><span class="line">            data_[i] = temp_array.data_[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    // 深拷贝赋值</span><br><span class="line">    Array&amp; operator=(const Array&amp; temp_array) &#123;</span><br><span class="line">        delete[] data_;</span><br><span class="line"> </span><br><span class="line">        size_ = temp_array.size_;</span><br><span class="line">        data_ = new int[size_];</span><br><span class="line">        for (int i = 0; i &lt; size_; i ++) &#123;</span><br><span class="line">            data_[i] = temp_array.data_[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ~Array() &#123;</span><br><span class="line">        delete[] data_;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">public:</span><br><span class="line">    int *data_;</span><br><span class="line">    int size_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>该类的拷贝构造函数、赋值运算符重载函数已经通过使用左值引用传参来避免一次多余拷贝了，但是内部实现要深拷贝，无法避免。 这时，有人提出一个想法：是不是可以提供一个<code>移动构造函数</code>，把被拷贝者的数据移动过来，被拷贝者后边就不要了，这样就可以避免深拷贝了，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Array &#123;</span><br><span class="line">public:</span><br><span class="line">    Array(int size) : size_(size) &#123;</span><br><span class="line">        data = new int[size_];</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    // 深拷贝构造</span><br><span class="line">    Array(const Array&amp; temp_array) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    // 深拷贝赋值</span><br><span class="line">    Array&amp; operator=(const Array&amp; temp_array) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // 移动构造函数，可以浅拷贝</span><br><span class="line">    Array(const Array&amp; temp_array, bool move) &#123;</span><br><span class="line">        data_ = temp_array.data_;</span><br><span class="line">        size_ = temp_array.size_;</span><br><span class="line">        // 为防止temp_array析构时delete data，提前置空其data_      </span><br><span class="line">        temp_array.data_ = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">    ~Array() &#123;</span><br><span class="line">        delete [] data_;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">public:</span><br><span class="line">    int *data_;</span><br><span class="line">    int size_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这么做有2个问题：</p><ul><li>  不优雅，表示移动语义还需要一个额外的参数(或者其他方式)。</li><li>  无法实现！<code>temp_array</code>是个const左值引用，无法被修改，所以<code>temp_array.data_ = nullptr;</code>这行会编译不过。当然函数参数可以改成非const：<code>Array(Array&amp; temp_array, bool move)&#123;...&#125;</code>，这样也有问题，由于左值引用不能接右值，<code>Array a = Array(Array(), true);</code>这种调用方式就没法用了。</li></ul><p>可以发现左值引用真是用的很不爽，<strong>右值引用的出现解决了这个问题</strong>，在STL的很多容器中，都实现了以<strong>右值引用为参数</strong>的<code>移动构造函数</code>和<code>移动赋值重载函数</code>，或者其他函数，最常见的如std::vector的<code>push_back</code>和<code>emplace_back</code>。参数为左值引用意味着拷贝，为右值引用意味着移动。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Array &#123;</span><br><span class="line">public:</span><br><span class="line">    ......</span><br><span class="line"> </span><br><span class="line">    // 优雅</span><br><span class="line">    Array(Array&amp;&amp; temp_array) &#123;</span><br><span class="line">        data_ = temp_array.data_;</span><br><span class="line">        size_ = temp_array.size_;</span><br><span class="line">        // 为防止temp_array析构时delete data，提前置空其data_      </span><br><span class="line">        temp_array.data_ = nullptr;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line"> </span><br><span class="line">public:</span><br><span class="line">    int *data_;</span><br><span class="line">    int size_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如何使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 例1：Array用法</span><br><span class="line">int main()&#123;</span><br><span class="line">    Array a;</span><br><span class="line"> </span><br><span class="line">    // 做一些操作</span><br><span class="line">    .....</span><br><span class="line">     </span><br><span class="line">    // 左值a，用std::move转化为右值</span><br><span class="line">    Array b(std::move(a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="实例：vector-push-back使用std-move提高性能"><a href="#实例：vector-push-back使用std-move提高性能" class="headerlink" title="实例：vector::push_back使用std::move提高性能"></a>实例：vector::push_back使用std::move提高性能</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 例2：std::vector和std::string的实际例子</span><br><span class="line">int main() &#123;</span><br><span class="line">    std::string str1 = &quot;aacasxs&quot;;</span><br><span class="line">    std::vector&lt;std::string&gt; vec;</span><br><span class="line">     </span><br><span class="line">    vec.push_back(str1); // 传统方法，copy</span><br><span class="line">    vec.push_back(std::move(str1)); // 调用移动语义的push_back方法，避免拷贝，str1会失去原有值，变成空字符串</span><br><span class="line">    vec.emplace_back(std::move(str1)); // emplace_back效果相同，str1会失去原有值</span><br><span class="line">    vec.emplace_back(&quot;axcsddcas&quot;); // 当然可以直接接右值</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// std::vector方法定义</span><br><span class="line">void push_back (const value_type&amp; val);</span><br><span class="line">void push_back (value_type&amp;&amp; val);</span><br><span class="line"> </span><br><span class="line">void emplace_back (Args&amp;&amp;... args);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在vector和string这个场景，加个<code>std::move</code>会调用到移动语义函数，避免了深拷贝。</p><p>除非设计不允许移动，STL类大都支持移动语义函数，即<code>可移动的</code>。 另外，编译器会<strong>默认</strong>在用户自定义的<code>class</code>和<code>struct</code>中生成移动语义函数，但前提是用户没有主动定义该类的<code>拷贝构造</code>等函数(具体规则自行百度哈)。 <strong>因此，可移动对象在&lt;需要拷贝且被拷贝者之后不再被需要&gt;的场景，建议使用</strong><code>std::move</code><strong>触发移动语义，提升性能。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">moveable_objecta = moveable_objectb; </span><br><span class="line">改为： </span><br><span class="line">moveable_objecta = std::move(moveable_objectb);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还有些STL类是<code>move-only</code>的，比如<code>unique_ptr</code>，这种类只有移动构造函数，因此只能移动(转移内部对象所有权，或者叫浅拷贝)，不能拷贝(深拷贝):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;A&gt; ptr_a = std::make_unique&lt;A&gt;();</span><br><span class="line"></span><br><span class="line">std::unique_ptr&lt;A&gt; ptr_b = std::move(ptr_a); // unique_ptr只有‘移动赋值重载函数‘，参数是&amp;&amp; ，只能接右值，因此必须用std::move转换类型</span><br><span class="line">std::unique_ptr&lt;A&gt; ptr_b = ptr_a; // 编译不通过</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>std::move本身只做类型转换，对性能无影响。</strong> <strong>我们可以在自己的类中实现移动语义，避免深拷贝，充分利用右值引用和std::move的语言特性。</strong></p><h3 id="完美转发-std-forward"><a href="#完美转发-std-forward" class="headerlink" title="完美转发 std::forward"></a>完美转发 std::forward</h3><p>和<code>std::move</code>一样，它的兄弟<code>std::forward</code>也充满了迷惑性，虽然名字含义是转发，但他并不会做转发，同样也是做类型转换.</p><p>与move相比，forward更强大，move只能转出来右值，forward都可以。</p><blockquote><p>std::forward<T>(u)有两个参数：T与 u。 a. 当T为左值引用类型时，u将被转换为T类型的左值； b. 否则u将被转换为T类型右值。  </T></p></blockquote><p>举个例子，有main，A，B三个函数，调用关系为：<code>main-&gt;A-&gt;B</code>，建议先看懂_2.3节对左右值引用本身是左值还是右值的讨论_再看这里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">void B(int&amp;&amp; ref_r) &#123;</span><br><span class="line">    ref_r = 1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// A、B的入参是右值引用</span><br><span class="line">// 有名字的右值引用是左值，因此ref_r是左值</span><br><span class="line">void A(int&amp;&amp; ref_r) &#123;</span><br><span class="line">    B(ref_r);  // 错误，B的入参是右值引用，需要接右值，ref_r是左值，编译失败</span><br><span class="line">     </span><br><span class="line">    B(std::move(ref_r)); // ok，std::move把左值转为右值，编译通过</span><br><span class="line">    B(std::forward&lt;int&gt;(ref_r));  // ok，std::forward的T是int类型，属于条件b，因此会把ref_r转为右值</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main() &#123;</span><br><span class="line">    int a = 5;</span><br><span class="line">    A(std::move(a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>例2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void change2(int&amp;&amp; ref_r) &#123;</span><br><span class="line">    ref_r = 1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void change3(int&amp; ref_l) &#123;</span><br><span class="line">    ref_l = 1;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// change的入参是右值引用</span><br><span class="line">// 有名字的右值引用是 左值，因此ref_r是左值</span><br><span class="line">void change(int&amp;&amp; ref_r) &#123;</span><br><span class="line">    change2(ref_r);  // 错误，change2的入参是右值引用，需要接右值，ref_r是左值，编译失败</span><br><span class="line">     </span><br><span class="line">    change2(std::move(ref_r)); // ok，std::move把左值转为右值，编译通过</span><br><span class="line">    change2(std::forward&lt;int &amp;&amp;&gt;(ref_r));  // ok，std::forward的T是右值引用类型(int &amp;&amp;)，符合条件b，因此u(ref_r)会被转换为右值，编译通过</span><br><span class="line">     </span><br><span class="line">    change3(ref_r); // ok，change3的入参是左值引用，需要接左值，ref_r是左值，编译通过</span><br><span class="line">    change3(std::forward&lt;int &amp;&gt;(ref_r)); // ok，std::forward的T是左值引用类型(int &amp;)，符合条件a，因此u(ref_r)会被转换为左值，编译通过</span><br><span class="line">    // 可见，forward可以把值转换为左值或者右值</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main() &#123;</span><br><span class="line">    int a = 5;</span><br><span class="line">    change(std::move(a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上边的示例在日常编程中基本不会用到，<code>std::forward</code>最主要运于模版编程的参数转发中，想深入了解需要学习<code>万能引用(T &amp;&amp;)</code>和<code>引用折叠(eg:&amp; &amp;&amp; → ?)</code>等知识，本文就不详细介绍这些了。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;什么是左值、右值&quot;&gt;&lt;a href=&quot;#什么是左值、右值&quot; class=&quot;headerlink&quot; title=&quot;什么是左值、右值&quot;&gt;&lt;/a&gt;什么是左值、右值&lt;/h3&gt;&lt;p&gt;首先不考虑引用以减少干扰，可以从2个角度判断：左值&lt;strong&gt;可以取地址、位于等号左边&lt;/strong&gt;；而右值&lt;strong&gt;没法取地址，位于等号右边&lt;/strong&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;int a = 5;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;  a可以通过 &amp;amp; 取地址，位于等号左边，所以a是左值。&lt;/li&gt;
&lt;li&gt;  5位于等号右边，5没法通过 &amp;amp; 取地址，所以5是个右值。&lt;/li&gt;&lt;/ul&gt;</summary>
    
    
    
    <category term="C/C++" scheme="https://rma-shuyu.github.io/categories/C-C/"/>
    
    
    <category term="C/C++" scheme="https://rma-shuyu.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>libvirt with dpdk-vdpa</title>
    <link href="https://rma-shuyu.github.io/2023/03/14/libvirt-with-dpdk-vdpa/"/>
    <id>https://rma-shuyu.github.io/2023/03/14/libvirt-with-dpdk-vdpa/</id>
    <published>2023-03-14T02:05:30.000Z</published>
    <updated>2024-06-22T07:34:15.373Z</updated>
    
    <content type="html"><![CDATA[<h2 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OS                               : CentOS Linux release 8.4.2105</span><br><span class="line">Kernel                           : 4.18.0-305.30.1.el8.x86_64</span><br><span class="line">qemu                             : 6.2.0</span><br><span class="line">dpdk                             : 22.11.1 </span><br><span class="line">libvirt                          : 8.0.0</span><br><span class="line">设备类型                         :  net</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="dpdk-vdpa启动"><a href="#dpdk-vdpa启动" class="headerlink" title="dpdk-vdpa启动"></a>dpdk-vdpa启动</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./dpdk-vdpa -c 0x2 -n 4 --socket-mem 1024,1024 \</span><br><span class="line">            -a 0000:cc:00.1,vdpa=1  -a 0000:cc:00.2,vdpa=1  \</span><br><span class="line">                -- --iface /tmp/vdpa-socket</span><br></pre></td></tr></table></figure><h2 id="libvirt-xml配置"><a href="#libvirt-xml配置" class="headerlink" title="libvirt xml配置"></a>libvirt xml配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">domain</span> <span class="attr">type</span>=<span class="string">&quot;kvm&quot;</span> <span class="attr">xmlns:qemu</span>=<span class="string">&#x27;http://libvirt.org/schemas/domain/qemu/1.0&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>vm0<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uuid</span>&gt;</span>d37f5411-b296-11ed-8e6c-0c48c6c879e4<span class="tag">&lt;/<span class="name">uuid</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">memory</span> <span class="attr">unit</span>=<span class="string">&quot;KiB&quot;</span>&gt;</span>2097152<span class="tag">&lt;/<span class="name">memory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">memoryBacking</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hugepages</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">page</span> <span class="attr">size</span>=<span class="string">&quot;2&quot;</span> <span class="attr">unit</span>=<span class="string">&quot;M&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hugepages</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nosharepages</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">locked</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">source</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">access</span> <span class="attr">mode</span>=<span class="string">&quot;shared&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">discard</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">memoryBacking</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">vcpu</span> <span class="attr">placement</span>=<span class="string">&quot;static&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">vcpu</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">os</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">type</span> <span class="attr">arch</span>=<span class="string">&quot;x86_64&quot;</span> <span class="attr">machine</span>=<span class="string">&quot;pc-i440fx-2.1&quot;</span>&gt;</span>hvm<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">os</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cpu</span> <span class="attr">mode</span>=<span class="string">&#x27;custom&#x27;</span> <span class="attr">match</span>=<span class="string">&#x27;exact&#x27;</span> <span class="attr">check</span>=<span class="string">&#x27;full&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">model</span> <span class="attr">fallback</span>=<span class="string">&#x27;forbid&#x27;</span>&gt;</span>kvm64<span class="tag">&lt;/<span class="name">model</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">feature</span> <span class="attr">policy</span>=<span class="string">&#x27;require&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;x2apic&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">feature</span> <span class="attr">policy</span>=<span class="string">&#x27;require&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;hypervisor&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">cpu</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">features</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">acpi</span>&gt;</span><span class="tag">&lt;/<span class="name">acpi</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">features</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">clock</span> <span class="attr">offset</span>=<span class="string">&quot;utc&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">clock</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">on_poweroff</span>&gt;</span>destroy<span class="tag">&lt;/<span class="name">on_poweroff</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">on_reboot</span>&gt;</span>restart<span class="tag">&lt;/<span class="name">on_reboot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">on_crash</span>&gt;</span>destroy<span class="tag">&lt;/<span class="name">on_crash</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">devices</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">emulator</span>&gt;</span>/root/pc-bios/qemu-system-x86_64<span class="tag">&lt;/<span class="name">emulator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">disk</span> <span class="attr">device</span>=<span class="string">&quot;disk&quot;</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">bus</span>=<span class="string">&quot;ide&quot;</span> <span class="attr">dev</span>=<span class="string">&quot;hda&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">source</span> <span class="attr">file</span>=<span class="string">&quot;/mnt/store/vm0-centos8.4-8g-ext4-host-dmar.img&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">disk</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">interface</span> <span class="attr">type</span>=<span class="string">&#x27;vhostuser&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mac</span> <span class="attr">address</span>=<span class="string">&#x27;00:aa:bb:cc:dd:ee&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">source</span> <span class="attr">type</span>=<span class="string">&#x27;unix&#x27;</span> <span class="attr">path</span>=<span class="string">&#x27;/tmp/vdpa-socket0&#x27;</span> <span class="attr">mode</span>=<span class="string">&#x27;client&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">model</span> <span class="attr">type</span>=<span class="string">&#x27;virtio&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">driver</span> <span class="attr">queues</span>=<span class="string">&#x27;4&#x27;</span> <span class="attr">rx_queue_size</span>=<span class="string">&#x27;512&#x27;</span> <span class="attr">tx_queue_size</span>=<span class="string">&#x27;512&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">serial</span> <span class="attr">type</span>=<span class="string">&quot;tcp&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">source</span> <span class="attr">mode</span>=<span class="string">&quot;bind&quot;</span> <span class="attr">host</span>=<span class="string">&quot;127.0.0.1&quot;</span> <span class="attr">service</span>=<span class="string">&quot;4321&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">protocol</span> <span class="attr">type</span>=<span class="string">&quot;telnet&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span> <span class="attr">port</span>=<span class="string">&quot;1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">serial</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">graphics</span> <span class="attr">type</span>=<span class="string">&#x27;vnc&#x27;</span> <span class="attr">port</span>=<span class="string">&#x27;5901&#x27;</span> <span class="attr">listen</span>=<span class="string">&#x27;0.0.0.0&#x27;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listen</span> <span class="attr">type</span>=<span class="string">&#x27;address&#x27;</span> <span class="attr">address</span>=<span class="string">&#x27;0.0.0.0&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">graphics</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">devices</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">qemu:commandline</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">qemu:arg</span> <span class="attr">value</span>=<span class="string">&#x27;-L&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">qemu:arg</span> <span class="attr">value</span>=<span class="string">&#x27;/root/pc-bios&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">qemu:commandline</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="验证结果"><a href="#验证结果" class="headerlink" title="验证结果"></a>验证结果</h2><p>1、查看libvirt是否正常拉起vm</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># virsh -c qemu+tcp:///system create vm.xml</span></span><br><span class="line">Domain <span class="string">&#x27;vm0&#x27;</span> created from vm.xml</span><br><span class="line"></span><br><span class="line"><span class="comment"># virsh list</span></span><br><span class="line"> Id   Name   State</span><br><span class="line">----------------------</span><br><span class="line"> 29   vm0    running</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2、ping测试<br><img src="03e2f3d08b21dc6b24565608fdd47abc9cbe6acb6bd8286f651bb44728647ad3.png" alt="图 2">  </p><h2 id="调试问题"><a href="#调试问题" class="headerlink" title="调试问题"></a>调试问题</h2><p>使用libvirt拉起vm时，ping failed<br><img src="3d9fe6c5801dcd971f82c9826d8fd9e596c0c1edd45cd42b49d299b31abe463e.png" alt="图 1">  </p><h3 id="定位过程"><a href="#定位过程" class="headerlink" title="定位过程"></a>定位过程</h3><p>1、查看/var/log/libvirt/qemu/vm0.log日志，发现存在错误日志打印，可以看到qemu启动参数需要指定<code>memory-backend-file</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2023-06-14T01:53:51.897860Z qemu-system-x86_64: Failed initializing vhost-user memory map, consider using -object memory-backend-file share=on</span><br><span class="line">2023-06-14T01:53:51.897958Z qemu-system-x86_64: vhost_set_mem_table failed: Input/output error (5)</span><br><span class="line">2023-06-14T01:53:51.912732Z qemu-system-x86_64: unable to start vhost net: 5: falling back on userspace virtio</span><br><span class="line">2023-06-14T01:53:51.949246Z qemu-system-x86_64: Failed initializing vhost-user memory map, consider using -object memory-backend-file share=on</span><br><span class="line">2023-06-14T01:53:51.949266Z qemu-system-x86_64: vhost_set_mem_table failed: Resource temporarily unavailable (11)</span><br><span class="line">2023-06-14T01:53:51.963736Z qemu-system-x86_64: unable to start vhost net: 11: falling back on userspace virtio</span><br></pre></td></tr></table></figure><p>2、查看qemu启动进程参数，发现qemu参数指定的是<code>memory-backend-ram</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root        6394       1 50 08:23 ?        00:00:47 /root/pc-bios/qemu-system-x86_64 -name guest=vm0,debug-threads=on -S -object &#123;<span class="string">&quot;qom-type&quot;</span>:<span class="string">&quot;secret&quot;</span>,<span class="string">&quot;id&quot;</span>:<span class="string">&quot;masterKey0&quot;</span>,<span class="string">&quot;format&quot;</span>:<span class="string">&quot;raw&quot;</span>,<span class="string">&quot;file&quot;</span>:<span class="string">&quot;/var/lib/libvirt/qemu/domain-10-vm0/master-key.aes&quot;</span>&#125; -machine pc-i440fx-2.1,usb=off,dump-guest-core=off,memory-backend=pc.ram -accel kvm -cpu kvm64,x2apic=on,hypervisor=on -m 2048 -object &#123;<span class="string">&quot;qom-type&quot;</span>:<span class="string">&quot;memory-backend-ram&quot;</span>,<span class="string">&quot;id&quot;</span>:<span class="string">&quot;pc.ram&quot;</span>,<span class="string">&quot;size&quot;</span>:2147483648&#125; -overcommit mem-lock=off -smp 2,sockets=2,cores=1,threads=1 -uuid d37f5411-b296-11ed-8e6c-0c48c6c879e4 -no-user-config -nodefaults -chardev socket,<span class="built_in">id</span>=charmonitor,fd=38,server=on,<span class="built_in">wait</span>=off -mon chardev=charmonitor,<span class="built_in">id</span>=monitor,mode=control -rtc base=utc -no-shutdown -boot strict=on -device piix3-usb-uhci,<span class="built_in">id</span>=usb,bus=pci.0,addr=0x1.0x2 -blockdev &#123;<span class="string">&quot;driver&quot;</span>:<span class="string">&quot;file&quot;</span>,<span class="string">&quot;filename&quot;</span>:<span class="string">&quot;/mnt/store/vm0-centos8.4-8g-ext4-host-dmar.img&quot;</span>,<span class="string">&quot;node-name&quot;</span>:<span class="string">&quot;libvirt-1-storage&quot;</span>,<span class="string">&quot;auto-read-only&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;discard&quot;</span>:<span class="string">&quot;unmap&quot;</span>&#125; -blockdev &#123;<span class="string">&quot;node-name&quot;</span>:<span class="string">&quot;libvirt-1-format&quot;</span>,<span class="string">&quot;read-only&quot;</span>:<span class="literal">false</span>,<span class="string">&quot;driver&quot;</span>:<span class="string">&quot;raw&quot;</span>,<span class="string">&quot;file&quot;</span>:<span class="string">&quot;libvirt-1-storage&quot;</span>&#125; -device ide-hd,bus=ide.0,unit=0,drive=libvirt-1-format,<span class="built_in">id</span>=ide0-0-0,bootindex=1 -chardev socket,<span class="built_in">id</span>=charnet0,path=/tmp/vdpa-socket0 -netdev vhost-user,chardev=charnet0,queues=4,<span class="built_in">id</span>=hostnet0 -device virtio-net-pci,mq=on,vectors=10,rx_queue_size=512,tx_queue_size=512,netdev=hostnet0,<span class="built_in">id</span>=net0,mac=00:aa:bb:cc:<span class="built_in">dd</span>:ee,bus=pci.0,addr=0x3 -chardev socket,<span class="built_in">id</span>=charserial0,host=127.0.0.1,port=4321,telnet=on,server=on,<span class="built_in">wait</span>=off -device isa-serial,chardev=charserial0,<span class="built_in">id</span>=serial0 -audiodev &#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;audio1&quot;</span>,<span class="string">&quot;driver&quot;</span>:<span class="string">&quot;none&quot;</span>&#125; -vnc 0.0.0.0:0,audiodev=audio1 -device cirrus-vga,<span class="built_in">id</span>=video0,bus=pci.0,addr=0x2 -device virtio-balloon-pci,<span class="built_in">id</span>=balloon0,bus=pci.0,addr=0x4 -L /root/pc-bios -msg timestamp=on</span><br></pre></td></tr></table></figure><h3 id="根因分析"><a href="#根因分析" class="headerlink" title="根因分析"></a>根因分析</h3><p>qemu进程在ram_block初始化的时候根据memory-backend-xxx，其中xxx可以指定file、memfd、ram，<br>从而指定不同的内存申请方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">host_memory_backend_memory_complete(UserCreatable *uc, Error **errp)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span> (bc-&gt;alloc) &#123;</span><br><span class="line">        bc-&gt;alloc(backend, &amp;local_err);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当指定memory-backend-file<br>则bc-&gt;alloc = file_backend_memory_alloc</p><p>当指定memory-backend-ram<br>则bc-&gt;alloc = ram_backend_memory_alloc;</p><p>这两个主要的区别在于申请ram_block时，file_backend_memory_alloc会额外申请一个fd，用于前后端进程共享内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RAMBlock *<span class="title function_">qemu_ram_alloc_from_file</span><span class="params">(<span class="type">ram_addr_t</span> size, MemoryRegion *mr,</span></span><br><span class="line"><span class="params">                                   <span class="type">uint32_t</span> ram_flags, <span class="type">const</span> <span class="type">char</span> *mem_path,</span></span><br><span class="line"><span class="params">                                   <span class="type">bool</span> readonly, Error **errp)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    fd = file_ram_open(mem_path, memory_region_name(mr), readonly, &amp;created,</span><br><span class="line">                       errp);</span><br><span class="line">...</span><br><span class="line">    block = qemu_ram_alloc_from_fd(size, mr, ram_flags, fd, <span class="number">0</span>, readonly, errp);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MemoryRegion通过vhost-user VHOST_USER_SET_MEM_TABLE消息传递到dpdk-vdpa进程<br>如果不指定memory-backend-file，VHOST_USER_SET_MEM_TABLE消息失败，在vhost_dev_start中返回失败，不会走后续设备启动流程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vhost_dev_start</span><span class="params">(<span class="keyword">struct</span> vhost_dev *hdev, VirtIODevice *vdev)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    r = hdev-&gt;vhost_ops-&gt;vhost_set_mem_table(hdev, hdev-&gt;mem);</span><br><span class="line">    <span class="keyword">if</span> (r &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        VHOST_OPS_DEBUG(<span class="string">&quot;vhost_set_mem_table failed&quot;</span>);</span><br><span class="line">        r = -errno;</span><br><span class="line">        <span class="keyword">goto</span> fail_mem;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">     r = hdev-&gt;vhost_ops-&gt;vhost_dev_start(hdev, <span class="literal">true</span>);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题修复"><a href="#问题修复" class="headerlink" title="问题修复"></a>问题修复</h3><p>libvirt xml指定memoryBacking类型为file</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">domain</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;<span class="name">memoryBacking</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hugepages</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">page</span> <span class="attr">size</span>=<span class="string">&quot;2&quot;</span> <span class="attr">unit</span>=<span class="string">&quot;M&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hugepages</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nosharepages</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">locked</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">source</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">access</span> <span class="attr">mode</span>=<span class="string">&quot;shared&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">discard</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">memoryBacking</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">domain</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此时再次启动vm，可以发现此时qemu进程启动参数为<code>memory-backend-file</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root       17715       1 75 23:02 ?        00:00:47 /root/pc-bios/qemu-system-x86_64 -name guest=vm0,debug-threads=on -S -object &#123;<span class="string">&quot;qom-type&quot;</span>:<span class="string">&quot;secret&quot;</span>,<span class="string">&quot;id&quot;</span>:<span class="string">&quot;masterKey0&quot;</span>,<span class="string">&quot;format&quot;</span>:<span class="string">&quot;raw&quot;</span>,<span class="string">&quot;file&quot;</span>:<span class="string">&quot;/var/lib/libvirt/qemu/domain-3-vm0/master-key.aes&quot;</span>&#125; -machine pc-i440fx-2.1,usb=off,dump-guest-core=off,mem-merge=off,memory-backend=pc.ram -accel kvm -cpu kvm64,x2apic=on,hypervisor=on -m 2048 -object &#123;<span class="string">&quot;qom-type&quot;</span>:<span class="string">&quot;memory-backend-file&quot;</span>,<span class="string">&quot;id&quot;</span>:<span class="string">&quot;pc.ram&quot;</span>,<span class="string">&quot;mem-path&quot;</span>:<span class="string">&quot;/dev/hugepages/libvirt/qemu/3-vm0&quot;</span>,<span class="string">&quot;discard-data&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;share&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;x-use-canonical-path-for-ramblock-id&quot;</span>:<span class="literal">false</span>,<span class="string">&quot;prealloc&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;size&quot;</span>:2147483648&#125; -overcommit mem-lock=on -smp 2,sockets=2,cores=1,threads=1 -uuid d37f5411-b296-11ed-8e6c-0c48c6c879e4 -no-user-config -nodefaults -chardev socket,<span class="built_in">id</span>=charmonitor,fd=39,server=on,<span class="built_in">wait</span>=off -mon chardev=charmonitor,<span class="built_in">id</span>=monitor,mode=control -rtc base=utc -no-shutdown -boot strict=on -device piix3-usb-uhci,<span class="built_in">id</span>=usb,bus=pci.0,addr=0x1.0x2 -blockdev &#123;<span class="string">&quot;driver&quot;</span>:<span class="string">&quot;file&quot;</span>,<span class="string">&quot;filename&quot;</span>:<span class="string">&quot;/mnt/store/vm0-centos8.4-8g-ext4-host-dmar.img&quot;</span>,<span class="string">&quot;node-name&quot;</span>:<span class="string">&quot;libvirt-1-storage&quot;</span>,<span class="string">&quot;auto-read-only&quot;</span>:<span class="literal">true</span>,<span class="string">&quot;discard&quot;</span>:<span class="string">&quot;unmap&quot;</span>&#125; -blockdev &#123;<span class="string">&quot;node-name&quot;</span>:<span class="string">&quot;libvirt-1-format&quot;</span>,<span class="string">&quot;read-only&quot;</span>:<span class="literal">false</span>,<span class="string">&quot;driver&quot;</span>:<span class="string">&quot;raw&quot;</span>,<span class="string">&quot;file&quot;</span>:<span class="string">&quot;libvirt-1-storage&quot;</span>&#125; -device ide-hd,bus=ide.0,unit=0,drive=libvirt-1-format,<span class="built_in">id</span>=ide0-0-0,bootindex=1 -chardev socket,<span class="built_in">id</span>=charnet0,path=/tmp/vdpa-socket0 -netdev vhost-user,chardev=charnet0,queues=4,<span class="built_in">id</span>=hostnet0 -device virtio-net-pci,mq=on,vectors=10,rx_queue_size=512,tx_queue_size=512,netdev=hostnet0,<span class="built_in">id</span>=net0,mac=00:aa:bb:cc:<span class="built_in">dd</span>:ee,bus=pci.0,addr=0x3 -chardev socket,<span class="built_in">id</span>=charserial0,host=127.0.0.1,port=4321,telnet=on,server=on,<span class="built_in">wait</span>=off -device isa-serial,chardev=charserial0,<span class="built_in">id</span>=serial0 -audiodev &#123;<span class="string">&quot;id&quot;</span>:<span class="string">&quot;audio1&quot;</span>,<span class="string">&quot;driver&quot;</span>:<span class="string">&quot;none&quot;</span>&#125; -vnc 0.0.0.0:0,audiodev=audio1 -device cirrus-vga,<span class="built_in">id</span>=video0,bus=pci.0,addr=0x2 -device virtio-balloon-pci,<span class="built_in">id</span>=balloon0,bus=pci.0,addr=0x4 -L /root/pc-bios -msg timestamp=on</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;环境信息&quot;&gt;&lt;a href=&quot;#环境信息&quot; class=&quot;headerlink&quot; title=&quot;环境信息&quot;&gt;&lt;/a&gt;环境信息&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;OS                               : CentOS Linux release 8.4.2105&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Kernel                           : 4.18.0-305.30.1.el8.x86_64&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;qemu                             : 6.2.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dpdk                             : 22.11.1 &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;libvirt                          : 8.0.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;设备类型                         :  net&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="虚拟化" scheme="https://rma-shuyu.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="Libvirt" scheme="https://rma-shuyu.github.io/tags/Libvirt/"/>
    
  </entry>
  
  <entry>
    <title>protobuf使用</title>
    <link href="https://rma-shuyu.github.io/2023/03/08/protobuf%E4%BD%BF%E7%94%A8/"/>
    <id>https://rma-shuyu.github.io/2023/03/08/protobuf%E4%BD%BF%E7%94%A8/</id>
    <published>2023-03-08T12:50:20.000Z</published>
    <updated>2024-06-22T07:34:15.388Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Protobuf安装"><a href="#Protobuf安装" class="headerlink" title="Protobuf安装"></a>Protobuf安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apt install protobuf-compiler protobuf-c-compiler libprotobuf-dev libprotobuf-c-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># check</span></span><br><span class="line">protoc --version</span><br><span class="line"><span class="built_in">which</span> protoc-c</span><br><span class="line">find / -name <span class="string">&quot;libprotobuf-c.so&quot;</span></span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="Protobuf使用说明"><a href="#Protobuf使用说明" class="headerlink" title="Protobuf使用说明"></a>Protobuf使用说明</h2><h3 id="proto定义"><a href="#proto定义" class="headerlink" title="proto定义"></a>proto定义</h3><p>一个简单的amessage.proto文件如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto2&quot;;</span><br><span class="line"></span><br><span class="line">message  AMessage</span><br><span class="line">&#123;</span><br><span class="line">    required int32 a=1; </span><br><span class="line">    optional int32 b=2; </span><br><span class="line">    </span><br><span class="line">     oneof test_oneof &#123;    </span><br><span class="line">         string c=3;    </span><br><span class="line">         int32  d=4;    </span><br><span class="line">     &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用如下命令在当前目录下生成protobuf的.c文件和.h文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc-c --c_out=. amessage.proto</span><br></pre></td></tr></table></figure><h3 id="序列化代码"><a href="#序列化代码" class="headerlink" title="序列化代码"></a>序列化代码</h3><p>序列化AMessage的代码amessage_serialize.c如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &quot;amessage.pb-c.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">AMessage msg = AMESSAGE__INIT; // AMessage</span><br><span class="line">void *buf; // Buffer to store serialized data</span><br><span class="line">unsigned len; // Length of serialized data</span><br><span class="line">char *word = &quot;hello world!&quot;;</span><br><span class="line"></span><br><span class="line">if (argc != 2 &amp;&amp; argc != 3 &amp;&amp; argc != 4) &#123; // Allow one or two integers</span><br><span class="line">fprintf(stderr, &quot;usage: amessage a [b] [c]\n&quot;);</span><br><span class="line">return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msg.a = atoi(argv[1]);</span><br><span class="line">if (argc &gt;= 3) &#123;</span><br><span class="line">msg.has_b = 1;</span><br><span class="line">msg.b = atoi(argv[2]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (argc &gt;= 4) &#123;</span><br><span class="line">msg.d = atoi(argv[3]);</span><br><span class="line">msg.test_oneof_case = AMESSAGE__TEST_ONEOF_D;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">msg.c = word;</span><br><span class="line">msg.test_oneof_case = AMESSAGE__TEST_ONEOF_C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">len = amessage__get_packed_size(&amp;msg);</span><br><span class="line"></span><br><span class="line">buf = malloc(len);</span><br><span class="line">amessage__pack(&amp;msg, buf);</span><br><span class="line"></span><br><span class="line">fprintf(stderr, &quot;Writing %d serialized bytes\n&quot;,</span><br><span class="line">len); // See the length of message</span><br><span class="line">fwrite(buf, len, 1,</span><br><span class="line">       stdout); // Write to stdout to allow direct command line piping</span><br><span class="line"></span><br><span class="line">free(buf); // Free the allocated serialized buffer</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意事项：</p><blockquote><p>使用A_MESSAGE__INIT宏来初始化消息结构体</p></blockquote><blockquote><p>成员has_b表示可选成员b是否存在</p></blockquote><blockquote><p>成员test_oneof_case指示oneof使用的成员是哪一个</p></blockquote><blockquote><p>AMESSAGE__TEST_ONEOF_C宏表示oneof使用的成员是c</p></blockquote><blockquote><p>amessage__get_packed_size函数返回序列化后消息的长度</p></blockquote><blockquote><p>amessage__pack函数序列化消息</p></blockquote><h3 id="反序列化代码"><a href="#反序列化代码" class="headerlink" title="反序列化代码"></a>反序列化代码</h3><p>反序列化消息的代码amessage_deserialize.c如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &quot;amessage.pb-c.h&quot;</span><br><span class="line">#define MAX_MSG_SIZE 1024</span><br><span class="line"></span><br><span class="line">static size_t read_buffer(unsigned max_length, uint8_t *out)</span><br><span class="line">&#123;</span><br><span class="line">size_t cur_len = 0;</span><br><span class="line">size_t nread;</span><br><span class="line">while ((nread = fread(out + cur_len, 1, max_length - cur_len, stdin)) !=</span><br><span class="line">       0) &#123;</span><br><span class="line">cur_len += nread;</span><br><span class="line">if (cur_len == max_length) &#123;</span><br><span class="line">fprintf(stderr, &quot;max message length exceeded\n&quot;);</span><br><span class="line">exit(1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return cur_len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">AMessage *msg;</span><br><span class="line"></span><br><span class="line">// Read packed message from standard-input.</span><br><span class="line">uint8_t buf[MAX_MSG_SIZE];</span><br><span class="line">size_t msg_len = read_buffer(MAX_MSG_SIZE, buf);</span><br><span class="line"></span><br><span class="line">// Unpack the message using protobuf-c.</span><br><span class="line">msg = amessage__unpack(NULL, msg_len, buf);</span><br><span class="line">if (msg == NULL) &#123;</span><br><span class="line">fprintf(stderr, &quot;error unpacking incoming message\n&quot;);</span><br><span class="line">exit(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// display the message&#x27;s fields.</span><br><span class="line">printf(&quot;Received: a=%d&quot;, msg-&gt;a); // required field</span><br><span class="line">if (msg-&gt;has_b) // handle optional field</span><br><span class="line">printf(&quot;  b=%d&quot;, msg-&gt;b);</span><br><span class="line">if (msg-&gt;test_oneof_case == AMESSAGE__TEST_ONEOF_C)</span><br><span class="line">printf(&quot;  c=%s&quot;, msg-&gt;c);</span><br><span class="line">else if (msg-&gt;test_oneof_case == AMESSAGE__TEST_ONEOF_D)</span><br><span class="line">printf(&quot;  d=%d&quot;, msg-&gt;d);</span><br><span class="line"></span><br><span class="line">printf(&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">// Free the unpacked message</span><br><span class="line">amessage__free_unpacked(msg, NULL);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Makefile文件"><a href="#Makefile文件" class="headerlink" title="Makefile文件"></a>Makefile文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">all:</span><br><span class="line">protoc-c --c_out=. amessage.proto</span><br><span class="line">gcc amessage_serialize.c amessage.pb-c.c -o amessage_serialize -lprotobuf-c</span><br><span class="line">gcc amessage_deserialize.c amessage.pb-c.c -o amessage_deserialize -lprotobuf-c</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">rm -f *.pb-c.c *.pb-c.h amessage_serialize amessage_deserialize</span><br></pre></td></tr></table></figure><h3 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./amessage_serialize 10 2 | ./amessage_deserialize</span><br><span class="line"></span><br><span class="line">Writing 18 serialized bytes</span><br><span class="line">Received: a=10  b=2  c=hello world!</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Protobuf安装&quot;&gt;&lt;a href=&quot;#Protobuf安装&quot; class=&quot;headerlink&quot; title=&quot;Protobuf安装&quot;&gt;&lt;/a&gt;Protobuf安装&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;apt install protobuf-compiler protobuf-c-compiler libprotobuf-dev libprotobuf-c-dev&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# check&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;protoc --version&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;which&lt;/span&gt; protoc-c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;find / -name &lt;span class=&quot;string&quot;&gt;&amp;quot;libprotobuf-c.so&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="GRPC" scheme="https://rma-shuyu.github.io/categories/GRPC/"/>
    
    
    <category term="protobuf" scheme="https://rma-shuyu.github.io/tags/protobuf/"/>
    
  </entry>
  
  <entry>
    <title>proto2语法指引</title>
    <link href="https://rma-shuyu.github.io/2023/03/07/proto2%E8%AF%AD%E6%B3%95/"/>
    <id>https://rma-shuyu.github.io/2023/03/07/proto2%E8%AF%AD%E6%B3%95/</id>
    <published>2023-03-07T12:50:20.000Z</published>
    <updated>2024-06-22T07:34:15.388Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本指南介绍如何使用 protocol buffer 语言来构造 protocol buffer 数据，包括 <code>.proto</code> 文件语法以及如何从 <code>.proto</code> 文件生成数据访问类。它涵盖了 protocol buffer 语言的 <strong>proto2</strong> 版本。</p></blockquote><span id="more"></span><h2 id="定义一个-Message-类型"><a href="#定义一个-Message-类型" class="headerlink" title="定义一个 Message 类型"></a>定义一个 Message 类型</h2><p>首先让我们看一个非常简单的例子。假设你要定义一个搜索请求的 message 格式，其中每个搜索请求都有一个查询字符串，你感兴趣的特定结果页数（第几页）以及每页的结果数。下面就是定义这个请求的 .proto 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">message SearchRequest &#123;</span><br><span class="line">  required string query = 1;  // 查询字符串</span><br><span class="line">  optional int32 page_number = 2;  // 第几页</span><br><span class="line">  optional int32 result_per_page = 3;  // 每页的结果数</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>SearchRequest message 定义指定了三个字段（名称/值对），每个字段对应着要包含在 message 中的数据，每个字段都有一个名称和类型。</p><h3 id="指定字段类型"><a href="#指定字段类型" class="headerlink" title="指定字段类型"></a>指定字段类型</h3><p>在上面的示例中，所有字段都是 <a href="https://developers.google.com/protocol-buffers/docs/proto#scalar">标量类型</a>：两个整数（<code>page_number</code> 和 <code>result_per_page</code>）和一个字符串（<code>query</code>）。但是，你还可以为字段指定复合类型，包括 <a href="https://developers.google.com/protocol-buffers/docs/proto#enum">枚举</a> 和其它的 message 类型。</p><h3 id="分配字段编号"><a href="#分配字段编号" class="headerlink" title="分配字段编号"></a>分配字段编号</h3><p>如你所见，message 定义中的每个字段都有<strong>唯一编号</strong>。这些数字以 <a href="https://www.jianshu.com/p/82ff31c6adc6">message 二进制格式</a> 标识你的字段，并且一旦你的 message 被使用，这些编号就无法再更改。请注意，1 到 15 范围内的字段编号需要一个字节进行编码，编码结果将同时包含编号和类型（你可以在 <a href="https://www.jianshu.com/p/82ff31c6adc6">Protocol Buffer 编码</a> 中找到更多相关信息）。16 到 2047 范围内的字段编号占用两个字节。因此，你应该为非常频繁出现的 message 元素保留字段编号 1 到 15。请记住为将来可能添加的常用元素预留出一些空间。</p><p>你可以指定的最小字段数为 1，最大字段数为 229 - 1 或 536,870,911。你也不能使用 19000 到 19999 范围内的数字（<code>FieldDescriptor::kFirstReservedNumber</code> 到 <code>FieldDescriptor::kLastReservedNumber</code>），因为它们是为 Protocol Buffers 的实现保留的 - 如果你使用这些保留数字之一，protocol buffer 编译器会抱怨你的 <code>.proto</code>。同样，你也不能使用任何以前定义的 <a href="https://developers.google.com/protocol-buffers/docs/proto#reserved">保留</a> 字段编号。</p><blockquote><p>译者注：<br>“不能使用任何以前定义的保留字段编号” 指的是使用 reserved 关键字声明的保留字段。</p></blockquote><h3 id="指定字段规则"><a href="#指定字段规则" class="headerlink" title="指定字段规则"></a>指定字段规则</h3><p>你指定的 message 字段可以是下面几种情况之一：</p><ul><li>  <strong>required</strong>: 格式良好的 message 必须包含该字段一次。</li><li>  <strong>optional</strong>: 格式良好的 message 可以包含该字段零次或一次（不超过一次）。</li><li>  <strong>repeated</strong>: 该字段可以在格式良好的消息中重复任意多次（包括零）。其中重复值的顺序会被保留。</li></ul><p>由于一些历史原因，标量数字类型的 repeated 字段不能尽可能高效地编码。新代码应使用特殊选项 [packed = true] 来获得更高效的编码。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">repeated int32 samples = 4 [packed=true];</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>对 required 的使用永远都应该非常小心。如果你希望在某个时刻停止写入或发送 required 字段，则将字段更改为可选字段将会有问题 - 旧读者会认为没有此字段的邮件不完整，可能会无意中拒绝或删除它们。你应该考虑为 buffers 编写特定于应用程序的自定义验证的例程。谷歌的一些工程师得出的结论是，使用 required 弊大于利；他们更喜欢只使用 optional 和 repeated。但是，这种观点并未普及。</p></blockquote><blockquote><p>译者注：在 proto3 中已经为兼容性彻底抛弃 required。</p></blockquote><h3 id="添加更多-message-类型"><a href="#添加更多-message-类型" class="headerlink" title="添加更多 message 类型"></a>添加更多 message 类型</h3><p>可以在单个 .proto 文件中定义多种 message 类型。这在你需要定义多个相关 message 的时候会很有用 - 例如，如果要定义与搜索请求相应的搜索回复 message - SearchResponse message，则可以将其添加到相同的 .proto：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">message SearchRequest &#123;</span><br><span class="line">  required string query = 1;</span><br><span class="line">  optional int32 page_number = 2;</span><br><span class="line">  optional int32 result_per_page = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message SearchResponse &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>组合 messages 会导致膨胀虽然可以在单个 .proto 文件中定义多种 messages 类型（例如 message，enum 和 service），但是当在单个文件中定义了大量具有不同依赖关系的 messages 时，它也会导致依赖性膨胀。建议每个 .proto 文件包含尽可能少的 message 类型。</p></blockquote><h3 id="添加注释"><a href="#添加注释" class="headerlink" title="添加注释"></a>添加注释</h3><p>为你的 .proto 文件添加注释，可以使用 C/C++ 语法风格的注释 // 和 /* … */ 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/* SearchRequest represents a search query, with pagination options to</span><br><span class="line"> * indicate which results to include in the response. */</span><br><span class="line"></span><br><span class="line">message SearchRequest &#123;</span><br><span class="line">  required string query = 1;</span><br><span class="line">  optional int32 page_number = 2;  // Which page number do we want?</span><br><span class="line">  optional int32 result_per_page = 3;  // Number of results to return per page.</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Reserved-保留字段"><a href="#Reserved-保留字段" class="headerlink" title="Reserved 保留字段"></a>Reserved 保留字段</h3><p>如果你通过完全删除字段或将其注释掉来更新 message 类型，则未来一些用户在做他们的修改或更新时就可能会再次使用这些字段编号。如果以后加载相同 <code>.proto</code> 的旧版本，这可能会导致一些严重问题，包括数据损坏，隐私错误等。确保不会发生这种情况的一种方法是指定已删除字段的字段编号（有时也需要指定名称为保留状态，英文名称可能会导致 JSON 序列化问题）为 “保留” 状态。如果将来的任何用户尝试使用这些字段标识符，protocol buffer 编译器将会抱怨。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">message Foo &#123;</span><br><span class="line">  reserved 2, 15, 9 to 11;</span><br><span class="line">  reserved &quot;foo&quot;, &quot;bar&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>请注意，你不能在同一 “reserved” 语句中将字段名称和字段编号混合在一起指定。</p><h3 id="你的-proto-文件将生成什么？"><a href="#你的-proto-文件将生成什么？" class="headerlink" title="你的 .proto 文件将生成什么？"></a>你的 .proto 文件将生成什么？</h3><p>当你在 <code>.proto</code> 上运行 protocol buffer 编译器时，编译器将会生成所需语言的代码，这些代码可以操作文件中描述的 message 类型，包括获取和设置字段值、将 message 序列化为输出流、以及从输入流中解析出 message。</p><ul><li>  对于 C++，编译器从每个 .proto 生成一个 .h 和 .cc 文件，其中包含文件中描述的每种 message 类型对应的类。</li><li>  对于 <strong>Java</strong>，编译器为每个 message 类型生成一个 .java 文件（类），以及用于创建 message 类实例的特殊 Builder 类。</li><li>  <strong>Python</strong> 有点不同 - Python 编译器生成一个模块，其中包含 .proto 中每种 message 类型的静态描述符，然后与元类一起使用以创建必要的 Python 数据访问类。</li><li>对于 <strong>Go</strong>，编译器会生成一个 .pb.go 文件，其中包含对应每种 message 类型的类型。<br>  你可以按照所选语言的教程了解更多有关各种语言使用 API ​​的信息。有关更多 API 详细信息，请参阅相关的 <a href="https://developers.google.com/protocol-buffers/docs/reference/overview">API 参考</a>。</li></ul><h2 id="标量值类型"><a href="#标量值类型" class="headerlink" title="标量值类型"></a>标量值类型</h2><p>标量 message 字段可以具有以下几种类型之一 - 该表显示 .proto 文件中指定的类型，以及自动生成的类中的相应类型：</p><table><thead><tr><th>.proto Type</th><th>Notes</th><th>C++ Type</th><th>Java Type</th><th>Python Type</th><th>Go Type</th></tr></thead><tbody><tr><td>double</td><td></td><td>double</td><td>double</td><td>float</td><td>*float64</td></tr><tr><td>float</td><td></td><td>float</td><td>float</td><td>float</td><td>*float32</td></tr><tr><td>int32</td><td>使用可变长度编码。编码负数的效率低 - 如果你的字段可能有负值，请改用 sint32</td><td>int32</td><td>int</td><td>int</td><td>*int32</td></tr><tr><td>int64</td><td>使用可变长度编码。编码负数的效率低 - 如果你的字段可能有负值，请改用 sint64</td><td>int64</td><td>long</td><td>int/long</td><td>*int64</td></tr><tr><td>uint32</td><td>使用可变长度编码</td><td>uint32</td><td>int</td><td>int/long</td><td>*uint32</td></tr><tr><td>uint64</td><td>使用可变长度编码</td><td>uint64</td><td>long</td><td>int/long</td><td>*uint64</td></tr><tr><td>sint32</td><td>使用可变长度编码。有符号的 int 值。这些比常规 int32 对负数能更有效地编码</td><td>int32</td><td>int</td><td>int</td><td>*int32</td></tr><tr><td>sint64</td><td>使用可变长度编码。有符号的 int 值。这些比常规 int64 对负数能更有效地编码</td><td>int64</td><td>long</td><td>int/long</td><td>*int64</td></tr><tr><td>fixed32</td><td>总是四个字节。如果值通常大于 228，则比 uint32 更有效。</td><td>uint32</td><td>int</td><td>int/long</td><td>*uint32</td></tr><tr><td>fixed64</td><td>总是八个字节。如果值通常大于 256，则比 uint64 更有效。</td><td>uint64</td><td>long</td><td>int/long</td><td>*uint64</td></tr><tr><td>sfixed32</td><td>总是四个字节</td><td>int32</td><td>int</td><td>int</td><td>*int32</td></tr><tr><td>sfixed64</td><td>总是八个字节</td><td>int64</td><td>long</td><td>int/long</td><td>*int64</td></tr><tr><td>bool</td><td></td><td>bool</td><td>boolean</td><td>bool</td><td>*bool</td></tr><tr><td>string</td><td>字符串必须始终包含 UTF-8 编码或 7 位 ASCII 文本</td><td>string</td><td>String</td><td>str/unicode</td><td>*string</td></tr><tr><td>bytes</td><td>可以包含任意字节序列</td><td>string</td><td>ByteString</td><td>str</td><td>byte</td></tr></tbody></table><p>在 Java 中，无符号的 32 位和 64 位整数使用它们对应的带符号表示，第一个 bit 位只是简单的存储在符号位中。<br>在所有情况下，设置字段的值将执行类型检查以确保其有效。<br>64 位或无符号 32 位整数在解码时始终表示为 long，但如果在设置字段时给出 int，则可以为int。在所有情况下，该值必须适合设置时的类型。见。<br>Python 字符串在解码时表示为 unicode，但如果给出了 ASCII 字符串，则可以是 str（这条可能会发生变化）。</p><h2 id="Optional-可选字段和默认值"><a href="#Optional-可选字段和默认值" class="headerlink" title="Optional 可选字段和默认值"></a>Optional 可选字段和默认值</h2><p>如上所述，message 描述中的元素可以标记为可选 optional。格式良好的 message 可能包含也可能不包含被声明为可选的元素。解析 message 时，如果 message 不包含 optional 元素，则解析对象中的相应字段将设置为该字段的默认值。可以将默认值指定为 message 描述的一部分。例如，假设你要为 SearchRequest 的 result_per_page 字段提供默认值10。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">optional int32 result_per_page = 3 [default = 10];</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果未为 optional 元素指定默认值，则使用特定于类型的默认值：对于字符串，默认值为空字符串。对于 bool，默认值为 false。对于数字类型，默认值为零。对于枚举，默认值是枚举类型定义中列出的第一个值。这意味着在将值添加到枚举值列表的开头时必须小心。有关如何安全的更改定义的指导，请参阅 <code>更新 Message 类型</code> 部分（见下面的 <code>更新 message 类型</code>）。</p><h2 id="枚举-Enumerations"><a href="#枚举-Enumerations" class="headerlink" title="枚举 Enumerations"></a>枚举 Enumerations</h2><p>在定义 message 类型时，你可能希望其中一个字段只有一个预定义的值列表。例如，假设你要为每个 SearchRequest 添加语料库字段，其中语料库可以是 UNIVERSAL，WEB，IMAGES，LOCAL，NEWS，PRODUCTS 或 VIDEO。你可以通过向 message 定义添加枚举来简单地执行此操作 - 具有枚举类型的字段只能将一组指定的常量作为其值（如果你尝试提供不同的值，则解析器会将其视为一个未知的领域）。在下面的例子中，我们添加了一个名为 Corpus 的枚举，其中包含所有可能的值，之后定义了一个类型为 Corpus 枚举的字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">message SearchRequest &#123;</span><br><span class="line">  required string query = 1;</span><br><span class="line">  optional int32 page_number = 2;</span><br><span class="line">  optional int32 result_per_page = 3 [default = 10];</span><br><span class="line">  enum Corpus &#123;</span><br><span class="line">    UNIVERSAL = 0;</span><br><span class="line">    WEB = 1;</span><br><span class="line">    IMAGES = 2;</span><br><span class="line">    LOCAL = 3;</span><br><span class="line">    NEWS = 4;</span><br><span class="line">    PRODUCTS = 5;</span><br><span class="line">    VIDEO = 6;</span><br><span class="line">  &#125;</span><br><span class="line">  optional Corpus corpus = 4 [default = UNIVERSAL];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>你可以通过为不同的枚举常量指定相同的值来定义别名。为此，你需要将 allow_alias 选项设置为true，否则 protocol 编译器将在找到别名时生成错误消息。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">enum EnumAllowingAlias &#123;</span><br><span class="line">  option allow_alias = true;</span><br><span class="line">  UNKNOWN = 0;</span><br><span class="line">  STARTED = 1;</span><br><span class="line">  RUNNING = 1;</span><br><span class="line">&#125;</span><br><span class="line">enum EnumNotAllowingAlias &#123;</span><br><span class="line">  UNKNOWN = 0;</span><br><span class="line">  STARTED = 1;</span><br><span class="line">  // RUNNING = 1;  // 取消此行注释将导致 Google 内部的编译错误和外部的警告消息</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>枚举器常量必须在 32 位整数范围内。由于 <code>enum</code> 值在线上使用 <code>varint encoding</code>，负值效率低，因此不推荐使用。你可以在 message 中定义 enums，如上例所示的那样。或者将其定义在 message 外部 - 这样这些 <code>enum</code> 就可以在 <code>.proto</code> 文件中的任何 message 定义中重用。你还可以使用一个 message 中声明的 <code>enum</code> 类型作为不同 message 中字段的类型，使用语法 <em>MessageType</em>.<em>EnumType</em> 来实现。</p><p>当你在使用 <code>enum</code> 的 <code>.proto</code> 上运行 protocol buffer 编译器时，生成的代码将具有相应的用于　Java 或 C++ 的 <code>enum</code>，或者用于创建集合的 Python 的特殊 <code>EnumDescriptor</code> 类。运行时生成的类中具有整数值的符号常量。</p><p>有关如何在应用程序中使用 enums 的更多信息，请参阅相关语言的 <a href="https://developers.google.com/protocol-buffers/docs/reference/overview">代码生成指南</a></p><h3 id="保留值"><a href="#保留值" class="headerlink" title="保留值"></a>保留值</h3><p>如果你通过完全删除枚举条目或将其注释掉来更新枚举类型，则未来用户可能在对 message 做出自己的修改或更新时重复使用这些数值。如果以后加载相同 <code>.proto</code> 的旧版本，这可能会导致严重问题，包括数据损坏，隐私错误等。确保不会发生这种情况的一种方法是指定已删除字段的字段编号（有时也需要指定名称为保留状态，英文名称可能会导致 JSON 序列化问题）为 “保留” 状态。如果将来的任何用户尝试使用这些字段标识符，protocol buffer 编译器将会抱怨。你可以使用 <code>max</code> 关键字指定保留的数值范围一直到最大值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">enum Foo &#123;</span><br><span class="line">  reserved 2, 15, 9 to 11, 40 to max;</span><br><span class="line">  reserved &quot;FOO&quot;, &quot;BAR&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>请注意，你不能在同一 “reserved” 语句中将字段名称和字段编号混合在一起指定。</p><h2 id="使用其他-Message-类型"><a href="#使用其他-Message-类型" class="headerlink" title="使用其他 Message 类型"></a>使用其他 Message 类型</h2><p>你可以使用其他 message 类型作为字段类型。例如，假设你希望在每个 SearchResponse 消息中包含 Result message - 为此，你可以在同一 .proto 中定义 Result message 类型，然后在SearchResponse 中指定 Result 类型的字段：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">message SearchResponse &#123;</span><br><span class="line">  repeated Result result = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Result &#123;</span><br><span class="line">  required string url = 1;</span><br><span class="line">  optional string title = 2;</span><br><span class="line">  repeated string snippets = 3;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="导入定义-Importing-Definitions"><a href="#导入定义-Importing-Definitions" class="headerlink" title="导入定义 Importing Definitions"></a>导入定义 Importing Definitions</h3><p>在上面的示例中，Result message 类型在与 SearchResponse 相同的文件中定义 - 如果要用作字段类型的 message 类型已在另一个 .proto 文件中定义，该怎么办？</p><p>你可以通过导入来使用其他 .proto 文件中的定义。要导入另一个 .proto 的定义，可以在文件顶部添加一个 import 语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &quot;myproject/other_protos.proto&quot;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>默认情况下，你只能使用直接导入的 .proto 文件中的定义。但是，有时你可能需要将 .proto 文件移动到新位置。现在，你可以在旧位置放置一个虚拟 .proto 文件，以使用 import public 概念将所有导入转发到新位置，而不是直接移动 .proto 文件并在一次更改中更新所有调用点。导入包含 import public 语句的 proto 的任何人都可以传递依赖导入公共依赖项。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// new.proto</span><br><span class="line">// All definitions are moved here</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// old.proto</span><br><span class="line">// This is the proto that all clients are importing.</span><br><span class="line">import public &quot;new.proto&quot;;</span><br><span class="line">import &quot;other.proto&quot;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// client.proto</span><br><span class="line">import &quot;old.proto&quot;;</span><br><span class="line">// 你可以使用 old.proto 和 new.proto 中的定义，但无法使用 other.proto</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>使用命令 -I/–proto_path 让 protocol 编译器在指定的一组目录中搜索要导入的文件。如果没有给出这个命令选项，它将查找调用编译器所在的目录。通常，你应将 –proto_path 设置为项目的根目录，并对所有导入使用完全限定名称。</p><h3 id="使用-proto3-Message-类型"><a href="#使用-proto3-Message-类型" class="headerlink" title="使用 proto3 Message 类型"></a>使用 proto3 Message 类型</h3><p>可以导入 <a href="https://developers.google.com/protocol-buffers/docs/proto3">proto3</a> message 类型并在 proto2 message 中使用它们，反之亦然。但是，proto2 枚举不能用于 proto3 语法。</p><h2 id="嵌套类型-Nested-Types"><a href="#嵌套类型-Nested-Types" class="headerlink" title="嵌套类型 Nested Types"></a>嵌套类型 Nested Types</h2><p>你可以在其他 message 类型中定义和使用 message 类型，如下例所示 - 此处结果消息在SearchResponse 消息中定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">message SearchResponse &#123;</span><br><span class="line">  message Result &#123;</span><br><span class="line">    required string url = 1;</span><br><span class="line">    optional string title = 2;</span><br><span class="line">    repeated string snippets = 3;</span><br><span class="line">  &#125;</span><br><span class="line">  repeated Result result = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果要在其父消息类型之外重用此消息类型，请将其称为 _Parent.Type_：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">message SomeOtherMessage &#123;</span><br><span class="line">  optional SearchResponse.Result result = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>你可以根据需要深入的嵌套消息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">message Outer &#123;                  // Level 0</span><br><span class="line">  message MiddleAA &#123;  // Level 1</span><br><span class="line">    message Inner &#123;   // Level 2</span><br><span class="line">      required int64 ival = 1;</span><br><span class="line">      optional bool  booly = 2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  message MiddleBB &#123;  // Level 1</span><br><span class="line">    message Inner &#123;   // Level 2</span><br><span class="line">      required int32 ival = 1;</span><br><span class="line">      optional bool  booly = 2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Groups"><a href="#Groups" class="headerlink" title="Groups"></a>Groups</h3><p><strong>请注意，此功能已弃用，在创建新消息类型时不应使用 - 请改用嵌套消息类型。</strong><br>Groups 是在 message 定义中嵌套信息的另一种方法。例如，指定包含许多结果的SearchResponse 的另一种方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">message SearchResponse &#123;</span><br><span class="line">  repeated group Result = 1 &#123;</span><br><span class="line">    required string url = 2;</span><br><span class="line">    optional string title = 3;</span><br><span class="line">    repeated string snippets = 4;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>group 只是将嵌套 message 类型和字段组合到单个声明中。在你的代码中，你可以将此消息视为具有名为 <code>result</code> 的 <code>Result</code> 类型字段（前一名称转换为小写，以便它不与前者冲突）。因此，此示例完全等同于上面的 <code>SearchResponse</code>，但 message 具有不同的编码结果。</p><blockquote><p>译者注：<br>再次强调，此功能<strong>已弃用</strong>，这里只为尽可能保留原文内容。</p></blockquote><h2 id="更新-message-类型"><a href="#更新-message-类型" class="headerlink" title="更新 message 类型"></a>更新 message 类型</h2><p>如果现有的 message 类型不再满足你的所有需求 - 例如，你希望 message 格式具有额外的字段 - 但你仍然希望使用旧格式创建代码，请不要担心！在不破坏任何现有代码的情况下更新 message 类型非常简单。请记住以下规则：</p><ul><li>  请勿更改任何现有字段的字段编号。</li><li>  你添加的任何新字段都应该是 <code>optional</code> 或 <code>repeated</code>。这意味着使用“旧”消息格式的代码序列化的任何消息都可以由新生成的代码进行解析，因为它们不会缺少任何 <code>required</code> 元素。你应该为这些元素设置合理的 <code>默认值</code>，以便新代码可以正确地与旧代码生成的 message 进行交互。同样，你的新代码创建的 message 可以由旧代码解析：旧的二进制文件在解析时只是忽略新字段。但是未丢弃这个新字段（未知字段），如果稍后序列化消息，则将新字段（未知字段）与其一起序列化 - 因此，如果将消息传递给新代码，则新字段仍然可用。</li><li>  只要在更新的 message 类型中不再使用字段编号，就可以删除非必填字段。你可能希望重命名该字段，可能添加前缀 “OBSOLETE_“，或者将字段编号<strong>保留（Reserved）</strong>，以便将来你的 <code>.proto</code> 的用户不会不小心重用这个编号。</li><li>  只要类型和编号保持不变，非必填字段就可以转换为扩展 <a href="https://developers.google.com/protocol-buffers/docs/proto#extensions">extensions</a>，反之亦然。</li><li>  <code>int32</code>，<code>uint32</code>，<code>int64</code>，<code>uint64</code> 和 <code>bool</code> 都是兼容的 - 这意味着你可以将字段从这些类型更改为另一种类型，而不会破坏向前或向后兼容性。如果从中解析出一个不符合相应类型的数字，你将获得与在 C++ 中将该数字转换为该类型时相同的效果（例如，如果将 64 位数字作为 int32 读取，它将被截断为 32 位）。</li><li>  <code>sint32</code> 和 <code>sint64</code> 彼此兼容，但与其他整数类型不兼容。</li><li>  只要字节是有效的 UTF-8，<code>string</code> 和 <code>bytes</code> 就是兼容的。</li><li>  如果字节包含 message 的编码版本，则嵌入 message 与 <code>bytes</code> 兼容。</li><li>  <code>fixed32</code> 与 <code>sfixed32</code> 兼容，<code>fixed64</code> 与 <code>sfixed64</code> 兼容。</li><li>  <code>optional</code> 与 <code>repeated</code> 兼容。给定重复字段的序列化数据作为输入，期望该字段为 <code>optional</code> 的客户端将采用最后一个输入值（如果它是基本类型字段）或合并所有输入元素（如果它是 message 类型字段）。</li><li>  更改默认值通常是正常的，只要你记住永远不会通过网络发送默认值。因此，如果程序接收到未设置特定字段的消息，则程序将看到该程序的协议版本中定义的默认值。它不会看到发件人代码中定义的默认值。</li><li>  <code>enum</code> 与 <code>int32</code>，<code>uint32</code>，<code>int64</code> 和 <code>uint64</code>兼容（注意，如果它们不适合，值将被截断），但要注意 message 反序列化时客户端代码对待它们将有所不同。值得注意的是，当 message 被反序列化时，将丢弃无法识别的 <code>enum</code> 值，这使得字段的 <code>has..</code> 访问器返回 false 并且其 getter 返回 <code>enum</code> 定义中列出的第一个值，或者如果指定了一个默认值则返回默认值。在 repeated 枚举字段的情况下，任何无法识别的值都将从列表中删除。但是，整数字段将始终保留其值。因此，在有可能接收超出范围的枚举值时，对整数升级为 <code>enum</code> 这一操作需要非常小心。</li><li>  在当前的 Java 和 C++ 实现中，当删除无法识别的 <code>enum</code> 值时，它们与其他未知字段一起存储。请注意，如果此数据被序列化，然后由识别这些值的客户端重新解析，则会导致奇怪的行为。在 optional 可选字段的情况下，即使在反序列化原始 message 之后写入新值，旧值仍然可以被客户端识别。在 repeated 字段的情况下，旧值将出现在任何已识别和新添加的值之后，这意味着顺序将不被保留。</li><li>  将单个 <code>optional</code> 值更改为 <strong>new</strong><code>oneof</code> 的成员是安全且二进制兼容的。如果你确定没有代码一次设置多个，则将多个 <code>optional</code> 字段移动到新的 <code>oneof</code> 中可能是安全的。但是将任何字段移动到现有的 <code>oneof</code> 是不安全的。</li></ul><h2 id="扩展-Extensions"><a href="#扩展-Extensions" class="headerlink" title="扩展 Extensions"></a>扩展 Extensions</h2><p>通过扩展，你可以声明 message 中的一系列字段编号用于第三方扩展。扩展名是那些未由原始 .proto 文件定义的字段的占位符。这允许通过使用这些字段编号来定义部分或全部字段从而将其它 .proto 文件定义的字段添加到当前 message 定义中。我们来看一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">message Foo &#123;</span><br><span class="line">  // ...</span><br><span class="line">  extensions 100 to 199;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这表示 Foo 中的字段数 [100,199] 的范围是为扩展保留的。其他用户现在可以使用指定范围内的字段编号在他们自己的 .proto 文件中为 Foo 添加新字段，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extend Foo &#123;</span><br><span class="line">  optional int32 bar = 126;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这会将名为 bar 且编号为 126 的字段添加到 Foo 的原始定义中。</p><blockquote><p>译者注：<br>第一段翻译过来的语义实在是太别扭了（因为站在了被扩展字段所在的 .proto 文件的角度来看待扩展），实际站在扩展字段所在的 .proto 文件的角度－就是可以在自己的 .proto 文件中扩展其他人定义的另一个 .proto 中的 message。</p></blockquote><p>当用户的 Foo 消息被编码时，其格式与用户在 Foo 中常规定义新字段的格式完全相同。但是，在应用程序代码中访问扩展字段的方式与访问常规字段略有不同 - 生成的数据访问代码具有用于处理扩展的特殊访问器。那么，举个例子，下面就是如何在 C++ 中设置 bar 的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Foo foo;</span><br><span class="line">foo.SetExtension(bar, 15);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>类似地，Foo 类定义模板化访问器 HasExtension()，ClearExtension()，GetExtension()，MutableExtension() 和 AddExtension()。它们都具有与正常字段生成的访问器相匹配的语义。有关使用扩展的更多信息，请参阅所选语言的代码生成参考。</p><p>请注意，扩展可以是任何字段类型，包括 message 类型，但不能是 oneofs 或 maps。</p><h3 id="嵌套扩展"><a href="#嵌套扩展" class="headerlink" title="嵌套扩展"></a>嵌套扩展</h3><p>你可以在另一种 message 类型内部声明扩展：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">message Baz &#123;</span><br><span class="line">  extend Foo &#123;</span><br><span class="line">    optional int32 bar = 126;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这种情况下，访问此扩展的 C++ 代码为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Foo foo;</span><br><span class="line">foo.SetExtension(Baz::bar, 15);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>换句话说，唯一的影响是 bar 是在 Baz 的范围内定义。</p><blockquote><p>注意:<br>这是一个常见的混淆源：在一个 message 类型中声明嵌套的扩展块并不意味着外部类型和扩展类型之间存在任何关系。特别是，上面的例子并不意味着 Baz 是 Foo 的任何子类。这意味着符号栏是在 Baz 范围内声明的；它仅仅只是一个静态成员而已。</p></blockquote><p>一种常见的模式是在扩展的字段类型范围内定义扩展 - 例如，这里是 Baz 类型的 Foo 扩展，其中扩展名被定义为 Baz 的一部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">message Baz &#123;</span><br><span class="line">  extend Foo &#123;</span><br><span class="line">    optional Baz foo_ext = 127;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>译者注：<br>这里比较绕，实际上就是要对某个 message A 扩展一个字段 B（B 类型），那么可以将这条扩展语句写在 message B 的定义里。</p></blockquote><p>但是，并不是必须要在类型内才能定义该类型的扩展字段。你也可以这样做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">message Baz &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 该定义甚至可以移到另一个文件中</span><br><span class="line">extend Foo &#123;</span><br><span class="line">  optional Baz foo_baz_ext = 127;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>实际上，这种语法可能是首选的，以避免混淆。如上所述，嵌套语法经常被不熟悉扩展的用户误认为是子类。</p><h3 id="选择扩展字段编号"><a href="#选择扩展字段编号" class="headerlink" title="选择扩展字段编号"></a>选择扩展字段编号</h3><p>确保两个用户不使用相同的字段编号向同一 message 类型添加扩展名非常重要 - 如果扩展名被意外解释为错误类型，则可能导致数据损坏。你可能需要考虑为项目定义扩展编号的约定以防止这种情况发生。</p><p>如果你的编号约定可能涉及那些具有非常大字段编号的扩展，则可以使用 max 关键字指定扩展范围至编号最大值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">message Foo &#123;</span><br><span class="line">  extensions 1000 to max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最大值为 229 - 1，或者 536,870,911。</p><p>与一般选择字段编号时一样，你的编号约定还需要避免 19000 到 19999 的字段编号(FieldDescriptor::kFirstReservedNumber 到 FieldDescriptor::kLastReservedNumber)，因为它们是为 Protocol Buffers 实现保留的。你可以定义包含此范围的扩展名范围，但 protocol 编译器不允许你使用这些编号定义实际扩展名。</p><h2 id="Oneof"><a href="#Oneof" class="headerlink" title="Oneof"></a>Oneof</h2><p>如果你的 message 包含许多可选字段，并且最多只能同时设置其中一个字段，则可以使用 oneof 功能强制执行此行为并节省内存。</p><p>Oneof 字段类似于可选字段，除了 oneof 共享内存中的所有字段，并且最多只能同时设置一个字段。设置 oneof 的任何成员会自动清除所有其他成员。你可以使用特殊的 case() 或 WhichOneof() 方法检查 oneof 字段中当前是哪个值（如果有）被设置，具体方法取决于你选择的语言。</p><h3 id="使用-Oneof"><a href="#使用-Oneof" class="headerlink" title="使用 Oneof"></a>使用 Oneof</h3><p>要在 .proto 中定义 oneof，请使用 oneof 关键字，后跟你的 oneof 名称，在本例中为 test_oneof：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">message SampleMessage &#123;</span><br><span class="line">  oneof test_oneof &#123;</span><br><span class="line">     string name = 4;</span><br><span class="line">     SubMessage sub_message = 9;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后，将 oneof 字段添加到 oneof 定义中。你可以添加任何类型的字段，但不能使用 <code>required</code>，<code>optional</code> 或 <code>repeated</code> 关键字。如果需要向 oneof 添加重复字段，可以使用包含重复字段的 message。</p><p>在生成的代码中，oneof 字段与常规 <code>optional</code> 方法具有相同的 getter 和 setter。你还可以使用特殊方法检查 oneof 中的值（如果有）。你可以在相关的 API 参考中找到有关所选语言的 oneof API的更多信息。</p><h3 id="Oneof-特性"><a href="#Oneof-特性" class="headerlink" title="Oneof 特性"></a>Oneof 特性</h3><ul><li>设置 oneof 字段将自动清除 oneof 的所有其他成员。因此，如果你设置了多个字段，则只有你设置的最后一个字段仍然具有值。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SampleMessage message;</span><br><span class="line">message.set_name(&quot;name&quot;);</span><br><span class="line">CHECK(message.has_name());</span><br><span class="line">message.mutable_sub_message();   // Will clear name field.</span><br><span class="line">CHECK(!message.has_name());</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>如果解析器遇到同一个 oneof 的多个成员，则在解析的消息中仅使用看到的最后一个成员。</li><li>oneof 不支持扩展</li><li>oneof 不能使用 repeated</li><li>反射 API 适用于 oneof 字段</li><li>如果你使用的是 C++，请确保你的代码不会导致内存崩溃。以下示例代码将崩溃，因为已通过调用 set_name() 方法删除了 sub_message。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SampleMessage message;</span><br><span class="line">SubMessage* sub_message = message.mutable_sub_message();</span><br><span class="line">message.set_name(&quot;name&quot;);      // Will delete sub_message</span><br><span class="line">sub_message-&gt;set_...            // Crashes here</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>同样在 C++中，如果你使用 Swap() 交换了两条 oneofs 消息，则每条消息将以另一条消息的 oneof 实例结束：在下面的示例中，msg1 将具有 sub_message 而 msg2 将具有 name。  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SampleMessage msg1;</span><br><span class="line">msg1.set_name(&quot;name&quot;);</span><br><span class="line">SampleMessage msg2;</span><br><span class="line">msg2.mutable_sub_message();</span><br><span class="line">msg1.swap(&amp;msg2);</span><br><span class="line">CHECK(msg1.has_sub_message());</span><br><span class="line">CHECK(msg2.has_name());</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="向后兼容性问题"><a href="#向后兼容性问题" class="headerlink" title="向后兼容性问题"></a>向后兼容性问题</h3><p>添加或删除其中一个字段时要小心。如果检查 oneof 的值返回 None/NOT_SET，则可能意味着 oneof 尚未设置或已设置为 oneof 的另一个字段。这种情况是无法区分的，因为无法知道未知字段是否是 oneof 成员。</p><h4 id="标签重用问题"><a href="#标签重用问题" class="headerlink" title="标签重用问题"></a>标签重用问题</h4><ul><li>  <strong>将 optional 可选字段移入或移出 oneof</strong>：在序列化和解析 message 后，你可能会丢失一些信息（某些字段将被清除）。但是，你可以安全地将单个字段移动到新的 oneof 中，并且如果已知只有一个字段被设置，则可以移动多个字段。</li><li>  <strong>删除 oneof 字段并将其重新添加回去</strong>：在序列化和解析 message 后，这可能会清除当前设置的 oneof 字段。</li><li>  <strong>拆分或合并 oneof</strong>：这与移动常规的 optional 字段有类似的问题。</li></ul><h2 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h2><p>如果要在数据定义中创建关联映射，protocol buffers 提供了一种方便快捷的语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map&lt;key_type, value_type&gt; map_field = N;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>…其中 <code>key_type</code> 可以是任何整数或字符串类型（任何标量类型除浮点类型和 <code>bytes</code>）。请注意，枚举不是有效的 <code>key_type</code>。<code>value_type</code> 可以是除 map 之外的任何类型。</p><p>因此，举个例子，如果要创建项目映射，其中每个 “Project” message 都与字符串键相关联，则可以像下面这样定义它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, Project&gt; projects = 3;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>生成的 map API 目前可用于所有 proto2 支持的语言。你可以在相关的 <a href="https://developers.google.com/protocol-buffers/docs/reference/overview">API 参考</a> 中找到有关所选语言的 map API 的更多信息。</p><h3 id="Maps-特性"><a href="#Maps-特性" class="headerlink" title="Maps 特性"></a>Maps 特性</h3><ul><li>  maps 不支持扩展</li><li>  maps 不能是 repeated、optional、required</li><li>  map 值的格式排序和 map 迭代排序未定义，因此你不能依赖于特定顺序的 map 项</li><li>  生成 .proto 的文本格式时，maps 按键排序。数字键按数字排序</li><li>  当解析或合并时，如果有重复的 map 键，则使用最后看到的键。从文本格式解析 map 时，如果存在重复键，则解析可能会失败</li></ul><h3 id="向后兼容性"><a href="#向后兼容性" class="headerlink" title="向后兼容性"></a>向后兼容性</h3><p>map 语法等效于以下内容，因此不支持 map 的 protocol buffers 实现仍可处理你的数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">message MapFieldEntry &#123;</span><br><span class="line">  optional key_type key = 1;</span><br><span class="line">  optional value_type value = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repeated MapFieldEntry map_field = N;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>任何支持 maps 的 protocol buffers 实现都必须生成和接受上述定义所能接受的数据。</p><h2 id="Packages"><a href="#Packages" class="headerlink" title="Packages"></a>Packages</h2><p>你可以将 optional 可选的包说明符添加到 .proto 文件，以防止 protocol message 类型之间的名称冲突。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">package foo.bar;</span><br><span class="line">message Open &#123; ... &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后，你可以在定义 message 类型的字段时使用包说明符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">message Foo &#123;</span><br><span class="line">  ...</span><br><span class="line">  required foo.bar.Open open = 1;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>package 影响生成的代码的方式取决于你所选择的语言：</p><ul><li>  在 <strong>C++</strong> 中，生成的类包含在 C++ 命名空间中。例如，Open 将位于命名空间 foo::bar 中。</li><li>  在 <strong>Java</strong> 中，除非在 .proto 文件中明确提供选项 java_package，否则该包将用作 Java 包</li><li>  在 <strong>Python</strong> 中，package 指令被忽略，因为 Python 模块是根据它们在文件系统中的位置进行组织的</li></ul><p>请注意，即使 package 指令不直接影响生成的代码，但是例如在 Python 中，仍然强烈建议指定 .proto 文件的包，否则可能导致描述符中的命名冲突并使 proto 对于其他语言不方便。</p><h3 id="Packages-和名称解析"><a href="#Packages-和名称解析" class="headerlink" title="Packages 和名称解析"></a>Packages 和名称解析</h3><p>protocol buffer 语言中的类型名称解析与 C++ 类似：首先搜索最里面的范围，然后搜索下一个范围，依此类推，每个包被认为是其父包的 “内部”。一个领先的 ‘.’（例如 .foo.bar.Baz）意味着从最外层的范围开始。</p><p>protocol buffer 编译器通过解析导入的 .proto 文件来解析所有类型名称。每种语言的代码生成器都知道如何使用相应的语言类型，即使它具有不同的范围和规则。</p><h2 id="定义服务"><a href="#定义服务" class="headerlink" title="定义服务"></a>定义服务</h2><p>如果要将 message 类型与 RPC（远程过程调用）系统一起使用，则可以在 .proto 文件中定义 RPC 服务接口，protocol buffer 编译器将使用你选择的语言生成服务接口代码和存根。因此，例如，如果要定义一个 RPC 服务，其中具有一个获取 SearchRequest 并返回 SearchResponse 的方法，可以在 .proto 文件中定义它，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">service SearchService &#123;</span><br><span class="line">  rpc Search (SearchRequest) returns (SearchResponse);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>默认情况下，protocol 编译器将生成一个名为 SearchService 的抽象接口和相应的 “存根” 实现。存根转发所有对 RpcChannel 的调用，而 RpcChannel 又是一个抽象接口，你必须根据自己的 RPC 系统自行定义。例如，你可以实现一个 RpcChannel，它将 message 序列化并通过 HTTP 将其发送到服务器。换句话说，生成的存根提供了一个类型安全的接口，用于进行基于 protocol-buffer 的 RPC 调用，而不会将你锁定到任何特定的 RPC 实现中。所以，在 C++ 中，你可能会得到这样的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">using google::protobuf;</span><br><span class="line"></span><br><span class="line">protobuf::RpcChannel* channel;</span><br><span class="line">protobuf::RpcController* controller;</span><br><span class="line">SearchService* service;</span><br><span class="line">SearchRequest request;</span><br><span class="line">SearchResponse response;</span><br><span class="line"></span><br><span class="line">void DoSearch() &#123;</span><br><span class="line">  // You provide classes MyRpcChannel and MyRpcController, which implement</span><br><span class="line">  // the abstract interfaces protobuf::RpcChannel and protobuf::RpcController.</span><br><span class="line">  channel = new MyRpcChannel(&quot;somehost.example.com:1234&quot;);</span><br><span class="line">  controller = new MyRpcController;</span><br><span class="line"></span><br><span class="line">  // The protocol compiler generates the SearchService class based on the</span><br><span class="line">  // definition given above.</span><br><span class="line">  service = new SearchService::Stub(channel);</span><br><span class="line"></span><br><span class="line">  // Set up the request.</span><br><span class="line">  request.set_query(&quot;protocol buffers&quot;);</span><br><span class="line"></span><br><span class="line">  // Execute the RPC.</span><br><span class="line">  service-&gt;Search(controller, request, response, protobuf::NewCallback(&amp;Done));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Done() &#123;</span><br><span class="line">  delete service;</span><br><span class="line">  delete channel;</span><br><span class="line">  delete controller;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所有服务类还实现了 Service 接口，它提供了一种在编译时不知道方法名称或其输入和输出类型的情况下来调用特定方法的方法。在服务器端，这可用于实现一个可以注册服务的 RPC 服务器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">using google::protobuf;</span><br><span class="line"></span><br><span class="line">class ExampleSearchService : public SearchService &#123;</span><br><span class="line"> public:</span><br><span class="line">  void Search(protobuf::RpcController* controller,</span><br><span class="line">              const SearchRequest* request,</span><br><span class="line">              SearchResponse* response,</span><br><span class="line">              protobuf::Closure* done) &#123;</span><br><span class="line">    if (request-&gt;query() == &quot;google&quot;) &#123;</span><br><span class="line">      response-&gt;add_result()-&gt;set_url(&quot;http://www.google.com&quot;);</span><br><span class="line">    &#125; else if (request-&gt;query() == &quot;protocol buffers&quot;) &#123;</span><br><span class="line">      response-&gt;add_result()-&gt;set_url(&quot;http://protobuf.googlecode.com&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    done-&gt;Run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  // You provide class MyRpcServer.  It does not have to implement any</span><br><span class="line">  // particular interface; this is just an example.</span><br><span class="line">  MyRpcServer server;</span><br><span class="line"></span><br><span class="line">  protobuf::Service* service = new ExampleSearchService;</span><br><span class="line">  server.ExportOnPort(1234, service);</span><br><span class="line">  server.Run();</span><br><span class="line"></span><br><span class="line">  delete service;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果你不想插入自己现有的 RPC 系统，现在可以使用 <a href="https://github.com/grpc/grpc-common">gRPC</a>: 一个由谷歌开发的与语言和平台无关的开源 RPC 系统。gRPC 特别适用于 protocol buffers，并允许你使用特殊的 protocol buffers 编译器插件直接从 <code>.proto</code> 文件生成相关的 RPC 代码。但是，由于使用 proto2 和 proto3 生成的客户端和服务器之间存在潜在的兼容性问题，我们建议你使用 proto3 来定义 gRPC 服务。你可以在 <a href="https://www.jianshu.com/p/fc7485af828d">Proto3 语言指南</a> 中找到有关 proto3 语法的更多信息。如果你确实希望将 proto2 与 gRPC 一起使用，则需要使用 3.0.0 或更高版本的 protocol buffers 编译器和库。</p><p>除了 gRPC 之外，还有许多正在进行的第三方项目，用于开发 Protocol Buffers 的 RPC 实现。有关我们了解的项目的链接列表，请参阅 <a href="https://github.com/google/protobuf/blob/master/docs/third_party.md">第三方附加组件维基页面</a>。</p><h2 id="选项-Options"><a href="#选项-Options" class="headerlink" title="选项 Options"></a>选项 Options</h2><p>.proto 文件中的各个声明可以使用许多选项进行注释。选项不会更改声明的整体含义，但可能会影响在特定上下文中处理它的方式。可用选项的完整列表在 google/protobuf/descriptor.proto 中定义。</p><p>一些选项是文件级选项，这意味着它们应该在顶级范围内编写，而不是在任何消息，枚举或服务定义中。一些选项是 message 消息级选项，这意味着它们应该写在 message 消息定义中。一些选项是字段级选项，这意味着它们应该写在字段定义中。选项也可以写在枚举类型、枚举值、服务类型和服务方法上，但是，目前在这几个项目上并没有任何有用的选项。</p><p>以下是一些最常用的选项：</p><ul><li>java_package（文件选项）：要用于生成的 Java 类的包。如果 .proto 文件中没有给出显式的 java_package 选项，那么默认情况下将使用 proto 包（使用 .proto 文件中的 “package” 关键字指定）。但是，proto 包通常不能生成好的 Java 包，因为 proto 包不会以反向域名开头。如果不生成Java 代码，则此选项无效。```<br>  option java_package = “com.example.foo”;  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">*   java\_outer\_classname（文件选项）：要生成的最外层 Java 类（以及文件名）的类名。如果 .proto 文件中没有指定显式的 java\_outer\_classname，则通过将 .proto 文件名转换为 camel-case 来构造类名（因此 foo\_bar.proto 变为 FooBar.java）。如果不生成 Java 代码，则此选项无效。</span><br><span class="line"></span><br></pre></td></tr></table></figure>option java_outer_classname = “Ponycopter”;</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*   optimize\_for（文件选项）：可以设置为 **SPEED**，**CODE\_SIZE** 或 **LITE\_RUNTIME**。这会以下列方式影响 C++和 Java 的代码生成器（可能还有第三方生成器）：</span><br><span class="line">    </span><br><span class="line">    *   **SPEED（默认值）**：protocol buffer 编译器将生成用于对 message 类型进行序列化，解析和执行其他常见操作的代码。此代码经过高度优化。</span><br><span class="line">    *   **CODE\_SIZE**：protocol buffer 编译器将生成最少的类，并依赖于基于反射的共享代码来实现序列化，解析和各种其他操作。因此，生成的代码将比使用 SPEED 小得多，但操作会更慢。类仍将实现与 SPEED 模式完全相同的公共 API。此模式在包含大量 .proto 文件的应用程序中最有用，并且不需要所有这些文件都非常快。</span><br><span class="line">    *   **LITE\_RUNTIME**：protocol buffer 编译器将生成仅依赖于 “lite” 运行时库（libprotobuf-lite 而不是libprotobuf）的类。精简版运行时比整个库小得多（大约小一个数量级），但省略了描述符和反射等特定功能。这对于在移动电话等受限平台上运行的应用程序尤其有用。编译器仍将生成所有方法的快速实现，就像在 SPEED 模式下一样。生成的类将仅实现每种语言的 MessageLite 接口，该接口仅提供完整 Message 接口的方法的子集。</span><br><span class="line">    </span><br></pre></td></tr></table></figure><pre><code>option optimize_for = CODE_SIZE;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line">*   `cc_generic_services`，`java_generic_services`，`py_generic_services`（文件选项）：protocol buffer 编译器应根据服务定义判断是否生成 C++，Java 和 Python 抽象服务代码。由于遗留原因，这些默认为 “true”。但是，从版本 2.3.0（2010年1月）开始，RPC 实现最好提供 [代码生成器插件](https://developers.google.com/protocol-buffers/docs/reference/cpp/google.protobuf.compiler.plugin.pb) 生成更具体到每个系统的代码，而不是依赖于 “抽象” 服务。</span><br><span class="line"></span><br></pre></td></tr></table></figure></code></pre><p>// This file relies on plugins to generate service code.<br>option cc_generic_services = false;<br>option java_generic_services = false;<br>option py_generic_services = false;</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*   `cc_enable_arenas`（文件选项）：为 C++ 生成的代码启用 [arena allocation](https://developers.google.com/protocol-buffers/docs/reference/arenas)</span><br><span class="line">*   message\_set\_wire\_format（消息选项）：如果设置为 true，则消息使用不同的二进制格式，旨在与 Google 内部使用的旧格式兼容，即 MessageSet。Google 以外的用户可能永远不需要使用此选项。必须严格按如下方式声明消息：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>message Foo {<br>  option message_set_wire_format = true;<br>  extensions 4 to max;<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*   `packed`（字段选项）：如果在基本数字类型的重复字段上设置为 &#x27;true\`，则一个更紧凑的编码 被使用。使用此选项没有任何缺点。但请注意，在版本 2.3.0 之前，在不期望的情况下接收打包数据的解析器将忽略它。因此，在不破坏兼容性的情况下，无法将现有字段更改为打包格式。在 2.3.0 及更高版本中，此更改是安全的，因为可打包字段的解析器将始终接受这两种格式，但如果你必须使用旧的 protobuf 版本处理旧程序，请务必小心。```</span><br><span class="line">    repeated int32 samples = 4 [packed=true];</span><br><span class="line">    </span><br></pre></td></tr></table></figure><ul><li><code>deprecated</code>（field option）：如果设置为 <code>true</code>，表示该字段已弃用，新代码不应使用该字段。在大多数语言中，这没有实际效果。在 Java 中，这变成了 <code>@Deprecated</code> 注释。将来，其他特定于语言的代码生成器可能会在字段的访问器上生成弃用注释，这将导致在编译尝试使用该字段的代码时发出警告。如果任何人都未使用该字段，并且你希望阻止新用户使用该字段，请考虑使用 <a href="https://developers.google.com/protocol-buffers/docs/proto#reserved">reserved</a> 替换字段声明。```<br>  optional int32 old_field = 6 [deprecated=true];  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">    </span><br><span class="line"></span><br><span class="line">### 自定义选项</span><br><span class="line"></span><br><span class="line">Protocol Buffers 甚至允许你定义和使用自己的选项。请注意，这是 **高级功能**，大多数人不需要。由于选项是由 `google/protobuf/descriptor.proto`（如 `FileOptions` 或 `FieldOptions`）中定义的消息定义的，因此定义你自己的选项只需要扩展这些消息。例如：</span><br><span class="line"></span><br></pre></td></tr></table></figure>import “google/protobuf/descriptor.proto”;</li></ul><p>extend google.protobuf.MessageOptions {<br>  optional string my_option = 51234;<br>}</p><p>message MyMessage {<br>  option (my_option) = “Hello world!”;<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这里我们通过扩展 MessageOptions 定义了一个新的 message 级选项。然后，当我们使用该选项时，必须将选项名称括在括号中以指示它是扩展名。我们现在可以在 C++ 中读取 my\_option 的值，如下所示：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>string value = MyMessage::descriptor()-&gt;options().GetExtension(my_option);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这里，`MyMessage::descriptor()-&gt;options()` 返回 `MyMessage` 的 `MessageOptions` protocol message。从中读取自定义选项就像阅读任何其他扩展。</span><br><span class="line"></span><br><span class="line">同样，在 Java 中我们会写：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>String value = MyProtoFile.MyMessage.getDescriptor().getOptions().getExtension(MyProtoFile.myOption);</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在 Python 中它将是：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>value = my_proto_file_pb2.MyMessage.DESCRIPTOR.GetOptions()<br>  .Extensions[my_proto_file_pb2.my_option]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以在 Protocol Buffers 语言中为每种结构自定义选项。这是一个使用各种选项的示例：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>import “google/protobuf/descriptor.proto”;</p><p>extend google.protobuf.FileOptions {<br>  optional string my_file_option = 50000;<br>}<br>extend google.protobuf.MessageOptions {<br>  optional int32 my_message_option = 50001;<br>}<br>extend google.protobuf.FieldOptions {<br>  optional float my_field_option = 50002;<br>}<br>extend google.protobuf.EnumOptions {<br>  optional bool my_enum_option = 50003;<br>}<br>extend google.protobuf.EnumValueOptions {<br>  optional uint32 my_enum_value_option = 50004;<br>}<br>extend google.protobuf.ServiceOptions {<br>  optional MyEnum my_service_option = 50005;<br>}<br>extend google.protobuf.MethodOptions {<br>  optional MyMessage my_method_option = 50006;<br>}</p><p>option (my_file_option) = “Hello world!”;</p><p>message MyMessage {<br>  option (my_message_option) = 1234;</p><p>  optional int32 foo = 1 [(my_field_option) = 4.5];<br>  optional string bar = 2;<br>}</p><p>enum MyEnum {<br>  option (my_enum_option) = true;</p><p>  FOO = 1 [(my_enum_value_option) = 321];<br>  BAR = 2;<br>}</p><p>message RequestType {}<br>message ResponseType {}</p><p>service MyService {<br>  option (my_service_option) = FOO;</p><p>  rpc MyMethod(RequestType) returns(ResponseType) {<br>    // Note:  my_method_option has type MyMessage.  We can set each field<br>    //   within it using a separate “option” line.<br>    option (my_method_option).foo = 567;<br>    option (my_method_option).bar = “Some string”;<br>  }<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">请注意，如果要在除定义它之外的包中使用自定义选项，则必须在选项名称前加上包名称，就像对类型名称一样。例如：</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>// foo.proto<br>import “google/protobuf/descriptor.proto”;<br>package foo;<br>extend google.protobuf.MessageOptions {<br>  optional string my_option = 51234;<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">// bar.proto</span><br><span class="line">import &quot;foo.proto&quot;;</span><br><span class="line">package bar;</span><br><span class="line">message MyMessage &#123;</span><br><span class="line">  option (foo.my_option) = &quot;Hello world!&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>最后一件事：由于自定义选项是扩展名，因此必须为其分配字段编号，就像任何其他字段或扩展名一样。在上面的示例中，我们使用了 50000-99999 范围内的字段编号。此范围保留供个别组织内部使用，因此你可以自由使用此范围内的数字用于内部应用程序。但是，如果你打算在公共应用程序中使用自定义选项，则务必确保你的字段编号是全局唯一的。要获取全球唯一的字段编号，请发送请求以向 <a href="https://github.com/google/protobuf/blob/master/docs/options.md">protobuf全球扩展注册表</a> 添加条目。通常你只需要一个扩展号。你可以通过将多个选项放在子消息中来实现一个扩展号声明多个选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">message FooOptions &#123;</span><br><span class="line">  optional int32 opt1 = 1;</span><br><span class="line">  optional string opt2 = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extend google.protobuf.FieldOptions &#123;</span><br><span class="line">  optional FooOptions foo_options = 1234;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// usage:</span><br><span class="line">message Bar &#123;</span><br><span class="line">  optional int32 a = 1 [(foo_options).opt1 = 123, (foo_options).opt2 = &quot;baz&quot;];</span><br><span class="line">  // alternative aggregate syntax (uses TextFormat):</span><br><span class="line">  optional int32 b = 2 [(foo_options) = &#123; opt1: 123 opt2: &quot;baz&quot; &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>另请注意，每种选项类型（文件级别，消息级别，字段级别等）都有自己的数字空间，例如，你可以使用相同的数字声明 FieldOptions 和 MessageOptions 的扩展名。</p><h2 id="生成你的类"><a href="#生成你的类" class="headerlink" title="生成你的类"></a>生成你的类</h2><p>要生成 Java，Python 或 C++代码，你需要使用 <code>.proto</code> 文件中定义的 message 类型，你需要在 <code>.proto</code> 上运行 protocol buffer 编译器 <code>protoc</code>。如果尚未安装编译器，请 <a href="https://developers.google.com/protocol-buffers/docs/downloads.html">下载软件包</a> 并按照 README 文件中的说明进行操作。</p><p>Protocol 编译器的调用如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">protoc --proto_path=IMPORT_PATH --cpp_out=DST_DIR --java_out=DST_DIR --python_out=DST_DIR path/to/file.proto</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>  IMPORT_PATH 指定在解析导入指令时查找 .proto 文件的目录。如果省略，则使用当前目录。可以通过多次传递 –proto_path 选项来指定多个导入目录；他们将按顺序搜索。-I = IMPORT_PATH 可以用作 –proto_path 的缩写形式。</li><li>你可以提供一个或多个输出指令：<ul><li>  <code>--cpp_out</code>在 <code>DST_DIR</code> 中生成 C++ 代码。有关详细信息，请参阅 <a href="https://developers.google.com/protocol-buffers/docs/reference/cpp-generated">C++ 生成的代码参考</a> 。</li><li>  <code>--java_out</code>在<code>DST_DIR</code>中生成 Java 代码。有关更多信息，请参阅 <a href="https://developers.google.com/protocol-buffers/docs/reference/java-generated">Java 生成的代码参考</a> 。</li><li><code>--python_out</code> 在 <code>DST_DIR</code> 中生成 Python 代码。有关更多信息，请参阅 <a href="https://developers.google.com/protocol-buffers/docs/reference/python-generated">Python 生成的代码</a> 。<br>  为了方便起见，如果 DST_DIR 以 .zip 或 .jar 结尾，编译器会将输出写入到具有给定名称的单个 ZIP 格式的存档文件。.jar 输出还将根据 Java JAR 规范的要求提供清单文件。请注意，如果输出存档已存在，则会被覆盖；编译器不够智能，无法将文件添加到现有存档中。</li></ul></li><li>  你必须提供一个或多个 .proto 文件作为输入。可以一次指定多个 .proto 文件。虽然文件是相对于当前目录命名的，但每个文件必须驻留在其中一个 IMPORT_PATH 中，以便编译器可以确定其规范名称。</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;本指南介绍如何使用 protocol buffer 语言来构造 protocol buffer 数据，包括 &lt;code&gt;.proto&lt;/code&gt; 文件语法以及如何从 &lt;code&gt;.proto&lt;/code&gt; 文件生成数据访问类。它涵盖了 protocol buffer 语言的 &lt;strong&gt;proto2&lt;/strong&gt; 版本。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="GRPC" scheme="https://rma-shuyu.github.io/categories/GRPC/"/>
    
    
    <category term="proto2" scheme="https://rma-shuyu.github.io/tags/proto2/"/>
    
  </entry>
  
  <entry>
    <title>DPDK+OVS+QEMU前后端启动vm</title>
    <link href="https://rma-shuyu.github.io/2023/03/06/DPDK-OVS-QEMU%E5%89%8D%E5%90%8E%E7%AB%AF%E5%90%AF%E5%8A%A8vm/"/>
    <id>https://rma-shuyu.github.io/2023/03/06/DPDK-OVS-QEMU%E5%89%8D%E5%90%8E%E7%AB%AF%E5%90%AF%E5%8A%A8vm/</id>
    <published>2023-03-06T08:01:04.000Z</published>
    <updated>2024-06-22T07:34:15.316Z</updated>
    
    <content type="html"><![CDATA[<h2 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h2><ul><li><p>DPDK 22.11.1</p></li><li><p>A DPDK supported NIC</p></li></ul><p>Only required when physical ports are in use</p><span id="more"></span><ul><li>A suitable kernel</li></ul><p>On Linux Distros running kernel version &gt;= 3.0, only IOMMU needs to enabled via the grub cmdline, assuming you are using VFIO. For older kernels, ensure the kernel is built with UIO, HUGETLBFS, PROC_PAGE_MONITOR, HPET, HPET_MMAP support. If these are not present, it will be necessary to upgrade your kernel or build a custom kernel with these flags enabled.</p><h2 id="dpdk环境设置"><a href="#dpdk环境设置" class="headerlink" title="dpdk环境设置"></a>dpdk环境设置</h2><p>检查VT-d功能是否打开</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /proc/cmdline | grep iommu=pt</span><br><span class="line"><span class="built_in">cat</span> /proc/cmdline | grep intel_iommu=on</span><br></pre></td></tr></table></figure><p>如果没有开启，那么需要修改/etc/default/grub中GRUB_CMDLINE_LINUX_DEFAULT，重新创建引导grub</p><p>设置大页，加载vfio，绑定物理网卡到vfio</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">huge_set --setup 4g</span><br><span class="line">modprobe vfio-pci</span><br><span class="line">dpdk_bind -b vfio-pci ens33f1</span><br></pre></td></tr></table></figure><p>这里的<code>huge_set</code>、<code>dpdk_bind</code>对应dpdk bin中的<code>dpdk-devbind.py</code>、<code>dpdk-hugepages.py</code></p><h2 id="ovs启动"><a href="#ovs启动" class="headerlink" title="ovs启动"></a>ovs启动</h2><ul><li>创建ovs相关目录</li><li>第一次需要创建ovsdb</li><li>启动ovsdb-server</li><li>检查db.sock是否正常创建</li><li>设置other_config为dpdk模式</li><li>启动ovs-vswitchd</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /mnt/store/ovs/images/bin</span><br><span class="line"></span><br><span class="line">dpdk_socket_mem=<span class="string">&quot;1024,0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> -p /var/run/openvswitch</span><br><span class="line"><span class="built_in">mkdir</span> -p /etc/openvswitch</span><br><span class="line"><span class="built_in">mkdir</span> -p /var/log/openvswitch</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ! <span class="built_in">test</span> -f /etc/openvswitch/conf.db; <span class="keyword">then</span></span><br><span class="line">./ovsdb-tool create /etc/openvswitch/conf.db /mnt/store/ovs/images/db/vswitch.ovsschema</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">./ovsdb-server /etc/openvswitch/conf.db -vconsole:emer -vsyslog:err -vfile:info --remote=punix:/var/run/openvswitch/db.sock --private-key=db:Open_vSwitch,SSL,private_key --certificate=db:Open_vSwitch,SSL,certificate --bootstrap-ca-cert=db:Open_vSwitch,SSL,ca_cert --no-chdir --log-file=/var/log/openvswitch/ovsdb-server.log --pidfile=/var/run/openvswitch/ovsdb-server.pid --detach --monitor</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [ ! -S /var/run/openvswitch/db.sock ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">sleep</span> 1</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">./ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-init=<span class="literal">true</span></span><br><span class="line">./ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-extra=<span class="string">&quot;--iova-mode=pa&quot;</span></span><br><span class="line">./ovs-vsctl --no-wait <span class="built_in">set</span> Open_vSwitch . other_config:dpdk-socket-mem=<span class="variable">$dpdk_socket_mem</span></span><br><span class="line"></span><br><span class="line">./ovs-vswitchd unix:/var/run/openvswitch/db.sock -vconsole:emer -vsyslog:err -vfile:info --mlockall --no-chdir --log-file=/var/log/openvswitch/ovs-vswitchd.log --pidfile=/var/run/openvswitch/ovs-vswitchd.pid --detach --monitor</span><br></pre></td></tr></table></figure><h2 id="ovs停止运行"><a href="#ovs停止运行" class="headerlink" title="ovs停止运行"></a>ovs停止运行</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ovs-appctl -t ovs-vswitchd <span class="built_in">exit</span></span><br><span class="line">ovs-appctl -t ovsdb-server <span class="built_in">exit</span></span><br></pre></td></tr></table></figure><h2 id="ovs创建port"><a href="#ovs创建port" class="headerlink" title="ovs创建port"></a>ovs创建port</h2><ul><li>创建网桥</li><li>物理端口绑定网桥</li><li>前后端通信端口绑定网桥</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">/mnt/store/ovs/images/bin/ovs-vsctl --may-exist add-br br0 -- <span class="built_in">set</span> bridge br0 datapath_type=netdev</span><br><span class="line"></span><br><span class="line"><span class="comment"># dpdk-devargs后面跟的是dpdk绑定网卡的pci bdf号</span></span><br><span class="line">/mnt/store/ovs/images/bin/ovs-vsctl --may-exist add-port br0 phy0 -- <span class="built_in">set</span> Interface phy0 <span class="built_in">type</span>=dpdk options:dpdk-devargs=0000:24:00.1</span><br><span class="line"></span><br><span class="line">/mnt/store/ovs/images/bin/ovs-vsctl --may-exist add-port br0 vhost-user-1 -- <span class="built_in">set</span> Interface vhost-user-1 <span class="built_in">type</span>=dpdkvhostuserclient options:vhost-server-path=<span class="string">&quot;/tmp/sock0&quot;</span></span><br></pre></td></tr></table></figure><ul><li>ovs-vsctl show查看运行结果</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># /mnt/store/ovs/images/bin/ovs-vsctl show</span></span><br><span class="line">90ce12f9-3e63-4fff-b615-ae7e864858db</span><br><span class="line">    Bridge br0</span><br><span class="line">        datapath_type: netdev</span><br><span class="line">        Port br0</span><br><span class="line">            Interface br0</span><br><span class="line">                <span class="built_in">type</span>: internal</span><br><span class="line">        Port vhost-user-1</span><br><span class="line">            Interface vhost-user-1</span><br><span class="line">                <span class="built_in">type</span>: dpdkvhostuserclient</span><br><span class="line">                options: &#123;vhost-server-path=<span class="string">&quot;/tmp/sock0&quot;</span>&#125;</span><br><span class="line">        Port phy0</span><br><span class="line">            Interface phy0</span><br><span class="line">                <span class="built_in">type</span>: dpdk</span><br><span class="line">                options: &#123;dpdk-devargs=<span class="string">&quot;0000:24:00.1&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="qemu启动"><a href="#qemu启动" class="headerlink" title="qemu启动"></a>qemu启动</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">ulimit</span> -l unlimited</span><br><span class="line">/root/pc-bios/qemu-system-x86_64  \</span><br><span class="line">-enable-kvm -m 2048 -cpu host \</span><br><span class="line">-hda /mnt/store/vm0-centos8.4-8g-ext4-host-dmar.img \</span><br><span class="line">-object memory-backend-file,<span class="built_in">id</span>=mem,size=2048M,mem-path=/dev/hugepages,share=on \</span><br><span class="line">-mem-prealloc \</span><br><span class="line">-numa node,memdev=mem \</span><br><span class="line">-chardev socket,<span class="built_in">id</span>=char0,path=/tmp/sock0,server=on \</span><br><span class="line">-netdev <span class="built_in">type</span>=vhost-user,<span class="built_in">id</span>=vdpa,chardev=char0,queues=4 \</span><br><span class="line">-device virtio-net-pci,mq=on,rx_queue_size=512,tx_queue_size=512,netdev=vdpa,mac=00:aa:bb:cc:<span class="built_in">dd</span>:ee,page-per-vq=on,disable-modern=on,disable-legacy=off \</span><br><span class="line">-serial telnet:127.1:4321,server,nowait \</span><br><span class="line">-monitor stdio \</span><br><span class="line">-D ./qemu-vm0.<span class="built_in">log</span> \</span><br><span class="line">-vnc :90 -L /root/pc-bios</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ping包测试"><a href="#ping包测试" class="headerlink" title="ping包测试"></a>ping包测试</h2><p>host上网桥配置ip，端口up</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig br0 192.188.1.3/24 up</span><br></pre></td></tr></table></figure><p>geust上net口配置同网段ip，端口up</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig ens3 192.188.1.2/24 up</span><br></pre></td></tr></table></figure><p>vm ping host<br><img src="212553173cc3f955da5935e31ed69460df0ad4632296146b4ae845f52fe8edde.png" alt="图 1">  </p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;先决条件&quot;&gt;&lt;a href=&quot;#先决条件&quot; class=&quot;headerlink&quot; title=&quot;先决条件&quot;&gt;&lt;/a&gt;先决条件&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;DPDK 22.11.1&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A DPDK supported NIC&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Only required when physical ports are in use&lt;/p&gt;</summary>
    
    
    
    <category term="虚拟化" scheme="https://rma-shuyu.github.io/categories/%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="DPDK" scheme="https://rma-shuyu.github.io/tags/DPDK/"/>
    
    <category term="OVS" scheme="https://rma-shuyu.github.io/tags/OVS/"/>
    
    <category term="QEMU" scheme="https://rma-shuyu.github.io/tags/QEMU/"/>
    
  </entry>
  
  <entry>
    <title>Python + Selenium</title>
    <link href="https://rma-shuyu.github.io/2023/02/16/Python-Selenium/"/>
    <id>https://rma-shuyu.github.io/2023/02/16/Python-Selenium/</id>
    <published>2023-02-16T12:17:45.000Z</published>
    <updated>2024-06-22T07:34:15.326Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Selenium-简介"><a href="#Selenium-简介" class="headerlink" title="Selenium 简介"></a>Selenium 简介</h1><blockquote><p>Selenium 是一个用于 Web 应用程序测试的工具。Selenium 测试直接运行在浏览器中，就像真正的用户在操作一样。支持的浏览器包括Mozilla Firefox，Safari，Chrome，Opera，Edge 等</p></blockquote><span id="more"></span><h1 id="Selenium-优势"><a href="#Selenium-优势" class="headerlink" title="Selenium 优势"></a>Selenium 优势</h1><p>1、免费开源</p><p>2、小巧，对于不同的语言而言，只是一个包的大小</p><p>3、支持多语言，python，java 等</p><p>4、支持多平台，多浏览器</p><h1 id="Selenium-原理"><a href="#Selenium-原理" class="headerlink" title="Selenium 原理"></a>Selenium 原理</h1><p><img src="https://tech.uupt.com/wp-content/uploads/2022/10/image-1024x551.png"></p><p>上图所示Selenium Client Library就是我们平时使用的编码语言，包括 java、python、C#等。可以看到这些语言并没有直接与 Browser Drivers 进行通信，而是通过了 JSON WireProtocol，这就是 webdriver 协议。</p><p>简单的说他定义了一套接口规范，以我们最熟悉的点击操作为例，他对应的接口协议是：</p><p>POST /session/{session id}/element/{element id}/click</p><p>这样以来，无论我们编码使用 python 代码来执行点击操作：</p><p>driver.find_element_by_id(“”).click()</p><p>还是以 java 代码执行点击操作：</p><p>driver.findElement(By.id(“”)).click();</p><p>都会通过 selenium 客户端的程序将 click 操作转化成对应的 webdriver 协议。这样对于 Browser Drivers 来说只需要解析具体协议，而无需关注客户端使用的是哪种代码了，这就是 selenium 支持多种语言的原理。</p><p>在 Browser Drivers 中可以看到各个浏览器的 driver，这里我们以 chromedriver 为例进行讲解。在代码中直接 new ChromeDriver() 将会启动一个 ChromeDriver 进程，ChromeDriver 是一个独立的服务，它是 google 为网站开发人员提供的自动化测试接口，它是 selenium 和 chrome 浏览器进行通信的桥梁。chromeDriver 解析 webdriver 协议，然后根据解析结果，调用与之对应的 Remote Debugging 协议来操控 chrome 浏览器，它可以和浏览器内核进行交互进而操控浏览器</p><h1 id="浏览器驱动"><a href="#浏览器驱动" class="headerlink" title="浏览器驱动"></a>浏览器驱动</h1><p>当 selenium 升级到 3.0 之后，对不同的浏览器驱动进行了规范。如果想使用 selenium 驱动不同的浏览器，必须单独下载并设置不同的浏览器驱动。</p><p>各浏览器驱动下载地址：</p><p>Firefox 浏览器驱动：<a href="https://github.com/mozilla/geckodriver/releases">geckodriver</a></p><p>Chrome 浏览器驱动：<a href="https://sites.google.com/a/chromium.org/chromedriver/home">chromedriver</a> , <a href="https://npm.taobao.org/mirrors/chromedriver">taobao</a>镜像</p><p>Edge 浏览器驱动：<a href="https://developer.microsoft.com/en-us/microsoft-edge/tools/webdriver">MicrosoftWebDriver</a></p><p>Opera 浏览器驱动：<a href="https://github.com/operasoftware/operachromiumdriver/releases">operadriver</a></p><h1 id="python-安装Selenium"><a href="#python-安装Selenium" class="headerlink" title="python 安装Selenium"></a>python 安装Selenium</h1><p>通过命令安装：pip install selenium</p><p>注：如果电脑上既有 python2，又有 python3，在执行 pip 命令安装时，要注意区分</p><h1 id="设置浏览器驱动"><a href="#设置浏览器驱动" class="headerlink" title="设置浏览器驱动"></a>设置浏览器驱动</h1><p>1、设置浏览器的地址非常简单。 我们可以手动创建一个存放浏览器驱动的目录，如： C:\driver ,将下载的浏览器驱动文件放到该目录下，然后将此目录路径放在环境变量 Path 下</p><p>2、python 验证不同的浏览器驱动是否正常使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line"> </span><br><span class="line">driver = webdriver.Firefox()   # Firefox浏览器</span><br><span class="line"></span><br><span class="line">driver = webdriver.Chrome()    # Chrome浏览器</span><br><span class="line"> </span><br><span class="line">driver = webdriver.Edge()      # Edge浏览器</span><br><span class="line"> </span><br><span class="line">driver = webdriver.Opera()     # Opera浏览器</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>3、测试是否正常打开浏览器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line"> </span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(&#x27;https://www.baidu.com&#x27;) # 打开百度</span><br><span class="line"> </span><br><span class="line">print(driver.title) # 获取网页title</span><br><span class="line"> </span><br><span class="line">driver.quit() # 关闭浏览器</span><br></pre></td></tr></table></figure><h1 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能"></a>常用功能</h1><h2 id="元素定位"><a href="#元素定位" class="headerlink" title="元素定位"></a>元素定位</h2><p>常用元素定位为 8 种，分别为：</p><p>通过 id 定位：find_element_by_id()</p><p>通过 id 定位一组元素：find_elements_by_id()</p><p>通过 name 定位：find_element_by_name()</p><p>通过 name 定位一组元素：find_elements_by_name()</p><p>通过 class name 定位：find_element_by_class_name()</p><p>通过 class name 定位一组元素：find_elements_by_class_name()</p><p>通过 tag name 定位：find_element_by_tag_name()</p><p>通过 tag name 定位一组元素：find_elements_by_tag_name()</p><p>通过 link text 定位：find_element_by_link_text()</p><p>通过 link text 定位一组元素：find_elements_by_link_text()</p><p>通过部分 link text 定位：find_element_by_partial_link_text()</p><p>通过部分 link text 定位一组元素：find_elements_by_partial_link_text()</p><p>通过 xpath 定位：find_element_by_xpath()</p><p>通过 xpath 定位一组元素：find_elements_by_xpath()</p><p>通过 css 定位：find_element_by_css_selector()</p><p>通过 css 定位一组元素：find_elements_by_css_selector()</p><p>注意：如果定位一组元素，则在 element 后面加一个 s</p><h2 id="控制浏览器"><a href="#控制浏览器" class="headerlink" title="控制浏览器"></a>控制浏览器</h2><ul><li>  控制浏览器大小</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line"></span><br><span class="line">driver = webdriver.Firefox()</span><br><span class="line">driver.get(&quot;http://www.baidu.com&quot;)</span><br><span class="line"> </span><br><span class="line"># 参数数字为像素点_</span><br><span class="line">print(&quot;设置浏览器宽500、高500显示&quot;)</span><br><span class="line">driver.set_window_size(500, 500)</span><br><span class="line">driver.quit()</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>  控制浏览器前进后退</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line"> </span><br><span class="line">driver = webdriver.Firefox()</span><br><span class="line"> </span><br><span class="line">#访问百度首页</span><br><span class="line">first_url= &#x27;http://www.baidu.com&#x27;</span><br><span class="line">print(&quot;access %s&quot; %(first_url))</span><br><span class="line">driver.get(first_url)</span><br><span class="line"> </span><br><span class="line">#访问新闻页面</span><br><span class="line">second_url=&#x27;http://news.baidu.com&#x27;</span><br><span class="line">print(&quot;access %s&quot; %(second_url))</span><br><span class="line">driver.get(second_url)</span><br><span class="line"> </span><br><span class="line">#返回（后退）到百度首页</span><br><span class="line">print(&quot;back to  %s &quot;%(first_url))</span><br><span class="line">driver.back()</span><br><span class="line"> </span><br><span class="line">#前进到新闻页</span><br><span class="line">print(&quot;forward to  %s&quot;%(second_url))</span><br><span class="line">driver.forward()</span><br><span class="line"> </span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure><h2 id="WebDriver-常用方法"><a href="#WebDriver-常用方法" class="headerlink" title="WebDriver 常用方法"></a>WebDriver 常用方法</h2><ul><li>  clear()： 清除文本</li><li>  send_keys (value)： 模拟按键输入</li><li>  click()： 单击元素</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line"> </span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(&quot;https://www.baidu.com&quot;)</span><br><span class="line">driver.find_element_by_id(&quot;kw&quot;).clear()</span><br><span class="line">driver.find_element_by_id(&quot;kw&quot;).send_keys(&quot;selenium&quot;)</span><br><span class="line">driver.find_element_by_id(&quot;su&quot;).click()</span><br><span class="line">driver.quit()</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>  submit()：用于提交表单</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line"> </span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(&quot;https://www.baidu.com&quot;)</span><br><span class="line"> </span><br><span class="line">search_text = driver.find_element_by_id(&#x27;kw&#x27;)</span><br><span class="line">search_text.send_keys(&#x27;selenium&#x27;)</span><br><span class="line">search_text.submit()</span><br><span class="line"> </span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure><h2 id="设置元素等待"><a href="#设置元素等待" class="headerlink" title="设置元素等待"></a>设置元素等待</h2><p>WebDriver 提供了两种类型的等待：显式等待和隐式等待</p><p>显式等待使 WebdDriver 等待某个条件成立时继续执行，否则在达到最大时长时抛出超时异常（TimeoutException）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">from selenium.webdriver.common.by import By</span><br><span class="line">from selenium.webdriver.support.ui import WebDriverWait</span><br><span class="line">from selenium.webdriver.support import expected_conditions as EC</span><br><span class="line"> </span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(&quot;http://www.baidu.com&quot;)</span><br><span class="line"> </span><br><span class="line">element = WebDriverWait(driver, 5, 0.5).until(EC.presence_of_element_located((By.ID, &quot;kw&quot;)))</span><br><span class="line">element.send_keys(&#x27;selenium&#x27;)</span><br><span class="line">driver.quit()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>隐式等待并不影响脚本的执行速度。其次，它并不针对页面上的某一元素进行等待。当脚本执行到某个元素定位时，如果元素可以定位，则继续执行；如果元素定位不到，则它将以轮询的方式不断地判断元素是否被定位到。假设在第 5 秒定位到了元素则继续执行，若直到超出设置时长（10 秒）还没有定位到元素，则抛出异常。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">from selenium import webdriver</span><br><span class="line">from selenium.common.exceptions import NoSuchElementException</span><br><span class="line">from time import ctime</span><br><span class="line"> </span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line"> </span><br><span class="line"># 设置隐式等待为10秒</span><br><span class="line">driver.implicitly_wait(10)</span><br><span class="line">driver.get(&quot;http://www.baidu.com&quot;)</span><br><span class="line"> </span><br><span class="line">try:</span><br><span class="line">    print(ctime())</span><br><span class="line">    driver.find_element_by_id(&quot;kww&quot;).send_keys(&#x27;selenium&#x27;)</span><br><span class="line">except NoSuchElementException as e:</span><br><span class="line">    print(e)</span><br><span class="line">finally:</span><br><span class="line">    print(ctime())</span><br><span class="line">    driver.quit()</span><br></pre></td></tr></table></figure><h1 id="Python-Selenium-实现识别图片验证码登录"><a href="#Python-Selenium-实现识别图片验证码登录" class="headerlink" title="Python+Selenium 实现识别图片验证码登录"></a>Python+Selenium 实现识别图片验证码登录</h1><p>1、打开网站设置要访问的网站地址，并把窗口最大化，这是能保证在电脑上每次截取的图片都是相同的大小</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">url = &quot;https://www.xxxxx.com&quot;</span><br><span class="line"># 1、打开浏览器，最大化浏览器</span><br><span class="line">driver = webdriver.Chrome()</span><br><span class="line">driver.get(url)</span><br><span class="line">#driver.implicitly_wait(10)#隐式等待10s</span><br><span class="line">driver.maximize_window()  #最大化窗口</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2、截取带图片验证码的网站内容，并保存在本地</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">driver.save_screenshot(&quot;H://test/01.png&quot;)#截取屏幕内容，保存到本地</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也可以通过 id 或者 Xpath 的方式定位到图片验证码的方式直接获取图片验证码，保存在本地</p><p><img src="https://tech.uupt.com/wp-content/uploads/2022/10/image-1-1024x456.png"></p><p>3、使用第三方库对图片进行识别（pytesseract 和ddddocr 都可以识别图片验证码）</p><p>a、使用pytesseract 识别图片验证码</p><p>定位在图片中验证码所在的位置，四个参数分别代表图片验证码的左，上，右，下坐标，可以通过 windows 自带的画图工具获取</p><p>当使用通过定位获取到验证码的方式时，可以跳过手动获取图片验证码的流程，直接跳转到图像处理步骤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ran = Image.open(&quot;H://test/01.png&quot;)   #打开截图，获取验证码位置，截取保存验证码</span><br><span class="line">box = (564, 395, 643, 423)  # 获取验证码位置,代表（左，上，右，下）</span><br><span class="line">ran.crop(box).save(&quot;H://test/02.png&quot;)   #把获取的验证码保存</span><br><span class="line">#获取验证码图片，读取验证码</span><br><span class="line">imageCode = Image.open(&quot;H://test/02.png&quot;)  #打开保存的验证码图片</span><br><span class="line">#imageCode.load()</span><br><span class="line"># 图像增强，二值化</span><br><span class="line">sharp_img = ImageEnhance.Contrast(imageCode).enhance(2.0)</span><br><span class="line">sharp_img.save(&quot;H://test/03.png&quot;) #保存图像增强，二值化之后的验证码图片</span><br><span class="line">sharp_img.load()  # 对比度增强</span><br><span class="line">time.sleep(2)</span><br><span class="line">print(sharp_img) #打印图片的信息</span><br><span class="line">code = pytesseract.image_to_string(sharp_img).strip() #读取验证码</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>b、使用 ddddocr 识别图片验证码</p><p>先将图片保存在本地，然后可以直接通过二进制读取图片，进行识别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 创建对象</span><br><span class="line">ocr = ddddocr.DdddOcr() </span><br><span class="line"># 使用二进制的方式读取图片</span><br><span class="line">with open(&#x27;./images/code1.png&#x27;, &#x27;rb&#x27;) as f:</span><br><span class="line">    img_tytes = f.read()</span><br><span class="line">    # 调用识别方法_</span><br><span class="line">    res = ocr.classification(img_tytes)</span><br><span class="line">    print(f&#x27;验证码为：&#123;res&#125;&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>4、定位账号密码等输入框，并输入相关内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name=driver.find_element_by_id(&quot;username&quot;)  #定位账号输入框</span><br><span class="line">password=driver.find_element_by_id(&quot;password_1&quot;)  #定位密码输入框</span><br><span class="line">code1=driver.find_element_by_id(&quot;user_ck&quot;)  #定位验证码输入框</span><br><span class="line">name.send_keys(&#x27;username&#x27;)   #给定位账号的输入框中输入值</span><br><span class="line">password.send_keys(&#x27;password&#x27;)   #给定位密码的输入框中输入值</span><br><span class="line">code1.send_keys(code)   #给定位验证码的输入框中输入读取到的验证码</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>5、定位并点击按钮</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">driver.find_element_by_name(&quot;yt0&quot;).click() #点击登录</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>6、最后关闭页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#关闭浏览器</span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Selenium-简介&quot;&gt;&lt;a href=&quot;#Selenium-简介&quot; class=&quot;headerlink&quot; title=&quot;Selenium 简介&quot;&gt;&lt;/a&gt;Selenium 简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;Selenium 是一个用于 Web 应用程序测试的工具。Selenium 测试直接运行在浏览器中，就像真正的用户在操作一样。支持的浏览器包括Mozilla Firefox，Safari，Chrome，Opera，Edge 等&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Python" scheme="https://rma-shuyu.github.io/categories/Python/"/>
    
    
    <category term="Selenium" scheme="https://rma-shuyu.github.io/tags/Selenium/"/>
    
  </entry>
  
</feed>
